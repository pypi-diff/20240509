# Comparing `tmp/gradio_model4dgs-0.0.2.tar.gz` & `tmp/gradio_model4dgs-0.0.3.tar.gz`

## Comparing `gradio_model4dgs-0.0.2.tar` & `gradio_model4dgs-0.0.3.tar`

### file list

```diff
@@ -1,35 +1,35 @@
--rw-r--r--   0        0        0       59 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/__init__.py
--rw-r--r--   0        0        0     3282 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/model4dgs.py
--rw-r--r--   0        0        0    23649 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/model4dgs.pyi
--rw-r--r--   0        0        0   790790 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/component/index.js
--rw-r--r--   0        0        0    12698 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/component/style.css
--rw-r--r--   0        0        0     1549 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/example/index.js
--rw-r--r--   0        0        0       61 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/example/style.css
--rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/__init__.py
--rw-r--r--   0        0        0      319 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/app.py
--rw-r--r--   0        0        0     2543 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/css.css
--rw-r--r--   0        0        0     5977 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/space.py
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_0.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_1.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_10.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_11.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_12.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_13.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_2.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_3.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_4.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_5.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_6.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_7.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_8.ply
--rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_9.ply
--rw-r--r--   0        0        0    94426 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/demo/assets/tiger_rgba.png
--rw-r--r--   0        0        0      306 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/frontend/Example.svelte
--rw-r--r--   0        0        0     1995 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/frontend/Index.svelte
--rw-r--r--   0        0        0    37166 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/frontend/package-lock.json
--rw-r--r--   0        0        0      546 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/frontend/package.json
--rw-r--r--   0        0        0     3130 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/frontend/shared/Model4DGS.svelte
--rw-r--r--   0        0        0       79 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/.gitignore
--rw-r--r--   0        0        0     4998 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/README.md
--rw-r--r--   0        0        0     1445 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/pyproject.toml
--rw-r--r--   0        0        0     6098 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.2/PKG-INFO
+-rw-r--r--   0        0        0       59 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/__init__.py
+-rw-r--r--   0        0        0     3339 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/model4dgs.py
+-rw-r--r--   0        0        0    23774 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/model4dgs.pyi
+-rw-r--r--   0        0        0   904166 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/component/index.js
+-rw-r--r--   0        0        0    12674 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/component/style.css
+-rw-r--r--   0        0        0     1549 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/example/index.js
+-rw-r--r--   0        0        0       61 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/example/style.css
+-rw-r--r--   0        0        0        0 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/__init__.py
+-rw-r--r--   0        0        0      568 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/app.py
+-rw-r--r--   0        0        0     2543 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/css.css
+-rw-r--r--   0        0        0     6286 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/space.py
+-rw-r--r--   0        0        0    94426 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/tiger_rgba.png
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_0.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_1.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_10.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_11.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_12.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_13.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_2.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_3.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_4.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_5.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_6.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_7.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_8.ply
+-rw-r--r--   0        0        0   715299 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_9.ply
+-rw-r--r--   0        0        0      306 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/frontend/Example.svelte
+-rw-r--r--   0        0        0     1945 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/frontend/Index.svelte
+-rw-r--r--   0        0        0   153463 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/frontend/package-lock.json
+-rw-r--r--   0        0        0      605 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/frontend/package.json
+-rw-r--r--   0        0        0     3065 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/frontend/shared/Model4DGS.svelte
+-rw-r--r--   0        0        0       79 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/.gitignore
+-rw-r--r--   0        0        0     5449 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/README.md
+-rw-r--r--   0        0        0     1336 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/pyproject.toml
+-rw-r--r--   0        0        0     6554 2020-02-02 00:00:00.000000 gradio_model4dgs-0.0.3/PKG-INFO
```

### Comparing `gradio_model4dgs-0.0.2/backend/gradio_model4dgs/model4dgs.py` & `gradio_model4dgs-0.0.3/backend/gradio_model4dgs/model4dgs.py`

 * *Files 5% similar despite different names*

```diff
@@ -62,23 +62,23 @@
             visible=visible,
             elem_id=elem_id,
             elem_classes=elem_classes,
             render=render,
             value=value,
         )
 
-    def preprocess(self, payload: List[str] | None) -> List[str] | None:
-        return payload
+    def preprocess(self, payload: Model4DGSData | None) -> List[str] | None:
+        return [file.path for file in payload.files]
 
-    def postprocess(self, value: List[str] | str | None) -> List[FileData] | None:
+    def postprocess(self, value: List[str] | str | None) -> Model4DGSData | None:
         if value is None:
             return value
         if isinstance(value, list):
-            return [FileData(path=file) for file in value]
-        return FileData(path=value)
+            return Model4DGSData(files=[FileData(path=file) for file in value])
+        return Model4DGSData(files=[])
 
     #example display name
     def as_example(self, input_data: List[str] | str | None) -> str:
         return Path(input_data).name if input_data else ""
 
     def example_inputs(self):
         return [
```

### Comparing `gradio_model4dgs-0.0.2/backend/gradio_model4dgs/model4dgs.pyi` & `gradio_model4dgs-0.0.3/backend/gradio_model4dgs/model4dgs.pyi`

 * *Files 1% similar despite different names*

```diff
@@ -63,23 +63,23 @@
             visible=visible,
             elem_id=elem_id,
             elem_classes=elem_classes,
             render=render,
             value=value,
         )
 
-    def preprocess(self, payload: List[str] | None) -> List[str] | None:
-        return payload
+    def preprocess(self, payload: Model4DGSData | None) -> List[str] | None:
+        return [file.path for file in payload.files]
 
-    def postprocess(self, value: List[str] | str | None) -> List[FileData] | None:
+    def postprocess(self, value: List[str] | str | None) -> Model4DGSData | None:
         if value is None:
             return value
         if isinstance(value, list):
-            return [FileData(path=file) for file in value]
-        return FileData(path=value)
+            return Model4DGSData(files=[FileData(path=file) for file in value])
+        return Model4DGSData(files=[])
 
     #example display name
     def as_example(self, input_data: List[str] | str | None) -> str:
         return Path(input_data).name if input_data else ""
 
     def example_inputs(self):
         return [
@@ -130,15 +130,15 @@
             queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
             batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
             max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
             preprocess: If False, will not run preprocessing of component data before running 'fn' (e.g. leaving it as a base64 string if this method is called with the `Image` component).
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
-            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` event) would allow a second submission after the pending event is complete.
+            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
             show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
     
@@ -172,15 +172,15 @@
             queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
             batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
             max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
             preprocess: If False, will not run preprocessing of component data before running 'fn' (e.g. leaving it as a base64 string if this method is called with the `Image` component).
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
-            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` event) would allow a second submission after the pending event is complete.
+            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
             show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
     
@@ -214,15 +214,15 @@
             queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
             batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
             max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
             preprocess: If False, will not run preprocessing of component data before running 'fn' (e.g. leaving it as a base64 string if this method is called with the `Image` component).
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
-            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` event) would allow a second submission after the pending event is complete.
+            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
             show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
     
@@ -256,14 +256,14 @@
             queue: If True, will place the request on the queue, if the queue has been enabled. If False, will not put this event on the queue, even if the queue has been enabled. If None, will use the queue setting of the gradio app.
             batch: If True, then the function should process a batch of inputs, meaning that it should accept a list of input values for each parameter. The lists should be of equal length (and be up to length `max_batch_size`). The function is then *required* to return a tuple of lists (even if there is only 1 output component), with each list in the tuple corresponding to one output component.
             max_batch_size: Maximum number of inputs to batch together if this is called from the queue (only relevant if batch=True)
             preprocess: If False, will not run preprocessing of component data before running 'fn' (e.g. leaving it as a base64 string if this method is called with the `Image` component).
             postprocess: If False, will not run postprocessing of component data before returning 'fn' output to the browser.
             cancels: A list of other events to cancel when this listener is triggered. For example, setting cancels=[click_event] will cancel the click_event, where click_event is the return value of another components .click method. Functions that have not yet run (or generators that are iterating) will be cancelled, but functions that are currently running will be allowed to finish.
             every: Run this event 'every' number of seconds while the client connection is open. Interpreted in seconds.
-            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` event) would allow a second submission after the pending event is complete.
+            trigger_mode: If "once" (default for all events except `.change()`) would not allow any submissions while an event is pending. If set to "multiple", unlimited submissions are allowed while pending, and "always_last" (default for `.change()` and `.key_up()` events) would allow a second submission after the pending event is complete.
             js: Optional frontend js method to run before running 'fn'. Input arguments for js method are values of 'inputs' and 'outputs', return should be a list of values for output components.
             concurrency_limit: If set, this is the maximum number of this event that can be running simultaneously. Can be set to None to mean no concurrency_limit (any number of this event can be running simultaneously). Set to "default" to use the default concurrency limit (defined by the `default_concurrency_limit` parameter in `Blocks.queue()`, which itself is 1 by default).
             concurrency_id: If set, this is the id of the concurrency group. Events with the same concurrency_id will be limited by the lowest set concurrency_limit.
             show_api: whether to show this event in the "view API" page of the Gradio app, or in the ".view_api()" method of the Gradio clients. Unlike setting api_name to False, setting show_api to False will still allow downstream apps to use this event. If fn is None, show_api will automatically be set to False.
         """
         ...
```

### Comparing `gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/component/index.js` & `gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/component/index.js`

 * *Files 8% similar despite different names*

#### js-beautify {}

```diff
@@ -1,152 +1,200 @@
-var bc = Object.defineProperty;
-var Tc = (i, e, t) => e in i ? bc(i, e, {
+var vu = Object.defineProperty;
+var xu = (s, e, t) => e in s ? vu(s, e, {
     enumerable: !0,
     configurable: !0,
     writable: !0,
     value: t
-}) : i[e] = t;
-var Pe = (i, e, t) => (Tc(i, typeof e != "symbol" ? e + "" : e, t), t);
+}) : s[e] = t;
+var le = (s, e, t) => (xu(s, typeof e != "symbol" ? e + "" : e, t), t);
 new Intl.Collator(0, {
     numeric: 1
 }).compare;
+
+function bc(s, e, t) {
+    if (s == null)
+        return null;
+    if (Array.isArray(s)) {
+        const n = [];
+        for (const i of s)
+            i == null ? n.push(null) : n.push(bc(i, e, t));
+        return n;
+    }
+    return s.is_stream ? t == null ? new Gr({
+        ...s,
+        url: e + "/stream/" + s.path
+    }) : new Gr({
+        ...s,
+        url: "/proxy=" + t + "stream/" + s.path
+    }) : new Gr({
+        ...s,
+        url: Mu(s.path, e, t)
+    });
+}
+
+function yu(s) {
+    try {
+        const e = new URL(s);
+        return e.protocol === "http:" || e.protocol === "https:";
+    } catch {
+        return !1;
+    }
+}
+
+function Mu(s, e, t) {
+    return s == null ? t ? `/proxy=${t}file=` : `${e}/file=` : yu(s) ? s : t ? `/proxy=${t}file=${s}` : `${e}/file=${s}`;
+}
+class Gr {
+    constructor({
+        path: e,
+        url: t,
+        orig_name: n,
+        size: i,
+        blob: r,
+        is_stream: o,
+        mime_type: a,
+        alt_text: l
+    }) {
+        this.path = e, this.url = t, this.orig_name = n, this.size = i, this.blob = t ? void 0 : r, this.is_stream = o, this.mime_type = a, this.alt_text = l;
+    }
+}
 const {
-    SvelteComponent: wc,
-    assign: Cc,
-    create_slot: Rc,
-    detach: Pc,
-    element: Lc,
-    get_all_dirty_from_scope: Dc,
-    get_slot_changes: Ic,
-    get_spread_update: Uc,
-    init: Fc,
-    insert: Nc,
-    safe_not_equal: Bc,
-    set_dynamic_element_data: Ro,
-    set_style: Dt,
-    toggle_class: Tn,
-    transition_in: Il,
-    transition_out: Ul,
-    update_slot_base: Oc
+    SvelteComponent: Eu,
+    assign: Au,
+    create_slot: Tu,
+    detach: bu,
+    element: Cu,
+    get_all_dirty_from_scope: wu,
+    get_slot_changes: Ru,
+    get_spread_update: Pu,
+    init: Du,
+    insert: Lu,
+    safe_not_equal: Fu,
+    set_dynamic_element_data: _o,
+    set_style: Gt,
+    toggle_class: kn,
+    transition_in: Cc,
+    transition_out: wc,
+    update_slot_base: Iu
 } = window.__gradio__svelte__internal;
 
-function zc(i) {
+function Uu(s) {
     let e, t, n;
-    const r = (
+    const i = (
             /*#slots*/
-            i[18].default
+            s[18].default
         ),
-        s = Rc(
-            r,
+        r = Tu(
             i,
+            s,
             /*$$scope*/
-            i[17],
+            s[17],
             null
         );
-    let a = [{
+    let o = [{
             "data-testid": (
                 /*test_id*/
-                i[7]
+                s[7]
             )
         }, {
             id: (
                 /*elem_id*/
-                i[2]
+                s[2]
             )
         }, {
             class: t = "block " + /*elem_classes*/
-                i[3].join(" ") + " svelte-1t38q2d"
+                s[3].join(" ") + " svelte-1t38q2d"
         }],
-        o = {};
-    for (let l = 0; l < a.length; l += 1)
-        o = Cc(o, a[l]);
+        a = {};
+    for (let l = 0; l < o.length; l += 1)
+        a = Au(a, o[l]);
     return {
         c() {
-            e = Lc(
+            e = Cu(
                 /*tag*/
-                i[14]
-            ), s && s.c(), Ro(
+                s[14]
+            ), r && r.c(), _o(
                 /*tag*/
-                i[14]
-            )(e, o), Tn(
+                s[14]
+            )(e, a), kn(
                 e,
                 "hidden",
                 /*visible*/
-                i[10] === !1
-            ), Tn(
+                s[10] === !1
+            ), kn(
                 e,
                 "padded",
                 /*padding*/
-                i[6]
-            ), Tn(
+                s[6]
+            ), kn(
                 e,
                 "border_focus",
                 /*border_mode*/
-                i[5] === "focus"
-            ), Tn(e, "hide-container", ! /*explicit_call*/
-                i[8] && ! /*container*/
-                i[9]), Dt(
+                s[5] === "focus"
+            ), kn(e, "hide-container", ! /*explicit_call*/
+                s[8] && ! /*container*/
+                s[9]), Gt(
                 e,
                 "height",
                 /*get_dimension*/
-                i[15](
+                s[15](
                     /*height*/
-                    i[0]
+                    s[0]
                 )
-            ), Dt(e, "width", typeof /*width*/ i[1] == "number" ? `calc(min(${/*width*/
-      i[1]}px, 100%))` : (
+            ), Gt(e, "width", typeof /*width*/ s[1] == "number" ? `calc(min(${/*width*/
+      s[1]}px, 100%))` : (
                 /*get_dimension*/
-                i[15](
+                s[15](
                     /*width*/
-                    i[1]
+                    s[1]
                 )
-            )), Dt(
+            )), Gt(
                 e,
                 "border-style",
                 /*variant*/
-                i[4]
-            ), Dt(
+                s[4]
+            ), Gt(
                 e,
                 "overflow",
                 /*allow_overflow*/
-                i[11] ? "visible" : "hidden"
-            ), Dt(
+                s[11] ? "visible" : "hidden"
+            ), Gt(
                 e,
                 "flex-grow",
                 /*scale*/
-                i[12]
-            ), Dt(e, "min-width", `calc(min(${/*min_width*/
-      i[13]}px, 100%))`), Dt(e, "border-width", "var(--block-border-width)");
+                s[12]
+            ), Gt(e, "min-width", `calc(min(${/*min_width*/
+      s[13]}px, 100%))`), Gt(e, "border-width", "var(--block-border-width)");
         },
         m(l, c) {
-            Nc(l, e, c), s && s.m(e, null), n = !0;
+            Lu(l, e, c), r && r.m(e, null), n = !0;
         },
         p(l, c) {
-            s && s.p && (!n || c & /*$$scope*/
-                    131072) && Oc(
-                    s,
+            r && r.p && (!n || c & /*$$scope*/
+                    131072) && Iu(
                     r,
+                    i,
                     l,
                     /*$$scope*/
                     l[17],
-                    n ? Ic(
-                        r,
+                    n ? Ru(
+                        i,
                         /*$$scope*/
                         l[17],
                         c,
                         null
-                    ) : Dc(
+                    ) : wu(
                         /*$$scope*/
                         l[17]
                     ),
                     null
-                ), Ro(
+                ), _o(
                     /*tag*/
                     l[14]
-                )(e, o = Uc(a, [
+                )(e, a = Pu(o, [
                     (!n || c & /*test_id*/
                         128) && {
                         "data-testid": (
                             /*test_id*/
                             l[7]
                         )
                     },
@@ -158,180 +206,180 @@
                         )
                     },
                     (!n || c & /*elem_classes*/
                         8 && t !== (t = "block " + /*elem_classes*/
                             l[3].join(" ") + " svelte-1t38q2d")) && {
                         class: t
                     }
-                ])), Tn(
+                ])), kn(
                     e,
                     "hidden",
                     /*visible*/
                     l[10] === !1
-                ), Tn(
+                ), kn(
                     e,
                     "padded",
                     /*padding*/
                     l[6]
-                ), Tn(
+                ), kn(
                     e,
                     "border_focus",
                     /*border_mode*/
                     l[5] === "focus"
-                ), Tn(e, "hide-container", ! /*explicit_call*/
+                ), kn(e, "hide-container", ! /*explicit_call*/
                     l[8] && ! /*container*/
                     l[9]), c & /*height*/
-                1 && Dt(
+                1 && Gt(
                     e,
                     "height",
                     /*get_dimension*/
                     l[15](
                         /*height*/
                         l[0]
                     )
                 ), c & /*width*/
-                2 && Dt(e, "width", typeof /*width*/ l[1] == "number" ? `calc(min(${/*width*/
+                2 && Gt(e, "width", typeof /*width*/ l[1] == "number" ? `calc(min(${/*width*/
       l[1]}px, 100%))` : (
                     /*get_dimension*/
                     l[15](
                         /*width*/
                         l[1]
                     )
                 )), c & /*variant*/
-                16 && Dt(
+                16 && Gt(
                     e,
                     "border-style",
                     /*variant*/
                     l[4]
                 ), c & /*allow_overflow*/
-                2048 && Dt(
+                2048 && Gt(
                     e,
                     "overflow",
                     /*allow_overflow*/
                     l[11] ? "visible" : "hidden"
                 ), c & /*scale*/
-                4096 && Dt(
+                4096 && Gt(
                     e,
                     "flex-grow",
                     /*scale*/
                     l[12]
                 ), c & /*min_width*/
-                8192 && Dt(e, "min-width", `calc(min(${/*min_width*/
+                8192 && Gt(e, "min-width", `calc(min(${/*min_width*/
       l[13]}px, 100%))`);
         },
         i(l) {
-            n || (Il(s, l), n = !0);
+            n || (Cc(r, l), n = !0);
         },
         o(l) {
-            Ul(s, l), n = !1;
+            wc(r, l), n = !1;
         },
         d(l) {
-            l && Pc(e), s && s.d(l);
+            l && bu(e), r && r.d(l);
         }
     };
 }
 
-function kc(i) {
+function Bu(s) {
     let e, t = (
         /*tag*/
-        i[14] && zc(i)
+        s[14] && Uu(s)
     );
     return {
         c() {
             t && t.c();
         },
-        m(n, r) {
-            t && t.m(n, r), e = !0;
+        m(n, i) {
+            t && t.m(n, i), e = !0;
         },
-        p(n, [r]) {
+        p(n, [i]) {
             /*tag*/
-            n[14] && t.p(n, r);
+            n[14] && t.p(n, i);
         },
         i(n) {
-            e || (Il(t, n), e = !0);
+            e || (Cc(t, n), e = !0);
         },
         o(n) {
-            Ul(t, n), e = !1;
+            wc(t, n), e = !1;
         },
         d(n) {
             t && t.d(n);
         }
     };
 }
 
-function Gc(i, e, t) {
+function Ou(s, e, t) {
     let {
         $$slots: n = {},
-        $$scope: r
+        $$scope: i
     } = e, {
-        height: s = void 0
+        height: r = void 0
     } = e, {
-        width: a = void 0
+        width: o = void 0
     } = e, {
-        elem_id: o = ""
+        elem_id: a = ""
     } = e, {
         elem_classes: l = []
     } = e, {
         variant: c = "solid"
     } = e, {
         border_mode: u = "base"
     } = e, {
-        padding: f = !0
+        padding: d = !0
     } = e, {
-        type: h = "normal"
+        type: f = "normal"
     } = e, {
-        test_id: p = void 0
+        test_id: h = void 0
     } = e, {
         explicit_call: g = !1
     } = e, {
-        container: v = !0
+        container: _ = !0
     } = e, {
         visible: m = !0
     } = e, {
-        allow_overflow: d = !0
+        allow_overflow: p = !0
     } = e, {
-        scale: M = null
+        scale: v = null
     } = e, {
-        min_width: _ = 0
-    } = e, A = h === "fieldset" ? "fieldset" : "div";
-    const R = (E) => {
+        min_width: S = 0
+    } = e, y = f === "fieldset" ? "fieldset" : "div";
+    const b = (E) => {
         if (E !== void 0) {
             if (typeof E == "number")
                 return E + "px";
             if (typeof E == "string")
                 return E;
         }
     };
-    return i.$$set = (E) => {
-        "height" in E && t(0, s = E.height), "width" in E && t(1, a = E.width), "elem_id" in E && t(2, o = E.elem_id), "elem_classes" in E && t(3, l = E.elem_classes), "variant" in E && t(4, c = E.variant), "border_mode" in E && t(5, u = E.border_mode), "padding" in E && t(6, f = E.padding), "type" in E && t(16, h = E.type), "test_id" in E && t(7, p = E.test_id), "explicit_call" in E && t(8, g = E.explicit_call), "container" in E && t(9, v = E.container), "visible" in E && t(10, m = E.visible), "allow_overflow" in E && t(11, d = E.allow_overflow), "scale" in E && t(12, M = E.scale), "min_width" in E && t(13, _ = E.min_width), "$$scope" in E && t(17, r = E.$$scope);
+    return s.$$set = (E) => {
+        "height" in E && t(0, r = E.height), "width" in E && t(1, o = E.width), "elem_id" in E && t(2, a = E.elem_id), "elem_classes" in E && t(3, l = E.elem_classes), "variant" in E && t(4, c = E.variant), "border_mode" in E && t(5, u = E.border_mode), "padding" in E && t(6, d = E.padding), "type" in E && t(16, f = E.type), "test_id" in E && t(7, h = E.test_id), "explicit_call" in E && t(8, g = E.explicit_call), "container" in E && t(9, _ = E.container), "visible" in E && t(10, m = E.visible), "allow_overflow" in E && t(11, p = E.allow_overflow), "scale" in E && t(12, v = E.scale), "min_width" in E && t(13, S = E.min_width), "$$scope" in E && t(17, i = E.$$scope);
     }, [
-        s,
-        a,
+        r,
         o,
+        a,
         l,
         c,
         u,
-        f,
-        p,
-        g,
-        v,
-        m,
         d,
-        M,
-        _,
-        A,
-        R,
         h,
-        r,
+        g,
+        _,
+        m,
+        p,
+        v,
+        S,
+        y,
+        b,
+        f,
+        i,
         n
     ];
 }
-class Hc extends wc {
+class Nu extends Eu {
     constructor(e) {
-        super(), Fc(this, e, Gc, kc, Bc, {
+        super(), Du(this, e, Ou, Bu, Fu, {
             height: 0,
             width: 1,
             elem_id: 2,
             elem_classes: 3,
             variant: 4,
             border_mode: 5,
             padding: 6,
@@ -343,339 +391,319 @@
             allow_overflow: 11,
             scale: 12,
             min_width: 13
         });
     }
 }
 const {
-    SvelteComponent: Vc,
-    append: ds,
-    attr: mr,
-    create_component: Wc,
-    destroy_component: Xc,
-    detach: qc,
-    element: Po,
-    init: Yc,
-    insert: jc,
-    mount_component: Kc,
-    safe_not_equal: Qc,
-    set_data: Zc,
-    space: Jc,
-    text: $c,
-    toggle_class: wn,
-    transition_in: eu,
-    transition_out: tu
+    SvelteComponent: ku,
+    append: Vr,
+    attr: Ns,
+    create_component: zu,
+    destroy_component: Hu,
+    detach: Gu,
+    element: So,
+    init: Vu,
+    insert: Wu,
+    mount_component: Xu,
+    safe_not_equal: qu,
+    set_data: Yu,
+    space: ju,
+    text: Ku,
+    toggle_class: zn,
+    transition_in: Zu,
+    transition_out: Qu
 } = window.__gradio__svelte__internal;
 
-function nu(i) {
-    let e, t, n, r, s, a;
+function Ju(s) {
+    let e, t, n, i, r, o;
     return n = new /*Icon*/
-    i[1]({}), {
+    s[1]({}), {
         c() {
-            e = Po("label"), t = Po("span"), Wc(n.$$.fragment), r = Jc(), s = $c(
+            e = So("label"), t = So("span"), zu(n.$$.fragment), i = ju(), r = Ku(
                 /*label*/
-                i[0]
-            ), mr(t, "class", "svelte-9gxdi0"), mr(e, "for", ""), mr(e, "data-testid", "block-label"), mr(e, "class", "svelte-9gxdi0"), wn(e, "hide", ! /*show_label*/
-                i[2]), wn(e, "sr-only", ! /*show_label*/
-                i[2]), wn(
+                s[0]
+            ), Ns(t, "class", "svelte-9gxdi0"), Ns(e, "for", ""), Ns(e, "data-testid", "block-label"), Ns(e, "class", "svelte-9gxdi0"), zn(e, "hide", ! /*show_label*/
+                s[2]), zn(e, "sr-only", ! /*show_label*/
+                s[2]), zn(
                 e,
                 "float",
                 /*float*/
-                i[4]
-            ), wn(
+                s[4]
+            ), zn(
                 e,
                 "hide-label",
                 /*disable*/
-                i[3]
+                s[3]
             );
         },
-        m(o, l) {
-            jc(o, e, l), ds(e, t), Kc(n, t, null), ds(e, r), ds(e, s), a = !0;
+        m(a, l) {
+            Wu(a, e, l), Vr(e, t), Xu(n, t, null), Vr(e, i), Vr(e, r), o = !0;
         },
-        p(o, [l]) {
-            (!a || l & /*label*/
-                1) && Zc(
-                s,
+        p(a, [l]) {
+            (!o || l & /*label*/
+                1) && Yu(
+                r,
                 /*label*/
-                o[0]
-            ), (!a || l & /*show_label*/
-                4) && wn(e, "hide", ! /*show_label*/
-                o[2]), (!a || l & /*show_label*/
-                4) && wn(e, "sr-only", ! /*show_label*/
-                o[2]), (!a || l & /*float*/
-                16) && wn(
+                a[0]
+            ), (!o || l & /*show_label*/
+                4) && zn(e, "hide", ! /*show_label*/
+                a[2]), (!o || l & /*show_label*/
+                4) && zn(e, "sr-only", ! /*show_label*/
+                a[2]), (!o || l & /*float*/
+                16) && zn(
                 e,
                 "float",
                 /*float*/
-                o[4]
-            ), (!a || l & /*disable*/
-                8) && wn(
+                a[4]
+            ), (!o || l & /*disable*/
+                8) && zn(
                 e,
                 "hide-label",
                 /*disable*/
-                o[3]
+                a[3]
             );
         },
-        i(o) {
-            a || (eu(n.$$.fragment, o), a = !0);
+        i(a) {
+            o || (Zu(n.$$.fragment, a), o = !0);
         },
-        o(o) {
-            tu(n.$$.fragment, o), a = !1;
+        o(a) {
+            Qu(n.$$.fragment, a), o = !1;
         },
-        d(o) {
-            o && qc(e), Xc(n);
+        d(a) {
+            a && Gu(e), Hu(n);
         }
     };
 }
 
-function iu(i, e, t) {
+function $u(s, e, t) {
     let {
         label: n = null
     } = e, {
-        Icon: r
+        Icon: i
     } = e, {
-        show_label: s = !0
+        show_label: r = !0
     } = e, {
-        disable: a = !1
+        disable: o = !1
     } = e, {
-        float: o = !0
+        float: a = !0
     } = e;
-    return i.$$set = (l) => {
-        "label" in l && t(0, n = l.label), "Icon" in l && t(1, r = l.Icon), "show_label" in l && t(2, s = l.show_label), "disable" in l && t(3, a = l.disable), "float" in l && t(4, o = l.float);
-    }, [n, r, s, a, o];
+    return s.$$set = (l) => {
+        "label" in l && t(0, n = l.label), "Icon" in l && t(1, i = l.Icon), "show_label" in l && t(2, r = l.show_label), "disable" in l && t(3, o = l.disable), "float" in l && t(4, a = l.float);
+    }, [n, i, r, o, a];
 }
-class co extends Vc {
+class qa extends ku {
     constructor(e) {
-        super(), Yc(this, e, iu, nu, Qc, {
+        super(), Vu(this, e, $u, Ju, qu, {
             label: 0,
             Icon: 1,
             show_label: 2,
             disable: 3,
             float: 4
         });
     }
 }
 const {
-    SvelteComponent: ru,
-    append: su,
-    attr: ps,
-    binding_callbacks: ou,
-    create_slot: au,
-    detach: lu,
-    element: Lo,
-    get_all_dirty_from_scope: cu,
-    get_slot_changes: uu,
-    init: fu,
-    insert: hu,
-    safe_not_equal: du,
-    toggle_class: Cn,
-    transition_in: pu,
-    transition_out: mu,
-    update_slot_base: gu
+    SvelteComponent: ed,
+    append: td,
+    attr: Wr,
+    binding_callbacks: nd,
+    create_slot: id,
+    detach: sd,
+    element: vo,
+    get_all_dirty_from_scope: rd,
+    get_slot_changes: ad,
+    init: od,
+    insert: ld,
+    safe_not_equal: cd,
+    toggle_class: Hn,
+    transition_in: ud,
+    transition_out: dd,
+    update_slot_base: fd
 } = window.__gradio__svelte__internal;
 
-function _u(i) {
+function hd(s) {
     let e, t, n;
-    const r = (
+    const i = (
             /*#slots*/
-            i[5].default
+            s[5].default
         ),
-        s = au(
-            r,
+        r = id(
             i,
+            s,
             /*$$scope*/
-            i[4],
+            s[4],
             null
         );
     return {
         c() {
-            e = Lo("div"), t = Lo("div"), s && s.c(), ps(t, "class", "icon svelte-3w3rth"), ps(e, "class", "empty svelte-3w3rth"), ps(e, "aria-label", "Empty value"), Cn(
+            e = vo("div"), t = vo("div"), r && r.c(), Wr(t, "class", "icon svelte-3w3rth"), Wr(e, "class", "empty svelte-3w3rth"), Wr(e, "aria-label", "Empty value"), Hn(
                 e,
                 "small",
                 /*size*/
-                i[0] === "small"
-            ), Cn(
+                s[0] === "small"
+            ), Hn(
                 e,
                 "large",
                 /*size*/
-                i[0] === "large"
-            ), Cn(
+                s[0] === "large"
+            ), Hn(
                 e,
                 "unpadded_box",
                 /*unpadded_box*/
-                i[1]
-            ), Cn(
+                s[1]
+            ), Hn(
                 e,
                 "small_parent",
                 /*parent_height*/
-                i[3]
+                s[3]
             );
         },
-        m(a, o) {
-            hu(a, e, o), su(e, t), s && s.m(t, null), i[6](e), n = !0;
+        m(o, a) {
+            ld(o, e, a), td(e, t), r && r.m(t, null), s[6](e), n = !0;
         },
-        p(a, [o]) {
-            s && s.p && (!n || o & /*$$scope*/
-                16) && gu(
-                s,
+        p(o, [a]) {
+            r && r.p && (!n || a & /*$$scope*/
+                16) && fd(
                 r,
-                a,
+                i,
+                o,
                 /*$$scope*/
-                a[4],
-                n ? uu(
-                    r,
+                o[4],
+                n ? ad(
+                    i,
                     /*$$scope*/
-                    a[4],
-                    o,
+                    o[4],
+                    a,
                     null
-                ) : cu(
+                ) : rd(
                     /*$$scope*/
-                    a[4]
+                    o[4]
                 ),
                 null
-            ), (!n || o & /*size*/
-                1) && Cn(
+            ), (!n || a & /*size*/
+                1) && Hn(
                 e,
                 "small",
                 /*size*/
-                a[0] === "small"
-            ), (!n || o & /*size*/
-                1) && Cn(
+                o[0] === "small"
+            ), (!n || a & /*size*/
+                1) && Hn(
                 e,
                 "large",
                 /*size*/
-                a[0] === "large"
-            ), (!n || o & /*unpadded_box*/
-                2) && Cn(
+                o[0] === "large"
+            ), (!n || a & /*unpadded_box*/
+                2) && Hn(
                 e,
                 "unpadded_box",
                 /*unpadded_box*/
-                a[1]
-            ), (!n || o & /*parent_height*/
-                8) && Cn(
+                o[1]
+            ), (!n || a & /*parent_height*/
+                8) && Hn(
                 e,
                 "small_parent",
                 /*parent_height*/
-                a[3]
+                o[3]
             );
         },
-        i(a) {
-            n || (pu(s, a), n = !0);
+        i(o) {
+            n || (ud(r, o), n = !0);
         },
-        o(a) {
-            mu(s, a), n = !1;
+        o(o) {
+            dd(r, o), n = !1;
         },
-        d(a) {
-            a && lu(e), s && s.d(a), i[6](null);
+        d(o) {
+            o && sd(e), r && r.d(o), s[6](null);
         }
     };
 }
 
-function vu(i) {
-    let e, t = i[0],
-        n = 1;
-    for (; n < i.length;) {
-        const r = i[n],
-            s = i[n + 1];
-        if (n += 2, (r === "optionalAccess" || r === "optionalCall") && t == null)
-            return;
-        r === "access" || r === "optionalAccess" ? (e = t, t = s(t)) : (r === "call" || r === "optionalCall") && (t = s((...a) => t.call(e, ...a)), e = void 0);
-    }
-    return t;
-}
-
-function xu(i, e, t) {
+function pd(s, e, t) {
     let n, {
-            $$slots: r = {},
-            $$scope: s
+            $$slots: i = {},
+            $$scope: r
         } = e,
         {
-            size: a = "small"
+            size: o = "small"
         } = e,
         {
-            unpadded_box: o = !1
+            unpadded_box: a = !1
         } = e,
         l;
 
-    function c(f) {
-        if (!f)
+    function c(d) {
+        var f;
+        if (!d)
             return !1;
         const {
             height: h
-        } = f.getBoundingClientRect(), {
-            height: p
-        } = vu([
-            f,
-            "access",
-            (g) => g.parentElement,
-            "optionalAccess",
-            (g) => g.getBoundingClientRect,
-            "call",
-            (g) => g()
-        ]) || {
+        } = d.getBoundingClientRect(), {
+            height: g
+        } = ((f = d.parentElement) === null || f === void 0 ? void 0 : f.getBoundingClientRect()) || {
             height: h
         };
-        return h > p + 2;
+        return h > g + 2;
     }
 
-    function u(f) {
-        ou[f ? "unshift" : "push"](() => {
-            l = f, t(2, l);
+    function u(d) {
+        nd[d ? "unshift" : "push"](() => {
+            l = d, t(2, l);
         });
     }
-    return i.$$set = (f) => {
-        "size" in f && t(0, a = f.size), "unpadded_box" in f && t(1, o = f.unpadded_box), "$$scope" in f && t(4, s = f.$$scope);
-    }, i.$$.update = () => {
-        i.$$.dirty & /*el*/
+    return s.$$set = (d) => {
+        "size" in d && t(0, o = d.size), "unpadded_box" in d && t(1, a = d.unpadded_box), "$$scope" in d && t(4, r = d.$$scope);
+    }, s.$$.update = () => {
+        s.$$.dirty & /*el*/
             4 && t(3, n = c(l));
-    }, [a, o, l, n, s, r, u];
+    }, [o, a, l, n, r, i, u];
 }
-class Su extends ru {
+class md extends ed {
     constructor(e) {
-        super(), fu(this, e, xu, _u, du, {
+        super(), od(this, e, pd, hd, cd, {
             size: 0,
             unpadded_box: 1
         });
     }
 }
 const {
-    SvelteComponent: Mu,
-    append: Do,
-    attr: Ot,
-    detach: yu,
-    init: Au,
-    insert: Eu,
-    noop: ms,
-    safe_not_equal: bu,
-    svg_element: gs
+    SvelteComponent: gd,
+    append: xo,
+    attr: Zt,
+    detach: _d,
+    init: Sd,
+    insert: vd,
+    noop: Xr,
+    safe_not_equal: xd,
+    svg_element: qr
 } = window.__gradio__svelte__internal;
 
-function Tu(i) {
+function yd(s) {
     let e, t, n;
     return {
         c() {
-            e = gs("svg"), t = gs("path"), n = gs("polyline"), Ot(t, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), Ot(n, "points", "13 2 13 9 20 9"), Ot(e, "xmlns", "http://www.w3.org/2000/svg"), Ot(e, "width", "100%"), Ot(e, "height", "100%"), Ot(e, "viewBox", "0 0 24 24"), Ot(e, "fill", "none"), Ot(e, "stroke", "currentColor"), Ot(e, "stroke-width", "1.5"), Ot(e, "stroke-linecap", "round"), Ot(e, "stroke-linejoin", "round"), Ot(e, "class", "feather feather-file");
+            e = qr("svg"), t = qr("path"), n = qr("polyline"), Zt(t, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), Zt(n, "points", "13 2 13 9 20 9"), Zt(e, "xmlns", "http://www.w3.org/2000/svg"), Zt(e, "width", "100%"), Zt(e, "height", "100%"), Zt(e, "viewBox", "0 0 24 24"), Zt(e, "fill", "none"), Zt(e, "stroke", "currentColor"), Zt(e, "stroke-width", "1.5"), Zt(e, "stroke-linecap", "round"), Zt(e, "stroke-linejoin", "round"), Zt(e, "class", "feather feather-file");
         },
-        m(r, s) {
-            Eu(r, e, s), Do(e, t), Do(e, n);
+        m(i, r) {
+            vd(i, e, r), xo(e, t), xo(e, n);
         },
-        p: ms,
-        i: ms,
-        o: ms,
-        d(r) {
-            r && yu(e);
+        p: Xr,
+        i: Xr,
+        o: Xr,
+        d(i) {
+            i && _d(e);
         }
     };
 }
-class rs extends Mu {
+class Lr extends gd {
     constructor(e) {
-        super(), Au(this, e, null, Tu, bu, {});
+        super(), Sd(this, e, null, yd, xd, {});
     }
 }
-const wu = [{
+const Md = [{
         color: "red",
         primary: 600,
         secondary: 100
     }, {
         color: "green",
         primary: 600,
         secondary: 100
@@ -708,15 +736,15 @@
         primary: 500,
         secondary: 100
     }, {
         color: "pink",
         primary: 600,
         secondary: 100
     }],
-    Io = {
+    yo = {
         inherit: "inherit",
         current: "currentColor",
         transparent: "transparent",
         black: "#000",
         white: "#fff",
         slate: {
             50: "#f8fafc",
@@ -1001,425 +1029,425 @@
             600: "#e11d48",
             700: "#be123c",
             800: "#9f1239",
             900: "#881337",
             950: "#4c0519"
         }
     };
-wu.reduce(
-    (i, {
+Md.reduce(
+    (s, {
         color: e,
         primary: t,
         secondary: n
     }) => ({
-        ...i,
+        ...s,
         [e]: {
-            primary: Io[e][t],
-            secondary: Io[e][n]
+            primary: yo[e][t],
+            secondary: yo[e][n]
         }
     }), {}
 );
 /**
  * @license
  * Copyright 2010-2023 Three.js Authors
  * SPDX-License-Identifier: MIT
  */
-const uo = "162",
-    fi = {
+const Ya = "162",
+    bi = {
         LEFT: 0,
         MIDDLE: 1,
         RIGHT: 2,
         ROTATE: 0,
         DOLLY: 1,
         PAN: 2
     },
-    hi = {
+    Ci = {
         ROTATE: 0,
         PAN: 1,
         DOLLY_PAN: 2,
         DOLLY_ROTATE: 3
     },
-    Cu = 0,
-    Uo = 1,
-    Ru = 2,
-    Fl = 1,
-    Pu = 2,
-    xn = 3,
-    hn = 0,
-    Pt = 1,
-    en = 2,
-    zn = 0,
-    ri = 1,
-    Fo = 2,
-    No = 3,
-    Bo = 4,
-    Nl = 5,
-    ei = 100,
-    Lu = 101,
-    Du = 102,
-    Oo = 103,
-    zo = 104,
-    Iu = 200,
-    Uu = 201,
-    Fu = 202,
-    Nu = 203,
-    cr = 204,
-    ur = 205,
-    Bu = 206,
-    Ou = 207,
-    zu = 208,
-    ku = 209,
-    Gu = 210,
-    Hu = 211,
-    Vu = 212,
-    Wu = 213,
-    Xu = 214,
-    qu = 0,
-    Yu = 1,
-    ju = 2,
-    qr = 3,
-    Ku = 4,
-    Qu = 5,
-    Zu = 6,
-    Ju = 7,
-    Bl = 0,
-    $u = 1,
-    ef = 2,
-    kn = 0,
-    tf = 1,
-    nf = 2,
-    rf = 3,
-    sf = 4,
-    of = 5,
-    af = 6,
-    lf = 7,
-    Ol = 300,
-    zi = 301,
-    ki = 302,
-    $s = 303,
-    eo = 304,
-    ss = 306,
-    to = 1e3,
-    tn = 1001,
-    no = 1002,
-    vt = 1003,
-    ko = 1004,
-    er = 1005,
-    Ct = 1006,
-    _s = 1007,
-    ni = 1008,
-    Gn = 1009,
-    cf = 1010,
-    uf = 1011,
-    fo = 1012,
-    zl = 1013,
-    nn = 1014,
-    an = 1015,
-    Gi = 1016,
-    kl = 1017,
-    Gl = 1018,
-    si = 1020,
-    ff = 1021,
-    Vt = 1023,
-    hf = 1024,
-    df = 1025,
-    Hn = 1026,
-    Hi = 1027,
-    pf = 1028,
-    ho = 1029,
-    io = 1030,
-    Hl = 1031,
-    po = 1033,
-    vs = 33776,
-    xs = 33777,
-    Ss = 33778,
-    Ms = 33779,
-    Go = 35840,
-    Ho = 35841,
-    Vo = 35842,
-    Wo = 35843,
-    Vl = 36196,
-    Xo = 37492,
-    qo = 37496,
-    Yo = 37808,
-    jo = 37809,
-    Ko = 37810,
-    Qo = 37811,
-    Zo = 37812,
-    Jo = 37813,
-    $o = 37814,
-    ea = 37815,
-    ta = 37816,
-    na = 37817,
-    ia = 37818,
-    ra = 37819,
-    sa = 37820,
-    oa = 37821,
-    ys = 36492,
-    aa = 36494,
-    la = 36495,
-    mf = 36283,
-    ca = 36284,
-    ua = 36285,
-    fa = 36286,
-    gf = 3200,
-    _f = 3201,
-    vf = 0,
-    xf = 1,
-    Nn = "",
-    sn = "srgb",
-    Wn = "srgb-linear",
-    mo = "display-p3",
-    os = "display-p3-linear",
-    Yr = "linear",
-    nt = "srgb",
-    jr = "rec709",
-    Kr = "p3",
-    di = 7680,
-    ha = 519,
-    Sf = 512,
-    Mf = 513,
-    yf = 514,
-    Wl = 515,
-    Af = 516,
-    Ef = 517,
-    bf = 518,
-    Tf = 519,
-    da = 35044,
-    wf = 35048,
-    pa = "300 es",
-    ro = 1035,
-    Mn = 2e3,
-    Qr = 2001;
-class ui {
+    Ed = 0,
+    Mo = 1,
+    Ad = 2,
+    Rc = 1,
+    Td = 2,
+    wn = 3,
+    yn = 0,
+    zt = 1,
+    un = 2,
+    Jn = 0,
+    Si = 1,
+    Eo = 2,
+    Ao = 3,
+    To = 4,
+    Pc = 5,
+    fi = 100,
+    bd = 101,
+    Cd = 102,
+    bo = 103,
+    Co = 104,
+    wd = 200,
+    Rd = 201,
+    Pd = 202,
+    Dd = 203,
+    Ps = 204,
+    Ds = 205,
+    Ld = 206,
+    Fd = 207,
+    Id = 208,
+    Ud = 209,
+    Bd = 210,
+    Od = 211,
+    Nd = 212,
+    kd = 213,
+    zd = 214,
+    Hd = 0,
+    Gd = 1,
+    Vd = 2,
+    vr = 3,
+    Wd = 4,
+    Xd = 5,
+    qd = 6,
+    Yd = 7,
+    Dc = 0,
+    jd = 1,
+    Kd = 2,
+    $n = 0,
+    Zd = 1,
+    Qd = 2,
+    Jd = 3,
+    $d = 4,
+    ef = 5,
+    tf = 6,
+    nf = 7,
+    Lc = 300,
+    os = 301,
+    ls = 302,
+    Fa = 303,
+    Ia = 304,
+    Fr = 306,
+    Ua = 1e3,
+    dn = 1001,
+    Ba = 1002,
+    bt = 1003,
+    wo = 1004,
+    xs = 1005,
+    Nt = 1006,
+    Yr = 1007,
+    mi = 1008,
+    In = 1009,
+    sf = 1010,
+    rf = 1011,
+    ja = 1012,
+    Fc = 1013,
+    fn = 1014,
+    gn = 1015,
+    xi = 1016,
+    Ic = 1017,
+    Uc = 1018,
+    vi = 1020,
+    af = 1021,
+    kt = 1023,
+    of = 1024,
+    lf = 1025,
+    ei = 1026,
+    cs = 1027,
+    cf = 1028,
+    Ka = 1029,
+    uf = 1030,
+    Bc = 1031,
+    Za = 1033,
+    jr = 33776,
+    Kr = 33777,
+    Zr = 33778,
+    Qr = 33779,
+    Ro = 35840,
+    Po = 35841,
+    Do = 35842,
+    Lo = 35843,
+    Oc = 36196,
+    Fo = 37492,
+    Io = 37496,
+    Uo = 37808,
+    Bo = 37809,
+    Oo = 37810,
+    No = 37811,
+    ko = 37812,
+    zo = 37813,
+    Ho = 37814,
+    Go = 37815,
+    Vo = 37816,
+    Wo = 37817,
+    Xo = 37818,
+    qo = 37819,
+    Yo = 37820,
+    jo = 37821,
+    Jr = 36492,
+    Ko = 36494,
+    Zo = 36495,
+    df = 36283,
+    Qo = 36284,
+    Jo = 36285,
+    $o = 36286,
+    ff = 3200,
+    hf = 3201,
+    pf = 0,
+    mf = 1,
+    Zn = "",
+    pn = "srgb",
+    ni = "srgb-linear",
+    Qa = "display-p3",
+    Ir = "display-p3-linear",
+    xr = "linear",
+    at = "srgb",
+    yr = "rec709",
+    Mr = "p3",
+    wi = 7680,
+    el = 519,
+    gf = 512,
+    _f = 513,
+    Sf = 514,
+    Nc = 515,
+    vf = 516,
+    xf = 517,
+    yf = 518,
+    Mf = 519,
+    tl = 35044,
+    Ef = 35048,
+    nl = "300 es",
+    Oa = 1035,
+    Dn = 2e3,
+    Er = 2001;
+class Ti {
     addEventListener(e, t) {
         this._listeners === void 0 && (this._listeners = {});
         const n = this._listeners;
         n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
     }
     hasEventListener(e, t) {
         if (this._listeners === void 0)
             return !1;
         const n = this._listeners;
         return n[e] !== void 0 && n[e].indexOf(t) !== -1;
     }
     removeEventListener(e, t) {
         if (this._listeners === void 0)
             return;
-        const r = this._listeners[e];
-        if (r !== void 0) {
-            const s = r.indexOf(t);
-            s !== -1 && r.splice(s, 1);
+        const i = this._listeners[e];
+        if (i !== void 0) {
+            const r = i.indexOf(t);
+            r !== -1 && i.splice(r, 1);
         }
     }
     dispatchEvent(e) {
         if (this._listeners === void 0)
             return;
         const n = this._listeners[e.type];
         if (n !== void 0) {
             e.target = this;
-            const r = n.slice(0);
-            for (let s = 0, a = r.length; s < a; s++)
-                r[s].call(this, e);
+            const i = n.slice(0);
+            for (let r = 0, o = i.length; r < o; r++)
+                i[r].call(this, e);
             e.target = null;
         }
     }
 }
-const Mt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
-let ma = 1234567;
-const sr = Math.PI / 180,
-    fr = 180 / Math.PI;
+const Rt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
+let il = 1234567;
+const Ts = Math.PI / 180,
+    Ls = 180 / Math.PI;
 
-function Ki() {
-    const i = Math.random() * 4294967295 | 0,
+function ms() {
+    const s = Math.random() * 4294967295 | 0,
         e = Math.random() * 4294967295 | 0,
         t = Math.random() * 4294967295 | 0,
         n = Math.random() * 4294967295 | 0;
-    return (Mt[i & 255] + Mt[i >> 8 & 255] + Mt[i >> 16 & 255] + Mt[i >> 24 & 255] + "-" + Mt[e & 255] + Mt[e >> 8 & 255] + "-" + Mt[e >> 16 & 15 | 64] + Mt[e >> 24 & 255] + "-" + Mt[t & 63 | 128] + Mt[t >> 8 & 255] + "-" + Mt[t >> 16 & 255] + Mt[t >> 24 & 255] + Mt[n & 255] + Mt[n >> 8 & 255] + Mt[n >> 16 & 255] + Mt[n >> 24 & 255]).toLowerCase();
+    return (Rt[s & 255] + Rt[s >> 8 & 255] + Rt[s >> 16 & 255] + Rt[s >> 24 & 255] + "-" + Rt[e & 255] + Rt[e >> 8 & 255] + "-" + Rt[e >> 16 & 15 | 64] + Rt[e >> 24 & 255] + "-" + Rt[t & 63 | 128] + Rt[t >> 8 & 255] + "-" + Rt[t >> 16 & 255] + Rt[t >> 24 & 255] + Rt[n & 255] + Rt[n >> 8 & 255] + Rt[n >> 16 & 255] + Rt[n >> 24 & 255]).toLowerCase();
 }
 
-function xt(i, e, t) {
-    return Math.max(e, Math.min(t, i));
+function Ct(s, e, t) {
+    return Math.max(e, Math.min(t, s));
 }
 
-function go(i, e) {
-    return (i % e + e) % e;
+function Ja(s, e) {
+    return (s % e + e) % e;
 }
 
-function Cf(i, e, t, n, r) {
-    return n + (i - e) * (r - n) / (t - e);
+function Af(s, e, t, n, i) {
+    return n + (s - e) * (i - n) / (t - e);
 }
 
-function Rf(i, e, t) {
-    return i !== e ? (t - i) / (e - i) : 0;
+function Tf(s, e, t) {
+    return s !== e ? (t - s) / (e - s) : 0;
 }
 
-function or(i, e, t) {
-    return (1 - t) * i + t * e;
+function bs(s, e, t) {
+    return (1 - t) * s + t * e;
 }
 
-function Pf(i, e, t, n) {
-    return or(i, e, 1 - Math.exp(-t * n));
+function bf(s, e, t, n) {
+    return bs(s, e, 1 - Math.exp(-t * n));
 }
 
-function Lf(i, e = 1) {
-    return e - Math.abs(go(i, e * 2) - e);
+function Cf(s, e = 1) {
+    return e - Math.abs(Ja(s, e * 2) - e);
 }
 
-function Df(i, e, t) {
-    return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * (3 - 2 * i));
+function wf(s, e, t) {
+    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * (3 - 2 * s));
 }
 
-function If(i, e, t) {
-    return i <= e ? 0 : i >= t ? 1 : (i = (i - e) / (t - e), i * i * i * (i * (i * 6 - 15) + 10));
+function Rf(s, e, t) {
+    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e), s * s * s * (s * (s * 6 - 15) + 10));
 }
 
-function Uf(i, e) {
-    return i + Math.floor(Math.random() * (e - i + 1));
+function Pf(s, e) {
+    return s + Math.floor(Math.random() * (e - s + 1));
 }
 
-function Ff(i, e) {
-    return i + Math.random() * (e - i);
+function Df(s, e) {
+    return s + Math.random() * (e - s);
 }
 
-function Nf(i) {
-    return i * (0.5 - Math.random());
+function Lf(s) {
+    return s * (0.5 - Math.random());
 }
 
-function Bf(i) {
-    i !== void 0 && (ma = i);
-    let e = ma += 1831565813;
+function Ff(s) {
+    s !== void 0 && (il = s);
+    let e = il += 1831565813;
     return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
 }
 
-function Of(i) {
-    return i * sr;
+function If(s) {
+    return s * Ts;
 }
 
-function zf(i) {
-    return i * fr;
+function Uf(s) {
+    return s * Ls;
 }
 
-function so(i) {
-    return (i & i - 1) === 0 && i !== 0;
+function Na(s) {
+    return (s & s - 1) === 0 && s !== 0;
 }
 
-function kf(i) {
-    return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2));
+function Bf(s) {
+    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
 }
 
-function Zr(i) {
-    return Math.pow(2, Math.floor(Math.log(i) / Math.LN2));
+function Ar(s) {
+    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2));
 }
 
-function Gf(i, e, t, n, r) {
-    const s = Math.cos,
-        a = Math.sin,
-        o = s(t / 2),
-        l = a(t / 2),
-        c = s((e + n) / 2),
-        u = a((e + n) / 2),
-        f = s((e - n) / 2),
-        h = a((e - n) / 2),
-        p = s((n - e) / 2),
-        g = a((n - e) / 2);
-    switch (r) {
+function Of(s, e, t, n, i) {
+    const r = Math.cos,
+        o = Math.sin,
+        a = r(t / 2),
+        l = o(t / 2),
+        c = r((e + n) / 2),
+        u = o((e + n) / 2),
+        d = r((e - n) / 2),
+        f = o((e - n) / 2),
+        h = r((n - e) / 2),
+        g = o((n - e) / 2);
+    switch (i) {
         case "XYX":
-            i.set(o * u, l * f, l * h, o * c);
+            s.set(a * u, l * d, l * f, a * c);
             break;
         case "YZY":
-            i.set(l * h, o * u, l * f, o * c);
+            s.set(l * f, a * u, l * d, a * c);
             break;
         case "ZXZ":
-            i.set(l * f, l * h, o * u, o * c);
+            s.set(l * d, l * f, a * u, a * c);
             break;
         case "XZX":
-            i.set(o * u, l * g, l * p, o * c);
+            s.set(a * u, l * g, l * h, a * c);
             break;
         case "YXY":
-            i.set(l * p, o * u, l * g, o * c);
+            s.set(l * h, a * u, l * g, a * c);
             break;
         case "ZYZ":
-            i.set(l * g, l * p, o * u, o * c);
+            s.set(l * g, l * h, a * u, a * c);
             break;
         default:
-            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
+            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
     }
 }
 
-function Di(i, e) {
+function Ki(s, e) {
     switch (e.constructor) {
         case Float32Array:
-            return i;
+            return s;
         case Uint32Array:
-            return i / 4294967295;
+            return s / 4294967295;
         case Uint16Array:
-            return i / 65535;
+            return s / 65535;
         case Uint8Array:
-            return i / 255;
+            return s / 255;
         case Int32Array:
-            return Math.max(i / 2147483647, -1);
+            return Math.max(s / 2147483647, -1);
         case Int16Array:
-            return Math.max(i / 32767, -1);
+            return Math.max(s / 32767, -1);
         case Int8Array:
-            return Math.max(i / 127, -1);
+            return Math.max(s / 127, -1);
         default:
             throw new Error("Invalid component type.");
     }
 }
 
-function Et(i, e) {
+function It(s, e) {
     switch (e.constructor) {
         case Float32Array:
-            return i;
+            return s;
         case Uint32Array:
-            return Math.round(i * 4294967295);
+            return Math.round(s * 4294967295);
         case Uint16Array:
-            return Math.round(i * 65535);
+            return Math.round(s * 65535);
         case Uint8Array:
-            return Math.round(i * 255);
+            return Math.round(s * 255);
         case Int32Array:
-            return Math.round(i * 2147483647);
+            return Math.round(s * 2147483647);
         case Int16Array:
-            return Math.round(i * 32767);
+            return Math.round(s * 32767);
         case Int8Array:
-            return Math.round(i * 127);
+            return Math.round(s * 127);
         default:
             throw new Error("Invalid component type.");
     }
 }
-const Xl = {
-    DEG2RAD: sr,
-    RAD2DEG: fr,
-    generateUUID: Ki,
-    clamp: xt,
-    euclideanModulo: go,
-    mapLinear: Cf,
-    inverseLerp: Rf,
-    lerp: or,
-    damp: Pf,
-    pingpong: Lf,
-    smoothstep: Df,
-    smootherstep: If,
-    randInt: Uf,
-    randFloat: Ff,
-    randFloatSpread: Nf,
-    seededRandom: Bf,
-    degToRad: Of,
-    radToDeg: zf,
-    isPowerOfTwo: so,
-    ceilPowerOfTwo: kf,
-    floorPowerOfTwo: Zr,
-    setQuaternionFromProperEuler: Gf,
-    normalize: Et,
-    denormalize: Di
+const kc = {
+    DEG2RAD: Ts,
+    RAD2DEG: Ls,
+    generateUUID: ms,
+    clamp: Ct,
+    euclideanModulo: Ja,
+    mapLinear: Af,
+    inverseLerp: Tf,
+    lerp: bs,
+    damp: bf,
+    pingpong: Cf,
+    smoothstep: wf,
+    smootherstep: Rf,
+    randInt: Pf,
+    randFloat: Df,
+    randFloatSpread: Lf,
+    seededRandom: Ff,
+    degToRad: If,
+    radToDeg: Uf,
+    isPowerOfTwo: Na,
+    ceilPowerOfTwo: Bf,
+    floorPowerOfTwo: Ar,
+    setQuaternionFromProperEuler: Of,
+    normalize: It,
+    denormalize: Ki
 };
-class me {
+class Ee {
     constructor(e = 0, t = 0) {
-        me.prototype.isVector2 = !0, this.x = e, this.y = t;
+        Ee.prototype.isVector2 = !0, this.x = e, this.y = t;
     }
     get width() {
         return this.x;
     }
     set width(e) {
         this.x = e;
     }
@@ -1502,16 +1530,16 @@
     }
     divideScalar(e) {
         return this.multiplyScalar(1 / e);
     }
     applyMatrix3(e) {
         const t = this.x,
             n = this.y,
-            r = e.elements;
-        return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this;
+            i = e.elements;
+        return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
     }
     min(e) {
         return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
     }
     max(e) {
         return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
     }
@@ -1562,15 +1590,15 @@
         return Math.atan2(-this.y, -this.x) + Math.PI;
     }
     angleTo(e) {
         const t = Math.sqrt(this.lengthSq() * e.lengthSq());
         if (t === 0)
             return Math.PI / 2;
         const n = this.dot(e) / t;
-        return Math.acos(xt(n, -1, 1));
+        return Math.acos(Ct(n, -1, 1));
     }
     distanceTo(e) {
         return Math.sqrt(this.distanceToSquared(e));
     }
     distanceToSquared(e) {
         const t = this.x - e.x,
             n = this.y - e.y;
@@ -1598,43 +1626,43 @@
         return e[t] = this.x, e[t + 1] = this.y, e;
     }
     fromBufferAttribute(e, t) {
         return this.x = e.getX(t), this.y = e.getY(t), this;
     }
     rotateAround(e, t) {
         const n = Math.cos(t),
-            r = Math.sin(t),
-            s = this.x - e.x,
-            a = this.y - e.y;
-        return this.x = s * n - a * r + e.x, this.y = s * r + a * n + e.y, this;
+            i = Math.sin(t),
+            r = this.x - e.x,
+            o = this.y - e.y;
+        return this.x = r * n - o * i + e.x, this.y = r * i + o * n + e.y, this;
     }
     random() {
             return this.x = Math.random(), this.y = Math.random(), this;
         }
         *[Symbol.iterator]() {
             yield this.x, yield this.y;
         }
 }
-class be {
-    constructor(e, t, n, r, s, a, o, l, c) {
-        be.prototype.isMatrix3 = !0, this.elements = [
+class Ue {
+    constructor(e, t, n, i, r, o, a, l, c) {
+        Ue.prototype.isMatrix3 = !0, this.elements = [
             1,
             0,
             0,
             0,
             1,
             0,
             0,
             0,
             1
-        ], e !== void 0 && this.set(e, t, n, r, s, a, o, l, c);
+        ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c);
     }
-    set(e, t, n, r, s, a, o, l, c) {
+    set(e, t, n, i, r, o, a, l, c) {
         const u = this.elements;
-        return u[0] = e, u[1] = r, u[2] = o, u[3] = t, u[4] = s, u[5] = l, u[6] = n, u[7] = a, u[8] = c, this;
+        return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = r, u[5] = l, u[6] = n, u[7] = o, u[8] = c, this;
     }
     identity() {
         return this.set(
             1,
             0,
             0,
             0,
@@ -1671,109 +1699,109 @@
         return this.multiplyMatrices(this, e);
     }
     premultiply(e) {
         return this.multiplyMatrices(e, this);
     }
     multiplyMatrices(e, t) {
         const n = e.elements,
-            r = t.elements,
-            s = this.elements,
-            a = n[0],
-            o = n[3],
+            i = t.elements,
+            r = this.elements,
+            o = n[0],
+            a = n[3],
             l = n[6],
             c = n[1],
             u = n[4],
-            f = n[7],
-            h = n[2],
-            p = n[5],
+            d = n[7],
+            f = n[2],
+            h = n[5],
             g = n[8],
-            v = r[0],
-            m = r[3],
-            d = r[6],
-            M = r[1],
-            _ = r[4],
-            A = r[7],
-            R = r[2],
-            E = r[5],
-            b = r[8];
-        return s[0] = a * v + o * M + l * R, s[3] = a * m + o * _ + l * E, s[6] = a * d + o * A + l * b, s[1] = c * v + u * M + f * R, s[4] = c * m + u * _ + f * E, s[7] = c * d + u * A + f * b, s[2] = h * v + p * M + g * R, s[5] = h * m + p * _ + g * E, s[8] = h * d + p * A + g * b, this;
+            _ = i[0],
+            m = i[3],
+            p = i[6],
+            v = i[1],
+            S = i[4],
+            y = i[7],
+            b = i[2],
+            E = i[5],
+            T = i[8];
+        return r[0] = o * _ + a * v + l * b, r[3] = o * m + a * S + l * E, r[6] = o * p + a * y + l * T, r[1] = c * _ + u * v + d * b, r[4] = c * m + u * S + d * E, r[7] = c * p + u * y + d * T, r[2] = f * _ + h * v + g * b, r[5] = f * m + h * S + g * E, r[8] = f * p + h * y + g * T, this;
     }
     multiplyScalar(e) {
         const t = this.elements;
         return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
     }
     determinant() {
         const e = this.elements,
             t = e[0],
             n = e[1],
-            r = e[2],
-            s = e[3],
-            a = e[4],
-            o = e[5],
+            i = e[2],
+            r = e[3],
+            o = e[4],
+            a = e[5],
             l = e[6],
             c = e[7],
             u = e[8];
-        return t * a * u - t * o * c - n * s * u + n * o * l + r * s * c - r * a * l;
+        return t * o * u - t * a * c - n * r * u + n * a * l + i * r * c - i * o * l;
     }
     invert() {
         const e = this.elements,
             t = e[0],
             n = e[1],
-            r = e[2],
-            s = e[3],
-            a = e[4],
-            o = e[5],
+            i = e[2],
+            r = e[3],
+            o = e[4],
+            a = e[5],
             l = e[6],
             c = e[7],
             u = e[8],
-            f = u * a - o * c,
-            h = o * l - u * s,
-            p = c * s - a * l,
-            g = t * f + n * h + r * p;
+            d = u * o - a * c,
+            f = a * l - u * r,
+            h = c * r - o * l,
+            g = t * d + n * f + i * h;
         if (g === 0)
             return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
-        const v = 1 / g;
-        return e[0] = f * v, e[1] = (r * c - u * n) * v, e[2] = (o * n - r * a) * v, e[3] = h * v, e[4] = (u * t - r * l) * v, e[5] = (r * s - o * t) * v, e[6] = p * v, e[7] = (n * l - c * t) * v, e[8] = (a * t - n * s) * v, this;
+        const _ = 1 / g;
+        return e[0] = d * _, e[1] = (i * c - u * n) * _, e[2] = (a * n - i * o) * _, e[3] = f * _, e[4] = (u * t - i * l) * _, e[5] = (i * r - a * t) * _, e[6] = h * _, e[7] = (n * l - c * t) * _, e[8] = (o * t - n * r) * _, this;
     }
     transpose() {
         let e;
         const t = this.elements;
         return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
     }
     getNormalMatrix(e) {
         return this.setFromMatrix4(e).invert().transpose();
     }
     transposeIntoArray(e) {
         const t = this.elements;
         return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
     }
-    setUvTransform(e, t, n, r, s, a, o) {
-        const l = Math.cos(s),
-            c = Math.sin(s);
+    setUvTransform(e, t, n, i, r, o, a) {
+        const l = Math.cos(r),
+            c = Math.sin(r);
         return this.set(
             n * l,
             n * c,
-            -n * (l * a + c * o) + a + e,
-            -r * c,
-            r * l,
-            -r * (-c * a + l * o) + o + t,
+            -n * (l * o + c * a) + o + e,
+            -i * c,
+            i * l,
+            -i * (-c * o + l * a) + a + t,
             0,
             0,
             1
         ), this;
     }
     //
     scale(e, t) {
-        return this.premultiply(As.makeScale(e, t)), this;
+        return this.premultiply($r.makeScale(e, t)), this;
     }
     rotate(e) {
-        return this.premultiply(As.makeRotation(-e)), this;
+        return this.premultiply($r.makeRotation(-e)), this;
     }
     translate(e, t) {
-        return this.premultiply(As.makeTranslation(e, t)), this;
+        return this.premultiply($r.makeTranslation(e, t)), this;
     }
     // for 2D Transforms
     makeTranslation(e, t) {
         return e.isVector2 ? this.set(
             1,
             0,
             e.x,
@@ -1823,16 +1851,16 @@
             1
         ), this;
     }
     //
     equals(e) {
         const t = this.elements,
             n = e.elements;
-        for (let r = 0; r < 9; r++)
-            if (t[r] !== n[r])
+        for (let i = 0; i < 9; i++)
+            if (t[i] !== n[i])
                 return !1;
         return !0;
     }
     fromArray(e, t = 0) {
         for (let n = 0; n < 9; n++)
             this.elements[n] = e[n + t];
         return this;
@@ -1841,210 +1869,210 @@
         const n = this.elements;
         return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
     }
     clone() {
         return new this.constructor().fromArray(this.elements);
     }
 }
-const As = /* @__PURE__ */ new be();
+const $r = /* @__PURE__ */ new Ue();
 
-function ql(i) {
-    for (let e = i.length - 1; e >= 0; --e)
-        if (i[e] >= 65535)
+function zc(s) {
+    for (let e = s.length - 1; e >= 0; --e)
+        if (s[e] >= 65535)
             return !0;
     return !1;
 }
 
-function Jr(i) {
-    return document.createElementNS("http://www.w3.org/1999/xhtml", i);
+function Tr(s) {
+    return document.createElementNS("http://www.w3.org/1999/xhtml", s);
 }
 
-function Hf() {
-    const i = Jr("canvas");
-    return i.style.display = "block", i;
+function Nf() {
+    const s = Tr("canvas");
+    return s.style.display = "block", s;
 }
-const ga = {};
+const sl = {};
 
-function Vf(i) {
-    i in ga || (ga[i] = !0, console.warn(i));
+function kf(s) {
+    s in sl || (sl[s] = !0, console.warn(s));
 }
-const _a = /* @__PURE__ */ new be().set(
+const rl = /* @__PURE__ */ new Ue().set(
         0.8224621,
         0.177538,
         0,
         0.0331941,
         0.9668058,
         0,
         0.0170827,
         0.0723974,
         0.9105199
     ),
-    va = /* @__PURE__ */ new be().set(
+    al = /* @__PURE__ */ new Ue().set(
         1.2249401,
         -0.2249404,
         0,
         -0.0420569,
         1.0420571,
         0,
         -0.0196376,
         -0.0786361,
         1.0982735
     ),
-    gr = {
-        [Wn]: {
-            transfer: Yr,
-            primaries: jr,
-            toReference: (i) => i,
-            fromReference: (i) => i
-        },
-        [sn]: {
-            transfer: nt,
-            primaries: jr,
-            toReference: (i) => i.convertSRGBToLinear(),
-            fromReference: (i) => i.convertLinearToSRGB()
-        },
-        [os]: {
-            transfer: Yr,
-            primaries: Kr,
-            toReference: (i) => i.applyMatrix3(va),
-            fromReference: (i) => i.applyMatrix3(_a)
-        },
-        [mo]: {
-            transfer: nt,
-            primaries: Kr,
-            toReference: (i) => i.convertSRGBToLinear().applyMatrix3(va),
-            fromReference: (i) => i.applyMatrix3(_a).convertLinearToSRGB()
+    ks = {
+        [ni]: {
+            transfer: xr,
+            primaries: yr,
+            toReference: (s) => s,
+            fromReference: (s) => s
+        },
+        [pn]: {
+            transfer: at,
+            primaries: yr,
+            toReference: (s) => s.convertSRGBToLinear(),
+            fromReference: (s) => s.convertLinearToSRGB()
+        },
+        [Ir]: {
+            transfer: xr,
+            primaries: Mr,
+            toReference: (s) => s.applyMatrix3(al),
+            fromReference: (s) => s.applyMatrix3(rl)
+        },
+        [Qa]: {
+            transfer: at,
+            primaries: Mr,
+            toReference: (s) => s.convertSRGBToLinear().applyMatrix3(al),
+            fromReference: (s) => s.applyMatrix3(rl).convertLinearToSRGB()
         }
     },
-    Wf = /* @__PURE__ */ new Set([Wn, os]),
-    Ze = {
+    zf = /* @__PURE__ */ new Set([ni, Ir]),
+    tt = {
         enabled: !0,
-        _workingColorSpace: Wn,
+        _workingColorSpace: ni,
         get workingColorSpace() {
             return this._workingColorSpace;
         },
-        set workingColorSpace(i) {
-            if (!Wf.has(i))
-                throw new Error(`Unsupported working color space, "${i}".`);
-            this._workingColorSpace = i;
+        set workingColorSpace(s) {
+            if (!zf.has(s))
+                throw new Error(`Unsupported working color space, "${s}".`);
+            this._workingColorSpace = s;
         },
-        convert: function(i, e, t) {
+        convert: function(s, e, t) {
             if (this.enabled === !1 || e === t || !e || !t)
-                return i;
-            const n = gr[e].toReference,
-                r = gr[t].fromReference;
-            return r(n(i));
+                return s;
+            const n = ks[e].toReference,
+                i = ks[t].fromReference;
+            return i(n(s));
         },
-        fromWorkingColorSpace: function(i, e) {
-            return this.convert(i, this._workingColorSpace, e);
+        fromWorkingColorSpace: function(s, e) {
+            return this.convert(s, this._workingColorSpace, e);
         },
-        toWorkingColorSpace: function(i, e) {
-            return this.convert(i, e, this._workingColorSpace);
+        toWorkingColorSpace: function(s, e) {
+            return this.convert(s, e, this._workingColorSpace);
         },
-        getPrimaries: function(i) {
-            return gr[i].primaries;
+        getPrimaries: function(s) {
+            return ks[s].primaries;
         },
-        getTransfer: function(i) {
-            return i === Nn ? Yr : gr[i].transfer;
+        getTransfer: function(s) {
+            return s === Zn ? xr : ks[s].transfer;
         }
     };
 
-function Bi(i) {
-    return i < 0.04045 ? i * 0.0773993808 : Math.pow(i * 0.9478672986 + 0.0521327014, 2.4);
+function is(s) {
+    return s < 0.04045 ? s * 0.0773993808 : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4);
 }
 
-function Es(i) {
-    return i < 31308e-7 ? i * 12.92 : 1.055 * Math.pow(i, 0.41666) - 0.055;
+function ea(s) {
+    return s < 31308e-7 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055;
 }
-let pi;
-class Yl {
+let Ri;
+class Hc {
     static getDataURL(e) {
         if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
             return e.src;
         let t;
         if (e instanceof HTMLCanvasElement)
             t = e;
         else {
-            pi === void 0 && (pi = Jr("canvas")), pi.width = e.width, pi.height = e.height;
-            const n = pi.getContext("2d");
-            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = pi;
+            Ri === void 0 && (Ri = Tr("canvas")), Ri.width = e.width, Ri.height = e.height;
+            const n = Ri.getContext("2d");
+            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Ri;
         }
         return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
     }
     static sRGBToLinear(e) {
         if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
-            const t = Jr("canvas");
+            const t = Tr("canvas");
             t.width = e.width, t.height = e.height;
             const n = t.getContext("2d");
             n.drawImage(e, 0, 0, e.width, e.height);
-            const r = n.getImageData(0, 0, e.width, e.height),
-                s = r.data;
-            for (let a = 0; a < s.length; a++)
-                s[a] = Bi(s[a] / 255) * 255;
-            return n.putImageData(r, 0, 0), t;
+            const i = n.getImageData(0, 0, e.width, e.height),
+                r = i.data;
+            for (let o = 0; o < r.length; o++)
+                r[o] = is(r[o] / 255) * 255;
+            return n.putImageData(i, 0, 0), t;
         } else if (e.data) {
             const t = e.data.slice(0);
             for (let n = 0; n < t.length; n++)
-                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Bi(t[n] / 255) * 255) : t[n] = Bi(t[n]);
+                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(is(t[n] / 255) * 255) : t[n] = is(t[n]);
             return {
                 data: t,
                 width: e.width,
                 height: e.height
             };
         } else
             return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
     }
 }
-let Xf = 0;
-class jl {
+let Hf = 0;
+class Gc {
     constructor(e = null) {
         this.isSource = !0, Object.defineProperty(this, "id", {
-            value: Xf++
-        }), this.uuid = Ki(), this.data = e, this.dataReady = !0, this.version = 0;
+            value: Hf++
+        }), this.uuid = ms(), this.data = e, this.dataReady = !0, this.version = 0;
     }
     set needsUpdate(e) {
         e === !0 && this.version++;
     }
     toJSON(e) {
         const t = e === void 0 || typeof e == "string";
         if (!t && e.images[this.uuid] !== void 0)
             return e.images[this.uuid];
         const n = {
                 uuid: this.uuid,
                 url: ""
             },
-            r = this.data;
-        if (r !== null) {
-            let s;
-            if (Array.isArray(r)) {
-                s = [];
-                for (let a = 0, o = r.length; a < o; a++)
-                    r[a].isDataTexture ? s.push(bs(r[a].image)) : s.push(bs(r[a]));
+            i = this.data;
+        if (i !== null) {
+            let r;
+            if (Array.isArray(i)) {
+                r = [];
+                for (let o = 0, a = i.length; o < a; o++)
+                    i[o].isDataTexture ? r.push(ta(i[o].image)) : r.push(ta(i[o]));
             } else
-                s = bs(r);
-            n.url = s;
+                r = ta(i);
+            n.url = r;
         }
         return t || (e.images[this.uuid] = n), n;
     }
 }
 
-function bs(i) {
-    return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? Yl.getDataURL(i) : i.data ? {
-        data: Array.from(i.data),
-        width: i.width,
-        height: i.height,
-        type: i.data.constructor.name
+function ta(s) {
+    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Hc.getDataURL(s) : s.data ? {
+        data: Array.from(s.data),
+        width: s.width,
+        height: s.height,
+        type: s.data.constructor.name
     } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
 }
-let qf = 0;
-class Tt extends ui {
-    constructor(e = Tt.DEFAULT_IMAGE, t = Tt.DEFAULT_MAPPING, n = tn, r = tn, s = Ct, a = ni, o = Vt, l = Gn, c = Tt.DEFAULT_ANISOTROPY, u = Nn) {
+let Gf = 0;
+class Ot extends Ti {
+    constructor(e = Ot.DEFAULT_IMAGE, t = Ot.DEFAULT_MAPPING, n = dn, i = dn, r = Nt, o = mi, a = kt, l = In, c = Ot.DEFAULT_ANISOTROPY, u = Zn) {
         super(), this.isTexture = !0, Object.defineProperty(this, "id", {
-            value: qf++
-        }), this.uuid = Ki(), this.name = "", this.source = new jl(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new me(0, 0), this.repeat = new me(1, 1), this.center = new me(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new be(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
+            value: Gf++
+        }), this.uuid = ms(), this.name = "", this.source = new Gc(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = r, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Ee(0, 0), this.repeat = new Ee(1, 1), this.center = new Ee(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ue(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1;
     }
     get image() {
         return this.source.data;
     }
     set image(e = null) {
         this.source.data = e;
     }
@@ -2093,67 +2121,67 @@
     }
     dispose() {
         this.dispatchEvent({
             type: "dispose"
         });
     }
     transformUv(e) {
-        if (this.mapping !== Ol)
+        if (this.mapping !== Lc)
             return e;
         if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
             switch (this.wrapS) {
-                case to:
+                case Ua:
                     e.x = e.x - Math.floor(e.x);
                     break;
-                case tn:
+                case dn:
                     e.x = e.x < 0 ? 0 : 1;
                     break;
-                case no:
+                case Ba:
                     Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                     break;
             }
         if (e.y < 0 || e.y > 1)
             switch (this.wrapT) {
-                case to:
+                case Ua:
                     e.y = e.y - Math.floor(e.y);
                     break;
-                case tn:
+                case dn:
                     e.y = e.y < 0 ? 0 : 1;
                     break;
-                case no:
+                case Ba:
                     Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                     break;
             }
         return this.flipY && (e.y = 1 - e.y), e;
     }
     set needsUpdate(e) {
         e === !0 && (this.version++, this.source.needsUpdate = !0);
     }
 }
-Tt.DEFAULT_IMAGE = null;
-Tt.DEFAULT_MAPPING = Ol;
-Tt.DEFAULT_ANISOTROPY = 1;
-class ut {
-    constructor(e = 0, t = 0, n = 0, r = 1) {
-        ut.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = r;
+Ot.DEFAULT_IMAGE = null;
+Ot.DEFAULT_MAPPING = Lc;
+Ot.DEFAULT_ANISOTROPY = 1;
+class _t {
+    constructor(e = 0, t = 0, n = 0, i = 1) {
+        _t.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
     }
     get width() {
         return this.z;
     }
     set width(e) {
         this.z = e;
     }
     get height() {
         return this.w;
     }
     set height(e) {
         this.w = e;
     }
-    set(e, t, n, r) {
-        return this.x = e, this.y = t, this.z = n, this.w = r, this;
+    set(e, t, n, i) {
+        return this.x = e, this.y = t, this.z = n, this.w = i, this;
     }
     setScalar(e) {
         return this.x = e, this.y = e, this.z = e, this.w = e, this;
     }
     setX(e) {
         return this.x = e, this;
     }
@@ -2231,53 +2259,53 @@
     }
     multiplyScalar(e) {
         return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
     }
     applyMatrix4(e) {
         const t = this.x,
             n = this.y,
-            r = this.z,
-            s = this.w,
-            a = e.elements;
-        return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * s, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * s, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * s, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * s, this;
+            i = this.z,
+            r = this.w,
+            o = e.elements;
+        return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r, this;
     }
     divideScalar(e) {
         return this.multiplyScalar(1 / e);
     }
     setAxisAngleFromQuaternion(e) {
         this.w = 2 * Math.acos(e.w);
         const t = Math.sqrt(1 - e.w * e.w);
         return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
     }
     setAxisAngleFromRotationMatrix(e) {
-        let t, n, r, s;
+        let t, n, i, r;
         const l = e.elements,
             c = l[0],
             u = l[4],
-            f = l[8],
-            h = l[1],
-            p = l[5],
+            d = l[8],
+            f = l[1],
+            h = l[5],
             g = l[9],
-            v = l[2],
+            _ = l[2],
             m = l[6],
-            d = l[10];
-        if (Math.abs(u - h) < 0.01 && Math.abs(f - v) < 0.01 && Math.abs(g - m) < 0.01) {
-            if (Math.abs(u + h) < 0.1 && Math.abs(f + v) < 0.1 && Math.abs(g + m) < 0.1 && Math.abs(c + p + d - 3) < 0.1)
+            p = l[10];
+        if (Math.abs(u - f) < 0.01 && Math.abs(d - _) < 0.01 && Math.abs(g - m) < 0.01) {
+            if (Math.abs(u + f) < 0.1 && Math.abs(d + _) < 0.1 && Math.abs(g + m) < 0.1 && Math.abs(c + h + p - 3) < 0.1)
                 return this.set(1, 0, 0, 0), this;
             t = Math.PI;
-            const _ = (c + 1) / 2,
-                A = (p + 1) / 2,
-                R = (d + 1) / 2,
-                E = (u + h) / 4,
-                b = (f + v) / 4,
-                I = (g + m) / 4;
-            return _ > A && _ > R ? _ < 0.01 ? (n = 0, r = 0.707106781, s = 0.707106781) : (n = Math.sqrt(_), r = E / n, s = b / n) : A > R ? A < 0.01 ? (n = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(A), n = E / r, s = I / r) : R < 0.01 ? (n = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(R), n = b / s, r = I / s), this.set(n, r, s, t), this;
+            const S = (c + 1) / 2,
+                y = (h + 1) / 2,
+                b = (p + 1) / 2,
+                E = (u + f) / 4,
+                T = (d + _) / 4,
+                L = (g + m) / 4;
+            return S > y && S > b ? S < 0.01 ? (n = 0, i = 0.707106781, r = 0.707106781) : (n = Math.sqrt(S), i = E / n, r = T / n) : y > b ? y < 0.01 ? (n = 0.707106781, i = 0, r = 0.707106781) : (i = Math.sqrt(y), n = E / i, r = L / i) : b < 0.01 ? (n = 0.707106781, i = 0.707106781, r = 0) : (r = Math.sqrt(b), n = T / r, i = L / r), this.set(n, i, r, t), this;
         }
-        let M = Math.sqrt((m - g) * (m - g) + (f - v) * (f - v) + (h - u) * (h - u));
-        return Math.abs(M) < 1e-3 && (M = 1), this.x = (m - g) / M, this.y = (f - v) / M, this.z = (h - u) / M, this.w = Math.acos((c + p + d - 1) / 2), this;
+        let v = Math.sqrt((m - g) * (m - g) + (d - _) * (d - _) + (f - u) * (f - u));
+        return Math.abs(v) < 1e-3 && (v = 1), this.x = (m - g) / v, this.y = (d - _) / v, this.z = (f - u) / v, this.w = Math.acos((c + h + p - 1) / 2), this;
     }
     min(e) {
         return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
     }
     max(e) {
         return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
     }
@@ -2345,144 +2373,144 @@
     random() {
             return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
         }
         *[Symbol.iterator]() {
             yield this.x, yield this.y, yield this.z, yield this.w;
         }
 }
-class Yf extends ui {
+class Vf extends Ti {
     constructor(e = 1, t = 1, n = {}) {
-        super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new ut(0, 0, e, t), this.scissorTest = !1, this.viewport = new ut(0, 0, e, t);
-        const r = {
+        super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new _t(0, 0, e, t), this.scissorTest = !1, this.viewport = new _t(0, 0, e, t);
+        const i = {
             width: e,
             height: t,
             depth: 1
         };
         n = Object.assign({
             generateMipmaps: !1,
             internalFormat: null,
-            minFilter: Ct,
+            minFilter: Nt,
             depthBuffer: !0,
             stencilBuffer: !1,
             depthTexture: null,
             samples: 0,
             count: 1
         }, n);
-        const s = new Tt(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
-        s.flipY = !1, s.generateMipmaps = n.generateMipmaps, s.internalFormat = n.internalFormat, this.textures = [];
-        const a = n.count;
-        for (let o = 0; o < a; o++)
-            this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = !0;
+        const r = new Ot(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
+        r.flipY = !1, r.generateMipmaps = n.generateMipmaps, r.internalFormat = n.internalFormat, this.textures = [];
+        const o = n.count;
+        for (let a = 0; a < o; a++)
+            this.textures[a] = r.clone(), this.textures[a].isRenderTargetTexture = !0;
         this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples;
     }
     get texture() {
         return this.textures[0];
     }
     set texture(e) {
         this.textures[0] = e;
     }
     setSize(e, t, n = 1) {
         if (this.width !== e || this.height !== t || this.depth !== n) {
             this.width = e, this.height = t, this.depth = n;
-            for (let r = 0, s = this.textures.length; r < s; r++)
-                this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = n;
+            for (let i = 0, r = this.textures.length; i < r; i++)
+                this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
             this.dispose();
         }
         this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
     }
     clone() {
         return new this.constructor().copy(this);
     }
     copy(e) {
         this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
-        for (let n = 0, r = e.textures.length; n < r; n++)
+        for (let n = 0, i = e.textures.length; n < i; n++)
             this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
         const t = Object.assign({}, e.texture.image);
-        return this.texture.source = new jl(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
+        return this.texture.source = new Gc(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
     }
     dispose() {
         this.dispatchEvent({
             type: "dispose"
         });
     }
 }
-class Vn extends Yf {
+class ti extends Vf {
     constructor(e = 1, t = 1, n = {}) {
         super(e, t, n), this.isWebGLRenderTarget = !0;
     }
 }
-class Kl extends Tt {
-    constructor(e = null, t = 1, n = 1, r = 1) {
+class Vc extends Ot {
+    constructor(e = null, t = 1, n = 1, i = 1) {
         super(null), this.isDataArrayTexture = !0, this.image = {
             data: e,
             width: t,
             height: n,
-            depth: r
-        }, this.magFilter = vt, this.minFilter = vt, this.wrapR = tn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
+            depth: i
+        }, this.magFilter = bt, this.minFilter = bt, this.wrapR = dn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
     }
 }
-class jf extends Tt {
-    constructor(e = null, t = 1, n = 1, r = 1) {
+class Wf extends Ot {
+    constructor(e = null, t = 1, n = 1, i = 1) {
         super(null), this.isData3DTexture = !0, this.image = {
             data: e,
             width: t,
             height: n,
-            depth: r
-        }, this.magFilter = vt, this.minFilter = vt, this.wrapR = tn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
+            depth: i
+        }, this.magFilter = bt, this.minFilter = bt, this.wrapR = dn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
     }
 }
-class wt {
-    constructor(e = 0, t = 0, n = 0, r = 1) {
-        this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = r;
-    }
-    static slerpFlat(e, t, n, r, s, a, o) {
-        let l = n[r + 0],
-            c = n[r + 1],
-            u = n[r + 2],
-            f = n[r + 3];
-        const h = s[a + 0],
-            p = s[a + 1],
-            g = s[a + 2],
-            v = s[a + 3];
-        if (o === 0) {
-            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f;
+class St {
+    constructor(e = 0, t = 0, n = 0, i = 1) {
+        this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
+    }
+    static slerpFlat(e, t, n, i, r, o, a) {
+        let l = n[i + 0],
+            c = n[i + 1],
+            u = n[i + 2],
+            d = n[i + 3];
+        const f = r[o + 0],
+            h = r[o + 1],
+            g = r[o + 2],
+            _ = r[o + 3];
+        if (a === 0) {
+            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d;
             return;
         }
-        if (o === 1) {
-            e[t + 0] = h, e[t + 1] = p, e[t + 2] = g, e[t + 3] = v;
+        if (a === 1) {
+            e[t + 0] = f, e[t + 1] = h, e[t + 2] = g, e[t + 3] = _;
             return;
         }
-        if (f !== v || l !== h || c !== p || u !== g) {
-            let m = 1 - o;
-            const d = l * h + c * p + u * g + f * v,
-                M = d >= 0 ? 1 : -1,
-                _ = 1 - d * d;
-            if (_ > Number.EPSILON) {
-                const R = Math.sqrt(_),
-                    E = Math.atan2(R, d * M);
-                m = Math.sin(m * E) / R, o = Math.sin(o * E) / R;
-            }
-            const A = o * M;
-            if (l = l * m + h * A, c = c * m + p * A, u = u * m + g * A, f = f * m + v * A, m === 1 - o) {
-                const R = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
-                l *= R, c *= R, u *= R, f *= R;
-            }
-        }
-        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f;
-    }
-    static multiplyQuaternionsFlat(e, t, n, r, s, a) {
-        const o = n[r],
-            l = n[r + 1],
-            c = n[r + 2],
-            u = n[r + 3],
-            f = s[a],
-            h = s[a + 1],
-            p = s[a + 2],
-            g = s[a + 3];
-        return e[t] = o * g + u * f + l * p - c * h, e[t + 1] = l * g + u * h + c * f - o * p, e[t + 2] = c * g + u * p + o * h - l * f, e[t + 3] = u * g - o * f - l * h - c * p, e;
+        if (d !== _ || l !== f || c !== h || u !== g) {
+            let m = 1 - a;
+            const p = l * f + c * h + u * g + d * _,
+                v = p >= 0 ? 1 : -1,
+                S = 1 - p * p;
+            if (S > Number.EPSILON) {
+                const b = Math.sqrt(S),
+                    E = Math.atan2(b, p * v);
+                m = Math.sin(m * E) / b, a = Math.sin(a * E) / b;
+            }
+            const y = a * v;
+            if (l = l * m + f * y, c = c * m + h * y, u = u * m + g * y, d = d * m + _ * y, m === 1 - a) {
+                const b = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
+                l *= b, c *= b, u *= b, d *= b;
+            }
+        }
+        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = d;
+    }
+    static multiplyQuaternionsFlat(e, t, n, i, r, o) {
+        const a = n[i],
+            l = n[i + 1],
+            c = n[i + 2],
+            u = n[i + 3],
+            d = r[o],
+            f = r[o + 1],
+            h = r[o + 2],
+            g = r[o + 3];
+        return e[t] = a * g + u * d + l * h - c * f, e[t + 1] = l * g + u * f + c * d - a * h, e[t + 2] = c * g + u * h + a * f - l * d, e[t + 3] = u * g - a * d - l * f - c * h, e;
     }
     get x() {
         return this._x;
     }
     set x(e) {
         this._x = e, this._onChangeCallback();
     }
@@ -2500,105 +2528,105 @@
     }
     get w() {
         return this._w;
     }
     set w(e) {
         this._w = e, this._onChangeCallback();
     }
-    set(e, t, n, r) {
-        return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this;
+    set(e, t, n, i) {
+        return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
     }
     clone() {
         return new this.constructor(this._x, this._y, this._z, this._w);
     }
     copy(e) {
         return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
     }
     setFromEuler(e, t = !0) {
         const n = e._x,
-            r = e._y,
-            s = e._z,
-            a = e._order,
-            o = Math.cos,
+            i = e._y,
+            r = e._z,
+            o = e._order,
+            a = Math.cos,
             l = Math.sin,
-            c = o(n / 2),
-            u = o(r / 2),
-            f = o(s / 2),
-            h = l(n / 2),
-            p = l(r / 2),
-            g = l(s / 2);
-        switch (a) {
+            c = a(n / 2),
+            u = a(i / 2),
+            d = a(r / 2),
+            f = l(n / 2),
+            h = l(i / 2),
+            g = l(r / 2);
+        switch (o) {
             case "XYZ":
-                this._x = h * u * f + c * p * g, this._y = c * p * f - h * u * g, this._z = c * u * g + h * p * f, this._w = c * u * f - h * p * g;
+                this._x = f * u * d + c * h * g, this._y = c * h * d - f * u * g, this._z = c * u * g + f * h * d, this._w = c * u * d - f * h * g;
                 break;
             case "YXZ":
-                this._x = h * u * f + c * p * g, this._y = c * p * f - h * u * g, this._z = c * u * g - h * p * f, this._w = c * u * f + h * p * g;
+                this._x = f * u * d + c * h * g, this._y = c * h * d - f * u * g, this._z = c * u * g - f * h * d, this._w = c * u * d + f * h * g;
                 break;
             case "ZXY":
-                this._x = h * u * f - c * p * g, this._y = c * p * f + h * u * g, this._z = c * u * g + h * p * f, this._w = c * u * f - h * p * g;
+                this._x = f * u * d - c * h * g, this._y = c * h * d + f * u * g, this._z = c * u * g + f * h * d, this._w = c * u * d - f * h * g;
                 break;
             case "ZYX":
-                this._x = h * u * f - c * p * g, this._y = c * p * f + h * u * g, this._z = c * u * g - h * p * f, this._w = c * u * f + h * p * g;
+                this._x = f * u * d - c * h * g, this._y = c * h * d + f * u * g, this._z = c * u * g - f * h * d, this._w = c * u * d + f * h * g;
                 break;
             case "YZX":
-                this._x = h * u * f + c * p * g, this._y = c * p * f + h * u * g, this._z = c * u * g - h * p * f, this._w = c * u * f - h * p * g;
+                this._x = f * u * d + c * h * g, this._y = c * h * d + f * u * g, this._z = c * u * g - f * h * d, this._w = c * u * d - f * h * g;
                 break;
             case "XZY":
-                this._x = h * u * f - c * p * g, this._y = c * p * f - h * u * g, this._z = c * u * g + h * p * f, this._w = c * u * f + h * p * g;
+                this._x = f * u * d - c * h * g, this._y = c * h * d - f * u * g, this._z = c * u * g + f * h * d, this._w = c * u * d + f * h * g;
                 break;
             default:
-                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
+                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
         }
         return t === !0 && this._onChangeCallback(), this;
     }
     setFromAxisAngle(e, t) {
         const n = t / 2,
-            r = Math.sin(n);
-        return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
+            i = Math.sin(n);
+        return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
     }
     setFromRotationMatrix(e) {
         const t = e.elements,
             n = t[0],
-            r = t[4],
-            s = t[8],
-            a = t[1],
-            o = t[5],
+            i = t[4],
+            r = t[8],
+            o = t[1],
+            a = t[5],
             l = t[9],
             c = t[2],
             u = t[6],
-            f = t[10],
-            h = n + o + f;
-        if (h > 0) {
-            const p = 0.5 / Math.sqrt(h + 1);
-            this._w = 0.25 / p, this._x = (u - l) * p, this._y = (s - c) * p, this._z = (a - r) * p;
-        } else if (n > o && n > f) {
-            const p = 2 * Math.sqrt(1 + n - o - f);
-            this._w = (u - l) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (s + c) / p;
-        } else if (o > f) {
-            const p = 2 * Math.sqrt(1 + o - n - f);
-            this._w = (s - c) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (l + u) / p;
+            d = t[10],
+            f = n + a + d;
+        if (f > 0) {
+            const h = 0.5 / Math.sqrt(f + 1);
+            this._w = 0.25 / h, this._x = (u - l) * h, this._y = (r - c) * h, this._z = (o - i) * h;
+        } else if (n > a && n > d) {
+            const h = 2 * Math.sqrt(1 + n - a - d);
+            this._w = (u - l) / h, this._x = 0.25 * h, this._y = (i + o) / h, this._z = (r + c) / h;
+        } else if (a > d) {
+            const h = 2 * Math.sqrt(1 + a - n - d);
+            this._w = (r - c) / h, this._x = (i + o) / h, this._y = 0.25 * h, this._z = (l + u) / h;
         } else {
-            const p = 2 * Math.sqrt(1 + f - n - o);
-            this._w = (a - r) / p, this._x = (s + c) / p, this._y = (l + u) / p, this._z = 0.25 * p;
+            const h = 2 * Math.sqrt(1 + d - n - a);
+            this._w = (o - i) / h, this._x = (r + c) / h, this._y = (l + u) / h, this._z = 0.25 * h;
         }
         return this._onChangeCallback(), this;
     }
     setFromUnitVectors(e, t) {
         let n = e.dot(t) + 1;
         return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
     }
     angleTo(e) {
-        return 2 * Math.acos(Math.abs(xt(this.dot(e), -1, 1)));
+        return 2 * Math.acos(Math.abs(Ct(this.dot(e), -1, 1)));
     }
     rotateTowards(e, t) {
         const n = this.angleTo(e);
         if (n === 0)
             return this;
-        const r = Math.min(1, t / n);
-        return this.slerp(e, r), this;
+        const i = Math.min(1, t / n);
+        return this.slerp(e, i), this;
     }
     identity() {
         return this.set(0, 0, 0, 1);
     }
     invert() {
         return this.conjugate();
     }
@@ -2622,60 +2650,60 @@
         return this.multiplyQuaternions(this, e);
     }
     premultiply(e) {
         return this.multiplyQuaternions(e, this);
     }
     multiplyQuaternions(e, t) {
         const n = e._x,
-            r = e._y,
-            s = e._z,
-            a = e._w,
-            o = t._x,
+            i = e._y,
+            r = e._z,
+            o = e._w,
+            a = t._x,
             l = t._y,
             c = t._z,
             u = t._w;
-        return this._x = n * u + a * o + r * c - s * l, this._y = r * u + a * l + s * o - n * c, this._z = s * u + a * c + n * l - r * o, this._w = a * u - n * o - r * l - s * c, this._onChangeCallback(), this;
+        return this._x = n * u + o * a + i * c - r * l, this._y = i * u + o * l + r * a - n * c, this._z = r * u + o * c + n * l - i * a, this._w = o * u - n * a - i * l - r * c, this._onChangeCallback(), this;
     }
     slerp(e, t) {
         if (t === 0)
             return this;
         if (t === 1)
             return this.copy(e);
         const n = this._x,
-            r = this._y,
-            s = this._z,
-            a = this._w;
-        let o = a * e._w + n * e._x + r * e._y + s * e._z;
-        if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1)
-            return this._w = a, this._x = n, this._y = r, this._z = s, this;
-        const l = 1 - o * o;
+            i = this._y,
+            r = this._z,
+            o = this._w;
+        let a = o * e._w + n * e._x + i * e._y + r * e._z;
+        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1)
+            return this._w = o, this._x = n, this._y = i, this._z = r, this;
+        const l = 1 - a * a;
         if (l <= Number.EPSILON) {
-            const p = 1 - t;
-            return this._w = p * a + t * this._w, this._x = p * n + t * this._x, this._y = p * r + t * this._y, this._z = p * s + t * this._z, this.normalize(), this;
+            const h = 1 - t;
+            return this._w = h * o + t * this._w, this._x = h * n + t * this._x, this._y = h * i + t * this._y, this._z = h * r + t * this._z, this.normalize(), this;
         }
         const c = Math.sqrt(l),
-            u = Math.atan2(c, o),
-            f = Math.sin((1 - t) * u) / c,
-            h = Math.sin(t * u) / c;
-        return this._w = a * f + this._w * h, this._x = n * f + this._x * h, this._y = r * f + this._y * h, this._z = s * f + this._z * h, this._onChangeCallback(), this;
+            u = Math.atan2(c, a),
+            d = Math.sin((1 - t) * u) / c,
+            f = Math.sin(t * u) / c;
+        return this._w = o * d + this._w * f, this._x = n * d + this._x * f, this._y = i * d + this._y * f, this._z = r * d + this._z * f, this._onChangeCallback(), this;
     }
     slerpQuaternions(e, t, n) {
         return this.copy(e).slerp(t, n);
     }
     random() {
         const e = 2 * Math.PI * Math.random(),
             t = 2 * Math.PI * Math.random(),
             n = Math.random(),
-            r = Math.sqrt(1 - n),
-            s = Math.sqrt(n);
+            i = Math.sqrt(1 - n),
+            r = Math.sqrt(n);
         return this.set(
-            r * Math.sin(e),
-            r * Math.cos(e),
-            s * Math.sin(t),
-            s * Math.cos(t)
+            i * Math.sin(e),
+            i * Math.cos(e),
+            r * Math.sin(t),
+            r * Math.cos(t)
         );
     }
     equals(e) {
         return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
     }
     fromArray(e, t = 0) {
         return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
@@ -2693,17 +2721,17 @@
         return this._onChangeCallback = e, this;
     }
     _onChangeCallback() {}
         *[Symbol.iterator]() {
             yield this._x, yield this._y, yield this._z, yield this._w;
         }
 }
-class P {
+class D {
     constructor(e = 0, t = 0, n = 0) {
-        P.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
+        D.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
     }
     set(e, t, n) {
         return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
     }
     setScalar(e) {
         return this.x = e, this.y = e, this.z = e, this;
     }
@@ -2777,62 +2805,62 @@
     multiplyScalar(e) {
         return this.x *= e, this.y *= e, this.z *= e, this;
     }
     multiplyVectors(e, t) {
         return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
     }
     applyEuler(e) {
-        return this.applyQuaternion(xa.setFromEuler(e));
+        return this.applyQuaternion(ol.setFromEuler(e));
     }
     applyAxisAngle(e, t) {
-        return this.applyQuaternion(xa.setFromAxisAngle(e, t));
+        return this.applyQuaternion(ol.setFromAxisAngle(e, t));
     }
     applyMatrix3(e) {
         const t = this.x,
             n = this.y,
-            r = this.z,
-            s = e.elements;
-        return this.x = s[0] * t + s[3] * n + s[6] * r, this.y = s[1] * t + s[4] * n + s[7] * r, this.z = s[2] * t + s[5] * n + s[8] * r, this;
+            i = this.z,
+            r = e.elements;
+        return this.x = r[0] * t + r[3] * n + r[6] * i, this.y = r[1] * t + r[4] * n + r[7] * i, this.z = r[2] * t + r[5] * n + r[8] * i, this;
     }
     applyNormalMatrix(e) {
         return this.applyMatrix3(e).normalize();
     }
     applyMatrix4(e) {
         const t = this.x,
             n = this.y,
-            r = this.z,
-            s = e.elements,
-            a = 1 / (s[3] * t + s[7] * n + s[11] * r + s[15]);
-        return this.x = (s[0] * t + s[4] * n + s[8] * r + s[12]) * a, this.y = (s[1] * t + s[5] * n + s[9] * r + s[13]) * a, this.z = (s[2] * t + s[6] * n + s[10] * r + s[14]) * a, this;
+            i = this.z,
+            r = e.elements,
+            o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
+        return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o, this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o, this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o, this;
     }
     applyQuaternion(e) {
         const t = this.x,
             n = this.y,
-            r = this.z,
-            s = e.x,
-            a = e.y,
-            o = e.z,
+            i = this.z,
+            r = e.x,
+            o = e.y,
+            a = e.z,
             l = e.w,
-            c = 2 * (a * r - o * n),
-            u = 2 * (o * t - s * r),
-            f = 2 * (s * n - a * t);
-        return this.x = t + l * c + a * f - o * u, this.y = n + l * u + o * c - s * f, this.z = r + l * f + s * u - a * c, this;
+            c = 2 * (o * i - a * n),
+            u = 2 * (a * t - r * i),
+            d = 2 * (r * n - o * t);
+        return this.x = t + l * c + o * d - a * u, this.y = n + l * u + a * c - r * d, this.z = i + l * d + r * u - o * c, this;
     }
     project(e) {
         return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
     }
     unproject(e) {
         return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
     }
     transformDirection(e) {
         const t = this.x,
             n = this.y,
-            r = this.z,
-            s = e.elements;
-        return this.x = s[0] * t + s[4] * n + s[8] * r, this.y = s[1] * t + s[5] * n + s[9] * r, this.z = s[2] * t + s[6] * n + s[10] * r, this.normalize();
+            i = this.z,
+            r = e.elements;
+        return this.x = r[0] * t + r[4] * n + r[8] * i, this.y = r[1] * t + r[5] * n + r[9] * i, this.z = r[2] * t + r[6] * n + r[10] * i, this.normalize();
     }
     divide(e) {
         return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
     }
     divideScalar(e) {
         return this.multiplyScalar(1 / e);
     }
@@ -2893,75 +2921,75 @@
         return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
     }
     cross(e) {
         return this.crossVectors(this, e);
     }
     crossVectors(e, t) {
         const n = e.x,
-            r = e.y,
-            s = e.z,
-            a = t.x,
-            o = t.y,
+            i = e.y,
+            r = e.z,
+            o = t.x,
+            a = t.y,
             l = t.z;
-        return this.x = r * l - s * o, this.y = s * a - n * l, this.z = n * o - r * a, this;
+        return this.x = i * l - r * a, this.y = r * o - n * l, this.z = n * a - i * o, this;
     }
     projectOnVector(e) {
         const t = e.lengthSq();
         if (t === 0)
             return this.set(0, 0, 0);
         const n = e.dot(this) / t;
         return this.copy(e).multiplyScalar(n);
     }
     projectOnPlane(e) {
-        return Ts.copy(this).projectOnVector(e), this.sub(Ts);
+        return na.copy(this).projectOnVector(e), this.sub(na);
     }
     reflect(e) {
-        return this.sub(Ts.copy(e).multiplyScalar(2 * this.dot(e)));
+        return this.sub(na.copy(e).multiplyScalar(2 * this.dot(e)));
     }
     angleTo(e) {
         const t = Math.sqrt(this.lengthSq() * e.lengthSq());
         if (t === 0)
             return Math.PI / 2;
         const n = this.dot(e) / t;
-        return Math.acos(xt(n, -1, 1));
+        return Math.acos(Ct(n, -1, 1));
     }
     distanceTo(e) {
         return Math.sqrt(this.distanceToSquared(e));
     }
     distanceToSquared(e) {
         const t = this.x - e.x,
             n = this.y - e.y,
-            r = this.z - e.z;
-        return t * t + n * n + r * r;
+            i = this.z - e.z;
+        return t * t + n * n + i * i;
     }
     manhattanDistanceTo(e) {
         return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
     }
     setFromSpherical(e) {
         return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
     }
     setFromSphericalCoords(e, t, n) {
-        const r = Math.sin(t) * e;
-        return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this;
+        const i = Math.sin(t) * e;
+        return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
     }
     setFromCylindrical(e) {
         return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
     }
     setFromCylindricalCoords(e, t, n) {
         return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
     }
     setFromMatrixPosition(e) {
         const t = e.elements;
         return this.x = t[12], this.y = t[13], this.z = t[14], this;
     }
     setFromMatrixScale(e) {
         const t = this.setFromMatrixColumn(e, 0).length(),
             n = this.setFromMatrixColumn(e, 1).length(),
-            r = this.setFromMatrixColumn(e, 2).length();
-        return this.x = t, this.y = n, this.z = r, this;
+            i = this.setFromMatrixColumn(e, 2).length();
+        return this.x = t, this.y = n, this.z = i, this;
     }
     setFromMatrixColumn(e, t) {
         return this.fromArray(e.elements, t * 4);
     }
     setFromMatrix3Column(e, t) {
         return this.fromArray(e.elements, t * 3);
     }
@@ -2992,43 +3020,43 @@
                 n = Math.sqrt(1 - t * t);
             return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
         }
         *[Symbol.iterator]() {
             yield this.x, yield this.y, yield this.z;
         }
 }
-const Ts = /* @__PURE__ */ new P(),
-    xa = /* @__PURE__ */ new wt();
-class Rt {
-    constructor(e = new P(1 / 0, 1 / 0, 1 / 0), t = new P(-1 / 0, -1 / 0, -1 / 0)) {
+const na = /* @__PURE__ */ new D(),
+    ol = /* @__PURE__ */ new St();
+class Un {
+    constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
         this.isBox3 = !0, this.min = e, this.max = t;
     }
     set(e, t) {
         return this.min.copy(e), this.max.copy(t), this;
     }
     setFromArray(e) {
         this.makeEmpty();
         for (let t = 0, n = e.length; t < n; t += 3)
-            this.expandByPoint(jt.fromArray(e, t));
+            this.expandByPoint(rn.fromArray(e, t));
         return this;
     }
     setFromBufferAttribute(e) {
         this.makeEmpty();
         for (let t = 0, n = e.count; t < n; t++)
-            this.expandByPoint(jt.fromBufferAttribute(e, t));
+            this.expandByPoint(rn.fromBufferAttribute(e, t));
         return this;
     }
     setFromPoints(e) {
         this.makeEmpty();
         for (let t = 0, n = e.length; t < n; t++)
             this.expandByPoint(e[t]);
         return this;
     }
     setFromCenterAndSize(e, t) {
-        const n = jt.copy(t).multiplyScalar(0.5);
+        const n = rn.copy(t).multiplyScalar(0.5);
         return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
     }
     setFromObject(e, t = !1) {
         return this.makeEmpty(), this.expandByObject(e, t);
     }
     clone() {
         return new this.constructor().copy(this);
@@ -3057,24 +3085,24 @@
     expandByScalar(e) {
         return this.min.addScalar(-e), this.max.addScalar(e), this;
     }
     expandByObject(e, t = !1) {
         e.updateWorldMatrix(!1, !1);
         const n = e.geometry;
         if (n !== void 0) {
-            const s = n.getAttribute("position");
-            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
-                for (let a = 0, o = s.count; a < o; a++)
-                    e.isMesh === !0 ? e.getVertexPosition(a, jt) : jt.fromBufferAttribute(s, a), jt.applyMatrix4(e.matrixWorld), this.expandByPoint(jt);
+            const r = n.getAttribute("position");
+            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
+                for (let o = 0, a = r.count; o < a; o++)
+                    e.isMesh === !0 ? e.getVertexPosition(o, rn) : rn.fromBufferAttribute(r, o), rn.applyMatrix4(e.matrixWorld), this.expandByPoint(rn);
             else
-                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), _r.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), _r.copy(n.boundingBox)), _r.applyMatrix4(e.matrixWorld), this.union(_r);
+                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), zs.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), zs.copy(n.boundingBox)), zs.applyMatrix4(e.matrixWorld), this.union(zs);
         }
-        const r = e.children;
-        for (let s = 0, a = r.length; s < a; s++)
-            this.expandByObject(r[s], t);
+        const i = e.children;
+        for (let r = 0, o = i.length; r < o; r++)
+            this.expandByObject(i[r], t);
         return this;
     }
     containsPoint(e) {
         return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
     }
     containsBox(e) {
         return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
@@ -3086,140 +3114,140 @@
             (e.z - this.min.z) / (this.max.z - this.min.z)
         );
     }
     intersectsBox(e) {
         return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
     }
     intersectsSphere(e) {
-        return this.clampPoint(e.center, jt), jt.distanceToSquared(e.center) <= e.radius * e.radius;
+        return this.clampPoint(e.center, rn), rn.distanceToSquared(e.center) <= e.radius * e.radius;
     }
     intersectsPlane(e) {
         let t, n;
         return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
     }
     intersectsTriangle(e) {
         if (this.isEmpty())
             return !1;
-        this.getCenter(tr), vr.subVectors(this.max, tr), mi.subVectors(e.a, tr), gi.subVectors(e.b, tr), _i.subVectors(e.c, tr), Rn.subVectors(gi, mi), Pn.subVectors(_i, gi), Yn.subVectors(mi, _i);
+        this.getCenter(ys), Hs.subVectors(this.max, ys), Pi.subVectors(e.a, ys), Di.subVectors(e.b, ys), Li.subVectors(e.c, ys), Gn.subVectors(Di, Pi), Vn.subVectors(Li, Di), ri.subVectors(Pi, Li);
         let t = [
             0,
-            -Rn.z,
-            Rn.y,
+            -Gn.z,
+            Gn.y,
             0,
-            -Pn.z,
-            Pn.y,
+            -Vn.z,
+            Vn.y,
             0,
-            -Yn.z,
-            Yn.y,
-            Rn.z,
+            -ri.z,
+            ri.y,
+            Gn.z,
             0,
-            -Rn.x,
-            Pn.z,
+            -Gn.x,
+            Vn.z,
             0,
-            -Pn.x,
-            Yn.z,
+            -Vn.x,
+            ri.z,
             0,
-            -Yn.x,
-            -Rn.y,
-            Rn.x,
+            -ri.x,
+            -Gn.y,
+            Gn.x,
             0,
-            -Pn.y,
-            Pn.x,
+            -Vn.y,
+            Vn.x,
             0,
-            -Yn.y,
-            Yn.x,
+            -ri.y,
+            ri.x,
             0
         ];
-        return !ws(t, mi, gi, _i, vr) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ws(t, mi, gi, _i, vr)) ? !1 : (xr.crossVectors(Rn, Pn), t = [xr.x, xr.y, xr.z], ws(t, mi, gi, _i, vr));
+        return !ia(t, Pi, Di, Li, Hs) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !ia(t, Pi, Di, Li, Hs)) ? !1 : (Gs.crossVectors(Gn, Vn), t = [Gs.x, Gs.y, Gs.z], ia(t, Pi, Di, Li, Hs));
     }
     clampPoint(e, t) {
         return t.copy(e).clamp(this.min, this.max);
     }
     distanceToPoint(e) {
-        return this.clampPoint(e, jt).distanceTo(e);
+        return this.clampPoint(e, rn).distanceTo(e);
     }
     getBoundingSphere(e) {
-        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(jt).length() * 0.5), e;
+        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(rn).length() * 0.5), e;
     }
     intersect(e) {
         return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
     }
     union(e) {
         return this.min.min(e.min), this.max.max(e.max), this;
     }
     applyMatrix4(e) {
-        return this.isEmpty() ? this : (pn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), pn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), pn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), pn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), pn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), pn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), pn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), pn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(pn), this);
+        return this.isEmpty() ? this : (En[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), En[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), En[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), En[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), En[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), En[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), En[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), En[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(En), this);
     }
     translate(e) {
         return this.min.add(e), this.max.add(e), this;
     }
     equals(e) {
         return e.min.equals(this.min) && e.max.equals(this.max);
     }
 }
-const pn = [
+const En = [
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P(),
+        new D(),
         /* @__PURE__ */
-        new P()
+        new D()
     ],
-    jt = /* @__PURE__ */ new P(),
-    _r = /* @__PURE__ */ new Rt(),
-    mi = /* @__PURE__ */ new P(),
-    gi = /* @__PURE__ */ new P(),
-    _i = /* @__PURE__ */ new P(),
-    Rn = /* @__PURE__ */ new P(),
-    Pn = /* @__PURE__ */ new P(),
-    Yn = /* @__PURE__ */ new P(),
-    tr = /* @__PURE__ */ new P(),
-    vr = /* @__PURE__ */ new P(),
-    xr = /* @__PURE__ */ new P(),
-    jn = /* @__PURE__ */ new P();
-
-function ws(i, e, t, n, r) {
-    for (let s = 0, a = i.length - 3; s <= a; s += 3) {
-        jn.fromArray(i, s);
-        const o = r.x * Math.abs(jn.x) + r.y * Math.abs(jn.y) + r.z * Math.abs(jn.z),
-            l = e.dot(jn),
-            c = t.dot(jn),
-            u = n.dot(jn);
-        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o)
+    rn = /* @__PURE__ */ new D(),
+    zs = /* @__PURE__ */ new Un(),
+    Pi = /* @__PURE__ */ new D(),
+    Di = /* @__PURE__ */ new D(),
+    Li = /* @__PURE__ */ new D(),
+    Gn = /* @__PURE__ */ new D(),
+    Vn = /* @__PURE__ */ new D(),
+    ri = /* @__PURE__ */ new D(),
+    ys = /* @__PURE__ */ new D(),
+    Hs = /* @__PURE__ */ new D(),
+    Gs = /* @__PURE__ */ new D(),
+    ai = /* @__PURE__ */ new D();
+
+function ia(s, e, t, n, i) {
+    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
+        ai.fromArray(s, r);
+        const a = i.x * Math.abs(ai.x) + i.y * Math.abs(ai.y) + i.z * Math.abs(ai.z),
+            l = e.dot(ai),
+            c = t.dot(ai),
+            u = n.dot(ai);
+        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a)
             return !1;
     }
     return !0;
 }
-const Kf = /* @__PURE__ */ new Rt(),
-    nr = /* @__PURE__ */ new P(),
-    Cs = /* @__PURE__ */ new P();
-class _o {
-    constructor(e = new P(), t = -1) {
+const Xf = /* @__PURE__ */ new Un(),
+    Ms = /* @__PURE__ */ new D(),
+    sa = /* @__PURE__ */ new D();
+class $a {
+    constructor(e = new D(), t = -1) {
         this.isSphere = !0, this.center = e, this.radius = t;
     }
     set(e, t) {
         return this.center.copy(e), this.radius = t, this;
     }
     setFromPoints(e, t) {
         const n = this.center;
-        t !== void 0 ? n.copy(t) : Kf.setFromPoints(e).getCenter(n);
-        let r = 0;
-        for (let s = 0, a = e.length; s < a; s++)
-            r = Math.max(r, n.distanceToSquared(e[s]));
-        return this.radius = Math.sqrt(r), this;
+        t !== void 0 ? n.copy(t) : Xf.setFromPoints(e).getCenter(n);
+        let i = 0;
+        for (let r = 0, o = e.length; r < o; r++)
+            i = Math.max(i, n.distanceToSquared(e[r]));
+        return this.radius = Math.sqrt(i), this;
     }
     copy(e) {
         return this.center.copy(e.center), this.radius = e.radius, this;
     }
     isEmpty() {
         return this.radius < 0;
     }
@@ -3254,42 +3282,42 @@
     }
     translate(e) {
         return this.center.add(e), this;
     }
     expandByPoint(e) {
         if (this.isEmpty())
             return this.center.copy(e), this.radius = 0, this;
-        nr.subVectors(e, this.center);
-        const t = nr.lengthSq();
+        Ms.subVectors(e, this.center);
+        const t = Ms.lengthSq();
         if (t > this.radius * this.radius) {
             const n = Math.sqrt(t),
-                r = (n - this.radius) * 0.5;
-            this.center.addScaledVector(nr, r / n), this.radius += r;
+                i = (n - this.radius) * 0.5;
+            this.center.addScaledVector(Ms, i / n), this.radius += i;
         }
         return this;
     }
     union(e) {
-        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Cs.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(nr.copy(e.center).add(Cs)), this.expandByPoint(nr.copy(e.center).sub(Cs))), this);
+        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (sa.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Ms.copy(e.center).add(sa)), this.expandByPoint(Ms.copy(e.center).sub(sa))), this);
     }
     equals(e) {
         return e.center.equals(this.center) && e.radius === this.radius;
     }
     clone() {
         return new this.constructor().copy(this);
     }
 }
-const mn = /* @__PURE__ */ new P(),
-    Rs = /* @__PURE__ */ new P(),
-    Sr = /* @__PURE__ */ new P(),
-    Ln = /* @__PURE__ */ new P(),
-    Ps = /* @__PURE__ */ new P(),
-    Mr = /* @__PURE__ */ new P(),
-    Ls = /* @__PURE__ */ new P();
-let Ql = class {
-    constructor(e = new P(), t = new P(0, 0, -1)) {
+const An = /* @__PURE__ */ new D(),
+    ra = /* @__PURE__ */ new D(),
+    Vs = /* @__PURE__ */ new D(),
+    Wn = /* @__PURE__ */ new D(),
+    aa = /* @__PURE__ */ new D(),
+    Ws = /* @__PURE__ */ new D(),
+    oa = /* @__PURE__ */ new D();
+let Wc = class {
+    constructor(e = new D(), t = new D(0, 0, -1)) {
         this.origin = e, this.direction = t;
     }
     set(e, t) {
         return this.origin.copy(e), this.direction.copy(t), this;
     }
     copy(e) {
         return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
@@ -3297,64 +3325,64 @@
     at(e, t) {
         return t.copy(this.origin).addScaledVector(this.direction, e);
     }
     lookAt(e) {
         return this.direction.copy(e).sub(this.origin).normalize(), this;
     }
     recast(e) {
-        return this.origin.copy(this.at(e, mn)), this;
+        return this.origin.copy(this.at(e, An)), this;
     }
     closestPointToPoint(e, t) {
         t.subVectors(e, this.origin);
         const n = t.dot(this.direction);
         return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
     }
     distanceToPoint(e) {
         return Math.sqrt(this.distanceSqToPoint(e));
     }
     distanceSqToPoint(e) {
-        const t = mn.subVectors(e, this.origin).dot(this.direction);
-        return t < 0 ? this.origin.distanceToSquared(e) : (mn.copy(this.origin).addScaledVector(this.direction, t), mn.distanceToSquared(e));
+        const t = An.subVectors(e, this.origin).dot(this.direction);
+        return t < 0 ? this.origin.distanceToSquared(e) : (An.copy(this.origin).addScaledVector(this.direction, t), An.distanceToSquared(e));
     }
-    distanceSqToSegment(e, t, n, r) {
-        Rs.copy(e).add(t).multiplyScalar(0.5), Sr.copy(t).sub(e).normalize(), Ln.copy(this.origin).sub(Rs);
-        const s = e.distanceTo(t) * 0.5,
-            a = -this.direction.dot(Sr),
-            o = Ln.dot(this.direction),
-            l = -Ln.dot(Sr),
-            c = Ln.lengthSq(),
-            u = Math.abs(1 - a * a);
-        let f, h, p, g;
+    distanceSqToSegment(e, t, n, i) {
+        ra.copy(e).add(t).multiplyScalar(0.5), Vs.copy(t).sub(e).normalize(), Wn.copy(this.origin).sub(ra);
+        const r = e.distanceTo(t) * 0.5,
+            o = -this.direction.dot(Vs),
+            a = Wn.dot(this.direction),
+            l = -Wn.dot(Vs),
+            c = Wn.lengthSq(),
+            u = Math.abs(1 - o * o);
+        let d, f, h, g;
         if (u > 0)
-            if (f = a * l - o, h = a * o - l, g = s * u, f >= 0)
-                if (h >= -g)
-                    if (h <= g) {
-                        const v = 1 / u;
-                        f *= v, h *= v, p = f * (f + a * h + 2 * o) + h * (a * f + h + 2 * l) + c;
+            if (d = o * l - a, f = o * a - l, g = r * u, d >= 0)
+                if (f >= -g)
+                    if (f <= g) {
+                        const _ = 1 / u;
+                        d *= _, f *= _, h = d * (d + o * f + 2 * a) + f * (o * d + f + 2 * l) + c;
                     } else
-                        h = s, f = Math.max(0, -(a * h + o)), p = -f * f + h * (h + 2 * l) + c;
+                        f = r, d = Math.max(0, -(o * f + a)), h = -d * d + f * (f + 2 * l) + c;
         else
-            h = -s, f = Math.max(0, -(a * h + o)), p = -f * f + h * (h + 2 * l) + c;
+            f = -r, d = Math.max(0, -(o * f + a)), h = -d * d + f * (f + 2 * l) + c;
         else
-            h <= -g ? (f = Math.max(0, -(-a * s + o)), h = f > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -f * f + h * (h + 2 * l) + c) : h <= g ? (f = 0, h = Math.min(Math.max(-s, -l), s), p = h * (h + 2 * l) + c) : (f = Math.max(0, -(a * s + o)), h = f > 0 ? s : Math.min(Math.max(-s, -l), s), p = -f * f + h * (h + 2 * l) + c);
+            f <= -g ? (d = Math.max(0, -(-o * r + a)), f = d > 0 ? -r : Math.min(Math.max(-r, -l), r), h = -d * d + f * (f + 2 * l) + c) : f <= g ? (d = 0, f = Math.min(Math.max(-r, -l), r), h = f * (f + 2 * l) + c) : (d = Math.max(0, -(o * r + a)), f = d > 0 ? r : Math.min(Math.max(-r, -l), r), h = -d * d + f * (f + 2 * l) + c);
         else
-            h = a > 0 ? -s : s, f = Math.max(0, -(a * h + o)), p = -f * f + h * (h + 2 * l) + c;
-        return n && n.copy(this.origin).addScaledVector(this.direction, f), r && r.copy(Rs).addScaledVector(Sr, h), p;
+            f = o > 0 ? -r : r, d = Math.max(0, -(o * f + a)), h = -d * d + f * (f + 2 * l) + c;
+        return n && n.copy(this.origin).addScaledVector(this.direction, d), i && i.copy(ra).addScaledVector(Vs, f), h;
     }
     intersectSphere(e, t) {
-        mn.subVectors(e.center, this.origin);
-        const n = mn.dot(this.direction),
-            r = mn.dot(mn) - n * n,
-            s = e.radius * e.radius;
-        if (r > s)
+        An.subVectors(e.center, this.origin);
+        const n = An.dot(this.direction),
+            i = An.dot(An) - n * n,
+            r = e.radius * e.radius;
+        if (i > r)
             return null;
-        const a = Math.sqrt(s - r),
-            o = n - a,
-            l = n + a;
-        return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
+        const o = Math.sqrt(r - i),
+            a = n - o,
+            l = n + o;
+        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
     }
     intersectsSphere(e) {
         return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
     }
     distanceToPlane(e) {
         const t = e.normal.dot(this.direction);
         if (t === 0)
@@ -3367,59 +3395,59 @@
         return n === null ? null : this.at(n, t);
     }
     intersectsPlane(e) {
         const t = e.distanceToPoint(this.origin);
         return t === 0 || e.normal.dot(this.direction) * t < 0;
     }
     intersectBox(e, t) {
-        let n, r, s, a, o, l;
+        let n, i, r, o, a, l;
         const c = 1 / this.direction.x,
             u = 1 / this.direction.y,
-            f = 1 / this.direction.z,
-            h = this.origin;
-        return c >= 0 ? (n = (e.min.x - h.x) * c, r = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c, r = (e.min.x - h.x) * c), u >= 0 ? (s = (e.min.y - h.y) * u, a = (e.max.y - h.y) * u) : (s = (e.max.y - h.y) * u, a = (e.min.y - h.y) * u), n > a || s > r || ((s > n || isNaN(n)) && (n = s), (a < r || isNaN(r)) && (r = a), f >= 0 ? (o = (e.min.z - h.z) * f, l = (e.max.z - h.z) * f) : (o = (e.max.z - h.z) * f, l = (e.min.z - h.z) * f), n > l || o > r) || ((o > n || n !== n) && (n = o), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(n >= 0 ? n : r, t);
+            d = 1 / this.direction.z,
+            f = this.origin;
+        return c >= 0 ? (n = (e.min.x - f.x) * c, i = (e.max.x - f.x) * c) : (n = (e.max.x - f.x) * c, i = (e.min.x - f.x) * c), u >= 0 ? (r = (e.min.y - f.y) * u, o = (e.max.y - f.y) * u) : (r = (e.max.y - f.y) * u, o = (e.min.y - f.y) * u), n > o || r > i || ((r > n || isNaN(n)) && (n = r), (o < i || isNaN(i)) && (i = o), d >= 0 ? (a = (e.min.z - f.z) * d, l = (e.max.z - f.z) * d) : (a = (e.max.z - f.z) * d, l = (e.min.z - f.z) * d), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t);
     }
     intersectsBox(e) {
-        return this.intersectBox(e, mn) !== null;
+        return this.intersectBox(e, An) !== null;
     }
-    intersectTriangle(e, t, n, r, s) {
-        Ps.subVectors(t, e), Mr.subVectors(n, e), Ls.crossVectors(Ps, Mr);
-        let a = this.direction.dot(Ls),
-            o;
-        if (a > 0) {
-            if (r)
+    intersectTriangle(e, t, n, i, r) {
+        aa.subVectors(t, e), Ws.subVectors(n, e), oa.crossVectors(aa, Ws);
+        let o = this.direction.dot(oa),
+            a;
+        if (o > 0) {
+            if (i)
                 return null;
-            o = 1;
-        } else if (a < 0)
-            o = -1, a = -a;
+            a = 1;
+        } else if (o < 0)
+            a = -1, o = -o;
         else
             return null;
-        Ln.subVectors(this.origin, e);
-        const l = o * this.direction.dot(Mr.crossVectors(Ln, Mr));
+        Wn.subVectors(this.origin, e);
+        const l = a * this.direction.dot(Ws.crossVectors(Wn, Ws));
         if (l < 0)
             return null;
-        const c = o * this.direction.dot(Ps.cross(Ln));
-        if (c < 0 || l + c > a)
+        const c = a * this.direction.dot(aa.cross(Wn));
+        if (c < 0 || l + c > o)
             return null;
-        const u = -o * Ln.dot(Ls);
-        return u < 0 ? null : this.at(u / a, s);
+        const u = -a * Wn.dot(oa);
+        return u < 0 ? null : this.at(u / o, r);
     }
     applyMatrix4(e) {
         return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
     }
     equals(e) {
         return e.origin.equals(this.origin) && e.direction.equals(this.direction);
     }
     clone() {
         return new this.constructor().copy(this);
     }
 };
-class ke {
-    constructor(e, t, n, r, s, a, o, l, c, u, f, h, p, g, v, m) {
-        ke.prototype.isMatrix4 = !0, this.elements = [
+class Ge {
+    constructor(e, t, n, i, r, o, a, l, c, u, d, f, h, g, _, m) {
+        Ge.prototype.isMatrix4 = !0, this.elements = [
             1,
             0,
             0,
             0,
             0,
             1,
             0,
@@ -3428,19 +3456,19 @@
             0,
             1,
             0,
             0,
             0,
             0,
             1
-        ], e !== void 0 && this.set(e, t, n, r, s, a, o, l, c, u, f, h, p, g, v, m);
+        ], e !== void 0 && this.set(e, t, n, i, r, o, a, l, c, u, d, f, h, g, _, m);
     }
-    set(e, t, n, r, s, a, o, l, c, u, f, h, p, g, v, m) {
-        const d = this.elements;
-        return d[0] = e, d[4] = t, d[8] = n, d[12] = r, d[1] = s, d[5] = a, d[9] = o, d[13] = l, d[2] = c, d[6] = u, d[10] = f, d[14] = h, d[3] = p, d[7] = g, d[11] = v, d[15] = m, this;
+    set(e, t, n, i, r, o, a, l, c, u, d, f, h, g, _, m) {
+        const p = this.elements;
+        return p[0] = e, p[4] = t, p[8] = n, p[12] = i, p[1] = r, p[5] = o, p[9] = a, p[13] = l, p[2] = c, p[6] = u, p[10] = d, p[14] = f, p[3] = h, p[7] = g, p[11] = _, p[15] = m, this;
     }
     identity() {
         return this.set(
             1,
             0,
             0,
             0,
@@ -3455,15 +3483,15 @@
             0,
             0,
             0,
             1
         ), this;
     }
     clone() {
-        return new ke().fromArray(this.elements);
+        return new Ge().fromArray(this.elements);
     }
     copy(e) {
         const t = this.elements,
             n = e.elements;
         return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
     }
     copyPosition(e) {
@@ -3514,194 +3542,194 @@
             0,
             1
         ), this;
     }
     extractRotation(e) {
         const t = this.elements,
             n = e.elements,
-            r = 1 / vi.setFromMatrixColumn(e, 0).length(),
-            s = 1 / vi.setFromMatrixColumn(e, 1).length(),
-            a = 1 / vi.setFromMatrixColumn(e, 2).length();
-        return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
+            i = 1 / Fi.setFromMatrixColumn(e, 0).length(),
+            r = 1 / Fi.setFromMatrixColumn(e, 1).length(),
+            o = 1 / Fi.setFromMatrixColumn(e, 2).length();
+        return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * r, t[5] = n[5] * r, t[6] = n[6] * r, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
     }
     makeRotationFromEuler(e) {
         const t = this.elements,
             n = e.x,
-            r = e.y,
-            s = e.z,
-            a = Math.cos(n),
-            o = Math.sin(n),
-            l = Math.cos(r),
-            c = Math.sin(r),
-            u = Math.cos(s),
-            f = Math.sin(s);
+            i = e.y,
+            r = e.z,
+            o = Math.cos(n),
+            a = Math.sin(n),
+            l = Math.cos(i),
+            c = Math.sin(i),
+            u = Math.cos(r),
+            d = Math.sin(r);
         if (e.order === "XYZ") {
-            const h = a * u,
-                p = a * f,
-                g = o * u,
-                v = o * f;
-            t[0] = l * u, t[4] = -l * f, t[8] = c, t[1] = p + g * c, t[5] = h - v * c, t[9] = -o * l, t[2] = v - h * c, t[6] = g + p * c, t[10] = a * l;
+            const f = o * u,
+                h = o * d,
+                g = a * u,
+                _ = a * d;
+            t[0] = l * u, t[4] = -l * d, t[8] = c, t[1] = h + g * c, t[5] = f - _ * c, t[9] = -a * l, t[2] = _ - f * c, t[6] = g + h * c, t[10] = o * l;
         } else if (e.order === "YXZ") {
-            const h = l * u,
-                p = l * f,
+            const f = l * u,
+                h = l * d,
                 g = c * u,
-                v = c * f;
-            t[0] = h + v * o, t[4] = g * o - p, t[8] = a * c, t[1] = a * f, t[5] = a * u, t[9] = -o, t[2] = p * o - g, t[6] = v + h * o, t[10] = a * l;
+                _ = c * d;
+            t[0] = f + _ * a, t[4] = g * a - h, t[8] = o * c, t[1] = o * d, t[5] = o * u, t[9] = -a, t[2] = h * a - g, t[6] = _ + f * a, t[10] = o * l;
         } else if (e.order === "ZXY") {
-            const h = l * u,
-                p = l * f,
+            const f = l * u,
+                h = l * d,
                 g = c * u,
-                v = c * f;
-            t[0] = h - v * o, t[4] = -a * f, t[8] = g + p * o, t[1] = p + g * o, t[5] = a * u, t[9] = v - h * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
+                _ = c * d;
+            t[0] = f - _ * a, t[4] = -o * d, t[8] = g + h * a, t[1] = h + g * a, t[5] = o * u, t[9] = _ - f * a, t[2] = -o * c, t[6] = a, t[10] = o * l;
         } else if (e.order === "ZYX") {
-            const h = a * u,
-                p = a * f,
-                g = o * u,
-                v = o * f;
-            t[0] = l * u, t[4] = g * c - p, t[8] = h * c + v, t[1] = l * f, t[5] = v * c + h, t[9] = p * c - g, t[2] = -c, t[6] = o * l, t[10] = a * l;
+            const f = o * u,
+                h = o * d,
+                g = a * u,
+                _ = a * d;
+            t[0] = l * u, t[4] = g * c - h, t[8] = f * c + _, t[1] = l * d, t[5] = _ * c + f, t[9] = h * c - g, t[2] = -c, t[6] = a * l, t[10] = o * l;
         } else if (e.order === "YZX") {
-            const h = a * l,
-                p = a * c,
-                g = o * l,
-                v = o * c;
-            t[0] = l * u, t[4] = v - h * f, t[8] = g * f + p, t[1] = f, t[5] = a * u, t[9] = -o * u, t[2] = -c * u, t[6] = p * f + g, t[10] = h - v * f;
+            const f = o * l,
+                h = o * c,
+                g = a * l,
+                _ = a * c;
+            t[0] = l * u, t[4] = _ - f * d, t[8] = g * d + h, t[1] = d, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = h * d + g, t[10] = f - _ * d;
         } else if (e.order === "XZY") {
-            const h = a * l,
-                p = a * c,
-                g = o * l,
-                v = o * c;
-            t[0] = l * u, t[4] = -f, t[8] = c * u, t[1] = h * f + v, t[5] = a * u, t[9] = p * f - g, t[2] = g * f - p, t[6] = o * u, t[10] = v * f + h;
+            const f = o * l,
+                h = o * c,
+                g = a * l,
+                _ = a * c;
+            t[0] = l * u, t[4] = -d, t[8] = c * u, t[1] = f * d + _, t[5] = o * u, t[9] = h * d - g, t[2] = g * d - h, t[6] = a * u, t[10] = _ * d + f;
         }
         return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
     }
     makeRotationFromQuaternion(e) {
-        return this.compose(Qf, e, Zf);
+        return this.compose(qf, e, Yf);
     }
     lookAt(e, t, n) {
-        const r = this.elements;
-        return It.subVectors(e, t), It.lengthSq() === 0 && (It.z = 1), It.normalize(), Dn.crossVectors(n, It), Dn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? It.x += 1e-4 : It.z += 1e-4, It.normalize(), Dn.crossVectors(n, It)), Dn.normalize(), yr.crossVectors(It, Dn), r[0] = Dn.x, r[4] = yr.x, r[8] = It.x, r[1] = Dn.y, r[5] = yr.y, r[9] = It.y, r[2] = Dn.z, r[6] = yr.z, r[10] = It.z, this;
+        const i = this.elements;
+        return Vt.subVectors(e, t), Vt.lengthSq() === 0 && (Vt.z = 1), Vt.normalize(), Xn.crossVectors(n, Vt), Xn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Vt.x += 1e-4 : Vt.z += 1e-4, Vt.normalize(), Xn.crossVectors(n, Vt)), Xn.normalize(), Xs.crossVectors(Vt, Xn), i[0] = Xn.x, i[4] = Xs.x, i[8] = Vt.x, i[1] = Xn.y, i[5] = Xs.y, i[9] = Vt.y, i[2] = Xn.z, i[6] = Xs.z, i[10] = Vt.z, this;
     }
     multiply(e) {
         return this.multiplyMatrices(this, e);
     }
     premultiply(e) {
         return this.multiplyMatrices(e, this);
     }
     multiplyMatrices(e, t) {
         const n = e.elements,
-            r = t.elements,
-            s = this.elements,
-            a = n[0],
-            o = n[4],
+            i = t.elements,
+            r = this.elements,
+            o = n[0],
+            a = n[4],
             l = n[8],
             c = n[12],
             u = n[1],
-            f = n[5],
-            h = n[9],
-            p = n[13],
+            d = n[5],
+            f = n[9],
+            h = n[13],
             g = n[2],
-            v = n[6],
+            _ = n[6],
             m = n[10],
-            d = n[14],
-            M = n[3],
-            _ = n[7],
-            A = n[11],
-            R = n[15],
-            E = r[0],
-            b = r[4],
-            I = r[8],
-            W = r[12],
-            S = r[1],
-            T = r[5],
-            Y = r[9],
-            K = r[13],
-            L = r[2],
-            N = r[6],
-            O = r[10],
-            B = r[14],
-            j = r[3],
-            q = r[7],
-            J = r[11],
-            ne = r[15];
-        return s[0] = a * E + o * S + l * L + c * j, s[4] = a * b + o * T + l * N + c * q, s[8] = a * I + o * Y + l * O + c * J, s[12] = a * W + o * K + l * B + c * ne, s[1] = u * E + f * S + h * L + p * j, s[5] = u * b + f * T + h * N + p * q, s[9] = u * I + f * Y + h * O + p * J, s[13] = u * W + f * K + h * B + p * ne, s[2] = g * E + v * S + m * L + d * j, s[6] = g * b + v * T + m * N + d * q, s[10] = g * I + v * Y + m * O + d * J, s[14] = g * W + v * K + m * B + d * ne, s[3] = M * E + _ * S + A * L + R * j, s[7] = M * b + _ * T + A * N + R * q, s[11] = M * I + _ * Y + A * O + R * J, s[15] = M * W + _ * K + A * B + R * ne, this;
+            p = n[14],
+            v = n[3],
+            S = n[7],
+            y = n[11],
+            b = n[15],
+            E = i[0],
+            T = i[4],
+            L = i[8],
+            B = i[12],
+            x = i[1],
+            A = i[5],
+            U = i[9],
+            N = i[13],
+            P = i[2],
+            I = i[6],
+            z = i[10],
+            K = i[14],
+            G = i[3],
+            q = i[7],
+            Q = i[11],
+            te = i[15];
+        return r[0] = o * E + a * x + l * P + c * G, r[4] = o * T + a * A + l * I + c * q, r[8] = o * L + a * U + l * z + c * Q, r[12] = o * B + a * N + l * K + c * te, r[1] = u * E + d * x + f * P + h * G, r[5] = u * T + d * A + f * I + h * q, r[9] = u * L + d * U + f * z + h * Q, r[13] = u * B + d * N + f * K + h * te, r[2] = g * E + _ * x + m * P + p * G, r[6] = g * T + _ * A + m * I + p * q, r[10] = g * L + _ * U + m * z + p * Q, r[14] = g * B + _ * N + m * K + p * te, r[3] = v * E + S * x + y * P + b * G, r[7] = v * T + S * A + y * I + b * q, r[11] = v * L + S * U + y * z + b * Q, r[15] = v * B + S * N + y * K + b * te, this;
     }
     multiplyScalar(e) {
         const t = this.elements;
         return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
     }
     determinant() {
         const e = this.elements,
             t = e[0],
             n = e[4],
-            r = e[8],
-            s = e[12],
-            a = e[1],
-            o = e[5],
+            i = e[8],
+            r = e[12],
+            o = e[1],
+            a = e[5],
             l = e[9],
             c = e[13],
             u = e[2],
-            f = e[6],
-            h = e[10],
-            p = e[14],
+            d = e[6],
+            f = e[10],
+            h = e[14],
             g = e[3],
-            v = e[7],
+            _ = e[7],
             m = e[11],
-            d = e[15];
-        return g * (+s * l * f - r * c * f - s * o * h + n * c * h + r * o * p - n * l * p) + v * (+t * l * p - t * c * h + s * a * h - r * a * p + r * c * u - s * l * u) + m * (+t * c * f - t * o * p - s * a * f + n * a * p + s * o * u - n * c * u) + d * (-r * o * u - t * l * f + t * o * h + r * a * f - n * a * h + n * l * u);
+            p = e[15];
+        return g * (+r * l * d - i * c * d - r * a * f + n * c * f + i * a * h - n * l * h) + _ * (+t * l * h - t * c * f + r * o * f - i * o * h + i * c * u - r * l * u) + m * (+t * c * d - t * a * h - r * o * d + n * o * h + r * a * u - n * c * u) + p * (-i * a * u - t * l * d + t * a * f + i * o * d - n * o * f + n * l * u);
     }
     transpose() {
         const e = this.elements;
         let t;
         return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
     }
     setPosition(e, t, n) {
-        const r = this.elements;
-        return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this;
+        const i = this.elements;
+        return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
     }
     invert() {
         const e = this.elements,
             t = e[0],
             n = e[1],
-            r = e[2],
-            s = e[3],
-            a = e[4],
-            o = e[5],
+            i = e[2],
+            r = e[3],
+            o = e[4],
+            a = e[5],
             l = e[6],
             c = e[7],
             u = e[8],
-            f = e[9],
-            h = e[10],
-            p = e[11],
+            d = e[9],
+            f = e[10],
+            h = e[11],
             g = e[12],
-            v = e[13],
+            _ = e[13],
             m = e[14],
-            d = e[15],
-            M = f * m * c - v * h * c + v * l * p - o * m * p - f * l * d + o * h * d,
-            _ = g * h * c - u * m * c - g * l * p + a * m * p + u * l * d - a * h * d,
-            A = u * v * c - g * f * c + g * o * p - a * v * p - u * o * d + a * f * d,
-            R = g * f * l - u * v * l - g * o * h + a * v * h + u * o * m - a * f * m,
-            E = t * M + n * _ + r * A + s * R;
+            p = e[15],
+            v = d * m * c - _ * f * c + _ * l * h - a * m * h - d * l * p + a * f * p,
+            S = g * f * c - u * m * c - g * l * h + o * m * h + u * l * p - o * f * p,
+            y = u * _ * c - g * d * c + g * a * h - o * _ * h - u * a * p + o * d * p,
+            b = g * d * l - u * _ * l - g * a * f + o * _ * f + u * a * m - o * d * m,
+            E = t * v + n * S + i * y + r * b;
         if (E === 0)
             return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
-        const b = 1 / E;
-        return e[0] = M * b, e[1] = (v * h * s - f * m * s - v * r * p + n * m * p + f * r * d - n * h * d) * b, e[2] = (o * m * s - v * l * s + v * r * c - n * m * c - o * r * d + n * l * d) * b, e[3] = (f * l * s - o * h * s - f * r * c + n * h * c + o * r * p - n * l * p) * b, e[4] = _ * b, e[5] = (u * m * s - g * h * s + g * r * p - t * m * p - u * r * d + t * h * d) * b, e[6] = (g * l * s - a * m * s - g * r * c + t * m * c + a * r * d - t * l * d) * b, e[7] = (a * h * s - u * l * s + u * r * c - t * h * c - a * r * p + t * l * p) * b, e[8] = A * b, e[9] = (g * f * s - u * v * s - g * n * p + t * v * p + u * n * d - t * f * d) * b, e[10] = (a * v * s - g * o * s + g * n * c - t * v * c - a * n * d + t * o * d) * b, e[11] = (u * o * s - a * f * s - u * n * c + t * f * c + a * n * p - t * o * p) * b, e[12] = R * b, e[13] = (u * v * r - g * f * r + g * n * h - t * v * h - u * n * m + t * f * m) * b, e[14] = (g * o * r - a * v * r - g * n * l + t * v * l + a * n * m - t * o * m) * b, e[15] = (a * f * r - u * o * r + u * n * l - t * f * l - a * n * h + t * o * h) * b, this;
+        const T = 1 / E;
+        return e[0] = v * T, e[1] = (_ * f * r - d * m * r - _ * i * h + n * m * h + d * i * p - n * f * p) * T, e[2] = (a * m * r - _ * l * r + _ * i * c - n * m * c - a * i * p + n * l * p) * T, e[3] = (d * l * r - a * f * r - d * i * c + n * f * c + a * i * h - n * l * h) * T, e[4] = S * T, e[5] = (u * m * r - g * f * r + g * i * h - t * m * h - u * i * p + t * f * p) * T, e[6] = (g * l * r - o * m * r - g * i * c + t * m * c + o * i * p - t * l * p) * T, e[7] = (o * f * r - u * l * r + u * i * c - t * f * c - o * i * h + t * l * h) * T, e[8] = y * T, e[9] = (g * d * r - u * _ * r - g * n * h + t * _ * h + u * n * p - t * d * p) * T, e[10] = (o * _ * r - g * a * r + g * n * c - t * _ * c - o * n * p + t * a * p) * T, e[11] = (u * a * r - o * d * r - u * n * c + t * d * c + o * n * h - t * a * h) * T, e[12] = b * T, e[13] = (u * _ * i - g * d * i + g * n * f - t * _ * f - u * n * m + t * d * m) * T, e[14] = (g * a * i - o * _ * i - g * n * l + t * _ * l + o * n * m - t * a * m) * T, e[15] = (o * d * i - u * a * i + u * n * l - t * d * l - o * n * f + t * a * f) * T, this;
     }
     scale(e) {
         const t = this.elements,
             n = e.x,
-            r = e.y,
-            s = e.z;
-        return t[0] *= n, t[4] *= r, t[8] *= s, t[1] *= n, t[5] *= r, t[9] *= s, t[2] *= n, t[6] *= r, t[10] *= s, t[3] *= n, t[7] *= r, t[11] *= s, this;
+            i = e.y,
+            r = e.z;
+        return t[0] *= n, t[4] *= i, t[8] *= r, t[1] *= n, t[5] *= i, t[9] *= r, t[2] *= n, t[6] *= i, t[10] *= r, t[3] *= n, t[7] *= i, t[11] *= r, this;
     }
     getMaxScaleOnAxis() {
         const e = this.elements,
             t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
             n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
-            r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
-        return Math.sqrt(Math.max(t, n, r));
+            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
+        return Math.sqrt(Math.max(t, n, i));
     }
     makeTranslation(e, t, n) {
         return e.isVector3 ? this.set(
             1,
             0,
             0,
             e.x,
@@ -3800,33 +3828,33 @@
             0,
             0,
             1
         ), this;
     }
     makeRotationAxis(e, t) {
         const n = Math.cos(t),
-            r = Math.sin(t),
-            s = 1 - n,
-            a = e.x,
-            o = e.y,
+            i = Math.sin(t),
+            r = 1 - n,
+            o = e.x,
+            a = e.y,
             l = e.z,
-            c = s * a,
-            u = s * o;
+            c = r * o,
+            u = r * a;
         return this.set(
-            c * a + n,
-            c * o - r * l,
-            c * l + r * o,
-            0,
-            c * o + r * l,
-            u * o + n,
-            u * l - r * a,
-            0,
-            c * l - r * o,
-            u * l + r * a,
-            s * l * l + n,
+            c * o + n,
+            c * a - i * l,
+            c * l + i * a,
+            0,
+            c * a + i * l,
+            u * a + n,
+            u * l - i * o,
+            0,
+            c * l - i * a,
+            u * l + i * o,
+            r * l * l + n,
             0,
             0,
             0,
             0,
             1
         ), this;
     }
@@ -3846,129 +3874,129 @@
             0,
             0,
             0,
             0,
             1
         ), this;
     }
-    makeShear(e, t, n, r, s, a) {
+    makeShear(e, t, n, i, r, o) {
         return this.set(
             1,
             n,
-            s,
+            r,
             0,
             e,
             1,
-            a,
+            o,
             0,
             t,
-            r,
+            i,
             1,
             0,
             0,
             0,
             0,
             1
         ), this;
     }
     compose(e, t, n) {
-        const r = this.elements,
-            s = t._x,
-            a = t._y,
-            o = t._z,
+        const i = this.elements,
+            r = t._x,
+            o = t._y,
+            a = t._z,
             l = t._w,
-            c = s + s,
-            u = a + a,
-            f = o + o,
-            h = s * c,
-            p = s * u,
-            g = s * f,
-            v = a * u,
-            m = a * f,
-            d = o * f,
-            M = l * c,
-            _ = l * u,
-            A = l * f,
-            R = n.x,
+            c = r + r,
+            u = o + o,
+            d = a + a,
+            f = r * c,
+            h = r * u,
+            g = r * d,
+            _ = o * u,
+            m = o * d,
+            p = a * d,
+            v = l * c,
+            S = l * u,
+            y = l * d,
+            b = n.x,
             E = n.y,
-            b = n.z;
-        return r[0] = (1 - (v + d)) * R, r[1] = (p + A) * R, r[2] = (g - _) * R, r[3] = 0, r[4] = (p - A) * E, r[5] = (1 - (h + d)) * E, r[6] = (m + M) * E, r[7] = 0, r[8] = (g + _) * b, r[9] = (m - M) * b, r[10] = (1 - (h + v)) * b, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
+            T = n.z;
+        return i[0] = (1 - (_ + p)) * b, i[1] = (h + y) * b, i[2] = (g - S) * b, i[3] = 0, i[4] = (h - y) * E, i[5] = (1 - (f + p)) * E, i[6] = (m + v) * E, i[7] = 0, i[8] = (g + S) * T, i[9] = (m - v) * T, i[10] = (1 - (f + _)) * T, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
     }
     decompose(e, t, n) {
-        const r = this.elements;
-        let s = vi.set(r[0], r[1], r[2]).length();
-        const a = vi.set(r[4], r[5], r[6]).length(),
-            o = vi.set(r[8], r[9], r[10]).length();
-        this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Kt.copy(this);
-        const c = 1 / s,
-            u = 1 / a,
-            f = 1 / o;
-        return Kt.elements[0] *= c, Kt.elements[1] *= c, Kt.elements[2] *= c, Kt.elements[4] *= u, Kt.elements[5] *= u, Kt.elements[6] *= u, Kt.elements[8] *= f, Kt.elements[9] *= f, Kt.elements[10] *= f, t.setFromRotationMatrix(Kt), n.x = s, n.y = a, n.z = o, this;
+        const i = this.elements;
+        let r = Fi.set(i[0], i[1], i[2]).length();
+        const o = Fi.set(i[4], i[5], i[6]).length(),
+            a = Fi.set(i[8], i[9], i[10]).length();
+        this.determinant() < 0 && (r = -r), e.x = i[12], e.y = i[13], e.z = i[14], an.copy(this);
+        const c = 1 / r,
+            u = 1 / o,
+            d = 1 / a;
+        return an.elements[0] *= c, an.elements[1] *= c, an.elements[2] *= c, an.elements[4] *= u, an.elements[5] *= u, an.elements[6] *= u, an.elements[8] *= d, an.elements[9] *= d, an.elements[10] *= d, t.setFromRotationMatrix(an), n.x = r, n.y = o, n.z = a, this;
     }
-    makePerspective(e, t, n, r, s, a, o = Mn) {
+    makePerspective(e, t, n, i, r, o, a = Dn) {
         const l = this.elements,
-            c = 2 * s / (t - e),
-            u = 2 * s / (n - r),
-            f = (t + e) / (t - e),
-            h = (n + r) / (n - r);
-        let p, g;
-        if (o === Mn)
-            p = -(a + s) / (a - s), g = -2 * a * s / (a - s);
-        else if (o === Qr)
-            p = -a / (a - s), g = -a * s / (a - s);
+            c = 2 * r / (t - e),
+            u = 2 * r / (n - i),
+            d = (t + e) / (t - e),
+            f = (n + i) / (n - i);
+        let h, g;
+        if (a === Dn)
+            h = -(o + r) / (o - r), g = -2 * o * r / (o - r);
+        else if (a === Er)
+            h = -o / (o - r), g = -o * r / (o - r);
         else
-            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
-        return l[0] = c, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = u, l[9] = h, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
+            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
+        return l[0] = c, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = u, l[9] = f, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = h, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
     }
-    makeOrthographic(e, t, n, r, s, a, o = Mn) {
+    makeOrthographic(e, t, n, i, r, o, a = Dn) {
         const l = this.elements,
             c = 1 / (t - e),
-            u = 1 / (n - r),
-            f = 1 / (a - s),
-            h = (t + e) * c,
-            p = (n + r) * u;
-        let g, v;
-        if (o === Mn)
-            g = (a + s) * f, v = -2 * f;
-        else if (o === Qr)
-            g = s * f, v = -1 * f;
+            u = 1 / (n - i),
+            d = 1 / (o - r),
+            f = (t + e) * c,
+            h = (n + i) * u;
+        let g, _;
+        if (a === Dn)
+            g = (o + r) * d, _ = -2 * d;
+        else if (a === Er)
+            g = r * d, _ = -1 * d;
         else
-            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
-        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -h, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = v, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
+            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
+        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -f, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -h, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
     }
     equals(e) {
         const t = this.elements,
             n = e.elements;
-        for (let r = 0; r < 16; r++)
-            if (t[r] !== n[r])
+        for (let i = 0; i < 16; i++)
+            if (t[i] !== n[i])
                 return !1;
         return !0;
     }
     fromArray(e, t = 0) {
         for (let n = 0; n < 16; n++)
             this.elements[n] = e[n + t];
         return this;
     }
     toArray(e = [], t = 0) {
         const n = this.elements;
         return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
     }
 }
-const vi = /* @__PURE__ */ new P(),
-    Kt = /* @__PURE__ */ new ke(),
-    Qf = /* @__PURE__ */ new P(0, 0, 0),
-    Zf = /* @__PURE__ */ new P(1, 1, 1),
-    Dn = /* @__PURE__ */ new P(),
-    yr = /* @__PURE__ */ new P(),
-    It = /* @__PURE__ */ new P(),
-    Sa = /* @__PURE__ */ new ke(),
-    Ma = /* @__PURE__ */ new wt();
-class bn {
-    constructor(e = 0, t = 0, n = 0, r = bn.DEFAULT_ORDER) {
-        this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = r;
+const Fi = /* @__PURE__ */ new D(),
+    an = /* @__PURE__ */ new Ge(),
+    qf = /* @__PURE__ */ new D(0, 0, 0),
+    Yf = /* @__PURE__ */ new D(1, 1, 1),
+    Xn = /* @__PURE__ */ new D(),
+    Xs = /* @__PURE__ */ new D(),
+    Vt = /* @__PURE__ */ new D(),
+    ll = /* @__PURE__ */ new Ge(),
+    cl = /* @__PURE__ */ new St();
+class Nn {
+    constructor(e = 0, t = 0, n = 0, i = Nn.DEFAULT_ORDER) {
+        this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
     }
     get x() {
         return this._x;
     }
     set x(e) {
         this._x = e, this._onChangeCallback();
     }
@@ -3986,66 +4014,66 @@
     }
     get order() {
         return this._order;
     }
     set order(e) {
         this._order = e, this._onChangeCallback();
     }
-    set(e, t, n, r = this._order) {
-        return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this;
+    set(e, t, n, i = this._order) {
+        return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
     }
     clone() {
         return new this.constructor(this._x, this._y, this._z, this._order);
     }
     copy(e) {
         return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
     }
     setFromRotationMatrix(e, t = this._order, n = !0) {
-        const r = e.elements,
-            s = r[0],
-            a = r[4],
-            o = r[8],
-            l = r[1],
-            c = r[5],
-            u = r[9],
-            f = r[2],
-            h = r[6],
-            p = r[10];
+        const i = e.elements,
+            r = i[0],
+            o = i[4],
+            a = i[8],
+            l = i[1],
+            c = i[5],
+            u = i[9],
+            d = i[2],
+            f = i[6],
+            h = i[10];
         switch (t) {
             case "XYZ":
-                this._y = Math.asin(xt(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(h, c), this._z = 0);
+                this._y = Math.asin(Ct(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-u, h), this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(f, c), this._z = 0);
                 break;
             case "YXZ":
-                this._x = Math.asin(-xt(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-f, s), this._z = 0);
+                this._x = Math.asin(-Ct(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(a, h), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r), this._z = 0);
                 break;
             case "ZXY":
-                this._x = Math.asin(xt(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-f, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
+                this._x = Math.asin(Ct(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._y = Math.atan2(-d, h), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, r));
                 break;
             case "ZYX":
-                this._y = Math.asin(-xt(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
+                this._y = Math.asin(-Ct(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(f, h), this._z = Math.atan2(l, r)) : (this._x = 0, this._z = Math.atan2(-o, c));
                 break;
             case "YZX":
-                this._z = Math.asin(xt(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-f, s)) : (this._x = 0, this._y = Math.atan2(o, p));
+                this._z = Math.asin(Ct(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-d, r)) : (this._x = 0, this._y = Math.atan2(a, h));
                 break;
             case "XZY":
-                this._z = Math.asin(-xt(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-u, p), this._y = 0);
+                this._z = Math.asin(-Ct(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(f, c), this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-u, h), this._y = 0);
                 break;
             default:
                 console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
         }
         return this._order = t, n === !0 && this._onChangeCallback(), this;
     }
     setFromQuaternion(e, t, n) {
-        return Sa.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Sa, t, n);
+        return ll.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ll, t, n);
     }
     setFromVector3(e, t = this._order) {
         return this.set(e.x, e.y, e.z, t);
     }
     reorder(e) {
-        return Ma.setFromEuler(this), this.setFromQuaternion(Ma, e);
+        return cl.setFromEuler(this), this.setFromQuaternion(cl, e);
     }
     equals(e) {
         return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
     }
     fromArray(e) {
         return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
     }
@@ -4056,16 +4084,16 @@
         return this._onChangeCallback = e, this;
     }
     _onChangeCallback() {}
         *[Symbol.iterator]() {
             yield this._x, yield this._y, yield this._z, yield this._order;
         }
 }
-bn.DEFAULT_ORDER = "XYZ";
-class Zl {
+Nn.DEFAULT_ORDER = "XYZ";
+class Xc {
     constructor() {
         this.mask = 1;
     }
     set(e) {
         this.mask = (1 << e | 0) >>> 0;
     }
     enable(e) {
@@ -4086,57 +4114,57 @@
     test(e) {
         return (this.mask & e.mask) !== 0;
     }
     isEnabled(e) {
         return (this.mask & (1 << e | 0)) !== 0;
     }
 }
-let Jf = 0;
-const ya = /* @__PURE__ */ new P(),
-    xi = /* @__PURE__ */ new wt(),
-    gn = /* @__PURE__ */ new ke(),
-    Ar = /* @__PURE__ */ new P(),
-    ir = /* @__PURE__ */ new P(),
-    $f = /* @__PURE__ */ new P(),
-    eh = /* @__PURE__ */ new wt(),
-    Aa = /* @__PURE__ */ new P(1, 0, 0),
-    Ea = /* @__PURE__ */ new P(0, 1, 0),
-    ba = /* @__PURE__ */ new P(0, 0, 1),
-    th = {
+let jf = 0;
+const ul = /* @__PURE__ */ new D(),
+    Ii = /* @__PURE__ */ new St(),
+    Tn = /* @__PURE__ */ new Ge(),
+    qs = /* @__PURE__ */ new D(),
+    Es = /* @__PURE__ */ new D(),
+    Kf = /* @__PURE__ */ new D(),
+    Zf = /* @__PURE__ */ new St(),
+    dl = /* @__PURE__ */ new D(1, 0, 0),
+    fl = /* @__PURE__ */ new D(0, 1, 0),
+    hl = /* @__PURE__ */ new D(0, 0, 1),
+    Qf = {
         type: "added"
     },
-    nh = {
+    Jf = {
         type: "removed"
     },
-    Ds = {
+    la = {
         type: "childadded",
         child: null
     },
-    Is = {
+    ca = {
         type: "childremoved",
         child: null
     };
-class gt extends ui {
+class Et extends Ti {
     constructor() {
         super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
-            value: Jf++
-        }), this.uuid = Ki(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = gt.DEFAULT_UP.clone();
-        const e = new P(),
-            t = new bn(),
-            n = new wt(),
-            r = new P(1, 1, 1);
+            value: jf++
+        }), this.uuid = ms(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Et.DEFAULT_UP.clone();
+        const e = new D(),
+            t = new Nn(),
+            n = new St(),
+            i = new D(1, 1, 1);
 
-        function s() {
+        function r() {
             n.setFromEuler(t, !1);
         }
 
-        function a() {
+        function o() {
             t.setFromQuaternion(n, void 0, !1);
         }
-        t._onChange(s), n._onChange(a), Object.defineProperties(this, {
+        t._onChange(r), n._onChange(o), Object.defineProperties(this, {
             position: {
                 configurable: !0,
                 enumerable: !0,
                 value: e
             },
             rotation: {
                 configurable: !0,
@@ -4147,23 +4175,23 @@
                 configurable: !0,
                 enumerable: !0,
                 value: n
             },
             scale: {
                 configurable: !0,
                 enumerable: !0,
-                value: r
+                value: i
             },
             modelViewMatrix: {
-                value: new ke()
+                value: new Ge()
             },
             normalMatrix: {
-                value: new be()
+                value: new Ue()
             }
-        }), this.matrix = new ke(), this.matrixWorld = new ke(), this.matrixAutoUpdate = gt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Zl(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
+        }), this.matrix = new Ge(), this.matrixWorld = new Ge(), this.matrixAutoUpdate = Et.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Et.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Xc(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
     }
     onBeforeShadow() {}
     onAfterShadow() {}
     onBeforeRender() {}
     onAfterRender() {}
     applyMatrix4(e) {
         this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
@@ -4180,151 +4208,151 @@
     setRotationFromMatrix(e) {
         this.quaternion.setFromRotationMatrix(e);
     }
     setRotationFromQuaternion(e) {
         this.quaternion.copy(e);
     }
     rotateOnAxis(e, t) {
-        return xi.setFromAxisAngle(e, t), this.quaternion.multiply(xi), this;
+        return Ii.setFromAxisAngle(e, t), this.quaternion.multiply(Ii), this;
     }
     rotateOnWorldAxis(e, t) {
-        return xi.setFromAxisAngle(e, t), this.quaternion.premultiply(xi), this;
+        return Ii.setFromAxisAngle(e, t), this.quaternion.premultiply(Ii), this;
     }
     rotateX(e) {
-        return this.rotateOnAxis(Aa, e);
+        return this.rotateOnAxis(dl, e);
     }
     rotateY(e) {
-        return this.rotateOnAxis(Ea, e);
+        return this.rotateOnAxis(fl, e);
     }
     rotateZ(e) {
-        return this.rotateOnAxis(ba, e);
+        return this.rotateOnAxis(hl, e);
     }
     translateOnAxis(e, t) {
-        return ya.copy(e).applyQuaternion(this.quaternion), this.position.add(ya.multiplyScalar(t)), this;
+        return ul.copy(e).applyQuaternion(this.quaternion), this.position.add(ul.multiplyScalar(t)), this;
     }
     translateX(e) {
-        return this.translateOnAxis(Aa, e);
+        return this.translateOnAxis(dl, e);
     }
     translateY(e) {
-        return this.translateOnAxis(Ea, e);
+        return this.translateOnAxis(fl, e);
     }
     translateZ(e) {
-        return this.translateOnAxis(ba, e);
+        return this.translateOnAxis(hl, e);
     }
     localToWorld(e) {
         return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
     }
     worldToLocal(e) {
-        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(gn.copy(this.matrixWorld).invert());
+        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Tn.copy(this.matrixWorld).invert());
     }
     lookAt(e, t, n) {
-        e.isVector3 ? Ar.copy(e) : Ar.set(e, t, n);
-        const r = this.parent;
-        this.updateWorldMatrix(!0, !1), ir.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? gn.lookAt(ir, Ar, this.up) : gn.lookAt(Ar, ir, this.up), this.quaternion.setFromRotationMatrix(gn), r && (gn.extractRotation(r.matrixWorld), xi.setFromRotationMatrix(gn), this.quaternion.premultiply(xi.invert()));
+        e.isVector3 ? qs.copy(e) : qs.set(e, t, n);
+        const i = this.parent;
+        this.updateWorldMatrix(!0, !1), Es.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Tn.lookAt(Es, qs, this.up) : Tn.lookAt(qs, Es, this.up), this.quaternion.setFromRotationMatrix(Tn), i && (Tn.extractRotation(i.matrixWorld), Ii.setFromRotationMatrix(Tn), this.quaternion.premultiply(Ii.invert()));
     }
     add(e) {
         if (arguments.length > 1) {
             for (let t = 0; t < arguments.length; t++)
                 this.add(arguments[t]);
             return this;
         }
-        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(th), Ds.child = e, this.dispatchEvent(Ds), Ds.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
+        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Qf), la.child = e, this.dispatchEvent(la), la.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
     }
     remove(e) {
         if (arguments.length > 1) {
             for (let n = 0; n < arguments.length; n++)
                 this.remove(arguments[n]);
             return this;
         }
         const t = this.children.indexOf(e);
-        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(nh), Is.child = e, this.dispatchEvent(Is), Is.child = null), this;
+        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(Jf), ca.child = e, this.dispatchEvent(ca), ca.child = null), this;
     }
     removeFromParent() {
         const e = this.parent;
         return e !== null && e.remove(this), this;
     }
     clear() {
         return this.remove(...this.children);
     }
     attach(e) {
-        return this.updateWorldMatrix(!0, !1), gn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), gn.multiply(e.parent.matrixWorld)), e.applyMatrix4(gn), this.add(e), e.updateWorldMatrix(!1, !0), this;
+        return this.updateWorldMatrix(!0, !1), Tn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Tn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Tn), this.add(e), e.updateWorldMatrix(!1, !0), this;
     }
     getObjectById(e) {
         return this.getObjectByProperty("id", e);
     }
     getObjectByName(e) {
         return this.getObjectByProperty("name", e);
     }
     getObjectByProperty(e, t) {
         if (this[e] === t)
             return this;
-        for (let n = 0, r = this.children.length; n < r; n++) {
-            const a = this.children[n].getObjectByProperty(e, t);
-            if (a !== void 0)
-                return a;
+        for (let n = 0, i = this.children.length; n < i; n++) {
+            const o = this.children[n].getObjectByProperty(e, t);
+            if (o !== void 0)
+                return o;
         }
     }
     getObjectsByProperty(e, t, n = []) {
         this[e] === t && n.push(this);
-        const r = this.children;
-        for (let s = 0, a = r.length; s < a; s++)
-            r[s].getObjectsByProperty(e, t, n);
+        const i = this.children;
+        for (let r = 0, o = i.length; r < o; r++)
+            i[r].getObjectsByProperty(e, t, n);
         return n;
     }
     getWorldPosition(e) {
         return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
     }
     getWorldQuaternion(e) {
-        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ir, e, $f), e;
+        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Es, e, Kf), e;
     }
     getWorldScale(e) {
-        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ir, eh, e), e;
+        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Es, Zf, e), e;
     }
     getWorldDirection(e) {
         this.updateWorldMatrix(!0, !1);
         const t = this.matrixWorld.elements;
         return e.set(t[8], t[9], t[10]).normalize();
     }
     raycast() {}
     traverse(e) {
         e(this);
         const t = this.children;
-        for (let n = 0, r = t.length; n < r; n++)
+        for (let n = 0, i = t.length; n < i; n++)
             t[n].traverse(e);
     }
     traverseVisible(e) {
         if (this.visible === !1)
             return;
         e(this);
         const t = this.children;
-        for (let n = 0, r = t.length; n < r; n++)
+        for (let n = 0, i = t.length; n < i; n++)
             t[n].traverseVisible(e);
     }
     traverseAncestors(e) {
         const t = this.parent;
         t !== null && (e(t), t.traverseAncestors(e));
     }
     updateMatrix() {
         this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
     }
     updateMatrixWorld(e) {
         this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
         const t = this.children;
-        for (let n = 0, r = t.length; n < r; n++) {
-            const s = t[n];
-            (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
+        for (let n = 0, i = t.length; n < i; n++) {
+            const r = t[n];
+            (r.matrixWorldAutoUpdate === !0 || e === !0) && r.updateMatrixWorld(e);
         }
     }
     updateWorldMatrix(e, t) {
         const n = this.parent;
         if (e === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === !0) {
-            const r = this.children;
-            for (let s = 0, a = r.length; s < a; s++) {
-                const o = r[s];
-                o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
+            const i = this.children;
+            for (let r = 0, o = i.length; r < o; r++) {
+                const a = i[r];
+                a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
             }
         }
     }
     toJSON(e) {
         const t = e === void 0 || typeof e == "string",
             n = {};
         t && (e = {
@@ -4337,230 +4365,230 @@
             animations: {},
             nodes: {}
         }, n.metadata = {
             version: 4.6,
             type: "Object",
             generator: "Object3D.toJSON"
         });
-        const r = {};
-        r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((o) => ({
-            boxInitialized: o.boxInitialized,
-            boxMin: o.box.min.toArray(),
-            boxMax: o.box.max.toArray(),
-            sphereInitialized: o.sphereInitialized,
-            sphereRadius: o.sphere.radius,
-            sphereCenter: o.sphere.center.toArray()
-        })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = {
-            center: r.boundingSphere.center.toArray(),
-            radius: r.boundingSphere.radius
-        }), this.boundingBox !== null && (r.boundingBox = {
-            min: r.boundingBox.min.toArray(),
-            max: r.boundingBox.max.toArray()
+        const i = {};
+        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map((a) => ({
+            boxInitialized: a.boxInitialized,
+            boxMin: a.box.min.toArray(),
+            boxMax: a.box.max.toArray(),
+            sphereInitialized: a.sphereInitialized,
+            sphereRadius: a.sphere.radius,
+            sphereCenter: a.sphere.center.toArray()
+        })), i.maxGeometryCount = this._maxGeometryCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (i.boundingSphere = {
+            center: i.boundingSphere.center.toArray(),
+            radius: i.boundingSphere.radius
+        }), this.boundingBox !== null && (i.boundingBox = {
+            min: i.boundingBox.min.toArray(),
+            max: i.boundingBox.max.toArray()
         }));
 
-        function s(o, l) {
-            return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
+        function r(a, l) {
+            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
         }
         if (this.isScene)
-            this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(e).uuid);
+            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
         else if (this.isMesh || this.isLine || this.isPoints) {
-            r.geometry = s(e.geometries, this.geometry);
-            const o = this.geometry.parameters;
-            if (o !== void 0 && o.shapes !== void 0) {
-                const l = o.shapes;
+            i.geometry = r(e.geometries, this.geometry);
+            const a = this.geometry.parameters;
+            if (a !== void 0 && a.shapes !== void 0) {
+                const l = a.shapes;
                 if (Array.isArray(l))
                     for (let c = 0, u = l.length; c < u; c++) {
-                        const f = l[c];
-                        s(e.shapes, f);
+                        const d = l[c];
+                        r(e.shapes, d);
                     }
                 else
-                    s(e.shapes, l);
+                    r(e.shapes, l);
             }
         }
-        if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0)
+        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
             if (Array.isArray(this.material)) {
-                const o = [];
+                const a = [];
                 for (let l = 0, c = this.material.length; l < c; l++)
-                    o.push(s(e.materials, this.material[l]));
-                r.material = o;
+                    a.push(r(e.materials, this.material[l]));
+                i.material = a;
             } else
-                r.material = s(e.materials, this.material);
+                i.material = r(e.materials, this.material);
         if (this.children.length > 0) {
-            r.children = [];
-            for (let o = 0; o < this.children.length; o++)
-                r.children.push(this.children[o].toJSON(e).object);
+            i.children = [];
+            for (let a = 0; a < this.children.length; a++)
+                i.children.push(this.children[a].toJSON(e).object);
         }
         if (this.animations.length > 0) {
-            r.animations = [];
-            for (let o = 0; o < this.animations.length; o++) {
-                const l = this.animations[o];
-                r.animations.push(s(e.animations, l));
+            i.animations = [];
+            for (let a = 0; a < this.animations.length; a++) {
+                const l = this.animations[a];
+                i.animations.push(r(e.animations, l));
             }
         }
         if (t) {
-            const o = a(e.geometries),
-                l = a(e.materials),
-                c = a(e.textures),
-                u = a(e.images),
-                f = a(e.shapes),
-                h = a(e.skeletons),
-                p = a(e.animations),
-                g = a(e.nodes);
-            o.length > 0 && (n.geometries = o), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), f.length > 0 && (n.shapes = f), h.length > 0 && (n.skeletons = h), p.length > 0 && (n.animations = p), g.length > 0 && (n.nodes = g);
+            const a = o(e.geometries),
+                l = o(e.materials),
+                c = o(e.textures),
+                u = o(e.images),
+                d = o(e.shapes),
+                f = o(e.skeletons),
+                h = o(e.animations),
+                g = o(e.nodes);
+            a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), d.length > 0 && (n.shapes = d), f.length > 0 && (n.skeletons = f), h.length > 0 && (n.animations = h), g.length > 0 && (n.nodes = g);
         }
-        return n.object = r, n;
+        return n.object = i, n;
 
-        function a(o) {
+        function o(a) {
             const l = [];
-            for (const c in o) {
-                const u = o[c];
+            for (const c in a) {
+                const u = a[c];
                 delete u.metadata, l.push(u);
             }
             return l;
         }
     }
     clone(e) {
         return new this.constructor().copy(this, e);
     }
     copy(e, t = !0) {
         if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
             for (let n = 0; n < e.children.length; n++) {
-                const r = e.children[n];
-                this.add(r.clone());
+                const i = e.children[n];
+                this.add(i.clone());
             }
         return this;
     }
 }
-gt.DEFAULT_UP = /* @__PURE__ */ new P(0, 1, 0);
-gt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
-gt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
-const Qt = /* @__PURE__ */ new P(),
-    _n = /* @__PURE__ */ new P(),
-    Us = /* @__PURE__ */ new P(),
-    vn = /* @__PURE__ */ new P(),
-    Si = /* @__PURE__ */ new P(),
-    Mi = /* @__PURE__ */ new P(),
-    Ta = /* @__PURE__ */ new P(),
-    Fs = /* @__PURE__ */ new P(),
-    Ns = /* @__PURE__ */ new P(),
-    Bs = /* @__PURE__ */ new P();
-class ln {
-    constructor(e = new P(), t = new P(), n = new P()) {
+Et.DEFAULT_UP = /* @__PURE__ */ new D(0, 1, 0);
+Et.DEFAULT_MATRIX_AUTO_UPDATE = !0;
+Et.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
+const on = /* @__PURE__ */ new D(),
+    bn = /* @__PURE__ */ new D(),
+    ua = /* @__PURE__ */ new D(),
+    Cn = /* @__PURE__ */ new D(),
+    Ui = /* @__PURE__ */ new D(),
+    Bi = /* @__PURE__ */ new D(),
+    pl = /* @__PURE__ */ new D(),
+    da = /* @__PURE__ */ new D(),
+    fa = /* @__PURE__ */ new D(),
+    ha = /* @__PURE__ */ new D();
+class _n {
+    constructor(e = new D(), t = new D(), n = new D()) {
         this.a = e, this.b = t, this.c = n;
     }
-    static getNormal(e, t, n, r) {
-        r.subVectors(n, t), Qt.subVectors(e, t), r.cross(Qt);
-        const s = r.lengthSq();
-        return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
+    static getNormal(e, t, n, i) {
+        i.subVectors(n, t), on.subVectors(e, t), i.cross(on);
+        const r = i.lengthSq();
+        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
     }
     // static/instance method to calculate barycentric coordinates
     // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
-    static getBarycoord(e, t, n, r, s) {
-        Qt.subVectors(r, t), _n.subVectors(n, t), Us.subVectors(e, t);
-        const a = Qt.dot(Qt),
-            o = Qt.dot(_n),
-            l = Qt.dot(Us),
-            c = _n.dot(_n),
-            u = _n.dot(Us),
-            f = a * c - o * o;
-        if (f === 0)
-            return s.set(0, 0, 0), null;
-        const h = 1 / f,
-            p = (c * l - o * u) * h,
-            g = (a * u - o * l) * h;
-        return s.set(1 - p - g, g, p);
+    static getBarycoord(e, t, n, i, r) {
+        on.subVectors(i, t), bn.subVectors(n, t), ua.subVectors(e, t);
+        const o = on.dot(on),
+            a = on.dot(bn),
+            l = on.dot(ua),
+            c = bn.dot(bn),
+            u = bn.dot(ua),
+            d = o * c - a * a;
+        if (d === 0)
+            return r.set(0, 0, 0), null;
+        const f = 1 / d,
+            h = (c * l - a * u) * f,
+            g = (o * u - a * l) * f;
+        return r.set(1 - h - g, g, h);
     }
-    static containsPoint(e, t, n, r) {
-        return this.getBarycoord(e, t, n, r, vn) === null ? !1 : vn.x >= 0 && vn.y >= 0 && vn.x + vn.y <= 1;
+    static containsPoint(e, t, n, i) {
+        return this.getBarycoord(e, t, n, i, Cn) === null ? !1 : Cn.x >= 0 && Cn.y >= 0 && Cn.x + Cn.y <= 1;
     }
-    static getInterpolation(e, t, n, r, s, a, o, l) {
-        return this.getBarycoord(e, t, n, r, vn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, vn.x), l.addScaledVector(a, vn.y), l.addScaledVector(o, vn.z), l);
+    static getInterpolation(e, t, n, i, r, o, a, l) {
+        return this.getBarycoord(e, t, n, i, Cn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(r, Cn.x), l.addScaledVector(o, Cn.y), l.addScaledVector(a, Cn.z), l);
     }
-    static isFrontFacing(e, t, n, r) {
-        return Qt.subVectors(n, t), _n.subVectors(e, t), Qt.cross(_n).dot(r) < 0;
+    static isFrontFacing(e, t, n, i) {
+        return on.subVectors(n, t), bn.subVectors(e, t), on.cross(bn).dot(i) < 0;
     }
     set(e, t, n) {
         return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
     }
-    setFromPointsAndIndices(e, t, n, r) {
-        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this;
+    setFromPointsAndIndices(e, t, n, i) {
+        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
     }
-    setFromAttributeAndIndices(e, t, n, r) {
-        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this;
+    setFromAttributeAndIndices(e, t, n, i) {
+        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
     }
     clone() {
         return new this.constructor().copy(this);
     }
     copy(e) {
         return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
     }
     getArea() {
-        return Qt.subVectors(this.c, this.b), _n.subVectors(this.a, this.b), Qt.cross(_n).length() * 0.5;
+        return on.subVectors(this.c, this.b), bn.subVectors(this.a, this.b), on.cross(bn).length() * 0.5;
     }
     getMidpoint(e) {
         return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
     }
     getNormal(e) {
-        return ln.getNormal(this.a, this.b, this.c, e);
+        return _n.getNormal(this.a, this.b, this.c, e);
     }
     getPlane(e) {
         return e.setFromCoplanarPoints(this.a, this.b, this.c);
     }
     getBarycoord(e, t) {
-        return ln.getBarycoord(e, this.a, this.b, this.c, t);
+        return _n.getBarycoord(e, this.a, this.b, this.c, t);
     }
-    getInterpolation(e, t, n, r, s) {
-        return ln.getInterpolation(e, this.a, this.b, this.c, t, n, r, s);
+    getInterpolation(e, t, n, i, r) {
+        return _n.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
     }
     containsPoint(e) {
-        return ln.containsPoint(e, this.a, this.b, this.c);
+        return _n.containsPoint(e, this.a, this.b, this.c);
     }
     isFrontFacing(e) {
-        return ln.isFrontFacing(this.a, this.b, this.c, e);
+        return _n.isFrontFacing(this.a, this.b, this.c, e);
     }
     intersectsBox(e) {
         return e.intersectsTriangle(this);
     }
     closestPointToPoint(e, t) {
         const n = this.a,
-            r = this.b,
-            s = this.c;
-        let a, o;
-        Si.subVectors(r, n), Mi.subVectors(s, n), Fs.subVectors(e, n);
-        const l = Si.dot(Fs),
-            c = Mi.dot(Fs);
+            i = this.b,
+            r = this.c;
+        let o, a;
+        Ui.subVectors(i, n), Bi.subVectors(r, n), da.subVectors(e, n);
+        const l = Ui.dot(da),
+            c = Bi.dot(da);
         if (l <= 0 && c <= 0)
             return t.copy(n);
-        Ns.subVectors(e, r);
-        const u = Si.dot(Ns),
-            f = Mi.dot(Ns);
-        if (u >= 0 && f <= u)
+        fa.subVectors(e, i);
+        const u = Ui.dot(fa),
+            d = Bi.dot(fa);
+        if (u >= 0 && d <= u)
+            return t.copy(i);
+        const f = l * d - u * c;
+        if (f <= 0 && l >= 0 && u <= 0)
+            return o = l / (l - u), t.copy(n).addScaledVector(Ui, o);
+        ha.subVectors(e, r);
+        const h = Ui.dot(ha),
+            g = Bi.dot(ha);
+        if (g >= 0 && h <= g)
             return t.copy(r);
-        const h = l * f - u * c;
-        if (h <= 0 && l >= 0 && u <= 0)
-            return a = l / (l - u), t.copy(n).addScaledVector(Si, a);
-        Bs.subVectors(e, s);
-        const p = Si.dot(Bs),
-            g = Mi.dot(Bs);
-        if (g >= 0 && p <= g)
-            return t.copy(s);
-        const v = p * c - l * g;
-        if (v <= 0 && c >= 0 && g <= 0)
-            return o = c / (c - g), t.copy(n).addScaledVector(Mi, o);
-        const m = u * g - p * f;
-        if (m <= 0 && f - u >= 0 && p - g >= 0)
-            return Ta.subVectors(s, r), o = (f - u) / (f - u + (p - g)), t.copy(r).addScaledVector(Ta, o);
-        const d = 1 / (m + v + h);
-        return a = v * d, o = h * d, t.copy(n).addScaledVector(Si, a).addScaledVector(Mi, o);
+        const _ = h * c - l * g;
+        if (_ <= 0 && c >= 0 && g <= 0)
+            return a = c / (c - g), t.copy(n).addScaledVector(Bi, a);
+        const m = u * g - h * d;
+        if (m <= 0 && d - u >= 0 && h - g >= 0)
+            return pl.subVectors(r, i), a = (d - u) / (d - u + (h - g)), t.copy(i).addScaledVector(pl, a);
+        const p = 1 / (m + _ + f);
+        return o = _ * p, a = f * p, t.copy(n).addScaledVector(Ui, o).addScaledVector(Bi, a);
     }
     equals(e) {
         return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
     }
 }
-const Jl = {
+const qc = {
         aliceblue: 15792383,
         antiquewhite: 16444375,
         aqua: 65535,
         aquamarine: 8388564,
         azure: 15794175,
         beige: 16119260,
         bisque: 16770244,
@@ -4702,184 +4730,184 @@
         violet: 15631086,
         wheat: 16113331,
         white: 16777215,
         whitesmoke: 16119285,
         yellow: 16776960,
         yellowgreen: 10145074
     },
-    In = {
+    qn = {
         h: 0,
         s: 0,
         l: 0
     },
-    Er = {
+    Ys = {
         h: 0,
         s: 0,
         l: 0
     };
 
-function Os(i, e, t) {
-    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? i + (e - i) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? i + (e - i) * 6 * (2 / 3 - t) : i;
+function pa(s, e, t) {
+    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s;
 }
-class Qe {
+class et {
     constructor(e, t, n) {
         return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
     }
     set(e, t, n) {
         if (t === void 0 && n === void 0) {
-            const r = e;
-            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
+            const i = e;
+            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
         } else
             this.setRGB(e, t, n);
         return this;
     }
     setScalar(e) {
         return this.r = e, this.g = e, this.b = e, this;
     }
-    setHex(e, t = sn) {
-        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ze.toWorkingColorSpace(this, t), this;
+    setHex(e, t = pn) {
+        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, tt.toWorkingColorSpace(this, t), this;
     }
-    setRGB(e, t, n, r = Ze.workingColorSpace) {
-        return this.r = e, this.g = t, this.b = n, Ze.toWorkingColorSpace(this, r), this;
+    setRGB(e, t, n, i = tt.workingColorSpace) {
+        return this.r = e, this.g = t, this.b = n, tt.toWorkingColorSpace(this, i), this;
     }
-    setHSL(e, t, n, r = Ze.workingColorSpace) {
-        if (e = go(e, 1), t = xt(t, 0, 1), n = xt(n, 0, 1), t === 0)
+    setHSL(e, t, n, i = tt.workingColorSpace) {
+        if (e = Ja(e, 1), t = Ct(t, 0, 1), n = Ct(n, 0, 1), t === 0)
             this.r = this.g = this.b = n;
         else {
-            const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
-                a = 2 * n - s;
-            this.r = Os(a, s, e + 1 / 3), this.g = Os(a, s, e), this.b = Os(a, s, e - 1 / 3);
-        }
-        return Ze.toWorkingColorSpace(this, r), this;
-    }
-    setStyle(e, t = sn) {
-        function n(s) {
-            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
-        }
-        let r;
-        if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
-            let s;
-            const a = r[1],
-                o = r[2];
-            switch (a) {
+            const r = n <= 0.5 ? n * (1 + t) : n + t - n * t,
+                o = 2 * n - r;
+            this.r = pa(o, r, e + 1 / 3), this.g = pa(o, r, e), this.b = pa(o, r, e - 1 / 3);
+        }
+        return tt.toWorkingColorSpace(this, i), this;
+    }
+    setStyle(e, t = pn) {
+        function n(r) {
+            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
+        }
+        let i;
+        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
+            let r;
+            const o = i[1],
+                a = i[2];
+            switch (o) {
                 case "rgb":
                 case "rgba":
-                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
-                        return n(s[4]), this.setRGB(
-                            Math.min(255, parseInt(s[1], 10)) / 255,
-                            Math.min(255, parseInt(s[2], 10)) / 255,
-                            Math.min(255, parseInt(s[3], 10)) / 255,
+                    if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
+                        return n(r[4]), this.setRGB(
+                            Math.min(255, parseInt(r[1], 10)) / 255,
+                            Math.min(255, parseInt(r[2], 10)) / 255,
+                            Math.min(255, parseInt(r[3], 10)) / 255,
                             t
                         );
-                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
-                        return n(s[4]), this.setRGB(
-                            Math.min(100, parseInt(s[1], 10)) / 100,
-                            Math.min(100, parseInt(s[2], 10)) / 100,
-                            Math.min(100, parseInt(s[3], 10)) / 100,
+                    if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
+                        return n(r[4]), this.setRGB(
+                            Math.min(100, parseInt(r[1], 10)) / 100,
+                            Math.min(100, parseInt(r[2], 10)) / 100,
+                            Math.min(100, parseInt(r[3], 10)) / 100,
                             t
                         );
                     break;
                 case "hsl":
                 case "hsla":
-                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))
-                        return n(s[4]), this.setHSL(
-                            parseFloat(s[1]) / 360,
-                            parseFloat(s[2]) / 100,
-                            parseFloat(s[3]) / 100,
+                    if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
+                        return n(r[4]), this.setHSL(
+                            parseFloat(r[1]) / 360,
+                            parseFloat(r[2]) / 100,
+                            parseFloat(r[3]) / 100,
                             t
                         );
                     break;
                 default:
                     console.warn("THREE.Color: Unknown color model " + e);
             }
-        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
-            const s = r[1],
-                a = s.length;
-            if (a === 3)
+        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
+            const r = i[1],
+                o = r.length;
+            if (o === 3)
                 return this.setRGB(
-                    parseInt(s.charAt(0), 16) / 15,
-                    parseInt(s.charAt(1), 16) / 15,
-                    parseInt(s.charAt(2), 16) / 15,
+                    parseInt(r.charAt(0), 16) / 15,
+                    parseInt(r.charAt(1), 16) / 15,
+                    parseInt(r.charAt(2), 16) / 15,
                     t
                 );
-            if (a === 6)
-                return this.setHex(parseInt(s, 16), t);
+            if (o === 6)
+                return this.setHex(parseInt(r, 16), t);
             console.warn("THREE.Color: Invalid hex color " + e);
         } else if (e && e.length > 0)
             return this.setColorName(e, t);
         return this;
     }
-    setColorName(e, t = sn) {
-        const n = Jl[e.toLowerCase()];
+    setColorName(e, t = pn) {
+        const n = qc[e.toLowerCase()];
         return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
     }
     clone() {
         return new this.constructor(this.r, this.g, this.b);
     }
     copy(e) {
         return this.r = e.r, this.g = e.g, this.b = e.b, this;
     }
     copySRGBToLinear(e) {
-        return this.r = Bi(e.r), this.g = Bi(e.g), this.b = Bi(e.b), this;
+        return this.r = is(e.r), this.g = is(e.g), this.b = is(e.b), this;
     }
     copyLinearToSRGB(e) {
-        return this.r = Es(e.r), this.g = Es(e.g), this.b = Es(e.b), this;
+        return this.r = ea(e.r), this.g = ea(e.g), this.b = ea(e.b), this;
     }
     convertSRGBToLinear() {
         return this.copySRGBToLinear(this), this;
     }
     convertLinearToSRGB() {
         return this.copyLinearToSRGB(this), this;
     }
-    getHex(e = sn) {
-        return Ze.fromWorkingColorSpace(yt.copy(this), e), Math.round(xt(yt.r * 255, 0, 255)) * 65536 + Math.round(xt(yt.g * 255, 0, 255)) * 256 + Math.round(xt(yt.b * 255, 0, 255));
+    getHex(e = pn) {
+        return tt.fromWorkingColorSpace(Pt.copy(this), e), Math.round(Ct(Pt.r * 255, 0, 255)) * 65536 + Math.round(Ct(Pt.g * 255, 0, 255)) * 256 + Math.round(Ct(Pt.b * 255, 0, 255));
     }
-    getHexString(e = sn) {
+    getHexString(e = pn) {
         return ("000000" + this.getHex(e).toString(16)).slice(-6);
     }
-    getHSL(e, t = Ze.workingColorSpace) {
-        Ze.fromWorkingColorSpace(yt.copy(this), t);
-        const n = yt.r,
-            r = yt.g,
-            s = yt.b,
-            a = Math.max(n, r, s),
-            o = Math.min(n, r, s);
+    getHSL(e, t = tt.workingColorSpace) {
+        tt.fromWorkingColorSpace(Pt.copy(this), t);
+        const n = Pt.r,
+            i = Pt.g,
+            r = Pt.b,
+            o = Math.max(n, i, r),
+            a = Math.min(n, i, r);
         let l, c;
-        const u = (o + a) / 2;
-        if (o === a)
+        const u = (a + o) / 2;
+        if (a === o)
             l = 0, c = 0;
         else {
-            const f = a - o;
-            switch (c = u <= 0.5 ? f / (a + o) : f / (2 - a - o), a) {
+            const d = o - a;
+            switch (c = u <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
                 case n:
-                    l = (r - s) / f + (r < s ? 6 : 0);
+                    l = (i - r) / d + (i < r ? 6 : 0);
                     break;
-                case r:
-                    l = (s - n) / f + 2;
+                case i:
+                    l = (r - n) / d + 2;
                     break;
-                case s:
-                    l = (n - r) / f + 4;
+                case r:
+                    l = (n - i) / d + 4;
                     break;
             }
             l /= 6;
         }
         return e.h = l, e.s = c, e.l = u, e;
     }
-    getRGB(e, t = Ze.workingColorSpace) {
-        return Ze.fromWorkingColorSpace(yt.copy(this), t), e.r = yt.r, e.g = yt.g, e.b = yt.b, e;
+    getRGB(e, t = tt.workingColorSpace) {
+        return tt.fromWorkingColorSpace(Pt.copy(this), t), e.r = Pt.r, e.g = Pt.g, e.b = Pt.b, e;
     }
-    getStyle(e = sn) {
-        Ze.fromWorkingColorSpace(yt.copy(this), e);
-        const t = yt.r,
-            n = yt.g,
-            r = yt.b;
-        return e !== sn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(r * 255)})`;
+    getStyle(e = pn) {
+        tt.fromWorkingColorSpace(Pt.copy(this), e);
+        const t = Pt.r,
+            n = Pt.g,
+            i = Pt.b;
+        return e !== pn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
     }
     offsetHSL(e, t, n) {
-        return this.getHSL(In), this.setHSL(In.h + e, In.s + t, In.l + n);
+        return this.getHSL(qn), this.setHSL(qn.h + e, qn.s + t, qn.l + n);
     }
     add(e) {
         return this.r += e.r, this.g += e.g, this.b += e.b, this;
     }
     addColors(e, t) {
         return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
     }
@@ -4898,29 +4926,29 @@
     lerp(e, t) {
         return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
     }
     lerpColors(e, t, n) {
         return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
     }
     lerpHSL(e, t) {
-        this.getHSL(In), e.getHSL(Er);
-        const n = or(In.h, Er.h, t),
-            r = or(In.s, Er.s, t),
-            s = or(In.l, Er.l, t);
-        return this.setHSL(n, r, s), this;
+        this.getHSL(qn), e.getHSL(Ys);
+        const n = bs(qn.h, Ys.h, t),
+            i = bs(qn.s, Ys.s, t),
+            r = bs(qn.l, Ys.l, t);
+        return this.setHSL(n, i, r), this;
     }
     setFromVector3(e) {
         return this.r = e.x, this.g = e.y, this.b = e.z, this;
     }
     applyMatrix3(e) {
         const t = this.r,
             n = this.g,
-            r = this.b,
-            s = e.elements;
-        return this.r = s[0] * t + s[3] * n + s[6] * r, this.g = s[1] * t + s[4] * n + s[7] * r, this.b = s[2] * t + s[5] * n + s[8] * r, this;
+            i = this.b,
+            r = e.elements;
+        return this.r = r[0] * t + r[3] * n + r[6] * i, this.g = r[1] * t + r[4] * n + r[7] * i, this.b = r[2] * t + r[5] * n + r[8] * i, this;
     }
     equals(e) {
         return e.r === this.r && e.g === this.g && e.b === this.b;
     }
     fromArray(e, t = 0) {
         return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
     }
@@ -4933,22 +4961,22 @@
     toJSON() {
             return this.getHex();
         }
         *[Symbol.iterator]() {
             yield this.r, yield this.g, yield this.b;
         }
 }
-const yt = /* @__PURE__ */ new Qe();
-Qe.NAMES = Jl;
-let ih = 0;
-class as extends ui {
+const Pt = /* @__PURE__ */ new et();
+et.NAMES = qc;
+let $f = 0;
+class Ur extends Ti {
     constructor() {
         super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
-            value: ih++
-        }), this.uuid = Ki(), this.name = "", this.type = "Material", this.blending = ri, this.side = hn, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = cr, this.blendDst = ur, this.blendEquation = ei, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Qe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = qr, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = ha, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = di, this.stencilZFail = di, this.stencilZPass = di, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
+            value: $f++
+        }), this.uuid = ms(), this.name = "", this.type = "Material", this.blending = Si, this.side = yn, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = Ps, this.blendDst = Ds, this.blendEquation = fi, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new et(0, 0, 0), this.blendAlpha = 0, this.depthFunc = vr, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = el, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = wi, this.stencilZFail = wi, this.stencilZPass = wi, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
     }
     get alphaTest() {
         return this._alphaTest;
     }
     set alphaTest(e) {
         this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
     }
@@ -4962,20 +4990,20 @@
         if (e !== void 0)
             for (const t in e) {
                 const n = e[t];
                 if (n === void 0) {
                     console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                     continue;
                 }
-                const r = this[t];
-                if (r === void 0) {
+                const i = this[t];
+                if (i === void 0) {
                     console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                     continue;
                 }
-                r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n;
+                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
             }
     }
     toJSON(e) {
         const t = e === void 0 || typeof e == "string";
         t && (e = {
             textures: {},
             images: {}
@@ -4983,138 +5011,138 @@
         const n = {
             metadata: {
                 version: 4.6,
                 type: "Material",
                 generator: "Material.toJSON"
             }
         };
-        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== ri && (n.blending = this.blending), this.side !== hn && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== cr && (n.blendSrc = this.blendSrc), this.blendDst !== ur && (n.blendDst = this.blendDst), this.blendEquation !== ei && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== qr && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ha && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== di && (n.stencilFail = this.stencilFail), this.stencilZFail !== di && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== di && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
+        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Si && (n.blending = this.blending), this.side !== yn && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== Ps && (n.blendSrc = this.blendSrc), this.blendDst !== Ds && (n.blendDst = this.blendDst), this.blendEquation !== fi && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== vr && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== el && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== wi && (n.stencilFail = this.stencilFail), this.stencilZFail !== wi && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== wi && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
 
-        function r(s) {
-            const a = [];
-            for (const o in s) {
-                const l = s[o];
-                delete l.metadata, a.push(l);
+        function i(r) {
+            const o = [];
+            for (const a in r) {
+                const l = r[a];
+                delete l.metadata, o.push(l);
             }
-            return a;
+            return o;
         }
         if (t) {
-            const s = r(e.textures),
-                a = r(e.images);
-            s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
+            const r = i(e.textures),
+                o = i(e.images);
+            r.length > 0 && (n.textures = r), o.length > 0 && (n.images = o);
         }
         return n;
     }
     clone() {
         return new this.constructor().copy(this);
     }
     copy(e) {
         this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
         const t = e.clippingPlanes;
         let n = null;
         if (t !== null) {
-            const r = t.length;
-            n = new Array(r);
-            for (let s = 0; s !== r; ++s)
-                n[s] = t[s].clone();
+            const i = t.length;
+            n = new Array(i);
+            for (let r = 0; r !== i; ++r)
+                n[r] = t[r].clone();
         }
         return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
     }
     dispose() {
         this.dispatchEvent({
             type: "dispose"
         });
     }
     set needsUpdate(e) {
         e === !0 && this.version++;
     }
 }
-class oi extends as {
+class yi extends Ur {
     constructor(e) {
-        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Qe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new bn(), this.combine = Bl, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
+        super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new et(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Nn(), this.combine = Dc, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
     }
     copy(e) {
         return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
     }
 }
-const Sn = /* @__PURE__ */ rh();
+const Pn = /* @__PURE__ */ eh();
 
-function rh() {
-    const i = new ArrayBuffer(4),
-        e = new Float32Array(i),
-        t = new Uint32Array(i),
+function eh() {
+    const s = new ArrayBuffer(4),
+        e = new Float32Array(s),
+        t = new Uint32Array(s),
         n = new Uint32Array(512),
-        r = new Uint32Array(512);
+        i = new Uint32Array(512);
     for (let l = 0; l < 256; ++l) {
         const c = l - 127;
-        c < -27 ? (n[l] = 0, n[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, r[l] = -c - 1, r[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, r[l] = 13, r[l | 256] = 13);
+        c < -27 ? (n[l] = 0, n[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, i[l] = 13, i[l | 256] = 13);
     }
-    const s = new Uint32Array(2048),
-        a = new Uint32Array(64),
-        o = new Uint32Array(64);
+    const r = new Uint32Array(2048),
+        o = new Uint32Array(64),
+        a = new Uint32Array(64);
     for (let l = 1; l < 1024; ++l) {
         let c = l << 13,
             u = 0;
         for (; !(c & 8388608);)
             c <<= 1, u -= 8388608;
-        c &= -8388609, u += 947912704, s[l] = c | u;
+        c &= -8388609, u += 947912704, r[l] = c | u;
     }
     for (let l = 1024; l < 2048; ++l)
-        s[l] = 939524096 + (l - 1024 << 13);
+        r[l] = 939524096 + (l - 1024 << 13);
     for (let l = 1; l < 31; ++l)
-        a[l] = l << 23;
-    a[31] = 1199570944, a[32] = 2147483648;
+        o[l] = l << 23;
+    o[31] = 1199570944, o[32] = 2147483648;
     for (let l = 33; l < 63; ++l)
-        a[l] = 2147483648 + (l - 32 << 23);
-    a[63] = 3347054592;
+        o[l] = 2147483648 + (l - 32 << 23);
+    o[63] = 3347054592;
     for (let l = 1; l < 64; ++l)
-        l !== 32 && (o[l] = 1024);
+        l !== 32 && (a[l] = 1024);
     return {
         floatView: e,
         uint32View: t,
         baseTable: n,
-        shiftTable: r,
-        mantissaTable: s,
-        exponentTable: a,
-        offsetTable: o
+        shiftTable: i,
+        mantissaTable: r,
+        exponentTable: o,
+        offsetTable: a
     };
 }
 
-function sh(i) {
-    Math.abs(i) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), i = xt(i, -65504, 65504), Sn.floatView[0] = i;
-    const e = Sn.uint32View[0],
+function th(s) {
+    Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), s = Ct(s, -65504, 65504), Pn.floatView[0] = s;
+    const e = Pn.uint32View[0],
         t = e >> 23 & 511;
-    return Sn.baseTable[t] + ((e & 8388607) >> Sn.shiftTable[t]);
+    return Pn.baseTable[t] + ((e & 8388607) >> Pn.shiftTable[t]);
 }
 
-function oh(i) {
-    const e = i >> 10;
-    return Sn.uint32View[0] = Sn.mantissaTable[Sn.offsetTable[e] + (i & 1023)] + Sn.exponentTable[e], Sn.floatView[0];
+function nh(s) {
+    const e = s >> 10;
+    return Pn.uint32View[0] = Pn.mantissaTable[Pn.offsetTable[e] + (s & 1023)] + Pn.exponentTable[e], Pn.floatView[0];
 }
-const $r = {
-        toHalfFloat: sh,
-        fromHalfFloat: oh
+const Fs = {
+        toHalfFloat: th,
+        fromHalfFloat: nh
     },
-    ct = /* @__PURE__ */ new P(),
-    br = /* @__PURE__ */ new me();
-class Wt {
+    mt = /* @__PURE__ */ new D(),
+    js = /* @__PURE__ */ new Ee();
+class en {
     constructor(e, t, n = !1) {
         if (Array.isArray(e))
             throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
-        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = da, this._updateRange = {
+        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = tl, this._updateRange = {
             offset: 0,
             count: -1
-        }, this.updateRanges = [], this.gpuType = an, this.version = 0;
+        }, this.updateRanges = [], this.gpuType = gn, this.version = 0;
     }
     onUploadCallback() {}
     set needsUpdate(e) {
         e === !0 && this.version++;
     }
     get updateRange() {
-        return Vf("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
+        return kf("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
     }
     setUsage(e) {
         return this.usage = e, this;
     }
     addUpdateRange(e, t) {
         this.updateRanges.push({
             start: e,
@@ -5125,144 +5153,144 @@
         this.updateRanges.length = 0;
     }
     copy(e) {
         return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
     }
     copyAt(e, t, n) {
         e *= this.itemSize, n *= t.itemSize;
-        for (let r = 0, s = this.itemSize; r < s; r++)
-            this.array[e + r] = t.array[n + r];
+        for (let i = 0, r = this.itemSize; i < r; i++)
+            this.array[e + i] = t.array[n + i];
         return this;
     }
     copyArray(e) {
         return this.array.set(e), this;
     }
     applyMatrix3(e) {
         if (this.itemSize === 2)
             for (let t = 0, n = this.count; t < n; t++)
-                br.fromBufferAttribute(this, t), br.applyMatrix3(e), this.setXY(t, br.x, br.y);
+                js.fromBufferAttribute(this, t), js.applyMatrix3(e), this.setXY(t, js.x, js.y);
         else if (this.itemSize === 3)
             for (let t = 0, n = this.count; t < n; t++)
-                ct.fromBufferAttribute(this, t), ct.applyMatrix3(e), this.setXYZ(t, ct.x, ct.y, ct.z);
+                mt.fromBufferAttribute(this, t), mt.applyMatrix3(e), this.setXYZ(t, mt.x, mt.y, mt.z);
         return this;
     }
     applyMatrix4(e) {
         for (let t = 0, n = this.count; t < n; t++)
-            ct.fromBufferAttribute(this, t), ct.applyMatrix4(e), this.setXYZ(t, ct.x, ct.y, ct.z);
+            mt.fromBufferAttribute(this, t), mt.applyMatrix4(e), this.setXYZ(t, mt.x, mt.y, mt.z);
         return this;
     }
     applyNormalMatrix(e) {
         for (let t = 0, n = this.count; t < n; t++)
-            ct.fromBufferAttribute(this, t), ct.applyNormalMatrix(e), this.setXYZ(t, ct.x, ct.y, ct.z);
+            mt.fromBufferAttribute(this, t), mt.applyNormalMatrix(e), this.setXYZ(t, mt.x, mt.y, mt.z);
         return this;
     }
     transformDirection(e) {
         for (let t = 0, n = this.count; t < n; t++)
-            ct.fromBufferAttribute(this, t), ct.transformDirection(e), this.setXYZ(t, ct.x, ct.y, ct.z);
+            mt.fromBufferAttribute(this, t), mt.transformDirection(e), this.setXYZ(t, mt.x, mt.y, mt.z);
         return this;
     }
     set(e, t = 0) {
         return this.array.set(e, t), this;
     }
     getComponent(e, t) {
         let n = this.array[e * this.itemSize + t];
-        return this.normalized && (n = Di(n, this.array)), n;
+        return this.normalized && (n = Ki(n, this.array)), n;
     }
     setComponent(e, t, n) {
-        return this.normalized && (n = Et(n, this.array)), this.array[e * this.itemSize + t] = n, this;
+        return this.normalized && (n = It(n, this.array)), this.array[e * this.itemSize + t] = n, this;
     }
     getX(e) {
         let t = this.array[e * this.itemSize];
-        return this.normalized && (t = Di(t, this.array)), t;
+        return this.normalized && (t = Ki(t, this.array)), t;
     }
     setX(e, t) {
-        return this.normalized && (t = Et(t, this.array)), this.array[e * this.itemSize] = t, this;
+        return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize] = t, this;
     }
     getY(e) {
         let t = this.array[e * this.itemSize + 1];
-        return this.normalized && (t = Di(t, this.array)), t;
+        return this.normalized && (t = Ki(t, this.array)), t;
     }
     setY(e, t) {
-        return this.normalized && (t = Et(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
+        return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
     }
     getZ(e) {
         let t = this.array[e * this.itemSize + 2];
-        return this.normalized && (t = Di(t, this.array)), t;
+        return this.normalized && (t = Ki(t, this.array)), t;
     }
     setZ(e, t) {
-        return this.normalized && (t = Et(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
+        return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
     }
     getW(e) {
         let t = this.array[e * this.itemSize + 3];
-        return this.normalized && (t = Di(t, this.array)), t;
+        return this.normalized && (t = Ki(t, this.array)), t;
     }
     setW(e, t) {
-        return this.normalized && (t = Et(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
+        return this.normalized && (t = It(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
     }
     setXY(e, t, n) {
-        return e *= this.itemSize, this.normalized && (t = Et(t, this.array), n = Et(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
+        return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
     }
-    setXYZ(e, t, n, r) {
-        return e *= this.itemSize, this.normalized && (t = Et(t, this.array), n = Et(n, this.array), r = Et(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this;
+    setXYZ(e, t, n, i) {
+        return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), i = It(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
     }
-    setXYZW(e, t, n, r, s) {
-        return e *= this.itemSize, this.normalized && (t = Et(t, this.array), n = Et(n, this.array), r = Et(r, this.array), s = Et(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = s, this;
+    setXYZW(e, t, n, i, r) {
+        return e *= this.itemSize, this.normalized && (t = It(t, this.array), n = It(n, this.array), i = It(i, this.array), r = It(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = r, this;
     }
     onUpload(e) {
         return this.onUploadCallback = e, this;
     }
     clone() {
         return new this.constructor(this.array, this.itemSize).copy(this);
     }
     toJSON() {
         const e = {
             itemSize: this.itemSize,
             type: this.array.constructor.name,
             array: Array.from(this.array),
             normalized: this.normalized
         };
-        return this.name !== "" && (e.name = this.name), this.usage !== da && (e.usage = this.usage), e;
+        return this.name !== "" && (e.name = this.name), this.usage !== tl && (e.usage = this.usage), e;
     }
 }
-class $l extends Wt {
+class Yc extends en {
     constructor(e, t, n) {
         super(new Uint16Array(e), t, n);
     }
 }
-class ec extends Wt {
+class jc extends en {
     constructor(e, t, n) {
         super(new Uint32Array(e), t, n);
     }
 }
-class Ft extends Wt {
+class Yt extends en {
     constructor(e, t, n) {
         super(new Float32Array(e), t, n);
     }
 }
-let ah = 0;
-const zt = /* @__PURE__ */ new ke(),
-    zs = /* @__PURE__ */ new gt(),
-    yi = /* @__PURE__ */ new P(),
-    Ut = /* @__PURE__ */ new Rt(),
-    rr = /* @__PURE__ */ new Rt(),
-    pt = /* @__PURE__ */ new P();
-class Yt extends ui {
+let ih = 0;
+const Qt = /* @__PURE__ */ new Ge(),
+    ma = /* @__PURE__ */ new Et(),
+    Oi = /* @__PURE__ */ new D(),
+    Wt = /* @__PURE__ */ new Un(),
+    As = /* @__PURE__ */ new Un(),
+    Mt = /* @__PURE__ */ new D();
+class sn extends Ti {
     constructor() {
         super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
-            value: ah++
-        }), this.uuid = Ki(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
+            value: ih++
+        }), this.uuid = ms(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
             start: 0,
             count: 1 / 0
         }, this.userData = {};
     }
     getIndex() {
         return this.index;
     }
     setIndex(e) {
-        return Array.isArray(e) ? this.index = new(ql(e) ? ec : $l)(e, 1) : this.index = e, this;
+        return Array.isArray(e) ? this.index = new(zc(e) ? jc : Yc)(e, 1) : this.index = e, this;
     }
     getAttribute(e) {
         return this.attributes[e];
     }
     setAttribute(e, t) {
         return this.attributes[e] = t, this;
     }
@@ -5286,244 +5314,244 @@
         this.drawRange.start = e, this.drawRange.count = t;
     }
     applyMatrix4(e) {
         const t = this.attributes.position;
         t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
         const n = this.attributes.normal;
         if (n !== void 0) {
-            const s = new be().getNormalMatrix(e);
-            n.applyNormalMatrix(s), n.needsUpdate = !0;
+            const r = new Ue().getNormalMatrix(e);
+            n.applyNormalMatrix(r), n.needsUpdate = !0;
         }
-        const r = this.attributes.tangent;
-        return r !== void 0 && (r.transformDirection(e), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
+        const i = this.attributes.tangent;
+        return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
     }
     applyQuaternion(e) {
-        return zt.makeRotationFromQuaternion(e), this.applyMatrix4(zt), this;
+        return Qt.makeRotationFromQuaternion(e), this.applyMatrix4(Qt), this;
     }
     rotateX(e) {
-        return zt.makeRotationX(e), this.applyMatrix4(zt), this;
+        return Qt.makeRotationX(e), this.applyMatrix4(Qt), this;
     }
     rotateY(e) {
-        return zt.makeRotationY(e), this.applyMatrix4(zt), this;
+        return Qt.makeRotationY(e), this.applyMatrix4(Qt), this;
     }
     rotateZ(e) {
-        return zt.makeRotationZ(e), this.applyMatrix4(zt), this;
+        return Qt.makeRotationZ(e), this.applyMatrix4(Qt), this;
     }
     translate(e, t, n) {
-        return zt.makeTranslation(e, t, n), this.applyMatrix4(zt), this;
+        return Qt.makeTranslation(e, t, n), this.applyMatrix4(Qt), this;
     }
     scale(e, t, n) {
-        return zt.makeScale(e, t, n), this.applyMatrix4(zt), this;
+        return Qt.makeScale(e, t, n), this.applyMatrix4(Qt), this;
     }
     lookAt(e) {
-        return zs.lookAt(e), zs.updateMatrix(), this.applyMatrix4(zs.matrix), this;
+        return ma.lookAt(e), ma.updateMatrix(), this.applyMatrix4(ma.matrix), this;
     }
     center() {
-        return this.computeBoundingBox(), this.boundingBox.getCenter(yi).negate(), this.translate(yi.x, yi.y, yi.z), this;
+        return this.computeBoundingBox(), this.boundingBox.getCenter(Oi).negate(), this.translate(Oi.x, Oi.y, Oi.z), this;
     }
     setFromPoints(e) {
         const t = [];
-        for (let n = 0, r = e.length; n < r; n++) {
-            const s = e[n];
-            t.push(s.x, s.y, s.z || 0);
+        for (let n = 0, i = e.length; n < i; n++) {
+            const r = e[n];
+            t.push(r.x, r.y, r.z || 0);
         }
-        return this.setAttribute("position", new Ft(t, 3)), this;
+        return this.setAttribute("position", new Yt(t, 3)), this;
     }
     computeBoundingBox() {
-        this.boundingBox === null && (this.boundingBox = new Rt());
+        this.boundingBox === null && (this.boundingBox = new Un());
         const e = this.attributes.position,
             t = this.morphAttributes.position;
         if (e && e.isGLBufferAttribute) {
             console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
-                new P(-1 / 0, -1 / 0, -1 / 0),
-                new P(1 / 0, 1 / 0, 1 / 0)
+                new D(-1 / 0, -1 / 0, -1 / 0),
+                new D(1 / 0, 1 / 0, 1 / 0)
             );
             return;
         }
         if (e !== void 0) {
             if (this.boundingBox.setFromBufferAttribute(e), t)
-                for (let n = 0, r = t.length; n < r; n++) {
-                    const s = t[n];
-                    Ut.setFromBufferAttribute(s), this.morphTargetsRelative ? (pt.addVectors(this.boundingBox.min, Ut.min), this.boundingBox.expandByPoint(pt), pt.addVectors(this.boundingBox.max, Ut.max), this.boundingBox.expandByPoint(pt)) : (this.boundingBox.expandByPoint(Ut.min), this.boundingBox.expandByPoint(Ut.max));
+                for (let n = 0, i = t.length; n < i; n++) {
+                    const r = t[n];
+                    Wt.setFromBufferAttribute(r), this.morphTargetsRelative ? (Mt.addVectors(this.boundingBox.min, Wt.min), this.boundingBox.expandByPoint(Mt), Mt.addVectors(this.boundingBox.max, Wt.max), this.boundingBox.expandByPoint(Mt)) : (this.boundingBox.expandByPoint(Wt.min), this.boundingBox.expandByPoint(Wt.max));
                 }
         } else
             this.boundingBox.makeEmpty();
         (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
     }
     computeBoundingSphere() {
-        this.boundingSphere === null && (this.boundingSphere = new _o());
+        this.boundingSphere === null && (this.boundingSphere = new $a());
         const e = this.attributes.position,
             t = this.morphAttributes.position;
         if (e && e.isGLBufferAttribute) {
-            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new P(), 1 / 0);
+            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new D(), 1 / 0);
             return;
         }
         if (e) {
             const n = this.boundingSphere.center;
-            if (Ut.setFromBufferAttribute(e), t)
-                for (let s = 0, a = t.length; s < a; s++) {
-                    const o = t[s];
-                    rr.setFromBufferAttribute(o), this.morphTargetsRelative ? (pt.addVectors(Ut.min, rr.min), Ut.expandByPoint(pt), pt.addVectors(Ut.max, rr.max), Ut.expandByPoint(pt)) : (Ut.expandByPoint(rr.min), Ut.expandByPoint(rr.max));
-                }
-            Ut.getCenter(n);
-            let r = 0;
-            for (let s = 0, a = e.count; s < a; s++)
-                pt.fromBufferAttribute(e, s), r = Math.max(r, n.distanceToSquared(pt));
+            if (Wt.setFromBufferAttribute(e), t)
+                for (let r = 0, o = t.length; r < o; r++) {
+                    const a = t[r];
+                    As.setFromBufferAttribute(a), this.morphTargetsRelative ? (Mt.addVectors(Wt.min, As.min), Wt.expandByPoint(Mt), Mt.addVectors(Wt.max, As.max), Wt.expandByPoint(Mt)) : (Wt.expandByPoint(As.min), Wt.expandByPoint(As.max));
+                }
+            Wt.getCenter(n);
+            let i = 0;
+            for (let r = 0, o = e.count; r < o; r++)
+                Mt.fromBufferAttribute(e, r), i = Math.max(i, n.distanceToSquared(Mt));
             if (t)
-                for (let s = 0, a = t.length; s < a; s++) {
-                    const o = t[s],
+                for (let r = 0, o = t.length; r < o; r++) {
+                    const a = t[r],
                         l = this.morphTargetsRelative;
-                    for (let c = 0, u = o.count; c < u; c++)
-                        pt.fromBufferAttribute(o, c), l && (yi.fromBufferAttribute(e, c), pt.add(yi)), r = Math.max(r, n.distanceToSquared(pt));
+                    for (let c = 0, u = a.count; c < u; c++)
+                        Mt.fromBufferAttribute(a, c), l && (Oi.fromBufferAttribute(e, c), Mt.add(Oi)), i = Math.max(i, n.distanceToSquared(Mt));
                 }
-            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
+            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
         }
     }
     computeTangents() {
         const e = this.index,
             t = this.attributes;
         if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
             console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
             return;
         }
         const n = t.position,
-            r = t.normal,
-            s = t.uv;
-        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Wt(new Float32Array(4 * n.count), 4));
-        const a = this.getAttribute("tangent"),
-            o = [],
+            i = t.normal,
+            r = t.uv;
+        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new en(new Float32Array(4 * n.count), 4));
+        const o = this.getAttribute("tangent"),
+            a = [],
             l = [];
-        for (let I = 0; I < n.count; I++)
-            o[I] = new P(), l[I] = new P();
-        const c = new P(),
-            u = new P(),
-            f = new P(),
-            h = new me(),
-            p = new me(),
-            g = new me(),
-            v = new P(),
-            m = new P();
-
-        function d(I, W, S) {
-            c.fromBufferAttribute(n, I), u.fromBufferAttribute(n, W), f.fromBufferAttribute(n, S), h.fromBufferAttribute(s, I), p.fromBufferAttribute(s, W), g.fromBufferAttribute(s, S), u.sub(c), f.sub(c), p.sub(h), g.sub(h);
-            const T = 1 / (p.x * g.y - g.x * p.y);
-            isFinite(T) && (v.copy(u).multiplyScalar(g.y).addScaledVector(f, -p.y).multiplyScalar(T), m.copy(f).multiplyScalar(p.x).addScaledVector(u, -g.x).multiplyScalar(T), o[I].add(v), o[W].add(v), o[S].add(v), l[I].add(m), l[W].add(m), l[S].add(m));
+        for (let L = 0; L < n.count; L++)
+            a[L] = new D(), l[L] = new D();
+        const c = new D(),
+            u = new D(),
+            d = new D(),
+            f = new Ee(),
+            h = new Ee(),
+            g = new Ee(),
+            _ = new D(),
+            m = new D();
+
+        function p(L, B, x) {
+            c.fromBufferAttribute(n, L), u.fromBufferAttribute(n, B), d.fromBufferAttribute(n, x), f.fromBufferAttribute(r, L), h.fromBufferAttribute(r, B), g.fromBufferAttribute(r, x), u.sub(c), d.sub(c), h.sub(f), g.sub(f);
+            const A = 1 / (h.x * g.y - g.x * h.y);
+            isFinite(A) && (_.copy(u).multiplyScalar(g.y).addScaledVector(d, -h.y).multiplyScalar(A), m.copy(d).multiplyScalar(h.x).addScaledVector(u, -g.x).multiplyScalar(A), a[L].add(_), a[B].add(_), a[x].add(_), l[L].add(m), l[B].add(m), l[x].add(m));
         }
-        let M = this.groups;
-        M.length === 0 && (M = [{
+        let v = this.groups;
+        v.length === 0 && (v = [{
             start: 0,
             count: e.count
         }]);
-        for (let I = 0, W = M.length; I < W; ++I) {
-            const S = M[I],
-                T = S.start,
-                Y = S.count;
-            for (let K = T, L = T + Y; K < L; K += 3)
-                d(
-                    e.getX(K + 0),
-                    e.getX(K + 1),
-                    e.getX(K + 2)
+        for (let L = 0, B = v.length; L < B; ++L) {
+            const x = v[L],
+                A = x.start,
+                U = x.count;
+            for (let N = A, P = A + U; N < P; N += 3)
+                p(
+                    e.getX(N + 0),
+                    e.getX(N + 1),
+                    e.getX(N + 2)
                 );
         }
-        const _ = new P(),
-            A = new P(),
-            R = new P(),
-            E = new P();
-
-        function b(I) {
-            R.fromBufferAttribute(r, I), E.copy(R);
-            const W = o[I];
-            _.copy(W), _.sub(R.multiplyScalar(R.dot(W))).normalize(), A.crossVectors(E, W);
-            const T = A.dot(l[I]) < 0 ? -1 : 1;
-            a.setXYZW(I, _.x, _.y, _.z, T);
-        }
-        for (let I = 0, W = M.length; I < W; ++I) {
-            const S = M[I],
-                T = S.start,
-                Y = S.count;
-            for (let K = T, L = T + Y; K < L; K += 3)
-                b(e.getX(K + 0)), b(e.getX(K + 1)), b(e.getX(K + 2));
+        const S = new D(),
+            y = new D(),
+            b = new D(),
+            E = new D();
+
+        function T(L) {
+            b.fromBufferAttribute(i, L), E.copy(b);
+            const B = a[L];
+            S.copy(B), S.sub(b.multiplyScalar(b.dot(B))).normalize(), y.crossVectors(E, B);
+            const A = y.dot(l[L]) < 0 ? -1 : 1;
+            o.setXYZW(L, S.x, S.y, S.z, A);
+        }
+        for (let L = 0, B = v.length; L < B; ++L) {
+            const x = v[L],
+                A = x.start,
+                U = x.count;
+            for (let N = A, P = A + U; N < P; N += 3)
+                T(e.getX(N + 0)), T(e.getX(N + 1)), T(e.getX(N + 2));
         }
     }
     computeVertexNormals() {
         const e = this.index,
             t = this.getAttribute("position");
         if (t !== void 0) {
             let n = this.getAttribute("normal");
             if (n === void 0)
-                n = new Wt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
+                n = new en(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
             else
-                for (let h = 0, p = n.count; h < p; h++)
-                    n.setXYZ(h, 0, 0, 0);
-            const r = new P(),
-                s = new P(),
-                a = new P(),
-                o = new P(),
-                l = new P(),
-                c = new P(),
-                u = new P(),
-                f = new P();
+                for (let f = 0, h = n.count; f < h; f++)
+                    n.setXYZ(f, 0, 0, 0);
+            const i = new D(),
+                r = new D(),
+                o = new D(),
+                a = new D(),
+                l = new D(),
+                c = new D(),
+                u = new D(),
+                d = new D();
             if (e)
-                for (let h = 0, p = e.count; h < p; h += 3) {
-                    const g = e.getX(h + 0),
-                        v = e.getX(h + 1),
-                        m = e.getX(h + 2);
-                    r.fromBufferAttribute(t, g), s.fromBufferAttribute(t, v), a.fromBufferAttribute(t, m), u.subVectors(a, s), f.subVectors(r, s), u.cross(f), o.fromBufferAttribute(n, g), l.fromBufferAttribute(n, v), c.fromBufferAttribute(n, m), o.add(u), l.add(u), c.add(u), n.setXYZ(g, o.x, o.y, o.z), n.setXYZ(v, l.x, l.y, l.z), n.setXYZ(m, c.x, c.y, c.z);
+                for (let f = 0, h = e.count; f < h; f += 3) {
+                    const g = e.getX(f + 0),
+                        _ = e.getX(f + 1),
+                        m = e.getX(f + 2);
+                    i.fromBufferAttribute(t, g), r.fromBufferAttribute(t, _), o.fromBufferAttribute(t, m), u.subVectors(o, r), d.subVectors(i, r), u.cross(d), a.fromBufferAttribute(n, g), l.fromBufferAttribute(n, _), c.fromBufferAttribute(n, m), a.add(u), l.add(u), c.add(u), n.setXYZ(g, a.x, a.y, a.z), n.setXYZ(_, l.x, l.y, l.z), n.setXYZ(m, c.x, c.y, c.z);
                 }
             else
-                for (let h = 0, p = t.count; h < p; h += 3)
-                    r.fromBufferAttribute(t, h + 0), s.fromBufferAttribute(t, h + 1), a.fromBufferAttribute(t, h + 2), u.subVectors(a, s), f.subVectors(r, s), u.cross(f), n.setXYZ(h + 0, u.x, u.y, u.z), n.setXYZ(h + 1, u.x, u.y, u.z), n.setXYZ(h + 2, u.x, u.y, u.z);
+                for (let f = 0, h = t.count; f < h; f += 3)
+                    i.fromBufferAttribute(t, f + 0), r.fromBufferAttribute(t, f + 1), o.fromBufferAttribute(t, f + 2), u.subVectors(o, r), d.subVectors(i, r), u.cross(d), n.setXYZ(f + 0, u.x, u.y, u.z), n.setXYZ(f + 1, u.x, u.y, u.z), n.setXYZ(f + 2, u.x, u.y, u.z);
             this.normalizeNormals(), n.needsUpdate = !0;
         }
     }
     normalizeNormals() {
         const e = this.attributes.normal;
         for (let t = 0, n = e.count; t < n; t++)
-            pt.fromBufferAttribute(e, t), pt.normalize(), e.setXYZ(t, pt.x, pt.y, pt.z);
+            Mt.fromBufferAttribute(e, t), Mt.normalize(), e.setXYZ(t, Mt.x, Mt.y, Mt.z);
     }
     toNonIndexed() {
-        function e(o, l) {
-            const c = o.array,
-                u = o.itemSize,
-                f = o.normalized,
-                h = new c.constructor(l.length * u);
-            let p = 0,
+        function e(a, l) {
+            const c = a.array,
+                u = a.itemSize,
+                d = a.normalized,
+                f = new c.constructor(l.length * u);
+            let h = 0,
                 g = 0;
-            for (let v = 0, m = l.length; v < m; v++) {
-                o.isInterleavedBufferAttribute ? p = l[v] * o.data.stride + o.offset : p = l[v] * u;
-                for (let d = 0; d < u; d++)
-                    h[g++] = c[p++];
+            for (let _ = 0, m = l.length; _ < m; _++) {
+                a.isInterleavedBufferAttribute ? h = l[_] * a.data.stride + a.offset : h = l[_] * u;
+                for (let p = 0; p < u; p++)
+                    f[g++] = c[h++];
             }
-            return new Wt(h, u, f);
+            return new en(f, u, d);
         }
         if (this.index === null)
             return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
-        const t = new Yt(),
+        const t = new sn(),
             n = this.index.array,
-            r = this.attributes;
-        for (const o in r) {
-            const l = r[o],
+            i = this.attributes;
+        for (const a in i) {
+            const l = i[a],
                 c = e(l, n);
-            t.setAttribute(o, c);
+            t.setAttribute(a, c);
         }
-        const s = this.morphAttributes;
-        for (const o in s) {
+        const r = this.morphAttributes;
+        for (const a in r) {
             const l = [],
-                c = s[o];
-            for (let u = 0, f = c.length; u < f; u++) {
-                const h = c[u],
-                    p = e(h, n);
-                l.push(p);
+                c = r[a];
+            for (let u = 0, d = c.length; u < d; u++) {
+                const f = c[u],
+                    h = e(f, n);
+                l.push(h);
             }
-            t.morphAttributes[o] = l;
+            t.morphAttributes[a] = l;
         }
         t.morphTargetsRelative = this.morphTargetsRelative;
-        const a = this.groups;
-        for (let o = 0, l = a.length; o < l; o++) {
-            const c = a[o];
+        const o = this.groups;
+        for (let a = 0, l = o.length; a < l; a++) {
+            const c = o[a];
             t.addGroup(c.start, c.count, c.materialIndex);
         }
         return t;
     }
     toJSON() {
         const e = {
             metadata: {
@@ -5547,327 +5575,327 @@
             array: Array.prototype.slice.call(t.array)
         });
         const n = this.attributes;
         for (const l in n) {
             const c = n[l];
             e.data.attributes[l] = c.toJSON(e.data);
         }
-        const r = {};
-        let s = !1;
+        const i = {};
+        let r = !1;
         for (const l in this.morphAttributes) {
             const c = this.morphAttributes[l],
                 u = [];
-            for (let f = 0, h = c.length; f < h; f++) {
-                const p = c[f];
-                u.push(p.toJSON(e.data));
-            }
-            u.length > 0 && (r[l] = u, s = !0);
-        }
-        s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
-        const a = this.groups;
-        a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
-        const o = this.boundingSphere;
-        return o !== null && (e.data.boundingSphere = {
-            center: o.center.toArray(),
-            radius: o.radius
+            for (let d = 0, f = c.length; d < f; d++) {
+                const h = c[d];
+                u.push(h.toJSON(e.data));
+            }
+            u.length > 0 && (i[l] = u, r = !0);
+        }
+        r && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
+        const o = this.groups;
+        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
+        const a = this.boundingSphere;
+        return a !== null && (e.data.boundingSphere = {
+            center: a.center.toArray(),
+            radius: a.radius
         }), e;
     }
     clone() {
         return new this.constructor().copy(this);
     }
     copy(e) {
         this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
         const t = {};
         this.name = e.name;
         const n = e.index;
         n !== null && this.setIndex(n.clone(t));
-        const r = e.attributes;
-        for (const c in r) {
-            const u = r[c];
+        const i = e.attributes;
+        for (const c in i) {
+            const u = i[c];
             this.setAttribute(c, u.clone(t));
         }
-        const s = e.morphAttributes;
-        for (const c in s) {
+        const r = e.morphAttributes;
+        for (const c in r) {
             const u = [],
-                f = s[c];
-            for (let h = 0, p = f.length; h < p; h++)
-                u.push(f[h].clone(t));
+                d = r[c];
+            for (let f = 0, h = d.length; f < h; f++)
+                u.push(d[f].clone(t));
             this.morphAttributes[c] = u;
         }
         this.morphTargetsRelative = e.morphTargetsRelative;
-        const a = e.groups;
-        for (let c = 0, u = a.length; c < u; c++) {
-            const f = a[c];
-            this.addGroup(f.start, f.count, f.materialIndex);
+        const o = e.groups;
+        for (let c = 0, u = o.length; c < u; c++) {
+            const d = o[c];
+            this.addGroup(d.start, d.count, d.materialIndex);
         }
-        const o = e.boundingBox;
-        o !== null && (this.boundingBox = o.clone());
+        const a = e.boundingBox;
+        a !== null && (this.boundingBox = a.clone());
         const l = e.boundingSphere;
         return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
     }
     dispose() {
         this.dispatchEvent({
             type: "dispose"
         });
     }
 }
-const wa = /* @__PURE__ */ new ke(),
-    Kn = /* @__PURE__ */ new Ql(),
-    Tr = /* @__PURE__ */ new _o(),
-    Ca = /* @__PURE__ */ new P(),
-    Ai = /* @__PURE__ */ new P(),
-    Ei = /* @__PURE__ */ new P(),
-    bi = /* @__PURE__ */ new P(),
-    ks = /* @__PURE__ */ new P(),
-    wr = /* @__PURE__ */ new P(),
-    Cr = /* @__PURE__ */ new me(),
-    Rr = /* @__PURE__ */ new me(),
-    Pr = /* @__PURE__ */ new me(),
-    Ra = /* @__PURE__ */ new P(),
-    Pa = /* @__PURE__ */ new P(),
-    La = /* @__PURE__ */ new P(),
-    Lr = /* @__PURE__ */ new P(),
-    Dr = /* @__PURE__ */ new P();
-class at extends gt {
-    constructor(e = new Yt(), t = new oi()) {
+const ml = /* @__PURE__ */ new Ge(),
+    oi = /* @__PURE__ */ new Wc(),
+    Ks = /* @__PURE__ */ new $a(),
+    gl = /* @__PURE__ */ new D(),
+    Ni = /* @__PURE__ */ new D(),
+    ki = /* @__PURE__ */ new D(),
+    zi = /* @__PURE__ */ new D(),
+    ga = /* @__PURE__ */ new D(),
+    Zs = /* @__PURE__ */ new D(),
+    Qs = /* @__PURE__ */ new Ee(),
+    Js = /* @__PURE__ */ new Ee(),
+    $s = /* @__PURE__ */ new Ee(),
+    _l = /* @__PURE__ */ new D(),
+    Sl = /* @__PURE__ */ new D(),
+    vl = /* @__PURE__ */ new D(),
+    er = /* @__PURE__ */ new D(),
+    tr = /* @__PURE__ */ new D();
+class pt extends Et {
+    constructor(e = new sn(), t = new yi()) {
         super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
     }
     copy(e, t) {
         return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
     }
     updateMorphTargets() {
         const t = this.geometry.morphAttributes,
             n = Object.keys(t);
         if (n.length > 0) {
-            const r = t[n[0]];
-            if (r !== void 0) {
+            const i = t[n[0]];
+            if (i !== void 0) {
                 this.morphTargetInfluences = [], this.morphTargetDictionary = {};
-                for (let s = 0, a = r.length; s < a; s++) {
-                    const o = r[s].name || String(s);
-                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[o] = s;
+                for (let r = 0, o = i.length; r < o; r++) {
+                    const a = i[r].name || String(r);
+                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
                 }
             }
         }
     }
     getVertexPosition(e, t) {
         const n = this.geometry,
-            r = n.attributes.position,
-            s = n.morphAttributes.position,
-            a = n.morphTargetsRelative;
-        t.fromBufferAttribute(r, e);
-        const o = this.morphTargetInfluences;
-        if (s && o) {
-            wr.set(0, 0, 0);
-            for (let l = 0, c = s.length; l < c; l++) {
-                const u = o[l],
-                    f = s[l];
-                u !== 0 && (ks.fromBufferAttribute(f, e), a ? wr.addScaledVector(ks, u) : wr.addScaledVector(ks.sub(t), u));
+            i = n.attributes.position,
+            r = n.morphAttributes.position,
+            o = n.morphTargetsRelative;
+        t.fromBufferAttribute(i, e);
+        const a = this.morphTargetInfluences;
+        if (r && a) {
+            Zs.set(0, 0, 0);
+            for (let l = 0, c = r.length; l < c; l++) {
+                const u = a[l],
+                    d = r[l];
+                u !== 0 && (ga.fromBufferAttribute(d, e), o ? Zs.addScaledVector(ga, u) : Zs.addScaledVector(ga.sub(t), u));
             }
-            t.add(wr);
+            t.add(Zs);
         }
         return t;
     }
     raycast(e, t) {
         const n = this.geometry,
-            r = this.material,
-            s = this.matrixWorld;
-        r !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Tr.copy(n.boundingSphere), Tr.applyMatrix4(s), Kn.copy(e.ray).recast(e.near), !(Tr.containsPoint(Kn.origin) === !1 && (Kn.intersectSphere(Tr, Ca) === null || Kn.origin.distanceToSquared(Ca) > (e.far - e.near) ** 2)) && (wa.copy(s).invert(), Kn.copy(e.ray).applyMatrix4(wa), !(n.boundingBox !== null && Kn.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, Kn)));
+            i = this.material,
+            r = this.matrixWorld;
+        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), Ks.copy(n.boundingSphere), Ks.applyMatrix4(r), oi.copy(e.ray).recast(e.near), !(Ks.containsPoint(oi.origin) === !1 && (oi.intersectSphere(Ks, gl) === null || oi.origin.distanceToSquared(gl) > (e.far - e.near) ** 2)) && (ml.copy(r).invert(), oi.copy(e.ray).applyMatrix4(ml), !(n.boundingBox !== null && oi.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, oi)));
     }
     _computeIntersections(e, t, n) {
-        let r;
-        const s = this.geometry,
-            a = this.material,
-            o = s.index,
-            l = s.attributes.position,
-            c = s.attributes.uv,
-            u = s.attributes.uv1,
-            f = s.attributes.normal,
-            h = s.groups,
-            p = s.drawRange;
-        if (o !== null)
-            if (Array.isArray(a))
-                for (let g = 0, v = h.length; g < v; g++) {
-                    const m = h[g],
-                        d = a[m.materialIndex],
-                        M = Math.max(m.start, p.start),
-                        _ = Math.min(o.count, Math.min(m.start + m.count, p.start + p.count));
-                    for (let A = M, R = _; A < R; A += 3) {
-                        const E = o.getX(A),
-                            b = o.getX(A + 1),
-                            I = o.getX(A + 2);
-                        r = Ir(this, d, e, n, c, u, f, E, b, I), r && (r.faceIndex = Math.floor(A / 3), r.face.materialIndex = m.materialIndex, t.push(r));
+        let i;
+        const r = this.geometry,
+            o = this.material,
+            a = r.index,
+            l = r.attributes.position,
+            c = r.attributes.uv,
+            u = r.attributes.uv1,
+            d = r.attributes.normal,
+            f = r.groups,
+            h = r.drawRange;
+        if (a !== null)
+            if (Array.isArray(o))
+                for (let g = 0, _ = f.length; g < _; g++) {
+                    const m = f[g],
+                        p = o[m.materialIndex],
+                        v = Math.max(m.start, h.start),
+                        S = Math.min(a.count, Math.min(m.start + m.count, h.start + h.count));
+                    for (let y = v, b = S; y < b; y += 3) {
+                        const E = a.getX(y),
+                            T = a.getX(y + 1),
+                            L = a.getX(y + 2);
+                        i = nr(this, p, e, n, c, u, d, E, T, L), i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = m.materialIndex, t.push(i));
                     }
                 }
         else {
-            const g = Math.max(0, p.start),
-                v = Math.min(o.count, p.start + p.count);
-            for (let m = g, d = v; m < d; m += 3) {
-                const M = o.getX(m),
-                    _ = o.getX(m + 1),
-                    A = o.getX(m + 2);
-                r = Ir(this, a, e, n, c, u, f, M, _, A), r && (r.faceIndex = Math.floor(m / 3), t.push(r));
+            const g = Math.max(0, h.start),
+                _ = Math.min(a.count, h.start + h.count);
+            for (let m = g, p = _; m < p; m += 3) {
+                const v = a.getX(m),
+                    S = a.getX(m + 1),
+                    y = a.getX(m + 2);
+                i = nr(this, o, e, n, c, u, d, v, S, y), i && (i.faceIndex = Math.floor(m / 3), t.push(i));
             }
         } else if (l !== void 0)
-            if (Array.isArray(a))
-                for (let g = 0, v = h.length; g < v; g++) {
-                    const m = h[g],
-                        d = a[m.materialIndex],
-                        M = Math.max(m.start, p.start),
-                        _ = Math.min(l.count, Math.min(m.start + m.count, p.start + p.count));
-                    for (let A = M, R = _; A < R; A += 3) {
-                        const E = A,
-                            b = A + 1,
-                            I = A + 2;
-                        r = Ir(this, d, e, n, c, u, f, E, b, I), r && (r.faceIndex = Math.floor(A / 3), r.face.materialIndex = m.materialIndex, t.push(r));
+            if (Array.isArray(o))
+                for (let g = 0, _ = f.length; g < _; g++) {
+                    const m = f[g],
+                        p = o[m.materialIndex],
+                        v = Math.max(m.start, h.start),
+                        S = Math.min(l.count, Math.min(m.start + m.count, h.start + h.count));
+                    for (let y = v, b = S; y < b; y += 3) {
+                        const E = y,
+                            T = y + 1,
+                            L = y + 2;
+                        i = nr(this, p, e, n, c, u, d, E, T, L), i && (i.faceIndex = Math.floor(y / 3), i.face.materialIndex = m.materialIndex, t.push(i));
                     }
                 }
         else {
-            const g = Math.max(0, p.start),
-                v = Math.min(l.count, p.start + p.count);
-            for (let m = g, d = v; m < d; m += 3) {
-                const M = m,
-                    _ = m + 1,
-                    A = m + 2;
-                r = Ir(this, a, e, n, c, u, f, M, _, A), r && (r.faceIndex = Math.floor(m / 3), t.push(r));
+            const g = Math.max(0, h.start),
+                _ = Math.min(l.count, h.start + h.count);
+            for (let m = g, p = _; m < p; m += 3) {
+                const v = m,
+                    S = m + 1,
+                    y = m + 2;
+                i = nr(this, o, e, n, c, u, d, v, S, y), i && (i.faceIndex = Math.floor(m / 3), t.push(i));
             }
         }
     }
 }
 
-function lh(i, e, t, n, r, s, a, o) {
+function sh(s, e, t, n, i, r, o, a) {
     let l;
-    if (e.side === Pt ? l = n.intersectTriangle(a, s, r, !0, o) : l = n.intersectTriangle(r, s, a, e.side === hn, o), l === null)
+    if (e.side === zt ? l = n.intersectTriangle(o, r, i, !0, a) : l = n.intersectTriangle(i, r, o, e.side === yn, a), l === null)
         return null;
-    Dr.copy(o), Dr.applyMatrix4(i.matrixWorld);
-    const c = t.ray.origin.distanceTo(Dr);
+    tr.copy(a), tr.applyMatrix4(s.matrixWorld);
+    const c = t.ray.origin.distanceTo(tr);
     return c < t.near || c > t.far ? null : {
         distance: c,
-        point: Dr.clone(),
-        object: i
+        point: tr.clone(),
+        object: s
     };
 }
 
-function Ir(i, e, t, n, r, s, a, o, l, c) {
-    i.getVertexPosition(o, Ai), i.getVertexPosition(l, Ei), i.getVertexPosition(c, bi);
-    const u = lh(i, e, t, n, Ai, Ei, bi, Lr);
+function nr(s, e, t, n, i, r, o, a, l, c) {
+    s.getVertexPosition(a, Ni), s.getVertexPosition(l, ki), s.getVertexPosition(c, zi);
+    const u = sh(s, e, t, n, Ni, ki, zi, er);
     if (u) {
-        r && (Cr.fromBufferAttribute(r, o), Rr.fromBufferAttribute(r, l), Pr.fromBufferAttribute(r, c), u.uv = ln.getInterpolation(Lr, Ai, Ei, bi, Cr, Rr, Pr, new me())), s && (Cr.fromBufferAttribute(s, o), Rr.fromBufferAttribute(s, l), Pr.fromBufferAttribute(s, c), u.uv1 = ln.getInterpolation(Lr, Ai, Ei, bi, Cr, Rr, Pr, new me())), a && (Ra.fromBufferAttribute(a, o), Pa.fromBufferAttribute(a, l), La.fromBufferAttribute(a, c), u.normal = ln.getInterpolation(Lr, Ai, Ei, bi, Ra, Pa, La, new P()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
-        const f = {
-            a: o,
+        i && (Qs.fromBufferAttribute(i, a), Js.fromBufferAttribute(i, l), $s.fromBufferAttribute(i, c), u.uv = _n.getInterpolation(er, Ni, ki, zi, Qs, Js, $s, new Ee())), r && (Qs.fromBufferAttribute(r, a), Js.fromBufferAttribute(r, l), $s.fromBufferAttribute(r, c), u.uv1 = _n.getInterpolation(er, Ni, ki, zi, Qs, Js, $s, new Ee())), o && (_l.fromBufferAttribute(o, a), Sl.fromBufferAttribute(o, l), vl.fromBufferAttribute(o, c), u.normal = _n.getInterpolation(er, Ni, ki, zi, _l, Sl, vl, new D()), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
+        const d = {
+            a,
             b: l,
             c,
-            normal: new P(),
+            normal: new D(),
             materialIndex: 0
         };
-        ln.getNormal(Ai, Ei, bi, f.normal), u.face = f;
+        _n.getNormal(Ni, ki, zi, d.normal), u.face = d;
     }
     return u;
 }
-class Qi extends Yt {
-    constructor(e = 1, t = 1, n = 1, r = 1, s = 1, a = 1) {
+class gs extends sn {
+    constructor(e = 1, t = 1, n = 1, i = 1, r = 1, o = 1) {
         super(), this.type = "BoxGeometry", this.parameters = {
             width: e,
             height: t,
             depth: n,
-            widthSegments: r,
-            heightSegments: s,
-            depthSegments: a
+            widthSegments: i,
+            heightSegments: r,
+            depthSegments: o
         };
-        const o = this;
-        r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
+        const a = this;
+        i = Math.floor(i), r = Math.floor(r), o = Math.floor(o);
         const l = [],
             c = [],
             u = [],
-            f = [];
-        let h = 0,
-            p = 0;
-        g("z", "y", "x", -1, -1, n, t, e, a, s, 0), g("z", "y", "x", 1, -1, n, t, -e, a, s, 1), g("x", "z", "y", 1, 1, e, n, t, r, a, 2), g("x", "z", "y", 1, -1, e, n, -t, r, a, 3), g("x", "y", "z", 1, -1, e, t, n, r, s, 4), g("x", "y", "z", -1, -1, e, t, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new Ft(c, 3)), this.setAttribute("normal", new Ft(u, 3)), this.setAttribute("uv", new Ft(f, 2));
-
-        function g(v, m, d, M, _, A, R, E, b, I, W) {
-            const S = A / b,
-                T = R / I,
-                Y = A / 2,
-                K = R / 2,
-                L = E / 2,
-                N = b + 1,
-                O = I + 1;
-            let B = 0,
-                j = 0;
-            const q = new P();
-            for (let J = 0; J < O; J++) {
-                const ne = J * T - K;
-                for (let ue = 0; ue < N; ue++) {
-                    const Z = ue * S - Y;
-                    q[v] = Z * M, q[m] = ne * _, q[d] = L, c.push(q.x, q.y, q.z), q[v] = 0, q[m] = 0, q[d] = E > 0 ? 1 : -1, u.push(q.x, q.y, q.z), f.push(ue / b), f.push(1 - J / I), B += 1;
-                }
-            }
-            for (let J = 0; J < I; J++)
-                for (let ne = 0; ne < b; ne++) {
-                    const ue = h + ne + N * J,
-                        Z = h + ne + N * (J + 1),
-                        H = h + (ne + 1) + N * (J + 1),
-                        ee = h + (ne + 1) + N * J;
-                    l.push(ue, Z, ee), l.push(Z, H, ee), j += 6;
+            d = [];
+        let f = 0,
+            h = 0;
+        g("z", "y", "x", -1, -1, n, t, e, o, r, 0), g("z", "y", "x", 1, -1, n, t, -e, o, r, 1), g("x", "z", "y", 1, 1, e, n, t, i, o, 2), g("x", "z", "y", 1, -1, e, n, -t, i, o, 3), g("x", "y", "z", 1, -1, e, t, n, i, r, 4), g("x", "y", "z", -1, -1, e, t, -n, i, r, 5), this.setIndex(l), this.setAttribute("position", new Yt(c, 3)), this.setAttribute("normal", new Yt(u, 3)), this.setAttribute("uv", new Yt(d, 2));
+
+        function g(_, m, p, v, S, y, b, E, T, L, B) {
+            const x = y / T,
+                A = b / L,
+                U = y / 2,
+                N = b / 2,
+                P = E / 2,
+                I = T + 1,
+                z = L + 1;
+            let K = 0,
+                G = 0;
+            const q = new D();
+            for (let Q = 0; Q < z; Q++) {
+                const te = Q * A - N;
+                for (let fe = 0; fe < I; fe++) {
+                    const ne = fe * x - U;
+                    q[_] = ne * v, q[m] = te * S, q[p] = P, c.push(q.x, q.y, q.z), q[_] = 0, q[m] = 0, q[p] = E > 0 ? 1 : -1, u.push(q.x, q.y, q.z), d.push(fe / T), d.push(1 - Q / L), K += 1;
+                }
+            }
+            for (let Q = 0; Q < L; Q++)
+                for (let te = 0; te < T; te++) {
+                    const fe = f + te + I * Q,
+                        ne = f + te + I * (Q + 1),
+                        V = f + (te + 1) + I * (Q + 1),
+                        J = f + (te + 1) + I * Q;
+                    l.push(fe, ne, J), l.push(ne, V, J), G += 6;
                 }
-            o.addGroup(p, j, W), p += j, h += B;
+            a.addGroup(h, G, B), h += G, f += K;
         }
     }
     copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
     }
     static fromJSON(e) {
-        return new Qi(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
+        return new gs(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
     }
 }
 
-function Vi(i) {
+function us(s) {
     const e = {};
-    for (const t in i) {
+    for (const t in s) {
         e[t] = {};
-        for (const n in i[t]) {
-            const r = i[t][n];
-            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = r.clone() : Array.isArray(r) ? e[t][n] = r.slice() : e[t][n] = r;
+        for (const n in s[t]) {
+            const i = s[t][n];
+            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
         }
     }
     return e;
 }
 
-function bt(i) {
+function Ut(s) {
     const e = {};
-    for (let t = 0; t < i.length; t++) {
-        const n = Vi(i[t]);
-        for (const r in n)
-            e[r] = n[r];
+    for (let t = 0; t < s.length; t++) {
+        const n = us(s[t]);
+        for (const i in n)
+            e[i] = n[i];
     }
     return e;
 }
 
-function ch(i) {
+function rh(s) {
     const e = [];
-    for (let t = 0; t < i.length; t++)
-        e.push(i[t].clone());
+    for (let t = 0; t < s.length; t++)
+        e.push(s[t].clone());
     return e;
 }
 
-function tc(i) {
-    return i.getRenderTarget() === null ? i.outputColorSpace : Ze.workingColorSpace;
+function Kc(s) {
+    return s.getRenderTarget() === null ? s.outputColorSpace : tt.workingColorSpace;
 }
-const uh = {
-    clone: Vi,
-    merge: bt
+const ah = {
+    clone: us,
+    merge: Ut
 };
-var fh = `void main() {
+var oh = `void main() {
 	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
 }`,
-    hh = `void main() {
+    lh = `void main() {
 	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
 }`;
-class Xt extends as {
+class tn extends Ur {
     constructor(e) {
-        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = fh, this.fragmentShader = hh, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
+        super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = oh, this.fragmentShader = lh, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
             derivatives: !1,
             // set to use derivatives
             fragDepth: !1,
             // set to use fragment depth values
             drawBuffers: !1,
             // set to use draw buffers
             shaderTextureLOD: !1,
@@ -5879,56 +5907,56 @@
         }, this.defaultAttributeValues = {
             color: [1, 1, 1],
             uv: [0, 0],
             uv1: [0, 0]
         }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
     }
     copy(e) {
-        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Vi(e.uniforms), this.uniformsGroups = ch(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
+        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = us(e.uniforms), this.uniformsGroups = rh(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
     }
     toJSON(e) {
         const t = super.toJSON(e);
         t.glslVersion = this.glslVersion, t.uniforms = {};
-        for (const r in this.uniforms) {
-            const a = this.uniforms[r].value;
-            a && a.isTexture ? t.uniforms[r] = {
+        for (const i in this.uniforms) {
+            const o = this.uniforms[i].value;
+            o && o.isTexture ? t.uniforms[i] = {
                 type: "t",
-                value: a.toJSON(e).uuid
-            } : a && a.isColor ? t.uniforms[r] = {
+                value: o.toJSON(e).uuid
+            } : o && o.isColor ? t.uniforms[i] = {
                 type: "c",
-                value: a.getHex()
-            } : a && a.isVector2 ? t.uniforms[r] = {
+                value: o.getHex()
+            } : o && o.isVector2 ? t.uniforms[i] = {
                 type: "v2",
-                value: a.toArray()
-            } : a && a.isVector3 ? t.uniforms[r] = {
+                value: o.toArray()
+            } : o && o.isVector3 ? t.uniforms[i] = {
                 type: "v3",
-                value: a.toArray()
-            } : a && a.isVector4 ? t.uniforms[r] = {
+                value: o.toArray()
+            } : o && o.isVector4 ? t.uniforms[i] = {
                 type: "v4",
-                value: a.toArray()
-            } : a && a.isMatrix3 ? t.uniforms[r] = {
+                value: o.toArray()
+            } : o && o.isMatrix3 ? t.uniforms[i] = {
                 type: "m3",
-                value: a.toArray()
-            } : a && a.isMatrix4 ? t.uniforms[r] = {
+                value: o.toArray()
+            } : o && o.isMatrix4 ? t.uniforms[i] = {
                 type: "m4",
-                value: a.toArray()
-            } : t.uniforms[r] = {
-                value: a
+                value: o.toArray()
+            } : t.uniforms[i] = {
+                value: o
             };
         }
         Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
         const n = {};
-        for (const r in this.extensions)
-            this.extensions[r] === !0 && (n[r] = !0);
+        for (const i in this.extensions)
+            this.extensions[i] === !0 && (n[i] = !0);
         return Object.keys(n).length > 0 && (t.extensions = n), t;
     }
 }
-class nc extends gt {
+class Zc extends Et {
     constructor() {
-        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new ke(), this.projectionMatrix = new ke(), this.projectionMatrixInverse = new ke(), this.coordinateSystem = Mn;
+        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ge(), this.projectionMatrix = new Ge(), this.projectionMatrixInverse = new Ge(), this.coordinateSystem = Dn;
     }
     copy(e, t) {
         return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
     }
     getWorldDirection(e) {
         return super.getWorldDirection(e).negate();
     }
@@ -5938,67 +5966,67 @@
     updateWorldMatrix(e, t) {
         super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
     }
     clone() {
         return new this.constructor().copy(this);
     }
 }
-const Un = /* @__PURE__ */ new P(),
-    Da = /* @__PURE__ */ new me(),
-    Ia = /* @__PURE__ */ new me();
-class Ht extends nc {
-    constructor(e = 50, t = 1, n = 0.1, r = 2e3) {
-        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
+const Yn = /* @__PURE__ */ new D(),
+    xl = /* @__PURE__ */ new Ee(),
+    yl = /* @__PURE__ */ new Ee();
+class $t extends Zc {
+    constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
+        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
     }
     copy(e, t) {
         return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
     }
     /**
      * Sets the FOV by focal length in respect to the current .filmGauge.
      *
      * The default film gauge is 35, so that the focal length can be specified for
      * a 35mm (full frame) camera.
      *
      * Values for focal length and film gauge must have the same unit.
      */
     setFocalLength(e) {
         const t = 0.5 * this.getFilmHeight() / e;
-        this.fov = fr * 2 * Math.atan(t), this.updateProjectionMatrix();
+        this.fov = Ls * 2 * Math.atan(t), this.updateProjectionMatrix();
     }
     /**
      * Calculates the focal length from the current .fov and .filmGauge.
      */
     getFocalLength() {
-        const e = Math.tan(sr * 0.5 * this.fov);
+        const e = Math.tan(Ts * 0.5 * this.fov);
         return 0.5 * this.getFilmHeight() / e;
     }
     getEffectiveFOV() {
-        return fr * 2 * Math.atan(
-            Math.tan(sr * 0.5 * this.fov) / this.zoom
+        return Ls * 2 * Math.atan(
+            Math.tan(Ts * 0.5 * this.fov) / this.zoom
         );
     }
     getFilmWidth() {
         return this.filmGauge * Math.min(this.aspect, 1);
     }
     getFilmHeight() {
         return this.filmGauge / Math.max(this.aspect, 1);
     }
     /**
      * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
      * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
      */
     getViewBounds(e, t, n) {
-        Un.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Un.x, Un.y).multiplyScalar(-e / Un.z), Un.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Un.x, Un.y).multiplyScalar(-e / Un.z);
+        Yn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Yn.x, Yn.y).multiplyScalar(-e / Yn.z), Yn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Yn.x, Yn.y).multiplyScalar(-e / Yn.z);
     }
     /**
      * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
      * Copies the result into the target Vector2, where x is width and y is height.
      */
     getViewSize(e, t) {
-        return this.getViewBounds(e, Da, Ia), t.subVectors(Ia, Da);
+        return this.getViewBounds(e, xl, yl), t.subVectors(yl, xl);
     }
     /**
      * Sets an offset in a larger frustum. This is useful for multi-window or
      * multi-monitor/multi-machine setups.
      *
      * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
      * the monitors are in grid like this
@@ -6027,115 +6055,115 @@
      *   --E--
      *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
      *   --F--
      *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
      *
      *   Note there is no reason monitors have to be the same size or in a grid.
      */
-    setViewOffset(e, t, n, r, s, a) {
+    setViewOffset(e, t, n, i, r, o) {
         this.aspect = e / t, this.view === null && (this.view = {
             enabled: !0,
             fullWidth: 1,
             fullHeight: 1,
             offsetX: 0,
             offsetY: 0,
             width: 1,
             height: 1
-        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
+        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
     }
     clearViewOffset() {
         this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
     }
     updateProjectionMatrix() {
         const e = this.near;
-        let t = e * Math.tan(sr * 0.5 * this.fov) / this.zoom,
+        let t = e * Math.tan(Ts * 0.5 * this.fov) / this.zoom,
             n = 2 * t,
-            r = this.aspect * n,
-            s = -0.5 * r;
-        const a = this.view;
+            i = this.aspect * n,
+            r = -0.5 * i;
+        const o = this.view;
         if (this.view !== null && this.view.enabled) {
-            const l = a.fullWidth,
-                c = a.fullHeight;
-            s += a.offsetX * r / l, t -= a.offsetY * n / c, r *= a.width / l, n *= a.height / c;
+            const l = o.fullWidth,
+                c = o.fullHeight;
+            r += o.offsetX * i / l, t -= o.offsetY * n / c, i *= o.width / l, n *= o.height / c;
         }
-        const o = this.filmOffset;
-        o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
+        const a = this.filmOffset;
+        a !== 0 && (r += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
     }
     toJSON(e) {
         const t = super.toJSON(e);
         return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
     }
 }
-const Ti = -90,
-    wi = 1;
-class dh extends gt {
+const Hi = -90,
+    Gi = 1;
+class ch extends Et {
     constructor(e, t, n) {
         super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
-        const r = new Ht(Ti, wi, e, t);
+        const i = new $t(Hi, Gi, e, t);
+        i.layers = this.layers, this.add(i);
+        const r = new $t(Hi, Gi, e, t);
         r.layers = this.layers, this.add(r);
-        const s = new Ht(Ti, wi, e, t);
-        s.layers = this.layers, this.add(s);
-        const a = new Ht(Ti, wi, e, t);
-        a.layers = this.layers, this.add(a);
-        const o = new Ht(Ti, wi, e, t);
+        const o = new $t(Hi, Gi, e, t);
         o.layers = this.layers, this.add(o);
-        const l = new Ht(Ti, wi, e, t);
+        const a = new $t(Hi, Gi, e, t);
+        a.layers = this.layers, this.add(a);
+        const l = new $t(Hi, Gi, e, t);
         l.layers = this.layers, this.add(l);
-        const c = new Ht(Ti, wi, e, t);
+        const c = new $t(Hi, Gi, e, t);
         c.layers = this.layers, this.add(c);
     }
     updateCoordinateSystem() {
         const e = this.coordinateSystem,
             t = this.children.concat(),
-            [n, r, s, a, o, l] = t;
+            [n, i, r, o, a, l] = t;
         for (const c of t)
             this.remove(c);
-        if (e === Mn)
-            n.up.set(0, 1, 0), n.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
-        else if (e === Qr)
-            n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
+        if (e === Dn)
+            n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
+        else if (e === Er)
+            n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
         else
             throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
         for (const c of t)
             this.add(c), c.updateMatrixWorld();
     }
     update(e, t) {
         this.parent === null && this.updateMatrixWorld();
         const {
             renderTarget: n,
-            activeMipmapLevel: r
+            activeMipmapLevel: i
         } = this;
         this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
-        const [s, a, o, l, c, u] = this.children, f = e.getRenderTarget(), h = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), g = e.xr.enabled;
+        const [r, o, a, l, c, u] = this.children, d = e.getRenderTarget(), f = e.getActiveCubeFace(), h = e.getActiveMipmapLevel(), g = e.xr.enabled;
         e.xr.enabled = !1;
-        const v = n.texture.generateMipmaps;
-        n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, r), e.render(t, s), e.setRenderTarget(n, 1, r), e.render(t, a), e.setRenderTarget(n, 2, r), e.render(t, o), e.setRenderTarget(n, 3, r), e.render(t, l), e.setRenderTarget(n, 4, r), e.render(t, c), n.texture.generateMipmaps = v, e.setRenderTarget(n, 5, r), e.render(t, u), e.setRenderTarget(f, h, p), e.xr.enabled = g, n.texture.needsPMREMUpdate = !0;
+        const _ = n.texture.generateMipmaps;
+        n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, r), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = _, e.setRenderTarget(n, 5, i), e.render(t, u), e.setRenderTarget(d, f, h), e.xr.enabled = g, n.texture.needsPMREMUpdate = !0;
     }
 }
-class ic extends Tt {
-    constructor(e, t, n, r, s, a, o, l, c, u) {
-        e = e !== void 0 ? e : [], t = t !== void 0 ? t : zi, super(e, t, n, r, s, a, o, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
+class Qc extends Ot {
+    constructor(e, t, n, i, r, o, a, l, c, u) {
+        e = e !== void 0 ? e : [], t = t !== void 0 ? t : os, super(e, t, n, i, r, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1;
     }
     get images() {
         return this.image;
     }
     set images(e) {
         this.image = e;
     }
 }
-class ph extends Vn {
+class uh extends ti {
     constructor(e = 1, t = {}) {
         super(e, e, t), this.isWebGLCubeRenderTarget = !0;
         const n = {
                 width: e,
                 height: e,
                 depth: 1
             },
-            r = [n, n, n, n, n, n];
-        this.texture = new ic(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ct;
+            i = [n, n, n, n, n, n];
+        this.texture = new Qc(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Nt;
     }
     fromEquirectangularTexture(e, t) {
         this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
         const n = {
                 uniforms: {
                     tEquirect: {
                         value: null
@@ -6181,54 +6209,54 @@
 
 					gl_FragColor = texture2D( tEquirect, sampleUV );
 
 				}
 			`
                 )
             },
-            r = new Qi(5, 5, 5),
-            s = new Xt({
+            i = new gs(5, 5, 5),
+            r = new tn({
                 name: "CubemapFromEquirect",
-                uniforms: Vi(n.uniforms),
+                uniforms: us(n.uniforms),
                 vertexShader: n.vertexShader,
                 fragmentShader: n.fragmentShader,
-                side: Pt,
-                blending: zn
+                side: zt,
+                blending: Jn
             });
-        s.uniforms.tEquirect.value = t;
-        const a = new at(r, s),
-            o = t.minFilter;
-        return t.minFilter === ni && (t.minFilter = Ct), new dh(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
-    }
-    clear(e, t, n, r) {
-        const s = e.getRenderTarget();
-        for (let a = 0; a < 6; a++)
-            e.setRenderTarget(this, a), e.clear(t, n, r);
-        e.setRenderTarget(s);
-    }
-}
-const Gs = /* @__PURE__ */ new P(),
-    mh = /* @__PURE__ */ new P(),
-    gh = /* @__PURE__ */ new be();
-class Fn {
-    constructor(e = new P(1, 0, 0), t = 0) {
+        r.uniforms.tEquirect.value = t;
+        const o = new pt(i, r),
+            a = t.minFilter;
+        return t.minFilter === mi && (t.minFilter = Nt), new ch(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
+    }
+    clear(e, t, n, i) {
+        const r = e.getRenderTarget();
+        for (let o = 0; o < 6; o++)
+            e.setRenderTarget(this, o), e.clear(t, n, i);
+        e.setRenderTarget(r);
+    }
+}
+const _a = /* @__PURE__ */ new D(),
+    dh = /* @__PURE__ */ new D(),
+    fh = /* @__PURE__ */ new Ue();
+class jn {
+    constructor(e = new D(1, 0, 0), t = 0) {
         this.isPlane = !0, this.normal = e, this.constant = t;
     }
     set(e, t) {
         return this.normal.copy(e), this.constant = t, this;
     }
-    setComponents(e, t, n, r) {
-        return this.normal.set(e, t, n), this.constant = r, this;
+    setComponents(e, t, n, i) {
+        return this.normal.set(e, t, n), this.constant = i, this;
     }
     setFromNormalAndCoplanarPoint(e, t) {
         return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
     }
     setFromCoplanarPoints(e, t, n) {
-        const r = Gs.subVectors(n, t).cross(mh.subVectors(e, t)).normalize();
-        return this.setFromNormalAndCoplanarPoint(r, e), this;
+        const i = _a.subVectors(n, t).cross(dh.subVectors(e, t)).normalize();
+        return this.setFromNormalAndCoplanarPoint(i, e), this;
     }
     copy(e) {
         return this.normal.copy(e.normal), this.constant = e.constant, this;
     }
     normalize() {
         const e = 1 / this.normal.length();
         return this.normal.multiplyScalar(e), this.constant *= e, this;
@@ -6242,20 +6270,20 @@
     distanceToSphere(e) {
         return this.distanceToPoint(e.center) - e.radius;
     }
     projectPoint(e, t) {
         return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
     }
     intersectLine(e, t) {
-        const n = e.delta(Gs),
-            r = this.normal.dot(n);
-        if (r === 0)
+        const n = e.delta(_a),
+            i = this.normal.dot(n);
+        if (i === 0)
             return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
-        const s = -(e.start.dot(this.normal) + this.constant) / r;
-        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
+        const r = -(e.start.dot(this.normal) + this.constant) / i;
+        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
     }
     intersectsLine(e) {
         const t = this.distanceToPoint(e.start),
             n = this.distanceToPoint(e.end);
         return t < 0 && n > 0 || n < 0 && t > 0;
     }
     intersectsBox(e) {
@@ -6264,98 +6292,98 @@
     intersectsSphere(e) {
         return e.intersectsPlane(this);
     }
     coplanarPoint(e) {
         return e.copy(this.normal).multiplyScalar(-this.constant);
     }
     applyMatrix4(e, t) {
-        const n = t || gh.getNormalMatrix(e),
-            r = this.coplanarPoint(Gs).applyMatrix4(e),
-            s = this.normal.applyMatrix3(n).normalize();
-        return this.constant = -r.dot(s), this;
+        const n = t || fh.getNormalMatrix(e),
+            i = this.coplanarPoint(_a).applyMatrix4(e),
+            r = this.normal.applyMatrix3(n).normalize();
+        return this.constant = -i.dot(r), this;
     }
     translate(e) {
         return this.constant -= e.dot(this.normal), this;
     }
     equals(e) {
         return e.normal.equals(this.normal) && e.constant === this.constant;
     }
     clone() {
         return new this.constructor().copy(this);
     }
 }
-const Qn = /* @__PURE__ */ new _o(),
-    Ur = /* @__PURE__ */ new P();
-class rc {
-    constructor(e = new Fn(), t = new Fn(), n = new Fn(), r = new Fn(), s = new Fn(), a = new Fn()) {
-        this.planes = [e, t, n, r, s, a];
-    }
-    set(e, t, n, r, s, a) {
-        const o = this.planes;
-        return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
+const li = /* @__PURE__ */ new $a(),
+    ir = /* @__PURE__ */ new D();
+class Jc {
+    constructor(e = new jn(), t = new jn(), n = new jn(), i = new jn(), r = new jn(), o = new jn()) {
+        this.planes = [e, t, n, i, r, o];
+    }
+    set(e, t, n, i, r, o) {
+        const a = this.planes;
+        return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(r), a[5].copy(o), this;
     }
     copy(e) {
         const t = this.planes;
         for (let n = 0; n < 6; n++)
             t[n].copy(e.planes[n]);
         return this;
     }
-    setFromProjectionMatrix(e, t = Mn) {
+    setFromProjectionMatrix(e, t = Dn) {
         const n = this.planes,
-            r = e.elements,
-            s = r[0],
-            a = r[1],
-            o = r[2],
-            l = r[3],
-            c = r[4],
-            u = r[5],
-            f = r[6],
-            h = r[7],
-            p = r[8],
-            g = r[9],
-            v = r[10],
-            m = r[11],
-            d = r[12],
-            M = r[13],
-            _ = r[14],
-            A = r[15];
-        if (n[0].setComponents(l - s, h - c, m - p, A - d).normalize(), n[1].setComponents(l + s, h + c, m + p, A + d).normalize(), n[2].setComponents(l + a, h + u, m + g, A + M).normalize(), n[3].setComponents(l - a, h - u, m - g, A - M).normalize(), n[4].setComponents(l - o, h - f, m - v, A - _).normalize(), t === Mn)
-            n[5].setComponents(l + o, h + f, m + v, A + _).normalize();
-        else if (t === Qr)
-            n[5].setComponents(o, f, v, _).normalize();
+            i = e.elements,
+            r = i[0],
+            o = i[1],
+            a = i[2],
+            l = i[3],
+            c = i[4],
+            u = i[5],
+            d = i[6],
+            f = i[7],
+            h = i[8],
+            g = i[9],
+            _ = i[10],
+            m = i[11],
+            p = i[12],
+            v = i[13],
+            S = i[14],
+            y = i[15];
+        if (n[0].setComponents(l - r, f - c, m - h, y - p).normalize(), n[1].setComponents(l + r, f + c, m + h, y + p).normalize(), n[2].setComponents(l + o, f + u, m + g, y + v).normalize(), n[3].setComponents(l - o, f - u, m - g, y - v).normalize(), n[4].setComponents(l - a, f - d, m - _, y - S).normalize(), t === Dn)
+            n[5].setComponents(l + a, f + d, m + _, y + S).normalize();
+        else if (t === Er)
+            n[5].setComponents(a, d, _, S).normalize();
         else
             throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
         return this;
     }
     intersectsObject(e) {
         if (e.boundingSphere !== void 0)
-            e.boundingSphere === null && e.computeBoundingSphere(), Qn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
+            e.boundingSphere === null && e.computeBoundingSphere(), li.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
         else {
             const t = e.geometry;
-            t.boundingSphere === null && t.computeBoundingSphere(), Qn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
+            t.boundingSphere === null && t.computeBoundingSphere(), li.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
         }
-        return this.intersectsSphere(Qn);
+        return this.intersectsSphere(li);
     }
     intersectsSprite(e) {
-        return Qn.center.set(0, 0, 0), Qn.radius = 0.7071067811865476, Qn.applyMatrix4(e.matrixWorld), this.intersectsSphere(Qn);
+        return li.center.set(0, 0, 0), li.radius = 0.7071067811865476, li.applyMatrix4(e.matrixWorld), this.intersectsSphere(li);
     }
     intersectsSphere(e) {
         const t = this.planes,
             n = e.center,
-            r = -e.radius;
-        for (let s = 0; s < 6; s++)
-            if (t[s].distanceToPoint(n) < r)
+            i = -e.radius;
+        for (let r = 0; r < 6; r++)
+            if (t[r].distanceToPoint(n) < i)
                 return !1;
         return !0;
     }
     intersectsBox(e) {
         const t = this.planes;
         for (let n = 0; n < 6; n++) {
-            const r = t[n];
-            if (Ur.x = r.normal.x > 0 ? e.max.x : e.min.x, Ur.y = r.normal.y > 0 ? e.max.y : e.min.y, Ur.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Ur) < 0)
+            const i = t[n];
+            if (ir.x = i.normal.x > 0 ? e.max.x : e.min.x, ir.y = i.normal.y > 0 ? e.max.y : e.min.y, ir.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(ir) < 0)
                 return !1;
         }
         return !0;
     }
     containsPoint(e) {
         const t = this.planes;
         for (let n = 0; n < 6; n++)
@@ -6364,202 +6392,202 @@
         return !0;
     }
     clone() {
         return new this.constructor().copy(this);
     }
 }
 
-function sc() {
-    let i = null,
+function $c() {
+    let s = null,
         e = !1,
         t = null,
         n = null;
 
-    function r(s, a) {
-        t(s, a), n = i.requestAnimationFrame(r);
+    function i(r, o) {
+        t(r, o), n = s.requestAnimationFrame(i);
     }
     return {
         start: function() {
-            e !== !0 && t !== null && (n = i.requestAnimationFrame(r), e = !0);
+            e !== !0 && t !== null && (n = s.requestAnimationFrame(i), e = !0);
         },
         stop: function() {
-            i.cancelAnimationFrame(n), e = !1;
+            s.cancelAnimationFrame(n), e = !1;
         },
-        setAnimationLoop: function(s) {
-            t = s;
+        setAnimationLoop: function(r) {
+            t = r;
         },
-        setContext: function(s) {
-            i = s;
+        setContext: function(r) {
+            s = r;
         }
     };
 }
 
-function _h(i, e) {
+function hh(s, e) {
     const t = e.isWebGL2,
         n = /* @__PURE__ */ new WeakMap();
 
-    function r(c, u) {
-        const f = c.array,
-            h = c.usage,
-            p = f.byteLength,
-            g = i.createBuffer();
-        i.bindBuffer(u, g), i.bufferData(u, f, h), c.onUploadCallback();
-        let v;
-        if (f instanceof Float32Array)
-            v = i.FLOAT;
-        else if (f instanceof Uint16Array)
+    function i(c, u) {
+        const d = c.array,
+            f = c.usage,
+            h = d.byteLength,
+            g = s.createBuffer();
+        s.bindBuffer(u, g), s.bufferData(u, d, f), c.onUploadCallback();
+        let _;
+        if (d instanceof Float32Array)
+            _ = s.FLOAT;
+        else if (d instanceof Uint16Array)
             if (c.isFloat16BufferAttribute)
                 if (t)
-                    v = i.HALF_FLOAT;
+                    _ = s.HALF_FLOAT;
                 else
                     throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
         else
-            v = i.UNSIGNED_SHORT;
-        else if (f instanceof Int16Array)
-            v = i.SHORT;
-        else if (f instanceof Uint32Array)
-            v = i.UNSIGNED_INT;
-        else if (f instanceof Int32Array)
-            v = i.INT;
-        else if (f instanceof Int8Array)
-            v = i.BYTE;
-        else if (f instanceof Uint8Array)
-            v = i.UNSIGNED_BYTE;
-        else if (f instanceof Uint8ClampedArray)
-            v = i.UNSIGNED_BYTE;
+            _ = s.UNSIGNED_SHORT;
+        else if (d instanceof Int16Array)
+            _ = s.SHORT;
+        else if (d instanceof Uint32Array)
+            _ = s.UNSIGNED_INT;
+        else if (d instanceof Int32Array)
+            _ = s.INT;
+        else if (d instanceof Int8Array)
+            _ = s.BYTE;
+        else if (d instanceof Uint8Array)
+            _ = s.UNSIGNED_BYTE;
+        else if (d instanceof Uint8ClampedArray)
+            _ = s.UNSIGNED_BYTE;
         else
-            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + f);
+            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
         return {
             buffer: g,
-            type: v,
-            bytesPerElement: f.BYTES_PER_ELEMENT,
+            type: _,
+            bytesPerElement: d.BYTES_PER_ELEMENT,
             version: c.version,
-            size: p
+            size: h
         };
     }
 
-    function s(c, u, f) {
-        const h = u.array,
-            p = u._updateRange,
+    function r(c, u, d) {
+        const f = u.array,
+            h = u._updateRange,
             g = u.updateRanges;
-        if (i.bindBuffer(f, c), p.count === -1 && g.length === 0 && i.bufferSubData(f, 0, h), g.length !== 0) {
-            for (let v = 0, m = g.length; v < m; v++) {
-                const d = g[v];
-                t ? i.bufferSubData(
-                    f,
-                    d.start * h.BYTES_PER_ELEMENT,
-                    h,
-                    d.start,
-                    d.count
-                ) : i.bufferSubData(
+        if (s.bindBuffer(d, c), h.count === -1 && g.length === 0 && s.bufferSubData(d, 0, f), g.length !== 0) {
+            for (let _ = 0, m = g.length; _ < m; _++) {
+                const p = g[_];
+                t ? s.bufferSubData(
+                    d,
+                    p.start * f.BYTES_PER_ELEMENT,
                     f,
-                    d.start * h.BYTES_PER_ELEMENT,
-                    h.subarray(d.start, d.start + d.count)
+                    p.start,
+                    p.count
+                ) : s.bufferSubData(
+                    d,
+                    p.start * f.BYTES_PER_ELEMENT,
+                    f.subarray(p.start, p.start + p.count)
                 );
             }
             u.clearUpdateRanges();
         }
-        p.count !== -1 && (t ? i.bufferSubData(
+        h.count !== -1 && (t ? s.bufferSubData(
+            d,
+            h.offset * f.BYTES_PER_ELEMENT,
             f,
-            p.offset * h.BYTES_PER_ELEMENT,
-            h,
-            p.offset,
-            p.count
-        ) : i.bufferSubData(
-            f,
-            p.offset * h.BYTES_PER_ELEMENT,
-            h.subarray(p.offset, p.offset + p.count)
-        ), p.count = -1), u.onUploadCallback();
+            h.offset,
+            h.count
+        ) : s.bufferSubData(
+            d,
+            h.offset * f.BYTES_PER_ELEMENT,
+            f.subarray(h.offset, h.offset + h.count)
+        ), h.count = -1), u.onUploadCallback();
     }
 
-    function a(c) {
+    function o(c) {
         return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
     }
 
-    function o(c) {
+    function a(c) {
         c.isInterleavedBufferAttribute && (c = c.data);
         const u = n.get(c);
-        u && (i.deleteBuffer(u.buffer), n.delete(c));
+        u && (s.deleteBuffer(u.buffer), n.delete(c));
     }
 
     function l(c, u) {
         if (c.isGLBufferAttribute) {
-            const h = n.get(c);
-            (!h || h.version < c.version) && n.set(c, {
+            const f = n.get(c);
+            (!f || f.version < c.version) && n.set(c, {
                 buffer: c.buffer,
                 type: c.type,
                 bytesPerElement: c.elementSize,
                 version: c.version
             });
             return;
         }
         c.isInterleavedBufferAttribute && (c = c.data);
-        const f = n.get(c);
-        if (f === void 0)
-            n.set(c, r(c, u));
-        else if (f.version < c.version) {
-            if (f.size !== c.array.byteLength)
+        const d = n.get(c);
+        if (d === void 0)
+            n.set(c, i(c, u));
+        else if (d.version < c.version) {
+            if (d.size !== c.array.byteLength)
                 throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
-            s(f.buffer, c, u), f.version = c.version;
+            r(d.buffer, c, u), d.version = c.version;
         }
     }
     return {
-        get: a,
-        remove: o,
+        get: o,
+        remove: a,
         update: l
     };
 }
-class Wi extends Yt {
-    constructor(e = 1, t = 1, n = 1, r = 1) {
+class ds extends sn {
+    constructor(e = 1, t = 1, n = 1, i = 1) {
         super(), this.type = "PlaneGeometry", this.parameters = {
             width: e,
             height: t,
             widthSegments: n,
-            heightSegments: r
+            heightSegments: i
         };
-        const s = e / 2,
-            a = t / 2,
-            o = Math.floor(n),
-            l = Math.floor(r),
-            c = o + 1,
+        const r = e / 2,
+            o = t / 2,
+            a = Math.floor(n),
+            l = Math.floor(i),
+            c = a + 1,
             u = l + 1,
-            f = e / o,
-            h = t / l,
-            p = [],
+            d = e / a,
+            f = t / l,
+            h = [],
             g = [],
-            v = [],
+            _ = [],
             m = [];
-        for (let d = 0; d < u; d++) {
-            const M = d * h - a;
-            for (let _ = 0; _ < c; _++) {
-                const A = _ * f - s;
-                g.push(A, -M, 0), v.push(0, 0, 1), m.push(_ / o), m.push(1 - d / l);
-            }
-        }
-        for (let d = 0; d < l; d++)
-            for (let M = 0; M < o; M++) {
-                const _ = M + c * d,
-                    A = M + c * (d + 1),
-                    R = M + 1 + c * (d + 1),
-                    E = M + 1 + c * d;
-                p.push(_, A, E), p.push(A, R, E);
+        for (let p = 0; p < u; p++) {
+            const v = p * f - o;
+            for (let S = 0; S < c; S++) {
+                const y = S * d - r;
+                g.push(y, -v, 0), _.push(0, 0, 1), m.push(S / a), m.push(1 - p / l);
+            }
+        }
+        for (let p = 0; p < l; p++)
+            for (let v = 0; v < a; v++) {
+                const S = v + c * p,
+                    y = v + c * (p + 1),
+                    b = v + 1 + c * (p + 1),
+                    E = v + 1 + c * p;
+                h.push(S, y, E), h.push(y, b, E);
             }
-        this.setIndex(p), this.setAttribute("position", new Ft(g, 3)), this.setAttribute("normal", new Ft(v, 3)), this.setAttribute("uv", new Ft(m, 2));
+        this.setIndex(h), this.setAttribute("position", new Yt(g, 3)), this.setAttribute("normal", new Yt(_, 3)), this.setAttribute("uv", new Yt(m, 2));
     }
     copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
     }
     static fromJSON(e) {
-        return new Wi(e.width, e.height, e.widthSegments, e.heightSegments);
+        return new ds(e.width, e.height, e.widthSegments, e.heightSegments);
     }
 }
-var vh = `#ifdef USE_ALPHAHASH
+var ph = `#ifdef USE_ALPHAHASH
 	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
 #endif`,
-    xh = `#ifdef USE_ALPHAHASH
+    mh = `#ifdef USE_ALPHAHASH
 	const float ALPHA_HASH_SCALE = 0.05;
 	float hash2D( vec2 value ) {
 		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
 	}
 	float hash3D( vec3 value ) {
 		return hash2D( vec2( hash2D( value.xy ), value.z ) );
 	}
@@ -6587,91 +6615,91 @@
 		);
 		float threshold = ( x < ( 1.0 - a ) )
 			? ( ( x < a ) ? cases.x : cases.y )
 			: cases.z;
 		return clamp( threshold , 1.0e-6, 1.0 );
 	}
 #endif`,
-    Sh = `#ifdef USE_ALPHAMAP
+    gh = `#ifdef USE_ALPHAMAP
 	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
 #endif`,
-    Mh = `#ifdef USE_ALPHAMAP
+    _h = `#ifdef USE_ALPHAMAP
 	uniform sampler2D alphaMap;
 #endif`,
-    yh = `#ifdef USE_ALPHATEST
+    Sh = `#ifdef USE_ALPHATEST
 	#ifdef ALPHA_TO_COVERAGE
 	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
 	if ( diffuseColor.a == 0.0 ) discard;
 	#else
 	if ( diffuseColor.a < alphaTest ) discard;
 	#endif
 #endif`,
-    Ah = `#ifdef USE_ALPHATEST
+    vh = `#ifdef USE_ALPHATEST
 	uniform float alphaTest;
 #endif`,
-    Eh = `#ifdef USE_AOMAP
+    xh = `#ifdef USE_AOMAP
 	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
 	reflectedLight.indirectDiffuse *= ambientOcclusion;
 	#if defined( USE_CLEARCOAT ) 
 		clearcoatSpecularIndirect *= ambientOcclusion;
 	#endif
 	#if defined( USE_SHEEN ) 
 		sheenSpecularIndirect *= ambientOcclusion;
 	#endif
 	#if defined( USE_ENVMAP ) && defined( STANDARD )
 		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
 		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
 	#endif
 #endif`,
-    bh = `#ifdef USE_AOMAP
+    yh = `#ifdef USE_AOMAP
 	uniform sampler2D aoMap;
 	uniform float aoMapIntensity;
 #endif`,
-    Th = `#ifdef USE_BATCHING
+    Mh = `#ifdef USE_BATCHING
 	attribute float batchId;
 	uniform highp sampler2D batchingTexture;
 	mat4 getBatchingMatrix( const in float i ) {
 		int size = textureSize( batchingTexture, 0 ).x;
 		int j = int( i ) * 4;
 		int x = j % size;
 		int y = j / size;
 		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
 		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
 		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
 		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
 		return mat4( v1, v2, v3, v4 );
 	}
 #endif`,
-    wh = `#ifdef USE_BATCHING
+    Eh = `#ifdef USE_BATCHING
 	mat4 batchingMatrix = getBatchingMatrix( batchId );
 #endif`,
-    Ch = `vec3 transformed = vec3( position );
+    Ah = `vec3 transformed = vec3( position );
 #ifdef USE_ALPHAHASH
 	vPosition = vec3( position );
 #endif`,
-    Rh = `vec3 objectNormal = vec3( normal );
+    Th = `vec3 objectNormal = vec3( normal );
 #ifdef USE_TANGENT
 	vec3 objectTangent = vec3( tangent.xyz );
 #endif`,
-    Ph = `float G_BlinnPhong_Implicit( ) {
+    bh = `float G_BlinnPhong_Implicit( ) {
 	return 0.25;
 }
 float D_BlinnPhong( const in float shininess, const in float dotNH ) {
 	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
 }
 vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
 	vec3 halfDir = normalize( lightDir + viewDir );
 	float dotNH = saturate( dot( normal, halfDir ) );
 	float dotVH = saturate( dot( viewDir, halfDir ) );
 	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
 	float G = G_BlinnPhong_Implicit( );
 	float D = D_BlinnPhong( shininess, dotNH );
 	return F * ( G * D );
 } // validated`,
-    Lh = `#ifdef USE_IRIDESCENCE
+    Ch = `#ifdef USE_IRIDESCENCE
 	const mat3 XYZ_TO_REC709 = mat3(
 		 3.2404542, -0.9692660,  0.0556434,
 		-1.5371385,  1.8760108, -0.2040259,
 		-0.4985314,  0.0415560,  1.0572252
 	);
 	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
 		vec3 sqrtF0 = sqrt( fresnel0 );
@@ -6727,15 +6755,15 @@
 			Cm *= r123;
 			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
 			I += Cm * Sm;
 		}
 		return max( I, vec3( 0.0 ) );
 	}
 #endif`,
-    Dh = `#ifdef USE_BUMPMAP
+    wh = `#ifdef USE_BUMPMAP
 	uniform sampler2D bumpMap;
 	uniform float bumpScale;
 	vec2 dHdxy_fwd() {
 		vec2 dSTdx = dFdx( vBumpMapUv );
 		vec2 dSTdy = dFdy( vBumpMapUv );
 		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
 		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
@@ -6749,15 +6777,15 @@
 		vec3 R1 = cross( vSigmaY, vN );
 		vec3 R2 = cross( vN, vSigmaX );
 		float fDet = dot( vSigmaX, R1 ) * faceDirection;
 		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
 		return normalize( abs( fDet ) * surf_norm - vGrad );
 	}
 #endif`,
-    Ih = `#if NUM_CLIPPING_PLANES > 0
+    Rh = `#if NUM_CLIPPING_PLANES > 0
 	vec4 plane;
 	#ifdef ALPHA_TO_COVERAGE
 		float distanceToPlane, distanceGradient;
 		float clipOpacity = 1.0;
 		#pragma unroll_loop_start
 		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
 			plane = clippingPlanes[ i ];
@@ -6796,51 +6824,51 @@
 				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
 			}
 			#pragma unroll_loop_end
 			if ( clipped ) discard;
 		#endif
 	#endif
 #endif`,
-    Uh = `#if NUM_CLIPPING_PLANES > 0
+    Ph = `#if NUM_CLIPPING_PLANES > 0
 	varying vec3 vClipPosition;
 	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
 #endif`,
-    Fh = `#if NUM_CLIPPING_PLANES > 0
+    Dh = `#if NUM_CLIPPING_PLANES > 0
 	varying vec3 vClipPosition;
 #endif`,
-    Nh = `#if NUM_CLIPPING_PLANES > 0
+    Lh = `#if NUM_CLIPPING_PLANES > 0
 	vClipPosition = - mvPosition.xyz;
 #endif`,
-    Bh = `#if defined( USE_COLOR_ALPHA )
+    Fh = `#if defined( USE_COLOR_ALPHA )
 	diffuseColor *= vColor;
 #elif defined( USE_COLOR )
 	diffuseColor.rgb *= vColor;
 #endif`,
-    Oh = `#if defined( USE_COLOR_ALPHA )
+    Ih = `#if defined( USE_COLOR_ALPHA )
 	varying vec4 vColor;
 #elif defined( USE_COLOR )
 	varying vec3 vColor;
 #endif`,
-    zh = `#if defined( USE_COLOR_ALPHA )
+    Uh = `#if defined( USE_COLOR_ALPHA )
 	varying vec4 vColor;
 #elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
 	varying vec3 vColor;
 #endif`,
-    kh = `#if defined( USE_COLOR_ALPHA )
+    Bh = `#if defined( USE_COLOR_ALPHA )
 	vColor = vec4( 1.0 );
 #elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
 	vColor = vec3( 1.0 );
 #endif
 #ifdef USE_COLOR
 	vColor *= color;
 #endif
 #ifdef USE_INSTANCING_COLOR
 	vColor.xyz *= instanceColor.xyz;
 #endif`,
-    Gh = `#define PI 3.141592653589793
+    Oh = `#define PI 3.141592653589793
 #define PI2 6.283185307179586
 #define PI_HALF 1.5707963267948966
 #define RECIPROCAL_PI 0.3183098861837907
 #define RECIPROCAL_PI2 0.15915494309189535
 #define EPSILON 1e-6
 #ifndef saturate
 #define saturate( a ) clamp( a, 0.0, 1.0 )
@@ -6911,15 +6939,15 @@
 	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
 	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
 }
 float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
 	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
 	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
 } // validated`,
-    Hh = `#ifdef ENVMAP_TYPE_CUBE_UV
+    Nh = `#ifdef ENVMAP_TYPE_CUBE_UV
 	#define cubeUV_minMipLevel 4.0
 	#define cubeUV_minTileSize 16.0
 	float getFace( vec3 direction ) {
 		vec3 absDirection = abs( direction );
 		float face = - 1.0;
 		if ( absDirection.x > absDirection.z ) {
 			if ( absDirection.x > absDirection.y )
@@ -7005,15 +7033,15 @@
 			return vec4( color0, 1.0 );
 		} else {
 			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
 			return vec4( mix( color0, color1, mipF ), 1.0 );
 		}
 	}
 #endif`,
-    Vh = `vec3 transformedNormal = objectNormal;
+    kh = `vec3 transformedNormal = objectNormal;
 #ifdef USE_TANGENT
 	vec3 transformedTangent = objectTangent;
 #endif
 #ifdef USE_BATCHING
 	mat3 bm = mat3( batchingMatrix );
 	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
 	transformedNormal = bm * transformedNormal;
@@ -7035,31 +7063,31 @@
 #endif
 #ifdef USE_TANGENT
 	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
 	#ifdef FLIP_SIDED
 		transformedTangent = - transformedTangent;
 	#endif
 #endif`,
-    Wh = `#ifdef USE_DISPLACEMENTMAP
+    zh = `#ifdef USE_DISPLACEMENTMAP
 	uniform sampler2D displacementMap;
 	uniform float displacementScale;
 	uniform float displacementBias;
 #endif`,
-    Xh = `#ifdef USE_DISPLACEMENTMAP
+    Hh = `#ifdef USE_DISPLACEMENTMAP
 	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
 #endif`,
-    qh = `#ifdef USE_EMISSIVEMAP
+    Gh = `#ifdef USE_EMISSIVEMAP
 	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
 	totalEmissiveRadiance *= emissiveColor.rgb;
 #endif`,
-    Yh = `#ifdef USE_EMISSIVEMAP
+    Vh = `#ifdef USE_EMISSIVEMAP
 	uniform sampler2D emissiveMap;
 #endif`,
-    jh = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
-    Kh = `
+    Wh = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
+    Xh = `
 const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
 	vec3( 0.8224621, 0.177538, 0.0 ),
 	vec3( 0.0331941, 0.9668058, 0.0 ),
 	vec3( 0.0170827, 0.0723974, 0.9105199 )
 );
 const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
 	vec3( 1.2249401, - 0.2249404, 0.0 ),
@@ -7080,15 +7108,15 @@
 }
 vec4 LinearToLinear( in vec4 value ) {
 	return value;
 }
 vec4 LinearTosRGB( in vec4 value ) {
 	return sRGBTransferOETF( value );
 }`,
-    Qh = `#ifdef USE_ENVMAP
+    qh = `#ifdef USE_ENVMAP
 	#ifdef ENV_WORLDPOS
 		vec3 cameraToFrag;
 		if ( isOrthographic ) {
 			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
 		} else {
 			cameraToFrag = normalize( vWorldPosition - cameraPosition );
 		}
@@ -7110,50 +7138,50 @@
 		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
 	#elif defined( ENVMAP_BLENDING_MIX )
 		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
 	#elif defined( ENVMAP_BLENDING_ADD )
 		outgoingLight += envColor.xyz * specularStrength * reflectivity;
 	#endif
 #endif`,
-    Zh = `#ifdef USE_ENVMAP
+    Yh = `#ifdef USE_ENVMAP
 	uniform float envMapIntensity;
 	uniform float flipEnvMap;
 	uniform mat3 envMapRotation;
 	#ifdef ENVMAP_TYPE_CUBE
 		uniform samplerCube envMap;
 	#else
 		uniform sampler2D envMap;
 	#endif
 	
 #endif`,
-    Jh = `#ifdef USE_ENVMAP
+    jh = `#ifdef USE_ENVMAP
 	uniform float reflectivity;
 	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
 		#define ENV_WORLDPOS
 	#endif
 	#ifdef ENV_WORLDPOS
 		varying vec3 vWorldPosition;
 		uniform float refractionRatio;
 	#else
 		varying vec3 vReflect;
 	#endif
 #endif`,
-    $h = `#ifdef USE_ENVMAP
+    Kh = `#ifdef USE_ENVMAP
 	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
 		#define ENV_WORLDPOS
 	#endif
 	#ifdef ENV_WORLDPOS
 		
 		varying vec3 vWorldPosition;
 	#else
 		varying vec3 vReflect;
 		uniform float refractionRatio;
 	#endif
 #endif`,
-    ed = `#ifdef USE_ENVMAP
+    Zh = `#ifdef USE_ENVMAP
 	#ifdef ENV_WORLDPOS
 		vWorldPosition = worldPosition.xyz;
 	#else
 		vec3 cameraToVertex;
 		if ( isOrthographic ) {
 			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
 		} else {
@@ -7163,79 +7191,79 @@
 		#ifdef ENVMAP_MODE_REFLECTION
 			vReflect = reflect( cameraToVertex, worldNormal );
 		#else
 			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
 		#endif
 	#endif
 #endif`,
-    td = `#ifdef USE_FOG
+    Qh = `#ifdef USE_FOG
 	vFogDepth = - mvPosition.z;
 #endif`,
-    nd = `#ifdef USE_FOG
+    Jh = `#ifdef USE_FOG
 	varying float vFogDepth;
 #endif`,
-    id = `#ifdef USE_FOG
+    $h = `#ifdef USE_FOG
 	#ifdef FOG_EXP2
 		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
 	#else
 		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
 	#endif
 	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
 #endif`,
-    rd = `#ifdef USE_FOG
+    ep = `#ifdef USE_FOG
 	uniform vec3 fogColor;
 	varying float vFogDepth;
 	#ifdef FOG_EXP2
 		uniform float fogDensity;
 	#else
 		uniform float fogNear;
 		uniform float fogFar;
 	#endif
 #endif`,
-    sd = `#ifdef USE_GRADIENTMAP
+    tp = `#ifdef USE_GRADIENTMAP
 	uniform sampler2D gradientMap;
 #endif
 vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
 	float dotNL = dot( normal, lightDirection );
 	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
 	#ifdef USE_GRADIENTMAP
 		return vec3( texture2D( gradientMap, coord ).r );
 	#else
 		vec2 fw = fwidth( coord ) * 0.5;
 		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
 	#endif
 }`,
-    od = `#ifdef USE_LIGHTMAP
+    np = `#ifdef USE_LIGHTMAP
 	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
 	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
 	reflectedLight.indirectDiffuse += lightMapIrradiance;
 #endif`,
-    ad = `#ifdef USE_LIGHTMAP
+    ip = `#ifdef USE_LIGHTMAP
 	uniform sampler2D lightMap;
 	uniform float lightMapIntensity;
 #endif`,
-    ld = `LambertMaterial material;
+    sp = `LambertMaterial material;
 material.diffuseColor = diffuseColor.rgb;
 material.specularStrength = specularStrength;`,
-    cd = `varying vec3 vViewPosition;
+    rp = `varying vec3 vViewPosition;
 struct LambertMaterial {
 	vec3 diffuseColor;
 	float specularStrength;
 };
 void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
 	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
 	vec3 irradiance = dotNL * directLight.color;
 	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
 }
 void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
 	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
 }
 #define RE_Direct				RE_Direct_Lambert
 #define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
-    ud = `uniform bool receiveShadow;
+    ap = `uniform bool receiveShadow;
 uniform vec3 ambientLightColor;
 #if defined( USE_LIGHT_PROBES )
 	uniform vec3 lightProbe[ 9 ];
 #endif
 vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
 	float x = normal.x, y = normal.y, z = normal.z;
 	vec3 result = shCoefficients[ 0 ] * 0.886227;
@@ -7351,15 +7379,15 @@
 	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
 		float dotNL = dot( normal, hemiLight.direction );
 		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
 		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
 		return irradiance;
 	}
 #endif`,
-    fd = `#ifdef USE_ENVMAP
+    op = `#ifdef USE_ENVMAP
 	vec3 getIBLIrradiance( const in vec3 normal ) {
 		#ifdef ENVMAP_TYPE_CUBE_UV
 			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
 			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
 			return PI * envMapColor.rgb * envMapIntensity;
 		#else
 			return vec3( 0.0 );
@@ -7385,35 +7413,35 @@
 				return getIBLRadiance( viewDir, bentNormal, roughness );
 			#else
 				return vec3( 0.0 );
 			#endif
 		}
 	#endif
 #endif`,
-    hd = `ToonMaterial material;
+    lp = `ToonMaterial material;
 material.diffuseColor = diffuseColor.rgb;`,
-    dd = `varying vec3 vViewPosition;
+    cp = `varying vec3 vViewPosition;
 struct ToonMaterial {
 	vec3 diffuseColor;
 };
 void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
 	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
 	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
 }
 void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
 	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
 }
 #define RE_Direct				RE_Direct_Toon
 #define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
-    pd = `BlinnPhongMaterial material;
+    up = `BlinnPhongMaterial material;
 material.diffuseColor = diffuseColor.rgb;
 material.specularColor = specular;
 material.specularShininess = shininess;
 material.specularStrength = specularStrength;`,
-    md = `varying vec3 vViewPosition;
+    dp = `varying vec3 vViewPosition;
 struct BlinnPhongMaterial {
 	vec3 diffuseColor;
 	vec3 specularColor;
 	float specularShininess;
 	float specularStrength;
 };
 void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
@@ -7423,15 +7451,15 @@
 	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
 }
 void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
 	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
 }
 #define RE_Direct				RE_Direct_BlinnPhong
 #define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
-    gd = `PhysicalMaterial material;
+    fp = `PhysicalMaterial material;
 material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
 vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
 float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
 material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
 material.roughness = min( material.roughness, 1.0 );
 #ifdef IOR
 	material.ior = ior;
@@ -7507,15 +7535,15 @@
 		anisotropyV /= material.anisotropy;
 		material.anisotropy = saturate( material.anisotropy );
 	}
 	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
 	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
 	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
 #endif`,
-    _d = `struct PhysicalMaterial {
+    hp = `struct PhysicalMaterial {
 	vec3 diffuseColor;
 	float roughness;
 	vec3 specularColor;
 	float specularF90;
 	#ifdef USE_CLEARCOAT
 		float clearcoat;
 		float clearcoatRoughness;
@@ -7808,15 +7836,15 @@
 #define RE_Direct				RE_Direct_Physical
 #define RE_Direct_RectArea		RE_Direct_RectArea_Physical
 #define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
 #define RE_IndirectSpecular		RE_IndirectSpecular_Physical
 float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
 	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
 }`,
-    vd = `
+    pp = `
 vec3 geometryPosition = - vViewPosition;
 vec3 geometryNormal = normal;
 vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
 vec3 geometryClearcoatNormal = vec3( 0.0 );
 #ifdef USE_CLEARCOAT
 	geometryClearcoatNormal = clearcoatNormal;
 #endif
@@ -7924,15 +7952,15 @@
 		#pragma unroll_loop_end
 	#endif
 #endif
 #if defined( RE_IndirectSpecular )
 	vec3 radiance = vec3( 0.0 );
 	vec3 clearcoatRadiance = vec3( 0.0 );
 #endif`,
-    xd = `#if defined( RE_IndirectDiffuse )
+    mp = `#if defined( RE_IndirectDiffuse )
 	#ifdef USE_LIGHTMAP
 		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
 		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
 		irradiance += lightMapIrradiance;
 	#endif
 	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
 		iblIrradiance += getIBLIrradiance( geometryNormal );
@@ -7944,123 +7972,123 @@
 	#else
 		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
 	#endif
 	#ifdef USE_CLEARCOAT
 		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
 	#endif
 #endif`,
-    Sd = `#if defined( RE_IndirectDiffuse )
+    gp = `#if defined( RE_IndirectDiffuse )
 	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
 #endif
 #if defined( RE_IndirectSpecular )
 	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
 #endif`,
-    Md = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
+    _p = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
 	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
 #endif`,
-    yd = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
+    Sp = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
 	uniform float logDepthBufFC;
 	varying float vFragDepth;
 	varying float vIsPerspective;
 #endif`,
-    Ad = `#ifdef USE_LOGDEPTHBUF
+    vp = `#ifdef USE_LOGDEPTHBUF
 	#ifdef USE_LOGDEPTHBUF_EXT
 		varying float vFragDepth;
 		varying float vIsPerspective;
 	#else
 		uniform float logDepthBufFC;
 	#endif
 #endif`,
-    Ed = `#ifdef USE_LOGDEPTHBUF
+    xp = `#ifdef USE_LOGDEPTHBUF
 	#ifdef USE_LOGDEPTHBUF_EXT
 		vFragDepth = 1.0 + gl_Position.w;
 		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
 	#else
 		if ( isPerspectiveMatrix( projectionMatrix ) ) {
 			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
 			gl_Position.z *= gl_Position.w;
 		}
 	#endif
 #endif`,
-    bd = `#ifdef USE_MAP
+    yp = `#ifdef USE_MAP
 	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
 	#ifdef DECODE_VIDEO_TEXTURE
 		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
 	
 	#endif
 	diffuseColor *= sampledDiffuseColor;
 #endif`,
-    Td = `#ifdef USE_MAP
+    Mp = `#ifdef USE_MAP
 	uniform sampler2D map;
 #endif`,
-    wd = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
+    Ep = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
 	#if defined( USE_POINTS_UV )
 		vec2 uv = vUv;
 	#else
 		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
 	#endif
 #endif
 #ifdef USE_MAP
 	diffuseColor *= texture2D( map, uv );
 #endif
 #ifdef USE_ALPHAMAP
 	diffuseColor.a *= texture2D( alphaMap, uv ).g;
 #endif`,
-    Cd = `#if defined( USE_POINTS_UV )
+    Ap = `#if defined( USE_POINTS_UV )
 	varying vec2 vUv;
 #else
 	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
 		uniform mat3 uvTransform;
 	#endif
 #endif
 #ifdef USE_MAP
 	uniform sampler2D map;
 #endif
 #ifdef USE_ALPHAMAP
 	uniform sampler2D alphaMap;
 #endif`,
-    Rd = `float metalnessFactor = metalness;
+    Tp = `float metalnessFactor = metalness;
 #ifdef USE_METALNESSMAP
 	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
 	metalnessFactor *= texelMetalness.b;
 #endif`,
-    Pd = `#ifdef USE_METALNESSMAP
+    bp = `#ifdef USE_METALNESSMAP
 	uniform sampler2D metalnessMap;
 #endif`,
-    Ld = `#ifdef USE_INSTANCING_MORPH
+    Cp = `#ifdef USE_INSTANCING_MORPH
 	float morphTargetInfluences[MORPHTARGETS_COUNT];
 	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
 	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
 		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
 	}
 #endif`,
-    Dd = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
+    wp = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
 	vColor *= morphTargetBaseInfluence;
 	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
 		#if defined( USE_COLOR_ALPHA )
 			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
 		#elif defined( USE_COLOR )
 			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
 		#endif
 	}
 #endif`,
-    Id = `#ifdef USE_MORPHNORMALS
+    Rp = `#ifdef USE_MORPHNORMALS
 	objectNormal *= morphTargetBaseInfluence;
 	#ifdef MORPHTARGETS_TEXTURE
 		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
 			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
 		}
 	#else
 		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
 		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
 		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
 		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
 	#endif
 #endif`,
-    Ud = `#ifdef USE_MORPHTARGETS
+    Pp = `#ifdef USE_MORPHTARGETS
 	#ifndef USE_INSTANCING_MORPH
 		uniform float morphTargetBaseInfluence;
 	#endif
 	#ifdef MORPHTARGETS_TEXTURE
 		#ifndef USE_INSTANCING_MORPH
 			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
 		#endif
@@ -8077,15 +8105,15 @@
 		#ifndef USE_MORPHNORMALS
 			uniform float morphTargetInfluences[ 8 ];
 		#else
 			uniform float morphTargetInfluences[ 4 ];
 		#endif
 	#endif
 #endif`,
-    Fd = `#ifdef USE_MORPHTARGETS
+    Dp = `#ifdef USE_MORPHTARGETS
 	transformed *= morphTargetBaseInfluence;
 	#ifdef MORPHTARGETS_TEXTURE
 		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
 			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
 		}
 	#else
 		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
@@ -8096,15 +8124,15 @@
 			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
 			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
 			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
 			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
 		#endif
 	#endif
 #endif`,
-    Nd = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
+    Lp = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
 #ifdef FLAT_SHADED
 	vec3 fdx = dFdx( vViewPosition );
 	vec3 fdy = dFdy( vViewPosition );
 	vec3 normal = normalize( cross( fdx, fdy ) );
 #else
 	vec3 normal = normalize( vNormal );
 	#ifdef DOUBLE_SIDED
@@ -8138,15 +8166,15 @@
 	#endif
 	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
 		tbn2[0] *= faceDirection;
 		tbn2[1] *= faceDirection;
 	#endif
 #endif
 vec3 nonPerturbedNormal = normal;`,
-    Bd = `#ifdef USE_NORMALMAP_OBJECTSPACE
+    Fp = `#ifdef USE_NORMALMAP_OBJECTSPACE
 	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
 	#ifdef FLIP_SIDED
 		normal = - normal;
 	#endif
 	#ifdef DOUBLE_SIDED
 		normal = normal * faceDirection;
 	#endif
@@ -8154,36 +8182,36 @@
 #elif defined( USE_NORMALMAP_TANGENTSPACE )
 	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
 	mapN.xy *= normalScale;
 	normal = normalize( tbn * mapN );
 #elif defined( USE_BUMPMAP )
 	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
 #endif`,
-    Od = `#ifndef FLAT_SHADED
+    Ip = `#ifndef FLAT_SHADED
 	varying vec3 vNormal;
 	#ifdef USE_TANGENT
 		varying vec3 vTangent;
 		varying vec3 vBitangent;
 	#endif
 #endif`,
-    zd = `#ifndef FLAT_SHADED
+    Up = `#ifndef FLAT_SHADED
 	varying vec3 vNormal;
 	#ifdef USE_TANGENT
 		varying vec3 vTangent;
 		varying vec3 vBitangent;
 	#endif
 #endif`,
-    kd = `#ifndef FLAT_SHADED
+    Bp = `#ifndef FLAT_SHADED
 	vNormal = normalize( transformedNormal );
 	#ifdef USE_TANGENT
 		vTangent = normalize( transformedTangent );
 		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
 	#endif
 #endif`,
-    Gd = `#ifdef USE_NORMALMAP
+    Op = `#ifdef USE_NORMALMAP
 	uniform sampler2D normalMap;
 	uniform vec2 normalScale;
 #endif
 #ifdef USE_NORMALMAP_OBJECTSPACE
 	uniform mat3 normalMatrix;
 #endif
 #if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
@@ -8198,46 +8226,46 @@
 		vec3 T = q1perp * st0.x + q0perp * st1.x;
 		vec3 B = q1perp * st0.y + q0perp * st1.y;
 		float det = max( dot( T, T ), dot( B, B ) );
 		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
 		return mat3( T * scale, B * scale, N );
 	}
 #endif`,
-    Hd = `#ifdef USE_CLEARCOAT
+    Np = `#ifdef USE_CLEARCOAT
 	vec3 clearcoatNormal = nonPerturbedNormal;
 #endif`,
-    Vd = `#ifdef USE_CLEARCOAT_NORMALMAP
+    kp = `#ifdef USE_CLEARCOAT_NORMALMAP
 	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
 	clearcoatMapN.xy *= clearcoatNormalScale;
 	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
 #endif`,
-    Wd = `#ifdef USE_CLEARCOATMAP
+    zp = `#ifdef USE_CLEARCOATMAP
 	uniform sampler2D clearcoatMap;
 #endif
 #ifdef USE_CLEARCOAT_NORMALMAP
 	uniform sampler2D clearcoatNormalMap;
 	uniform vec2 clearcoatNormalScale;
 #endif
 #ifdef USE_CLEARCOAT_ROUGHNESSMAP
 	uniform sampler2D clearcoatRoughnessMap;
 #endif`,
-    Xd = `#ifdef USE_IRIDESCENCEMAP
+    Hp = `#ifdef USE_IRIDESCENCEMAP
 	uniform sampler2D iridescenceMap;
 #endif
 #ifdef USE_IRIDESCENCE_THICKNESSMAP
 	uniform sampler2D iridescenceThicknessMap;
 #endif`,
-    qd = `#ifdef OPAQUE
+    Gp = `#ifdef OPAQUE
 diffuseColor.a = 1.0;
 #endif
 #ifdef USE_TRANSMISSION
 diffuseColor.a *= material.transmissionAlpha;
 #endif
 gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
-    Yd = `vec3 packNormalToRGB( const in vec3 normal ) {
+    Vp = `vec3 packNormalToRGB( const in vec3 normal ) {
 	return normalize( normal ) * 0.5 + 0.5;
 }
 vec3 unpackRGBToNormal( const in vec3 rgb ) {
 	return 2.0 * rgb.xyz - 1.0;
 }
 const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
 const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
@@ -8271,46 +8299,46 @@
 }
 float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
 	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
 }
 float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
 	return ( near * far ) / ( ( far - near ) * depth - far );
 }`,
-    jd = `#ifdef PREMULTIPLIED_ALPHA
+    Wp = `#ifdef PREMULTIPLIED_ALPHA
 	gl_FragColor.rgb *= gl_FragColor.a;
 #endif`,
-    Kd = `vec4 mvPosition = vec4( transformed, 1.0 );
+    Xp = `vec4 mvPosition = vec4( transformed, 1.0 );
 #ifdef USE_BATCHING
 	mvPosition = batchingMatrix * mvPosition;
 #endif
 #ifdef USE_INSTANCING
 	mvPosition = instanceMatrix * mvPosition;
 #endif
 mvPosition = modelViewMatrix * mvPosition;
 gl_Position = projectionMatrix * mvPosition;`,
-    Qd = `#ifdef DITHERING
+    qp = `#ifdef DITHERING
 	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
 #endif`,
-    Zd = `#ifdef DITHERING
+    Yp = `#ifdef DITHERING
 	vec3 dithering( vec3 color ) {
 		float grid_position = rand( gl_FragCoord.xy );
 		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
 		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
 		return color + dither_shift_RGB;
 	}
 #endif`,
-    Jd = `float roughnessFactor = roughness;
+    jp = `float roughnessFactor = roughness;
 #ifdef USE_ROUGHNESSMAP
 	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
 	roughnessFactor *= texelRoughness.g;
 #endif`,
-    $d = `#ifdef USE_ROUGHNESSMAP
+    Kp = `#ifdef USE_ROUGHNESSMAP
 	uniform sampler2D roughnessMap;
 #endif`,
-    ep = `#if NUM_SPOT_LIGHT_COORDS > 0
+    Zp = `#if NUM_SPOT_LIGHT_COORDS > 0
 	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
 #endif
 #if NUM_SPOT_LIGHT_MAPS > 0
 	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
 #endif
 #ifdef USE_SHADOWMAP
 	#if NUM_DIR_LIGHT_SHADOWS > 0
@@ -8480,15 +8508,15 @@
 				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
 			) * ( 1.0 / 9.0 );
 		#else
 			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
 		#endif
 	}
 #endif`,
-    tp = `#if NUM_SPOT_LIGHT_COORDS > 0
+    Qp = `#if NUM_SPOT_LIGHT_COORDS > 0
 	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
 	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
 #endif
 #ifdef USE_SHADOWMAP
 	#if NUM_DIR_LIGHT_SHADOWS > 0
 		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
 		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
@@ -8519,15 +8547,15 @@
 			vec2 shadowMapSize;
 			float shadowCameraNear;
 			float shadowCameraFar;
 		};
 		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
 	#endif
 #endif`,
-    np = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
+    Jp = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
 	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
 	vec4 shadowWorldPosition;
 #endif
 #if defined( USE_SHADOWMAP )
 	#if NUM_DIR_LIGHT_SHADOWS > 0
 		#pragma unroll_loop_start
 		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
@@ -8552,15 +8580,15 @@
 		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
 			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
 		#endif
 		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
 	}
 	#pragma unroll_loop_end
 #endif`,
-    ip = `float getShadowMask() {
+    $p = `float getShadowMask() {
 	float shadow = 1.0;
 	#ifdef USE_SHADOWMAP
 	#if NUM_DIR_LIGHT_SHADOWS > 0
 	DirectionalLightShadow directionalLight;
 	#pragma unroll_loop_start
 	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
 		directionalLight = directionalLightShadows[ i ];
@@ -8585,21 +8613,21 @@
 		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
 	}
 	#pragma unroll_loop_end
 	#endif
 	#endif
 	return shadow;
 }`,
-    rp = `#ifdef USE_SKINNING
+    em = `#ifdef USE_SKINNING
 	mat4 boneMatX = getBoneMatrix( skinIndex.x );
 	mat4 boneMatY = getBoneMatrix( skinIndex.y );
 	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
 	mat4 boneMatW = getBoneMatrix( skinIndex.w );
 #endif`,
-    sp = `#ifdef USE_SKINNING
+    tm = `#ifdef USE_SKINNING
 	uniform mat4 bindMatrix;
 	uniform mat4 bindMatrixInverse;
 	uniform highp sampler2D boneTexture;
 	mat4 getBoneMatrix( const in float i ) {
 		int size = textureSize( boneTexture, 0 ).x;
 		int j = int( i ) * 4;
 		int x = j % size;
@@ -8607,49 +8635,49 @@
 		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
 		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
 		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
 		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
 		return mat4( v1, v2, v3, v4 );
 	}
 #endif`,
-    op = `#ifdef USE_SKINNING
+    nm = `#ifdef USE_SKINNING
 	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
 	vec4 skinned = vec4( 0.0 );
 	skinned += boneMatX * skinVertex * skinWeight.x;
 	skinned += boneMatY * skinVertex * skinWeight.y;
 	skinned += boneMatZ * skinVertex * skinWeight.z;
 	skinned += boneMatW * skinVertex * skinWeight.w;
 	transformed = ( bindMatrixInverse * skinned ).xyz;
 #endif`,
-    ap = `#ifdef USE_SKINNING
+    im = `#ifdef USE_SKINNING
 	mat4 skinMatrix = mat4( 0.0 );
 	skinMatrix += skinWeight.x * boneMatX;
 	skinMatrix += skinWeight.y * boneMatY;
 	skinMatrix += skinWeight.z * boneMatZ;
 	skinMatrix += skinWeight.w * boneMatW;
 	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
 	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
 	#ifdef USE_TANGENT
 		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
 	#endif
 #endif`,
-    lp = `float specularStrength;
+    sm = `float specularStrength;
 #ifdef USE_SPECULARMAP
 	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
 	specularStrength = texelSpecular.r;
 #else
 	specularStrength = 1.0;
 #endif`,
-    cp = `#ifdef USE_SPECULARMAP
+    rm = `#ifdef USE_SPECULARMAP
 	uniform sampler2D specularMap;
 #endif`,
-    up = `#if defined( TONE_MAPPING )
+    am = `#if defined( TONE_MAPPING )
 	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
 #endif`,
-    fp = `#ifndef saturate
+    om = `#ifndef saturate
 #define saturate( a ) clamp( a, 0.0, 1.0 )
 #endif
 uniform float toneMappingExposure;
 vec3 LinearToneMapping( vec3 color ) {
 	return saturate( toneMappingExposure * color );
 }
 vec3 ReinhardToneMapping( vec3 color ) {
@@ -8739,15 +8767,15 @@
 	float d = 1. - startCompression;
 	float newPeak = 1. - d * d / (peak + d - startCompression);
 	color *= newPeak / peak;
 	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
 	return mix(color, vec3(1, 1, 1), g);
 }
 vec3 CustomToneMapping( vec3 color ) { return color; }`,
-    hp = `#ifdef USE_TRANSMISSION
+    lm = `#ifdef USE_TRANSMISSION
 	material.transmission = transmission;
 	material.transmissionAlpha = 1.0;
 	material.thickness = thickness;
 	material.attenuationDistance = attenuationDistance;
 	material.attenuationColor = attenuationColor;
 	#ifdef USE_TRANSMISSIONMAP
 		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
@@ -8761,15 +8789,15 @@
 	vec4 transmitted = getIBLVolumeRefraction(
 		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
 		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
 		material.attenuationColor, material.attenuationDistance );
 	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
 	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
 #endif`,
-    dp = `#ifdef USE_TRANSMISSION
+    cm = `#ifdef USE_TRANSMISSION
 	uniform float transmission;
 	uniform float thickness;
 	uniform float attenuationDistance;
 	uniform vec3 attenuationColor;
 	#ifdef USE_TRANSMISSIONMAP
 		uniform sampler2D transmissionMap;
 	#endif
@@ -8868,15 +8896,15 @@
 		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
 		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
 		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
 		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
 		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
 	}
 #endif`,
-    pp = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
+    um = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
 	varying vec2 vUv;
 #endif
 #ifdef USE_MAP
 	varying vec2 vMapUv;
 #endif
 #ifdef USE_ALPHAMAP
 	varying vec2 vAlphaMapUv;
@@ -8939,15 +8967,15 @@
 	uniform mat3 transmissionMapTransform;
 	varying vec2 vTransmissionMapUv;
 #endif
 #ifdef USE_THICKNESSMAP
 	uniform mat3 thicknessMapTransform;
 	varying vec2 vThicknessMapUv;
 #endif`,
-    mp = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
+    dm = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
 	varying vec2 vUv;
 #endif
 #ifdef USE_MAP
 	uniform mat3 mapTransform;
 	varying vec2 vMapUv;
 #endif
 #ifdef USE_ALPHAMAP
@@ -9034,15 +9062,15 @@
 	uniform mat3 transmissionMapTransform;
 	varying vec2 vTransmissionMapUv;
 #endif
 #ifdef USE_THICKNESSMAP
 	uniform mat3 thicknessMapTransform;
 	varying vec2 vThicknessMapUv;
 #endif`,
-    gp = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
+    fm = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
 	vUv = vec3( uv, 1 ).xy;
 #endif
 #ifdef USE_MAP
 	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
 #endif
 #ifdef USE_ALPHAMAP
 	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
@@ -9106,52 +9134,52 @@
 #endif
 #ifdef USE_TRANSMISSIONMAP
 	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
 #endif
 #ifdef USE_THICKNESSMAP
 	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
 #endif`,
-    _p = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
+    hm = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
 	vec4 worldPosition = vec4( transformed, 1.0 );
 	#ifdef USE_BATCHING
 		worldPosition = batchingMatrix * worldPosition;
 	#endif
 	#ifdef USE_INSTANCING
 		worldPosition = instanceMatrix * worldPosition;
 	#endif
 	worldPosition = modelMatrix * worldPosition;
 #endif`;
-const vp = `varying vec2 vUv;
+const pm = `varying vec2 vUv;
 uniform mat3 uvTransform;
 void main() {
 	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
 	gl_Position = vec4( position.xy, 1.0, 1.0 );
 }`,
-    xp = `uniform sampler2D t2D;
+    mm = `uniform sampler2D t2D;
 uniform float backgroundIntensity;
 varying vec2 vUv;
 void main() {
 	vec4 texColor = texture2D( t2D, vUv );
 	#ifdef DECODE_VIDEO_TEXTURE
 		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
 	#endif
 	texColor.rgb *= backgroundIntensity;
 	gl_FragColor = texColor;
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 }`,
-    Sp = `varying vec3 vWorldDirection;
+    gm = `varying vec3 vWorldDirection;
 #include <common>
 void main() {
 	vWorldDirection = transformDirection( position, modelMatrix );
 	#include <begin_vertex>
 	#include <project_vertex>
 	gl_Position.z = gl_Position.w;
 }`,
-    Mp = `#ifdef ENVMAP_TYPE_CUBE
+    _m = `#ifdef ENVMAP_TYPE_CUBE
 	uniform samplerCube envMap;
 #elif defined( ENVMAP_TYPE_CUBE_UV )
 	uniform sampler2D envMap;
 #endif
 uniform float flipEnvMap;
 uniform float backgroundBlurriness;
 uniform float backgroundIntensity;
@@ -9167,34 +9195,34 @@
 		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
 	#endif
 	texColor.rgb *= backgroundIntensity;
 	gl_FragColor = texColor;
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 }`,
-    yp = `varying vec3 vWorldDirection;
+    Sm = `varying vec3 vWorldDirection;
 #include <common>
 void main() {
 	vWorldDirection = transformDirection( position, modelMatrix );
 	#include <begin_vertex>
 	#include <project_vertex>
 	gl_Position.z = gl_Position.w;
 }`,
-    Ap = `uniform samplerCube tCube;
+    vm = `uniform samplerCube tCube;
 uniform float tFlip;
 uniform float opacity;
 varying vec3 vWorldDirection;
 void main() {
 	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
 	gl_FragColor = texColor;
 	gl_FragColor.a *= opacity;
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 }`,
-    Ep = `#include <common>
+    xm = `#include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <morphtarget_pars_vertex>
 #include <skinning_pars_vertex>
 #include <logdepthbuf_pars_vertex>
 #include <clipping_planes_pars_vertex>
@@ -9214,15 +9242,15 @@
 	#include <skinning_vertex>
 	#include <displacementmap_vertex>
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	vHighPrecisionZW = gl_Position.zw;
 }`,
-    bp = `#if DEPTH_PACKING == 3200
+    ym = `#if DEPTH_PACKING == 3200
 	uniform float opacity;
 #endif
 #include <common>
 #include <packing>
 #include <uv_pars_fragment>
 #include <map_pars_fragment>
 #include <alphamap_pars_fragment>
@@ -9245,15 +9273,15 @@
 	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
 	#if DEPTH_PACKING == 3200
 		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
 	#elif DEPTH_PACKING == 3201
 		gl_FragColor = packDepthToRGBA( fragCoordZ );
 	#endif
 }`,
-    Tp = `#define DISTANCE
+    Mm = `#define DISTANCE
 varying vec3 vWorldPosition;
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <morphtarget_pars_vertex>
 #include <skinning_pars_vertex>
@@ -9273,15 +9301,15 @@
 	#include <skinning_vertex>
 	#include <displacementmap_vertex>
 	#include <project_vertex>
 	#include <worldpos_vertex>
 	#include <clipping_planes_vertex>
 	vWorldPosition = worldPosition.xyz;
 }`,
-    wp = `#define DISTANCE
+    Em = `#define DISTANCE
 uniform vec3 referencePosition;
 uniform float nearDistance;
 uniform float farDistance;
 varying vec3 vWorldPosition;
 #include <common>
 #include <packing>
 #include <uv_pars_fragment>
@@ -9298,32 +9326,32 @@
 	#include <alphatest_fragment>
 	#include <alphahash_fragment>
 	float dist = length( vWorldPosition - referencePosition );
 	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
 	dist = saturate( dist );
 	gl_FragColor = packDepthToRGBA( dist );
 }`,
-    Cp = `varying vec3 vWorldDirection;
+    Am = `varying vec3 vWorldDirection;
 #include <common>
 void main() {
 	vWorldDirection = transformDirection( position, modelMatrix );
 	#include <begin_vertex>
 	#include <project_vertex>
 }`,
-    Rp = `uniform sampler2D tEquirect;
+    Tm = `uniform sampler2D tEquirect;
 varying vec3 vWorldDirection;
 #include <common>
 void main() {
 	vec3 direction = normalize( vWorldDirection );
 	vec2 sampleUV = equirectUv( direction );
 	gl_FragColor = texture2D( tEquirect, sampleUV );
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 }`,
-    Pp = `uniform float scale;
+    bm = `uniform float scale;
 attribute float lineDistance;
 varying float vLineDistance;
 #include <common>
 #include <uv_pars_vertex>
 #include <color_pars_vertex>
 #include <fog_pars_vertex>
 #include <morphtarget_pars_vertex>
@@ -9338,15 +9366,15 @@
 	#include <begin_vertex>
 	#include <morphtarget_vertex>
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	#include <fog_vertex>
 }`,
-    Lp = `uniform vec3 diffuse;
+    Cm = `uniform vec3 diffuse;
 uniform float opacity;
 uniform float dashSize;
 uniform float totalSize;
 varying float vLineDistance;
 #include <common>
 #include <color_pars_fragment>
 #include <uv_pars_fragment>
@@ -9367,15 +9395,15 @@
 	outgoingLight = diffuseColor.rgb;
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 }`,
-    Dp = `#include <common>
+    wm = `#include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <envmap_pars_vertex>
 #include <color_pars_vertex>
 #include <fog_pars_vertex>
 #include <morphtarget_pars_vertex>
 #include <skinning_pars_vertex>
@@ -9400,15 +9428,15 @@
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	#include <worldpos_vertex>
 	#include <envmap_vertex>
 	#include <fog_vertex>
 }`,
-    Ip = `uniform vec3 diffuse;
+    Rm = `uniform vec3 diffuse;
 uniform float opacity;
 #ifndef FLAT_SHADED
 	varying vec3 vNormal;
 #endif
 #include <common>
 #include <dithering_pars_fragment>
 #include <color_pars_fragment>
@@ -9449,15 +9477,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    Up = `#define LAMBERT
+    Pm = `#define LAMBERT
 varying vec3 vViewPosition;
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <envmap_pars_vertex>
 #include <color_pars_vertex>
@@ -9489,15 +9517,15 @@
 	#include <clipping_planes_vertex>
 	vViewPosition = - mvPosition.xyz;
 	#include <worldpos_vertex>
 	#include <envmap_vertex>
 	#include <shadowmap_vertex>
 	#include <fog_vertex>
 }`,
-    Fp = `#define LAMBERT
+    Dm = `#define LAMBERT
 uniform vec3 diffuse;
 uniform vec3 emissive;
 uniform float opacity;
 #include <common>
 #include <packing>
 #include <dithering_pars_fragment>
 #include <color_pars_fragment>
@@ -9547,15 +9575,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    Np = `#define MATCAP
+    Lm = `#define MATCAP
 varying vec3 vViewPosition;
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <color_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <fog_pars_vertex>
@@ -9582,15 +9610,15 @@
 	#include <displacementmap_vertex>
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	#include <fog_vertex>
 	vViewPosition = - mvPosition.xyz;
 }`,
-    Bp = `#define MATCAP
+    Fm = `#define MATCAP
 uniform vec3 diffuse;
 uniform float opacity;
 uniform sampler2D matcap;
 varying vec3 vViewPosition;
 #include <common>
 #include <dithering_pars_fragment>
 #include <color_pars_fragment>
@@ -9629,15 +9657,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    Op = `#define NORMAL
+    Im = `#define NORMAL
 #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
 	varying vec3 vViewPosition;
 #endif
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
@@ -9663,15 +9691,15 @@
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
 	vViewPosition = - mvPosition.xyz;
 #endif
 }`,
-    zp = `#define NORMAL
+    Um = `#define NORMAL
 uniform float opacity;
 #if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
 	varying vec3 vViewPosition;
 #endif
 #include <packing>
 #include <uv_pars_fragment>
 #include <normal_pars_fragment>
@@ -9686,15 +9714,15 @@
 	#include <normal_fragment_begin>
 	#include <normal_fragment_maps>
 	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
 	#ifdef OPAQUE
 		gl_FragColor.a = 1.0;
 	#endif
 }`,
-    kp = `#define PHONG
+    Bm = `#define PHONG
 varying vec3 vViewPosition;
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <envmap_pars_vertex>
 #include <color_pars_vertex>
@@ -9726,15 +9754,15 @@
 	#include <clipping_planes_vertex>
 	vViewPosition = - mvPosition.xyz;
 	#include <worldpos_vertex>
 	#include <envmap_vertex>
 	#include <shadowmap_vertex>
 	#include <fog_vertex>
 }`,
-    Gp = `#define PHONG
+    Om = `#define PHONG
 uniform vec3 diffuse;
 uniform vec3 emissive;
 uniform vec3 specular;
 uniform float shininess;
 uniform float opacity;
 #include <common>
 #include <packing>
@@ -9786,15 +9814,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    Hp = `#define STANDARD
+    Nm = `#define STANDARD
 varying vec3 vViewPosition;
 #ifdef USE_TRANSMISSION
 	varying vec3 vWorldPosition;
 #endif
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
@@ -9830,15 +9858,15 @@
 	#include <worldpos_vertex>
 	#include <shadowmap_vertex>
 	#include <fog_vertex>
 #ifdef USE_TRANSMISSION
 	vWorldPosition = worldPosition.xyz;
 #endif
 }`,
-    Vp = `#define STANDARD
+    km = `#define STANDARD
 #ifdef PHYSICAL
 	#define IOR
 	#define USE_SPECULAR
 #endif
 uniform vec3 diffuse;
 uniform vec3 emissive;
 uniform float roughness;
@@ -9953,15 +9981,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    Wp = `#define TOON
+    zm = `#define TOON
 varying vec3 vViewPosition;
 #include <common>
 #include <batching_pars_vertex>
 #include <uv_pars_vertex>
 #include <displacementmap_pars_vertex>
 #include <color_pars_vertex>
 #include <fog_pars_vertex>
@@ -9991,15 +10019,15 @@
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	vViewPosition = - mvPosition.xyz;
 	#include <worldpos_vertex>
 	#include <shadowmap_vertex>
 	#include <fog_vertex>
 }`,
-    Xp = `#define TOON
+    Hm = `#define TOON
 uniform vec3 diffuse;
 uniform vec3 emissive;
 uniform float opacity;
 #include <common>
 #include <packing>
 #include <dithering_pars_fragment>
 #include <color_pars_fragment>
@@ -10045,15 +10073,15 @@
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 	#include <dithering_fragment>
 }`,
-    qp = `uniform float size;
+    Gm = `uniform float size;
 uniform float scale;
 #include <common>
 #include <color_pars_vertex>
 #include <fog_pars_vertex>
 #include <morphtarget_pars_vertex>
 #include <logdepthbuf_pars_vertex>
 #include <clipping_planes_pars_vertex>
@@ -10077,15 +10105,15 @@
 		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
 	#endif
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	#include <worldpos_vertex>
 	#include <fog_vertex>
 }`,
-    Yp = `uniform vec3 diffuse;
+    Vm = `uniform vec3 diffuse;
 uniform float opacity;
 #include <common>
 #include <color_pars_fragment>
 #include <map_particle_pars_fragment>
 #include <alphatest_pars_fragment>
 #include <alphahash_pars_fragment>
 #include <fog_pars_fragment>
@@ -10103,15 +10131,15 @@
 	outgoingLight = diffuseColor.rgb;
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 	#include <premultiplied_alpha_fragment>
 }`,
-    jp = `#include <common>
+    Wm = `#include <common>
 #include <batching_pars_vertex>
 #include <fog_pars_vertex>
 #include <morphtarget_pars_vertex>
 #include <skinning_pars_vertex>
 #include <logdepthbuf_pars_vertex>
 #include <shadowmap_pars_vertex>
 void main() {
@@ -10127,15 +10155,15 @@
 	#include <skinning_vertex>
 	#include <project_vertex>
 	#include <logdepthbuf_vertex>
 	#include <worldpos_vertex>
 	#include <shadowmap_vertex>
 	#include <fog_vertex>
 }`,
-    Kp = `uniform vec3 color;
+    Xm = `uniform vec3 color;
 uniform float opacity;
 #include <common>
 #include <packing>
 #include <fog_pars_fragment>
 #include <bsdfs>
 #include <lights_pars_begin>
 #include <logdepthbuf_pars_fragment>
@@ -10144,15 +10172,15 @@
 void main() {
 	#include <logdepthbuf_fragment>
 	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 }`,
-    Qp = `uniform float rotation;
+    qm = `uniform float rotation;
 uniform vec2 center;
 #include <common>
 #include <uv_pars_vertex>
 #include <fog_pars_vertex>
 #include <logdepthbuf_pars_vertex>
 #include <clipping_planes_pars_vertex>
 void main() {
@@ -10171,15 +10199,15 @@
 	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
 	mvPosition.xy += rotatedPosition;
 	gl_Position = projectionMatrix * mvPosition;
 	#include <logdepthbuf_vertex>
 	#include <clipping_planes_vertex>
 	#include <fog_vertex>
 }`,
-    Zp = `uniform vec3 diffuse;
+    Ym = `uniform vec3 diffuse;
 uniform float opacity;
 #include <common>
 #include <uv_pars_fragment>
 #include <map_pars_fragment>
 #include <alphamap_pars_fragment>
 #include <alphatest_pars_fragment>
 #include <alphahash_pars_fragment>
@@ -10197,196 +10225,196 @@
 	#include <alphahash_fragment>
 	outgoingLight = diffuseColor.rgb;
 	#include <opaque_fragment>
 	#include <tonemapping_fragment>
 	#include <colorspace_fragment>
 	#include <fog_fragment>
 }`,
-    We = {
-        alphahash_fragment: vh,
-        alphahash_pars_fragment: xh,
-        alphamap_fragment: Sh,
-        alphamap_pars_fragment: Mh,
-        alphatest_fragment: yh,
-        alphatest_pars_fragment: Ah,
-        aomap_fragment: Eh,
-        aomap_pars_fragment: bh,
-        batching_pars_vertex: Th,
-        batching_vertex: wh,
-        begin_vertex: Ch,
-        beginnormal_vertex: Rh,
-        bsdfs: Ph,
-        iridescence_fragment: Lh,
-        bumpmap_pars_fragment: Dh,
-        clipping_planes_fragment: Ih,
-        clipping_planes_pars_fragment: Uh,
-        clipping_planes_pars_vertex: Fh,
-        clipping_planes_vertex: Nh,
-        color_fragment: Bh,
-        color_pars_fragment: Oh,
-        color_pars_vertex: zh,
-        color_vertex: kh,
-        common: Gh,
-        cube_uv_reflection_fragment: Hh,
-        defaultnormal_vertex: Vh,
-        displacementmap_pars_vertex: Wh,
-        displacementmap_vertex: Xh,
-        emissivemap_fragment: qh,
-        emissivemap_pars_fragment: Yh,
-        colorspace_fragment: jh,
-        colorspace_pars_fragment: Kh,
-        envmap_fragment: Qh,
-        envmap_common_pars_fragment: Zh,
-        envmap_pars_fragment: Jh,
-        envmap_pars_vertex: $h,
-        envmap_physical_pars_fragment: fd,
-        envmap_vertex: ed,
-        fog_vertex: td,
-        fog_pars_vertex: nd,
-        fog_fragment: id,
-        fog_pars_fragment: rd,
-        gradientmap_pars_fragment: sd,
-        lightmap_fragment: od,
-        lightmap_pars_fragment: ad,
-        lights_lambert_fragment: ld,
-        lights_lambert_pars_fragment: cd,
-        lights_pars_begin: ud,
-        lights_toon_fragment: hd,
-        lights_toon_pars_fragment: dd,
-        lights_phong_fragment: pd,
-        lights_phong_pars_fragment: md,
-        lights_physical_fragment: gd,
-        lights_physical_pars_fragment: _d,
-        lights_fragment_begin: vd,
-        lights_fragment_maps: xd,
-        lights_fragment_end: Sd,
-        logdepthbuf_fragment: Md,
-        logdepthbuf_pars_fragment: yd,
-        logdepthbuf_pars_vertex: Ad,
-        logdepthbuf_vertex: Ed,
-        map_fragment: bd,
-        map_pars_fragment: Td,
-        map_particle_fragment: wd,
-        map_particle_pars_fragment: Cd,
-        metalnessmap_fragment: Rd,
-        metalnessmap_pars_fragment: Pd,
-        morphinstance_vertex: Ld,
-        morphcolor_vertex: Dd,
-        morphnormal_vertex: Id,
-        morphtarget_pars_vertex: Ud,
-        morphtarget_vertex: Fd,
-        normal_fragment_begin: Nd,
-        normal_fragment_maps: Bd,
-        normal_pars_fragment: Od,
-        normal_pars_vertex: zd,
-        normal_vertex: kd,
-        normalmap_pars_fragment: Gd,
-        clearcoat_normal_fragment_begin: Hd,
-        clearcoat_normal_fragment_maps: Vd,
-        clearcoat_pars_fragment: Wd,
-        iridescence_pars_fragment: Xd,
-        opaque_fragment: qd,
-        packing: Yd,
-        premultiplied_alpha_fragment: jd,
-        project_vertex: Kd,
-        dithering_fragment: Qd,
-        dithering_pars_fragment: Zd,
-        roughnessmap_fragment: Jd,
-        roughnessmap_pars_fragment: $d,
-        shadowmap_pars_fragment: ep,
-        shadowmap_pars_vertex: tp,
-        shadowmap_vertex: np,
-        shadowmask_pars_fragment: ip,
-        skinbase_vertex: rp,
-        skinning_pars_vertex: sp,
-        skinning_vertex: op,
-        skinnormal_vertex: ap,
-        specularmap_fragment: lp,
-        specularmap_pars_fragment: cp,
-        tonemapping_fragment: up,
-        tonemapping_pars_fragment: fp,
-        transmission_fragment: hp,
-        transmission_pars_fragment: dp,
-        uv_pars_fragment: pp,
-        uv_pars_vertex: mp,
-        uv_vertex: gp,
-        worldpos_vertex: _p,
-        background_vert: vp,
-        background_frag: xp,
-        backgroundCube_vert: Sp,
-        backgroundCube_frag: Mp,
-        cube_vert: yp,
-        cube_frag: Ap,
-        depth_vert: Ep,
-        depth_frag: bp,
-        distanceRGBA_vert: Tp,
-        distanceRGBA_frag: wp,
-        equirect_vert: Cp,
-        equirect_frag: Rp,
-        linedashed_vert: Pp,
-        linedashed_frag: Lp,
-        meshbasic_vert: Dp,
-        meshbasic_frag: Ip,
-        meshlambert_vert: Up,
-        meshlambert_frag: Fp,
-        meshmatcap_vert: Np,
-        meshmatcap_frag: Bp,
-        meshnormal_vert: Op,
-        meshnormal_frag: zp,
-        meshphong_vert: kp,
-        meshphong_frag: Gp,
-        meshphysical_vert: Hp,
-        meshphysical_frag: Vp,
-        meshtoon_vert: Wp,
-        meshtoon_frag: Xp,
-        points_vert: qp,
-        points_frag: Yp,
-        shadow_vert: jp,
-        shadow_frag: Kp,
-        sprite_vert: Qp,
-        sprite_frag: Zp
+    je = {
+        alphahash_fragment: ph,
+        alphahash_pars_fragment: mh,
+        alphamap_fragment: gh,
+        alphamap_pars_fragment: _h,
+        alphatest_fragment: Sh,
+        alphatest_pars_fragment: vh,
+        aomap_fragment: xh,
+        aomap_pars_fragment: yh,
+        batching_pars_vertex: Mh,
+        batching_vertex: Eh,
+        begin_vertex: Ah,
+        beginnormal_vertex: Th,
+        bsdfs: bh,
+        iridescence_fragment: Ch,
+        bumpmap_pars_fragment: wh,
+        clipping_planes_fragment: Rh,
+        clipping_planes_pars_fragment: Ph,
+        clipping_planes_pars_vertex: Dh,
+        clipping_planes_vertex: Lh,
+        color_fragment: Fh,
+        color_pars_fragment: Ih,
+        color_pars_vertex: Uh,
+        color_vertex: Bh,
+        common: Oh,
+        cube_uv_reflection_fragment: Nh,
+        defaultnormal_vertex: kh,
+        displacementmap_pars_vertex: zh,
+        displacementmap_vertex: Hh,
+        emissivemap_fragment: Gh,
+        emissivemap_pars_fragment: Vh,
+        colorspace_fragment: Wh,
+        colorspace_pars_fragment: Xh,
+        envmap_fragment: qh,
+        envmap_common_pars_fragment: Yh,
+        envmap_pars_fragment: jh,
+        envmap_pars_vertex: Kh,
+        envmap_physical_pars_fragment: op,
+        envmap_vertex: Zh,
+        fog_vertex: Qh,
+        fog_pars_vertex: Jh,
+        fog_fragment: $h,
+        fog_pars_fragment: ep,
+        gradientmap_pars_fragment: tp,
+        lightmap_fragment: np,
+        lightmap_pars_fragment: ip,
+        lights_lambert_fragment: sp,
+        lights_lambert_pars_fragment: rp,
+        lights_pars_begin: ap,
+        lights_toon_fragment: lp,
+        lights_toon_pars_fragment: cp,
+        lights_phong_fragment: up,
+        lights_phong_pars_fragment: dp,
+        lights_physical_fragment: fp,
+        lights_physical_pars_fragment: hp,
+        lights_fragment_begin: pp,
+        lights_fragment_maps: mp,
+        lights_fragment_end: gp,
+        logdepthbuf_fragment: _p,
+        logdepthbuf_pars_fragment: Sp,
+        logdepthbuf_pars_vertex: vp,
+        logdepthbuf_vertex: xp,
+        map_fragment: yp,
+        map_pars_fragment: Mp,
+        map_particle_fragment: Ep,
+        map_particle_pars_fragment: Ap,
+        metalnessmap_fragment: Tp,
+        metalnessmap_pars_fragment: bp,
+        morphinstance_vertex: Cp,
+        morphcolor_vertex: wp,
+        morphnormal_vertex: Rp,
+        morphtarget_pars_vertex: Pp,
+        morphtarget_vertex: Dp,
+        normal_fragment_begin: Lp,
+        normal_fragment_maps: Fp,
+        normal_pars_fragment: Ip,
+        normal_pars_vertex: Up,
+        normal_vertex: Bp,
+        normalmap_pars_fragment: Op,
+        clearcoat_normal_fragment_begin: Np,
+        clearcoat_normal_fragment_maps: kp,
+        clearcoat_pars_fragment: zp,
+        iridescence_pars_fragment: Hp,
+        opaque_fragment: Gp,
+        packing: Vp,
+        premultiplied_alpha_fragment: Wp,
+        project_vertex: Xp,
+        dithering_fragment: qp,
+        dithering_pars_fragment: Yp,
+        roughnessmap_fragment: jp,
+        roughnessmap_pars_fragment: Kp,
+        shadowmap_pars_fragment: Zp,
+        shadowmap_pars_vertex: Qp,
+        shadowmap_vertex: Jp,
+        shadowmask_pars_fragment: $p,
+        skinbase_vertex: em,
+        skinning_pars_vertex: tm,
+        skinning_vertex: nm,
+        skinnormal_vertex: im,
+        specularmap_fragment: sm,
+        specularmap_pars_fragment: rm,
+        tonemapping_fragment: am,
+        tonemapping_pars_fragment: om,
+        transmission_fragment: lm,
+        transmission_pars_fragment: cm,
+        uv_pars_fragment: um,
+        uv_pars_vertex: dm,
+        uv_vertex: fm,
+        worldpos_vertex: hm,
+        background_vert: pm,
+        background_frag: mm,
+        backgroundCube_vert: gm,
+        backgroundCube_frag: _m,
+        cube_vert: Sm,
+        cube_frag: vm,
+        depth_vert: xm,
+        depth_frag: ym,
+        distanceRGBA_vert: Mm,
+        distanceRGBA_frag: Em,
+        equirect_vert: Am,
+        equirect_frag: Tm,
+        linedashed_vert: bm,
+        linedashed_frag: Cm,
+        meshbasic_vert: wm,
+        meshbasic_frag: Rm,
+        meshlambert_vert: Pm,
+        meshlambert_frag: Dm,
+        meshmatcap_vert: Lm,
+        meshmatcap_frag: Fm,
+        meshnormal_vert: Im,
+        meshnormal_frag: Um,
+        meshphong_vert: Bm,
+        meshphong_frag: Om,
+        meshphysical_vert: Nm,
+        meshphysical_frag: km,
+        meshtoon_vert: zm,
+        meshtoon_frag: Hm,
+        points_vert: Gm,
+        points_frag: Vm,
+        shadow_vert: Wm,
+        shadow_frag: Xm,
+        sprite_vert: qm,
+        sprite_frag: Ym
     },
-    oe = {
+    he = {
         common: {
             diffuse: {
-                value: /* @__PURE__ */ new Qe(16777215)
+                value: /* @__PURE__ */ new et(16777215)
             },
             opacity: {
                 value: 1
             },
             map: {
                 value: null
             },
             mapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             alphaMap: {
                 value: null
             },
             alphaMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             alphaTest: {
                 value: 0
             }
         },
         specularmap: {
             specularMap: {
                 value: null
             },
             specularMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         envmap: {
             envMap: {
                 value: null
             },
             envMapRotation: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             flipEnvMap: {
                 value: -1
             },
             reflectivity: {
                 value: 1
             },
@@ -10404,86 +10432,86 @@
             aoMap: {
                 value: null
             },
             aoMapIntensity: {
                 value: 1
             },
             aoMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         lightmap: {
             lightMap: {
                 value: null
             },
             lightMapIntensity: {
                 value: 1
             },
             lightMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         bumpmap: {
             bumpMap: {
                 value: null
             },
             bumpMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             bumpScale: {
                 value: 1
             }
         },
         normalmap: {
             normalMap: {
                 value: null
             },
             normalMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             normalScale: {
-                value: /* @__PURE__ */ new me(1, 1)
+                value: /* @__PURE__ */ new Ee(1, 1)
             }
         },
         displacementmap: {
             displacementMap: {
                 value: null
             },
             displacementMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             displacementScale: {
                 value: 1
             },
             displacementBias: {
                 value: 0
             }
         },
         emissivemap: {
             emissiveMap: {
                 value: null
             },
             emissiveMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         metalnessmap: {
             metalnessMap: {
                 value: null
             },
             metalnessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         roughnessmap: {
             roughnessMap: {
                 value: null
             },
             roughnessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         gradientmap: {
             gradientMap: {
                 value: null
             }
         },
@@ -10494,15 +10522,15 @@
             fogNear: {
                 value: 1
             },
             fogFar: {
                 value: 2e3
             },
             fogColor: {
-                value: /* @__PURE__ */ new Qe(16777215)
+                value: /* @__PURE__ */ new et(16777215)
             }
         },
         lights: {
             ambientLightColor: {
                 value: []
             },
             lightProbe: {
@@ -10609,15 +10637,15 @@
             },
             ltc_2: {
                 value: null
             }
         },
         points: {
             diffuse: {
-                value: /* @__PURE__ */ new Qe(16777215)
+                value: /* @__PURE__ */ new et(16777215)
             },
             opacity: {
                 value: 1
             },
             size: {
                 value: 1
             },
@@ -10627,251 +10655,251 @@
             map: {
                 value: null
             },
             alphaMap: {
                 value: null
             },
             alphaMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             alphaTest: {
                 value: 0
             },
             uvTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         },
         sprite: {
             diffuse: {
-                value: /* @__PURE__ */ new Qe(16777215)
+                value: /* @__PURE__ */ new et(16777215)
             },
             opacity: {
                 value: 1
             },
             center: {
-                value: /* @__PURE__ */ new me(0.5, 0.5)
+                value: /* @__PURE__ */ new Ee(0.5, 0.5)
             },
             rotation: {
                 value: 0
             },
             map: {
                 value: null
             },
             mapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             alphaMap: {
                 value: null
             },
             alphaMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             alphaTest: {
                 value: 0
             }
         }
     },
-    on = {
+    mn = {
         basic: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.specularmap,
-                oe.envmap,
-                oe.aomap,
-                oe.lightmap,
-                oe.fog
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.specularmap,
+                he.envmap,
+                he.aomap,
+                he.lightmap,
+                he.fog
             ]),
-            vertexShader: We.meshbasic_vert,
-            fragmentShader: We.meshbasic_frag
+            vertexShader: je.meshbasic_vert,
+            fragmentShader: je.meshbasic_frag
         },
         lambert: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.specularmap,
-                oe.envmap,
-                oe.aomap,
-                oe.lightmap,
-                oe.emissivemap,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap,
-                oe.fog,
-                oe.lights, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.specularmap,
+                he.envmap,
+                he.aomap,
+                he.lightmap,
+                he.emissivemap,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap,
+                he.fog,
+                he.lights, {
                     emissive: {
-                        value: /* @__PURE__ */ new Qe(0)
+                        value: /* @__PURE__ */ new et(0)
                     }
                 }
             ]),
-            vertexShader: We.meshlambert_vert,
-            fragmentShader: We.meshlambert_frag
+            vertexShader: je.meshlambert_vert,
+            fragmentShader: je.meshlambert_frag
         },
         phong: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.specularmap,
-                oe.envmap,
-                oe.aomap,
-                oe.lightmap,
-                oe.emissivemap,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap,
-                oe.fog,
-                oe.lights, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.specularmap,
+                he.envmap,
+                he.aomap,
+                he.lightmap,
+                he.emissivemap,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap,
+                he.fog,
+                he.lights, {
                     emissive: {
-                        value: /* @__PURE__ */ new Qe(0)
+                        value: /* @__PURE__ */ new et(0)
                     },
                     specular: {
-                        value: /* @__PURE__ */ new Qe(1118481)
+                        value: /* @__PURE__ */ new et(1118481)
                     },
                     shininess: {
                         value: 30
                     }
                 }
             ]),
-            vertexShader: We.meshphong_vert,
-            fragmentShader: We.meshphong_frag
+            vertexShader: je.meshphong_vert,
+            fragmentShader: je.meshphong_frag
         },
         standard: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.envmap,
-                oe.aomap,
-                oe.lightmap,
-                oe.emissivemap,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap,
-                oe.roughnessmap,
-                oe.metalnessmap,
-                oe.fog,
-                oe.lights, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.envmap,
+                he.aomap,
+                he.lightmap,
+                he.emissivemap,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap,
+                he.roughnessmap,
+                he.metalnessmap,
+                he.fog,
+                he.lights, {
                     emissive: {
-                        value: /* @__PURE__ */ new Qe(0)
+                        value: /* @__PURE__ */ new et(0)
                     },
                     roughness: {
                         value: 1
                     },
                     metalness: {
                         value: 0
                     },
                     envMapIntensity: {
                         value: 1
                     }
                     // temporary
                 }
             ]),
-            vertexShader: We.meshphysical_vert,
-            fragmentShader: We.meshphysical_frag
+            vertexShader: je.meshphysical_vert,
+            fragmentShader: je.meshphysical_frag
         },
         toon: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.aomap,
-                oe.lightmap,
-                oe.emissivemap,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap,
-                oe.gradientmap,
-                oe.fog,
-                oe.lights, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.aomap,
+                he.lightmap,
+                he.emissivemap,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap,
+                he.gradientmap,
+                he.fog,
+                he.lights, {
                     emissive: {
-                        value: /* @__PURE__ */ new Qe(0)
+                        value: /* @__PURE__ */ new et(0)
                     }
                 }
             ]),
-            vertexShader: We.meshtoon_vert,
-            fragmentShader: We.meshtoon_frag
+            vertexShader: je.meshtoon_vert,
+            fragmentShader: je.meshtoon_frag
         },
         matcap: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap,
-                oe.fog, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap,
+                he.fog, {
                     matcap: {
                         value: null
                     }
                 }
             ]),
-            vertexShader: We.meshmatcap_vert,
-            fragmentShader: We.meshmatcap_frag
+            vertexShader: je.meshmatcap_vert,
+            fragmentShader: je.meshmatcap_frag
         },
         points: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.points,
-                oe.fog
+            uniforms: /* @__PURE__ */ Ut([
+                he.points,
+                he.fog
             ]),
-            vertexShader: We.points_vert,
-            fragmentShader: We.points_frag
+            vertexShader: je.points_vert,
+            fragmentShader: je.points_frag
         },
         dashed: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.fog, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.fog, {
                     scale: {
                         value: 1
                     },
                     dashSize: {
                         value: 1
                     },
                     totalSize: {
                         value: 2
                     }
                 }
             ]),
-            vertexShader: We.linedashed_vert,
-            fragmentShader: We.linedashed_frag
+            vertexShader: je.linedashed_vert,
+            fragmentShader: je.linedashed_frag
         },
         depth: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.displacementmap
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.displacementmap
             ]),
-            vertexShader: We.depth_vert,
-            fragmentShader: We.depth_frag
+            vertexShader: je.depth_vert,
+            fragmentShader: je.depth_frag
         },
         normal: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.bumpmap,
-                oe.normalmap,
-                oe.displacementmap, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.bumpmap,
+                he.normalmap,
+                he.displacementmap, {
                     opacity: {
                         value: 1
                     }
                 }
             ]),
-            vertexShader: We.meshnormal_vert,
-            fragmentShader: We.meshnormal_frag
+            vertexShader: je.meshnormal_vert,
+            fragmentShader: je.meshnormal_frag
         },
         sprite: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.sprite,
-                oe.fog
+            uniforms: /* @__PURE__ */ Ut([
+                he.sprite,
+                he.fog
             ]),
-            vertexShader: We.sprite_vert,
-            fragmentShader: We.sprite_frag
+            vertexShader: je.sprite_vert,
+            fragmentShader: je.sprite_frag
         },
         background: {
             uniforms: {
                 uvTransform: {
-                    value: /* @__PURE__ */ new be()
+                    value: /* @__PURE__ */ new Ue()
                 },
                 t2D: {
                     value: null
                 },
                 backgroundIntensity: {
                     value: 1
                 }
             },
-            vertexShader: We.background_vert,
-            fragmentShader: We.background_frag
+            vertexShader: je.background_vert,
+            fragmentShader: je.background_frag
         },
         backgroundCube: {
             uniforms: {
                 envMap: {
                     value: null
                 },
                 flipEnvMap: {
@@ -10880,855 +10908,855 @@
                 backgroundBlurriness: {
                     value: 0
                 },
                 backgroundIntensity: {
                     value: 1
                 },
                 backgroundRotation: {
-                    value: /* @__PURE__ */ new be()
+                    value: /* @__PURE__ */ new Ue()
                 }
             },
-            vertexShader: We.backgroundCube_vert,
-            fragmentShader: We.backgroundCube_frag
+            vertexShader: je.backgroundCube_vert,
+            fragmentShader: je.backgroundCube_frag
         },
         cube: {
             uniforms: {
                 tCube: {
                     value: null
                 },
                 tFlip: {
                     value: -1
                 },
                 opacity: {
                     value: 1
                 }
             },
-            vertexShader: We.cube_vert,
-            fragmentShader: We.cube_frag
+            vertexShader: je.cube_vert,
+            fragmentShader: je.cube_frag
         },
         equirect: {
             uniforms: {
                 tEquirect: {
                     value: null
                 }
             },
-            vertexShader: We.equirect_vert,
-            fragmentShader: We.equirect_frag
+            vertexShader: je.equirect_vert,
+            fragmentShader: je.equirect_frag
         },
         distanceRGBA: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.common,
-                oe.displacementmap, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.common,
+                he.displacementmap, {
                     referencePosition: {
-                        value: /* @__PURE__ */ new P()
+                        value: /* @__PURE__ */ new D()
                     },
                     nearDistance: {
                         value: 1
                     },
                     farDistance: {
                         value: 1e3
                     }
                 }
             ]),
-            vertexShader: We.distanceRGBA_vert,
-            fragmentShader: We.distanceRGBA_frag
+            vertexShader: je.distanceRGBA_vert,
+            fragmentShader: je.distanceRGBA_frag
         },
         shadow: {
-            uniforms: /* @__PURE__ */ bt([
-                oe.lights,
-                oe.fog, {
+            uniforms: /* @__PURE__ */ Ut([
+                he.lights,
+                he.fog, {
                     color: {
-                        value: /* @__PURE__ */ new Qe(0)
+                        value: /* @__PURE__ */ new et(0)
                     },
                     opacity: {
                         value: 1
                     }
                 }
             ]),
-            vertexShader: We.shadow_vert,
-            fragmentShader: We.shadow_frag
+            vertexShader: je.shadow_vert,
+            fragmentShader: je.shadow_frag
         }
     };
-on.physical = {
-    uniforms: /* @__PURE__ */ bt([
-        on.standard.uniforms, {
+mn.physical = {
+    uniforms: /* @__PURE__ */ Ut([
+        mn.standard.uniforms, {
             clearcoat: {
                 value: 0
             },
             clearcoatMap: {
                 value: null
             },
             clearcoatMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             clearcoatNormalMap: {
                 value: null
             },
             clearcoatNormalMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             clearcoatNormalScale: {
-                value: /* @__PURE__ */ new me(1, 1)
+                value: /* @__PURE__ */ new Ee(1, 1)
             },
             clearcoatRoughness: {
                 value: 0
             },
             clearcoatRoughnessMap: {
                 value: null
             },
             clearcoatRoughnessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             iridescence: {
                 value: 0
             },
             iridescenceMap: {
                 value: null
             },
             iridescenceMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             iridescenceIOR: {
                 value: 1.3
             },
             iridescenceThicknessMinimum: {
                 value: 100
             },
             iridescenceThicknessMaximum: {
                 value: 400
             },
             iridescenceThicknessMap: {
                 value: null
             },
             iridescenceThicknessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             sheen: {
                 value: 0
             },
             sheenColor: {
-                value: /* @__PURE__ */ new Qe(0)
+                value: /* @__PURE__ */ new et(0)
             },
             sheenColorMap: {
                 value: null
             },
             sheenColorMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             sheenRoughness: {
                 value: 1
             },
             sheenRoughnessMap: {
                 value: null
             },
             sheenRoughnessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             transmission: {
                 value: 0
             },
             transmissionMap: {
                 value: null
             },
             transmissionMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             transmissionSamplerSize: {
-                value: /* @__PURE__ */ new me()
+                value: /* @__PURE__ */ new Ee()
             },
             transmissionSamplerMap: {
                 value: null
             },
             thickness: {
                 value: 0
             },
             thicknessMap: {
                 value: null
             },
             thicknessMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             attenuationDistance: {
                 value: 0
             },
             attenuationColor: {
-                value: /* @__PURE__ */ new Qe(0)
+                value: /* @__PURE__ */ new et(0)
             },
             specularColor: {
-                value: /* @__PURE__ */ new Qe(1, 1, 1)
+                value: /* @__PURE__ */ new et(1, 1, 1)
             },
             specularColorMap: {
                 value: null
             },
             specularColorMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             specularIntensity: {
                 value: 1
             },
             specularIntensityMap: {
                 value: null
             },
             specularIntensityMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             },
             anisotropyVector: {
-                value: /* @__PURE__ */ new me()
+                value: /* @__PURE__ */ new Ee()
             },
             anisotropyMap: {
                 value: null
             },
             anisotropyMapTransform: {
-                value: /* @__PURE__ */ new be()
+                value: /* @__PURE__ */ new Ue()
             }
         }
     ]),
-    vertexShader: We.meshphysical_vert,
-    fragmentShader: We.meshphysical_frag
+    vertexShader: je.meshphysical_vert,
+    fragmentShader: je.meshphysical_frag
 };
-const Fr = {
+const sr = {
         r: 0,
         b: 0,
         g: 0
     },
-    Zn = /* @__PURE__ */ new bn(),
-    Jp = /* @__PURE__ */ new ke();
+    ci = /* @__PURE__ */ new Nn(),
+    jm = /* @__PURE__ */ new Ge();
 
-function $p(i, e, t, n, r, s, a) {
-    const o = new Qe(0);
-    let l = s === !0 ? 0 : 1,
-        c, u, f = null,
-        h = 0,
-        p = null;
-
-    function g(m, d) {
-        let M = !1,
-            _ = d.isScene === !0 ? d.background : null;
-        _ && _.isTexture && (_ = (d.backgroundBlurriness > 0 ? t : e).get(_)), _ === null ? v(o, l) : _ && _.isColor && (v(_, 1), M = !0);
-        const A = i.xr.getEnvironmentBlendMode();
-        A === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, a) : A === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, a), (i.autoClear || M) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), _ && (_.isCubeTexture || _.mapping === ss) ? (u === void 0 && (u = new at(
-            new Qi(1, 1, 1),
-            new Xt({
+function Km(s, e, t, n, i, r, o) {
+    const a = new et(0);
+    let l = r === !0 ? 0 : 1,
+        c, u, d = null,
+        f = 0,
+        h = null;
+
+    function g(m, p) {
+        let v = !1,
+            S = p.isScene === !0 ? p.background : null;
+        S && S.isTexture && (S = (p.backgroundBlurriness > 0 ? t : e).get(S)), S === null ? _(a, l) : S && S.isColor && (_(S, 1), v = !0);
+        const y = s.xr.getEnvironmentBlendMode();
+        y === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : y === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (s.autoClear || v) && s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil), S && (S.isCubeTexture || S.mapping === Fr) ? (u === void 0 && (u = new pt(
+            new gs(1, 1, 1),
+            new tn({
                 name: "BackgroundCubeMaterial",
-                uniforms: Vi(on.backgroundCube.uniforms),
-                vertexShader: on.backgroundCube.vertexShader,
-                fragmentShader: on.backgroundCube.fragmentShader,
-                side: Pt,
+                uniforms: us(mn.backgroundCube.uniforms),
+                vertexShader: mn.backgroundCube.vertexShader,
+                fragmentShader: mn.backgroundCube.fragmentShader,
+                side: zt,
                 depthTest: !1,
                 depthWrite: !1,
                 fog: !1
             })
-        ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(R, E, b) {
-            this.matrixWorld.copyPosition(b.matrixWorld);
+        ), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(b, E, T) {
+            this.matrixWorld.copyPosition(T.matrixWorld);
         }, Object.defineProperty(u.material, "envMap", {
             get: function() {
                 return this.uniforms.envMap.value;
             }
-        }), r.update(u)), Zn.copy(d.backgroundRotation), Zn.x *= -1, Zn.y *= -1, Zn.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (Zn.y *= -1, Zn.z *= -1), u.material.uniforms.envMap.value = _, u.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = d.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = d.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(Jp.makeRotationFromEuler(Zn)), u.material.toneMapped = Ze.getTransfer(_.colorSpace) !== nt, (f !== _ || h !== _.version || p !== i.toneMapping) && (u.material.needsUpdate = !0, f = _, h = _.version, p = i.toneMapping), u.layers.enableAll(), m.unshift(u, u.geometry, u.material, 0, 0, null)) : _ && _.isTexture && (c === void 0 && (c = new at(
-            new Wi(2, 2),
-            new Xt({
+        }), i.update(u)), ci.copy(p.backgroundRotation), ci.x *= -1, ci.y *= -1, ci.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (ci.y *= -1, ci.z *= -1), u.material.uniforms.envMap.value = S, u.material.uniforms.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = p.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(jm.makeRotationFromEuler(ci)), u.material.toneMapped = tt.getTransfer(S.colorSpace) !== at, (d !== S || f !== S.version || h !== s.toneMapping) && (u.material.needsUpdate = !0, d = S, f = S.version, h = s.toneMapping), u.layers.enableAll(), m.unshift(u, u.geometry, u.material, 0, 0, null)) : S && S.isTexture && (c === void 0 && (c = new pt(
+            new ds(2, 2),
+            new tn({
                 name: "BackgroundMaterial",
-                uniforms: Vi(on.background.uniforms),
-                vertexShader: on.background.vertexShader,
-                fragmentShader: on.background.fragmentShader,
-                side: hn,
+                uniforms: us(mn.background.uniforms),
+                vertexShader: mn.background.vertexShader,
+                fragmentShader: mn.background.fragmentShader,
+                side: yn,
                 depthTest: !1,
                 depthWrite: !1,
                 fog: !1
             })
         ), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
             get: function() {
                 return this.uniforms.t2D.value;
             }
-        }), r.update(c)), c.material.uniforms.t2D.value = _, c.material.uniforms.backgroundIntensity.value = d.backgroundIntensity, c.material.toneMapped = Ze.getTransfer(_.colorSpace) !== nt, _.matrixAutoUpdate === !0 && _.updateMatrix(), c.material.uniforms.uvTransform.value.copy(_.matrix), (f !== _ || h !== _.version || p !== i.toneMapping) && (c.material.needsUpdate = !0, f = _, h = _.version, p = i.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null));
+        }), i.update(c)), c.material.uniforms.t2D.value = S, c.material.uniforms.backgroundIntensity.value = p.backgroundIntensity, c.material.toneMapped = tt.getTransfer(S.colorSpace) !== at, S.matrixAutoUpdate === !0 && S.updateMatrix(), c.material.uniforms.uvTransform.value.copy(S.matrix), (d !== S || f !== S.version || h !== s.toneMapping) && (c.material.needsUpdate = !0, d = S, f = S.version, h = s.toneMapping), c.layers.enableAll(), m.unshift(c, c.geometry, c.material, 0, 0, null));
     }
 
-    function v(m, d) {
-        m.getRGB(Fr, tc(i)), n.buffers.color.setClear(Fr.r, Fr.g, Fr.b, d, a);
+    function _(m, p) {
+        m.getRGB(sr, Kc(s)), n.buffers.color.setClear(sr.r, sr.g, sr.b, p, o);
     }
     return {
         getClearColor: function() {
-            return o;
+            return a;
         },
-        setClearColor: function(m, d = 1) {
-            o.set(m), l = d, v(o, l);
+        setClearColor: function(m, p = 1) {
+            a.set(m), l = p, _(a, l);
         },
         getClearAlpha: function() {
             return l;
         },
         setClearAlpha: function(m) {
-            l = m, v(o, l);
+            l = m, _(a, l);
         },
         render: g
     };
 }
 
-function em(i, e, t, n) {
-    const r = i.getParameter(i.MAX_VERTEX_ATTRIBS),
-        s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
-        a = n.isWebGL2 || s !== null,
-        o = {},
+function Zm(s, e, t, n) {
+    const i = s.getParameter(s.MAX_VERTEX_ATTRIBS),
+        r = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
+        o = n.isWebGL2 || r !== null,
+        a = {},
         l = m(null);
     let c = l,
         u = !1;
 
-    function f(L, N, O, B, j) {
+    function d(P, I, z, K, G) {
         let q = !1;
-        if (a) {
-            const J = v(B, O, N);
-            c !== J && (c = J, p(c.object)), q = d(L, B, O, j), q && M(L, B, O, j);
+        if (o) {
+            const Q = _(K, z, I);
+            c !== Q && (c = Q, h(c.object)), q = p(P, K, z, G), q && v(P, K, z, G);
         } else {
-            const J = N.wireframe === !0;
-            (c.geometry !== B.id || c.program !== O.id || c.wireframe !== J) && (c.geometry = B.id, c.program = O.id, c.wireframe = J, q = !0);
+            const Q = I.wireframe === !0;
+            (c.geometry !== K.id || c.program !== z.id || c.wireframe !== Q) && (c.geometry = K.id, c.program = z.id, c.wireframe = Q, q = !0);
         }
-        j !== null && t.update(j, i.ELEMENT_ARRAY_BUFFER), (q || u) && (u = !1, I(L, N, O, B), j !== null && i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t.get(j).buffer));
+        G !== null && t.update(G, s.ELEMENT_ARRAY_BUFFER), (q || u) && (u = !1, L(P, I, z, K), G !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, t.get(G).buffer));
     }
 
-    function h() {
-        return n.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES();
+    function f() {
+        return n.isWebGL2 ? s.createVertexArray() : r.createVertexArrayOES();
     }
 
-    function p(L) {
-        return n.isWebGL2 ? i.bindVertexArray(L) : s.bindVertexArrayOES(L);
+    function h(P) {
+        return n.isWebGL2 ? s.bindVertexArray(P) : r.bindVertexArrayOES(P);
     }
 
-    function g(L) {
-        return n.isWebGL2 ? i.deleteVertexArray(L) : s.deleteVertexArrayOES(L);
+    function g(P) {
+        return n.isWebGL2 ? s.deleteVertexArray(P) : r.deleteVertexArrayOES(P);
     }
 
-    function v(L, N, O) {
-        const B = O.wireframe === !0;
-        let j = o[L.id];
-        j === void 0 && (j = {}, o[L.id] = j);
-        let q = j[N.id];
-        q === void 0 && (q = {}, j[N.id] = q);
-        let J = q[B];
-        return J === void 0 && (J = m(h()), q[B] = J), J;
+    function _(P, I, z) {
+        const K = z.wireframe === !0;
+        let G = a[P.id];
+        G === void 0 && (G = {}, a[P.id] = G);
+        let q = G[I.id];
+        q === void 0 && (q = {}, G[I.id] = q);
+        let Q = q[K];
+        return Q === void 0 && (Q = m(f()), q[K] = Q), Q;
     }
 
-    function m(L) {
-        const N = [],
-            O = [],
-            B = [];
-        for (let j = 0; j < r; j++)
-            N[j] = 0, O[j] = 0, B[j] = 0;
+    function m(P) {
+        const I = [],
+            z = [],
+            K = [];
+        for (let G = 0; G < i; G++)
+            I[G] = 0, z[G] = 0, K[G] = 0;
         return {
             // for backward compatibility on non-VAO support browser
             geometry: null,
             program: null,
             wireframe: !1,
-            newAttributes: N,
-            enabledAttributes: O,
-            attributeDivisors: B,
-            object: L,
+            newAttributes: I,
+            enabledAttributes: z,
+            attributeDivisors: K,
+            object: P,
             attributes: {},
             index: null
         };
     }
 
-    function d(L, N, O, B) {
-        const j = c.attributes,
-            q = N.attributes;
-        let J = 0;
-        const ne = O.getAttributes();
-        for (const ue in ne)
-            if (ne[ue].location >= 0) {
-                const H = j[ue];
-                let ee = q[ue];
-                if (ee === void 0 && (ue === "instanceMatrix" && L.instanceMatrix && (ee = L.instanceMatrix), ue === "instanceColor" && L.instanceColor && (ee = L.instanceColor)), H === void 0 || H.attribute !== ee || ee && H.data !== ee.data)
+    function p(P, I, z, K) {
+        const G = c.attributes,
+            q = I.attributes;
+        let Q = 0;
+        const te = z.getAttributes();
+        for (const fe in te)
+            if (te[fe].location >= 0) {
+                const V = G[fe];
+                let J = q[fe];
+                if (J === void 0 && (fe === "instanceMatrix" && P.instanceMatrix && (J = P.instanceMatrix), fe === "instanceColor" && P.instanceColor && (J = P.instanceColor)), V === void 0 || V.attribute !== J || J && V.data !== J.data)
                     return !0;
-                J++;
+                Q++;
             }
-        return c.attributesNum !== J || c.index !== B;
+        return c.attributesNum !== Q || c.index !== K;
     }
 
-    function M(L, N, O, B) {
-        const j = {},
-            q = N.attributes;
-        let J = 0;
-        const ne = O.getAttributes();
-        for (const ue in ne)
-            if (ne[ue].location >= 0) {
-                let H = q[ue];
-                H === void 0 && (ue === "instanceMatrix" && L.instanceMatrix && (H = L.instanceMatrix), ue === "instanceColor" && L.instanceColor && (H = L.instanceColor));
-                const ee = {};
-                ee.attribute = H, H && H.data && (ee.data = H.data), j[ue] = ee, J++;
+    function v(P, I, z, K) {
+        const G = {},
+            q = I.attributes;
+        let Q = 0;
+        const te = z.getAttributes();
+        for (const fe in te)
+            if (te[fe].location >= 0) {
+                let V = q[fe];
+                V === void 0 && (fe === "instanceMatrix" && P.instanceMatrix && (V = P.instanceMatrix), fe === "instanceColor" && P.instanceColor && (V = P.instanceColor));
+                const J = {};
+                J.attribute = V, V && V.data && (J.data = V.data), G[fe] = J, Q++;
             }
-        c.attributes = j, c.attributesNum = J, c.index = B;
+        c.attributes = G, c.attributesNum = Q, c.index = K;
     }
 
-    function _() {
-        const L = c.newAttributes;
-        for (let N = 0, O = L.length; N < O; N++)
-            L[N] = 0;
+    function S() {
+        const P = c.newAttributes;
+        for (let I = 0, z = P.length; I < z; I++)
+            P[I] = 0;
     }
 
-    function A(L) {
-        R(L, 0);
+    function y(P) {
+        b(P, 0);
     }
 
-    function R(L, N) {
-        const O = c.newAttributes,
-            B = c.enabledAttributes,
-            j = c.attributeDivisors;
-        O[L] = 1, B[L] === 0 && (i.enableVertexAttribArray(L), B[L] = 1), j[L] !== N && ((n.isWebGL2 ? i : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](L, N), j[L] = N);
+    function b(P, I) {
+        const z = c.newAttributes,
+            K = c.enabledAttributes,
+            G = c.attributeDivisors;
+        z[P] = 1, K[P] === 0 && (s.enableVertexAttribArray(P), K[P] = 1), G[P] !== I && ((n.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](P, I), G[P] = I);
     }
 
     function E() {
-        const L = c.newAttributes,
-            N = c.enabledAttributes;
-        for (let O = 0, B = N.length; O < B; O++)
-            N[O] !== L[O] && (i.disableVertexAttribArray(O), N[O] = 0);
+        const P = c.newAttributes,
+            I = c.enabledAttributes;
+        for (let z = 0, K = I.length; z < K; z++)
+            I[z] !== P[z] && (s.disableVertexAttribArray(z), I[z] = 0);
     }
 
-    function b(L, N, O, B, j, q, J) {
-        J === !0 ? i.vertexAttribIPointer(L, N, O, j, q) : i.vertexAttribPointer(L, N, O, B, j, q);
+    function T(P, I, z, K, G, q, Q) {
+        Q === !0 ? s.vertexAttribIPointer(P, I, z, G, q) : s.vertexAttribPointer(P, I, z, K, G, q);
     }
 
-    function I(L, N, O, B) {
-        if (n.isWebGL2 === !1 && (L.isInstancedMesh || B.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
+    function L(P, I, z, K) {
+        if (n.isWebGL2 === !1 && (P.isInstancedMesh || K.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null)
             return;
-        _();
-        const j = B.attributes,
-            q = O.getAttributes(),
-            J = N.defaultAttributeValues;
-        for (const ne in q) {
-            const ue = q[ne];
-            if (ue.location >= 0) {
-                let Z = j[ne];
-                if (Z === void 0 && (ne === "instanceMatrix" && L.instanceMatrix && (Z = L.instanceMatrix), ne === "instanceColor" && L.instanceColor && (Z = L.instanceColor)), Z !== void 0) {
-                    const H = Z.normalized,
-                        ee = Z.itemSize,
-                        pe = t.get(Z);
-                    if (pe === void 0)
+        S();
+        const G = K.attributes,
+            q = z.getAttributes(),
+            Q = I.defaultAttributeValues;
+        for (const te in q) {
+            const fe = q[te];
+            if (fe.location >= 0) {
+                let ne = G[te];
+                if (ne === void 0 && (te === "instanceMatrix" && P.instanceMatrix && (ne = P.instanceMatrix), te === "instanceColor" && P.instanceColor && (ne = P.instanceColor)), ne !== void 0) {
+                    const V = ne.normalized,
+                        J = ne.itemSize,
+                        se = t.get(ne);
+                    if (se === void 0)
                         continue;
-                    const Te = pe.buffer,
-                        xe = pe.type,
-                        ge = pe.bytesPerElement,
-                        Ke = n.isWebGL2 === !0 && (xe === i.INT || xe === i.UNSIGNED_INT || Z.gpuType === zl);
-                    if (Z.isInterleavedBufferAttribute) {
-                        const we = Z.data,
-                            F = we.stride,
-                            lt = Z.offset;
-                        if (we.isInstancedInterleavedBuffer) {
-                            for (let Me = 0; Me < ue.locationSize; Me++)
-                                R(ue.location + Me, we.meshPerAttribute);
-                            L.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = we.meshPerAttribute * we.count);
+                    const Ae = se.buffer,
+                        xe = se.type,
+                        ge = se.bytesPerElement,
+                        Qe = n.isWebGL2 === !0 && (xe === s.INT || xe === s.UNSIGNED_INT || ne.gpuType === Fc);
+                    if (ne.isInterleavedBufferAttribute) {
+                        const Re = ne.data,
+                            O = Re.stride,
+                            Je = ne.offset;
+                        if (Re.isInstancedInterleavedBuffer) {
+                            for (let Te = 0; Te < fe.locationSize; Te++)
+                                b(fe.location + Te, Re.meshPerAttribute);
+                            P.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = Re.meshPerAttribute * Re.count);
                         } else
-                            for (let Me = 0; Me < ue.locationSize; Me++)
-                                A(ue.location + Me);
-                        i.bindBuffer(i.ARRAY_BUFFER, Te);
-                        for (let Me = 0; Me < ue.locationSize; Me++)
-                            b(
-                                ue.location + Me,
-                                ee / ue.locationSize,
+                            for (let Te = 0; Te < fe.locationSize; Te++)
+                                y(fe.location + Te);
+                        s.bindBuffer(s.ARRAY_BUFFER, Ae);
+                        for (let Te = 0; Te < fe.locationSize; Te++)
+                            T(
+                                fe.location + Te,
+                                J / fe.locationSize,
                                 xe,
-                                H,
-                                F * ge,
-                                (lt + ee / ue.locationSize * Me) * ge,
-                                Ke
+                                V,
+                                O * ge,
+                                (Je + J / fe.locationSize * Te) * ge,
+                                Qe
                             );
                     } else {
-                        if (Z.isInstancedBufferAttribute) {
-                            for (let we = 0; we < ue.locationSize; we++)
-                                R(ue.location + we, Z.meshPerAttribute);
-                            L.isInstancedMesh !== !0 && B._maxInstanceCount === void 0 && (B._maxInstanceCount = Z.meshPerAttribute * Z.count);
+                        if (ne.isInstancedBufferAttribute) {
+                            for (let Re = 0; Re < fe.locationSize; Re++)
+                                b(fe.location + Re, ne.meshPerAttribute);
+                            P.isInstancedMesh !== !0 && K._maxInstanceCount === void 0 && (K._maxInstanceCount = ne.meshPerAttribute * ne.count);
                         } else
-                            for (let we = 0; we < ue.locationSize; we++)
-                                A(ue.location + we);
-                        i.bindBuffer(i.ARRAY_BUFFER, Te);
-                        for (let we = 0; we < ue.locationSize; we++)
-                            b(
-                                ue.location + we,
-                                ee / ue.locationSize,
+                            for (let Re = 0; Re < fe.locationSize; Re++)
+                                y(fe.location + Re);
+                        s.bindBuffer(s.ARRAY_BUFFER, Ae);
+                        for (let Re = 0; Re < fe.locationSize; Re++)
+                            T(
+                                fe.location + Re,
+                                J / fe.locationSize,
                                 xe,
-                                H,
-                                ee * ge,
-                                ee / ue.locationSize * we * ge,
-                                Ke
+                                V,
+                                J * ge,
+                                J / fe.locationSize * Re * ge,
+                                Qe
                             );
                     }
-                } else if (J !== void 0) {
-                    const H = J[ne];
-                    if (H !== void 0)
-                        switch (H.length) {
+                } else if (Q !== void 0) {
+                    const V = Q[te];
+                    if (V !== void 0)
+                        switch (V.length) {
                             case 2:
-                                i.vertexAttrib2fv(ue.location, H);
+                                s.vertexAttrib2fv(fe.location, V);
                                 break;
                             case 3:
-                                i.vertexAttrib3fv(ue.location, H);
+                                s.vertexAttrib3fv(fe.location, V);
                                 break;
                             case 4:
-                                i.vertexAttrib4fv(ue.location, H);
+                                s.vertexAttrib4fv(fe.location, V);
                                 break;
                             default:
-                                i.vertexAttrib1fv(ue.location, H);
+                                s.vertexAttrib1fv(fe.location, V);
                         }
                 }
             }
         }
         E();
     }
 
-    function W() {
-        Y();
-        for (const L in o) {
-            const N = o[L];
-            for (const O in N) {
-                const B = N[O];
-                for (const j in B)
-                    g(B[j].object), delete B[j];
-                delete N[O];
+    function B() {
+        U();
+        for (const P in a) {
+            const I = a[P];
+            for (const z in I) {
+                const K = I[z];
+                for (const G in K)
+                    g(K[G].object), delete K[G];
+                delete I[z];
             }
-            delete o[L];
+            delete a[P];
         }
     }
 
-    function S(L) {
-        if (o[L.id] === void 0)
+    function x(P) {
+        if (a[P.id] === void 0)
             return;
-        const N = o[L.id];
-        for (const O in N) {
-            const B = N[O];
-            for (const j in B)
-                g(B[j].object), delete B[j];
-            delete N[O];
-        }
-        delete o[L.id];
+        const I = a[P.id];
+        for (const z in I) {
+            const K = I[z];
+            for (const G in K)
+                g(K[G].object), delete K[G];
+            delete I[z];
+        }
+        delete a[P.id];
     }
 
-    function T(L) {
-        for (const N in o) {
-            const O = o[N];
-            if (O[L.id] === void 0)
+    function A(P) {
+        for (const I in a) {
+            const z = a[I];
+            if (z[P.id] === void 0)
                 continue;
-            const B = O[L.id];
-            for (const j in B)
-                g(B[j].object), delete B[j];
-            delete O[L.id];
+            const K = z[P.id];
+            for (const G in K)
+                g(K[G].object), delete K[G];
+            delete z[P.id];
         }
     }
 
-    function Y() {
-        K(), u = !0, c !== l && (c = l, p(c.object));
+    function U() {
+        N(), u = !0, c !== l && (c = l, h(c.object));
     }
 
-    function K() {
+    function N() {
         l.geometry = null, l.program = null, l.wireframe = !1;
     }
     return {
-        setup: f,
-        reset: Y,
-        resetDefaultState: K,
-        dispose: W,
-        releaseStatesOfGeometry: S,
-        releaseStatesOfProgram: T,
-        initAttributes: _,
-        enableAttribute: A,
+        setup: d,
+        reset: U,
+        resetDefaultState: N,
+        dispose: B,
+        releaseStatesOfGeometry: x,
+        releaseStatesOfProgram: A,
+        initAttributes: S,
+        enableAttribute: y,
         disableUnusedAttributes: E
     };
 }
 
-function tm(i, e, t, n) {
-    const r = n.isWebGL2;
-    let s;
+function Qm(s, e, t, n) {
+    const i = n.isWebGL2;
+    let r;
 
-    function a(u) {
-        s = u;
+    function o(u) {
+        r = u;
     }
 
-    function o(u, f) {
-        i.drawArrays(s, u, f), t.update(f, s, 1);
+    function a(u, d) {
+        s.drawArrays(r, u, d), t.update(d, r, 1);
     }
 
-    function l(u, f, h) {
-        if (h === 0)
+    function l(u, d, f) {
+        if (f === 0)
             return;
-        let p, g;
-        if (r)
-            p = i, g = "drawArraysInstanced";
-        else if (p = e.get("ANGLE_instanced_arrays"), g = "drawArraysInstancedANGLE", p === null) {
+        let h, g;
+        if (i)
+            h = s, g = "drawArraysInstanced";
+        else if (h = e.get("ANGLE_instanced_arrays"), g = "drawArraysInstancedANGLE", h === null) {
             console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
             return;
         }
-        p[g](s, u, f, h), t.update(f, s, h);
+        h[g](r, u, d, f), t.update(d, r, f);
     }
 
-    function c(u, f, h) {
-        if (h === 0)
+    function c(u, d, f) {
+        if (f === 0)
             return;
-        const p = e.get("WEBGL_multi_draw");
-        if (p === null)
-            for (let g = 0; g < h; g++)
-                this.render(u[g], f[g]);
+        const h = e.get("WEBGL_multi_draw");
+        if (h === null)
+            for (let g = 0; g < f; g++)
+                this.render(u[g], d[g]);
         else {
-            p.multiDrawArraysWEBGL(s, u, 0, f, 0, h);
+            h.multiDrawArraysWEBGL(r, u, 0, d, 0, f);
             let g = 0;
-            for (let v = 0; v < h; v++)
-                g += f[v];
-            t.update(g, s, 1);
+            for (let _ = 0; _ < f; _++)
+                g += d[_];
+            t.update(g, r, 1);
         }
     }
-    this.setMode = a, this.render = o, this.renderInstances = l, this.renderMultiDraw = c;
+    this.setMode = o, this.render = a, this.renderInstances = l, this.renderMultiDraw = c;
 }
 
-function nm(i, e, t) {
+function Jm(s, e, t) {
     let n;
 
-    function r() {
+    function i() {
         if (n !== void 0)
             return n;
         if (e.has("EXT_texture_filter_anisotropic") === !0) {
-            const b = e.get("EXT_texture_filter_anisotropic");
-            n = i.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+            const T = e.get("EXT_texture_filter_anisotropic");
+            n = s.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
         } else
             n = 0;
         return n;
     }
 
-    function s(b) {
-        if (b === "highp") {
-            if (i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.HIGH_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.HIGH_FLOAT).precision > 0)
+    function r(T) {
+        if (T === "highp") {
+            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                 return "highp";
-            b = "mediump";
+            T = "mediump";
         }
-        return b === "mediump" && i.getShaderPrecisionFormat(i.VERTEX_SHADER, i.MEDIUM_FLOAT).precision > 0 && i.getShaderPrecisionFormat(i.FRAGMENT_SHADER, i.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
+        return T === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
     }
-    const a = typeof WebGL2RenderingContext < "u" && i.constructor.name === "WebGL2RenderingContext";
-    let o = t.precision !== void 0 ? t.precision : "highp";
-    const l = s(o);
-    l !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", l, "instead."), o = l);
-    const c = a || e.has("WEBGL_draw_buffers"),
+    const o = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
+    let a = t.precision !== void 0 ? t.precision : "highp";
+    const l = r(a);
+    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
+    const c = o || e.has("WEBGL_draw_buffers"),
         u = t.logarithmicDepthBuffer === !0,
-        f = i.getParameter(i.MAX_TEXTURE_IMAGE_UNITS),
-        h = i.getParameter(i.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
-        p = i.getParameter(i.MAX_TEXTURE_SIZE),
-        g = i.getParameter(i.MAX_CUBE_MAP_TEXTURE_SIZE),
-        v = i.getParameter(i.MAX_VERTEX_ATTRIBS),
-        m = i.getParameter(i.MAX_VERTEX_UNIFORM_VECTORS),
-        d = i.getParameter(i.MAX_VARYING_VECTORS),
-        M = i.getParameter(i.MAX_FRAGMENT_UNIFORM_VECTORS),
-        _ = h > 0,
-        A = a || e.has("OES_texture_float"),
-        R = _ && A,
-        E = a ? i.getParameter(i.MAX_SAMPLES) : 0;
+        d = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
+        f = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
+        h = s.getParameter(s.MAX_TEXTURE_SIZE),
+        g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
+        _ = s.getParameter(s.MAX_VERTEX_ATTRIBS),
+        m = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
+        p = s.getParameter(s.MAX_VARYING_VECTORS),
+        v = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
+        S = f > 0,
+        y = o || e.has("OES_texture_float"),
+        b = S && y,
+        E = o ? s.getParameter(s.MAX_SAMPLES) : 0;
     return {
-        isWebGL2: a,
+        isWebGL2: o,
         drawBuffers: c,
-        getMaxAnisotropy: r,
-        getMaxPrecision: s,
-        precision: o,
+        getMaxAnisotropy: i,
+        getMaxPrecision: r,
+        precision: a,
         logarithmicDepthBuffer: u,
-        maxTextures: f,
-        maxVertexTextures: h,
-        maxTextureSize: p,
+        maxTextures: d,
+        maxVertexTextures: f,
+        maxTextureSize: h,
         maxCubemapSize: g,
-        maxAttributes: v,
+        maxAttributes: _,
         maxVertexUniforms: m,
-        maxVaryings: d,
-        maxFragmentUniforms: M,
-        vertexTextures: _,
-        floatFragmentTextures: A,
-        floatVertexTextures: R,
+        maxVaryings: p,
+        maxFragmentUniforms: v,
+        vertexTextures: S,
+        floatFragmentTextures: y,
+        floatVertexTextures: b,
         maxSamples: E
     };
 }
 
-function im(i) {
+function $m(s) {
     const e = this;
     let t = null,
         n = 0,
-        r = !1,
-        s = !1;
-    const a = new Fn(),
-        o = new be(),
+        i = !1,
+        r = !1;
+    const o = new jn(),
+        a = new Ue(),
         l = {
             value: null,
             needsUpdate: !1
         };
-    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, h) {
-        const p = f.length !== 0 || h || // enable state of previous frame - the clipping code has to
+    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, f) {
+        const h = d.length !== 0 || f || // enable state of previous frame - the clipping code has to
             // run another frame in order to reset the state:
-            n !== 0 || r;
-        return r = h, n = f.length, p;
+            n !== 0 || i;
+        return i = f, n = d.length, h;
     }, this.beginShadows = function() {
-        s = !0, u(null);
+        r = !0, u(null);
     }, this.endShadows = function() {
-        s = !1;
-    }, this.setGlobalState = function(f, h) {
-        t = u(f, h, 0);
-    }, this.setState = function(f, h, p) {
-        const g = f.clippingPlanes,
-            v = f.clipIntersection,
-            m = f.clipShadows,
-            d = i.get(f);
-        if (!r || g === null || g.length === 0 || s && !m)
-            s ? u(null) : c();
+        r = !1;
+    }, this.setGlobalState = function(d, f) {
+        t = u(d, f, 0);
+    }, this.setState = function(d, f, h) {
+        const g = d.clippingPlanes,
+            _ = d.clipIntersection,
+            m = d.clipShadows,
+            p = s.get(d);
+        if (!i || g === null || g.length === 0 || r && !m)
+            r ? u(null) : c();
         else {
-            const M = s ? 0 : n,
-                _ = M * 4;
-            let A = d.clippingState || null;
-            l.value = A, A = u(g, h, _, p);
-            for (let R = 0; R !== _; ++R)
-                A[R] = t[R];
-            d.clippingState = A, this.numIntersection = v ? this.numPlanes : 0, this.numPlanes += M;
+            const v = r ? 0 : n,
+                S = v * 4;
+            let y = p.clippingState || null;
+            l.value = y, y = u(g, f, S, h);
+            for (let b = 0; b !== S; ++b)
+                y[b] = t[b];
+            p.clippingState = y, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += v;
         }
     };
 
     function c() {
         l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0;
     }
 
-    function u(f, h, p, g) {
-        const v = f !== null ? f.length : 0;
+    function u(d, f, h, g) {
+        const _ = d !== null ? d.length : 0;
         let m = null;
-        if (v !== 0) {
+        if (_ !== 0) {
             if (m = l.value, g !== !0 || m === null) {
-                const d = p + v * 4,
-                    M = h.matrixWorldInverse;
-                o.getNormalMatrix(M), (m === null || m.length < d) && (m = new Float32Array(d));
-                for (let _ = 0, A = p; _ !== v; ++_, A += 4)
-                    a.copy(f[_]).applyMatrix4(M, o), a.normal.toArray(m, A), m[A + 3] = a.constant;
+                const p = h + _ * 4,
+                    v = f.matrixWorldInverse;
+                a.getNormalMatrix(v), (m === null || m.length < p) && (m = new Float32Array(p));
+                for (let S = 0, y = h; S !== _; ++S, y += 4)
+                    o.copy(d[S]).applyMatrix4(v, a), o.normal.toArray(m, y), m[y + 3] = o.constant;
             }
             l.value = m, l.needsUpdate = !0;
         }
-        return e.numPlanes = v, e.numIntersection = 0, m;
+        return e.numPlanes = _, e.numIntersection = 0, m;
     }
 }
 
-function rm(i) {
+function eg(s) {
     let e = /* @__PURE__ */ new WeakMap();
 
-    function t(a, o) {
-        return o === $s ? a.mapping = zi : o === eo && (a.mapping = ki), a;
+    function t(o, a) {
+        return a === Fa ? o.mapping = os : a === Ia && (o.mapping = ls), o;
     }
 
-    function n(a) {
-        if (a && a.isTexture) {
-            const o = a.mapping;
-            if (o === $s || o === eo)
-                if (e.has(a)) {
-                    const l = e.get(a).texture;
-                    return t(l, a.mapping);
+    function n(o) {
+        if (o && o.isTexture) {
+            const a = o.mapping;
+            if (a === Fa || a === Ia)
+                if (e.has(o)) {
+                    const l = e.get(o).texture;
+                    return t(l, o.mapping);
                 } else {
-                    const l = a.image;
+                    const l = o.image;
                     if (l && l.height > 0) {
-                        const c = new ph(l.height);
-                        return c.fromEquirectangularTexture(i, a), e.set(a, c), a.addEventListener("dispose", r), t(c.texture, a.mapping);
+                        const c = new uh(l.height);
+                        return c.fromEquirectangularTexture(s, o), e.set(o, c), o.addEventListener("dispose", i), t(c.texture, o.mapping);
                     } else
                         return null;
                 }
         }
-        return a;
+        return o;
     }
 
-    function r(a) {
-        const o = a.target;
-        o.removeEventListener("dispose", r);
-        const l = e.get(o);
-        l !== void 0 && (e.delete(o), l.dispose());
+    function i(o) {
+        const a = o.target;
+        a.removeEventListener("dispose", i);
+        const l = e.get(a);
+        l !== void 0 && (e.delete(a), l.dispose());
     }
 
-    function s() {
+    function r() {
         e = /* @__PURE__ */ new WeakMap();
     }
     return {
         get: n,
-        dispose: s
+        dispose: r
     };
 }
-class oc extends nc {
-    constructor(e = -1, t = 1, n = 1, r = -1, s = 0.1, a = 2e3) {
-        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
+class eo extends Zc {
+    constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, o = 2e3) {
+        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = r, this.far = o, this.updateProjectionMatrix();
     }
     copy(e, t) {
         return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
     }
-    setViewOffset(e, t, n, r, s, a) {
+    setViewOffset(e, t, n, i, r, o) {
         this.view === null && (this.view = {
             enabled: !0,
             fullWidth: 1,
             fullHeight: 1,
             offsetX: 0,
             offsetY: 0,
             width: 1,
             height: 1
-        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
+        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = r, this.view.height = o, this.updateProjectionMatrix();
     }
     clearViewOffset() {
         this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
     }
     updateProjectionMatrix() {
         const e = (this.right - this.left) / (2 * this.zoom),
             t = (this.top - this.bottom) / (2 * this.zoom),
             n = (this.right + this.left) / 2,
-            r = (this.top + this.bottom) / 2;
-        let s = n - e,
-            a = n + e,
-            o = r + t,
-            l = r - t;
+            i = (this.top + this.bottom) / 2;
+        let r = n - e,
+            o = n + e,
+            a = i + t,
+            l = i - t;
         if (this.view !== null && this.view.enabled) {
             const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                 u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
-            s += c * this.view.offsetX, a = s + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height;
+            r += c * this.view.offsetX, o = r + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height;
         }
-        this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
+        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
     }
     toJSON(e) {
         const t = super.toJSON(e);
         return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
     }
 }
-const Ui = 4,
-    Ua = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
-    ti = 20,
-    Hs = /* @__PURE__ */ new oc(),
-    Fa = /* @__PURE__ */ new Qe();
-let Vs = null,
-    Ws = 0,
-    Xs = 0;
-const $n = (1 + Math.sqrt(5)) / 2,
-    Ci = 1 / $n,
-    Na = [
+const Qi = 4,
+    Ml = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
+    hi = 20,
+    Sa = /* @__PURE__ */ new eo(),
+    El = /* @__PURE__ */ new et();
+let va = null,
+    xa = 0,
+    ya = 0;
+const di = (1 + Math.sqrt(5)) / 2,
+    Vi = 1 / di,
+    Al = [
         /* @__PURE__ */
-        new P(1, 1, 1),
+        new D(1, 1, 1),
         /* @__PURE__ */
-        new P(-1, 1, 1),
+        new D(-1, 1, 1),
         /* @__PURE__ */
-        new P(1, 1, -1),
+        new D(1, 1, -1),
         /* @__PURE__ */
-        new P(-1, 1, -1),
+        new D(-1, 1, -1),
         /* @__PURE__ */
-        new P(0, $n, Ci),
+        new D(0, di, Vi),
         /* @__PURE__ */
-        new P(0, $n, -Ci),
+        new D(0, di, -Vi),
         /* @__PURE__ */
-        new P(Ci, 0, $n),
+        new D(Vi, 0, di),
         /* @__PURE__ */
-        new P(-Ci, 0, $n),
+        new D(-Vi, 0, di),
         /* @__PURE__ */
-        new P($n, Ci, 0),
+        new D(di, Vi, 0),
         /* @__PURE__ */
-        new P(-$n, Ci, 0)
+        new D(-di, Vi, 0)
     ];
-class Ba {
+class Tl {
     constructor(e) {
         this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
     }
     /**
      * Generates a PMREM from a supplied Scene, which can be faster than using an
      * image if networking bandwidth is low. Optional sigma specifies a blur radius
      * in radians to be applied to the scene before PMREM generation. Optional near
      * and far planes ensure the scene is rendered in its entirety (the cubeCamera
      * is placed at the origin).
      */
-    fromScene(e, t = 0, n = 0.1, r = 100) {
-        Vs = this._renderer.getRenderTarget(), Ws = this._renderer.getActiveCubeFace(), Xs = this._renderer.getActiveMipmapLevel(), this._setSize(256);
-        const s = this._allocateTargets();
-        return s.depthBuffer = !0, this._sceneToCubeUV(e, n, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
+    fromScene(e, t = 0, n = 0.1, i = 100) {
+        va = this._renderer.getRenderTarget(), xa = this._renderer.getActiveCubeFace(), ya = this._renderer.getActiveMipmapLevel(), this._setSize(256);
+        const r = this._allocateTargets();
+        return r.depthBuffer = !0, this._sceneToCubeUV(e, n, i, r), t > 0 && this._blur(r, 0, 0, t), this._applyPMREM(r), this._cleanup(r), r;
     }
     /**
      * Generates a PMREM from an equirectangular texture, which can be either LDR
      * or HDR. The ideal input image size is 1k (1024 x 512),
      * as this matches best with the 256 x 256 cubemap output.
      * The smallest supported equirectangular image size is 64 x 32.
      */
@@ -11745,22 +11773,22 @@
         return this._fromTexture(e, t);
     }
     /**
      * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
      * your texture's network fetch for increased concurrency.
      */
     compileCubemapShader() {
-        this._cubemapMaterial === null && (this._cubemapMaterial = ka(), this._compileMaterial(this._cubemapMaterial));
+        this._cubemapMaterial === null && (this._cubemapMaterial = wl(), this._compileMaterial(this._cubemapMaterial));
     }
     /**
      * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
      * your texture's network fetch for increased concurrency.
      */
     compileEquirectangularShader() {
-        this._equirectMaterial === null && (this._equirectMaterial = za(), this._compileMaterial(this._equirectMaterial));
+        this._equirectMaterial === null && (this._equirectMaterial = Cl(), this._compileMaterial(this._equirectMaterial));
     }
     /**
      * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
      * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
      * one of them will cause any others to also become unusable.
      */
     dispose() {
@@ -11772,240 +11800,240 @@
     }
     _dispose() {
         this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
         for (let e = 0; e < this._lodPlanes.length; e++)
             this._lodPlanes[e].dispose();
     }
     _cleanup(e) {
-        this._renderer.setRenderTarget(Vs, Ws, Xs), e.scissorTest = !1, Nr(e, 0, 0, e.width, e.height);
+        this._renderer.setRenderTarget(va, xa, ya), e.scissorTest = !1, rr(e, 0, 0, e.width, e.height);
     }
     _fromTexture(e, t) {
-        e.mapping === zi || e.mapping === ki ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Vs = this._renderer.getRenderTarget(), Ws = this._renderer.getActiveCubeFace(), Xs = this._renderer.getActiveMipmapLevel();
+        e.mapping === os || e.mapping === ls ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), va = this._renderer.getRenderTarget(), xa = this._renderer.getActiveCubeFace(), ya = this._renderer.getActiveMipmapLevel();
         const n = t || this._allocateTargets();
         return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
     }
     _allocateTargets() {
         const e = 3 * Math.max(this._cubeSize, 112),
             t = 4 * this._cubeSize,
             n = {
-                magFilter: Ct,
-                minFilter: Ct,
+                magFilter: Nt,
+                minFilter: Nt,
                 generateMipmaps: !1,
-                type: Gi,
-                format: Vt,
-                colorSpace: Wn,
+                type: xi,
+                format: kt,
+                colorSpace: ni,
                 depthBuffer: !1
             },
-            r = Oa(e, t, n);
+            i = bl(e, t, n);
         if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
-            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Oa(e, t, n);
+            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = bl(e, t, n);
             const {
-                _lodMax: s
+                _lodMax: r
             } = this;
             ({
                 sizeLods: this._sizeLods,
                 lodPlanes: this._lodPlanes,
                 sigmas: this._sigmas
-            } = sm(s)), this._blurMaterial = om(s, e, t);
+            } = tg(r)), this._blurMaterial = ng(r, e, t);
         }
-        return r;
+        return i;
     }
     _compileMaterial(e) {
-        const t = new at(this._lodPlanes[0], e);
-        this._renderer.compile(t, Hs);
+        const t = new pt(this._lodPlanes[0], e);
+        this._renderer.compile(t, Sa);
     }
-    _sceneToCubeUV(e, t, n, r) {
-        const o = new Ht(90, 1, t, n),
+    _sceneToCubeUV(e, t, n, i) {
+        const a = new $t(90, 1, t, n),
             l = [1, -1, 1, 1, 1, 1],
             c = [1, 1, 1, -1, -1, -1],
             u = this._renderer,
-            f = u.autoClear,
-            h = u.toneMapping;
-        u.getClearColor(Fa), u.toneMapping = kn, u.autoClear = !1;
-        const p = new oi({
+            d = u.autoClear,
+            f = u.toneMapping;
+        u.getClearColor(El), u.toneMapping = $n, u.autoClear = !1;
+        const h = new yi({
                 name: "PMREM.Background",
-                side: Pt,
+                side: zt,
                 depthWrite: !1,
                 depthTest: !1
             }),
-            g = new at(new Qi(), p);
-        let v = !1;
+            g = new pt(new gs(), h);
+        let _ = !1;
         const m = e.background;
-        m ? m.isColor && (p.color.copy(m), e.background = null, v = !0) : (p.color.copy(Fa), v = !0);
-        for (let d = 0; d < 6; d++) {
-            const M = d % 3;
-            M === 0 ? (o.up.set(0, l[d], 0), o.lookAt(c[d], 0, 0)) : M === 1 ? (o.up.set(0, 0, l[d]), o.lookAt(0, c[d], 0)) : (o.up.set(0, l[d], 0), o.lookAt(0, 0, c[d]));
-            const _ = this._cubeSize;
-            Nr(r, M * _, d > 2 ? _ : 0, _, _), u.setRenderTarget(r), v && u.render(g, o), u.render(e, o);
+        m ? m.isColor && (h.color.copy(m), e.background = null, _ = !0) : (h.color.copy(El), _ = !0);
+        for (let p = 0; p < 6; p++) {
+            const v = p % 3;
+            v === 0 ? (a.up.set(0, l[p], 0), a.lookAt(c[p], 0, 0)) : v === 1 ? (a.up.set(0, 0, l[p]), a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0), a.lookAt(0, 0, c[p]));
+            const S = this._cubeSize;
+            rr(i, v * S, p > 2 ? S : 0, S, S), u.setRenderTarget(i), _ && u.render(g, a), u.render(e, a);
         }
-        g.geometry.dispose(), g.material.dispose(), u.toneMapping = h, u.autoClear = f, e.background = m;
+        g.geometry.dispose(), g.material.dispose(), u.toneMapping = f, u.autoClear = d, e.background = m;
     }
     _textureToCubeUV(e, t) {
         const n = this._renderer,
-            r = e.mapping === zi || e.mapping === ki;
-        r ? (this._cubemapMaterial === null && (this._cubemapMaterial = ka()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = za());
-        const s = r ? this._cubemapMaterial : this._equirectMaterial,
-            a = new at(this._lodPlanes[0], s),
-            o = s.uniforms;
-        o.envMap.value = e;
+            i = e.mapping === os || e.mapping === ls;
+        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = wl()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Cl());
+        const r = i ? this._cubemapMaterial : this._equirectMaterial,
+            o = new pt(this._lodPlanes[0], r),
+            a = r.uniforms;
+        a.envMap.value = e;
         const l = this._cubeSize;
-        Nr(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Hs);
+        rr(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, Sa);
     }
     _applyPMREM(e) {
         const t = this._renderer,
             n = t.autoClear;
         t.autoClear = !1;
-        for (let r = 1; r < this._lodPlanes.length; r++) {
-            const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
-                a = Na[(r - 1) % Na.length];
-            this._blur(e, r - 1, r, s, a);
+        for (let i = 1; i < this._lodPlanes.length; i++) {
+            const r = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]),
+                o = Al[(i - 1) % Al.length];
+            this._blur(e, i - 1, i, r, o);
         }
         t.autoClear = n;
     }
     /**
      * This is a two-pass Gaussian blur for a cubemap. Normally this is done
      * vertically and horizontally, but this breaks down on a cube. Here we apply
      * the blur latitudinally (around the poles), and then longitudinally (towards
      * the poles) to approximate the orthogonally-separable blur. It is least
      * accurate at the poles, but still does a decent job.
      */
-    _blur(e, t, n, r, s) {
-        const a = this._pingPongRenderTarget;
+    _blur(e, t, n, i, r) {
+        const o = this._pingPongRenderTarget;
         this._halfBlur(
             e,
-            a,
+            o,
             t,
             n,
-            r,
+            i,
             "latitudinal",
-            s
+            r
         ), this._halfBlur(
-            a,
+            o,
             e,
             n,
             n,
-            r,
+            i,
             "longitudinal",
-            s
+            r
         );
     }
-    _halfBlur(e, t, n, r, s, a, o) {
+    _halfBlur(e, t, n, i, r, o, a) {
         const l = this._renderer,
             c = this._blurMaterial;
-        a !== "latitudinal" && a !== "longitudinal" && console.error(
+        o !== "latitudinal" && o !== "longitudinal" && console.error(
             "blur direction must be either latitudinal or longitudinal!"
         );
         const u = 3,
-            f = new at(this._lodPlanes[r], c),
-            h = c.uniforms,
-            p = this._sizeLods[n] - 1,
-            g = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * ti - 1),
-            v = s / g,
-            m = isFinite(s) ? 1 + Math.floor(u * v) : ti;
-        m > ti && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${ti}`);
-        const d = [];
-        let M = 0;
-        for (let b = 0; b < ti; ++b) {
-            const I = b / v,
-                W = Math.exp(-I * I / 2);
-            d.push(W), b === 0 ? M += W : b < m && (M += 2 * W);
-        }
-        for (let b = 0; b < d.length; b++)
-            d[b] = d[b] / M;
-        h.envMap.value = e.texture, h.samples.value = m, h.weights.value = d, h.latitudinal.value = a === "latitudinal", o && (h.poleAxis.value = o);
+            d = new pt(this._lodPlanes[i], c),
+            f = c.uniforms,
+            h = this._sizeLods[n] - 1,
+            g = isFinite(r) ? Math.PI / (2 * h) : 2 * Math.PI / (2 * hi - 1),
+            _ = r / g,
+            m = isFinite(r) ? 1 + Math.floor(u * _) : hi;
+        m > hi && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${hi}`);
+        const p = [];
+        let v = 0;
+        for (let T = 0; T < hi; ++T) {
+            const L = T / _,
+                B = Math.exp(-L * L / 2);
+            p.push(B), T === 0 ? v += B : T < m && (v += 2 * B);
+        }
+        for (let T = 0; T < p.length; T++)
+            p[T] = p[T] / v;
+        f.envMap.value = e.texture, f.samples.value = m, f.weights.value = p, f.latitudinal.value = o === "latitudinal", a && (f.poleAxis.value = a);
         const {
-            _lodMax: _
+            _lodMax: S
         } = this;
-        h.dTheta.value = g, h.mipInt.value = _ - n;
-        const A = this._sizeLods[r],
-            R = 3 * A * (r > _ - Ui ? r - _ + Ui : 0),
-            E = 4 * (this._cubeSize - A);
-        Nr(t, R, E, 3 * A, 2 * A), l.setRenderTarget(t), l.render(f, Hs);
+        f.dTheta.value = g, f.mipInt.value = S - n;
+        const y = this._sizeLods[i],
+            b = 3 * y * (i > S - Qi ? i - S + Qi : 0),
+            E = 4 * (this._cubeSize - y);
+        rr(t, b, E, 3 * y, 2 * y), l.setRenderTarget(t), l.render(d, Sa);
     }
 }
 
-function sm(i) {
+function tg(s) {
     const e = [],
         t = [],
         n = [];
-    let r = i;
-    const s = i - Ui + 1 + Ua.length;
-    for (let a = 0; a < s; a++) {
-        const o = Math.pow(2, r);
-        t.push(o);
-        let l = 1 / o;
-        a > i - Ui ? l = Ua[a - i + Ui - 1] : a === 0 && (l = 0), n.push(l);
-        const c = 1 / (o - 2),
+    let i = s;
+    const r = s - Qi + 1 + Ml.length;
+    for (let o = 0; o < r; o++) {
+        const a = Math.pow(2, i);
+        t.push(a);
+        let l = 1 / a;
+        o > s - Qi ? l = Ml[o - s + Qi - 1] : o === 0 && (l = 0), n.push(l);
+        const c = 1 / (a - 2),
             u = -c,
-            f = 1 + c,
-            h = [u, u, f, u, f, f, u, u, f, f, u, f],
-            p = 6,
+            d = 1 + c,
+            f = [u, u, d, u, d, d, u, u, d, d, u, d],
+            h = 6,
             g = 6,
-            v = 3,
+            _ = 3,
             m = 2,
-            d = 1,
-            M = new Float32Array(v * g * p),
-            _ = new Float32Array(m * g * p),
-            A = new Float32Array(d * g * p);
-        for (let E = 0; E < p; E++) {
-            const b = E % 3 * 2 / 3 - 1,
-                I = E > 2 ? 0 : -1,
-                W = [
-                    b,
-                    I,
+            p = 1,
+            v = new Float32Array(_ * g * h),
+            S = new Float32Array(m * g * h),
+            y = new Float32Array(p * g * h);
+        for (let E = 0; E < h; E++) {
+            const T = E % 3 * 2 / 3 - 1,
+                L = E > 2 ? 0 : -1,
+                B = [
+                    T,
+                    L,
                     0,
-                    b + 2 / 3,
-                    I,
+                    T + 2 / 3,
+                    L,
                     0,
-                    b + 2 / 3,
-                    I + 1,
+                    T + 2 / 3,
+                    L + 1,
                     0,
-                    b,
-                    I,
+                    T,
+                    L,
                     0,
-                    b + 2 / 3,
-                    I + 1,
+                    T + 2 / 3,
+                    L + 1,
                     0,
-                    b,
-                    I + 1,
+                    T,
+                    L + 1,
                     0
                 ];
-            M.set(W, v * g * E), _.set(h, m * g * E);
-            const S = [E, E, E, E, E, E];
-            A.set(S, d * g * E);
+            v.set(B, _ * g * E), S.set(f, m * g * E);
+            const x = [E, E, E, E, E, E];
+            y.set(x, p * g * E);
         }
-        const R = new Yt();
-        R.setAttribute("position", new Wt(M, v)), R.setAttribute("uv", new Wt(_, m)), R.setAttribute("faceIndex", new Wt(A, d)), e.push(R), r > Ui && r--;
+        const b = new sn();
+        b.setAttribute("position", new en(v, _)), b.setAttribute("uv", new en(S, m)), b.setAttribute("faceIndex", new en(y, p)), e.push(b), i > Qi && i--;
     }
     return {
         lodPlanes: e,
         sizeLods: t,
         sigmas: n
     };
 }
 
-function Oa(i, e, t) {
-    const n = new Vn(i, e, t);
-    return n.texture.mapping = ss, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
+function bl(s, e, t) {
+    const n = new ti(s, e, t);
+    return n.texture.mapping = Fr, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n;
 }
 
-function Nr(i, e, t, n, r) {
-    i.viewport.set(e, t, n, r), i.scissor.set(e, t, n, r);
+function rr(s, e, t, n, i) {
+    s.viewport.set(e, t, n, i), s.scissor.set(e, t, n, i);
 }
 
-function om(i, e, t) {
-    const n = new Float32Array(ti),
-        r = new P(0, 1, 0);
-    return new Xt({
+function ng(s, e, t) {
+    const n = new Float32Array(hi),
+        i = new D(0, 1, 0);
+    return new tn({
         name: "SphericalGaussianBlur",
         defines: {
-            n: ti,
+            n: hi,
             CUBEUV_TEXEL_WIDTH: 1 / e,
             CUBEUV_TEXEL_HEIGHT: 1 / t,
-            CUBEUV_MAX_MIP: `${i}.0`
+            CUBEUV_MAX_MIP: `${s}.0`
         },
         uniforms: {
             envMap: {
                 value: null
             },
             samples: {
                 value: 1
@@ -12019,18 +12047,18 @@
             dTheta: {
                 value: 0
             },
             mipInt: {
                 value: 0
             },
             poleAxis: {
-                value: r
+                value: i
             }
         },
-        vertexShader: vo(),
+        vertexShader: to(),
         fragmentShader: (
             /* glsl */
             `
 
 			precision mediump float;
 			precision mediump int;
 
@@ -12087,29 +12115,29 @@
 					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );
 
 				}
 
 			}
 		`
         ),
-        blending: zn,
+        blending: Jn,
         depthTest: !1,
         depthWrite: !1
     });
 }
 
-function za() {
-    return new Xt({
+function Cl() {
+    return new tn({
         name: "EquirectangularToCubeUV",
         uniforms: {
             envMap: {
                 value: null
             }
         },
-        vertexShader: vo(),
+        vertexShader: to(),
         fragmentShader: (
             /* glsl */
             `
 
 			precision mediump float;
 			precision mediump int;
 
@@ -12125,32 +12153,32 @@
 				vec2 uv = equirectUv( outputDirection );
 
 				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );
 
 			}
 		`
         ),
-        blending: zn,
+        blending: Jn,
         depthTest: !1,
         depthWrite: !1
     });
 }
 
-function ka() {
-    return new Xt({
+function wl() {
+    return new tn({
         name: "CubemapToCubeUV",
         uniforms: {
             envMap: {
                 value: null
             },
             flipEnvMap: {
                 value: -1
             }
         },
-        vertexShader: vo(),
+        vertexShader: to(),
         fragmentShader: (
             /* glsl */
             `
 
 			precision mediump float;
 			precision mediump int;
 
@@ -12163,21 +12191,21 @@
 			void main() {
 
 				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );
 
 			}
 		`
         ),
-        blending: zn,
+        blending: Jn,
         depthTest: !1,
         depthWrite: !1
     });
 }
 
-function vo() {
+function to() {
     return (
         /* glsl */
         `
 
 		precision mediump float;
 		precision mediump int;
 
@@ -12231,1270 +12259,1270 @@
 			gl_Position = vec4( position, 1.0 );
 
 		}
 	`
     );
 }
 
-function am(i) {
+function ig(s) {
     let e = /* @__PURE__ */ new WeakMap(),
         t = null;
 
-    function n(o) {
-        if (o && o.isTexture) {
-            const l = o.mapping,
-                c = l === $s || l === eo,
-                u = l === zi || l === ki;
+    function n(a) {
+        if (a && a.isTexture) {
+            const l = a.mapping,
+                c = l === Fa || l === Ia,
+                u = l === os || l === ls;
             if (c || u)
-                if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
-                    o.needsPMREMUpdate = !1;
-                    let f = e.get(o);
-                    return t === null && (t = new Ba(i)), f = c ? t.fromEquirectangular(o, f) : t.fromCubemap(o, f), e.set(o, f), f.texture;
+                if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
+                    a.needsPMREMUpdate = !1;
+                    let d = e.get(a);
+                    return t === null && (t = new Tl(s)), d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture;
                 } else {
-                    if (e.has(o))
-                        return e.get(o).texture;
+                    if (e.has(a))
+                        return e.get(a).texture;
                     {
-                        const f = o.image;
-                        if (c && f && f.height > 0 || u && f && r(f)) {
-                            t === null && (t = new Ba(i));
-                            const h = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
-                            return e.set(o, h), o.addEventListener("dispose", s), h.texture;
+                        const d = a.image;
+                        if (c && d && d.height > 0 || u && d && i(d)) {
+                            t === null && (t = new Tl(s));
+                            const f = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
+                            return e.set(a, f), a.addEventListener("dispose", r), f.texture;
                         } else
                             return null;
                     }
                 }
         }
-        return o;
+        return a;
     }
 
-    function r(o) {
+    function i(a) {
         let l = 0;
         const c = 6;
         for (let u = 0; u < c; u++)
-            o[u] !== void 0 && l++;
+            a[u] !== void 0 && l++;
         return l === c;
     }
 
-    function s(o) {
-        const l = o.target;
-        l.removeEventListener("dispose", s);
+    function r(a) {
+        const l = a.target;
+        l.removeEventListener("dispose", r);
         const c = e.get(l);
         c !== void 0 && (e.delete(l), c.dispose());
     }
 
-    function a() {
+    function o() {
         e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
     }
     return {
         get: n,
-        dispose: a
+        dispose: o
     };
 }
 
-function lm(i) {
+function sg(s) {
     const e = {};
 
     function t(n) {
         if (e[n] !== void 0)
             return e[n];
-        let r;
+        let i;
         switch (n) {
             case "WEBGL_depth_texture":
-                r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
+                i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
                 break;
             case "EXT_texture_filter_anisotropic":
-                r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
+                i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                 break;
             case "WEBGL_compressed_texture_s3tc":
-                r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
+                i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                 break;
             case "WEBGL_compressed_texture_pvrtc":
-                r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
+                i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                 break;
             default:
-                r = i.getExtension(n);
+                i = s.getExtension(n);
         }
-        return e[n] = r, r;
+        return e[n] = i, i;
     }
     return {
         has: function(n) {
             return t(n) !== null;
         },
         init: function(n) {
             n.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
         },
         get: function(n) {
-            const r = t(n);
-            return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r;
+            const i = t(n);
+            return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
         }
     };
 }
 
-function cm(i, e, t, n) {
-    const r = {},
-        s = /* @__PURE__ */ new WeakMap();
+function rg(s, e, t, n) {
+    const i = {},
+        r = /* @__PURE__ */ new WeakMap();
 
-    function a(f) {
-        const h = f.target;
-        h.index !== null && e.remove(h.index);
-        for (const g in h.attributes)
-            e.remove(h.attributes[g]);
-        for (const g in h.morphAttributes) {
-            const v = h.morphAttributes[g];
-            for (let m = 0, d = v.length; m < d; m++)
-                e.remove(v[m]);
-        }
-        h.removeEventListener("dispose", a), delete r[h.id];
-        const p = s.get(h);
-        p && (e.remove(p), s.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount, t.memory.geometries--;
-    }
-
-    function o(f, h) {
-        return r[h.id] === !0 || (h.addEventListener("dispose", a), r[h.id] = !0, t.memory.geometries++), h;
-    }
-
-    function l(f) {
-        const h = f.attributes;
-        for (const g in h)
-            e.update(h[g], i.ARRAY_BUFFER);
-        const p = f.morphAttributes;
-        for (const g in p) {
-            const v = p[g];
-            for (let m = 0, d = v.length; m < d; m++)
-                e.update(v[m], i.ARRAY_BUFFER);
+    function o(d) {
+        const f = d.target;
+        f.index !== null && e.remove(f.index);
+        for (const g in f.attributes)
+            e.remove(f.attributes[g]);
+        for (const g in f.morphAttributes) {
+            const _ = f.morphAttributes[g];
+            for (let m = 0, p = _.length; m < p; m++)
+                e.remove(_[m]);
+        }
+        f.removeEventListener("dispose", o), delete i[f.id];
+        const h = r.get(f);
+        h && (e.remove(h), r.delete(f)), n.releaseStatesOfGeometry(f), f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount, t.memory.geometries--;
+    }
+
+    function a(d, f) {
+        return i[f.id] === !0 || (f.addEventListener("dispose", o), i[f.id] = !0, t.memory.geometries++), f;
+    }
+
+    function l(d) {
+        const f = d.attributes;
+        for (const g in f)
+            e.update(f[g], s.ARRAY_BUFFER);
+        const h = d.morphAttributes;
+        for (const g in h) {
+            const _ = h[g];
+            for (let m = 0, p = _.length; m < p; m++)
+                e.update(_[m], s.ARRAY_BUFFER);
         }
     }
 
-    function c(f) {
-        const h = [],
-            p = f.index,
-            g = f.attributes.position;
-        let v = 0;
-        if (p !== null) {
-            const M = p.array;
-            v = p.version;
-            for (let _ = 0, A = M.length; _ < A; _ += 3) {
-                const R = M[_ + 0],
-                    E = M[_ + 1],
-                    b = M[_ + 2];
-                h.push(R, E, E, b, b, R);
+    function c(d) {
+        const f = [],
+            h = d.index,
+            g = d.attributes.position;
+        let _ = 0;
+        if (h !== null) {
+            const v = h.array;
+            _ = h.version;
+            for (let S = 0, y = v.length; S < y; S += 3) {
+                const b = v[S + 0],
+                    E = v[S + 1],
+                    T = v[S + 2];
+                f.push(b, E, E, T, T, b);
             }
         } else if (g !== void 0) {
-            const M = g.array;
-            v = g.version;
-            for (let _ = 0, A = M.length / 3 - 1; _ < A; _ += 3) {
-                const R = _ + 0,
-                    E = _ + 1,
-                    b = _ + 2;
-                h.push(R, E, E, b, b, R);
+            const v = g.array;
+            _ = g.version;
+            for (let S = 0, y = v.length / 3 - 1; S < y; S += 3) {
+                const b = S + 0,
+                    E = S + 1,
+                    T = S + 2;
+                f.push(b, E, E, T, T, b);
             }
         } else
             return;
-        const m = new(ql(h) ? ec : $l)(h, 1);
-        m.version = v;
-        const d = s.get(f);
-        d && e.remove(d), s.set(f, m);
+        const m = new(zc(f) ? jc : Yc)(f, 1);
+        m.version = _;
+        const p = r.get(d);
+        p && e.remove(p), r.set(d, m);
     }
 
-    function u(f) {
-        const h = s.get(f);
-        if (h) {
-            const p = f.index;
-            p !== null && h.version < p.version && c(f);
+    function u(d) {
+        const f = r.get(d);
+        if (f) {
+            const h = d.index;
+            h !== null && f.version < h.version && c(d);
         } else
-            c(f);
-        return s.get(f);
+            c(d);
+        return r.get(d);
     }
     return {
-        get: o,
+        get: a,
         update: l,
         getWireframeAttribute: u
     };
 }
 
-function um(i, e, t, n) {
-    const r = n.isWebGL2;
-    let s;
+function ag(s, e, t, n) {
+    const i = n.isWebGL2;
+    let r;
 
-    function a(p) {
-        s = p;
+    function o(h) {
+        r = h;
     }
-    let o, l;
+    let a, l;
 
-    function c(p) {
-        o = p.type, l = p.bytesPerElement;
+    function c(h) {
+        a = h.type, l = h.bytesPerElement;
     }
 
-    function u(p, g) {
-        i.drawElements(s, g, o, p * l), t.update(g, s, 1);
+    function u(h, g) {
+        s.drawElements(r, g, a, h * l), t.update(g, r, 1);
     }
 
-    function f(p, g, v) {
-        if (v === 0)
+    function d(h, g, _) {
+        if (_ === 0)
             return;
-        let m, d;
-        if (r)
-            m = i, d = "drawElementsInstanced";
-        else if (m = e.get("ANGLE_instanced_arrays"), d = "drawElementsInstancedANGLE", m === null) {
+        let m, p;
+        if (i)
+            m = s, p = "drawElementsInstanced";
+        else if (m = e.get("ANGLE_instanced_arrays"), p = "drawElementsInstancedANGLE", m === null) {
             console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
             return;
         }
-        m[d](s, g, o, p * l, v), t.update(g, s, v);
+        m[p](r, g, a, h * l, _), t.update(g, r, _);
     }
 
-    function h(p, g, v) {
-        if (v === 0)
+    function f(h, g, _) {
+        if (_ === 0)
             return;
         const m = e.get("WEBGL_multi_draw");
         if (m === null)
-            for (let d = 0; d < v; d++)
-                this.render(p[d] / l, g[d]);
+            for (let p = 0; p < _; p++)
+                this.render(h[p] / l, g[p]);
         else {
-            m.multiDrawElementsWEBGL(s, g, 0, o, p, 0, v);
-            let d = 0;
-            for (let M = 0; M < v; M++)
-                d += g[M];
-            t.update(d, s, 1);
+            m.multiDrawElementsWEBGL(r, g, 0, a, h, 0, _);
+            let p = 0;
+            for (let v = 0; v < _; v++)
+                p += g[v];
+            t.update(p, r, 1);
         }
     }
-    this.setMode = a, this.setIndex = c, this.render = u, this.renderInstances = f, this.renderMultiDraw = h;
+    this.setMode = o, this.setIndex = c, this.render = u, this.renderInstances = d, this.renderMultiDraw = f;
 }
 
-function fm(i) {
+function og(s) {
     const e = {
             geometries: 0,
             textures: 0
         },
         t = {
             frame: 0,
             calls: 0,
             triangles: 0,
             points: 0,
             lines: 0
         };
 
-    function n(s, a, o) {
-        switch (t.calls++, a) {
-            case i.TRIANGLES:
-                t.triangles += o * (s / 3);
+    function n(r, o, a) {
+        switch (t.calls++, o) {
+            case s.TRIANGLES:
+                t.triangles += a * (r / 3);
                 break;
-            case i.LINES:
-                t.lines += o * (s / 2);
+            case s.LINES:
+                t.lines += a * (r / 2);
                 break;
-            case i.LINE_STRIP:
-                t.lines += o * (s - 1);
+            case s.LINE_STRIP:
+                t.lines += a * (r - 1);
                 break;
-            case i.LINE_LOOP:
-                t.lines += o * s;
+            case s.LINE_LOOP:
+                t.lines += a * r;
                 break;
-            case i.POINTS:
-                t.points += o * s;
+            case s.POINTS:
+                t.points += a * r;
                 break;
             default:
-                console.error("THREE.WebGLInfo: Unknown draw mode:", a);
+                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                 break;
         }
     }
 
-    function r() {
+    function i() {
         t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
     }
     return {
         memory: e,
         render: t,
         programs: null,
         autoReset: !0,
-        reset: r,
+        reset: i,
         update: n
     };
 }
 
-function hm(i, e) {
-    return i[0] - e[0];
+function lg(s, e) {
+    return s[0] - e[0];
 }
 
-function dm(i, e) {
-    return Math.abs(e[1]) - Math.abs(i[1]);
+function cg(s, e) {
+    return Math.abs(e[1]) - Math.abs(s[1]);
 }
 
-function pm(i, e, t) {
+function ug(s, e, t) {
     const n = {},
-        r = new Float32Array(8),
-        s = /* @__PURE__ */ new WeakMap(),
-        a = new ut(),
-        o = [];
+        i = new Float32Array(8),
+        r = /* @__PURE__ */ new WeakMap(),
+        o = new _t(),
+        a = [];
     for (let c = 0; c < 8; c++)
-        o[c] = [c, 0];
+        a[c] = [c, 0];
 
-    function l(c, u, f) {
-        const h = c.morphTargetInfluences;
+    function l(c, u, d) {
+        const f = c.morphTargetInfluences;
         if (e.isWebGL2 === !0) {
-            const p = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
-                g = p !== void 0 ? p.length : 0;
-            let v = s.get(u);
-            if (v === void 0 || v.count !== g) {
-                let Y = function() {
-                    S.dispose(), s.delete(u), u.removeEventListener("dispose", Y);
+            const h = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
+                g = h !== void 0 ? h.length : 0;
+            let _ = r.get(u);
+            if (_ === void 0 || _.count !== g) {
+                let U = function() {
+                    x.dispose(), r.delete(u), u.removeEventListener("dispose", U);
                 };
-                v !== void 0 && v.texture.dispose();
+                _ !== void 0 && _.texture.dispose();
                 const m = u.morphAttributes.position !== void 0,
-                    d = u.morphAttributes.normal !== void 0,
-                    M = u.morphAttributes.color !== void 0,
-                    _ = u.morphAttributes.position || [],
-                    A = u.morphAttributes.normal || [],
-                    R = u.morphAttributes.color || [];
+                    p = u.morphAttributes.normal !== void 0,
+                    v = u.morphAttributes.color !== void 0,
+                    S = u.morphAttributes.position || [],
+                    y = u.morphAttributes.normal || [],
+                    b = u.morphAttributes.color || [];
                 let E = 0;
-                m === !0 && (E = 1), d === !0 && (E = 2), M === !0 && (E = 3);
-                let b = u.attributes.position.count * E,
-                    I = 1;
-                b > e.maxTextureSize && (I = Math.ceil(b / e.maxTextureSize), b = e.maxTextureSize);
-                const W = new Float32Array(b * I * 4 * g),
-                    S = new Kl(W, b, I, g);
-                S.type = an, S.needsUpdate = !0;
-                const T = E * 4;
-                for (let K = 0; K < g; K++) {
-                    const L = _[K],
-                        N = A[K],
-                        O = R[K],
-                        B = b * I * 4 * K;
-                    for (let j = 0; j < L.count; j++) {
-                        const q = j * T;
-                        m === !0 && (a.fromBufferAttribute(L, j), W[B + q + 0] = a.x, W[B + q + 1] = a.y, W[B + q + 2] = a.z, W[B + q + 3] = 0), d === !0 && (a.fromBufferAttribute(N, j), W[B + q + 4] = a.x, W[B + q + 5] = a.y, W[B + q + 6] = a.z, W[B + q + 7] = 0), M === !0 && (a.fromBufferAttribute(O, j), W[B + q + 8] = a.x, W[B + q + 9] = a.y, W[B + q + 10] = a.z, W[B + q + 11] = O.itemSize === 4 ? a.w : 1);
+                m === !0 && (E = 1), p === !0 && (E = 2), v === !0 && (E = 3);
+                let T = u.attributes.position.count * E,
+                    L = 1;
+                T > e.maxTextureSize && (L = Math.ceil(T / e.maxTextureSize), T = e.maxTextureSize);
+                const B = new Float32Array(T * L * 4 * g),
+                    x = new Vc(B, T, L, g);
+                x.type = gn, x.needsUpdate = !0;
+                const A = E * 4;
+                for (let N = 0; N < g; N++) {
+                    const P = S[N],
+                        I = y[N],
+                        z = b[N],
+                        K = T * L * 4 * N;
+                    for (let G = 0; G < P.count; G++) {
+                        const q = G * A;
+                        m === !0 && (o.fromBufferAttribute(P, G), B[K + q + 0] = o.x, B[K + q + 1] = o.y, B[K + q + 2] = o.z, B[K + q + 3] = 0), p === !0 && (o.fromBufferAttribute(I, G), B[K + q + 4] = o.x, B[K + q + 5] = o.y, B[K + q + 6] = o.z, B[K + q + 7] = 0), v === !0 && (o.fromBufferAttribute(z, G), B[K + q + 8] = o.x, B[K + q + 9] = o.y, B[K + q + 10] = o.z, B[K + q + 11] = z.itemSize === 4 ? o.w : 1);
                     }
                 }
-                v = {
+                _ = {
                     count: g,
-                    texture: S,
-                    size: new me(b, I)
-                }, s.set(u, v), u.addEventListener("dispose", Y);
+                    texture: x,
+                    size: new Ee(T, L)
+                }, r.set(u, _), u.addEventListener("dispose", U);
             }
             if (c.isInstancedMesh === !0 && c.morphTexture !== null)
-                f.getUniforms().setValue(i, "morphTexture", c.morphTexture, t);
+                d.getUniforms().setValue(s, "morphTexture", c.morphTexture, t);
             else {
                 let m = 0;
-                for (let M = 0; M < h.length; M++)
-                    m += h[M];
-                const d = u.morphTargetsRelative ? 1 : 1 - m;
-                f.getUniforms().setValue(i, "morphTargetBaseInfluence", d), f.getUniforms().setValue(i, "morphTargetInfluences", h);
+                for (let v = 0; v < f.length; v++)
+                    m += f[v];
+                const p = u.morphTargetsRelative ? 1 : 1 - m;
+                d.getUniforms().setValue(s, "morphTargetBaseInfluence", p), d.getUniforms().setValue(s, "morphTargetInfluences", f);
             }
-            f.getUniforms().setValue(i, "morphTargetsTexture", v.texture, t), f.getUniforms().setValue(i, "morphTargetsTextureSize", v.size);
+            d.getUniforms().setValue(s, "morphTargetsTexture", _.texture, t), d.getUniforms().setValue(s, "morphTargetsTextureSize", _.size);
         } else {
-            const p = h === void 0 ? 0 : h.length;
+            const h = f === void 0 ? 0 : f.length;
             let g = n[u.id];
-            if (g === void 0 || g.length !== p) {
+            if (g === void 0 || g.length !== h) {
                 g = [];
-                for (let _ = 0; _ < p; _++)
-                    g[_] = [_, 0];
+                for (let S = 0; S < h; S++)
+                    g[S] = [S, 0];
                 n[u.id] = g;
             }
-            for (let _ = 0; _ < p; _++) {
-                const A = g[_];
-                A[0] = _, A[1] = h[_];
-            }
-            g.sort(dm);
-            for (let _ = 0; _ < 8; _++)
-                _ < p && g[_][1] ? (o[_][0] = g[_][0], o[_][1] = g[_][1]) : (o[_][0] = Number.MAX_SAFE_INTEGER, o[_][1] = 0);
-            o.sort(hm);
-            const v = u.morphAttributes.position,
+            for (let S = 0; S < h; S++) {
+                const y = g[S];
+                y[0] = S, y[1] = f[S];
+            }
+            g.sort(cg);
+            for (let S = 0; S < 8; S++)
+                S < h && g[S][1] ? (a[S][0] = g[S][0], a[S][1] = g[S][1]) : (a[S][0] = Number.MAX_SAFE_INTEGER, a[S][1] = 0);
+            a.sort(lg);
+            const _ = u.morphAttributes.position,
                 m = u.morphAttributes.normal;
-            let d = 0;
-            for (let _ = 0; _ < 8; _++) {
-                const A = o[_],
-                    R = A[0],
-                    E = A[1];
-                R !== Number.MAX_SAFE_INTEGER && E ? (v && u.getAttribute("morphTarget" + _) !== v[R] && u.setAttribute("morphTarget" + _, v[R]), m && u.getAttribute("morphNormal" + _) !== m[R] && u.setAttribute("morphNormal" + _, m[R]), r[_] = E, d += E) : (v && u.hasAttribute("morphTarget" + _) === !0 && u.deleteAttribute("morphTarget" + _), m && u.hasAttribute("morphNormal" + _) === !0 && u.deleteAttribute("morphNormal" + _), r[_] = 0);
+            let p = 0;
+            for (let S = 0; S < 8; S++) {
+                const y = a[S],
+                    b = y[0],
+                    E = y[1];
+                b !== Number.MAX_SAFE_INTEGER && E ? (_ && u.getAttribute("morphTarget" + S) !== _[b] && u.setAttribute("morphTarget" + S, _[b]), m && u.getAttribute("morphNormal" + S) !== m[b] && u.setAttribute("morphNormal" + S, m[b]), i[S] = E, p += E) : (_ && u.hasAttribute("morphTarget" + S) === !0 && u.deleteAttribute("morphTarget" + S), m && u.hasAttribute("morphNormal" + S) === !0 && u.deleteAttribute("morphNormal" + S), i[S] = 0);
             }
-            const M = u.morphTargetsRelative ? 1 : 1 - d;
-            f.getUniforms().setValue(i, "morphTargetBaseInfluence", M), f.getUniforms().setValue(i, "morphTargetInfluences", r);
+            const v = u.morphTargetsRelative ? 1 : 1 - p;
+            d.getUniforms().setValue(s, "morphTargetBaseInfluence", v), d.getUniforms().setValue(s, "morphTargetInfluences", i);
         }
     }
     return {
         update: l
     };
 }
 
-function mm(i, e, t, n) {
-    let r = /* @__PURE__ */ new WeakMap();
+function dg(s, e, t, n) {
+    let i = /* @__PURE__ */ new WeakMap();
 
-    function s(l) {
+    function r(l) {
         const c = n.render.frame,
             u = l.geometry,
-            f = e.get(l, u);
-        if (r.get(f) !== c && (e.update(f), r.set(f, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === !1 && l.addEventListener("dispose", o), r.get(l) !== c && (t.update(l.instanceMatrix, i.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, i.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh) {
-            const h = l.skeleton;
-            r.get(h) !== c && (h.update(), r.set(h, c));
+            d = e.get(l, u);
+        if (i.get(d) !== c && (e.update(d), i.set(d, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
+            const f = l.skeleton;
+            i.get(f) !== c && (f.update(), i.set(f, c));
         }
-        return f;
+        return d;
     }
 
-    function a() {
-        r = /* @__PURE__ */ new WeakMap();
+    function o() {
+        i = /* @__PURE__ */ new WeakMap();
     }
 
-    function o(l) {
+    function a(l) {
         const c = l.target;
-        c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
+        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
     }
     return {
-        update: s,
-        dispose: a
+        update: r,
+        dispose: o
     };
 }
-class xo extends Tt {
-    constructor(e, t, n, r, s, a, o, l, c, u) {
-        if (u = u !== void 0 ? u : Hn, u !== Hn && u !== Hi)
+class no extends Ot {
+    constructor(e, t, n, i, r, o, a, l, c, u) {
+        if (u = u !== void 0 ? u : ei, u !== ei && u !== cs)
             throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
-        n === void 0 && u === Hn && (n = nn), n === void 0 && u === Hi && (n = si), super(null, r, s, a, o, l, u, n, c), this.isDepthTexture = !0, this.image = {
+        n === void 0 && u === ei && (n = fn), n === void 0 && u === cs && (n = vi), super(null, i, r, o, a, l, u, n, c), this.isDepthTexture = !0, this.image = {
             width: e,
             height: t
-        }, this.magFilter = o !== void 0 ? o : vt, this.minFilter = l !== void 0 ? l : vt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
+        }, this.magFilter = a !== void 0 ? a : bt, this.minFilter = l !== void 0 ? l : bt, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
     }
     copy(e) {
         return super.copy(e), this.compareFunction = e.compareFunction, this;
     }
     toJSON(e) {
         const t = super.toJSON(e);
         return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
     }
 }
-const ac = /* @__PURE__ */ new Tt(),
-    lc = /* @__PURE__ */ new xo(1, 1);
-lc.compareFunction = Wl;
-const cc = /* @__PURE__ */ new Kl(),
-    uc = /* @__PURE__ */ new jf(),
-    fc = /* @__PURE__ */ new ic(),
-    Ga = [],
-    Ha = [],
-    Va = new Float32Array(16),
-    Wa = new Float32Array(9),
-    Xa = new Float32Array(4);
+const eu = /* @__PURE__ */ new Ot(),
+    tu = /* @__PURE__ */ new no(1, 1);
+tu.compareFunction = Nc;
+const nu = /* @__PURE__ */ new Vc(),
+    iu = /* @__PURE__ */ new Wf(),
+    su = /* @__PURE__ */ new Qc(),
+    Rl = [],
+    Pl = [],
+    Dl = new Float32Array(16),
+    Ll = new Float32Array(9),
+    Fl = new Float32Array(4);
 
-function Zi(i, e, t) {
-    const n = i[0];
+function _s(s, e, t) {
+    const n = s[0];
     if (n <= 0 || n > 0)
-        return i;
-    const r = e * t;
-    let s = Ga[r];
-    if (s === void 0 && (s = new Float32Array(r), Ga[r] = s), e !== 0) {
-        n.toArray(s, 0);
-        for (let a = 1, o = 0; a !== e; ++a)
-            o += t, i[a].toArray(s, o);
+        return s;
+    const i = e * t;
+    let r = Rl[i];
+    if (r === void 0 && (r = new Float32Array(i), Rl[i] = r), e !== 0) {
+        n.toArray(r, 0);
+        for (let o = 1, a = 0; o !== e; ++o)
+            a += t, s[o].toArray(r, a);
     }
-    return s;
+    return r;
 }
 
-function ft(i, e) {
-    if (i.length !== e.length)
+function vt(s, e) {
+    if (s.length !== e.length)
         return !1;
-    for (let t = 0, n = i.length; t < n; t++)
-        if (i[t] !== e[t])
+    for (let t = 0, n = s.length; t < n; t++)
+        if (s[t] !== e[t])
             return !1;
     return !0;
 }
 
-function ht(i, e) {
+function xt(s, e) {
     for (let t = 0, n = e.length; t < n; t++)
-        i[t] = e[t];
+        s[t] = e[t];
 }
 
-function ls(i, e) {
-    let t = Ha[e];
-    t === void 0 && (t = new Int32Array(e), Ha[e] = t);
+function Br(s, e) {
+    let t = Pl[e];
+    t === void 0 && (t = new Int32Array(e), Pl[e] = t);
     for (let n = 0; n !== e; ++n)
-        t[n] = i.allocateTextureUnit();
+        t[n] = s.allocateTextureUnit();
     return t;
 }
 
-function gm(i, e) {
+function fg(s, e) {
     const t = this.cache;
-    t[0] !== e && (i.uniform1f(this.addr, e), t[0] = e);
+    t[0] !== e && (s.uniform1f(this.addr, e), t[0] = e);
 }
 
-function _m(i, e) {
+function hg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
+        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform2fv(this.addr, e), ht(t, e);
+        s.uniform2fv(this.addr, e), xt(t, e);
     }
 }
 
-function vm(i, e) {
+function pg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
     else if (e.r !== void 0)
-        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (i.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
+        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform3fv(this.addr, e), ht(t, e);
+        s.uniform3fv(this.addr, e), xt(t, e);
     }
 }
 
-function xm(i, e) {
+function mg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform4fv(this.addr, e), ht(t, e);
+        s.uniform4fv(this.addr, e), xt(t, e);
     }
 }
 
-function Sm(i, e) {
+function gg(s, e) {
     const t = this.cache,
         n = e.elements;
     if (n === void 0) {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniformMatrix2fv(this.addr, !1, e), ht(t, e);
+        s.uniformMatrix2fv(this.addr, !1, e), xt(t, e);
     } else {
-        if (ft(t, n))
+        if (vt(t, n))
             return;
-        Xa.set(n), i.uniformMatrix2fv(this.addr, !1, Xa), ht(t, n);
+        Fl.set(n), s.uniformMatrix2fv(this.addr, !1, Fl), xt(t, n);
     }
 }
 
-function Mm(i, e) {
+function _g(s, e) {
     const t = this.cache,
         n = e.elements;
     if (n === void 0) {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniformMatrix3fv(this.addr, !1, e), ht(t, e);
+        s.uniformMatrix3fv(this.addr, !1, e), xt(t, e);
     } else {
-        if (ft(t, n))
+        if (vt(t, n))
             return;
-        Wa.set(n), i.uniformMatrix3fv(this.addr, !1, Wa), ht(t, n);
+        Ll.set(n), s.uniformMatrix3fv(this.addr, !1, Ll), xt(t, n);
     }
 }
 
-function ym(i, e) {
+function Sg(s, e) {
     const t = this.cache,
         n = e.elements;
     if (n === void 0) {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniformMatrix4fv(this.addr, !1, e), ht(t, e);
+        s.uniformMatrix4fv(this.addr, !1, e), xt(t, e);
     } else {
-        if (ft(t, n))
+        if (vt(t, n))
             return;
-        Va.set(n), i.uniformMatrix4fv(this.addr, !1, Va), ht(t, n);
+        Dl.set(n), s.uniformMatrix4fv(this.addr, !1, Dl), xt(t, n);
     }
 }
 
-function Am(i, e) {
+function vg(s, e) {
     const t = this.cache;
-    t[0] !== e && (i.uniform1i(this.addr, e), t[0] = e);
+    t[0] !== e && (s.uniform1i(this.addr, e), t[0] = e);
 }
 
-function Em(i, e) {
+function xg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
+        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform2iv(this.addr, e), ht(t, e);
+        s.uniform2iv(this.addr, e), xt(t, e);
     }
 }
 
-function bm(i, e) {
+function yg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform3iv(this.addr, e), ht(t, e);
+        s.uniform3iv(this.addr, e), xt(t, e);
     }
 }
 
-function Tm(i, e) {
+function Mg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform4iv(this.addr, e), ht(t, e);
+        s.uniform4iv(this.addr, e), xt(t, e);
     }
 }
 
-function wm(i, e) {
+function Eg(s, e) {
     const t = this.cache;
-    t[0] !== e && (i.uniform1ui(this.addr, e), t[0] = e);
+    t[0] !== e && (s.uniform1ui(this.addr, e), t[0] = e);
 }
 
-function Cm(i, e) {
+function Ag(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y) && (i.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
+        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform2uiv(this.addr, e), ht(t, e);
+        s.uniform2uiv(this.addr, e), xt(t, e);
     }
 }
 
-function Rm(i, e) {
+function Tg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (i.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform3uiv(this.addr, e), ht(t, e);
+        s.uniform3uiv(this.addr, e), xt(t, e);
     }
 }
 
-function Pm(i, e) {
+function bg(s, e) {
     const t = this.cache;
     if (e.x !== void 0)
-        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (i.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
+        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
     else {
-        if (ft(t, e))
+        if (vt(t, e))
             return;
-        i.uniform4uiv(this.addr, e), ht(t, e);
+        s.uniform4uiv(this.addr, e), xt(t, e);
     }
 }
 
-function Lm(i, e, t) {
+function Cg(s, e, t) {
     const n = this.cache,
-        r = t.allocateTextureUnit();
-    n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r);
-    const s = this.type === i.SAMPLER_2D_SHADOW ? lc : ac;
-    t.setTexture2D(e || s, r);
+        i = t.allocateTextureUnit();
+    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i);
+    const r = this.type === s.SAMPLER_2D_SHADOW ? tu : eu;
+    t.setTexture2D(e || r, i);
 }
 
-function Dm(i, e, t) {
+function wg(s, e, t) {
     const n = this.cache,
-        r = t.allocateTextureUnit();
-    n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture3D(e || uc, r);
+        i = t.allocateTextureUnit();
+    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || iu, i);
 }
 
-function Im(i, e, t) {
+function Rg(s, e, t) {
     const n = this.cache,
-        r = t.allocateTextureUnit();
-    n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTextureCube(e || fc, r);
+        i = t.allocateTextureUnit();
+    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || su, i);
 }
 
-function Um(i, e, t) {
+function Pg(s, e, t) {
     const n = this.cache,
-        r = t.allocateTextureUnit();
-    n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), t.setTexture2DArray(e || cc, r);
+        i = t.allocateTextureUnit();
+    n[0] !== i && (s.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || nu, i);
 }
 
-function Fm(i) {
-    switch (i) {
+function Dg(s) {
+    switch (s) {
         case 5126:
-            return gm;
+            return fg;
         case 35664:
-            return _m;
+            return hg;
         case 35665:
-            return vm;
+            return pg;
         case 35666:
-            return xm;
+            return mg;
         case 35674:
-            return Sm;
+            return gg;
         case 35675:
-            return Mm;
+            return _g;
         case 35676:
-            return ym;
+            return Sg;
         case 5124:
         case 35670:
-            return Am;
+            return vg;
         case 35667:
         case 35671:
-            return Em;
+            return xg;
         case 35668:
         case 35672:
-            return bm;
+            return yg;
         case 35669:
         case 35673:
-            return Tm;
+            return Mg;
         case 5125:
-            return wm;
+            return Eg;
         case 36294:
-            return Cm;
+            return Ag;
         case 36295:
-            return Rm;
+            return Tg;
         case 36296:
-            return Pm;
+            return bg;
         case 35678:
         case 36198:
         case 36298:
         case 36306:
         case 35682:
-            return Lm;
+            return Cg;
         case 35679:
         case 36299:
         case 36307:
-            return Dm;
+            return wg;
         case 35680:
         case 36300:
         case 36308:
         case 36293:
-            return Im;
+            return Rg;
         case 36289:
         case 36303:
         case 36311:
         case 36292:
-            return Um;
+            return Pg;
     }
 }
 
-function Nm(i, e) {
-    i.uniform1fv(this.addr, e);
+function Lg(s, e) {
+    s.uniform1fv(this.addr, e);
 }
 
-function Bm(i, e) {
-    const t = Zi(e, this.size, 2);
-    i.uniform2fv(this.addr, t);
+function Fg(s, e) {
+    const t = _s(e, this.size, 2);
+    s.uniform2fv(this.addr, t);
 }
 
-function Om(i, e) {
-    const t = Zi(e, this.size, 3);
-    i.uniform3fv(this.addr, t);
+function Ig(s, e) {
+    const t = _s(e, this.size, 3);
+    s.uniform3fv(this.addr, t);
 }
 
-function zm(i, e) {
-    const t = Zi(e, this.size, 4);
-    i.uniform4fv(this.addr, t);
+function Ug(s, e) {
+    const t = _s(e, this.size, 4);
+    s.uniform4fv(this.addr, t);
 }
 
-function km(i, e) {
-    const t = Zi(e, this.size, 4);
-    i.uniformMatrix2fv(this.addr, !1, t);
+function Bg(s, e) {
+    const t = _s(e, this.size, 4);
+    s.uniformMatrix2fv(this.addr, !1, t);
 }
 
-function Gm(i, e) {
-    const t = Zi(e, this.size, 9);
-    i.uniformMatrix3fv(this.addr, !1, t);
+function Og(s, e) {
+    const t = _s(e, this.size, 9);
+    s.uniformMatrix3fv(this.addr, !1, t);
 }
 
-function Hm(i, e) {
-    const t = Zi(e, this.size, 16);
-    i.uniformMatrix4fv(this.addr, !1, t);
+function Ng(s, e) {
+    const t = _s(e, this.size, 16);
+    s.uniformMatrix4fv(this.addr, !1, t);
 }
 
-function Vm(i, e) {
-    i.uniform1iv(this.addr, e);
+function kg(s, e) {
+    s.uniform1iv(this.addr, e);
 }
 
-function Wm(i, e) {
-    i.uniform2iv(this.addr, e);
+function zg(s, e) {
+    s.uniform2iv(this.addr, e);
 }
 
-function Xm(i, e) {
-    i.uniform3iv(this.addr, e);
+function Hg(s, e) {
+    s.uniform3iv(this.addr, e);
 }
 
-function qm(i, e) {
-    i.uniform4iv(this.addr, e);
+function Gg(s, e) {
+    s.uniform4iv(this.addr, e);
 }
 
-function Ym(i, e) {
-    i.uniform1uiv(this.addr, e);
+function Vg(s, e) {
+    s.uniform1uiv(this.addr, e);
 }
 
-function jm(i, e) {
-    i.uniform2uiv(this.addr, e);
+function Wg(s, e) {
+    s.uniform2uiv(this.addr, e);
 }
 
-function Km(i, e) {
-    i.uniform3uiv(this.addr, e);
+function Xg(s, e) {
+    s.uniform3uiv(this.addr, e);
 }
 
-function Qm(i, e) {
-    i.uniform4uiv(this.addr, e);
+function qg(s, e) {
+    s.uniform4uiv(this.addr, e);
 }
 
-function Zm(i, e, t) {
+function Yg(s, e, t) {
     const n = this.cache,
-        r = e.length,
-        s = ls(t, r);
-    ft(n, s) || (i.uniform1iv(this.addr, s), ht(n, s));
-    for (let a = 0; a !== r; ++a)
-        t.setTexture2D(e[a] || ac, s[a]);
+        i = e.length,
+        r = Br(t, i);
+    vt(n, r) || (s.uniform1iv(this.addr, r), xt(n, r));
+    for (let o = 0; o !== i; ++o)
+        t.setTexture2D(e[o] || eu, r[o]);
 }
 
-function Jm(i, e, t) {
+function jg(s, e, t) {
     const n = this.cache,
-        r = e.length,
-        s = ls(t, r);
-    ft(n, s) || (i.uniform1iv(this.addr, s), ht(n, s));
-    for (let a = 0; a !== r; ++a)
-        t.setTexture3D(e[a] || uc, s[a]);
+        i = e.length,
+        r = Br(t, i);
+    vt(n, r) || (s.uniform1iv(this.addr, r), xt(n, r));
+    for (let o = 0; o !== i; ++o)
+        t.setTexture3D(e[o] || iu, r[o]);
 }
 
-function $m(i, e, t) {
+function Kg(s, e, t) {
     const n = this.cache,
-        r = e.length,
-        s = ls(t, r);
-    ft(n, s) || (i.uniform1iv(this.addr, s), ht(n, s));
-    for (let a = 0; a !== r; ++a)
-        t.setTextureCube(e[a] || fc, s[a]);
+        i = e.length,
+        r = Br(t, i);
+    vt(n, r) || (s.uniform1iv(this.addr, r), xt(n, r));
+    for (let o = 0; o !== i; ++o)
+        t.setTextureCube(e[o] || su, r[o]);
 }
 
-function eg(i, e, t) {
+function Zg(s, e, t) {
     const n = this.cache,
-        r = e.length,
-        s = ls(t, r);
-    ft(n, s) || (i.uniform1iv(this.addr, s), ht(n, s));
-    for (let a = 0; a !== r; ++a)
-        t.setTexture2DArray(e[a] || cc, s[a]);
+        i = e.length,
+        r = Br(t, i);
+    vt(n, r) || (s.uniform1iv(this.addr, r), xt(n, r));
+    for (let o = 0; o !== i; ++o)
+        t.setTexture2DArray(e[o] || nu, r[o]);
 }
 
-function tg(i) {
-    switch (i) {
+function Qg(s) {
+    switch (s) {
         case 5126:
-            return Nm;
+            return Lg;
         case 35664:
-            return Bm;
+            return Fg;
         case 35665:
-            return Om;
+            return Ig;
         case 35666:
-            return zm;
+            return Ug;
         case 35674:
-            return km;
+            return Bg;
         case 35675:
-            return Gm;
+            return Og;
         case 35676:
-            return Hm;
+            return Ng;
         case 5124:
         case 35670:
-            return Vm;
+            return kg;
         case 35667:
         case 35671:
-            return Wm;
+            return zg;
         case 35668:
         case 35672:
-            return Xm;
+            return Hg;
         case 35669:
         case 35673:
-            return qm;
+            return Gg;
         case 5125:
-            return Ym;
+            return Vg;
         case 36294:
-            return jm;
+            return Wg;
         case 36295:
-            return Km;
+            return Xg;
         case 36296:
-            return Qm;
+            return qg;
         case 35678:
         case 36198:
         case 36298:
         case 36306:
         case 35682:
-            return Zm;
+            return Yg;
         case 35679:
         case 36299:
         case 36307:
-            return Jm;
+            return jg;
         case 35680:
         case 36300:
         case 36308:
         case 36293:
-            return $m;
+            return Kg;
         case 36289:
         case 36303:
         case 36311:
         case 36292:
-            return eg;
+            return Zg;
     }
 }
-class ng {
+class Jg {
     constructor(e, t, n) {
-        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = Fm(t.type);
+        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = Dg(t.type);
     }
 }
-class ig {
+class $g {
     constructor(e, t, n) {
-        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = tg(t.type);
+        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = Qg(t.type);
     }
 }
-class rg {
+class e0 {
     constructor(e) {
         this.id = e, this.seq = [], this.map = {};
     }
     setValue(e, t, n) {
-        const r = this.seq;
-        for (let s = 0, a = r.length; s !== a; ++s) {
-            const o = r[s];
-            o.setValue(e, t[o.id], n);
+        const i = this.seq;
+        for (let r = 0, o = i.length; r !== o; ++r) {
+            const a = i[r];
+            a.setValue(e, t[a.id], n);
         }
     }
 }
-const qs = /(\w+)(\])?(\[|\.)?/g;
-
-function qa(i, e) {
-    i.seq.push(e), i.map[e.id] = e;
-}
-
-function sg(i, e, t) {
-    const n = i.name,
-        r = n.length;
-    for (qs.lastIndex = 0;;) {
-        const s = qs.exec(n),
-            a = qs.lastIndex;
-        let o = s[1];
-        const l = s[2] === "]",
-            c = s[3];
-        if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === r) {
-            qa(t, c === void 0 ? new ng(o, i, e) : new ig(o, i, e));
+const Ma = /(\w+)(\])?(\[|\.)?/g;
+
+function Il(s, e) {
+    s.seq.push(e), s.map[e.id] = e;
+}
+
+function t0(s, e, t) {
+    const n = s.name,
+        i = n.length;
+    for (Ma.lastIndex = 0;;) {
+        const r = Ma.exec(n),
+            o = Ma.lastIndex;
+        let a = r[1];
+        const l = r[2] === "]",
+            c = r[3];
+        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
+            Il(t, c === void 0 ? new Jg(a, s, e) : new $g(a, s, e));
             break;
         } else {
-            let f = t.map[o];
-            f === void 0 && (f = new rg(o), qa(t, f)), t = f;
+            let d = t.map[a];
+            d === void 0 && (d = new e0(a), Il(t, d)), t = d;
         }
     }
 }
-class Vr {
+class hr {
     constructor(e, t) {
         this.seq = [], this.map = {};
         const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
-        for (let r = 0; r < n; ++r) {
-            const s = e.getActiveUniform(t, r),
-                a = e.getUniformLocation(t, s.name);
-            sg(s, a, this);
+        for (let i = 0; i < n; ++i) {
+            const r = e.getActiveUniform(t, i),
+                o = e.getUniformLocation(t, r.name);
+            t0(r, o, this);
         }
     }
-    setValue(e, t, n, r) {
-        const s = this.map[t];
-        s !== void 0 && s.setValue(e, n, r);
+    setValue(e, t, n, i) {
+        const r = this.map[t];
+        r !== void 0 && r.setValue(e, n, i);
     }
     setOptional(e, t, n) {
-        const r = t[n];
-        r !== void 0 && this.setValue(e, n, r);
+        const i = t[n];
+        i !== void 0 && this.setValue(e, n, i);
     }
-    static upload(e, t, n, r) {
-        for (let s = 0, a = t.length; s !== a; ++s) {
-            const o = t[s],
-                l = n[o.id];
-            l.needsUpdate !== !1 && o.setValue(e, l.value, r);
+    static upload(e, t, n, i) {
+        for (let r = 0, o = t.length; r !== o; ++r) {
+            const a = t[r],
+                l = n[a.id];
+            l.needsUpdate !== !1 && a.setValue(e, l.value, i);
         }
     }
     static seqWithValue(e, t) {
         const n = [];
-        for (let r = 0, s = e.length; r !== s; ++r) {
-            const a = e[r];
-            a.id in t && n.push(a);
+        for (let i = 0, r = e.length; i !== r; ++i) {
+            const o = e[i];
+            o.id in t && n.push(o);
         }
         return n;
     }
 }
 
-function Ya(i, e, t) {
-    const n = i.createShader(e);
-    return i.shaderSource(n, t), i.compileShader(n), n;
+function Ul(s, e, t) {
+    const n = s.createShader(e);
+    return s.shaderSource(n, t), s.compileShader(n), n;
 }
-const og = 37297;
-let ag = 0;
+const n0 = 37297;
+let i0 = 0;
 
-function lg(i, e) {
-    const t = i.split(`
+function s0(s, e) {
+    const t = s.split(`
 `),
         n = [],
-        r = Math.max(e - 6, 0),
-        s = Math.min(e + 6, t.length);
-    for (let a = r; a < s; a++) {
-        const o = a + 1;
-        n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
+        i = Math.max(e - 6, 0),
+        r = Math.min(e + 6, t.length);
+    for (let o = i; o < r; o++) {
+        const a = o + 1;
+        n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
     }
     return n.join(`
 `);
 }
 
-function cg(i) {
-    const e = Ze.getPrimaries(Ze.workingColorSpace),
-        t = Ze.getPrimaries(i);
+function r0(s) {
+    const e = tt.getPrimaries(tt.workingColorSpace),
+        t = tt.getPrimaries(s);
     let n;
-    switch (e === t ? n = "" : e === Kr && t === jr ? n = "LinearDisplayP3ToLinearSRGB" : e === jr && t === Kr && (n = "LinearSRGBToLinearDisplayP3"), i) {
-        case Wn:
-        case os:
+    switch (e === t ? n = "" : e === Mr && t === yr ? n = "LinearDisplayP3ToLinearSRGB" : e === yr && t === Mr && (n = "LinearSRGBToLinearDisplayP3"), s) {
+        case ni:
+        case Ir:
             return [n, "LinearTransferOETF"];
-        case sn:
-        case mo:
+        case pn:
+        case Qa:
             return [n, "sRGBTransferOETF"];
         default:
-            return console.warn("THREE.WebGLProgram: Unsupported color space:", i), [n, "LinearTransferOETF"];
+            return console.warn("THREE.WebGLProgram: Unsupported color space:", s), [n, "LinearTransferOETF"];
     }
 }
 
-function ja(i, e, t) {
-    const n = i.getShaderParameter(e, i.COMPILE_STATUS),
-        r = i.getShaderInfoLog(e).trim();
-    if (n && r === "")
+function Bl(s, e, t) {
+    const n = s.getShaderParameter(e, s.COMPILE_STATUS),
+        i = s.getShaderInfoLog(e).trim();
+    if (n && i === "")
         return "";
-    const s = /ERROR: 0:(\d+)/.exec(r);
-    if (s) {
-        const a = parseInt(s[1]);
+    const r = /ERROR: 0:(\d+)/.exec(i);
+    if (r) {
+        const o = parseInt(r[1]);
         return t.toUpperCase() + `
 
-` + r + `
+` + i + `
 
-` + lg(i.getShaderSource(e), a);
+` + s0(s.getShaderSource(e), o);
     } else
-        return r;
+        return i;
 }
 
-function ug(i, e) {
-    const t = cg(e);
-    return `vec4 ${i}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
+function a0(s, e) {
+    const t = r0(e);
+    return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
 }
 
-function fg(i, e) {
+function o0(s, e) {
     let t;
     switch (e) {
-        case tf:
+        case Zd:
             t = "Linear";
             break;
-        case nf:
+        case Qd:
             t = "Reinhard";
             break;
-        case rf:
+        case Jd:
             t = "OptimizedCineon";
             break;
-        case sf:
+        case $d:
             t = "ACESFilmic";
             break;
-        case af:
+        case tf:
             t = "AgX";
             break;
-        case lf:
+        case nf:
             t = "Neutral";
             break;
-        case of:
+        case ef:
             t = "Custom";
             break;
         default:
             console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
     }
-    return "vec3 " + i + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
+    return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
 }
 
-function hg(i) {
+function l0(s) {
     return [
-        i.extensionDerivatives || i.envMapCubeUVHeight || i.bumpMap || i.normalMapTangentSpace || i.clearcoatNormalMap || i.flatShading || i.alphaToCoverage || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
-        (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
-        i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
-        (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
-    ].filter(Fi).join(`
+        s.extensionDerivatives || s.envMapCubeUVHeight || s.bumpMap || s.normalMapTangentSpace || s.clearcoatNormalMap || s.flatShading || s.alphaToCoverage || s.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
+        (s.extensionFragDepth || s.logarithmicDepthBuffer) && s.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
+        s.extensionDrawBuffers && s.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
+        (s.extensionShaderTextureLOD || s.envMap || s.transmission) && s.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
+    ].filter(Ji).join(`
 `);
 }
 
-function dg(i) {
+function c0(s) {
     return [
-        i.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
-        i.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
-    ].filter(Fi).join(`
+        s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
+        s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
+    ].filter(Ji).join(`
 `);
 }
 
-function pg(i) {
+function u0(s) {
     const e = [];
-    for (const t in i) {
-        const n = i[t];
+    for (const t in s) {
+        const n = s[t];
         n !== !1 && e.push("#define " + t + " " + n);
     }
     return e.join(`
 `);
 }
 
-function mg(i, e) {
+function d0(s, e) {
     const t = {},
-        n = i.getProgramParameter(e, i.ACTIVE_ATTRIBUTES);
-    for (let r = 0; r < n; r++) {
-        const s = i.getActiveAttrib(e, r),
-            a = s.name;
-        let o = 1;
-        s.type === i.FLOAT_MAT2 && (o = 2), s.type === i.FLOAT_MAT3 && (o = 3), s.type === i.FLOAT_MAT4 && (o = 4), t[a] = {
-            type: s.type,
-            location: i.getAttribLocation(e, a),
-            locationSize: o
+        n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
+    for (let i = 0; i < n; i++) {
+        const r = s.getActiveAttrib(e, i),
+            o = r.name;
+        let a = 1;
+        r.type === s.FLOAT_MAT2 && (a = 2), r.type === s.FLOAT_MAT3 && (a = 3), r.type === s.FLOAT_MAT4 && (a = 4), t[o] = {
+            type: r.type,
+            location: s.getAttribLocation(e, o),
+            locationSize: a
         };
     }
     return t;
 }
 
-function Fi(i) {
-    return i !== "";
+function Ji(s) {
+    return s !== "";
 }
 
-function Ka(i, e) {
+function Ol(s, e) {
     const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
-    return i.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
+    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
 }
 
-function Qa(i, e) {
-    return i.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
+function Nl(s, e) {
+    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
 }
-const gg = /^[ \t]*#include +<([\w\d./]+)>/gm;
+const f0 = /^[ \t]*#include +<([\w\d./]+)>/gm;
 
-function oo(i) {
-    return i.replace(gg, vg);
+function ka(s) {
+    return s.replace(f0, p0);
 }
-const _g = /* @__PURE__ */ new Map([
+const h0 = /* @__PURE__ */ new Map([
     ["encodings_fragment", "colorspace_fragment"],
     // @deprecated, r154
     ["encodings_pars_fragment", "colorspace_pars_fragment"],
     // @deprecated, r154
     ["output_fragment", "opaque_fragment"]
     // @deprecated, r154
 ]);
 
-function vg(i, e) {
-    let t = We[e];
+function p0(s, e) {
+    let t = je[e];
     if (t === void 0) {
-        const n = _g.get(e);
+        const n = h0.get(e);
         if (n !== void 0)
-            t = We[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
+            t = je[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
         else
             throw new Error("Can not resolve #include <" + e + ">");
     }
-    return oo(t);
+    return ka(t);
 }
-const xg = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
+const m0 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
 
-function Za(i) {
-    return i.replace(xg, Sg);
+function kl(s) {
+    return s.replace(m0, g0);
 }
 
-function Sg(i, e, t, n) {
-    let r = "";
-    for (let s = parseInt(e); s < parseInt(t); s++)
-        r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
-    return r;
+function g0(s, e, t, n) {
+    let i = "";
+    for (let r = parseInt(e); r < parseInt(t); r++)
+        i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
+    return i;
 }
 
-function Ja(i) {
-    let e = `precision ${i.precision} float;
-	precision ${i.precision} int;
-	precision ${i.precision} sampler2D;
-	precision ${i.precision} samplerCube;
+function zl(s) {
+    let e = `precision ${s.precision} float;
+	precision ${s.precision} int;
+	precision ${s.precision} sampler2D;
+	precision ${s.precision} samplerCube;
 	`;
-    return i.isWebGL2 && (e += `precision ${i.precision} sampler3D;
-		precision ${i.precision} sampler2DArray;
-		precision ${i.precision} sampler2DShadow;
-		precision ${i.precision} samplerCubeShadow;
-		precision ${i.precision} sampler2DArrayShadow;
-		precision ${i.precision} isampler2D;
-		precision ${i.precision} isampler3D;
-		precision ${i.precision} isamplerCube;
-		precision ${i.precision} isampler2DArray;
-		precision ${i.precision} usampler2D;
-		precision ${i.precision} usampler3D;
-		precision ${i.precision} usamplerCube;
-		precision ${i.precision} usampler2DArray;
-		`), i.precision === "highp" ? e += `
-#define HIGH_PRECISION` : i.precision === "mediump" ? e += `
-#define MEDIUM_PRECISION` : i.precision === "lowp" && (e += `
+    return s.isWebGL2 && (e += `precision ${s.precision} sampler3D;
+		precision ${s.precision} sampler2DArray;
+		precision ${s.precision} sampler2DShadow;
+		precision ${s.precision} samplerCubeShadow;
+		precision ${s.precision} sampler2DArrayShadow;
+		precision ${s.precision} isampler2D;
+		precision ${s.precision} isampler3D;
+		precision ${s.precision} isamplerCube;
+		precision ${s.precision} isampler2DArray;
+		precision ${s.precision} usampler2D;
+		precision ${s.precision} usampler3D;
+		precision ${s.precision} usamplerCube;
+		precision ${s.precision} usampler2DArray;
+		`), s.precision === "highp" ? e += `
+#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
+#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
 #define LOW_PRECISION`), e;
 }
 
-function Mg(i) {
+function _0(s) {
     let e = "SHADOWMAP_TYPE_BASIC";
-    return i.shadowMapType === Fl ? e = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === Pu ? e = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === xn && (e = "SHADOWMAP_TYPE_VSM"), e;
+    return s.shadowMapType === Rc ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === Td ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === wn && (e = "SHADOWMAP_TYPE_VSM"), e;
 }
 
-function yg(i) {
+function S0(s) {
     let e = "ENVMAP_TYPE_CUBE";
-    if (i.envMap)
-        switch (i.envMapMode) {
-            case zi:
-            case ki:
+    if (s.envMap)
+        switch (s.envMapMode) {
+            case os:
+            case ls:
                 e = "ENVMAP_TYPE_CUBE";
                 break;
-            case ss:
+            case Fr:
                 e = "ENVMAP_TYPE_CUBE_UV";
                 break;
         }
     return e;
 }
 
-function Ag(i) {
+function v0(s) {
     let e = "ENVMAP_MODE_REFLECTION";
-    if (i.envMap)
-        switch (i.envMapMode) {
-            case ki:
+    if (s.envMap)
+        switch (s.envMapMode) {
+            case ls:
                 e = "ENVMAP_MODE_REFRACTION";
                 break;
         }
     return e;
 }
 
-function Eg(i) {
+function x0(s) {
     let e = "ENVMAP_BLENDING_NONE";
-    if (i.envMap)
-        switch (i.combine) {
-            case Bl:
+    if (s.envMap)
+        switch (s.combine) {
+            case Dc:
                 e = "ENVMAP_BLENDING_MULTIPLY";
                 break;
-            case $u:
+            case jd:
                 e = "ENVMAP_BLENDING_MIX";
                 break;
-            case ef:
+            case Kd:
                 e = "ENVMAP_BLENDING_ADD";
                 break;
         }
     return e;
 }
 
-function bg(i) {
-    const e = i.envMapCubeUVHeight;
+function y0(s) {
+    const e = s.envMapCubeUVHeight;
     if (e === null)
         return null;
     const t = Math.log2(e) - 2,
         n = 1 / e;
     return {
         texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
         texelHeight: n,
         maxMip: t
     };
 }
 
-function Tg(i, e, t, n) {
-    const r = i.getContext(),
-        s = t.defines;
-    let a = t.vertexShader,
-        o = t.fragmentShader;
-    const l = Mg(t),
-        c = yg(t),
-        u = Ag(t),
-        f = Eg(t),
-        h = bg(t),
-        p = t.isWebGL2 ? "" : hg(t),
-        g = dg(t),
-        v = pg(s),
-        m = r.createProgram();
-    let d, M, _ = t.glslVersion ? "#version " + t.glslVersion + `
+function M0(s, e, t, n) {
+    const i = s.getContext(),
+        r = t.defines;
+    let o = t.vertexShader,
+        a = t.fragmentShader;
+    const l = _0(t),
+        c = S0(t),
+        u = v0(t),
+        d = x0(t),
+        f = y0(t),
+        h = t.isWebGL2 ? "" : l0(t),
+        g = c0(t),
+        _ = u0(r),
+        m = i.createProgram();
+    let p, v, S = t.glslVersion ? "#version " + t.glslVersion + `
 ` : "";
-    t.isRawShaderMaterial ? (d = [
+    t.isRawShaderMaterial ? (p = [
         "#define SHADER_TYPE " + t.shaderType,
         "#define SHADER_NAME " + t.shaderName,
-        v
-    ].filter(Fi).join(`
-`), d.length > 0 && (d += `
-`), M = [
-        p,
+        _
+    ].filter(Ji).join(`
+`), p.length > 0 && (p += `
+`), v = [
+        h,
         "#define SHADER_TYPE " + t.shaderType,
         "#define SHADER_NAME " + t.shaderName,
-        v
-    ].filter(Fi).join(`
-`), M.length > 0 && (M += `
-`)) : (d = [
-        Ja(t),
+        _
+    ].filter(Ji).join(`
+`), v.length > 0 && (v += `
+`)) : (p = [
+        zl(t),
         "#define SHADER_TYPE " + t.shaderType,
         "#define SHADER_NAME " + t.shaderName,
-        v,
+        _,
         t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
         t.batching ? "#define USE_BATCHING" : "",
         t.instancing ? "#define USE_INSTANCING" : "",
         t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
         t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
         t.useFog && t.fog ? "#define USE_FOG" : "",
         t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
@@ -13632,33 +13660,33 @@
         "#endif",
         "#ifdef USE_SKINNING",
         "	attribute vec4 skinIndex;",
         "	attribute vec4 skinWeight;",
         "#endif",
         `
 `
-    ].filter(Fi).join(`
-`), M = [
-        p,
-        Ja(t),
+    ].filter(Ji).join(`
+`), v = [
+        h,
+        zl(t),
         "#define SHADER_TYPE " + t.shaderType,
         "#define SHADER_NAME " + t.shaderName,
-        v,
+        _,
         t.useFog && t.fog ? "#define USE_FOG" : "",
         t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
         t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
         t.map ? "#define USE_MAP" : "",
         t.matcap ? "#define USE_MATCAP" : "",
         t.envMap ? "#define USE_ENVMAP" : "",
         t.envMap ? "#define " + c : "",
         t.envMap ? "#define " + u : "",
-        t.envMap ? "#define " + f : "",
-        h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
-        h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
-        h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
+        t.envMap ? "#define " + d : "",
+        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
+        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
+        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
         t.lightMap ? "#define USE_LIGHTMAP" : "",
         t.aoMap ? "#define USE_AOMAP" : "",
         t.bumpMap ? "#define USE_BUMPMAP" : "",
         t.normalMap ? "#define USE_NORMALMAP" : "",
         t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
         t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
         t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
@@ -13703,128 +13731,128 @@
         t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
         t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
         t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
         t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
         "uniform mat4 viewMatrix;",
         "uniform vec3 cameraPosition;",
         "uniform bool isOrthographic;",
-        t.toneMapping !== kn ? "#define TONE_MAPPING" : "",
-        t.toneMapping !== kn ? We.tonemapping_pars_fragment : "",
+        t.toneMapping !== $n ? "#define TONE_MAPPING" : "",
+        t.toneMapping !== $n ? je.tonemapping_pars_fragment : "",
         // this code is required here because it is used by the toneMapping() function defined below
-        t.toneMapping !== kn ? fg("toneMapping", t.toneMapping) : "",
+        t.toneMapping !== $n ? o0("toneMapping", t.toneMapping) : "",
         t.dithering ? "#define DITHERING" : "",
         t.opaque ? "#define OPAQUE" : "",
-        We.colorspace_pars_fragment,
+        je.colorspace_pars_fragment,
         // this code is required here because it is used by the various encoding/decoding function defined below
-        ug("linearToOutputTexel", t.outputColorSpace),
+        a0("linearToOutputTexel", t.outputColorSpace),
         t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
         `
 `
-    ].filter(Fi).join(`
-`)), a = oo(a), a = Ka(a, t), a = Qa(a, t), o = oo(o), o = Ka(o, t), o = Qa(o, t), a = Za(a), o = Za(o), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (_ = `#version 300 es
-`, d = [
+    ].filter(Ji).join(`
+`)), o = ka(o), o = Ol(o, t), o = Nl(o, t), a = ka(a), a = Ol(a, t), a = Nl(a, t), o = kl(o), a = kl(a), t.isWebGL2 && t.isRawShaderMaterial !== !0 && (S = `#version 300 es
+`, p = [
         g,
         "precision mediump sampler2DArray;",
         "#define attribute in",
         "#define varying out",
         "#define texture2D texture"
     ].join(`
 `) + `
-` + d, M = [
+` + p, v = [
         "precision mediump sampler2DArray;",
         "#define varying in",
-        t.glslVersion === pa ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
-        t.glslVersion === pa ? "" : "#define gl_FragColor pc_fragColor",
+        t.glslVersion === nl ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
+        t.glslVersion === nl ? "" : "#define gl_FragColor pc_fragColor",
         "#define gl_FragDepthEXT gl_FragDepth",
         "#define texture2D texture",
         "#define textureCube texture",
         "#define texture2DProj textureProj",
         "#define texture2DLodEXT textureLod",
         "#define texture2DProjLodEXT textureProjLod",
         "#define textureCubeLodEXT textureLod",
         "#define texture2DGradEXT textureGrad",
         "#define texture2DProjGradEXT textureProjGrad",
         "#define textureCubeGradEXT textureGrad"
     ].join(`
 `) + `
-` + M);
-    const A = _ + d + a,
-        R = _ + M + o,
-        E = Ya(r, r.VERTEX_SHADER, A),
-        b = Ya(r, r.FRAGMENT_SHADER, R);
-    r.attachShader(m, E), r.attachShader(m, b), t.index0AttributeName !== void 0 ? r.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m);
-
-    function I(Y) {
-        if (i.debug.checkShaderErrors) {
-            const K = r.getProgramInfoLog(m).trim(),
-                L = r.getShaderInfoLog(E).trim(),
-                N = r.getShaderInfoLog(b).trim();
-            let O = !0,
-                B = !0;
-            if (r.getProgramParameter(m, r.LINK_STATUS) === !1)
-                if (O = !1, typeof i.debug.onShaderError == "function")
-                    i.debug.onShaderError(r, m, E, b);
+` + v);
+    const y = S + p + o,
+        b = S + v + a,
+        E = Ul(i, i.VERTEX_SHADER, y),
+        T = Ul(i, i.FRAGMENT_SHADER, b);
+    i.attachShader(m, E), i.attachShader(m, T), t.index0AttributeName !== void 0 ? i.bindAttribLocation(m, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"), i.linkProgram(m);
+
+    function L(U) {
+        if (s.debug.checkShaderErrors) {
+            const N = i.getProgramInfoLog(m).trim(),
+                P = i.getShaderInfoLog(E).trim(),
+                I = i.getShaderInfoLog(T).trim();
+            let z = !0,
+                K = !0;
+            if (i.getProgramParameter(m, i.LINK_STATUS) === !1)
+                if (z = !1, typeof s.debug.onShaderError == "function")
+                    s.debug.onShaderError(i, m, E, T);
                 else {
-                    const j = ja(r, E, "vertex"),
-                        q = ja(r, b, "fragment");
+                    const G = Bl(i, E, "vertex"),
+                        q = Bl(i, T, "fragment");
                     console.error(
-                        "THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, r.VALIDATE_STATUS) + `
+                        "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(m, i.VALIDATE_STATUS) + `
 
-Material Name: ` + Y.name + `
-Material Type: ` + Y.type + `
+Material Name: ` + U.name + `
+Material Type: ` + U.type + `
 
-Program Info Log: ` + K + `
-` + j + `
+Program Info Log: ` + N + `
+` + G + `
 ` + q
                     );
                 }
             else
-                K !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", K) : (L === "" || N === "") && (B = !1);
-            B && (Y.diagnostics = {
-                runnable: O,
-                programLog: K,
+                N !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", N) : (P === "" || I === "") && (K = !1);
+            K && (U.diagnostics = {
+                runnable: z,
+                programLog: N,
                 vertexShader: {
-                    log: L,
-                    prefix: d
+                    log: P,
+                    prefix: p
                 },
                 fragmentShader: {
-                    log: N,
-                    prefix: M
+                    log: I,
+                    prefix: v
                 }
             });
         }
-        r.deleteShader(E), r.deleteShader(b), W = new Vr(r, m), S = mg(r, m);
+        i.deleteShader(E), i.deleteShader(T), B = new hr(i, m), x = d0(i, m);
     }
-    let W;
+    let B;
     this.getUniforms = function() {
-        return W === void 0 && I(this), W;
+        return B === void 0 && L(this), B;
     };
-    let S;
+    let x;
     this.getAttributes = function() {
-        return S === void 0 && I(this), S;
+        return x === void 0 && L(this), x;
     };
-    let T = t.rendererExtensionParallelShaderCompile === !1;
+    let A = t.rendererExtensionParallelShaderCompile === !1;
     return this.isReady = function() {
-        return T === !1 && (T = r.getProgramParameter(m, og)), T;
+        return A === !1 && (A = i.getProgramParameter(m, n0)), A;
     }, this.destroy = function() {
-        n.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0;
-    }, this.type = t.shaderType, this.name = t.shaderName, this.id = ag++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = E, this.fragmentShader = b, this;
+        n.releaseStatesOfProgram(this), i.deleteProgram(m), this.program = void 0;
+    }, this.type = t.shaderType, this.name = t.shaderName, this.id = i0++, this.cacheKey = e, this.usedTimes = 1, this.program = m, this.vertexShader = E, this.fragmentShader = T, this;
 }
-let wg = 0;
-class Cg {
+let E0 = 0;
+class A0 {
     constructor() {
         this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
     }
     update(e) {
         const t = e.vertexShader,
             n = e.fragmentShader,
-            r = this._getShaderStage(t),
-            s = this._getShaderStage(n),
-            a = this._getShaderCacheForMaterial(e);
-        return a.has(r) === !1 && (a.add(r), r.usedTimes++), a.has(s) === !1 && (a.add(s), s.usedTimes++), this;
+            i = this._getShaderStage(t),
+            r = this._getShaderStage(n),
+            o = this._getShaderCacheForMaterial(e);
+        return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(r) === !1 && (o.add(r), r.usedTimes++), this;
     }
     remove(e) {
         const t = this.materialCache.get(e);
         for (const n of t)
             n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
         return this.materialCache.delete(e), this;
     }
@@ -13841,33 +13869,33 @@
         const t = this.materialCache;
         let n = t.get(e);
         return n === void 0 && (n = /* @__PURE__ */ new Set(), t.set(e, n)), n;
     }
     _getShaderStage(e) {
         const t = this.shaderCache;
         let n = t.get(e);
-        return n === void 0 && (n = new Rg(e), t.set(e, n)), n;
+        return n === void 0 && (n = new T0(e), t.set(e, n)), n;
     }
 }
-class Rg {
+class T0 {
     constructor(e) {
-        this.id = wg++, this.code = e, this.usedTimes = 0;
+        this.id = E0++, this.code = e, this.usedTimes = 0;
     }
 }
 
-function Pg(i, e, t, n, r, s, a) {
-    const o = new Zl(),
-        l = new Cg(),
+function b0(s, e, t, n, i, r, o) {
+    const a = new Xc(),
+        l = new A0(),
         c = /* @__PURE__ */ new Set(),
         u = [],
-        f = r.isWebGL2,
-        h = r.logarithmicDepthBuffer,
-        p = r.vertexTextures;
-    let g = r.precision;
-    const v = {
+        d = i.isWebGL2,
+        f = i.logarithmicDepthBuffer,
+        h = i.vertexTextures;
+    let g = i.precision;
+    const _ = {
         MeshDepthMaterial: "depth",
         MeshDistanceMaterial: "distanceRGBA",
         MeshNormalMaterial: "normal",
         MeshBasicMaterial: "basic",
         MeshLambertMaterial: "lambert",
         MeshPhongMaterial: "phong",
         MeshToonMaterial: "toon",
@@ -13877,496 +13905,496 @@
         LineBasicMaterial: "basic",
         LineDashedMaterial: "dashed",
         PointsMaterial: "points",
         ShadowMaterial: "shadow",
         SpriteMaterial: "sprite"
     };
 
-    function m(S) {
-        return c.add(S), S === 0 ? "uv" : `uv${S}`;
+    function m(x) {
+        return c.add(x), x === 0 ? "uv" : `uv${x}`;
     }
 
-    function d(S, T, Y, K, L) {
-        const N = K.fog,
-            O = L.geometry,
-            B = S.isMeshStandardMaterial ? K.environment : null,
-            j = (S.isMeshStandardMaterial ? t : e).get(S.envMap || B),
-            q = j && j.mapping === ss ? j.image.height : null,
-            J = v[S.type];
-        S.precision !== null && (g = r.getMaxPrecision(S.precision), g !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", g, "instead."));
-        const ne = O.morphAttributes.position || O.morphAttributes.normal || O.morphAttributes.color,
-            ue = ne !== void 0 ? ne.length : 0;
-        let Z = 0;
-        O.morphAttributes.position !== void 0 && (Z = 1), O.morphAttributes.normal !== void 0 && (Z = 2), O.morphAttributes.color !== void 0 && (Z = 3);
-        let H, ee, pe, Te;
-        if (J) {
-            const et = on[J];
-            H = et.vertexShader, ee = et.fragmentShader;
+    function p(x, A, U, N, P) {
+        const I = N.fog,
+            z = P.geometry,
+            K = x.isMeshStandardMaterial ? N.environment : null,
+            G = (x.isMeshStandardMaterial ? t : e).get(x.envMap || K),
+            q = G && G.mapping === Fr ? G.image.height : null,
+            Q = _[x.type];
+        x.precision !== null && (g = i.getMaxPrecision(x.precision), g !== x.precision && console.warn("THREE.WebGLProgram.getParameters:", x.precision, "not supported, using", g, "instead."));
+        const te = z.morphAttributes.position || z.morphAttributes.normal || z.morphAttributes.color,
+            fe = te !== void 0 ? te.length : 0;
+        let ne = 0;
+        z.morphAttributes.position !== void 0 && (ne = 1), z.morphAttributes.normal !== void 0 && (ne = 2), z.morphAttributes.color !== void 0 && (ne = 3);
+        let V, J, se, Ae;
+        if (Q) {
+            const it = mn[Q];
+            V = it.vertexShader, J = it.fragmentShader;
         } else
-            H = S.vertexShader, ee = S.fragmentShader, l.update(S), pe = l.getVertexShaderID(S), Te = l.getFragmentShaderID(S);
-        const xe = i.getRenderTarget(),
-            ge = L.isInstancedMesh === !0,
-            Ke = L.isBatchedMesh === !0,
-            we = !!S.map,
-            F = !!S.matcap,
-            lt = !!j,
-            Me = !!S.aoMap,
-            Ne = !!S.lightMap,
-            ye = !!S.bumpMap,
-            qe = !!S.normalMap,
-            Ie = !!S.displacementMap,
-            Be = !!S.emissiveMap,
-            Je = !!S.metalnessMap,
-            w = !!S.roughnessMap,
-            x = S.anisotropy > 0,
-            X = S.clearcoat > 0,
-            Q = S.iridescence > 0,
-            te = S.sheen > 0,
-            $ = S.transmission > 0,
-            Le = x && !!S.anisotropyMap,
-            Ae = X && !!S.clearcoatMap,
-            se = X && !!S.clearcoatNormalMap,
-            ce = X && !!S.clearcoatRoughnessMap,
-            Re = Q && !!S.iridescenceMap,
-            C = Q && !!S.iridescenceThicknessMap,
-            le = te && !!S.sheenColorMap,
-            ve = te && !!S.sheenRoughnessMap,
-            fe = !!S.specularMap,
-            he = !!S.specularColorMap,
-            _e = !!S.specularIntensityMap,
-            De = $ && !!S.transmissionMap,
-            Ue = $ && !!S.thicknessMap,
-            $e = !!S.gradientMap,
-            D = !!S.alphaMap,
-            re = S.alphaTest > 0,
-            z = !!S.alphaHash,
-            ie = !!S.extensions;
-        let ae = kn;
-        S.toneMapped && (xe === null || xe.isXRRenderTarget === !0) && (ae = i.toneMapping);
-        const Oe = {
-            isWebGL2: f,
-            shaderID: J,
-            shaderType: S.type,
-            shaderName: S.name,
-            vertexShader: H,
-            fragmentShader: ee,
-            defines: S.defines,
-            customVertexShaderID: pe,
-            customFragmentShaderID: Te,
-            isRawShaderMaterial: S.isRawShaderMaterial === !0,
-            glslVersion: S.glslVersion,
+            V = x.vertexShader, J = x.fragmentShader, l.update(x), se = l.getVertexShaderID(x), Ae = l.getFragmentShaderID(x);
+        const xe = s.getRenderTarget(),
+            ge = P.isInstancedMesh === !0,
+            Qe = P.isBatchedMesh === !0,
+            Re = !!x.map,
+            O = !!x.matcap,
+            Je = !!G,
+            Te = !!x.aoMap,
+            Ie = !!x.lightMap,
+            Me = !!x.bumpMap,
+            ze = !!x.normalMap,
+            Oe = !!x.displacementMap,
+            we = !!x.emissiveMap,
+            Ke = !!x.metalnessMap,
+            w = !!x.roughnessMap,
+            M = x.anisotropy > 0,
+            k = x.clearcoat > 0,
+            Z = x.iridescence > 0,
+            re = x.sheen > 0,
+            ie = x.transmission > 0,
+            Be = M && !!x.anisotropyMap,
+            Pe = k && !!x.clearcoatMap,
+            oe = k && !!x.clearcoatNormalMap,
+            de = k && !!x.clearcoatRoughnessMap,
+            De = Z && !!x.iridescenceMap,
+            R = Z && !!x.iridescenceThicknessMap,
+            ue = re && !!x.sheenColorMap,
+            Se = re && !!x.sheenRoughnessMap,
+            me = !!x.specularMap,
+            _e = !!x.specularColorMap,
+            ve = !!x.specularIntensityMap,
+            Le = ie && !!x.transmissionMap,
+            Ne = ie && !!x.thicknessMap,
+            nt = !!x.gradientMap,
+            F = !!x.alphaMap,
+            ce = x.alphaTest > 0,
+            W = !!x.alphaHash,
+            ae = !!x.extensions;
+        let pe = $n;
+        x.toneMapped && (xe === null || xe.isXRRenderTarget === !0) && (pe = s.toneMapping);
+        const Ve = {
+            isWebGL2: d,
+            shaderID: Q,
+            shaderType: x.type,
+            shaderName: x.name,
+            vertexShader: V,
+            fragmentShader: J,
+            defines: x.defines,
+            customVertexShaderID: se,
+            customFragmentShaderID: Ae,
+            isRawShaderMaterial: x.isRawShaderMaterial === !0,
+            glslVersion: x.glslVersion,
             precision: g,
-            batching: Ke,
+            batching: Qe,
             instancing: ge,
-            instancingColor: ge && L.instanceColor !== null,
-            instancingMorph: ge && L.morphTexture !== null,
-            supportsVertexTextures: p,
-            outputColorSpace: xe === null ? i.outputColorSpace : xe.isXRRenderTarget === !0 ? xe.texture.colorSpace : Wn,
-            alphaToCoverage: !!S.alphaToCoverage,
-            map: we,
-            matcap: F,
-            envMap: lt,
-            envMapMode: lt && j.mapping,
+            instancingColor: ge && P.instanceColor !== null,
+            instancingMorph: ge && P.morphTexture !== null,
+            supportsVertexTextures: h,
+            outputColorSpace: xe === null ? s.outputColorSpace : xe.isXRRenderTarget === !0 ? xe.texture.colorSpace : ni,
+            alphaToCoverage: !!x.alphaToCoverage,
+            map: Re,
+            matcap: O,
+            envMap: Je,
+            envMapMode: Je && G.mapping,
             envMapCubeUVHeight: q,
-            aoMap: Me,
-            lightMap: Ne,
-            bumpMap: ye,
-            normalMap: qe,
-            displacementMap: p && Ie,
-            emissiveMap: Be,
-            normalMapObjectSpace: qe && S.normalMapType === xf,
-            normalMapTangentSpace: qe && S.normalMapType === vf,
-            metalnessMap: Je,
+            aoMap: Te,
+            lightMap: Ie,
+            bumpMap: Me,
+            normalMap: ze,
+            displacementMap: h && Oe,
+            emissiveMap: we,
+            normalMapObjectSpace: ze && x.normalMapType === mf,
+            normalMapTangentSpace: ze && x.normalMapType === pf,
+            metalnessMap: Ke,
             roughnessMap: w,
-            anisotropy: x,
-            anisotropyMap: Le,
-            clearcoat: X,
-            clearcoatMap: Ae,
-            clearcoatNormalMap: se,
-            clearcoatRoughnessMap: ce,
-            iridescence: Q,
-            iridescenceMap: Re,
-            iridescenceThicknessMap: C,
-            sheen: te,
-            sheenColorMap: le,
-            sheenRoughnessMap: ve,
-            specularMap: fe,
-            specularColorMap: he,
-            specularIntensityMap: _e,
-            transmission: $,
-            transmissionMap: De,
-            thicknessMap: Ue,
-            gradientMap: $e,
-            opaque: S.transparent === !1 && S.blending === ri && S.alphaToCoverage === !1,
-            alphaMap: D,
-            alphaTest: re,
-            alphaHash: z,
-            combine: S.combine,
+            anisotropy: M,
+            anisotropyMap: Be,
+            clearcoat: k,
+            clearcoatMap: Pe,
+            clearcoatNormalMap: oe,
+            clearcoatRoughnessMap: de,
+            iridescence: Z,
+            iridescenceMap: De,
+            iridescenceThicknessMap: R,
+            sheen: re,
+            sheenColorMap: ue,
+            sheenRoughnessMap: Se,
+            specularMap: me,
+            specularColorMap: _e,
+            specularIntensityMap: ve,
+            transmission: ie,
+            transmissionMap: Le,
+            thicknessMap: Ne,
+            gradientMap: nt,
+            opaque: x.transparent === !1 && x.blending === Si && x.alphaToCoverage === !1,
+            alphaMap: F,
+            alphaTest: ce,
+            alphaHash: W,
+            combine: x.combine,
             //
-            mapUv: we && m(S.map.channel),
-            aoMapUv: Me && m(S.aoMap.channel),
-            lightMapUv: Ne && m(S.lightMap.channel),
-            bumpMapUv: ye && m(S.bumpMap.channel),
-            normalMapUv: qe && m(S.normalMap.channel),
-            displacementMapUv: Ie && m(S.displacementMap.channel),
-            emissiveMapUv: Be && m(S.emissiveMap.channel),
-            metalnessMapUv: Je && m(S.metalnessMap.channel),
-            roughnessMapUv: w && m(S.roughnessMap.channel),
-            anisotropyMapUv: Le && m(S.anisotropyMap.channel),
-            clearcoatMapUv: Ae && m(S.clearcoatMap.channel),
-            clearcoatNormalMapUv: se && m(S.clearcoatNormalMap.channel),
-            clearcoatRoughnessMapUv: ce && m(S.clearcoatRoughnessMap.channel),
-            iridescenceMapUv: Re && m(S.iridescenceMap.channel),
-            iridescenceThicknessMapUv: C && m(S.iridescenceThicknessMap.channel),
-            sheenColorMapUv: le && m(S.sheenColorMap.channel),
-            sheenRoughnessMapUv: ve && m(S.sheenRoughnessMap.channel),
-            specularMapUv: fe && m(S.specularMap.channel),
-            specularColorMapUv: he && m(S.specularColorMap.channel),
-            specularIntensityMapUv: _e && m(S.specularIntensityMap.channel),
-            transmissionMapUv: De && m(S.transmissionMap.channel),
-            thicknessMapUv: Ue && m(S.thicknessMap.channel),
-            alphaMapUv: D && m(S.alphaMap.channel),
+            mapUv: Re && m(x.map.channel),
+            aoMapUv: Te && m(x.aoMap.channel),
+            lightMapUv: Ie && m(x.lightMap.channel),
+            bumpMapUv: Me && m(x.bumpMap.channel),
+            normalMapUv: ze && m(x.normalMap.channel),
+            displacementMapUv: Oe && m(x.displacementMap.channel),
+            emissiveMapUv: we && m(x.emissiveMap.channel),
+            metalnessMapUv: Ke && m(x.metalnessMap.channel),
+            roughnessMapUv: w && m(x.roughnessMap.channel),
+            anisotropyMapUv: Be && m(x.anisotropyMap.channel),
+            clearcoatMapUv: Pe && m(x.clearcoatMap.channel),
+            clearcoatNormalMapUv: oe && m(x.clearcoatNormalMap.channel),
+            clearcoatRoughnessMapUv: de && m(x.clearcoatRoughnessMap.channel),
+            iridescenceMapUv: De && m(x.iridescenceMap.channel),
+            iridescenceThicknessMapUv: R && m(x.iridescenceThicknessMap.channel),
+            sheenColorMapUv: ue && m(x.sheenColorMap.channel),
+            sheenRoughnessMapUv: Se && m(x.sheenRoughnessMap.channel),
+            specularMapUv: me && m(x.specularMap.channel),
+            specularColorMapUv: _e && m(x.specularColorMap.channel),
+            specularIntensityMapUv: ve && m(x.specularIntensityMap.channel),
+            transmissionMapUv: Le && m(x.transmissionMap.channel),
+            thicknessMapUv: Ne && m(x.thicknessMap.channel),
+            alphaMapUv: F && m(x.alphaMap.channel),
             //
-            vertexTangents: !!O.attributes.tangent && (qe || x),
-            vertexColors: S.vertexColors,
-            vertexAlphas: S.vertexColors === !0 && !!O.attributes.color && O.attributes.color.itemSize === 4,
-            pointsUvs: L.isPoints === !0 && !!O.attributes.uv && (we || D),
-            fog: !!N,
-            useFog: S.fog === !0,
-            fogExp2: !!N && N.isFogExp2,
-            flatShading: S.flatShading === !0,
-            sizeAttenuation: S.sizeAttenuation === !0,
-            logarithmicDepthBuffer: h,
-            skinning: L.isSkinnedMesh === !0,
-            morphTargets: O.morphAttributes.position !== void 0,
-            morphNormals: O.morphAttributes.normal !== void 0,
-            morphColors: O.morphAttributes.color !== void 0,
-            morphTargetsCount: ue,
-            morphTextureStride: Z,
-            numDirLights: T.directional.length,
-            numPointLights: T.point.length,
-            numSpotLights: T.spot.length,
-            numSpotLightMaps: T.spotLightMap.length,
-            numRectAreaLights: T.rectArea.length,
-            numHemiLights: T.hemi.length,
-            numDirLightShadows: T.directionalShadowMap.length,
-            numPointLightShadows: T.pointShadowMap.length,
-            numSpotLightShadows: T.spotShadowMap.length,
-            numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
-            numLightProbes: T.numLightProbes,
-            numClippingPlanes: a.numPlanes,
-            numClipIntersection: a.numIntersection,
-            dithering: S.dithering,
-            shadowMapEnabled: i.shadowMap.enabled && Y.length > 0,
-            shadowMapType: i.shadowMap.type,
-            toneMapping: ae,
-            useLegacyLights: i._useLegacyLights,
-            decodeVideoTexture: we && S.map.isVideoTexture === !0 && Ze.getTransfer(S.map.colorSpace) === nt,
-            premultipliedAlpha: S.premultipliedAlpha,
-            doubleSided: S.side === en,
-            flipSided: S.side === Pt,
-            useDepthPacking: S.depthPacking >= 0,
-            depthPacking: S.depthPacking || 0,
-            index0AttributeName: S.index0AttributeName,
-            extensionDerivatives: ie && S.extensions.derivatives === !0,
-            extensionFragDepth: ie && S.extensions.fragDepth === !0,
-            extensionDrawBuffers: ie && S.extensions.drawBuffers === !0,
-            extensionShaderTextureLOD: ie && S.extensions.shaderTextureLOD === !0,
-            extensionClipCullDistance: ie && S.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
-            extensionMultiDraw: ie && S.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
-            rendererExtensionFragDepth: f || n.has("EXT_frag_depth"),
-            rendererExtensionDrawBuffers: f || n.has("WEBGL_draw_buffers"),
-            rendererExtensionShaderTextureLod: f || n.has("EXT_shader_texture_lod"),
+            vertexTangents: !!z.attributes.tangent && (ze || M),
+            vertexColors: x.vertexColors,
+            vertexAlphas: x.vertexColors === !0 && !!z.attributes.color && z.attributes.color.itemSize === 4,
+            pointsUvs: P.isPoints === !0 && !!z.attributes.uv && (Re || F),
+            fog: !!I,
+            useFog: x.fog === !0,
+            fogExp2: !!I && I.isFogExp2,
+            flatShading: x.flatShading === !0,
+            sizeAttenuation: x.sizeAttenuation === !0,
+            logarithmicDepthBuffer: f,
+            skinning: P.isSkinnedMesh === !0,
+            morphTargets: z.morphAttributes.position !== void 0,
+            morphNormals: z.morphAttributes.normal !== void 0,
+            morphColors: z.morphAttributes.color !== void 0,
+            morphTargetsCount: fe,
+            morphTextureStride: ne,
+            numDirLights: A.directional.length,
+            numPointLights: A.point.length,
+            numSpotLights: A.spot.length,
+            numSpotLightMaps: A.spotLightMap.length,
+            numRectAreaLights: A.rectArea.length,
+            numHemiLights: A.hemi.length,
+            numDirLightShadows: A.directionalShadowMap.length,
+            numPointLightShadows: A.pointShadowMap.length,
+            numSpotLightShadows: A.spotShadowMap.length,
+            numSpotLightShadowsWithMaps: A.numSpotLightShadowsWithMaps,
+            numLightProbes: A.numLightProbes,
+            numClippingPlanes: o.numPlanes,
+            numClipIntersection: o.numIntersection,
+            dithering: x.dithering,
+            shadowMapEnabled: s.shadowMap.enabled && U.length > 0,
+            shadowMapType: s.shadowMap.type,
+            toneMapping: pe,
+            useLegacyLights: s._useLegacyLights,
+            decodeVideoTexture: Re && x.map.isVideoTexture === !0 && tt.getTransfer(x.map.colorSpace) === at,
+            premultipliedAlpha: x.premultipliedAlpha,
+            doubleSided: x.side === un,
+            flipSided: x.side === zt,
+            useDepthPacking: x.depthPacking >= 0,
+            depthPacking: x.depthPacking || 0,
+            index0AttributeName: x.index0AttributeName,
+            extensionDerivatives: ae && x.extensions.derivatives === !0,
+            extensionFragDepth: ae && x.extensions.fragDepth === !0,
+            extensionDrawBuffers: ae && x.extensions.drawBuffers === !0,
+            extensionShaderTextureLOD: ae && x.extensions.shaderTextureLOD === !0,
+            extensionClipCullDistance: ae && x.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
+            extensionMultiDraw: ae && x.extensions.multiDraw === !0 && n.has("WEBGL_multi_draw"),
+            rendererExtensionFragDepth: d || n.has("EXT_frag_depth"),
+            rendererExtensionDrawBuffers: d || n.has("WEBGL_draw_buffers"),
+            rendererExtensionShaderTextureLod: d || n.has("EXT_shader_texture_lod"),
             rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
-            customProgramCacheKey: S.customProgramCacheKey()
+            customProgramCacheKey: x.customProgramCacheKey()
         };
-        return Oe.vertexUv1s = c.has(1), Oe.vertexUv2s = c.has(2), Oe.vertexUv3s = c.has(3), c.clear(), Oe;
+        return Ve.vertexUv1s = c.has(1), Ve.vertexUv2s = c.has(2), Ve.vertexUv3s = c.has(3), c.clear(), Ve;
     }
 
-    function M(S) {
-        const T = [];
-        if (S.shaderID ? T.push(S.shaderID) : (T.push(S.customVertexShaderID), T.push(S.customFragmentShaderID)), S.defines !== void 0)
-            for (const Y in S.defines)
-                T.push(Y), T.push(S.defines[Y]);
-        return S.isRawShaderMaterial === !1 && (_(T, S), A(T, S), T.push(i.outputColorSpace)), T.push(S.customProgramCacheKey), T.join();
+    function v(x) {
+        const A = [];
+        if (x.shaderID ? A.push(x.shaderID) : (A.push(x.customVertexShaderID), A.push(x.customFragmentShaderID)), x.defines !== void 0)
+            for (const U in x.defines)
+                A.push(U), A.push(x.defines[U]);
+        return x.isRawShaderMaterial === !1 && (S(A, x), y(A, x), A.push(s.outputColorSpace)), A.push(x.customProgramCacheKey), A.join();
     }
 
-    function _(S, T) {
-        S.push(T.precision), S.push(T.outputColorSpace), S.push(T.envMapMode), S.push(T.envMapCubeUVHeight), S.push(T.mapUv), S.push(T.alphaMapUv), S.push(T.lightMapUv), S.push(T.aoMapUv), S.push(T.bumpMapUv), S.push(T.normalMapUv), S.push(T.displacementMapUv), S.push(T.emissiveMapUv), S.push(T.metalnessMapUv), S.push(T.roughnessMapUv), S.push(T.anisotropyMapUv), S.push(T.clearcoatMapUv), S.push(T.clearcoatNormalMapUv), S.push(T.clearcoatRoughnessMapUv), S.push(T.iridescenceMapUv), S.push(T.iridescenceThicknessMapUv), S.push(T.sheenColorMapUv), S.push(T.sheenRoughnessMapUv), S.push(T.specularMapUv), S.push(T.specularColorMapUv), S.push(T.specularIntensityMapUv), S.push(T.transmissionMapUv), S.push(T.thicknessMapUv), S.push(T.combine), S.push(T.fogExp2), S.push(T.sizeAttenuation), S.push(T.morphTargetsCount), S.push(T.morphAttributeCount), S.push(T.numDirLights), S.push(T.numPointLights), S.push(T.numSpotLights), S.push(T.numSpotLightMaps), S.push(T.numHemiLights), S.push(T.numRectAreaLights), S.push(T.numDirLightShadows), S.push(T.numPointLightShadows), S.push(T.numSpotLightShadows), S.push(T.numSpotLightShadowsWithMaps), S.push(T.numLightProbes), S.push(T.shadowMapType), S.push(T.toneMapping), S.push(T.numClippingPlanes), S.push(T.numClipIntersection), S.push(T.depthPacking);
+    function S(x, A) {
+        x.push(A.precision), x.push(A.outputColorSpace), x.push(A.envMapMode), x.push(A.envMapCubeUVHeight), x.push(A.mapUv), x.push(A.alphaMapUv), x.push(A.lightMapUv), x.push(A.aoMapUv), x.push(A.bumpMapUv), x.push(A.normalMapUv), x.push(A.displacementMapUv), x.push(A.emissiveMapUv), x.push(A.metalnessMapUv), x.push(A.roughnessMapUv), x.push(A.anisotropyMapUv), x.push(A.clearcoatMapUv), x.push(A.clearcoatNormalMapUv), x.push(A.clearcoatRoughnessMapUv), x.push(A.iridescenceMapUv), x.push(A.iridescenceThicknessMapUv), x.push(A.sheenColorMapUv), x.push(A.sheenRoughnessMapUv), x.push(A.specularMapUv), x.push(A.specularColorMapUv), x.push(A.specularIntensityMapUv), x.push(A.transmissionMapUv), x.push(A.thicknessMapUv), x.push(A.combine), x.push(A.fogExp2), x.push(A.sizeAttenuation), x.push(A.morphTargetsCount), x.push(A.morphAttributeCount), x.push(A.numDirLights), x.push(A.numPointLights), x.push(A.numSpotLights), x.push(A.numSpotLightMaps), x.push(A.numHemiLights), x.push(A.numRectAreaLights), x.push(A.numDirLightShadows), x.push(A.numPointLightShadows), x.push(A.numSpotLightShadows), x.push(A.numSpotLightShadowsWithMaps), x.push(A.numLightProbes), x.push(A.shadowMapType), x.push(A.toneMapping), x.push(A.numClippingPlanes), x.push(A.numClipIntersection), x.push(A.depthPacking);
     }
 
-    function A(S, T) {
-        o.disableAll(), T.isWebGL2 && o.enable(0), T.supportsVertexTextures && o.enable(1), T.instancing && o.enable(2), T.instancingColor && o.enable(3), T.instancingMorph && o.enable(4), T.matcap && o.enable(5), T.envMap && o.enable(6), T.normalMapObjectSpace && o.enable(7), T.normalMapTangentSpace && o.enable(8), T.clearcoat && o.enable(9), T.iridescence && o.enable(10), T.alphaTest && o.enable(11), T.vertexColors && o.enable(12), T.vertexAlphas && o.enable(13), T.vertexUv1s && o.enable(14), T.vertexUv2s && o.enable(15), T.vertexUv3s && o.enable(16), T.vertexTangents && o.enable(17), T.anisotropy && o.enable(18), T.alphaHash && o.enable(19), T.batching && o.enable(20), S.push(o.mask), o.disableAll(), T.fog && o.enable(0), T.useFog && o.enable(1), T.flatShading && o.enable(2), T.logarithmicDepthBuffer && o.enable(3), T.skinning && o.enable(4), T.morphTargets && o.enable(5), T.morphNormals && o.enable(6), T.morphColors && o.enable(7), T.premultipliedAlpha && o.enable(8), T.shadowMapEnabled && o.enable(9), T.useLegacyLights && o.enable(10), T.doubleSided && o.enable(11), T.flipSided && o.enable(12), T.useDepthPacking && o.enable(13), T.dithering && o.enable(14), T.transmission && o.enable(15), T.sheen && o.enable(16), T.opaque && o.enable(17), T.pointsUvs && o.enable(18), T.decodeVideoTexture && o.enable(19), T.alphaToCoverage && o.enable(20), S.push(o.mask);
+    function y(x, A) {
+        a.disableAll(), A.isWebGL2 && a.enable(0), A.supportsVertexTextures && a.enable(1), A.instancing && a.enable(2), A.instancingColor && a.enable(3), A.instancingMorph && a.enable(4), A.matcap && a.enable(5), A.envMap && a.enable(6), A.normalMapObjectSpace && a.enable(7), A.normalMapTangentSpace && a.enable(8), A.clearcoat && a.enable(9), A.iridescence && a.enable(10), A.alphaTest && a.enable(11), A.vertexColors && a.enable(12), A.vertexAlphas && a.enable(13), A.vertexUv1s && a.enable(14), A.vertexUv2s && a.enable(15), A.vertexUv3s && a.enable(16), A.vertexTangents && a.enable(17), A.anisotropy && a.enable(18), A.alphaHash && a.enable(19), A.batching && a.enable(20), x.push(a.mask), a.disableAll(), A.fog && a.enable(0), A.useFog && a.enable(1), A.flatShading && a.enable(2), A.logarithmicDepthBuffer && a.enable(3), A.skinning && a.enable(4), A.morphTargets && a.enable(5), A.morphNormals && a.enable(6), A.morphColors && a.enable(7), A.premultipliedAlpha && a.enable(8), A.shadowMapEnabled && a.enable(9), A.useLegacyLights && a.enable(10), A.doubleSided && a.enable(11), A.flipSided && a.enable(12), A.useDepthPacking && a.enable(13), A.dithering && a.enable(14), A.transmission && a.enable(15), A.sheen && a.enable(16), A.opaque && a.enable(17), A.pointsUvs && a.enable(18), A.decodeVideoTexture && a.enable(19), A.alphaToCoverage && a.enable(20), x.push(a.mask);
     }
 
-    function R(S) {
-        const T = v[S.type];
-        let Y;
-        if (T) {
-            const K = on[T];
-            Y = uh.clone(K.uniforms);
+    function b(x) {
+        const A = _[x.type];
+        let U;
+        if (A) {
+            const N = mn[A];
+            U = ah.clone(N.uniforms);
         } else
-            Y = S.uniforms;
-        return Y;
+            U = x.uniforms;
+        return U;
     }
 
-    function E(S, T) {
-        let Y;
-        for (let K = 0, L = u.length; K < L; K++) {
-            const N = u[K];
-            if (N.cacheKey === T) {
-                Y = N, ++Y.usedTimes;
+    function E(x, A) {
+        let U;
+        for (let N = 0, P = u.length; N < P; N++) {
+            const I = u[N];
+            if (I.cacheKey === A) {
+                U = I, ++U.usedTimes;
                 break;
             }
         }
-        return Y === void 0 && (Y = new Tg(i, T, S, s), u.push(Y)), Y;
+        return U === void 0 && (U = new M0(s, A, x, r), u.push(U)), U;
     }
 
-    function b(S) {
-        if (--S.usedTimes === 0) {
-            const T = u.indexOf(S);
-            u[T] = u[u.length - 1], u.pop(), S.destroy();
+    function T(x) {
+        if (--x.usedTimes === 0) {
+            const A = u.indexOf(x);
+            u[A] = u[u.length - 1], u.pop(), x.destroy();
         }
     }
 
-    function I(S) {
-        l.remove(S);
+    function L(x) {
+        l.remove(x);
     }
 
-    function W() {
+    function B() {
         l.dispose();
     }
     return {
-        getParameters: d,
-        getProgramCacheKey: M,
-        getUniforms: R,
+        getParameters: p,
+        getProgramCacheKey: v,
+        getUniforms: b,
         acquireProgram: E,
-        releaseProgram: b,
-        releaseShaderCache: I,
+        releaseProgram: T,
+        releaseShaderCache: L,
         // Exposed for resource monitoring & error feedback via renderer.info:
         programs: u,
-        dispose: W
+        dispose: B
     };
 }
 
-function Lg() {
-    let i = /* @__PURE__ */ new WeakMap();
+function C0() {
+    let s = /* @__PURE__ */ new WeakMap();
 
-    function e(s) {
-        let a = i.get(s);
-        return a === void 0 && (a = {}, i.set(s, a)), a;
+    function e(r) {
+        let o = s.get(r);
+        return o === void 0 && (o = {}, s.set(r, o)), o;
     }
 
-    function t(s) {
-        i.delete(s);
+    function t(r) {
+        s.delete(r);
     }
 
-    function n(s, a, o) {
-        i.get(s)[a] = o;
+    function n(r, o, a) {
+        s.get(r)[o] = a;
     }
 
-    function r() {
-        i = /* @__PURE__ */ new WeakMap();
+    function i() {
+        s = /* @__PURE__ */ new WeakMap();
     }
     return {
         get: e,
         remove: t,
         update: n,
-        dispose: r
+        dispose: i
     };
 }
 
-function Dg(i, e) {
-    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.material.id !== e.material.id ? i.material.id - e.material.id : i.z !== e.z ? i.z - e.z : i.id - e.id;
+function w0(s, e) {
+    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id;
 }
 
-function $a(i, e) {
-    return i.groupOrder !== e.groupOrder ? i.groupOrder - e.groupOrder : i.renderOrder !== e.renderOrder ? i.renderOrder - e.renderOrder : i.z !== e.z ? e.z - i.z : i.id - e.id;
+function Hl(s, e) {
+    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id;
 }
 
-function el() {
-    const i = [];
+function Gl() {
+    const s = [];
     let e = 0;
     const t = [],
         n = [],
-        r = [];
+        i = [];
 
-    function s() {
-        e = 0, t.length = 0, n.length = 0, r.length = 0;
+    function r() {
+        e = 0, t.length = 0, n.length = 0, i.length = 0;
     }
 
-    function a(f, h, p, g, v, m) {
-        let d = i[e];
-        return d === void 0 ? (d = {
-            id: f.id,
-            object: f,
-            geometry: h,
-            material: p,
+    function o(d, f, h, g, _, m) {
+        let p = s[e];
+        return p === void 0 ? (p = {
+            id: d.id,
+            object: d,
+            geometry: f,
+            material: h,
             groupOrder: g,
-            renderOrder: f.renderOrder,
-            z: v,
+            renderOrder: d.renderOrder,
+            z: _,
             group: m
-        }, i[e] = d) : (d.id = f.id, d.object = f, d.geometry = h, d.material = p, d.groupOrder = g, d.renderOrder = f.renderOrder, d.z = v, d.group = m), e++, d;
+        }, s[e] = p) : (p.id = d.id, p.object = d, p.geometry = f, p.material = h, p.groupOrder = g, p.renderOrder = d.renderOrder, p.z = _, p.group = m), e++, p;
     }
 
-    function o(f, h, p, g, v, m) {
-        const d = a(f, h, p, g, v, m);
-        p.transmission > 0 ? n.push(d) : p.transparent === !0 ? r.push(d) : t.push(d);
+    function a(d, f, h, g, _, m) {
+        const p = o(d, f, h, g, _, m);
+        h.transmission > 0 ? n.push(p) : h.transparent === !0 ? i.push(p) : t.push(p);
     }
 
-    function l(f, h, p, g, v, m) {
-        const d = a(f, h, p, g, v, m);
-        p.transmission > 0 ? n.unshift(d) : p.transparent === !0 ? r.unshift(d) : t.unshift(d);
+    function l(d, f, h, g, _, m) {
+        const p = o(d, f, h, g, _, m);
+        h.transmission > 0 ? n.unshift(p) : h.transparent === !0 ? i.unshift(p) : t.unshift(p);
     }
 
-    function c(f, h) {
-        t.length > 1 && t.sort(f || Dg), n.length > 1 && n.sort(h || $a), r.length > 1 && r.sort(h || $a);
+    function c(d, f) {
+        t.length > 1 && t.sort(d || w0), n.length > 1 && n.sort(f || Hl), i.length > 1 && i.sort(f || Hl);
     }
 
     function u() {
-        for (let f = e, h = i.length; f < h; f++) {
-            const p = i[f];
-            if (p.id === null)
+        for (let d = e, f = s.length; d < f; d++) {
+            const h = s[d];
+            if (h.id === null)
                 break;
-            p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
+            h.id = null, h.object = null, h.geometry = null, h.material = null, h.group = null;
         }
     }
     return {
         opaque: t,
         transmissive: n,
-        transparent: r,
-        init: s,
-        push: o,
+        transparent: i,
+        init: r,
+        push: a,
         unshift: l,
         finish: u,
         sort: c
     };
 }
 
-function Ig() {
-    let i = /* @__PURE__ */ new WeakMap();
+function R0() {
+    let s = /* @__PURE__ */ new WeakMap();
 
-    function e(n, r) {
-        const s = i.get(n);
-        let a;
-        return s === void 0 ? (a = new el(), i.set(n, [a])) : r >= s.length ? (a = new el(), s.push(a)) : a = s[r], a;
+    function e(n, i) {
+        const r = s.get(n);
+        let o;
+        return r === void 0 ? (o = new Gl(), s.set(n, [o])) : i >= r.length ? (o = new Gl(), r.push(o)) : o = r[i], o;
     }
 
     function t() {
-        i = /* @__PURE__ */ new WeakMap();
+        s = /* @__PURE__ */ new WeakMap();
     }
     return {
         get: e,
         dispose: t
     };
 }
 
-function Ug() {
-    const i = {};
+function P0() {
+    const s = {};
     return {
         get: function(e) {
-            if (i[e.id] !== void 0)
-                return i[e.id];
+            if (s[e.id] !== void 0)
+                return s[e.id];
             let t;
             switch (e.type) {
                 case "DirectionalLight":
                     t = {
-                        direction: new P(),
-                        color: new Qe()
+                        direction: new D(),
+                        color: new et()
                     };
                     break;
                 case "SpotLight":
                     t = {
-                        position: new P(),
-                        direction: new P(),
-                        color: new Qe(),
+                        position: new D(),
+                        direction: new D(),
+                        color: new et(),
                         distance: 0,
                         coneCos: 0,
                         penumbraCos: 0,
                         decay: 0
                     };
                     break;
                 case "PointLight":
                     t = {
-                        position: new P(),
-                        color: new Qe(),
+                        position: new D(),
+                        color: new et(),
                         distance: 0,
                         decay: 0
                     };
                     break;
                 case "HemisphereLight":
                     t = {
-                        direction: new P(),
-                        skyColor: new Qe(),
-                        groundColor: new Qe()
+                        direction: new D(),
+                        skyColor: new et(),
+                        groundColor: new et()
                     };
                     break;
                 case "RectAreaLight":
                     t = {
-                        color: new Qe(),
-                        position: new P(),
-                        halfWidth: new P(),
-                        halfHeight: new P()
+                        color: new et(),
+                        position: new D(),
+                        halfWidth: new D(),
+                        halfHeight: new D()
                     };
                     break;
             }
-            return i[e.id] = t, t;
+            return s[e.id] = t, t;
         }
     };
 }
 
-function Fg() {
-    const i = {};
+function D0() {
+    const s = {};
     return {
         get: function(e) {
-            if (i[e.id] !== void 0)
-                return i[e.id];
+            if (s[e.id] !== void 0)
+                return s[e.id];
             let t;
             switch (e.type) {
                 case "DirectionalLight":
                     t = {
                         shadowBias: 0,
                         shadowNormalBias: 0,
                         shadowRadius: 1,
-                        shadowMapSize: new me()
+                        shadowMapSize: new Ee()
                     };
                     break;
                 case "SpotLight":
                     t = {
                         shadowBias: 0,
                         shadowNormalBias: 0,
                         shadowRadius: 1,
-                        shadowMapSize: new me()
+                        shadowMapSize: new Ee()
                     };
                     break;
                 case "PointLight":
                     t = {
                         shadowBias: 0,
                         shadowNormalBias: 0,
                         shadowRadius: 1,
-                        shadowMapSize: new me(),
+                        shadowMapSize: new Ee(),
                         shadowCameraNear: 1,
                         shadowCameraFar: 1e3
                     };
                     break;
             }
-            return i[e.id] = t, t;
+            return s[e.id] = t, t;
         }
     };
 }
-let Ng = 0;
+let L0 = 0;
 
-function Bg(i, e) {
-    return (e.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (i.map ? 1 : 0);
+function F0(s, e) {
+    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0);
 }
 
-function Og(i, e) {
-    const t = new Ug(),
-        n = Fg(),
-        r = {
+function I0(s, e) {
+    const t = new P0(),
+        n = D0(),
+        i = {
             version: 0,
             hash: {
                 directionalLength: -1,
                 pointLength: -1,
                 spotLength: -1,
                 rectAreaLength: -1,
                 hemiLength: -1,
@@ -14395,197 +14423,197 @@
             pointShadowMap: [],
             pointShadowMatrix: [],
             hemi: [],
             numSpotLightShadowsWithMaps: 0,
             numLightProbes: 0
         };
     for (let u = 0; u < 9; u++)
-        r.probe.push(new P());
-    const s = new P(),
-        a = new ke(),
-        o = new ke();
-
-    function l(u, f) {
-        let h = 0,
-            p = 0,
+        i.probe.push(new D());
+    const r = new D(),
+        o = new Ge(),
+        a = new Ge();
+
+    function l(u, d) {
+        let f = 0,
+            h = 0,
             g = 0;
-        for (let Y = 0; Y < 9; Y++)
-            r.probe[Y].set(0, 0, 0);
-        let v = 0,
+        for (let U = 0; U < 9; U++)
+            i.probe[U].set(0, 0, 0);
+        let _ = 0,
             m = 0,
-            d = 0,
-            M = 0,
-            _ = 0,
-            A = 0,
-            R = 0,
-            E = 0,
+            p = 0,
+            v = 0,
+            S = 0,
+            y = 0,
             b = 0,
-            I = 0,
-            W = 0;
-        u.sort(Bg);
-        const S = f === !0 ? Math.PI : 1;
-        for (let Y = 0, K = u.length; Y < K; Y++) {
-            const L = u[Y],
-                N = L.color,
-                O = L.intensity,
-                B = L.distance,
-                j = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
-            if (L.isAmbientLight)
-                h += N.r * O * S, p += N.g * O * S, g += N.b * O * S;
-            else if (L.isLightProbe) {
+            E = 0,
+            T = 0,
+            L = 0,
+            B = 0;
+        u.sort(F0);
+        const x = d === !0 ? Math.PI : 1;
+        for (let U = 0, N = u.length; U < N; U++) {
+            const P = u[U],
+                I = P.color,
+                z = P.intensity,
+                K = P.distance,
+                G = P.shadow && P.shadow.map ? P.shadow.map.texture : null;
+            if (P.isAmbientLight)
+                f += I.r * z * x, h += I.g * z * x, g += I.b * z * x;
+            else if (P.isLightProbe) {
                 for (let q = 0; q < 9; q++)
-                    r.probe[q].addScaledVector(L.sh.coefficients[q], O);
-                W++;
-            } else if (L.isDirectionalLight) {
-                const q = t.get(L);
-                if (q.color.copy(L.color).multiplyScalar(L.intensity * S), L.castShadow) {
-                    const J = L.shadow,
-                        ne = n.get(L);
-                    ne.shadowBias = J.bias, ne.shadowNormalBias = J.normalBias, ne.shadowRadius = J.radius, ne.shadowMapSize = J.mapSize, r.directionalShadow[v] = ne, r.directionalShadowMap[v] = j, r.directionalShadowMatrix[v] = L.shadow.matrix, A++;
-                }
-                r.directional[v] = q, v++;
-            } else if (L.isSpotLight) {
-                const q = t.get(L);
-                q.position.setFromMatrixPosition(L.matrixWorld), q.color.copy(N).multiplyScalar(O * S), q.distance = B, q.coneCos = Math.cos(L.angle), q.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), q.decay = L.decay, r.spot[d] = q;
-                const J = L.shadow;
-                if (L.map && (r.spotLightMap[b] = L.map, b++, J.updateMatrices(L), L.castShadow && I++), r.spotLightMatrix[d] = J.matrix, L.castShadow) {
-                    const ne = n.get(L);
-                    ne.shadowBias = J.bias, ne.shadowNormalBias = J.normalBias, ne.shadowRadius = J.radius, ne.shadowMapSize = J.mapSize, r.spotShadow[d] = ne, r.spotShadowMap[d] = j, E++;
-                }
-                d++;
-            } else if (L.isRectAreaLight) {
-                const q = t.get(L);
-                q.color.copy(N).multiplyScalar(O), q.halfWidth.set(L.width * 0.5, 0, 0), q.halfHeight.set(0, L.height * 0.5, 0), r.rectArea[M] = q, M++;
-            } else if (L.isPointLight) {
-                const q = t.get(L);
-                if (q.color.copy(L.color).multiplyScalar(L.intensity * S), q.distance = L.distance, q.decay = L.decay, L.castShadow) {
-                    const J = L.shadow,
-                        ne = n.get(L);
-                    ne.shadowBias = J.bias, ne.shadowNormalBias = J.normalBias, ne.shadowRadius = J.radius, ne.shadowMapSize = J.mapSize, ne.shadowCameraNear = J.camera.near, ne.shadowCameraFar = J.camera.far, r.pointShadow[m] = ne, r.pointShadowMap[m] = j, r.pointShadowMatrix[m] = L.shadow.matrix, R++;
-                }
-                r.point[m] = q, m++;
-            } else if (L.isHemisphereLight) {
-                const q = t.get(L);
-                q.skyColor.copy(L.color).multiplyScalar(O * S), q.groundColor.copy(L.groundColor).multiplyScalar(O * S), r.hemi[_] = q, _++;
-            }
-        }
-        M > 0 && (e.isWebGL2 ? i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = oe.LTC_FLOAT_1, r.rectAreaLTC2 = oe.LTC_FLOAT_2) : (r.rectAreaLTC1 = oe.LTC_HALF_1, r.rectAreaLTC2 = oe.LTC_HALF_2) : i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = oe.LTC_FLOAT_1, r.rectAreaLTC2 = oe.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = oe.LTC_HALF_1, r.rectAreaLTC2 = oe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = h, r.ambient[1] = p, r.ambient[2] = g;
-        const T = r.hash;
-        (T.directionalLength !== v || T.pointLength !== m || T.spotLength !== d || T.rectAreaLength !== M || T.hemiLength !== _ || T.numDirectionalShadows !== A || T.numPointShadows !== R || T.numSpotShadows !== E || T.numSpotMaps !== b || T.numLightProbes !== W) && (r.directional.length = v, r.spot.length = d, r.rectArea.length = M, r.point.length = m, r.hemi.length = _, r.directionalShadow.length = A, r.directionalShadowMap.length = A, r.pointShadow.length = R, r.pointShadowMap.length = R, r.spotShadow.length = E, r.spotShadowMap.length = E, r.directionalShadowMatrix.length = A, r.pointShadowMatrix.length = R, r.spotLightMatrix.length = E + b - I, r.spotLightMap.length = b, r.numSpotLightShadowsWithMaps = I, r.numLightProbes = W, T.directionalLength = v, T.pointLength = m, T.spotLength = d, T.rectAreaLength = M, T.hemiLength = _, T.numDirectionalShadows = A, T.numPointShadows = R, T.numSpotShadows = E, T.numSpotMaps = b, T.numLightProbes = W, r.version = Ng++);
-    }
-
-    function c(u, f) {
-        let h = 0,
-            p = 0,
+                    i.probe[q].addScaledVector(P.sh.coefficients[q], z);
+                B++;
+            } else if (P.isDirectionalLight) {
+                const q = t.get(P);
+                if (q.color.copy(P.color).multiplyScalar(P.intensity * x), P.castShadow) {
+                    const Q = P.shadow,
+                        te = n.get(P);
+                    te.shadowBias = Q.bias, te.shadowNormalBias = Q.normalBias, te.shadowRadius = Q.radius, te.shadowMapSize = Q.mapSize, i.directionalShadow[_] = te, i.directionalShadowMap[_] = G, i.directionalShadowMatrix[_] = P.shadow.matrix, y++;
+                }
+                i.directional[_] = q, _++;
+            } else if (P.isSpotLight) {
+                const q = t.get(P);
+                q.position.setFromMatrixPosition(P.matrixWorld), q.color.copy(I).multiplyScalar(z * x), q.distance = K, q.coneCos = Math.cos(P.angle), q.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), q.decay = P.decay, i.spot[p] = q;
+                const Q = P.shadow;
+                if (P.map && (i.spotLightMap[T] = P.map, T++, Q.updateMatrices(P), P.castShadow && L++), i.spotLightMatrix[p] = Q.matrix, P.castShadow) {
+                    const te = n.get(P);
+                    te.shadowBias = Q.bias, te.shadowNormalBias = Q.normalBias, te.shadowRadius = Q.radius, te.shadowMapSize = Q.mapSize, i.spotShadow[p] = te, i.spotShadowMap[p] = G, E++;
+                }
+                p++;
+            } else if (P.isRectAreaLight) {
+                const q = t.get(P);
+                q.color.copy(I).multiplyScalar(z), q.halfWidth.set(P.width * 0.5, 0, 0), q.halfHeight.set(0, P.height * 0.5, 0), i.rectArea[v] = q, v++;
+            } else if (P.isPointLight) {
+                const q = t.get(P);
+                if (q.color.copy(P.color).multiplyScalar(P.intensity * x), q.distance = P.distance, q.decay = P.decay, P.castShadow) {
+                    const Q = P.shadow,
+                        te = n.get(P);
+                    te.shadowBias = Q.bias, te.shadowNormalBias = Q.normalBias, te.shadowRadius = Q.radius, te.shadowMapSize = Q.mapSize, te.shadowCameraNear = Q.camera.near, te.shadowCameraFar = Q.camera.far, i.pointShadow[m] = te, i.pointShadowMap[m] = G, i.pointShadowMatrix[m] = P.shadow.matrix, b++;
+                }
+                i.point[m] = q, m++;
+            } else if (P.isHemisphereLight) {
+                const q = t.get(P);
+                q.skyColor.copy(P.color).multiplyScalar(z * x), q.groundColor.copy(P.groundColor).multiplyScalar(z * x), i.hemi[S] = q, S++;
+            }
+        }
+        v > 0 && (e.isWebGL2 ? s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = he.LTC_FLOAT_1, i.rectAreaLTC2 = he.LTC_FLOAT_2) : (i.rectAreaLTC1 = he.LTC_HALF_1, i.rectAreaLTC2 = he.LTC_HALF_2) : s.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = he.LTC_FLOAT_1, i.rectAreaLTC2 = he.LTC_FLOAT_2) : s.has("OES_texture_half_float_linear") === !0 ? (i.rectAreaLTC1 = he.LTC_HALF_1, i.rectAreaLTC2 = he.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), i.ambient[0] = f, i.ambient[1] = h, i.ambient[2] = g;
+        const A = i.hash;
+        (A.directionalLength !== _ || A.pointLength !== m || A.spotLength !== p || A.rectAreaLength !== v || A.hemiLength !== S || A.numDirectionalShadows !== y || A.numPointShadows !== b || A.numSpotShadows !== E || A.numSpotMaps !== T || A.numLightProbes !== B) && (i.directional.length = _, i.spot.length = p, i.rectArea.length = v, i.point.length = m, i.hemi.length = S, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = b, i.pointShadowMap.length = b, i.spotShadow.length = E, i.spotShadowMap.length = E, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = b, i.spotLightMatrix.length = E + T - L, i.spotLightMap.length = T, i.numSpotLightShadowsWithMaps = L, i.numLightProbes = B, A.directionalLength = _, A.pointLength = m, A.spotLength = p, A.rectAreaLength = v, A.hemiLength = S, A.numDirectionalShadows = y, A.numPointShadows = b, A.numSpotShadows = E, A.numSpotMaps = T, A.numLightProbes = B, i.version = L0++);
+    }
+
+    function c(u, d) {
+        let f = 0,
+            h = 0,
             g = 0,
-            v = 0,
+            _ = 0,
             m = 0;
-        const d = f.matrixWorldInverse;
-        for (let M = 0, _ = u.length; M < _; M++) {
-            const A = u[M];
-            if (A.isDirectionalLight) {
-                const R = r.directional[h];
-                R.direction.setFromMatrixPosition(A.matrixWorld), s.setFromMatrixPosition(A.target.matrixWorld), R.direction.sub(s), R.direction.transformDirection(d), h++;
-            } else if (A.isSpotLight) {
-                const R = r.spot[g];
-                R.position.setFromMatrixPosition(A.matrixWorld), R.position.applyMatrix4(d), R.direction.setFromMatrixPosition(A.matrixWorld), s.setFromMatrixPosition(A.target.matrixWorld), R.direction.sub(s), R.direction.transformDirection(d), g++;
-            } else if (A.isRectAreaLight) {
-                const R = r.rectArea[v];
-                R.position.setFromMatrixPosition(A.matrixWorld), R.position.applyMatrix4(d), o.identity(), a.copy(A.matrixWorld), a.premultiply(d), o.extractRotation(a), R.halfWidth.set(A.width * 0.5, 0, 0), R.halfHeight.set(0, A.height * 0.5, 0), R.halfWidth.applyMatrix4(o), R.halfHeight.applyMatrix4(o), v++;
-            } else if (A.isPointLight) {
-                const R = r.point[p];
-                R.position.setFromMatrixPosition(A.matrixWorld), R.position.applyMatrix4(d), p++;
-            } else if (A.isHemisphereLight) {
-                const R = r.hemi[m];
-                R.direction.setFromMatrixPosition(A.matrixWorld), R.direction.transformDirection(d), m++;
+        const p = d.matrixWorldInverse;
+        for (let v = 0, S = u.length; v < S; v++) {
+            const y = u[v];
+            if (y.isDirectionalLight) {
+                const b = i.directional[f];
+                b.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(p), f++;
+            } else if (y.isSpotLight) {
+                const b = i.spot[g];
+                b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), b.direction.setFromMatrixPosition(y.matrixWorld), r.setFromMatrixPosition(y.target.matrixWorld), b.direction.sub(r), b.direction.transformDirection(p), g++;
+            } else if (y.isRectAreaLight) {
+                const b = i.rectArea[_];
+                b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), a.identity(), o.copy(y.matrixWorld), o.premultiply(p), a.extractRotation(o), b.halfWidth.set(y.width * 0.5, 0, 0), b.halfHeight.set(0, y.height * 0.5, 0), b.halfWidth.applyMatrix4(a), b.halfHeight.applyMatrix4(a), _++;
+            } else if (y.isPointLight) {
+                const b = i.point[h];
+                b.position.setFromMatrixPosition(y.matrixWorld), b.position.applyMatrix4(p), h++;
+            } else if (y.isHemisphereLight) {
+                const b = i.hemi[m];
+                b.direction.setFromMatrixPosition(y.matrixWorld), b.direction.transformDirection(p), m++;
             }
         }
     }
     return {
         setup: l,
         setupView: c,
-        state: r
+        state: i
     };
 }
 
-function tl(i, e) {
-    const t = new Og(i, e),
+function Vl(s, e) {
+    const t = new I0(s, e),
         n = [],
-        r = [];
+        i = [];
 
-    function s() {
-        n.length = 0, r.length = 0;
+    function r() {
+        n.length = 0, i.length = 0;
     }
 
-    function a(f) {
-        n.push(f);
+    function o(d) {
+        n.push(d);
     }
 
-    function o(f) {
-        r.push(f);
+    function a(d) {
+        i.push(d);
     }
 
-    function l(f) {
-        t.setup(n, f);
+    function l(d) {
+        t.setup(n, d);
     }
 
-    function c(f) {
-        t.setupView(n, f);
+    function c(d) {
+        t.setupView(n, d);
     }
     return {
-        init: s,
+        init: r,
         state: {
             lightsArray: n,
-            shadowsArray: r,
+            shadowsArray: i,
             lights: t
         },
         setupLights: l,
         setupLightsView: c,
-        pushLight: a,
-        pushShadow: o
+        pushLight: o,
+        pushShadow: a
     };
 }
 
-function zg(i, e) {
+function U0(s, e) {
     let t = /* @__PURE__ */ new WeakMap();
 
-    function n(s, a = 0) {
-        const o = t.get(s);
+    function n(r, o = 0) {
+        const a = t.get(r);
         let l;
-        return o === void 0 ? (l = new tl(i, e), t.set(s, [l])) : a >= o.length ? (l = new tl(i, e), o.push(l)) : l = o[a], l;
+        return a === void 0 ? (l = new Vl(s, e), t.set(r, [l])) : o >= a.length ? (l = new Vl(s, e), a.push(l)) : l = a[o], l;
     }
 
-    function r() {
+    function i() {
         t = /* @__PURE__ */ new WeakMap();
     }
     return {
         get: n,
-        dispose: r
+        dispose: i
     };
 }
-class kg extends as {
+class B0 extends Ur {
     constructor(e) {
-        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = gf, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
+        super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = ff, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e);
     }
     copy(e) {
         return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
     }
 }
-class Gg extends as {
+class O0 extends Ur {
     constructor(e) {
         super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
     }
     copy(e) {
         return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
     }
 }
-const Hg = `void main() {
+const N0 = `void main() {
 	gl_Position = vec4( position, 1.0 );
 }`,
-    Vg = `uniform sampler2D shadow_pass;
+    k0 = `uniform sampler2D shadow_pass;
 uniform vec2 resolution;
 uniform float radius;
 #include <packing>
 void main() {
 	const float samples = float( VSM_SAMPLES );
 	float mean = 0.0;
 	float squared_mean = 0.0;
@@ -14605,1438 +14633,1438 @@
 	}
 	mean = mean / samples;
 	squared_mean = squared_mean / samples;
 	float std_dev = sqrt( squared_mean - mean * mean );
 	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
 }`;
 
-function Wg(i, e, t) {
-    let n = new rc();
-    const r = new me(),
-        s = new me(),
-        a = new ut(),
-        o = new kg({
-            depthPacking: _f
+function z0(s, e, t) {
+    let n = new Jc();
+    const i = new Ee(),
+        r = new Ee(),
+        o = new _t(),
+        a = new B0({
+            depthPacking: hf
         }),
-        l = new Gg(),
+        l = new O0(),
         c = {},
         u = t.maxTextureSize,
-        f = {
-            [hn]: Pt,
-            [Pt]: hn,
-            [en]: en
+        d = {
+            [yn]: zt,
+            [zt]: yn,
+            [un]: un
         },
-        h = new Xt({
+        f = new tn({
             defines: {
                 VSM_SAMPLES: 8
             },
             uniforms: {
                 shadow_pass: {
                     value: null
                 },
                 resolution: {
-                    value: new me()
+                    value: new Ee()
                 },
                 radius: {
                     value: 4
                 }
             },
-            vertexShader: Hg,
-            fragmentShader: Vg
+            vertexShader: N0,
+            fragmentShader: k0
         }),
-        p = h.clone();
-    p.defines.HORIZONTAL_PASS = 1;
-    const g = new Yt();
+        h = f.clone();
+    h.defines.HORIZONTAL_PASS = 1;
+    const g = new sn();
     g.setAttribute(
         "position",
-        new Wt(
+        new en(
             new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
             3
         )
     );
-    const v = new at(g, h),
+    const _ = new pt(g, f),
         m = this;
-    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Fl;
-    let d = this.type;
-    this.render = function(E, b, I) {
+    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Rc;
+    let p = this.type;
+    this.render = function(E, T, L) {
         if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || E.length === 0)
             return;
-        const W = i.getRenderTarget(),
-            S = i.getActiveCubeFace(),
-            T = i.getActiveMipmapLevel(),
-            Y = i.state;
-        Y.setBlending(zn), Y.buffers.color.setClear(1, 1, 1, 1), Y.buffers.depth.setTest(!0), Y.setScissorTest(!1);
-        const K = d !== xn && this.type === xn,
-            L = d === xn && this.type !== xn;
-        for (let N = 0, O = E.length; N < O; N++) {
-            const B = E[N],
-                j = B.shadow;
-            if (j === void 0) {
-                console.warn("THREE.WebGLShadowMap:", B, "has no shadow.");
+        const B = s.getRenderTarget(),
+            x = s.getActiveCubeFace(),
+            A = s.getActiveMipmapLevel(),
+            U = s.state;
+        U.setBlending(Jn), U.buffers.color.setClear(1, 1, 1, 1), U.buffers.depth.setTest(!0), U.setScissorTest(!1);
+        const N = p !== wn && this.type === wn,
+            P = p === wn && this.type !== wn;
+        for (let I = 0, z = E.length; I < z; I++) {
+            const K = E[I],
+                G = K.shadow;
+            if (G === void 0) {
+                console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
                 continue;
             }
-            if (j.autoUpdate === !1 && j.needsUpdate === !1)
+            if (G.autoUpdate === !1 && G.needsUpdate === !1)
                 continue;
-            r.copy(j.mapSize);
-            const q = j.getFrameExtents();
-            if (r.multiply(q), s.copy(j.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / q.x), r.x = s.x * q.x, j.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / q.y), r.y = s.y * q.y, j.mapSize.y = s.y)), j.map === null || K === !0 || L === !0) {
-                const ne = this.type !== xn ? {
-                    minFilter: vt,
-                    magFilter: vt
+            i.copy(G.mapSize);
+            const q = G.getFrameExtents();
+            if (i.multiply(q), r.copy(G.mapSize), (i.x > u || i.y > u) && (i.x > u && (r.x = Math.floor(u / q.x), i.x = r.x * q.x, G.mapSize.x = r.x), i.y > u && (r.y = Math.floor(u / q.y), i.y = r.y * q.y, G.mapSize.y = r.y)), G.map === null || N === !0 || P === !0) {
+                const te = this.type !== wn ? {
+                    minFilter: bt,
+                    magFilter: bt
                 } : {};
-                j.map !== null && j.map.dispose(), j.map = new Vn(r.x, r.y, ne), j.map.texture.name = B.name + ".shadowMap", j.camera.updateProjectionMatrix();
+                G.map !== null && G.map.dispose(), G.map = new ti(i.x, i.y, te), G.map.texture.name = K.name + ".shadowMap", G.camera.updateProjectionMatrix();
             }
-            i.setRenderTarget(j.map), i.clear();
-            const J = j.getViewportCount();
-            for (let ne = 0; ne < J; ne++) {
-                const ue = j.getViewport(ne);
-                a.set(
-                    s.x * ue.x,
-                    s.y * ue.y,
-                    s.x * ue.z,
-                    s.y * ue.w
-                ), Y.viewport(a), j.updateMatrices(B, ne), n = j.getFrustum(), A(b, I, j.camera, B, this.type);
+            s.setRenderTarget(G.map), s.clear();
+            const Q = G.getViewportCount();
+            for (let te = 0; te < Q; te++) {
+                const fe = G.getViewport(te);
+                o.set(
+                    r.x * fe.x,
+                    r.y * fe.y,
+                    r.x * fe.z,
+                    r.y * fe.w
+                ), U.viewport(o), G.updateMatrices(K, te), n = G.getFrustum(), y(T, L, G.camera, K, this.type);
             }
-            j.isPointLightShadow !== !0 && this.type === xn && M(j, I), j.needsUpdate = !1;
+            G.isPointLightShadow !== !0 && this.type === wn && v(G, L), G.needsUpdate = !1;
         }
-        d = this.type, m.needsUpdate = !1, i.setRenderTarget(W, S, T);
+        p = this.type, m.needsUpdate = !1, s.setRenderTarget(B, x, A);
     };
 
-    function M(E, b) {
-        const I = e.update(v);
-        h.defines.VSM_SAMPLES !== E.blurSamples && (h.defines.VSM_SAMPLES = E.blurSamples, p.defines.VSM_SAMPLES = E.blurSamples, h.needsUpdate = !0, p.needsUpdate = !0), E.mapPass === null && (E.mapPass = new Vn(r.x, r.y)), h.uniforms.shadow_pass.value = E.map.texture, h.uniforms.resolution.value = E.mapSize, h.uniforms.radius.value = E.radius, i.setRenderTarget(E.mapPass), i.clear(), i.renderBufferDirect(b, null, I, h, v, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, i.setRenderTarget(E.map), i.clear(), i.renderBufferDirect(b, null, I, p, v, null);
+    function v(E, T) {
+        const L = e.update(_);
+        f.defines.VSM_SAMPLES !== E.blurSamples && (f.defines.VSM_SAMPLES = E.blurSamples, h.defines.VSM_SAMPLES = E.blurSamples, f.needsUpdate = !0, h.needsUpdate = !0), E.mapPass === null && (E.mapPass = new ti(i.x, i.y)), f.uniforms.shadow_pass.value = E.map.texture, f.uniforms.resolution.value = E.mapSize, f.uniforms.radius.value = E.radius, s.setRenderTarget(E.mapPass), s.clear(), s.renderBufferDirect(T, null, L, f, _, null), h.uniforms.shadow_pass.value = E.mapPass.texture, h.uniforms.resolution.value = E.mapSize, h.uniforms.radius.value = E.radius, s.setRenderTarget(E.map), s.clear(), s.renderBufferDirect(T, null, L, h, _, null);
     }
 
-    function _(E, b, I, W) {
-        let S = null;
-        const T = I.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
-        if (T !== void 0)
-            S = T;
-        else if (S = I.isPointLight === !0 ? l : o, i.localClippingEnabled && b.clipShadows === !0 && Array.isArray(b.clippingPlanes) && b.clippingPlanes.length !== 0 || b.displacementMap && b.displacementScale !== 0 || b.alphaMap && b.alphaTest > 0 || b.map && b.alphaTest > 0) {
-            const Y = S.uuid,
-                K = b.uuid;
-            let L = c[Y];
-            L === void 0 && (L = {}, c[Y] = L);
-            let N = L[K];
-            N === void 0 && (N = S.clone(), L[K] = N, b.addEventListener("dispose", R)), S = N;
+    function S(E, T, L, B) {
+        let x = null;
+        const A = L.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
+        if (A !== void 0)
+            x = A;
+        else if (x = L.isPointLight === !0 ? l : a, s.localClippingEnabled && T.clipShadows === !0 && Array.isArray(T.clippingPlanes) && T.clippingPlanes.length !== 0 || T.displacementMap && T.displacementScale !== 0 || T.alphaMap && T.alphaTest > 0 || T.map && T.alphaTest > 0) {
+            const U = x.uuid,
+                N = T.uuid;
+            let P = c[U];
+            P === void 0 && (P = {}, c[U] = P);
+            let I = P[N];
+            I === void 0 && (I = x.clone(), P[N] = I, T.addEventListener("dispose", b)), x = I;
         }
-        if (S.visible = b.visible, S.wireframe = b.wireframe, W === xn ? S.side = b.shadowSide !== null ? b.shadowSide : b.side : S.side = b.shadowSide !== null ? b.shadowSide : f[b.side], S.alphaMap = b.alphaMap, S.alphaTest = b.alphaTest, S.map = b.map, S.clipShadows = b.clipShadows, S.clippingPlanes = b.clippingPlanes, S.clipIntersection = b.clipIntersection, S.displacementMap = b.displacementMap, S.displacementScale = b.displacementScale, S.displacementBias = b.displacementBias, S.wireframeLinewidth = b.wireframeLinewidth, S.linewidth = b.linewidth, I.isPointLight === !0 && S.isMeshDistanceMaterial === !0) {
-            const Y = i.properties.get(S);
-            Y.light = I;
+        if (x.visible = T.visible, x.wireframe = T.wireframe, B === wn ? x.side = T.shadowSide !== null ? T.shadowSide : T.side : x.side = T.shadowSide !== null ? T.shadowSide : d[T.side], x.alphaMap = T.alphaMap, x.alphaTest = T.alphaTest, x.map = T.map, x.clipShadows = T.clipShadows, x.clippingPlanes = T.clippingPlanes, x.clipIntersection = T.clipIntersection, x.displacementMap = T.displacementMap, x.displacementScale = T.displacementScale, x.displacementBias = T.displacementBias, x.wireframeLinewidth = T.wireframeLinewidth, x.linewidth = T.linewidth, L.isPointLight === !0 && x.isMeshDistanceMaterial === !0) {
+            const U = s.properties.get(x);
+            U.light = L;
         }
-        return S;
+        return x;
     }
 
-    function A(E, b, I, W, S) {
+    function y(E, T, L, B, x) {
         if (E.visible === !1)
             return;
-        if (E.layers.test(b.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && S === xn) && (!E.frustumCulled || n.intersectsObject(E))) {
-            E.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, E.matrixWorld);
-            const K = e.update(E),
-                L = E.material;
-            if (Array.isArray(L)) {
-                const N = K.groups;
-                for (let O = 0, B = N.length; O < B; O++) {
-                    const j = N[O],
-                        q = L[j.materialIndex];
+        if (E.layers.test(T.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && x === wn) && (!E.frustumCulled || n.intersectsObject(E))) {
+            E.modelViewMatrix.multiplyMatrices(L.matrixWorldInverse, E.matrixWorld);
+            const N = e.update(E),
+                P = E.material;
+            if (Array.isArray(P)) {
+                const I = N.groups;
+                for (let z = 0, K = I.length; z < K; z++) {
+                    const G = I[z],
+                        q = P[G.materialIndex];
                     if (q && q.visible) {
-                        const J = _(E, q, W, S);
-                        E.onBeforeShadow(i, E, b, I, K, J, j), i.renderBufferDirect(I, null, K, J, E, j), E.onAfterShadow(i, E, b, I, K, J, j);
+                        const Q = S(E, q, B, x);
+                        E.onBeforeShadow(s, E, T, L, N, Q, G), s.renderBufferDirect(L, null, N, Q, E, G), E.onAfterShadow(s, E, T, L, N, Q, G);
                     }
                 }
-            } else if (L.visible) {
-                const N = _(E, L, W, S);
-                E.onBeforeShadow(i, E, b, I, K, N, null), i.renderBufferDirect(I, null, K, N, E, null), E.onAfterShadow(i, E, b, I, K, N, null);
+            } else if (P.visible) {
+                const I = S(E, P, B, x);
+                E.onBeforeShadow(s, E, T, L, N, I, null), s.renderBufferDirect(L, null, N, I, E, null), E.onAfterShadow(s, E, T, L, N, I, null);
             }
         }
-        const Y = E.children;
-        for (let K = 0, L = Y.length; K < L; K++)
-            A(Y[K], b, I, W, S);
+        const U = E.children;
+        for (let N = 0, P = U.length; N < P; N++)
+            y(U[N], T, L, B, x);
     }
 
-    function R(E) {
-        E.target.removeEventListener("dispose", R);
-        for (const I in c) {
-            const W = c[I],
-                S = E.target.uuid;
-            S in W && (W[S].dispose(), delete W[S]);
+    function b(E) {
+        E.target.removeEventListener("dispose", b);
+        for (const L in c) {
+            const B = c[L],
+                x = E.target.uuid;
+            x in B && (B[x].dispose(), delete B[x]);
         }
     }
 }
 
-function Xg(i, e, t) {
+function H0(s, e, t) {
     const n = t.isWebGL2;
 
-    function r() {
-        let D = !1;
-        const re = new ut();
-        let z = null;
-        const ie = new ut(0, 0, 0, 0);
+    function i() {
+        let F = !1;
+        const ce = new _t();
+        let W = null;
+        const ae = new _t(0, 0, 0, 0);
         return {
-            setMask: function(ae) {
-                z !== ae && !D && (i.colorMask(ae, ae, ae, ae), z = ae);
+            setMask: function(pe) {
+                W !== pe && !F && (s.colorMask(pe, pe, pe, pe), W = pe);
             },
-            setLocked: function(ae) {
-                D = ae;
+            setLocked: function(pe) {
+                F = pe;
             },
-            setClear: function(ae, Oe, et, _t, Nt) {
-                Nt === !0 && (ae *= _t, Oe *= _t, et *= _t), re.set(ae, Oe, et, _t), ie.equals(re) === !1 && (i.clearColor(ae, Oe, et, _t), ie.copy(re));
+            setClear: function(pe, Ve, it, At, jt) {
+                jt === !0 && (pe *= At, Ve *= At, it *= At), ce.set(pe, Ve, it, At), ae.equals(ce) === !1 && (s.clearColor(pe, Ve, it, At), ae.copy(ce));
             },
             reset: function() {
-                D = !1, z = null, ie.set(-1, 0, 0, 0);
+                F = !1, W = null, ae.set(-1, 0, 0, 0);
             }
         };
     }
 
-    function s() {
-        let D = !1,
-            re = null,
-            z = null,
-            ie = null;
+    function r() {
+        let F = !1,
+            ce = null,
+            W = null,
+            ae = null;
         return {
-            setTest: function(ae) {
-                ae ? ge(i.DEPTH_TEST) : Ke(i.DEPTH_TEST);
+            setTest: function(pe) {
+                pe ? ge(s.DEPTH_TEST) : Qe(s.DEPTH_TEST);
             },
-            setMask: function(ae) {
-                re !== ae && !D && (i.depthMask(ae), re = ae);
+            setMask: function(pe) {
+                ce !== pe && !F && (s.depthMask(pe), ce = pe);
             },
-            setFunc: function(ae) {
-                if (z !== ae) {
-                    switch (ae) {
-                        case qu:
-                            i.depthFunc(i.NEVER);
+            setFunc: function(pe) {
+                if (W !== pe) {
+                    switch (pe) {
+                        case Hd:
+                            s.depthFunc(s.NEVER);
                             break;
-                        case Yu:
-                            i.depthFunc(i.ALWAYS);
+                        case Gd:
+                            s.depthFunc(s.ALWAYS);
                             break;
-                        case ju:
-                            i.depthFunc(i.LESS);
+                        case Vd:
+                            s.depthFunc(s.LESS);
                             break;
-                        case qr:
-                            i.depthFunc(i.LEQUAL);
+                        case vr:
+                            s.depthFunc(s.LEQUAL);
                             break;
-                        case Ku:
-                            i.depthFunc(i.EQUAL);
+                        case Wd:
+                            s.depthFunc(s.EQUAL);
                             break;
-                        case Qu:
-                            i.depthFunc(i.GEQUAL);
+                        case Xd:
+                            s.depthFunc(s.GEQUAL);
                             break;
-                        case Zu:
-                            i.depthFunc(i.GREATER);
+                        case qd:
+                            s.depthFunc(s.GREATER);
                             break;
-                        case Ju:
-                            i.depthFunc(i.NOTEQUAL);
+                        case Yd:
+                            s.depthFunc(s.NOTEQUAL);
                             break;
                         default:
-                            i.depthFunc(i.LEQUAL);
+                            s.depthFunc(s.LEQUAL);
                     }
-                    z = ae;
+                    W = pe;
                 }
             },
-            setLocked: function(ae) {
-                D = ae;
+            setLocked: function(pe) {
+                F = pe;
             },
-            setClear: function(ae) {
-                ie !== ae && (i.clearDepth(ae), ie = ae);
+            setClear: function(pe) {
+                ae !== pe && (s.clearDepth(pe), ae = pe);
             },
             reset: function() {
-                D = !1, re = null, z = null, ie = null;
+                F = !1, ce = null, W = null, ae = null;
             }
         };
     }
 
-    function a() {
-        let D = !1,
-            re = null,
-            z = null,
-            ie = null,
+    function o() {
+        let F = !1,
+            ce = null,
+            W = null,
             ae = null,
-            Oe = null,
-            et = null,
-            _t = null,
-            Nt = null;
+            pe = null,
+            Ve = null,
+            it = null,
+            At = null,
+            jt = null;
         return {
-            setTest: function(tt) {
-                D || (tt ? ge(i.STENCIL_TEST) : Ke(i.STENCIL_TEST));
+            setTest: function(st) {
+                F || (st ? ge(s.STENCIL_TEST) : Qe(s.STENCIL_TEST));
             },
-            setMask: function(tt) {
-                re !== tt && !D && (i.stencilMask(tt), re = tt);
+            setMask: function(st) {
+                ce !== st && !F && (s.stencilMask(st), ce = st);
             },
-            setFunc: function(tt, At, rn) {
-                (z !== tt || ie !== At || ae !== rn) && (i.stencilFunc(tt, At, rn), z = tt, ie = At, ae = rn);
+            setFunc: function(st, Ft, hn) {
+                (W !== st || ae !== Ft || pe !== hn) && (s.stencilFunc(st, Ft, hn), W = st, ae = Ft, pe = hn);
             },
-            setOp: function(tt, At, rn) {
-                (Oe !== tt || et !== At || _t !== rn) && (i.stencilOp(tt, At, rn), Oe = tt, et = At, _t = rn);
+            setOp: function(st, Ft, hn) {
+                (Ve !== st || it !== Ft || At !== hn) && (s.stencilOp(st, Ft, hn), Ve = st, it = Ft, At = hn);
             },
-            setLocked: function(tt) {
-                D = tt;
+            setLocked: function(st) {
+                F = st;
             },
-            setClear: function(tt) {
-                Nt !== tt && (i.clearStencil(tt), Nt = tt);
+            setClear: function(st) {
+                jt !== st && (s.clearStencil(st), jt = st);
             },
             reset: function() {
-                D = !1, re = null, z = null, ie = null, ae = null, Oe = null, et = null, _t = null, Nt = null;
+                F = !1, ce = null, W = null, ae = null, pe = null, Ve = null, it = null, At = null, jt = null;
             }
         };
     }
-    const o = new r(),
-        l = new s(),
-        c = new a(),
+    const a = new i(),
+        l = new r(),
+        c = new o(),
         u = /* @__PURE__ */ new WeakMap(),
-        f = /* @__PURE__ */ new WeakMap();
-    let h = {},
-        p = {},
+        d = /* @__PURE__ */ new WeakMap();
+    let f = {},
+        h = {},
         g = /* @__PURE__ */ new WeakMap(),
-        v = [],
+        _ = [],
         m = null,
-        d = !1,
-        M = null,
-        _ = null,
-        A = null,
-        R = null,
-        E = null,
+        p = !1,
+        v = null,
+        S = null,
+        y = null,
         b = null,
-        I = null,
-        W = new Qe(0, 0, 0),
-        S = 0,
-        T = !1,
-        Y = null,
-        K = null,
+        E = null,
+        T = null,
         L = null,
+        B = new et(0, 0, 0),
+        x = 0,
+        A = !1,
+        U = null,
         N = null,
-        O = null;
-    const B = i.getParameter(i.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
-    let j = !1,
+        P = null,
+        I = null,
+        z = null;
+    const K = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
+    let G = !1,
         q = 0;
-    const J = i.getParameter(i.VERSION);
-    J.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL (\d)/.exec(J)[1]), j = q >= 1) : J.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), j = q >= 2);
-    let ne = null,
-        ue = {};
-    const Z = i.getParameter(i.SCISSOR_BOX),
-        H = i.getParameter(i.VIEWPORT),
-        ee = new ut().fromArray(Z),
-        pe = new ut().fromArray(H);
-
-    function Te(D, re, z, ie) {
-        const ae = new Uint8Array(4),
-            Oe = i.createTexture();
-        i.bindTexture(D, Oe), i.texParameteri(D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(D, i.TEXTURE_MAG_FILTER, i.NEAREST);
-        for (let et = 0; et < z; et++)
-            n && (D === i.TEXTURE_3D || D === i.TEXTURE_2D_ARRAY) ? i.texImage3D(re, 0, i.RGBA, 1, 1, ie, 0, i.RGBA, i.UNSIGNED_BYTE, ae) : i.texImage2D(re + et, 0, i.RGBA, 1, 1, 0, i.RGBA, i.UNSIGNED_BYTE, ae);
-        return Oe;
+    const Q = s.getParameter(s.VERSION);
+    Q.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL (\d)/.exec(Q)[1]), G = q >= 1) : Q.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), G = q >= 2);
+    let te = null,
+        fe = {};
+    const ne = s.getParameter(s.SCISSOR_BOX),
+        V = s.getParameter(s.VIEWPORT),
+        J = new _t().fromArray(ne),
+        se = new _t().fromArray(V);
+
+    function Ae(F, ce, W, ae) {
+        const pe = new Uint8Array(4),
+            Ve = s.createTexture();
+        s.bindTexture(F, Ve), s.texParameteri(F, s.TEXTURE_MIN_FILTER, s.NEAREST), s.texParameteri(F, s.TEXTURE_MAG_FILTER, s.NEAREST);
+        for (let it = 0; it < W; it++)
+            n && (F === s.TEXTURE_3D || F === s.TEXTURE_2D_ARRAY) ? s.texImage3D(ce, 0, s.RGBA, 1, 1, ae, 0, s.RGBA, s.UNSIGNED_BYTE, pe) : s.texImage2D(ce + it, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, pe);
+        return Ve;
     }
     const xe = {};
-    xe[i.TEXTURE_2D] = Te(i.TEXTURE_2D, i.TEXTURE_2D, 1), xe[i.TEXTURE_CUBE_MAP] = Te(i.TEXTURE_CUBE_MAP, i.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (xe[i.TEXTURE_2D_ARRAY] = Te(i.TEXTURE_2D_ARRAY, i.TEXTURE_2D_ARRAY, 1, 1), xe[i.TEXTURE_3D] = Te(i.TEXTURE_3D, i.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ge(i.DEPTH_TEST), l.setFunc(qr), Ie(!1), Be(Uo), ge(i.CULL_FACE), ye(zn);
+    xe[s.TEXTURE_2D] = Ae(s.TEXTURE_2D, s.TEXTURE_2D, 1), xe[s.TEXTURE_CUBE_MAP] = Ae(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6), n && (xe[s.TEXTURE_2D_ARRAY] = Ae(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1), xe[s.TEXTURE_3D] = Ae(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), ge(s.DEPTH_TEST), l.setFunc(vr), Oe(!1), we(Mo), ge(s.CULL_FACE), Me(Jn);
 
-    function ge(D) {
-        h[D] !== !0 && (i.enable(D), h[D] = !0);
+    function ge(F) {
+        f[F] !== !0 && (s.enable(F), f[F] = !0);
     }
 
-    function Ke(D) {
-        h[D] !== !1 && (i.disable(D), h[D] = !1);
+    function Qe(F) {
+        f[F] !== !1 && (s.disable(F), f[F] = !1);
     }
 
-    function we(D, re) {
-        return p[D] !== re ? (i.bindFramebuffer(D, re), p[D] = re, n && (D === i.DRAW_FRAMEBUFFER && (p[i.FRAMEBUFFER] = re), D === i.FRAMEBUFFER && (p[i.DRAW_FRAMEBUFFER] = re)), !0) : !1;
+    function Re(F, ce) {
+        return h[F] !== ce ? (s.bindFramebuffer(F, ce), h[F] = ce, n && (F === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = ce), F === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = ce)), !0) : !1;
     }
 
-    function F(D, re) {
-        let z = v,
-            ie = !1;
-        if (D) {
-            z = g.get(re), z === void 0 && (z = [], g.set(re, z));
-            const ae = D.textures;
-            if (z.length !== ae.length || z[0] !== i.COLOR_ATTACHMENT0) {
-                for (let Oe = 0, et = ae.length; Oe < et; Oe++)
-                    z[Oe] = i.COLOR_ATTACHMENT0 + Oe;
-                z.length = ae.length, ie = !0;
+    function O(F, ce) {
+        let W = _,
+            ae = !1;
+        if (F) {
+            W = g.get(ce), W === void 0 && (W = [], g.set(ce, W));
+            const pe = F.textures;
+            if (W.length !== pe.length || W[0] !== s.COLOR_ATTACHMENT0) {
+                for (let Ve = 0, it = pe.length; Ve < it; Ve++)
+                    W[Ve] = s.COLOR_ATTACHMENT0 + Ve;
+                W.length = pe.length, ae = !0;
             }
         } else
-            z[0] !== i.BACK && (z[0] = i.BACK, ie = !0);
-        if (ie)
+            W[0] !== s.BACK && (W[0] = s.BACK, ae = !0);
+        if (ae)
             if (t.isWebGL2)
-                i.drawBuffers(z);
+                s.drawBuffers(W);
             else if (e.has("WEBGL_draw_buffers") === !0)
-            e.get("WEBGL_draw_buffers").drawBuffersWEBGL(z);
+            e.get("WEBGL_draw_buffers").drawBuffersWEBGL(W);
         else
             throw new Error("THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension");
     }
 
-    function lt(D) {
-        return m !== D ? (i.useProgram(D), m = D, !0) : !1;
+    function Je(F) {
+        return m !== F ? (s.useProgram(F), m = F, !0) : !1;
     }
-    const Me = {
-        [ei]: i.FUNC_ADD,
-        [Lu]: i.FUNC_SUBTRACT,
-        [Du]: i.FUNC_REVERSE_SUBTRACT
+    const Te = {
+        [fi]: s.FUNC_ADD,
+        [bd]: s.FUNC_SUBTRACT,
+        [Cd]: s.FUNC_REVERSE_SUBTRACT
     };
     if (n)
-        Me[Oo] = i.MIN, Me[zo] = i.MAX;
+        Te[bo] = s.MIN, Te[Co] = s.MAX;
     else {
-        const D = e.get("EXT_blend_minmax");
-        D !== null && (Me[Oo] = D.MIN_EXT, Me[zo] = D.MAX_EXT);
+        const F = e.get("EXT_blend_minmax");
+        F !== null && (Te[bo] = F.MIN_EXT, Te[Co] = F.MAX_EXT);
     }
-    const Ne = {
-        [Iu]: i.ZERO,
-        [Uu]: i.ONE,
-        [Fu]: i.SRC_COLOR,
-        [cr]: i.SRC_ALPHA,
-        [Gu]: i.SRC_ALPHA_SATURATE,
-        [zu]: i.DST_COLOR,
-        [Bu]: i.DST_ALPHA,
-        [Nu]: i.ONE_MINUS_SRC_COLOR,
-        [ur]: i.ONE_MINUS_SRC_ALPHA,
-        [ku]: i.ONE_MINUS_DST_COLOR,
-        [Ou]: i.ONE_MINUS_DST_ALPHA,
-        [Hu]: i.CONSTANT_COLOR,
-        [Vu]: i.ONE_MINUS_CONSTANT_COLOR,
-        [Wu]: i.CONSTANT_ALPHA,
-        [Xu]: i.ONE_MINUS_CONSTANT_ALPHA
-    };
-
-    function ye(D, re, z, ie, ae, Oe, et, _t, Nt, tt) {
-        if (D === zn) {
-            d === !0 && (Ke(i.BLEND), d = !1);
+    const Ie = {
+        [wd]: s.ZERO,
+        [Rd]: s.ONE,
+        [Pd]: s.SRC_COLOR,
+        [Ps]: s.SRC_ALPHA,
+        [Bd]: s.SRC_ALPHA_SATURATE,
+        [Id]: s.DST_COLOR,
+        [Ld]: s.DST_ALPHA,
+        [Dd]: s.ONE_MINUS_SRC_COLOR,
+        [Ds]: s.ONE_MINUS_SRC_ALPHA,
+        [Ud]: s.ONE_MINUS_DST_COLOR,
+        [Fd]: s.ONE_MINUS_DST_ALPHA,
+        [Od]: s.CONSTANT_COLOR,
+        [Nd]: s.ONE_MINUS_CONSTANT_COLOR,
+        [kd]: s.CONSTANT_ALPHA,
+        [zd]: s.ONE_MINUS_CONSTANT_ALPHA
+    };
+
+    function Me(F, ce, W, ae, pe, Ve, it, At, jt, st) {
+        if (F === Jn) {
+            p === !0 && (Qe(s.BLEND), p = !1);
             return;
         }
-        if (d === !1 && (ge(i.BLEND), d = !0), D !== Nl) {
-            if (D !== M || tt !== T) {
-                if ((_ !== ei || E !== ei) && (i.blendEquation(i.FUNC_ADD), _ = ei, E = ei), tt)
-                    switch (D) {
-                        case ri:
-                            i.blendFuncSeparate(i.ONE, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
+        if (p === !1 && (ge(s.BLEND), p = !0), F !== Pc) {
+            if (F !== v || st !== A) {
+                if ((S !== fi || E !== fi) && (s.blendEquation(s.FUNC_ADD), S = fi, E = fi), st)
+                    switch (F) {
+                        case Si:
+                            s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                             break;
-                        case Fo:
-                            i.blendFunc(i.ONE, i.ONE);
+                        case Eo:
+                            s.blendFunc(s.ONE, s.ONE);
                             break;
-                        case No:
-                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
+                        case Ao:
+                            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                             break;
-                        case Bo:
-                            i.blendFuncSeparate(i.ZERO, i.SRC_COLOR, i.ZERO, i.SRC_ALPHA);
+                        case To:
+                            s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                             break;
                         default:
-                            console.error("THREE.WebGLState: Invalid blending: ", D);
+                            console.error("THREE.WebGLState: Invalid blending: ", F);
                             break;
                     }
                 else
-                    switch (D) {
-                        case ri:
-                            i.blendFuncSeparate(i.SRC_ALPHA, i.ONE_MINUS_SRC_ALPHA, i.ONE, i.ONE_MINUS_SRC_ALPHA);
+                    switch (F) {
+                        case Si:
+                            s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                             break;
-                        case Fo:
-                            i.blendFunc(i.SRC_ALPHA, i.ONE);
+                        case Eo:
+                            s.blendFunc(s.SRC_ALPHA, s.ONE);
                             break;
-                        case No:
-                            i.blendFuncSeparate(i.ZERO, i.ONE_MINUS_SRC_COLOR, i.ZERO, i.ONE);
+                        case Ao:
+                            s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                             break;
-                        case Bo:
-                            i.blendFunc(i.ZERO, i.SRC_COLOR);
+                        case To:
+                            s.blendFunc(s.ZERO, s.SRC_COLOR);
                             break;
                         default:
-                            console.error("THREE.WebGLState: Invalid blending: ", D);
+                            console.error("THREE.WebGLState: Invalid blending: ", F);
                             break;
                     }
-                A = null, R = null, b = null, I = null, W.set(0, 0, 0), S = 0, M = D, T = tt;
+                y = null, b = null, T = null, L = null, B.set(0, 0, 0), x = 0, v = F, A = st;
             }
             return;
         }
-        ae = ae || re, Oe = Oe || z, et = et || ie, (re !== _ || ae !== E) && (i.blendEquationSeparate(Me[re], Me[ae]), _ = re, E = ae), (z !== A || ie !== R || Oe !== b || et !== I) && (i.blendFuncSeparate(Ne[z], Ne[ie], Ne[Oe], Ne[et]), A = z, R = ie, b = Oe, I = et), (_t.equals(W) === !1 || Nt !== S) && (i.blendColor(_t.r, _t.g, _t.b, Nt), W.copy(_t), S = Nt), M = D, T = !1;
+        pe = pe || ce, Ve = Ve || W, it = it || ae, (ce !== S || pe !== E) && (s.blendEquationSeparate(Te[ce], Te[pe]), S = ce, E = pe), (W !== y || ae !== b || Ve !== T || it !== L) && (s.blendFuncSeparate(Ie[W], Ie[ae], Ie[Ve], Ie[it]), y = W, b = ae, T = Ve, L = it), (At.equals(B) === !1 || jt !== x) && (s.blendColor(At.r, At.g, At.b, jt), B.copy(At), x = jt), v = F, A = !1;
     }
 
-    function qe(D, re) {
-        D.side === en ? Ke(i.CULL_FACE) : ge(i.CULL_FACE);
-        let z = D.side === Pt;
-        re && (z = !z), Ie(z), D.blending === ri && D.transparent === !1 ? ye(zn) : ye(D.blending, D.blendEquation, D.blendSrc, D.blendDst, D.blendEquationAlpha, D.blendSrcAlpha, D.blendDstAlpha, D.blendColor, D.blendAlpha, D.premultipliedAlpha), l.setFunc(D.depthFunc), l.setTest(D.depthTest), l.setMask(D.depthWrite), o.setMask(D.colorWrite);
-        const ie = D.stencilWrite;
-        c.setTest(ie), ie && (c.setMask(D.stencilWriteMask), c.setFunc(D.stencilFunc, D.stencilRef, D.stencilFuncMask), c.setOp(D.stencilFail, D.stencilZFail, D.stencilZPass)), w(D.polygonOffset, D.polygonOffsetFactor, D.polygonOffsetUnits), D.alphaToCoverage === !0 ? ge(i.SAMPLE_ALPHA_TO_COVERAGE) : Ke(i.SAMPLE_ALPHA_TO_COVERAGE);
+    function ze(F, ce) {
+        F.side === un ? Qe(s.CULL_FACE) : ge(s.CULL_FACE);
+        let W = F.side === zt;
+        ce && (W = !W), Oe(W), F.blending === Si && F.transparent === !1 ? Me(Jn) : Me(F.blending, F.blendEquation, F.blendSrc, F.blendDst, F.blendEquationAlpha, F.blendSrcAlpha, F.blendDstAlpha, F.blendColor, F.blendAlpha, F.premultipliedAlpha), l.setFunc(F.depthFunc), l.setTest(F.depthTest), l.setMask(F.depthWrite), a.setMask(F.colorWrite);
+        const ae = F.stencilWrite;
+        c.setTest(ae), ae && (c.setMask(F.stencilWriteMask), c.setFunc(F.stencilFunc, F.stencilRef, F.stencilFuncMask), c.setOp(F.stencilFail, F.stencilZFail, F.stencilZPass)), w(F.polygonOffset, F.polygonOffsetFactor, F.polygonOffsetUnits), F.alphaToCoverage === !0 ? ge(s.SAMPLE_ALPHA_TO_COVERAGE) : Qe(s.SAMPLE_ALPHA_TO_COVERAGE);
     }
 
-    function Ie(D) {
-        Y !== D && (D ? i.frontFace(i.CW) : i.frontFace(i.CCW), Y = D);
+    function Oe(F) {
+        U !== F && (F ? s.frontFace(s.CW) : s.frontFace(s.CCW), U = F);
     }
 
-    function Be(D) {
-        D !== Cu ? (ge(i.CULL_FACE), D !== K && (D === Uo ? i.cullFace(i.BACK) : D === Ru ? i.cullFace(i.FRONT) : i.cullFace(i.FRONT_AND_BACK))) : Ke(i.CULL_FACE), K = D;
+    function we(F) {
+        F !== Ed ? (ge(s.CULL_FACE), F !== N && (F === Mo ? s.cullFace(s.BACK) : F === Ad ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : Qe(s.CULL_FACE), N = F;
     }
 
-    function Je(D) {
-        D !== L && (j && i.lineWidth(D), L = D);
+    function Ke(F) {
+        F !== P && (G && s.lineWidth(F), P = F);
     }
 
-    function w(D, re, z) {
-        D ? (ge(i.POLYGON_OFFSET_FILL), (N !== re || O !== z) && (i.polygonOffset(re, z), N = re, O = z)) : Ke(i.POLYGON_OFFSET_FILL);
+    function w(F, ce, W) {
+        F ? (ge(s.POLYGON_OFFSET_FILL), (I !== ce || z !== W) && (s.polygonOffset(ce, W), I = ce, z = W)) : Qe(s.POLYGON_OFFSET_FILL);
     }
 
-    function x(D) {
-        D ? ge(i.SCISSOR_TEST) : Ke(i.SCISSOR_TEST);
+    function M(F) {
+        F ? ge(s.SCISSOR_TEST) : Qe(s.SCISSOR_TEST);
     }
 
-    function X(D) {
-        D === void 0 && (D = i.TEXTURE0 + B - 1), ne !== D && (i.activeTexture(D), ne = D);
+    function k(F) {
+        F === void 0 && (F = s.TEXTURE0 + K - 1), te !== F && (s.activeTexture(F), te = F);
     }
 
-    function Q(D, re, z) {
-        z === void 0 && (ne === null ? z = i.TEXTURE0 + B - 1 : z = ne);
-        let ie = ue[z];
-        ie === void 0 && (ie = {
+    function Z(F, ce, W) {
+        W === void 0 && (te === null ? W = s.TEXTURE0 + K - 1 : W = te);
+        let ae = fe[W];
+        ae === void 0 && (ae = {
             type: void 0,
             texture: void 0
-        }, ue[z] = ie), (ie.type !== D || ie.texture !== re) && (ne !== z && (i.activeTexture(z), ne = z), i.bindTexture(D, re || xe[D]), ie.type = D, ie.texture = re);
+        }, fe[W] = ae), (ae.type !== F || ae.texture !== ce) && (te !== W && (s.activeTexture(W), te = W), s.bindTexture(F, ce || xe[F]), ae.type = F, ae.texture = ce);
     }
 
-    function te() {
-        const D = ue[ne];
-        D !== void 0 && D.type !== void 0 && (i.bindTexture(D.type, null), D.type = void 0, D.texture = void 0);
+    function re() {
+        const F = fe[te];
+        F !== void 0 && F.type !== void 0 && (s.bindTexture(F.type, null), F.type = void 0, F.texture = void 0);
     }
 
-    function $() {
+    function ie() {
         try {
-            i.compressedTexImage2D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.compressedTexImage2D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function Le() {
+    function Be() {
         try {
-            i.compressedTexImage3D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.compressedTexImage3D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function Ae() {
+    function Pe() {
         try {
-            i.texSubImage2D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texSubImage2D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function se() {
+    function oe() {
         try {
-            i.texSubImage3D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texSubImage3D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function ce() {
+    function de() {
         try {
-            i.compressedTexSubImage2D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.compressedTexSubImage2D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function Re() {
+    function De() {
         try {
-            i.compressedTexSubImage3D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.compressedTexSubImage3D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function C() {
+    function R() {
         try {
-            i.texStorage2D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texStorage2D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function le() {
+    function ue() {
         try {
-            i.texStorage3D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texStorage3D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function ve() {
+    function Se() {
         try {
-            i.texImage2D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texImage2D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function fe() {
+    function me() {
         try {
-            i.texImage3D.apply(i, arguments);
-        } catch (D) {
-            console.error("THREE.WebGLState:", D);
+            s.texImage3D.apply(s, arguments);
+        } catch (F) {
+            console.error("THREE.WebGLState:", F);
         }
     }
 
-    function he(D) {
-        ee.equals(D) === !1 && (i.scissor(D.x, D.y, D.z, D.w), ee.copy(D));
+    function _e(F) {
+        J.equals(F) === !1 && (s.scissor(F.x, F.y, F.z, F.w), J.copy(F));
     }
 
-    function _e(D) {
-        pe.equals(D) === !1 && (i.viewport(D.x, D.y, D.z, D.w), pe.copy(D));
+    function ve(F) {
+        se.equals(F) === !1 && (s.viewport(F.x, F.y, F.z, F.w), se.copy(F));
     }
 
-    function De(D, re) {
-        let z = f.get(re);
-        z === void 0 && (z = /* @__PURE__ */ new WeakMap(), f.set(re, z));
-        let ie = z.get(D);
-        ie === void 0 && (ie = i.getUniformBlockIndex(re, D.name), z.set(D, ie));
+    function Le(F, ce) {
+        let W = d.get(ce);
+        W === void 0 && (W = /* @__PURE__ */ new WeakMap(), d.set(ce, W));
+        let ae = W.get(F);
+        ae === void 0 && (ae = s.getUniformBlockIndex(ce, F.name), W.set(F, ae));
     }
 
-    function Ue(D, re) {
-        const ie = f.get(re).get(D);
-        u.get(re) !== ie && (i.uniformBlockBinding(re, ie, D.__bindingPointIndex), u.set(re, ie));
+    function Ne(F, ce) {
+        const ae = d.get(ce).get(F);
+        u.get(ce) !== ae && (s.uniformBlockBinding(ce, ae, F.__bindingPointIndex), u.set(ce, ae));
     }
 
-    function $e() {
-        i.disable(i.BLEND), i.disable(i.CULL_FACE), i.disable(i.DEPTH_TEST), i.disable(i.POLYGON_OFFSET_FILL), i.disable(i.SCISSOR_TEST), i.disable(i.STENCIL_TEST), i.disable(i.SAMPLE_ALPHA_TO_COVERAGE), i.blendEquation(i.FUNC_ADD), i.blendFunc(i.ONE, i.ZERO), i.blendFuncSeparate(i.ONE, i.ZERO, i.ONE, i.ZERO), i.blendColor(0, 0, 0, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(i.LESS), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(i.ALWAYS, 0, 4294967295), i.stencilOp(i.KEEP, i.KEEP, i.KEEP), i.clearStencil(0), i.cullFace(i.BACK), i.frontFace(i.CCW), i.polygonOffset(0, 0), i.activeTexture(i.TEXTURE0), i.bindFramebuffer(i.FRAMEBUFFER, null), n === !0 && (i.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), i.bindFramebuffer(i.READ_FRAMEBUFFER, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), h = {}, ne = null, ue = {}, p = {}, g = /* @__PURE__ */ new WeakMap(), v = [], m = null, d = !1, M = null, _ = null, A = null, R = null, E = null, b = null, I = null, W = new Qe(0, 0, 0), S = 0, T = !1, Y = null, K = null, L = null, N = null, O = null, ee.set(0, 0, i.canvas.width, i.canvas.height), pe.set(0, 0, i.canvas.width, i.canvas.height), o.reset(), l.reset(), c.reset();
+    function nt() {
+        s.disable(s.BLEND), s.disable(s.CULL_FACE), s.disable(s.DEPTH_TEST), s.disable(s.POLYGON_OFFSET_FILL), s.disable(s.SCISSOR_TEST), s.disable(s.STENCIL_TEST), s.disable(s.SAMPLE_ALPHA_TO_COVERAGE), s.blendEquation(s.FUNC_ADD), s.blendFunc(s.ONE, s.ZERO), s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO), s.blendColor(0, 0, 0, 0), s.colorMask(!0, !0, !0, !0), s.clearColor(0, 0, 0, 0), s.depthMask(!0), s.depthFunc(s.LESS), s.clearDepth(1), s.stencilMask(4294967295), s.stencilFunc(s.ALWAYS, 0, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), s.clearStencil(0), s.cullFace(s.BACK), s.frontFace(s.CCW), s.polygonOffset(0, 0), s.activeTexture(s.TEXTURE0), s.bindFramebuffer(s.FRAMEBUFFER, null), n === !0 && (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), s.bindFramebuffer(s.READ_FRAMEBUFFER, null)), s.useProgram(null), s.lineWidth(1), s.scissor(0, 0, s.canvas.width, s.canvas.height), s.viewport(0, 0, s.canvas.width, s.canvas.height), f = {}, te = null, fe = {}, h = {}, g = /* @__PURE__ */ new WeakMap(), _ = [], m = null, p = !1, v = null, S = null, y = null, b = null, E = null, T = null, L = null, B = new et(0, 0, 0), x = 0, A = !1, U = null, N = null, P = null, I = null, z = null, J.set(0, 0, s.canvas.width, s.canvas.height), se.set(0, 0, s.canvas.width, s.canvas.height), a.reset(), l.reset(), c.reset();
     }
     return {
         buffers: {
-            color: o,
+            color: a,
             depth: l,
             stencil: c
         },
         enable: ge,
-        disable: Ke,
-        bindFramebuffer: we,
-        drawBuffers: F,
-        useProgram: lt,
-        setBlending: ye,
-        setMaterial: qe,
-        setFlipSided: Ie,
-        setCullFace: Be,
-        setLineWidth: Je,
+        disable: Qe,
+        bindFramebuffer: Re,
+        drawBuffers: O,
+        useProgram: Je,
+        setBlending: Me,
+        setMaterial: ze,
+        setFlipSided: Oe,
+        setCullFace: we,
+        setLineWidth: Ke,
         setPolygonOffset: w,
-        setScissorTest: x,
-        activeTexture: X,
-        bindTexture: Q,
-        unbindTexture: te,
-        compressedTexImage2D: $,
-        compressedTexImage3D: Le,
-        texImage2D: ve,
-        texImage3D: fe,
-        updateUBOMapping: De,
-        uniformBlockBinding: Ue,
-        texStorage2D: C,
-        texStorage3D: le,
-        texSubImage2D: Ae,
-        texSubImage3D: se,
-        compressedTexSubImage2D: ce,
-        compressedTexSubImage3D: Re,
-        scissor: he,
-        viewport: _e,
-        reset: $e
+        setScissorTest: M,
+        activeTexture: k,
+        bindTexture: Z,
+        unbindTexture: re,
+        compressedTexImage2D: ie,
+        compressedTexImage3D: Be,
+        texImage2D: Se,
+        texImage3D: me,
+        updateUBOMapping: Le,
+        uniformBlockBinding: Ne,
+        texStorage2D: R,
+        texStorage3D: ue,
+        texSubImage2D: Pe,
+        texSubImage3D: oe,
+        compressedTexSubImage2D: de,
+        compressedTexSubImage3D: De,
+        scissor: _e,
+        viewport: ve,
+        reset: nt
     };
 }
 
-function qg(i, e, t, n, r, s, a) {
-    const o = r.isWebGL2,
+function G0(s, e, t, n, i, r, o) {
+    const a = i.isWebGL2,
         l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
         c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
-        u = new me(),
-        f = /* @__PURE__ */ new WeakMap();
-    let h;
-    const p = /* @__PURE__ */ new WeakMap();
+        u = new Ee(),
+        d = /* @__PURE__ */ new WeakMap();
+    let f;
+    const h = /* @__PURE__ */ new WeakMap();
     let g = !1;
     try {
         g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
     } catch {}
 
-    function v(w, x) {
+    function _(w, M) {
         return g ? (
             // eslint-disable-next-line compat/compat
-            new OffscreenCanvas(w, x)
-        ) : Jr("canvas");
+            new OffscreenCanvas(w, M)
+        ) : Tr("canvas");
     }
 
-    function m(w, x, X, Q) {
-        let te = 1;
-        const $ = Je(w);
-        if (($.width > Q || $.height > Q) && (te = Q / Math.max($.width, $.height)), te < 1 || x === !0)
+    function m(w, M, k, Z) {
+        let re = 1;
+        const ie = Ke(w);
+        if ((ie.width > Z || ie.height > Z) && (re = Z / Math.max(ie.width, ie.height)), re < 1 || M === !0)
             if (typeof HTMLImageElement < "u" && w instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && w instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && w instanceof ImageBitmap || typeof VideoFrame < "u" && w instanceof VideoFrame) {
-                const Le = x ? Zr : Math.floor,
-                    Ae = Le(te * $.width),
-                    se = Le(te * $.height);
-                h === void 0 && (h = v(Ae, se));
-                const ce = X ? v(Ae, se) : h;
-                return ce.width = Ae, ce.height = se, ce.getContext("2d").drawImage(w, 0, 0, Ae, se), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + $.width + "x" + $.height + ") to (" + Ae + "x" + se + ")."), ce;
+                const Be = M ? Ar : Math.floor,
+                    Pe = Be(re * ie.width),
+                    oe = Be(re * ie.height);
+                f === void 0 && (f = _(Pe, oe));
+                const de = k ? _(Pe, oe) : f;
+                return de.width = Pe, de.height = oe, de.getContext("2d").drawImage(w, 0, 0, Pe, oe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ie.width + "x" + ie.height + ") to (" + Pe + "x" + oe + ")."), de;
             } else
-                return "data" in w && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + $.width + "x" + $.height + ")."), w;
+                return "data" in w && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ie.width + "x" + ie.height + ")."), w;
         return w;
     }
 
-    function d(w) {
-        const x = Je(w);
-        return so(x.width) && so(x.height);
+    function p(w) {
+        const M = Ke(w);
+        return Na(M.width) && Na(M.height);
     }
 
-    function M(w) {
-        return o ? !1 : w.wrapS !== tn || w.wrapT !== tn || w.minFilter !== vt && w.minFilter !== Ct;
+    function v(w) {
+        return a ? !1 : w.wrapS !== dn || w.wrapT !== dn || w.minFilter !== bt && w.minFilter !== Nt;
     }
 
-    function _(w, x) {
-        return w.generateMipmaps && x && w.minFilter !== vt && w.minFilter !== Ct;
+    function S(w, M) {
+        return w.generateMipmaps && M && w.minFilter !== bt && w.minFilter !== Nt;
     }
 
-    function A(w) {
-        i.generateMipmap(w);
+    function y(w) {
+        s.generateMipmap(w);
     }
 
-    function R(w, x, X, Q, te = !1) {
-        if (o === !1)
-            return x;
+    function b(w, M, k, Z, re = !1) {
+        if (a === !1)
+            return M;
         if (w !== null) {
-            if (i[w] !== void 0)
-                return i[w];
+            if (s[w] !== void 0)
+                return s[w];
             console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + w + "'");
         }
-        let $ = x;
-        if (x === i.RED && (X === i.FLOAT && ($ = i.R32F), X === i.HALF_FLOAT && ($ = i.R16F), X === i.UNSIGNED_BYTE && ($ = i.R8)), x === i.RED_INTEGER && (X === i.UNSIGNED_BYTE && ($ = i.R8UI), X === i.UNSIGNED_SHORT && ($ = i.R16UI), X === i.UNSIGNED_INT && ($ = i.R32UI), X === i.BYTE && ($ = i.R8I), X === i.SHORT && ($ = i.R16I), X === i.INT && ($ = i.R32I)), x === i.RG && (X === i.FLOAT && ($ = i.RG32F), X === i.HALF_FLOAT && ($ = i.RG16F), X === i.UNSIGNED_BYTE && ($ = i.RG8)), x === i.RG_INTEGER && (X === i.UNSIGNED_BYTE && ($ = i.RG8UI), X === i.UNSIGNED_SHORT && ($ = i.RG16UI), X === i.UNSIGNED_INT && ($ = i.RG32UI), X === i.BYTE && ($ = i.RG8I), X === i.SHORT && ($ = i.RG16I), X === i.INT && ($ = i.RG32I)), x === i.RGBA) {
-            const Le = te ? Yr : Ze.getTransfer(Q);
-            X === i.FLOAT && ($ = i.RGBA32F), X === i.HALF_FLOAT && ($ = i.RGBA16F), X === i.UNSIGNED_BYTE && ($ = Le === nt ? i.SRGB8_ALPHA8 : i.RGBA8), X === i.UNSIGNED_SHORT_4_4_4_4 && ($ = i.RGBA4), X === i.UNSIGNED_SHORT_5_5_5_1 && ($ = i.RGB5_A1);
+        let ie = M;
+        if (M === s.RED && (k === s.FLOAT && (ie = s.R32F), k === s.HALF_FLOAT && (ie = s.R16F), k === s.UNSIGNED_BYTE && (ie = s.R8)), M === s.RED_INTEGER && (k === s.UNSIGNED_BYTE && (ie = s.R8UI), k === s.UNSIGNED_SHORT && (ie = s.R16UI), k === s.UNSIGNED_INT && (ie = s.R32UI), k === s.BYTE && (ie = s.R8I), k === s.SHORT && (ie = s.R16I), k === s.INT && (ie = s.R32I)), M === s.RG && (k === s.FLOAT && (ie = s.RG32F), k === s.HALF_FLOAT && (ie = s.RG16F), k === s.UNSIGNED_BYTE && (ie = s.RG8)), M === s.RG_INTEGER && (k === s.UNSIGNED_BYTE && (ie = s.RG8UI), k === s.UNSIGNED_SHORT && (ie = s.RG16UI), k === s.UNSIGNED_INT && (ie = s.RG32UI), k === s.BYTE && (ie = s.RG8I), k === s.SHORT && (ie = s.RG16I), k === s.INT && (ie = s.RG32I)), M === s.RGBA) {
+            const Be = re ? xr : tt.getTransfer(Z);
+            k === s.FLOAT && (ie = s.RGBA32F), k === s.HALF_FLOAT && (ie = s.RGBA16F), k === s.UNSIGNED_BYTE && (ie = Be === at ? s.SRGB8_ALPHA8 : s.RGBA8), k === s.UNSIGNED_SHORT_4_4_4_4 && (ie = s.RGBA4), k === s.UNSIGNED_SHORT_5_5_5_1 && (ie = s.RGB5_A1);
         }
-        return ($ === i.R16F || $ === i.R32F || $ === i.RG16F || $ === i.RG32F || $ === i.RGBA16F || $ === i.RGBA32F) && e.get("EXT_color_buffer_float"), $;
+        return (ie === s.R16F || ie === s.R32F || ie === s.RG16F || ie === s.RG32F || ie === s.RGBA16F || ie === s.RGBA32F) && e.get("EXT_color_buffer_float"), ie;
     }
 
-    function E(w, x, X) {
-        return _(w, X) === !0 || w.isFramebufferTexture && w.minFilter !== vt && w.minFilter !== Ct ? Math.log2(Math.max(x.width, x.height)) + 1 : w.mipmaps !== void 0 && w.mipmaps.length > 0 ? w.mipmaps.length : w.isCompressedTexture && Array.isArray(w.image) ? x.mipmaps.length : 1;
+    function E(w, M, k) {
+        return S(w, k) === !0 || w.isFramebufferTexture && w.minFilter !== bt && w.minFilter !== Nt ? Math.log2(Math.max(M.width, M.height)) + 1 : w.mipmaps !== void 0 && w.mipmaps.length > 0 ? w.mipmaps.length : w.isCompressedTexture && Array.isArray(w.image) ? M.mipmaps.length : 1;
     }
 
-    function b(w) {
-        return w === vt || w === ko || w === er ? i.NEAREST : i.LINEAR;
+    function T(w) {
+        return w === bt || w === wo || w === xs ? s.NEAREST : s.LINEAR;
     }
 
-    function I(w) {
-        const x = w.target;
-        x.removeEventListener("dispose", I), S(x), x.isVideoTexture && f.delete(x);
+    function L(w) {
+        const M = w.target;
+        M.removeEventListener("dispose", L), x(M), M.isVideoTexture && d.delete(M);
     }
 
-    function W(w) {
-        const x = w.target;
-        x.removeEventListener("dispose", W), Y(x);
+    function B(w) {
+        const M = w.target;
+        M.removeEventListener("dispose", B), U(M);
     }
 
-    function S(w) {
-        const x = n.get(w);
-        if (x.__webglInit === void 0)
+    function x(w) {
+        const M = n.get(w);
+        if (M.__webglInit === void 0)
             return;
-        const X = w.source,
-            Q = p.get(X);
-        if (Q) {
-            const te = Q[x.__cacheKey];
-            te.usedTimes--, te.usedTimes === 0 && T(w), Object.keys(Q).length === 0 && p.delete(X);
+        const k = w.source,
+            Z = h.get(k);
+        if (Z) {
+            const re = Z[M.__cacheKey];
+            re.usedTimes--, re.usedTimes === 0 && A(w), Object.keys(Z).length === 0 && h.delete(k);
         }
         n.remove(w);
     }
 
-    function T(w) {
-        const x = n.get(w);
-        i.deleteTexture(x.__webglTexture);
-        const X = w.source,
-            Q = p.get(X);
-        delete Q[x.__cacheKey], a.memory.textures--;
+    function A(w) {
+        const M = n.get(w);
+        s.deleteTexture(M.__webglTexture);
+        const k = w.source,
+            Z = h.get(k);
+        delete Z[M.__cacheKey], o.memory.textures--;
     }
 
-    function Y(w) {
-        const x = n.get(w);
+    function U(w) {
+        const M = n.get(w);
         if (w.depthTexture && w.depthTexture.dispose(), w.isWebGLCubeRenderTarget)
-            for (let Q = 0; Q < 6; Q++) {
-                if (Array.isArray(x.__webglFramebuffer[Q]))
-                    for (let te = 0; te < x.__webglFramebuffer[Q].length; te++)
-                        i.deleteFramebuffer(x.__webglFramebuffer[Q][te]);
+            for (let Z = 0; Z < 6; Z++) {
+                if (Array.isArray(M.__webglFramebuffer[Z]))
+                    for (let re = 0; re < M.__webglFramebuffer[Z].length; re++)
+                        s.deleteFramebuffer(M.__webglFramebuffer[Z][re]);
                 else
-                    i.deleteFramebuffer(x.__webglFramebuffer[Q]);
-                x.__webglDepthbuffer && i.deleteRenderbuffer(x.__webglDepthbuffer[Q]);
+                    s.deleteFramebuffer(M.__webglFramebuffer[Z]);
+                M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer[Z]);
             }
         else {
-            if (Array.isArray(x.__webglFramebuffer))
-                for (let Q = 0; Q < x.__webglFramebuffer.length; Q++)
-                    i.deleteFramebuffer(x.__webglFramebuffer[Q]);
+            if (Array.isArray(M.__webglFramebuffer))
+                for (let Z = 0; Z < M.__webglFramebuffer.length; Z++)
+                    s.deleteFramebuffer(M.__webglFramebuffer[Z]);
             else
-                i.deleteFramebuffer(x.__webglFramebuffer);
-            if (x.__webglDepthbuffer && i.deleteRenderbuffer(x.__webglDepthbuffer), x.__webglMultisampledFramebuffer && i.deleteFramebuffer(x.__webglMultisampledFramebuffer), x.__webglColorRenderbuffer)
-                for (let Q = 0; Q < x.__webglColorRenderbuffer.length; Q++)
-                    x.__webglColorRenderbuffer[Q] && i.deleteRenderbuffer(x.__webglColorRenderbuffer[Q]);
-            x.__webglDepthRenderbuffer && i.deleteRenderbuffer(x.__webglDepthRenderbuffer);
-        }
-        const X = w.textures;
-        for (let Q = 0, te = X.length; Q < te; Q++) {
-            const $ = n.get(X[Q]);
-            $.__webglTexture && (i.deleteTexture($.__webglTexture), a.memory.textures--), n.remove(X[Q]);
+                s.deleteFramebuffer(M.__webglFramebuffer);
+            if (M.__webglDepthbuffer && s.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && s.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer)
+                for (let Z = 0; Z < M.__webglColorRenderbuffer.length; Z++)
+                    M.__webglColorRenderbuffer[Z] && s.deleteRenderbuffer(M.__webglColorRenderbuffer[Z]);
+            M.__webglDepthRenderbuffer && s.deleteRenderbuffer(M.__webglDepthRenderbuffer);
+        }
+        const k = w.textures;
+        for (let Z = 0, re = k.length; Z < re; Z++) {
+            const ie = n.get(k[Z]);
+            ie.__webglTexture && (s.deleteTexture(ie.__webglTexture), o.memory.textures--), n.remove(k[Z]);
         }
         n.remove(w);
     }
-    let K = 0;
+    let N = 0;
 
-    function L() {
-        K = 0;
+    function P() {
+        N = 0;
     }
 
-    function N() {
-        const w = K;
-        return w >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + w + " texture units while this GPU supports only " + r.maxTextures), K += 1, w;
+    function I() {
+        const w = N;
+        return w >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + w + " texture units while this GPU supports only " + i.maxTextures), N += 1, w;
     }
 
-    function O(w) {
-        const x = [];
-        return x.push(w.wrapS), x.push(w.wrapT), x.push(w.wrapR || 0), x.push(w.magFilter), x.push(w.minFilter), x.push(w.anisotropy), x.push(w.internalFormat), x.push(w.format), x.push(w.type), x.push(w.generateMipmaps), x.push(w.premultiplyAlpha), x.push(w.flipY), x.push(w.unpackAlignment), x.push(w.colorSpace), x.join();
+    function z(w) {
+        const M = [];
+        return M.push(w.wrapS), M.push(w.wrapT), M.push(w.wrapR || 0), M.push(w.magFilter), M.push(w.minFilter), M.push(w.anisotropy), M.push(w.internalFormat), M.push(w.format), M.push(w.type), M.push(w.generateMipmaps), M.push(w.premultiplyAlpha), M.push(w.flipY), M.push(w.unpackAlignment), M.push(w.colorSpace), M.join();
     }
 
-    function B(w, x) {
-        const X = n.get(w);
-        if (w.isVideoTexture && Ie(w), w.isRenderTargetTexture === !1 && w.version > 0 && X.__version !== w.version) {
-            const Q = w.image;
-            if (Q === null)
+    function K(w, M) {
+        const k = n.get(w);
+        if (w.isVideoTexture && Oe(w), w.isRenderTargetTexture === !1 && w.version > 0 && k.__version !== w.version) {
+            const Z = w.image;
+            if (Z === null)
                 console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
-            else if (Q.complete === !1)
+            else if (Z.complete === !1)
                 console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
             else {
-                pe(X, w, x);
+                se(k, w, M);
                 return;
             }
         }
-        t.bindTexture(i.TEXTURE_2D, X.__webglTexture, i.TEXTURE0 + x);
+        t.bindTexture(s.TEXTURE_2D, k.__webglTexture, s.TEXTURE0 + M);
     }
 
-    function j(w, x) {
-        const X = n.get(w);
-        if (w.version > 0 && X.__version !== w.version) {
-            pe(X, w, x);
+    function G(w, M) {
+        const k = n.get(w);
+        if (w.version > 0 && k.__version !== w.version) {
+            se(k, w, M);
             return;
         }
-        t.bindTexture(i.TEXTURE_2D_ARRAY, X.__webglTexture, i.TEXTURE0 + x);
+        t.bindTexture(s.TEXTURE_2D_ARRAY, k.__webglTexture, s.TEXTURE0 + M);
     }
 
-    function q(w, x) {
-        const X = n.get(w);
-        if (w.version > 0 && X.__version !== w.version) {
-            pe(X, w, x);
+    function q(w, M) {
+        const k = n.get(w);
+        if (w.version > 0 && k.__version !== w.version) {
+            se(k, w, M);
             return;
         }
-        t.bindTexture(i.TEXTURE_3D, X.__webglTexture, i.TEXTURE0 + x);
+        t.bindTexture(s.TEXTURE_3D, k.__webglTexture, s.TEXTURE0 + M);
     }
 
-    function J(w, x) {
-        const X = n.get(w);
-        if (w.version > 0 && X.__version !== w.version) {
-            Te(X, w, x);
+    function Q(w, M) {
+        const k = n.get(w);
+        if (w.version > 0 && k.__version !== w.version) {
+            Ae(k, w, M);
             return;
         }
-        t.bindTexture(i.TEXTURE_CUBE_MAP, X.__webglTexture, i.TEXTURE0 + x);
+        t.bindTexture(s.TEXTURE_CUBE_MAP, k.__webglTexture, s.TEXTURE0 + M);
     }
-    const ne = {
-            [to]: i.REPEAT,
-            [tn]: i.CLAMP_TO_EDGE,
-            [no]: i.MIRRORED_REPEAT
-        },
-        ue = {
-            [vt]: i.NEAREST,
-            [ko]: i.NEAREST_MIPMAP_NEAREST,
-            [er]: i.NEAREST_MIPMAP_LINEAR,
-            [Ct]: i.LINEAR,
-            [_s]: i.LINEAR_MIPMAP_NEAREST,
-            [ni]: i.LINEAR_MIPMAP_LINEAR
-        },
-        Z = {
-            [Sf]: i.NEVER,
-            [Tf]: i.ALWAYS,
-            [Mf]: i.LESS,
-            [Wl]: i.LEQUAL,
-            [yf]: i.EQUAL,
-            [bf]: i.GEQUAL,
-            [Af]: i.GREATER,
-            [Ef]: i.NOTEQUAL
+    const te = {
+            [Ua]: s.REPEAT,
+            [dn]: s.CLAMP_TO_EDGE,
+            [Ba]: s.MIRRORED_REPEAT
+        },
+        fe = {
+            [bt]: s.NEAREST,
+            [wo]: s.NEAREST_MIPMAP_NEAREST,
+            [xs]: s.NEAREST_MIPMAP_LINEAR,
+            [Nt]: s.LINEAR,
+            [Yr]: s.LINEAR_MIPMAP_NEAREST,
+            [mi]: s.LINEAR_MIPMAP_LINEAR
+        },
+        ne = {
+            [gf]: s.NEVER,
+            [Mf]: s.ALWAYS,
+            [_f]: s.LESS,
+            [Nc]: s.LEQUAL,
+            [Sf]: s.EQUAL,
+            [yf]: s.GEQUAL,
+            [vf]: s.GREATER,
+            [xf]: s.NOTEQUAL
         };
 
-    function H(w, x, X) {
-        if (x.type === an && e.has("OES_texture_float_linear") === !1 && (x.magFilter === Ct || x.magFilter === _s || x.magFilter === er || x.magFilter === ni || x.minFilter === Ct || x.minFilter === _s || x.minFilter === er || x.minFilter === ni) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), X ? (i.texParameteri(w, i.TEXTURE_WRAP_S, ne[x.wrapS]), i.texParameteri(w, i.TEXTURE_WRAP_T, ne[x.wrapT]), (w === i.TEXTURE_3D || w === i.TEXTURE_2D_ARRAY) && i.texParameteri(w, i.TEXTURE_WRAP_R, ne[x.wrapR]), i.texParameteri(w, i.TEXTURE_MAG_FILTER, ue[x.magFilter]), i.texParameteri(w, i.TEXTURE_MIN_FILTER, ue[x.minFilter])) : (i.texParameteri(w, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(w, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), (w === i.TEXTURE_3D || w === i.TEXTURE_2D_ARRAY) && i.texParameteri(w, i.TEXTURE_WRAP_R, i.CLAMP_TO_EDGE), (x.wrapS !== tn || x.wrapT !== tn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(w, i.TEXTURE_MAG_FILTER, b(x.magFilter)), i.texParameteri(w, i.TEXTURE_MIN_FILTER, b(x.minFilter)), x.minFilter !== vt && x.minFilter !== Ct && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), x.compareFunction && (i.texParameteri(w, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE), i.texParameteri(w, i.TEXTURE_COMPARE_FUNC, Z[x.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
-            if (x.magFilter === vt || x.minFilter !== er && x.minFilter !== ni || x.type === an && e.has("OES_texture_float_linear") === !1 || o === !1 && x.type === Gi && e.has("OES_texture_half_float_linear") === !1)
+    function V(w, M, k) {
+        if (M.type === gn && e.has("OES_texture_float_linear") === !1 && (M.magFilter === Nt || M.magFilter === Yr || M.magFilter === xs || M.magFilter === mi || M.minFilter === Nt || M.minFilter === Yr || M.minFilter === xs || M.minFilter === mi) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), k ? (s.texParameteri(w, s.TEXTURE_WRAP_S, te[M.wrapS]), s.texParameteri(w, s.TEXTURE_WRAP_T, te[M.wrapT]), (w === s.TEXTURE_3D || w === s.TEXTURE_2D_ARRAY) && s.texParameteri(w, s.TEXTURE_WRAP_R, te[M.wrapR]), s.texParameteri(w, s.TEXTURE_MAG_FILTER, fe[M.magFilter]), s.texParameteri(w, s.TEXTURE_MIN_FILTER, fe[M.minFilter])) : (s.texParameteri(w, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(w, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE), (w === s.TEXTURE_3D || w === s.TEXTURE_2D_ARRAY) && s.texParameteri(w, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE), (M.wrapS !== dn || M.wrapT !== dn) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), s.texParameteri(w, s.TEXTURE_MAG_FILTER, T(M.magFilter)), s.texParameteri(w, s.TEXTURE_MIN_FILTER, T(M.minFilter)), M.minFilter !== bt && M.minFilter !== Nt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), M.compareFunction && (s.texParameteri(w, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE), s.texParameteri(w, s.TEXTURE_COMPARE_FUNC, ne[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
+            if (M.magFilter === bt || M.minFilter !== xs && M.minFilter !== mi || M.type === gn && e.has("OES_texture_float_linear") === !1 || a === !1 && M.type === xi && e.has("OES_texture_half_float_linear") === !1)
                 return;
-            if (x.anisotropy > 1 || n.get(x).__currentAnisotropy) {
-                const Q = e.get("EXT_texture_filter_anisotropic");
-                i.texParameterf(w, Q.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(x.anisotropy, r.getMaxAnisotropy())), n.get(x).__currentAnisotropy = x.anisotropy;
+            if (M.anisotropy > 1 || n.get(M).__currentAnisotropy) {
+                const Z = e.get("EXT_texture_filter_anisotropic");
+                s.texParameterf(w, Z.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, i.getMaxAnisotropy())), n.get(M).__currentAnisotropy = M.anisotropy;
             }
         }
     }
 
-    function ee(w, x) {
-        let X = !1;
-        w.__webglInit === void 0 && (w.__webglInit = !0, x.addEventListener("dispose", I));
-        const Q = x.source;
-        let te = p.get(Q);
-        te === void 0 && (te = {}, p.set(Q, te));
-        const $ = O(x);
-        if ($ !== w.__cacheKey) {
-            te[$] === void 0 && (te[$] = {
-                texture: i.createTexture(),
+    function J(w, M) {
+        let k = !1;
+        w.__webglInit === void 0 && (w.__webglInit = !0, M.addEventListener("dispose", L));
+        const Z = M.source;
+        let re = h.get(Z);
+        re === void 0 && (re = {}, h.set(Z, re));
+        const ie = z(M);
+        if (ie !== w.__cacheKey) {
+            re[ie] === void 0 && (re[ie] = {
+                texture: s.createTexture(),
                 usedTimes: 0
-            }, a.memory.textures++, X = !0), te[$].usedTimes++;
-            const Le = te[w.__cacheKey];
-            Le !== void 0 && (te[w.__cacheKey].usedTimes--, Le.usedTimes === 0 && T(x)), w.__cacheKey = $, w.__webglTexture = te[$].texture;
-        }
-        return X;
-    }
-
-    function pe(w, x, X) {
-        let Q = i.TEXTURE_2D;
-        (x.isDataArrayTexture || x.isCompressedArrayTexture) && (Q = i.TEXTURE_2D_ARRAY), x.isData3DTexture && (Q = i.TEXTURE_3D);
-        const te = ee(w, x),
-            $ = x.source;
-        t.bindTexture(Q, w.__webglTexture, i.TEXTURE0 + X);
-        const Le = n.get($);
-        if ($.version !== Le.__version || te === !0) {
-            t.activeTexture(i.TEXTURE0 + X);
-            const Ae = Ze.getPrimaries(Ze.workingColorSpace),
-                se = x.colorSpace === Nn ? null : Ze.getPrimaries(x.colorSpace),
-                ce = x.colorSpace === Nn || Ae === se ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
-            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, x.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, x.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, ce);
-            const Re = M(x) && d(x.image) === !1;
-            let C = m(x.image, Re, !1, r.maxTextureSize);
-            C = Be(x, C);
-            const le = d(C) || o,
-                ve = s.convert(x.format, x.colorSpace);
-            let fe = s.convert(x.type),
-                he = R(x.internalFormat, ve, fe, x.colorSpace, x.isVideoTexture);
-            H(Q, x, le);
-            let _e;
-            const De = x.mipmaps,
-                Ue = o && x.isVideoTexture !== !0 && he !== Vl,
-                $e = Le.__version === void 0 || te === !0,
-                D = $.dataReady,
-                re = E(x, C, le);
-            if (x.isDepthTexture)
-                he = i.DEPTH_COMPONENT, o ? x.type === an ? he = i.DEPTH_COMPONENT32F : x.type === nn ? he = i.DEPTH_COMPONENT24 : x.type === si ? he = i.DEPTH24_STENCIL8 : he = i.DEPTH_COMPONENT16 : x.type === an && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), x.format === Hn && he === i.DEPTH_COMPONENT && x.type !== fo && x.type !== nn && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), x.type = nn, fe = s.convert(x.type)), x.format === Hi && he === i.DEPTH_COMPONENT && (he = i.DEPTH_STENCIL, x.type !== si && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), x.type = si, fe = s.convert(x.type))), $e && (Ue ? t.texStorage2D(i.TEXTURE_2D, 1, he, C.width, C.height) : t.texImage2D(i.TEXTURE_2D, 0, he, C.width, C.height, 0, ve, fe, null));
-            else if (x.isDataTexture)
-                if (De.length > 0 && le) {
-                    Ue && $e && t.texStorage2D(i.TEXTURE_2D, re, he, De[0].width, De[0].height);
-                    for (let z = 0, ie = De.length; z < ie; z++)
-                        _e = De[z], Ue ? D && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, _e.width, _e.height, ve, fe, _e.data) : t.texImage2D(i.TEXTURE_2D, z, he, _e.width, _e.height, 0, ve, fe, _e.data);
-                    x.generateMipmaps = !1;
+            }, o.memory.textures++, k = !0), re[ie].usedTimes++;
+            const Be = re[w.__cacheKey];
+            Be !== void 0 && (re[w.__cacheKey].usedTimes--, Be.usedTimes === 0 && A(M)), w.__cacheKey = ie, w.__webglTexture = re[ie].texture;
+        }
+        return k;
+    }
+
+    function se(w, M, k) {
+        let Z = s.TEXTURE_2D;
+        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Z = s.TEXTURE_2D_ARRAY), M.isData3DTexture && (Z = s.TEXTURE_3D);
+        const re = J(w, M),
+            ie = M.source;
+        t.bindTexture(Z, w.__webglTexture, s.TEXTURE0 + k);
+        const Be = n.get(ie);
+        if (ie.version !== Be.__version || re === !0) {
+            t.activeTexture(s.TEXTURE0 + k);
+            const Pe = tt.getPrimaries(tt.workingColorSpace),
+                oe = M.colorSpace === Zn ? null : tt.getPrimaries(M.colorSpace),
+                de = M.colorSpace === Zn || Pe === oe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
+            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, de);
+            const De = v(M) && p(M.image) === !1;
+            let R = m(M.image, De, !1, i.maxTextureSize);
+            R = we(M, R);
+            const ue = p(R) || a,
+                Se = r.convert(M.format, M.colorSpace);
+            let me = r.convert(M.type),
+                _e = b(M.internalFormat, Se, me, M.colorSpace, M.isVideoTexture);
+            V(Z, M, ue);
+            let ve;
+            const Le = M.mipmaps,
+                Ne = a && M.isVideoTexture !== !0 && _e !== Oc,
+                nt = Be.__version === void 0 || re === !0,
+                F = ie.dataReady,
+                ce = E(M, R, ue);
+            if (M.isDepthTexture)
+                _e = s.DEPTH_COMPONENT, a ? M.type === gn ? _e = s.DEPTH_COMPONENT32F : M.type === fn ? _e = s.DEPTH_COMPONENT24 : M.type === vi ? _e = s.DEPTH24_STENCIL8 : _e = s.DEPTH_COMPONENT16 : M.type === gn && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), M.format === ei && _e === s.DEPTH_COMPONENT && M.type !== ja && M.type !== fn && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), M.type = fn, me = r.convert(M.type)), M.format === cs && _e === s.DEPTH_COMPONENT && (_e = s.DEPTH_STENCIL, M.type !== vi && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), M.type = vi, me = r.convert(M.type))), nt && (Ne ? t.texStorage2D(s.TEXTURE_2D, 1, _e, R.width, R.height) : t.texImage2D(s.TEXTURE_2D, 0, _e, R.width, R.height, 0, Se, me, null));
+            else if (M.isDataTexture)
+                if (Le.length > 0 && ue) {
+                    Ne && nt && t.texStorage2D(s.TEXTURE_2D, ce, _e, Le[0].width, Le[0].height);
+                    for (let W = 0, ae = Le.length; W < ae; W++)
+                        ve = Le[W], Ne ? F && t.texSubImage2D(s.TEXTURE_2D, W, 0, 0, ve.width, ve.height, Se, me, ve.data) : t.texImage2D(s.TEXTURE_2D, W, _e, ve.width, ve.height, 0, Se, me, ve.data);
+                    M.generateMipmaps = !1;
                 } else
-                    Ue ? ($e && t.texStorage2D(i.TEXTURE_2D, re, he, C.width, C.height), D && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, C.width, C.height, ve, fe, C.data)) : t.texImage2D(i.TEXTURE_2D, 0, he, C.width, C.height, 0, ve, fe, C.data);
-            else if (x.isCompressedTexture)
-                if (x.isCompressedArrayTexture) {
-                    Ue && $e && t.texStorage3D(i.TEXTURE_2D_ARRAY, re, he, De[0].width, De[0].height, C.depth);
-                    for (let z = 0, ie = De.length; z < ie; z++)
-                        _e = De[z], x.format !== Vt ? ve !== null ? Ue ? D && t.compressedTexSubImage3D(i.TEXTURE_2D_ARRAY, z, 0, 0, 0, _e.width, _e.height, C.depth, ve, _e.data, 0, 0) : t.compressedTexImage3D(i.TEXTURE_2D_ARRAY, z, he, _e.width, _e.height, C.depth, 0, _e.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ue ? D && t.texSubImage3D(i.TEXTURE_2D_ARRAY, z, 0, 0, 0, _e.width, _e.height, C.depth, ve, fe, _e.data) : t.texImage3D(i.TEXTURE_2D_ARRAY, z, he, _e.width, _e.height, C.depth, 0, ve, fe, _e.data);
+                    Ne ? (nt && t.texStorage2D(s.TEXTURE_2D, ce, _e, R.width, R.height), F && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, R.width, R.height, Se, me, R.data)) : t.texImage2D(s.TEXTURE_2D, 0, _e, R.width, R.height, 0, Se, me, R.data);
+            else if (M.isCompressedTexture)
+                if (M.isCompressedArrayTexture) {
+                    Ne && nt && t.texStorage3D(s.TEXTURE_2D_ARRAY, ce, _e, Le[0].width, Le[0].height, R.depth);
+                    for (let W = 0, ae = Le.length; W < ae; W++)
+                        ve = Le[W], M.format !== kt ? Se !== null ? Ne ? F && t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, W, 0, 0, 0, ve.width, ve.height, R.depth, Se, ve.data, 0, 0) : t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, W, _e, ve.width, ve.height, R.depth, 0, ve.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ne ? F && t.texSubImage3D(s.TEXTURE_2D_ARRAY, W, 0, 0, 0, ve.width, ve.height, R.depth, Se, me, ve.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, W, _e, ve.width, ve.height, R.depth, 0, Se, me, ve.data);
                 } else {
-                    Ue && $e && t.texStorage2D(i.TEXTURE_2D, re, he, De[0].width, De[0].height);
-                    for (let z = 0, ie = De.length; z < ie; z++)
-                        _e = De[z], x.format !== Vt ? ve !== null ? Ue ? D && t.compressedTexSubImage2D(i.TEXTURE_2D, z, 0, 0, _e.width, _e.height, ve, _e.data) : t.compressedTexImage2D(i.TEXTURE_2D, z, he, _e.width, _e.height, 0, _e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ue ? D && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, _e.width, _e.height, ve, fe, _e.data) : t.texImage2D(i.TEXTURE_2D, z, he, _e.width, _e.height, 0, ve, fe, _e.data);
-                }
-            else if (x.isDataArrayTexture)
-                Ue ? ($e && t.texStorage3D(i.TEXTURE_2D_ARRAY, re, he, C.width, C.height, C.depth), D && t.texSubImage3D(i.TEXTURE_2D_ARRAY, 0, 0, 0, 0, C.width, C.height, C.depth, ve, fe, C.data)) : t.texImage3D(i.TEXTURE_2D_ARRAY, 0, he, C.width, C.height, C.depth, 0, ve, fe, C.data);
-            else if (x.isData3DTexture)
-                Ue ? ($e && t.texStorage3D(i.TEXTURE_3D, re, he, C.width, C.height, C.depth), D && t.texSubImage3D(i.TEXTURE_3D, 0, 0, 0, 0, C.width, C.height, C.depth, ve, fe, C.data)) : t.texImage3D(i.TEXTURE_3D, 0, he, C.width, C.height, C.depth, 0, ve, fe, C.data);
-            else if (x.isFramebufferTexture) {
-                if ($e)
-                    if (Ue)
-                        t.texStorage2D(i.TEXTURE_2D, re, he, C.width, C.height);
+                    Ne && nt && t.texStorage2D(s.TEXTURE_2D, ce, _e, Le[0].width, Le[0].height);
+                    for (let W = 0, ae = Le.length; W < ae; W++)
+                        ve = Le[W], M.format !== kt ? Se !== null ? Ne ? F && t.compressedTexSubImage2D(s.TEXTURE_2D, W, 0, 0, ve.width, ve.height, Se, ve.data) : t.compressedTexImage2D(s.TEXTURE_2D, W, _e, ve.width, ve.height, 0, ve.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ne ? F && t.texSubImage2D(s.TEXTURE_2D, W, 0, 0, ve.width, ve.height, Se, me, ve.data) : t.texImage2D(s.TEXTURE_2D, W, _e, ve.width, ve.height, 0, Se, me, ve.data);
+                }
+            else if (M.isDataArrayTexture)
+                Ne ? (nt && t.texStorage3D(s.TEXTURE_2D_ARRAY, ce, _e, R.width, R.height, R.depth), F && t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, R.width, R.height, R.depth, Se, me, R.data)) : t.texImage3D(s.TEXTURE_2D_ARRAY, 0, _e, R.width, R.height, R.depth, 0, Se, me, R.data);
+            else if (M.isData3DTexture)
+                Ne ? (nt && t.texStorage3D(s.TEXTURE_3D, ce, _e, R.width, R.height, R.depth), F && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, R.width, R.height, R.depth, Se, me, R.data)) : t.texImage3D(s.TEXTURE_3D, 0, _e, R.width, R.height, R.depth, 0, Se, me, R.data);
+            else if (M.isFramebufferTexture) {
+                if (nt)
+                    if (Ne)
+                        t.texStorage2D(s.TEXTURE_2D, ce, _e, R.width, R.height);
                     else {
-                        let z = C.width,
-                            ie = C.height;
-                        for (let ae = 0; ae < re; ae++)
-                            t.texImage2D(i.TEXTURE_2D, ae, he, z, ie, 0, ve, fe, null), z >>= 1, ie >>= 1;
+                        let W = R.width,
+                            ae = R.height;
+                        for (let pe = 0; pe < ce; pe++)
+                            t.texImage2D(s.TEXTURE_2D, pe, _e, W, ae, 0, Se, me, null), W >>= 1, ae >>= 1;
                     }
-            } else if (De.length > 0 && le) {
-                if (Ue && $e) {
-                    const z = Je(De[0]);
-                    t.texStorage2D(i.TEXTURE_2D, re, he, z.width, z.height);
-                }
-                for (let z = 0, ie = De.length; z < ie; z++)
-                    _e = De[z], Ue ? D && t.texSubImage2D(i.TEXTURE_2D, z, 0, 0, ve, fe, _e) : t.texImage2D(i.TEXTURE_2D, z, he, ve, fe, _e);
-                x.generateMipmaps = !1;
-            } else if (Ue) {
-                if ($e) {
-                    const z = Je(C);
-                    t.texStorage2D(i.TEXTURE_2D, re, he, z.width, z.height);
+            } else if (Le.length > 0 && ue) {
+                if (Ne && nt) {
+                    const W = Ke(Le[0]);
+                    t.texStorage2D(s.TEXTURE_2D, ce, _e, W.width, W.height);
+                }
+                for (let W = 0, ae = Le.length; W < ae; W++)
+                    ve = Le[W], Ne ? F && t.texSubImage2D(s.TEXTURE_2D, W, 0, 0, Se, me, ve) : t.texImage2D(s.TEXTURE_2D, W, _e, Se, me, ve);
+                M.generateMipmaps = !1;
+            } else if (Ne) {
+                if (nt) {
+                    const W = Ke(R);
+                    t.texStorage2D(s.TEXTURE_2D, ce, _e, W.width, W.height);
                 }
-                D && t.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, ve, fe, C);
+                F && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Se, me, R);
             } else
-                t.texImage2D(i.TEXTURE_2D, 0, he, ve, fe, C);
-            _(x, le) && A(Q), Le.__version = $.version, x.onUpdate && x.onUpdate(x);
+                t.texImage2D(s.TEXTURE_2D, 0, _e, Se, me, R);
+            S(M, ue) && y(Z), Be.__version = ie.version, M.onUpdate && M.onUpdate(M);
         }
-        w.__version = x.version;
+        w.__version = M.version;
     }
 
-    function Te(w, x, X) {
-        if (x.image.length !== 6)
+    function Ae(w, M, k) {
+        if (M.image.length !== 6)
             return;
-        const Q = ee(w, x),
-            te = x.source;
-        t.bindTexture(i.TEXTURE_CUBE_MAP, w.__webglTexture, i.TEXTURE0 + X);
-        const $ = n.get(te);
-        if (te.version !== $.__version || Q === !0) {
-            t.activeTexture(i.TEXTURE0 + X);
-            const Le = Ze.getPrimaries(Ze.workingColorSpace),
-                Ae = x.colorSpace === Nn ? null : Ze.getPrimaries(x.colorSpace),
-                se = x.colorSpace === Nn || Le === Ae ? i.NONE : i.BROWSER_DEFAULT_WEBGL;
-            i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, x.flipY), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha), i.pixelStorei(i.UNPACK_ALIGNMENT, x.unpackAlignment), i.pixelStorei(i.UNPACK_COLORSPACE_CONVERSION_WEBGL, se);
-            const ce = x.isCompressedTexture || x.image[0].isCompressedTexture,
-                Re = x.image[0] && x.image[0].isDataTexture,
-                C = [];
-            for (let z = 0; z < 6; z++)
-                !ce && !Re ? C[z] = m(x.image[z], !1, !0, r.maxCubemapSize) : C[z] = Re ? x.image[z].image : x.image[z], C[z] = Be(x, C[z]);
-            const le = C[0],
-                ve = d(le) || o,
-                fe = s.convert(x.format, x.colorSpace),
-                he = s.convert(x.type),
-                _e = R(x.internalFormat, fe, he, x.colorSpace),
-                De = o && x.isVideoTexture !== !0,
-                Ue = $.__version === void 0 || Q === !0,
-                $e = te.dataReady;
-            let D = E(x, le, ve);
-            H(i.TEXTURE_CUBE_MAP, x, ve);
-            let re;
-            if (ce) {
-                De && Ue && t.texStorage2D(i.TEXTURE_CUBE_MAP, D, _e, le.width, le.height);
-                for (let z = 0; z < 6; z++) {
-                    re = C[z].mipmaps;
-                    for (let ie = 0; ie < re.length; ie++) {
-                        const ae = re[ie];
-                        x.format !== Vt ? fe !== null ? De ? $e && t.compressedTexSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie, 0, 0, ae.width, ae.height, fe, ae.data) : t.compressedTexImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie, _e, ae.width, ae.height, 0, ae.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : De ? $e && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie, 0, 0, ae.width, ae.height, fe, he, ae.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie, _e, ae.width, ae.height, 0, fe, he, ae.data);
+        const Z = J(w, M),
+            re = M.source;
+        t.bindTexture(s.TEXTURE_CUBE_MAP, w.__webglTexture, s.TEXTURE0 + k);
+        const ie = n.get(re);
+        if (re.version !== ie.__version || Z === !0) {
+            t.activeTexture(s.TEXTURE0 + k);
+            const Be = tt.getPrimaries(tt.workingColorSpace),
+                Pe = M.colorSpace === Zn ? null : tt.getPrimaries(M.colorSpace),
+                oe = M.colorSpace === Zn || Be === Pe ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
+            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, M.flipY), s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), s.pixelStorei(s.UNPACK_ALIGNMENT, M.unpackAlignment), s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, oe);
+            const de = M.isCompressedTexture || M.image[0].isCompressedTexture,
+                De = M.image[0] && M.image[0].isDataTexture,
+                R = [];
+            for (let W = 0; W < 6; W++)
+                !de && !De ? R[W] = m(M.image[W], !1, !0, i.maxCubemapSize) : R[W] = De ? M.image[W].image : M.image[W], R[W] = we(M, R[W]);
+            const ue = R[0],
+                Se = p(ue) || a,
+                me = r.convert(M.format, M.colorSpace),
+                _e = r.convert(M.type),
+                ve = b(M.internalFormat, me, _e, M.colorSpace),
+                Le = a && M.isVideoTexture !== !0,
+                Ne = ie.__version === void 0 || Z === !0,
+                nt = re.dataReady;
+            let F = E(M, ue, Se);
+            V(s.TEXTURE_CUBE_MAP, M, Se);
+            let ce;
+            if (de) {
+                Le && Ne && t.texStorage2D(s.TEXTURE_CUBE_MAP, F, ve, ue.width, ue.height);
+                for (let W = 0; W < 6; W++) {
+                    ce = R[W].mipmaps;
+                    for (let ae = 0; ae < ce.length; ae++) {
+                        const pe = ce[ae];
+                        M.format !== kt ? me !== null ? Le ? nt && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae, 0, 0, pe.width, pe.height, me, pe.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae, ve, pe.width, pe.height, 0, pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Le ? nt && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae, 0, 0, pe.width, pe.height, me, _e, pe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae, ve, pe.width, pe.height, 0, me, _e, pe.data);
                     }
                 }
             } else {
-                if (re = x.mipmaps, De && Ue) {
-                    re.length > 0 && D++;
-                    const z = Je(C[0]);
-                    t.texStorage2D(i.TEXTURE_CUBE_MAP, D, _e, z.width, z.height);
-                }
-                for (let z = 0; z < 6; z++)
-                    if (Re) {
-                        De ? $e && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, 0, 0, C[z].width, C[z].height, fe, he, C[z].data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, _e, C[z].width, C[z].height, 0, fe, he, C[z].data);
-                        for (let ie = 0; ie < re.length; ie++) {
-                            const Oe = re[ie].image[z].image;
-                            De ? $e && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie + 1, 0, 0, Oe.width, Oe.height, fe, he, Oe.data) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie + 1, _e, Oe.width, Oe.height, 0, fe, he, Oe.data);
+                if (ce = M.mipmaps, Le && Ne) {
+                    ce.length > 0 && F++;
+                    const W = Ke(R[0]);
+                    t.texStorage2D(s.TEXTURE_CUBE_MAP, F, ve, W.width, W.height);
+                }
+                for (let W = 0; W < 6; W++)
+                    if (De) {
+                        Le ? nt && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, R[W].width, R[W].height, me, _e, R[W].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, ve, R[W].width, R[W].height, 0, me, _e, R[W].data);
+                        for (let ae = 0; ae < ce.length; ae++) {
+                            const Ve = ce[ae].image[W].image;
+                            Le ? nt && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae + 1, 0, 0, Ve.width, Ve.height, me, _e, Ve.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae + 1, ve, Ve.width, Ve.height, 0, me, _e, Ve.data);
                         }
                     } else {
-                        De ? $e && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, 0, 0, fe, he, C[z]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, 0, _e, fe, he, C[z]);
-                        for (let ie = 0; ie < re.length; ie++) {
-                            const ae = re[ie];
-                            De ? $e && t.texSubImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie + 1, 0, 0, fe, he, ae.image[z]) : t.texImage2D(i.TEXTURE_CUBE_MAP_POSITIVE_X + z, ie + 1, _e, fe, he, ae.image[z]);
+                        Le ? nt && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, me, _e, R[W]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, ve, me, _e, R[W]);
+                        for (let ae = 0; ae < ce.length; ae++) {
+                            const pe = ce[ae];
+                            Le ? nt && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae + 1, 0, 0, me, _e, pe.image[W]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + W, ae + 1, ve, me, _e, pe.image[W]);
                         }
                     }
             }
-            _(x, ve) && A(i.TEXTURE_CUBE_MAP), $.__version = te.version, x.onUpdate && x.onUpdate(x);
+            S(M, Se) && y(s.TEXTURE_CUBE_MAP), ie.__version = re.version, M.onUpdate && M.onUpdate(M);
         }
-        w.__version = x.version;
+        w.__version = M.version;
     }
 
-    function xe(w, x, X, Q, te, $) {
-        const Le = s.convert(X.format, X.colorSpace),
-            Ae = s.convert(X.type),
-            se = R(X.internalFormat, Le, Ae, X.colorSpace);
-        if (!n.get(x).__hasExternalTextures) {
-            const Re = Math.max(1, x.width >> $),
-                C = Math.max(1, x.height >> $);
-            te === i.TEXTURE_3D || te === i.TEXTURE_2D_ARRAY ? t.texImage3D(te, $, se, Re, C, x.depth, 0, Le, Ae, null) : t.texImage2D(te, $, se, Re, C, 0, Le, Ae, null);
-        }
-        t.bindFramebuffer(i.FRAMEBUFFER, w), qe(x) ? l.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, Q, te, n.get(X).__webglTexture, 0, ye(x)) : (te === i.TEXTURE_2D || te >= i.TEXTURE_CUBE_MAP_POSITIVE_X && te <= i.TEXTURE_CUBE_MAP_NEGATIVE_Z) && i.framebufferTexture2D(i.FRAMEBUFFER, Q, te, n.get(X).__webglTexture, $), t.bindFramebuffer(i.FRAMEBUFFER, null);
-    }
-
-    function ge(w, x, X) {
-        if (i.bindRenderbuffer(i.RENDERBUFFER, w), x.depthBuffer && !x.stencilBuffer) {
-            let Q = o === !0 ? i.DEPTH_COMPONENT24 : i.DEPTH_COMPONENT16;
-            if (X || qe(x)) {
-                const te = x.depthTexture;
-                te && te.isDepthTexture && (te.type === an ? Q = i.DEPTH_COMPONENT32F : te.type === nn && (Q = i.DEPTH_COMPONENT24));
-                const $ = ye(x);
-                qe(x) ? l.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, $, Q, x.width, x.height) : i.renderbufferStorageMultisample(i.RENDERBUFFER, $, Q, x.width, x.height);
+    function xe(w, M, k, Z, re, ie) {
+        const Be = r.convert(k.format, k.colorSpace),
+            Pe = r.convert(k.type),
+            oe = b(k.internalFormat, Be, Pe, k.colorSpace);
+        if (!n.get(M).__hasExternalTextures) {
+            const De = Math.max(1, M.width >> ie),
+                R = Math.max(1, M.height >> ie);
+            re === s.TEXTURE_3D || re === s.TEXTURE_2D_ARRAY ? t.texImage3D(re, ie, oe, De, R, M.depth, 0, Be, Pe, null) : t.texImage2D(re, ie, oe, De, R, 0, Be, Pe, null);
+        }
+        t.bindFramebuffer(s.FRAMEBUFFER, w), ze(M) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, Z, re, n.get(k).__webglTexture, 0, Me(M)) : (re === s.TEXTURE_2D || re >= s.TEXTURE_CUBE_MAP_POSITIVE_X && re <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, Z, re, n.get(k).__webglTexture, ie), t.bindFramebuffer(s.FRAMEBUFFER, null);
+    }
+
+    function ge(w, M, k) {
+        if (s.bindRenderbuffer(s.RENDERBUFFER, w), M.depthBuffer && !M.stencilBuffer) {
+            let Z = a === !0 ? s.DEPTH_COMPONENT24 : s.DEPTH_COMPONENT16;
+            if (k || ze(M)) {
+                const re = M.depthTexture;
+                re && re.isDepthTexture && (re.type === gn ? Z = s.DEPTH_COMPONENT32F : re.type === fn && (Z = s.DEPTH_COMPONENT24));
+                const ie = Me(M);
+                ze(M) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ie, Z, M.width, M.height) : s.renderbufferStorageMultisample(s.RENDERBUFFER, ie, Z, M.width, M.height);
             } else
-                i.renderbufferStorage(i.RENDERBUFFER, Q, x.width, x.height);
-            i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, w);
-        } else if (x.depthBuffer && x.stencilBuffer) {
-            const Q = ye(x);
-            X && qe(x) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, Q, i.DEPTH24_STENCIL8, x.width, x.height) : qe(x) ? l.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, Q, i.DEPTH24_STENCIL8, x.width, x.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, x.width, x.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, w);
+                s.renderbufferStorage(s.RENDERBUFFER, Z, M.width, M.height);
+            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, w);
+        } else if (M.depthBuffer && M.stencilBuffer) {
+            const Z = Me(M);
+            k && ze(M) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Z, s.DEPTH24_STENCIL8, M.width, M.height) : ze(M) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Z, s.DEPTH24_STENCIL8, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, M.width, M.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, w);
         } else {
-            const Q = x.textures;
-            for (let te = 0; te < Q.length; te++) {
-                const $ = Q[te],
-                    Le = s.convert($.format, $.colorSpace),
-                    Ae = s.convert($.type),
-                    se = R($.internalFormat, Le, Ae, $.colorSpace),
-                    ce = ye(x);
-                X && qe(x) === !1 ? i.renderbufferStorageMultisample(i.RENDERBUFFER, ce, se, x.width, x.height) : qe(x) ? l.renderbufferStorageMultisampleEXT(i.RENDERBUFFER, ce, se, x.width, x.height) : i.renderbufferStorage(i.RENDERBUFFER, se, x.width, x.height);
+            const Z = M.textures;
+            for (let re = 0; re < Z.length; re++) {
+                const ie = Z[re],
+                    Be = r.convert(ie.format, ie.colorSpace),
+                    Pe = r.convert(ie.type),
+                    oe = b(ie.internalFormat, Be, Pe, ie.colorSpace),
+                    de = Me(M);
+                k && ze(M) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, de, oe, M.width, M.height) : ze(M) ? l.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, de, oe, M.width, M.height) : s.renderbufferStorage(s.RENDERBUFFER, oe, M.width, M.height);
             }
         }
-        i.bindRenderbuffer(i.RENDERBUFFER, null);
+        s.bindRenderbuffer(s.RENDERBUFFER, null);
     }
 
-    function Ke(w, x) {
-        if (x && x.isWebGLCubeRenderTarget)
+    function Qe(w, M) {
+        if (M && M.isWebGLCubeRenderTarget)
             throw new Error("Depth Texture with cube render targets is not supported");
-        if (t.bindFramebuffer(i.FRAMEBUFFER, w), !(x.depthTexture && x.depthTexture.isDepthTexture))
+        if (t.bindFramebuffer(s.FRAMEBUFFER, w), !(M.depthTexture && M.depthTexture.isDepthTexture))
             throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
-        (!n.get(x.depthTexture).__webglTexture || x.depthTexture.image.width !== x.width || x.depthTexture.image.height !== x.height) && (x.depthTexture.image.width = x.width, x.depthTexture.image.height = x.height, x.depthTexture.needsUpdate = !0), B(x.depthTexture, 0);
-        const Q = n.get(x.depthTexture).__webglTexture,
-            te = ye(x);
-        if (x.depthTexture.format === Hn)
-            qe(x) ? l.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Q, 0, te) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.TEXTURE_2D, Q, 0);
-        else if (x.depthTexture.format === Hi)
-            qe(x) ? l.framebufferTexture2DMultisampleEXT(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Q, 0, te) : i.framebufferTexture2D(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.TEXTURE_2D, Q, 0);
+        (!n.get(M.depthTexture).__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = !0), K(M.depthTexture, 0);
+        const Z = n.get(M.depthTexture).__webglTexture,
+            re = Me(M);
+        if (M.depthTexture.format === ei)
+            ze(M) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Z, 0, re) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, Z, 0);
+        else if (M.depthTexture.format === cs)
+            ze(M) ? l.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Z, 0, re) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, Z, 0);
         else
             throw new Error("Unknown depthTexture format");
     }
 
-    function we(w) {
-        const x = n.get(w),
-            X = w.isWebGLCubeRenderTarget === !0;
-        if (w.depthTexture && !x.__autoAllocateDepthBuffer) {
-            if (X)
+    function Re(w) {
+        const M = n.get(w),
+            k = w.isWebGLCubeRenderTarget === !0;
+        if (w.depthTexture && !M.__autoAllocateDepthBuffer) {
+            if (k)
                 throw new Error("target.depthTexture not supported in Cube render targets");
-            Ke(x.__webglFramebuffer, w);
-        } else if (X) {
-            x.__webglDepthbuffer = [];
-            for (let Q = 0; Q < 6; Q++)
-                t.bindFramebuffer(i.FRAMEBUFFER, x.__webglFramebuffer[Q]), x.__webglDepthbuffer[Q] = i.createRenderbuffer(), ge(x.__webglDepthbuffer[Q], w, !1);
+            Qe(M.__webglFramebuffer, w);
+        } else if (k) {
+            M.__webglDepthbuffer = [];
+            for (let Z = 0; Z < 6; Z++)
+                t.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer[Z]), M.__webglDepthbuffer[Z] = s.createRenderbuffer(), ge(M.__webglDepthbuffer[Z], w, !1);
         } else
-            t.bindFramebuffer(i.FRAMEBUFFER, x.__webglFramebuffer), x.__webglDepthbuffer = i.createRenderbuffer(), ge(x.__webglDepthbuffer, w, !1);
-        t.bindFramebuffer(i.FRAMEBUFFER, null);
+            t.bindFramebuffer(s.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer = s.createRenderbuffer(), ge(M.__webglDepthbuffer, w, !1);
+        t.bindFramebuffer(s.FRAMEBUFFER, null);
     }
 
-    function F(w, x, X) {
-        const Q = n.get(w);
-        x !== void 0 && xe(Q.__webglFramebuffer, w, w.texture, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, 0), X !== void 0 && we(w);
-    }
-
-    function lt(w) {
-        const x = w.texture,
-            X = n.get(w),
-            Q = n.get(x);
-        w.addEventListener("dispose", W);
-        const te = w.textures,
-            $ = w.isWebGLCubeRenderTarget === !0,
-            Le = te.length > 1,
-            Ae = d(w) || o;
-        if (Le || (Q.__webglTexture === void 0 && (Q.__webglTexture = i.createTexture()), Q.__version = x.version, a.memory.textures++), $) {
-            X.__webglFramebuffer = [];
-            for (let se = 0; se < 6; se++)
-                if (o && x.mipmaps && x.mipmaps.length > 0) {
-                    X.__webglFramebuffer[se] = [];
-                    for (let ce = 0; ce < x.mipmaps.length; ce++)
-                        X.__webglFramebuffer[se][ce] = i.createFramebuffer();
+    function O(w, M, k) {
+        const Z = n.get(w);
+        M !== void 0 && xe(Z.__webglFramebuffer, w, w.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0), k !== void 0 && Re(w);
+    }
+
+    function Je(w) {
+        const M = w.texture,
+            k = n.get(w),
+            Z = n.get(M);
+        w.addEventListener("dispose", B);
+        const re = w.textures,
+            ie = w.isWebGLCubeRenderTarget === !0,
+            Be = re.length > 1,
+            Pe = p(w) || a;
+        if (Be || (Z.__webglTexture === void 0 && (Z.__webglTexture = s.createTexture()), Z.__version = M.version, o.memory.textures++), ie) {
+            k.__webglFramebuffer = [];
+            for (let oe = 0; oe < 6; oe++)
+                if (a && M.mipmaps && M.mipmaps.length > 0) {
+                    k.__webglFramebuffer[oe] = [];
+                    for (let de = 0; de < M.mipmaps.length; de++)
+                        k.__webglFramebuffer[oe][de] = s.createFramebuffer();
                 } else
-                    X.__webglFramebuffer[se] = i.createFramebuffer();
+                    k.__webglFramebuffer[oe] = s.createFramebuffer();
         } else {
-            if (o && x.mipmaps && x.mipmaps.length > 0) {
-                X.__webglFramebuffer = [];
-                for (let se = 0; se < x.mipmaps.length; se++)
-                    X.__webglFramebuffer[se] = i.createFramebuffer();
+            if (a && M.mipmaps && M.mipmaps.length > 0) {
+                k.__webglFramebuffer = [];
+                for (let oe = 0; oe < M.mipmaps.length; oe++)
+                    k.__webglFramebuffer[oe] = s.createFramebuffer();
             } else
-                X.__webglFramebuffer = i.createFramebuffer();
-            if (Le)
-                if (r.drawBuffers)
-                    for (let se = 0, ce = te.length; se < ce; se++) {
-                        const Re = n.get(te[se]);
-                        Re.__webglTexture === void 0 && (Re.__webglTexture = i.createTexture(), a.memory.textures++);
+                k.__webglFramebuffer = s.createFramebuffer();
+            if (Be)
+                if (i.drawBuffers)
+                    for (let oe = 0, de = re.length; oe < de; oe++) {
+                        const De = n.get(re[oe]);
+                        De.__webglTexture === void 0 && (De.__webglTexture = s.createTexture(), o.memory.textures++);
                     }
             else
                 console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
-            if (o && w.samples > 0 && qe(w) === !1) {
-                X.__webglMultisampledFramebuffer = i.createFramebuffer(), X.__webglColorRenderbuffer = [], t.bindFramebuffer(i.FRAMEBUFFER, X.__webglMultisampledFramebuffer);
-                for (let se = 0; se < te.length; se++) {
-                    const ce = te[se];
-                    X.__webglColorRenderbuffer[se] = i.createRenderbuffer(), i.bindRenderbuffer(i.RENDERBUFFER, X.__webglColorRenderbuffer[se]);
-                    const Re = s.convert(ce.format, ce.colorSpace),
-                        C = s.convert(ce.type),
-                        le = R(ce.internalFormat, Re, C, ce.colorSpace, w.isXRRenderTarget === !0),
-                        ve = ye(w);
-                    i.renderbufferStorageMultisample(i.RENDERBUFFER, ve, le, w.width, w.height), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + se, i.RENDERBUFFER, X.__webglColorRenderbuffer[se]);
-                }
-                i.bindRenderbuffer(i.RENDERBUFFER, null), w.depthBuffer && (X.__webglDepthRenderbuffer = i.createRenderbuffer(), ge(X.__webglDepthRenderbuffer, w, !0)), t.bindFramebuffer(i.FRAMEBUFFER, null);
-            }
-        }
-        if ($) {
-            t.bindTexture(i.TEXTURE_CUBE_MAP, Q.__webglTexture), H(i.TEXTURE_CUBE_MAP, x, Ae);
-            for (let se = 0; se < 6; se++)
-                if (o && x.mipmaps && x.mipmaps.length > 0)
-                    for (let ce = 0; ce < x.mipmaps.length; ce++)
-                        xe(X.__webglFramebuffer[se][ce], w, x, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + se, ce);
+            if (a && w.samples > 0 && ze(w) === !1) {
+                k.__webglMultisampledFramebuffer = s.createFramebuffer(), k.__webglColorRenderbuffer = [], t.bindFramebuffer(s.FRAMEBUFFER, k.__webglMultisampledFramebuffer);
+                for (let oe = 0; oe < re.length; oe++) {
+                    const de = re[oe];
+                    k.__webglColorRenderbuffer[oe] = s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, k.__webglColorRenderbuffer[oe]);
+                    const De = r.convert(de.format, de.colorSpace),
+                        R = r.convert(de.type),
+                        ue = b(de.internalFormat, De, R, de.colorSpace, w.isXRRenderTarget === !0),
+                        Se = Me(w);
+                    s.renderbufferStorageMultisample(s.RENDERBUFFER, Se, ue, w.width, w.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + oe, s.RENDERBUFFER, k.__webglColorRenderbuffer[oe]);
+                }
+                s.bindRenderbuffer(s.RENDERBUFFER, null), w.depthBuffer && (k.__webglDepthRenderbuffer = s.createRenderbuffer(), ge(k.__webglDepthRenderbuffer, w, !0)), t.bindFramebuffer(s.FRAMEBUFFER, null);
+            }
+        }
+        if (ie) {
+            t.bindTexture(s.TEXTURE_CUBE_MAP, Z.__webglTexture), V(s.TEXTURE_CUBE_MAP, M, Pe);
+            for (let oe = 0; oe < 6; oe++)
+                if (a && M.mipmaps && M.mipmaps.length > 0)
+                    for (let de = 0; de < M.mipmaps.length; de++)
+                        xe(k.__webglFramebuffer[oe][de], w, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + oe, de);
                 else
-                    xe(X.__webglFramebuffer[se], w, x, i.COLOR_ATTACHMENT0, i.TEXTURE_CUBE_MAP_POSITIVE_X + se, 0);
-            _(x, Ae) && A(i.TEXTURE_CUBE_MAP), t.unbindTexture();
-        } else if (Le) {
-            for (let se = 0, ce = te.length; se < ce; se++) {
-                const Re = te[se],
-                    C = n.get(Re);
-                t.bindTexture(i.TEXTURE_2D, C.__webglTexture), H(i.TEXTURE_2D, Re, Ae), xe(X.__webglFramebuffer, w, Re, i.COLOR_ATTACHMENT0 + se, i.TEXTURE_2D, 0), _(Re, Ae) && A(i.TEXTURE_2D);
+                    xe(k.__webglFramebuffer[oe], w, M, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + oe, 0);
+            S(M, Pe) && y(s.TEXTURE_CUBE_MAP), t.unbindTexture();
+        } else if (Be) {
+            for (let oe = 0, de = re.length; oe < de; oe++) {
+                const De = re[oe],
+                    R = n.get(De);
+                t.bindTexture(s.TEXTURE_2D, R.__webglTexture), V(s.TEXTURE_2D, De, Pe), xe(k.__webglFramebuffer, w, De, s.COLOR_ATTACHMENT0 + oe, s.TEXTURE_2D, 0), S(De, Pe) && y(s.TEXTURE_2D);
             }
             t.unbindTexture();
         } else {
-            let se = i.TEXTURE_2D;
-            if ((w.isWebGL3DRenderTarget || w.isWebGLArrayRenderTarget) && (o ? se = w.isWebGL3DRenderTarget ? i.TEXTURE_3D : i.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(se, Q.__webglTexture), H(se, x, Ae), o && x.mipmaps && x.mipmaps.length > 0)
-                for (let ce = 0; ce < x.mipmaps.length; ce++)
-                    xe(X.__webglFramebuffer[ce], w, x, i.COLOR_ATTACHMENT0, se, ce);
+            let oe = s.TEXTURE_2D;
+            if ((w.isWebGL3DRenderTarget || w.isWebGLArrayRenderTarget) && (a ? oe = w.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(oe, Z.__webglTexture), V(oe, M, Pe), a && M.mipmaps && M.mipmaps.length > 0)
+                for (let de = 0; de < M.mipmaps.length; de++)
+                    xe(k.__webglFramebuffer[de], w, M, s.COLOR_ATTACHMENT0, oe, de);
             else
-                xe(X.__webglFramebuffer, w, x, i.COLOR_ATTACHMENT0, se, 0);
-            _(x, Ae) && A(se), t.unbindTexture();
+                xe(k.__webglFramebuffer, w, M, s.COLOR_ATTACHMENT0, oe, 0);
+            S(M, Pe) && y(oe), t.unbindTexture();
         }
-        w.depthBuffer && we(w);
+        w.depthBuffer && Re(w);
     }
 
-    function Me(w) {
-        const x = d(w) || o,
-            X = w.textures;
-        for (let Q = 0, te = X.length; Q < te; Q++) {
-            const $ = X[Q];
-            if (_($, x)) {
-                const Le = w.isWebGLCubeRenderTarget ? i.TEXTURE_CUBE_MAP : i.TEXTURE_2D,
-                    Ae = n.get($).__webglTexture;
-                t.bindTexture(Le, Ae), A(Le), t.unbindTexture();
+    function Te(w) {
+        const M = p(w) || a,
+            k = w.textures;
+        for (let Z = 0, re = k.length; Z < re; Z++) {
+            const ie = k[Z];
+            if (S(ie, M)) {
+                const Be = w.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D,
+                    Pe = n.get(ie).__webglTexture;
+                t.bindTexture(Be, Pe), y(Be), t.unbindTexture();
             }
         }
     }
 
-    function Ne(w) {
-        if (o && w.samples > 0 && qe(w) === !1) {
-            const x = w.textures,
-                X = w.width,
-                Q = w.height;
-            let te = i.COLOR_BUFFER_BIT;
-            const $ = [],
-                Le = w.stencilBuffer ? i.DEPTH_STENCIL_ATTACHMENT : i.DEPTH_ATTACHMENT,
-                Ae = n.get(w),
-                se = x.length > 1;
-            if (se)
-                for (let ce = 0; ce < x.length; ce++)
-                    t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ce, i.RENDERBUFFER, null), t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ce, i.TEXTURE_2D, null, 0);
-            t.bindFramebuffer(i.READ_FRAMEBUFFER, Ae.__webglMultisampledFramebuffer), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Ae.__webglFramebuffer);
-            for (let ce = 0; ce < x.length; ce++) {
-                $.push(i.COLOR_ATTACHMENT0 + ce), w.depthBuffer && $.push(Le);
-                const Re = Ae.__ignoreDepthValues !== void 0 ? Ae.__ignoreDepthValues : !1;
-                if (Re === !1 && (w.depthBuffer && (te |= i.DEPTH_BUFFER_BIT), w.stencilBuffer && (te |= i.STENCIL_BUFFER_BIT)), se && i.framebufferRenderbuffer(i.READ_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.RENDERBUFFER, Ae.__webglColorRenderbuffer[ce]), Re === !0 && (i.invalidateFramebuffer(i.READ_FRAMEBUFFER, [Le]), i.invalidateFramebuffer(i.DRAW_FRAMEBUFFER, [Le])), se) {
-                    const C = n.get(x[ce]).__webglTexture;
-                    i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, C, 0);
-                }
-                i.blitFramebuffer(0, 0, X, Q, 0, 0, X, Q, te, i.NEAREST), c && i.invalidateFramebuffer(i.READ_FRAMEBUFFER, $);
-            }
-            if (t.bindFramebuffer(i.READ_FRAMEBUFFER, null), t.bindFramebuffer(i.DRAW_FRAMEBUFFER, null), se)
-                for (let ce = 0; ce < x.length; ce++) {
-                    t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ce, i.RENDERBUFFER, Ae.__webglColorRenderbuffer[ce]);
-                    const Re = n.get(x[ce]).__webglTexture;
-                    t.bindFramebuffer(i.FRAMEBUFFER, Ae.__webglFramebuffer), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, i.COLOR_ATTACHMENT0 + ce, i.TEXTURE_2D, Re, 0);
-                }
-            t.bindFramebuffer(i.DRAW_FRAMEBUFFER, Ae.__webglMultisampledFramebuffer);
+    function Ie(w) {
+        if (a && w.samples > 0 && ze(w) === !1) {
+            const M = w.textures,
+                k = w.width,
+                Z = w.height;
+            let re = s.COLOR_BUFFER_BIT;
+            const ie = [],
+                Be = w.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT,
+                Pe = n.get(w),
+                oe = M.length > 1;
+            if (oe)
+                for (let de = 0; de < M.length; de++)
+                    t.bindFramebuffer(s.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + de, s.RENDERBUFFER, null), t.bindFramebuffer(s.FRAMEBUFFER, Pe.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + de, s.TEXTURE_2D, null, 0);
+            t.bindFramebuffer(s.READ_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Pe.__webglFramebuffer);
+            for (let de = 0; de < M.length; de++) {
+                ie.push(s.COLOR_ATTACHMENT0 + de), w.depthBuffer && ie.push(Be);
+                const De = Pe.__ignoreDepthValues !== void 0 ? Pe.__ignoreDepthValues : !1;
+                if (De === !1 && (w.depthBuffer && (re |= s.DEPTH_BUFFER_BIT), w.stencilBuffer && (re |= s.STENCIL_BUFFER_BIT)), oe && s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, Pe.__webglColorRenderbuffer[de]), De === !0 && (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [Be]), s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [Be])), oe) {
+                    const R = n.get(M[de]).__webglTexture;
+                    s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, R, 0);
+                }
+                s.blitFramebuffer(0, 0, k, Z, 0, 0, k, Z, re, s.NEAREST), c && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, ie);
+            }
+            if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null), t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null), oe)
+                for (let de = 0; de < M.length; de++) {
+                    t.bindFramebuffer(s.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + de, s.RENDERBUFFER, Pe.__webglColorRenderbuffer[de]);
+                    const De = n.get(M[de]).__webglTexture;
+                    t.bindFramebuffer(s.FRAMEBUFFER, Pe.__webglFramebuffer), s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + de, s.TEXTURE_2D, De, 0);
+                }
+            t.bindFramebuffer(s.DRAW_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer);
         }
     }
 
-    function ye(w) {
-        return Math.min(r.maxSamples, w.samples);
-    }
-
-    function qe(w) {
-        const x = n.get(w);
-        return o && w.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && x.__useRenderToTexture !== !1;
+    function Me(w) {
+        return Math.min(i.maxSamples, w.samples);
+    }
+
+    function ze(w) {
+        const M = n.get(w);
+        return a && w.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && M.__useRenderToTexture !== !1;
     }
 
-    function Ie(w) {
-        const x = a.render.frame;
-        f.get(w) !== x && (f.set(w, x), w.update());
+    function Oe(w) {
+        const M = o.render.frame;
+        d.get(w) !== M && (d.set(w, M), w.update());
     }
 
-    function Be(w, x) {
-        const X = w.colorSpace,
-            Q = w.format,
-            te = w.type;
-        return w.isCompressedTexture === !0 || w.isVideoTexture === !0 || w.format === ro || X !== Wn && X !== Nn && (Ze.getTransfer(X) === nt ? o === !1 ? e.has("EXT_sRGB") === !0 && Q === Vt ? (w.format = ro, w.minFilter = Ct, w.generateMipmaps = !1) : x = Yl.sRGBToLinear(x) : (Q !== Vt || te !== Gn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", X)), x;
+    function we(w, M) {
+        const k = w.colorSpace,
+            Z = w.format,
+            re = w.type;
+        return w.isCompressedTexture === !0 || w.isVideoTexture === !0 || w.format === Oa || k !== ni && k !== Zn && (tt.getTransfer(k) === at ? a === !1 ? e.has("EXT_sRGB") === !0 && Z === kt ? (w.format = Oa, w.minFilter = Nt, w.generateMipmaps = !1) : M = Hc.sRGBToLinear(M) : (Z !== kt || re !== In) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", k)), M;
     }
 
-    function Je(w) {
+    function Ke(w) {
         return typeof HTMLImageElement < "u" && w instanceof HTMLImageElement ? (u.width = w.naturalWidth || w.width, u.height = w.naturalHeight || w.height) : typeof VideoFrame < "u" && w instanceof VideoFrame ? (u.width = w.displayWidth, u.height = w.displayHeight) : (u.width = w.width, u.height = w.height), u;
     }
-    this.allocateTextureUnit = N, this.resetTextureUnits = L, this.setTexture2D = B, this.setTexture2DArray = j, this.setTexture3D = q, this.setTextureCube = J, this.rebindTextures = F, this.setupRenderTarget = lt, this.updateRenderTargetMipmap = Me, this.updateMultisampleRenderTarget = Ne, this.setupDepthRenderbuffer = we, this.setupFrameBufferTexture = xe, this.useMultisampledRTT = qe;
+    this.allocateTextureUnit = I, this.resetTextureUnits = P, this.setTexture2D = K, this.setTexture2DArray = G, this.setTexture3D = q, this.setTextureCube = Q, this.rebindTextures = O, this.setupRenderTarget = Je, this.updateRenderTargetMipmap = Te, this.updateMultisampleRenderTarget = Ie, this.setupDepthRenderbuffer = Re, this.setupFrameBufferTexture = xe, this.useMultisampledRTT = ze;
 }
 
-function Yg(i, e, t) {
+function ru(s, e, t) {
     const n = t.isWebGL2;
 
-    function r(s, a = Nn) {
-        let o;
-        const l = Ze.getTransfer(a);
-        if (s === Gn)
-            return i.UNSIGNED_BYTE;
-        if (s === kl)
-            return i.UNSIGNED_SHORT_4_4_4_4;
-        if (s === Gl)
-            return i.UNSIGNED_SHORT_5_5_5_1;
-        if (s === cf)
-            return i.BYTE;
-        if (s === uf)
-            return i.SHORT;
-        if (s === fo)
-            return i.UNSIGNED_SHORT;
-        if (s === zl)
-            return i.INT;
-        if (s === nn)
-            return i.UNSIGNED_INT;
-        if (s === an)
-            return i.FLOAT;
-        if (s === Gi)
-            return n ? i.HALF_FLOAT : (o = e.get("OES_texture_half_float"), o !== null ? o.HALF_FLOAT_OES : null);
-        if (s === ff)
-            return i.ALPHA;
-        if (s === Vt)
-            return i.RGBA;
-        if (s === hf)
-            return i.LUMINANCE;
-        if (s === df)
-            return i.LUMINANCE_ALPHA;
-        if (s === Hn)
-            return i.DEPTH_COMPONENT;
-        if (s === Hi)
-            return i.DEPTH_STENCIL;
-        if (s === ro)
-            return o = e.get("EXT_sRGB"), o !== null ? o.SRGB_ALPHA_EXT : null;
-        if (s === pf)
-            return i.RED;
-        if (s === ho)
-            return i.RED_INTEGER;
-        if (s === io)
-            return i.RG;
-        if (s === Hl)
-            return i.RG_INTEGER;
-        if (s === po)
-            return i.RGBA_INTEGER;
-        if (s === vs || s === xs || s === Ss || s === Ms)
-            if (l === nt)
-                if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
-                    if (s === vs)
-                        return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
-                    if (s === xs)
-                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
-                    if (s === Ss)
-                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
-                    if (s === Ms)
-                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
+    function i(r, o = Zn) {
+        let a;
+        const l = tt.getTransfer(o);
+        if (r === In)
+            return s.UNSIGNED_BYTE;
+        if (r === Ic)
+            return s.UNSIGNED_SHORT_4_4_4_4;
+        if (r === Uc)
+            return s.UNSIGNED_SHORT_5_5_5_1;
+        if (r === sf)
+            return s.BYTE;
+        if (r === rf)
+            return s.SHORT;
+        if (r === ja)
+            return s.UNSIGNED_SHORT;
+        if (r === Fc)
+            return s.INT;
+        if (r === fn)
+            return s.UNSIGNED_INT;
+        if (r === gn)
+            return s.FLOAT;
+        if (r === xi)
+            return n ? s.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
+        if (r === af)
+            return s.ALPHA;
+        if (r === kt)
+            return s.RGBA;
+        if (r === of)
+            return s.LUMINANCE;
+        if (r === lf)
+            return s.LUMINANCE_ALPHA;
+        if (r === ei)
+            return s.DEPTH_COMPONENT;
+        if (r === cs)
+            return s.DEPTH_STENCIL;
+        if (r === Oa)
+            return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
+        if (r === cf)
+            return s.RED;
+        if (r === Ka)
+            return s.RED_INTEGER;
+        if (r === uf)
+            return s.RG;
+        if (r === Bc)
+            return s.RG_INTEGER;
+        if (r === Za)
+            return s.RGBA_INTEGER;
+        if (r === jr || r === Kr || r === Zr || r === Qr)
+            if (l === at)
+                if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
+                    if (r === jr)
+                        return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
+                    if (r === Kr)
+                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
+                    if (r === Zr)
+                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
+                    if (r === Qr)
+                        return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
                 } else
                     return null;
-        else if (o = e.get("WEBGL_compressed_texture_s3tc"), o !== null) {
-            if (s === vs)
-                return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
-            if (s === xs)
-                return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
-            if (s === Ss)
-                return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
-            if (s === Ms)
-                return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
+        else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
+            if (r === jr)
+                return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
+            if (r === Kr)
+                return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
+            if (r === Zr)
+                return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
+            if (r === Qr)
+                return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
         } else
             return null;
-        if (s === Go || s === Ho || s === Vo || s === Wo)
-            if (o = e.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
-                if (s === Go)
-                    return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
-                if (s === Ho)
-                    return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
-                if (s === Vo)
-                    return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
-                if (s === Wo)
-                    return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
+        if (r === Ro || r === Po || r === Do || r === Lo)
+            if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
+                if (r === Ro)
+                    return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
+                if (r === Po)
+                    return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
+                if (r === Do)
+                    return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
+                if (r === Lo)
+                    return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
             } else
                 return null;
-        if (s === Vl)
-            return o = e.get("WEBGL_compressed_texture_etc1"), o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null;
-        if (s === Xo || s === qo)
-            if (o = e.get("WEBGL_compressed_texture_etc"), o !== null) {
-                if (s === Xo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
-                if (s === qo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
+        if (r === Oc)
+            return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
+        if (r === Fo || r === Io)
+            if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
+                if (r === Fo)
+                    return l === at ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
+                if (r === Io)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
             } else
                 return null;
-        if (s === Yo || s === jo || s === Ko || s === Qo || s === Zo || s === Jo || s === $o || s === ea || s === ta || s === na || s === ia || s === ra || s === sa || s === oa)
-            if (o = e.get("WEBGL_compressed_texture_astc"), o !== null) {
-                if (s === Yo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
-                if (s === jo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
-                if (s === Ko)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
-                if (s === Qo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
-                if (s === Zo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
-                if (s === Jo)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
-                if (s === $o)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
-                if (s === ea)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
-                if (s === ta)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
-                if (s === na)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
-                if (s === ia)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
-                if (s === ra)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
-                if (s === sa)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
-                if (s === oa)
-                    return l === nt ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
+        if (r === Uo || r === Bo || r === Oo || r === No || r === ko || r === zo || r === Ho || r === Go || r === Vo || r === Wo || r === Xo || r === qo || r === Yo || r === jo)
+            if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
+                if (r === Uo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
+                if (r === Bo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
+                if (r === Oo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
+                if (r === No)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
+                if (r === ko)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
+                if (r === zo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
+                if (r === Ho)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
+                if (r === Go)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
+                if (r === Vo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
+                if (r === Wo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
+                if (r === Xo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
+                if (r === qo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
+                if (r === Yo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
+                if (r === jo)
+                    return l === at ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
             } else
                 return null;
-        if (s === ys || s === aa || s === la)
-            if (o = e.get("EXT_texture_compression_bptc"), o !== null) {
-                if (s === ys)
-                    return l === nt ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
-                if (s === aa)
-                    return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
-                if (s === la)
-                    return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
+        if (r === Jr || r === Ko || r === Zo)
+            if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
+                if (r === Jr)
+                    return l === at ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
+                if (r === Ko)
+                    return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
+                if (r === Zo)
+                    return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
             } else
                 return null;
-        if (s === mf || s === ca || s === ua || s === fa)
-            if (o = e.get("EXT_texture_compression_rgtc"), o !== null) {
-                if (s === ys)
-                    return o.COMPRESSED_RED_RGTC1_EXT;
-                if (s === ca)
-                    return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
-                if (s === ua)
-                    return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
-                if (s === fa)
-                    return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
+        if (r === df || r === Qo || r === Jo || r === $o)
+            if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
+                if (r === Jr)
+                    return a.COMPRESSED_RED_RGTC1_EXT;
+                if (r === Qo)
+                    return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
+                if (r === Jo)
+                    return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
+                if (r === $o)
+                    return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
             } else
                 return null;
-        return s === si ? n ? i.UNSIGNED_INT_24_8 : (o = e.get("WEBGL_depth_texture"), o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null) : i[s] !== void 0 ? i[s] : null;
+        return r === vi ? n ? s.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : s[r] !== void 0 ? s[r] : null;
     }
     return {
-        convert: r
+        convert: i
     };
 }
-class jg extends Ht {
+class V0 extends $t {
     constructor(e = []) {
         super(), this.isArrayCamera = !0, this.cameras = e;
     }
 }
-class Br extends gt {
+class ar extends Et {
     constructor() {
         super(), this.isGroup = !0, this.type = "Group";
     }
 }
-const Kg = {
+const W0 = {
     type: "move"
 };
-class Ys {
+class Ea {
     constructor() {
         this._targetRay = null, this._grip = null, this._hand = null;
     }
     getHandSpace() {
-        return this._hand === null && (this._hand = new Br(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
+        return this._hand === null && (this._hand = new ar(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
             pinching: !1
         }), this._hand;
     }
     getTargetRaySpace() {
-        return this._targetRay === null && (this._targetRay = new Br(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new P(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new P()), this._targetRay;
+        return this._targetRay === null && (this._targetRay = new ar(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new D(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new D()), this._targetRay;
     }
     getGripSpace() {
-        return this._grip === null && (this._grip = new Br(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new P(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new P()), this._grip;
+        return this._grip === null && (this._grip = new ar(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new D(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new D()), this._grip;
     }
     dispatchEvent(e) {
         return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
     }
     connect(e) {
         if (e && e.hand) {
             const t = this._hand;
@@ -16052,64 +16080,64 @@
     disconnect(e) {
         return this.dispatchEvent({
             type: "disconnected",
             data: e
         }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
     }
     update(e, t, n) {
-        let r = null,
-            s = null,
-            a = null;
-        const o = this._targetRay,
+        let i = null,
+            r = null,
+            o = null;
+        const a = this._targetRay,
             l = this._grip,
             c = this._hand;
         if (e && t.session.visibilityState !== "visible-blurred") {
             if (c && e.hand) {
-                a = !0;
-                for (const v of e.hand.values()) {
-                    const m = t.getJointPose(v, n),
-                        d = this._getHandJoint(c, v);
-                    m !== null && (d.matrix.fromArray(m.transform.matrix), d.matrix.decompose(d.position, d.rotation, d.scale), d.matrixWorldNeedsUpdate = !0, d.jointRadius = m.radius), d.visible = m !== null;
+                o = !0;
+                for (const _ of e.hand.values()) {
+                    const m = t.getJointPose(_, n),
+                        p = this._getHandJoint(c, _);
+                    m !== null && (p.matrix.fromArray(m.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, p.jointRadius = m.radius), p.visible = m !== null;
                 }
                 const u = c.joints["index-finger-tip"],
-                    f = c.joints["thumb-tip"],
-                    h = u.position.distanceTo(f.position),
-                    p = 0.02,
+                    d = c.joints["thumb-tip"],
+                    f = u.position.distanceTo(d.position),
+                    h = 0.02,
                     g = 5e-3;
-                c.inputState.pinching && h > p + g ? (c.inputState.pinching = !1, this.dispatchEvent({
+                c.inputState.pinching && f > h + g ? (c.inputState.pinching = !1, this.dispatchEvent({
                     type: "pinchend",
                     handedness: e.handedness,
                     target: this
-                })) : !c.inputState.pinching && h <= p - g && (c.inputState.pinching = !0, this.dispatchEvent({
+                })) : !c.inputState.pinching && f <= h - g && (c.inputState.pinching = !0, this.dispatchEvent({
                     type: "pinchstart",
                     handedness: e.handedness,
                     target: this
                 }));
             } else
-                l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
-            o !== null && (r = t.getPose(e.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Kg)));
+                l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n), r !== null && (l.matrix.fromArray(r.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1, r.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
+            a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && r !== null && (i = r), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(W0)));
         }
-        return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
+        return a !== null && (a.visible = i !== null), l !== null && (l.visible = r !== null), c !== null && (c.visible = o !== null), this;
     }
     // private method
     _getHandJoint(e, t) {
         if (e.joints[t.jointName] === void 0) {
-            const n = new Br();
+            const n = new ar();
             n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
         }
         return e.joints[t.jointName];
     }
 }
-const Qg = `
+const X0 = `
 void main() {
 
 	gl_Position = vec4( position, 1.0 );
 
 }`,
-    Zg = `
+    q0 = `
 uniform sampler2DArray depthColor;
 uniform float depthWidth;
 uniform float depthHeight;
 
 void main() {
 
 	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );
@@ -16121,1383 +16149,1383 @@
 	} else {
 
 		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;
 
 	}
 
 }`;
-class Jg {
+class Y0 {
     constructor() {
         this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
     }
     init(e, t, n) {
         if (this.texture === null) {
-            const r = new Tt(),
-                s = e.properties.get(r);
-            s.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
+            const i = new Ot(),
+                r = e.properties.get(i);
+            r.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i;
         }
     }
     render(e, t) {
         if (this.texture !== null) {
             if (this.mesh === null) {
                 const n = t.cameras[0].viewport,
-                    r = new Xt({
+                    i = new tn({
                         extensions: {
                             fragDepth: !0
                         },
-                        vertexShader: Qg,
-                        fragmentShader: Zg,
+                        vertexShader: X0,
+                        fragmentShader: q0,
                         uniforms: {
                             depthColor: {
                                 value: this.texture
                             },
                             depthWidth: {
                                 value: n.z
                             },
                             depthHeight: {
                                 value: n.w
                             }
                         }
                     });
-                this.mesh = new at(new Wi(20, 20), r);
+                this.mesh = new pt(new ds(20, 20), i);
             }
             e.render(this.mesh, t);
         }
     }
     reset() {
         this.texture = null, this.mesh = null;
     }
 }
-class $g extends ui {
+class j0 extends Ti {
     constructor(e, t) {
         super();
         const n = this;
-        let r = null,
-            s = 1,
-            a = null,
-            o = "local-floor",
+        let i = null,
+            r = 1,
+            o = null,
+            a = "local-floor",
             l = 1,
             c = null,
             u = null,
+            d = null,
             f = null,
             h = null,
-            p = null,
             g = null;
-        const v = new Jg(),
+        const _ = new Y0(),
             m = t.getContextAttributes();
-        let d = null,
-            M = null;
-        const _ = [],
-            A = [],
-            R = new me();
+        let p = null,
+            v = null;
+        const S = [],
+            y = [],
+            b = new Ee();
         let E = null;
-        const b = new Ht();
-        b.layers.enable(1), b.viewport = new ut();
-        const I = new Ht();
-        I.layers.enable(2), I.viewport = new ut();
-        const W = [b, I],
-            S = new jg();
-        S.layers.enable(1), S.layers.enable(2);
-        let T = null,
-            Y = null;
-        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(H) {
-            let ee = _[H];
-            return ee === void 0 && (ee = new Ys(), _[H] = ee), ee.getTargetRaySpace();
-        }, this.getControllerGrip = function(H) {
-            let ee = _[H];
-            return ee === void 0 && (ee = new Ys(), _[H] = ee), ee.getGripSpace();
-        }, this.getHand = function(H) {
-            let ee = _[H];
-            return ee === void 0 && (ee = new Ys(), _[H] = ee), ee.getHandSpace();
+        const T = new $t();
+        T.layers.enable(1), T.viewport = new _t();
+        const L = new $t();
+        L.layers.enable(2), L.viewport = new _t();
+        const B = [T, L],
+            x = new V0();
+        x.layers.enable(1), x.layers.enable(2);
+        let A = null,
+            U = null;
+        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(V) {
+            let J = S[V];
+            return J === void 0 && (J = new Ea(), S[V] = J), J.getTargetRaySpace();
+        }, this.getControllerGrip = function(V) {
+            let J = S[V];
+            return J === void 0 && (J = new Ea(), S[V] = J), J.getGripSpace();
+        }, this.getHand = function(V) {
+            let J = S[V];
+            return J === void 0 && (J = new Ea(), S[V] = J), J.getHandSpace();
         };
 
-        function K(H) {
-            const ee = A.indexOf(H.inputSource);
-            if (ee === -1)
+        function N(V) {
+            const J = y.indexOf(V.inputSource);
+            if (J === -1)
                 return;
-            const pe = _[ee];
-            pe !== void 0 && (pe.update(H.inputSource, H.frame, c || a), pe.dispatchEvent({
-                type: H.type,
-                data: H.inputSource
+            const se = S[J];
+            se !== void 0 && (se.update(V.inputSource, V.frame, c || o), se.dispatchEvent({
+                type: V.type,
+                data: V.inputSource
             }));
         }
 
-        function L() {
-            r.removeEventListener("select", K), r.removeEventListener("selectstart", K), r.removeEventListener("selectend", K), r.removeEventListener("squeeze", K), r.removeEventListener("squeezestart", K), r.removeEventListener("squeezeend", K), r.removeEventListener("end", L), r.removeEventListener("inputsourceschange", N);
-            for (let H = 0; H < _.length; H++) {
-                const ee = A[H];
-                ee !== null && (A[H] = null, _[H].disconnect(ee));
+        function P() {
+            i.removeEventListener("select", N), i.removeEventListener("selectstart", N), i.removeEventListener("selectend", N), i.removeEventListener("squeeze", N), i.removeEventListener("squeezestart", N), i.removeEventListener("squeezeend", N), i.removeEventListener("end", P), i.removeEventListener("inputsourceschange", I);
+            for (let V = 0; V < S.length; V++) {
+                const J = y[V];
+                J !== null && (y[V] = null, S[V].disconnect(J));
             }
-            T = null, Y = null, v.reset(), e.setRenderTarget(d), p = null, h = null, f = null, r = null, M = null, Z.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(R.width, R.height, !1), n.dispatchEvent({
+            A = null, U = null, _.reset(), e.setRenderTarget(p), h = null, f = null, d = null, i = null, v = null, ne.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(b.width, b.height, !1), n.dispatchEvent({
                 type: "sessionend"
             });
         }
-        this.setFramebufferScaleFactor = function(H) {
-            s = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
-        }, this.setReferenceSpaceType = function(H) {
-            o = H, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
+        this.setFramebufferScaleFactor = function(V) {
+            r = V, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
+        }, this.setReferenceSpaceType = function(V) {
+            a = V, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
         }, this.getReferenceSpace = function() {
-            return c || a;
-        }, this.setReferenceSpace = function(H) {
-            c = H;
+            return c || o;
+        }, this.setReferenceSpace = function(V) {
+            c = V;
         }, this.getBaseLayer = function() {
-            return h !== null ? h : p;
+            return f !== null ? f : h;
         }, this.getBinding = function() {
-            return f;
+            return d;
         }, this.getFrame = function() {
             return g;
         }, this.getSession = function() {
-            return r;
-        }, this.setSession = async function(H) {
-            if (r = H, r !== null) {
-                if (d = e.getRenderTarget(), r.addEventListener("select", K), r.addEventListener("selectstart", K), r.addEventListener("selectend", K), r.addEventListener("squeeze", K), r.addEventListener("squeezestart", K), r.addEventListener("squeezeend", K), r.addEventListener("end", L), r.addEventListener("inputsourceschange", N), m.xrCompatible !== !0 && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(R), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
-                    const ee = {
-                        antialias: r.renderState.layers === void 0 ? m.antialias : !0,
+            return i;
+        }, this.setSession = async function(V) {
+            if (i = V, i !== null) {
+                if (p = e.getRenderTarget(), i.addEventListener("select", N), i.addEventListener("selectstart", N), i.addEventListener("selectend", N), i.addEventListener("squeeze", N), i.addEventListener("squeezestart", N), i.addEventListener("squeezeend", N), i.addEventListener("end", P), i.addEventListener("inputsourceschange", I), m.xrCompatible !== !0 && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(b), i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1) {
+                    const J = {
+                        antialias: i.renderState.layers === void 0 ? m.antialias : !0,
                         alpha: !0,
                         depth: m.depth,
                         stencil: m.stencil,
-                        framebufferScaleFactor: s
+                        framebufferScaleFactor: r
                     };
-                    p = new XRWebGLLayer(r, t, ee), r.updateRenderState({
-                        baseLayer: p
-                    }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, !1), M = new Vn(
-                        p.framebufferWidth,
-                        p.framebufferHeight, {
-                            format: Vt,
-                            type: Gn,
+                    h = new XRWebGLLayer(i, t, J), i.updateRenderState({
+                        baseLayer: h
+                    }), e.setPixelRatio(1), e.setSize(h.framebufferWidth, h.framebufferHeight, !1), v = new ti(
+                        h.framebufferWidth,
+                        h.framebufferHeight, {
+                            format: kt,
+                            type: In,
                             colorSpace: e.outputColorSpace,
                             stencilBuffer: m.stencil
                         }
                     );
                 } else {
-                    let ee = null,
-                        pe = null,
-                        Te = null;
-                    m.depth && (Te = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ee = m.stencil ? Hi : Hn, pe = m.stencil ? si : nn);
+                    let J = null,
+                        se = null,
+                        Ae = null;
+                    m.depth && (Ae = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, J = m.stencil ? cs : ei, se = m.stencil ? vi : fn);
                     const xe = {
                         colorFormat: t.RGBA8,
-                        depthFormat: Te,
-                        scaleFactor: s
+                        depthFormat: Ae,
+                        scaleFactor: r
                     };
-                    f = new XRWebGLBinding(r, t), h = f.createProjectionLayer(xe), r.updateRenderState({
-                        layers: [h]
-                    }), e.setPixelRatio(1), e.setSize(h.textureWidth, h.textureHeight, !1), M = new Vn(
-                        h.textureWidth,
-                        h.textureHeight, {
-                            format: Vt,
-                            type: Gn,
-                            depthTexture: new xo(h.textureWidth, h.textureHeight, pe, void 0, void 0, void 0, void 0, void 0, void 0, ee),
+                    d = new XRWebGLBinding(i, t), f = d.createProjectionLayer(xe), i.updateRenderState({
+                        layers: [f]
+                    }), e.setPixelRatio(1), e.setSize(f.textureWidth, f.textureHeight, !1), v = new ti(
+                        f.textureWidth,
+                        f.textureHeight, {
+                            format: kt,
+                            type: In,
+                            depthTexture: new no(f.textureWidth, f.textureHeight, se, void 0, void 0, void 0, void 0, void 0, void 0, J),
                             stencilBuffer: m.stencil,
                             colorSpace: e.outputColorSpace,
                             samples: m.antialias ? 4 : 0
                         }
                     );
-                    const ge = e.properties.get(M);
-                    ge.__ignoreDepthValues = h.ignoreDepthValues;
+                    const ge = e.properties.get(v);
+                    ge.__ignoreDepthValues = f.ignoreDepthValues;
                 }
-                M.isXRRenderTarget = !0, this.setFoveation(l), c = null, a = await r.requestReferenceSpace(o), Z.setContext(r), Z.start(), n.isPresenting = !0, n.dispatchEvent({
+                v.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await i.requestReferenceSpace(a), ne.setContext(i), ne.start(), n.isPresenting = !0, n.dispatchEvent({
                     type: "sessionstart"
                 });
             }
         }, this.getEnvironmentBlendMode = function() {
-            if (r !== null)
-                return r.environmentBlendMode;
+            if (i !== null)
+                return i.environmentBlendMode;
         };
 
-        function N(H) {
-            for (let ee = 0; ee < H.removed.length; ee++) {
-                const pe = H.removed[ee],
-                    Te = A.indexOf(pe);
-                Te >= 0 && (A[Te] = null, _[Te].disconnect(pe));
-            }
-            for (let ee = 0; ee < H.added.length; ee++) {
-                const pe = H.added[ee];
-                let Te = A.indexOf(pe);
-                if (Te === -1) {
-                    for (let ge = 0; ge < _.length; ge++)
-                        if (ge >= A.length) {
-                            A.push(pe), Te = ge;
+        function I(V) {
+            for (let J = 0; J < V.removed.length; J++) {
+                const se = V.removed[J],
+                    Ae = y.indexOf(se);
+                Ae >= 0 && (y[Ae] = null, S[Ae].disconnect(se));
+            }
+            for (let J = 0; J < V.added.length; J++) {
+                const se = V.added[J];
+                let Ae = y.indexOf(se);
+                if (Ae === -1) {
+                    for (let ge = 0; ge < S.length; ge++)
+                        if (ge >= y.length) {
+                            y.push(se), Ae = ge;
                             break;
-                        } else if (A[ge] === null) {
-                        A[ge] = pe, Te = ge;
+                        } else if (y[ge] === null) {
+                        y[ge] = se, Ae = ge;
                         break;
                     }
-                    if (Te === -1)
+                    if (Ae === -1)
                         break;
                 }
-                const xe = _[Te];
-                xe && xe.connect(pe);
+                const xe = S[Ae];
+                xe && xe.connect(se);
             }
         }
-        const O = new P(),
-            B = new P();
+        const z = new D(),
+            K = new D();
 
-        function j(H, ee, pe) {
-            O.setFromMatrixPosition(ee.matrixWorld), B.setFromMatrixPosition(pe.matrixWorld);
-            const Te = O.distanceTo(B),
-                xe = ee.projectionMatrix.elements,
-                ge = pe.projectionMatrix.elements,
-                Ke = xe[14] / (xe[10] - 1),
-                we = xe[14] / (xe[10] + 1),
-                F = (xe[9] + 1) / xe[5],
-                lt = (xe[9] - 1) / xe[5],
-                Me = (xe[8] - 1) / xe[0],
-                Ne = (ge[8] + 1) / ge[0],
-                ye = Ke * Me,
-                qe = Ke * Ne,
-                Ie = Te / (-Me + Ne),
-                Be = Ie * -Me;
-            ee.matrixWorld.decompose(H.position, H.quaternion, H.scale), H.translateX(Be), H.translateZ(Ie), H.matrixWorld.compose(H.position, H.quaternion, H.scale), H.matrixWorldInverse.copy(H.matrixWorld).invert();
-            const Je = Ke + Ie,
-                w = we + Ie,
-                x = ye - Be,
-                X = qe + (Te - Be),
-                Q = F * we / w * Je,
-                te = lt * we / w * Je;
-            H.projectionMatrix.makePerspective(x, X, Q, te, Je, w), H.projectionMatrixInverse.copy(H.projectionMatrix).invert();
+        function G(V, J, se) {
+            z.setFromMatrixPosition(J.matrixWorld), K.setFromMatrixPosition(se.matrixWorld);
+            const Ae = z.distanceTo(K),
+                xe = J.projectionMatrix.elements,
+                ge = se.projectionMatrix.elements,
+                Qe = xe[14] / (xe[10] - 1),
+                Re = xe[14] / (xe[10] + 1),
+                O = (xe[9] + 1) / xe[5],
+                Je = (xe[9] - 1) / xe[5],
+                Te = (xe[8] - 1) / xe[0],
+                Ie = (ge[8] + 1) / ge[0],
+                Me = Qe * Te,
+                ze = Qe * Ie,
+                Oe = Ae / (-Te + Ie),
+                we = Oe * -Te;
+            J.matrixWorld.decompose(V.position, V.quaternion, V.scale), V.translateX(we), V.translateZ(Oe), V.matrixWorld.compose(V.position, V.quaternion, V.scale), V.matrixWorldInverse.copy(V.matrixWorld).invert();
+            const Ke = Qe + Oe,
+                w = Re + Oe,
+                M = Me - we,
+                k = ze + (Ae - we),
+                Z = O * Re / w * Ke,
+                re = Je * Re / w * Ke;
+            V.projectionMatrix.makePerspective(M, k, Z, re, Ke, w), V.projectionMatrixInverse.copy(V.projectionMatrix).invert();
         }
 
-        function q(H, ee) {
-            ee === null ? H.matrixWorld.copy(H.matrix) : H.matrixWorld.multiplyMatrices(ee.matrixWorld, H.matrix), H.matrixWorldInverse.copy(H.matrixWorld).invert();
+        function q(V, J) {
+            J === null ? V.matrixWorld.copy(V.matrix) : V.matrixWorld.multiplyMatrices(J.matrixWorld, V.matrix), V.matrixWorldInverse.copy(V.matrixWorld).invert();
         }
-        this.updateCamera = function(H) {
-            if (r === null)
+        this.updateCamera = function(V) {
+            if (i === null)
                 return;
-            v.texture !== null && (H.near = v.depthNear, H.far = v.depthFar), S.near = I.near = b.near = H.near, S.far = I.far = b.far = H.far, (T !== S.near || Y !== S.far) && (r.updateRenderState({
-                depthNear: S.near,
-                depthFar: S.far
-            }), T = S.near, Y = S.far, b.near = T, b.far = Y, I.near = T, I.far = Y, b.updateProjectionMatrix(), I.updateProjectionMatrix(), H.updateProjectionMatrix());
-            const ee = H.parent,
-                pe = S.cameras;
-            q(S, ee);
-            for (let Te = 0; Te < pe.length; Te++)
-                q(pe[Te], ee);
-            pe.length === 2 ? j(S, b, I) : S.projectionMatrix.copy(b.projectionMatrix), J(H, S, ee);
+            _.texture !== null && (V.near = _.depthNear, V.far = _.depthFar), x.near = L.near = T.near = V.near, x.far = L.far = T.far = V.far, (A !== x.near || U !== x.far) && (i.updateRenderState({
+                depthNear: x.near,
+                depthFar: x.far
+            }), A = x.near, U = x.far, T.near = A, T.far = U, L.near = A, L.far = U, T.updateProjectionMatrix(), L.updateProjectionMatrix(), V.updateProjectionMatrix());
+            const J = V.parent,
+                se = x.cameras;
+            q(x, J);
+            for (let Ae = 0; Ae < se.length; Ae++)
+                q(se[Ae], J);
+            se.length === 2 ? G(x, T, L) : x.projectionMatrix.copy(T.projectionMatrix), Q(V, x, J);
         };
 
-        function J(H, ee, pe) {
-            pe === null ? H.matrix.copy(ee.matrixWorld) : (H.matrix.copy(pe.matrixWorld), H.matrix.invert(), H.matrix.multiply(ee.matrixWorld)), H.matrix.decompose(H.position, H.quaternion, H.scale), H.updateMatrixWorld(!0), H.projectionMatrix.copy(ee.projectionMatrix), H.projectionMatrixInverse.copy(ee.projectionMatrixInverse), H.isPerspectiveCamera && (H.fov = fr * 2 * Math.atan(1 / H.projectionMatrix.elements[5]), H.zoom = 1);
+        function Q(V, J, se) {
+            se === null ? V.matrix.copy(J.matrixWorld) : (V.matrix.copy(se.matrixWorld), V.matrix.invert(), V.matrix.multiply(J.matrixWorld)), V.matrix.decompose(V.position, V.quaternion, V.scale), V.updateMatrixWorld(!0), V.projectionMatrix.copy(J.projectionMatrix), V.projectionMatrixInverse.copy(J.projectionMatrixInverse), V.isPerspectiveCamera && (V.fov = Ls * 2 * Math.atan(1 / V.projectionMatrix.elements[5]), V.zoom = 1);
         }
         this.getCamera = function() {
-            return S;
+            return x;
         }, this.getFoveation = function() {
-            if (!(h === null && p === null))
+            if (!(f === null && h === null))
                 return l;
-        }, this.setFoveation = function(H) {
-            l = H, h !== null && (h.fixedFoveation = H), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = H);
+        }, this.setFoveation = function(V) {
+            l = V, f !== null && (f.fixedFoveation = V), h !== null && h.fixedFoveation !== void 0 && (h.fixedFoveation = V);
         }, this.hasDepthSensing = function() {
-            return v.texture !== null;
+            return _.texture !== null;
         };
-        let ne = null;
+        let te = null;
 
-        function ue(H, ee) {
-            if (u = ee.getViewerPose(c || a), g = ee, u !== null) {
-                const pe = u.views;
-                p !== null && (e.setRenderTargetFramebuffer(M, p.framebuffer), e.setRenderTarget(M));
-                let Te = !1;
-                pe.length !== S.cameras.length && (S.cameras.length = 0, Te = !0);
-                for (let ge = 0; ge < pe.length; ge++) {
-                    const Ke = pe[ge];
-                    let we = null;
-                    if (p !== null)
-                        we = p.getViewport(Ke);
+        function fe(V, J) {
+            if (u = J.getViewerPose(c || o), g = J, u !== null) {
+                const se = u.views;
+                h !== null && (e.setRenderTargetFramebuffer(v, h.framebuffer), e.setRenderTarget(v));
+                let Ae = !1;
+                se.length !== x.cameras.length && (x.cameras.length = 0, Ae = !0);
+                for (let ge = 0; ge < se.length; ge++) {
+                    const Qe = se[ge];
+                    let Re = null;
+                    if (h !== null)
+                        Re = h.getViewport(Qe);
                     else {
-                        const lt = f.getViewSubImage(h, Ke);
-                        we = lt.viewport, ge === 0 && (e.setRenderTargetTextures(
-                            M,
-                            lt.colorTexture,
-                            h.ignoreDepthValues ? void 0 : lt.depthStencilTexture
-                        ), e.setRenderTarget(M));
+                        const Je = d.getViewSubImage(f, Qe);
+                        Re = Je.viewport, ge === 0 && (e.setRenderTargetTextures(
+                            v,
+                            Je.colorTexture,
+                            f.ignoreDepthValues ? void 0 : Je.depthStencilTexture
+                        ), e.setRenderTarget(v));
                     }
-                    let F = W[ge];
-                    F === void 0 && (F = new Ht(), F.layers.enable(ge), F.viewport = new ut(), W[ge] = F), F.matrix.fromArray(Ke.transform.matrix), F.matrix.decompose(F.position, F.quaternion, F.scale), F.projectionMatrix.fromArray(Ke.projectionMatrix), F.projectionMatrixInverse.copy(F.projectionMatrix).invert(), F.viewport.set(we.x, we.y, we.width, we.height), ge === 0 && (S.matrix.copy(F.matrix), S.matrix.decompose(S.position, S.quaternion, S.scale)), Te === !0 && S.cameras.push(F);
+                    let O = B[ge];
+                    O === void 0 && (O = new $t(), O.layers.enable(ge), O.viewport = new _t(), B[ge] = O), O.matrix.fromArray(Qe.transform.matrix), O.matrix.decompose(O.position, O.quaternion, O.scale), O.projectionMatrix.fromArray(Qe.projectionMatrix), O.projectionMatrixInverse.copy(O.projectionMatrix).invert(), O.viewport.set(Re.x, Re.y, Re.width, Re.height), ge === 0 && (x.matrix.copy(O.matrix), x.matrix.decompose(x.position, x.quaternion, x.scale)), Ae === !0 && x.cameras.push(O);
                 }
-                const xe = r.enabledFeatures;
+                const xe = i.enabledFeatures;
                 if (xe && xe.includes("depth-sensing")) {
-                    const ge = f.getDepthInformation(pe[0]);
-                    ge && ge.isValid && ge.texture && v.init(e, ge, r.renderState);
+                    const ge = d.getDepthInformation(se[0]);
+                    ge && ge.isValid && ge.texture && _.init(e, ge, i.renderState);
                 }
             }
-            for (let pe = 0; pe < _.length; pe++) {
-                const Te = A[pe],
-                    xe = _[pe];
-                Te !== null && xe !== void 0 && xe.update(Te, ee, c || a);
+            for (let se = 0; se < S.length; se++) {
+                const Ae = y[se],
+                    xe = S[se];
+                Ae !== null && xe !== void 0 && xe.update(Ae, J, c || o);
             }
-            v.render(e, S), ne && ne(H, ee), ee.detectedPlanes && n.dispatchEvent({
+            _.render(e, x), te && te(V, J), J.detectedPlanes && n.dispatchEvent({
                 type: "planesdetected",
-                data: ee
+                data: J
             }), g = null;
         }
-        const Z = new sc();
-        Z.setAnimationLoop(ue), this.setAnimationLoop = function(H) {
-            ne = H;
+        const ne = new $c();
+        ne.setAnimationLoop(fe), this.setAnimationLoop = function(V) {
+            te = V;
         }, this.dispose = function() {};
     }
 }
-const Jn = /* @__PURE__ */ new bn(),
-    e_ = /* @__PURE__ */ new ke();
+const ui = /* @__PURE__ */ new Nn(),
+    K0 = /* @__PURE__ */ new Ge();
 
-function t_(i, e) {
-    function t(m, d) {
-        m.matrixAutoUpdate === !0 && m.updateMatrix(), d.value.copy(m.matrix);
+function Z0(s, e) {
+    function t(m, p) {
+        m.matrixAutoUpdate === !0 && m.updateMatrix(), p.value.copy(m.matrix);
     }
 
-    function n(m, d) {
-        d.color.getRGB(m.fogColor.value, tc(i)), d.isFog ? (m.fogNear.value = d.near, m.fogFar.value = d.far) : d.isFogExp2 && (m.fogDensity.value = d.density);
+    function n(m, p) {
+        p.color.getRGB(m.fogColor.value, Kc(s)), p.isFog ? (m.fogNear.value = p.near, m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density);
     }
 
-    function r(m, d, M, _, A) {
-        d.isMeshBasicMaterial || d.isMeshLambertMaterial ? s(m, d) : d.isMeshToonMaterial ? (s(m, d), f(m, d)) : d.isMeshPhongMaterial ? (s(m, d), u(m, d)) : d.isMeshStandardMaterial ? (s(m, d), h(m, d), d.isMeshPhysicalMaterial && p(m, d, A)) : d.isMeshMatcapMaterial ? (s(m, d), g(m, d)) : d.isMeshDepthMaterial ? s(m, d) : d.isMeshDistanceMaterial ? (s(m, d), v(m, d)) : d.isMeshNormalMaterial ? s(m, d) : d.isLineBasicMaterial ? (a(m, d), d.isLineDashedMaterial && o(m, d)) : d.isPointsMaterial ? l(m, d, M, _) : d.isSpriteMaterial ? c(m, d) : d.isShadowMaterial ? (m.color.value.copy(d.color), m.opacity.value = d.opacity) : d.isShaderMaterial && (d.uniformsNeedUpdate = !1);
+    function i(m, p, v, S, y) {
+        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(m, p) : p.isMeshToonMaterial ? (r(m, p), d(m, p)) : p.isMeshPhongMaterial ? (r(m, p), u(m, p)) : p.isMeshStandardMaterial ? (r(m, p), f(m, p), p.isMeshPhysicalMaterial && h(m, p, y)) : p.isMeshMatcapMaterial ? (r(m, p), g(m, p)) : p.isMeshDepthMaterial ? r(m, p) : p.isMeshDistanceMaterial ? (r(m, p), _(m, p)) : p.isMeshNormalMaterial ? r(m, p) : p.isLineBasicMaterial ? (o(m, p), p.isLineDashedMaterial && a(m, p)) : p.isPointsMaterial ? l(m, p, v, S) : p.isSpriteMaterial ? c(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color), m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1);
     }
 
-    function s(m, d) {
-        m.opacity.value = d.opacity, d.color && m.diffuse.value.copy(d.color), d.emissive && m.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity), d.map && (m.map.value = d.map, t(d.map, m.mapTransform)), d.alphaMap && (m.alphaMap.value = d.alphaMap, t(d.alphaMap, m.alphaMapTransform)), d.bumpMap && (m.bumpMap.value = d.bumpMap, t(d.bumpMap, m.bumpMapTransform), m.bumpScale.value = d.bumpScale, d.side === Pt && (m.bumpScale.value *= -1)), d.normalMap && (m.normalMap.value = d.normalMap, t(d.normalMap, m.normalMapTransform), m.normalScale.value.copy(d.normalScale), d.side === Pt && m.normalScale.value.negate()), d.displacementMap && (m.displacementMap.value = d.displacementMap, t(d.displacementMap, m.displacementMapTransform), m.displacementScale.value = d.displacementScale, m.displacementBias.value = d.displacementBias), d.emissiveMap && (m.emissiveMap.value = d.emissiveMap, t(d.emissiveMap, m.emissiveMapTransform)), d.specularMap && (m.specularMap.value = d.specularMap, t(d.specularMap, m.specularMapTransform)), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
-        const M = e.get(d),
-            _ = M.envMap,
-            A = M.envMapRotation;
-        if (_ && (m.envMap.value = _, Jn.copy(A), Jn.x *= -1, Jn.y *= -1, Jn.z *= -1, _.isCubeTexture && _.isRenderTargetTexture === !1 && (Jn.y *= -1, Jn.z *= -1), m.envMapRotation.value.setFromMatrix4(e_.makeRotationFromEuler(Jn)), m.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = d.reflectivity, m.ior.value = d.ior, m.refractionRatio.value = d.refractionRatio), d.lightMap) {
-            m.lightMap.value = d.lightMap;
-            const R = i._useLegacyLights === !0 ? Math.PI : 1;
-            m.lightMapIntensity.value = d.lightMapIntensity * R, t(d.lightMap, m.lightMapTransform);
+    function r(m, p) {
+        m.opacity.value = p.opacity, p.color && m.diffuse.value.copy(p.color), p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity), p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.bumpMap && (m.bumpMap.value = p.bumpMap, t(p.bumpMap, m.bumpMapTransform), m.bumpScale.value = p.bumpScale, p.side === zt && (m.bumpScale.value *= -1)), p.normalMap && (m.normalMap.value = p.normalMap, t(p.normalMap, m.normalMapTransform), m.normalScale.value.copy(p.normalScale), p.side === zt && m.normalScale.value.negate()), p.displacementMap && (m.displacementMap.value = p.displacementMap, t(p.displacementMap, m.displacementMapTransform), m.displacementScale.value = p.displacementScale, m.displacementBias.value = p.displacementBias), p.emissiveMap && (m.emissiveMap.value = p.emissiveMap, t(p.emissiveMap, m.emissiveMapTransform)), p.specularMap && (m.specularMap.value = p.specularMap, t(p.specularMap, m.specularMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
+        const v = e.get(p),
+            S = v.envMap,
+            y = v.envMapRotation;
+        if (S && (m.envMap.value = S, ui.copy(y), ui.x *= -1, ui.y *= -1, ui.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (ui.y *= -1, ui.z *= -1), m.envMapRotation.value.setFromMatrix4(K0.makeRotationFromEuler(ui)), m.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = p.reflectivity, m.ior.value = p.ior, m.refractionRatio.value = p.refractionRatio), p.lightMap) {
+            m.lightMap.value = p.lightMap;
+            const b = s._useLegacyLights === !0 ? Math.PI : 1;
+            m.lightMapIntensity.value = p.lightMapIntensity * b, t(p.lightMap, m.lightMapTransform);
         }
-        d.aoMap && (m.aoMap.value = d.aoMap, m.aoMapIntensity.value = d.aoMapIntensity, t(d.aoMap, m.aoMapTransform));
+        p.aoMap && (m.aoMap.value = p.aoMap, m.aoMapIntensity.value = p.aoMapIntensity, t(p.aoMap, m.aoMapTransform));
     }
 
-    function a(m, d) {
-        m.diffuse.value.copy(d.color), m.opacity.value = d.opacity, d.map && (m.map.value = d.map, t(d.map, m.mapTransform));
+    function o(m, p) {
+        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, p.map && (m.map.value = p.map, t(p.map, m.mapTransform));
     }
 
-    function o(m, d) {
-        m.dashSize.value = d.dashSize, m.totalSize.value = d.dashSize + d.gapSize, m.scale.value = d.scale;
+    function a(m, p) {
+        m.dashSize.value = p.dashSize, m.totalSize.value = p.dashSize + p.gapSize, m.scale.value = p.scale;
     }
 
-    function l(m, d, M, _) {
-        m.diffuse.value.copy(d.color), m.opacity.value = d.opacity, m.size.value = d.size * M, m.scale.value = _ * 0.5, d.map && (m.map.value = d.map, t(d.map, m.uvTransform)), d.alphaMap && (m.alphaMap.value = d.alphaMap, t(d.alphaMap, m.alphaMapTransform)), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
+    function l(m, p, v, S) {
+        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.size.value = p.size * v, m.scale.value = S * 0.5, p.map && (m.map.value = p.map, t(p.map, m.uvTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
     }
 
-    function c(m, d) {
-        m.diffuse.value.copy(d.color), m.opacity.value = d.opacity, m.rotation.value = d.rotation, d.map && (m.map.value = d.map, t(d.map, m.mapTransform)), d.alphaMap && (m.alphaMap.value = d.alphaMap, t(d.alphaMap, m.alphaMapTransform)), d.alphaTest > 0 && (m.alphaTest.value = d.alphaTest);
+    function c(m, p) {
+        m.diffuse.value.copy(p.color), m.opacity.value = p.opacity, m.rotation.value = p.rotation, p.map && (m.map.value = p.map, t(p.map, m.mapTransform)), p.alphaMap && (m.alphaMap.value = p.alphaMap, t(p.alphaMap, m.alphaMapTransform)), p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
     }
 
-    function u(m, d) {
-        m.specular.value.copy(d.specular), m.shininess.value = Math.max(d.shininess, 1e-4);
+    function u(m, p) {
+        m.specular.value.copy(p.specular), m.shininess.value = Math.max(p.shininess, 1e-4);
     }
 
-    function f(m, d) {
-        d.gradientMap && (m.gradientMap.value = d.gradientMap);
+    function d(m, p) {
+        p.gradientMap && (m.gradientMap.value = p.gradientMap);
     }
 
-    function h(m, d) {
-        m.metalness.value = d.metalness, d.metalnessMap && (m.metalnessMap.value = d.metalnessMap, t(d.metalnessMap, m.metalnessMapTransform)), m.roughness.value = d.roughness, d.roughnessMap && (m.roughnessMap.value = d.roughnessMap, t(d.roughnessMap, m.roughnessMapTransform)), e.get(d).envMap && (m.envMapIntensity.value = d.envMapIntensity);
+    function f(m, p) {
+        m.metalness.value = p.metalness, p.metalnessMap && (m.metalnessMap.value = p.metalnessMap, t(p.metalnessMap, m.metalnessMapTransform)), m.roughness.value = p.roughness, p.roughnessMap && (m.roughnessMap.value = p.roughnessMap, t(p.roughnessMap, m.roughnessMapTransform)), e.get(p).envMap && (m.envMapIntensity.value = p.envMapIntensity);
     }
 
-    function p(m, d, M) {
-        m.ior.value = d.ior, d.sheen > 0 && (m.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen), m.sheenRoughness.value = d.sheenRoughness, d.sheenColorMap && (m.sheenColorMap.value = d.sheenColorMap, t(d.sheenColorMap, m.sheenColorMapTransform)), d.sheenRoughnessMap && (m.sheenRoughnessMap.value = d.sheenRoughnessMap, t(d.sheenRoughnessMap, m.sheenRoughnessMapTransform))), d.clearcoat > 0 && (m.clearcoat.value = d.clearcoat, m.clearcoatRoughness.value = d.clearcoatRoughness, d.clearcoatMap && (m.clearcoatMap.value = d.clearcoatMap, t(d.clearcoatMap, m.clearcoatMapTransform)), d.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap, t(d.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), d.clearcoatNormalMap && (m.clearcoatNormalMap.value = d.clearcoatNormalMap, t(d.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(d.clearcoatNormalScale), d.side === Pt && m.clearcoatNormalScale.value.negate())), d.iridescence > 0 && (m.iridescence.value = d.iridescence, m.iridescenceIOR.value = d.iridescenceIOR, m.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1], d.iridescenceMap && (m.iridescenceMap.value = d.iridescenceMap, t(d.iridescenceMap, m.iridescenceMapTransform)), d.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = d.iridescenceThicknessMap, t(d.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), d.transmission > 0 && (m.transmission.value = d.transmission, m.transmissionSamplerMap.value = M.texture, m.transmissionSamplerSize.value.set(M.width, M.height), d.transmissionMap && (m.transmissionMap.value = d.transmissionMap, t(d.transmissionMap, m.transmissionMapTransform)), m.thickness.value = d.thickness, d.thicknessMap && (m.thicknessMap.value = d.thicknessMap, t(d.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = d.attenuationDistance, m.attenuationColor.value.copy(d.attenuationColor)), d.anisotropy > 0 && (m.anisotropyVector.value.set(d.anisotropy * Math.cos(d.anisotropyRotation), d.anisotropy * Math.sin(d.anisotropyRotation)), d.anisotropyMap && (m.anisotropyMap.value = d.anisotropyMap, t(d.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = d.specularIntensity, m.specularColor.value.copy(d.specularColor), d.specularColorMap && (m.specularColorMap.value = d.specularColorMap, t(d.specularColorMap, m.specularColorMapTransform)), d.specularIntensityMap && (m.specularIntensityMap.value = d.specularIntensityMap, t(d.specularIntensityMap, m.specularIntensityMapTransform));
+    function h(m, p, v) {
+        m.ior.value = p.ior, p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen), m.sheenRoughness.value = p.sheenRoughness, p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap, t(p.sheenColorMap, m.sheenColorMapTransform)), p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap, t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))), p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat, m.clearcoatRoughness.value = p.clearcoatRoughness, p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap, t(p.clearcoatMap, m.clearcoatMapTransform)), p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap, t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)), p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap, t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform), m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale), p.side === zt && m.clearcoatNormalScale.value.negate())), p.iridescence > 0 && (m.iridescence.value = p.iridescence, m.iridescenceIOR.value = p.iridescenceIOR, m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1], p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap, t(p.iridescenceMap, m.iridescenceMapTransform)), p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap, t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))), p.transmission > 0 && (m.transmission.value = p.transmission, m.transmissionSamplerMap.value = v.texture, m.transmissionSamplerSize.value.set(v.width, v.height), p.transmissionMap && (m.transmissionMap.value = p.transmissionMap, t(p.transmissionMap, m.transmissionMapTransform)), m.thickness.value = p.thickness, p.thicknessMap && (m.thicknessMap.value = p.thicknessMap, t(p.thicknessMap, m.thicknessMapTransform)), m.attenuationDistance.value = p.attenuationDistance, m.attenuationColor.value.copy(p.attenuationColor)), p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)), p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap, t(p.anisotropyMap, m.anisotropyMapTransform))), m.specularIntensity.value = p.specularIntensity, m.specularColor.value.copy(p.specularColor), p.specularColorMap && (m.specularColorMap.value = p.specularColorMap, t(p.specularColorMap, m.specularColorMapTransform)), p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap, t(p.specularIntensityMap, m.specularIntensityMapTransform));
     }
 
-    function g(m, d) {
-        d.matcap && (m.matcap.value = d.matcap);
+    function g(m, p) {
+        p.matcap && (m.matcap.value = p.matcap);
     }
 
-    function v(m, d) {
-        const M = e.get(d).light;
-        m.referencePosition.value.setFromMatrixPosition(M.matrixWorld), m.nearDistance.value = M.shadow.camera.near, m.farDistance.value = M.shadow.camera.far;
+    function _(m, p) {
+        const v = e.get(p).light;
+        m.referencePosition.value.setFromMatrixPosition(v.matrixWorld), m.nearDistance.value = v.shadow.camera.near, m.farDistance.value = v.shadow.camera.far;
     }
     return {
         refreshFogUniforms: n,
-        refreshMaterialUniforms: r
+        refreshMaterialUniforms: i
     };
 }
 
-function n_(i, e, t, n) {
-    let r = {},
-        s = {},
-        a = [];
-    const o = t.isWebGL2 ? i.getParameter(i.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
+function Q0(s, e, t, n) {
+    let i = {},
+        r = {},
+        o = [];
+    const a = t.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
 
-    function l(M, _) {
-        const A = _.program;
-        n.uniformBlockBinding(M, A);
+    function l(v, S) {
+        const y = S.program;
+        n.uniformBlockBinding(v, y);
     }
 
-    function c(M, _) {
-        let A = r[M.id];
-        A === void 0 && (g(M), A = u(M), r[M.id] = A, M.addEventListener("dispose", m));
-        const R = _.program;
-        n.updateUBOMapping(M, R);
+    function c(v, S) {
+        let y = i[v.id];
+        y === void 0 && (g(v), y = u(v), i[v.id] = y, v.addEventListener("dispose", m));
+        const b = S.program;
+        n.updateUBOMapping(v, b);
         const E = e.render.frame;
-        s[M.id] !== E && (h(M), s[M.id] = E);
+        r[v.id] !== E && (f(v), r[v.id] = E);
     }
 
-    function u(M) {
-        const _ = f();
-        M.__bindingPointIndex = _;
-        const A = i.createBuffer(),
-            R = M.__size,
-            E = M.usage;
-        return i.bindBuffer(i.UNIFORM_BUFFER, A), i.bufferData(i.UNIFORM_BUFFER, R, E), i.bindBuffer(i.UNIFORM_BUFFER, null), i.bindBufferBase(i.UNIFORM_BUFFER, _, A), A;
+    function u(v) {
+        const S = d();
+        v.__bindingPointIndex = S;
+        const y = s.createBuffer(),
+            b = v.__size,
+            E = v.usage;
+        return s.bindBuffer(s.UNIFORM_BUFFER, y), s.bufferData(s.UNIFORM_BUFFER, b, E), s.bindBuffer(s.UNIFORM_BUFFER, null), s.bindBufferBase(s.UNIFORM_BUFFER, S, y), y;
     }
 
-    function f() {
-        for (let M = 0; M < o; M++)
-            if (a.indexOf(M) === -1)
-                return a.push(M), M;
+    function d() {
+        for (let v = 0; v < a; v++)
+            if (o.indexOf(v) === -1)
+                return o.push(v), v;
         return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
     }
 
-    function h(M) {
-        const _ = r[M.id],
-            A = M.uniforms,
-            R = M.__cache;
-        i.bindBuffer(i.UNIFORM_BUFFER, _);
-        for (let E = 0, b = A.length; E < b; E++) {
-            const I = Array.isArray(A[E]) ? A[E] : [A[E]];
-            for (let W = 0, S = I.length; W < S; W++) {
-                const T = I[W];
-                if (p(T, E, W, R) === !0) {
-                    const Y = T.__offset,
-                        K = Array.isArray(T.value) ? T.value : [T.value];
-                    let L = 0;
-                    for (let N = 0; N < K.length; N++) {
-                        const O = K[N],
-                            B = v(O);
-                        typeof O == "number" || typeof O == "boolean" ? (T.__data[0] = O, i.bufferSubData(i.UNIFORM_BUFFER, Y + L, T.__data)) : O.isMatrix3 ? (T.__data[0] = O.elements[0], T.__data[1] = O.elements[1], T.__data[2] = O.elements[2], T.__data[3] = 0, T.__data[4] = O.elements[3], T.__data[5] = O.elements[4], T.__data[6] = O.elements[5], T.__data[7] = 0, T.__data[8] = O.elements[6], T.__data[9] = O.elements[7], T.__data[10] = O.elements[8], T.__data[11] = 0) : (O.toArray(T.__data, L), L += B.storage / Float32Array.BYTES_PER_ELEMENT);
+    function f(v) {
+        const S = i[v.id],
+            y = v.uniforms,
+            b = v.__cache;
+        s.bindBuffer(s.UNIFORM_BUFFER, S);
+        for (let E = 0, T = y.length; E < T; E++) {
+            const L = Array.isArray(y[E]) ? y[E] : [y[E]];
+            for (let B = 0, x = L.length; B < x; B++) {
+                const A = L[B];
+                if (h(A, E, B, b) === !0) {
+                    const U = A.__offset,
+                        N = Array.isArray(A.value) ? A.value : [A.value];
+                    let P = 0;
+                    for (let I = 0; I < N.length; I++) {
+                        const z = N[I],
+                            K = _(z);
+                        typeof z == "number" || typeof z == "boolean" ? (A.__data[0] = z, s.bufferSubData(s.UNIFORM_BUFFER, U + P, A.__data)) : z.isMatrix3 ? (A.__data[0] = z.elements[0], A.__data[1] = z.elements[1], A.__data[2] = z.elements[2], A.__data[3] = 0, A.__data[4] = z.elements[3], A.__data[5] = z.elements[4], A.__data[6] = z.elements[5], A.__data[7] = 0, A.__data[8] = z.elements[6], A.__data[9] = z.elements[7], A.__data[10] = z.elements[8], A.__data[11] = 0) : (z.toArray(A.__data, P), P += K.storage / Float32Array.BYTES_PER_ELEMENT);
                     }
-                    i.bufferSubData(i.UNIFORM_BUFFER, Y, T.__data);
+                    s.bufferSubData(s.UNIFORM_BUFFER, U, A.__data);
                 }
             }
         }
-        i.bindBuffer(i.UNIFORM_BUFFER, null);
+        s.bindBuffer(s.UNIFORM_BUFFER, null);
     }
 
-    function p(M, _, A, R) {
-        const E = M.value,
-            b = _ + "_" + A;
-        if (R[b] === void 0)
-            return typeof E == "number" || typeof E == "boolean" ? R[b] = E : R[b] = E.clone(), !0;
+    function h(v, S, y, b) {
+        const E = v.value,
+            T = S + "_" + y;
+        if (b[T] === void 0)
+            return typeof E == "number" || typeof E == "boolean" ? b[T] = E : b[T] = E.clone(), !0;
         {
-            const I = R[b];
+            const L = b[T];
             if (typeof E == "number" || typeof E == "boolean") {
-                if (I !== E)
-                    return R[b] = E, !0;
-            } else if (I.equals(E) === !1)
-                return I.copy(E), !0;
+                if (L !== E)
+                    return b[T] = E, !0;
+            } else if (L.equals(E) === !1)
+                return L.copy(E), !0;
         }
         return !1;
     }
 
-    function g(M) {
-        const _ = M.uniforms;
-        let A = 0;
-        const R = 16;
-        for (let b = 0, I = _.length; b < I; b++) {
-            const W = Array.isArray(_[b]) ? _[b] : [_[b]];
-            for (let S = 0, T = W.length; S < T; S++) {
-                const Y = W[S],
-                    K = Array.isArray(Y.value) ? Y.value : [Y.value];
-                for (let L = 0, N = K.length; L < N; L++) {
-                    const O = K[L],
-                        B = v(O),
-                        j = A % R;
-                    j !== 0 && R - j < B.boundary && (A += R - j), Y.__data = new Float32Array(B.storage / Float32Array.BYTES_PER_ELEMENT), Y.__offset = A, A += B.storage;
+    function g(v) {
+        const S = v.uniforms;
+        let y = 0;
+        const b = 16;
+        for (let T = 0, L = S.length; T < L; T++) {
+            const B = Array.isArray(S[T]) ? S[T] : [S[T]];
+            for (let x = 0, A = B.length; x < A; x++) {
+                const U = B[x],
+                    N = Array.isArray(U.value) ? U.value : [U.value];
+                for (let P = 0, I = N.length; P < I; P++) {
+                    const z = N[P],
+                        K = _(z),
+                        G = y % b;
+                    G !== 0 && b - G < K.boundary && (y += b - G), U.__data = new Float32Array(K.storage / Float32Array.BYTES_PER_ELEMENT), U.__offset = y, y += K.storage;
                 }
             }
         }
-        const E = A % R;
-        return E > 0 && (A += R - E), M.__size = A, M.__cache = {}, this;
+        const E = y % b;
+        return E > 0 && (y += b - E), v.__size = y, v.__cache = {}, this;
     }
 
-    function v(M) {
-        const _ = {
+    function _(v) {
+        const S = {
             boundary: 0,
             // bytes
             storage: 0
             // bytes
         };
-        return typeof M == "number" || typeof M == "boolean" ? (_.boundary = 4, _.storage = 4) : M.isVector2 ? (_.boundary = 8, _.storage = 8) : M.isVector3 || M.isColor ? (_.boundary = 16, _.storage = 12) : M.isVector4 ? (_.boundary = 16, _.storage = 16) : M.isMatrix3 ? (_.boundary = 48, _.storage = 48) : M.isMatrix4 ? (_.boundary = 64, _.storage = 64) : M.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", M), _;
+        return typeof v == "number" || typeof v == "boolean" ? (S.boundary = 4, S.storage = 4) : v.isVector2 ? (S.boundary = 8, S.storage = 8) : v.isVector3 || v.isColor ? (S.boundary = 16, S.storage = 12) : v.isVector4 ? (S.boundary = 16, S.storage = 16) : v.isMatrix3 ? (S.boundary = 48, S.storage = 48) : v.isMatrix4 ? (S.boundary = 64, S.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), S;
     }
 
-    function m(M) {
-        const _ = M.target;
-        _.removeEventListener("dispose", m);
-        const A = a.indexOf(_.__bindingPointIndex);
-        a.splice(A, 1), i.deleteBuffer(r[_.id]), delete r[_.id], delete s[_.id];
+    function m(v) {
+        const S = v.target;
+        S.removeEventListener("dispose", m);
+        const y = o.indexOf(S.__bindingPointIndex);
+        o.splice(y, 1), s.deleteBuffer(i[S.id]), delete i[S.id], delete r[S.id];
     }
 
-    function d() {
-        for (const M in r)
-            i.deleteBuffer(r[M]);
-        a = [], r = {}, s = {};
+    function p() {
+        for (const v in i)
+            s.deleteBuffer(i[v]);
+        o = [], i = {}, r = {};
     }
     return {
         bind: l,
         update: c,
-        dispose: d
+        dispose: p
     };
 }
-class hc {
+class au {
     constructor(e = {}) {
         const {
-            canvas: t = Hf(),
+            canvas: t = Nf(),
             context: n = null,
-            depth: r = !0,
-            stencil: s = !0,
-            alpha: a = !1,
-            antialias: o = !1,
+            depth: i = !0,
+            stencil: r = !0,
+            alpha: o = !1,
+            antialias: a = !1,
             premultipliedAlpha: l = !0,
             preserveDrawingBuffer: c = !1,
             powerPreference: u = "default",
-            failIfMajorPerformanceCaveat: f = !1
+            failIfMajorPerformanceCaveat: d = !1
         } = e;
         this.isWebGLRenderer = !0;
-        let h;
-        n !== null ? h = n.getContextAttributes().alpha : h = a;
-        const p = new Uint32Array(4),
+        let f;
+        n !== null ? f = n.getContextAttributes().alpha : f = o;
+        const h = new Uint32Array(4),
             g = new Int32Array(4);
-        let v = null,
+        let _ = null,
             m = null;
-        const d = [],
-            M = [];
+        const p = [],
+            v = [];
         this.domElement = t, this.debug = {
             /**
              * Enables error checking and reporting when shader programs are being compiled
              * @type {boolean}
              */
             checkShaderErrors: !0,
             /**
              * Callback for custom error reporting.
              * @type {?Function}
              */
             onShaderError: null
-        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = sn, this._useLegacyLights = !1, this.toneMapping = kn, this.toneMappingExposure = 1;
-        const _ = this;
-        let A = !1,
-            R = 0,
+        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = pn, this._useLegacyLights = !1, this.toneMapping = $n, this.toneMappingExposure = 1;
+        const S = this;
+        let y = !1,
+            b = 0,
             E = 0,
-            b = null,
-            I = -1,
-            W = null;
-        const S = new ut(),
-            T = new ut();
-        let Y = null;
-        const K = new Qe(0);
-        let L = 0,
-            N = t.width,
-            O = t.height,
-            B = 1,
-            j = null,
+            T = null,
+            L = -1,
+            B = null;
+        const x = new _t(),
+            A = new _t();
+        let U = null;
+        const N = new et(0);
+        let P = 0,
+            I = t.width,
+            z = t.height,
+            K = 1,
+            G = null,
             q = null;
-        const J = new ut(0, 0, N, O),
-            ne = new ut(0, 0, N, O);
-        let ue = !1;
-        const Z = new rc();
-        let H = !1,
-            ee = !1,
-            pe = null;
-        const Te = new ke(),
-            xe = new me(),
-            ge = new P(),
-            Ke = {
+        const Q = new _t(0, 0, I, z),
+            te = new _t(0, 0, I, z);
+        let fe = !1;
+        const ne = new Jc();
+        let V = !1,
+            J = !1,
+            se = null;
+        const Ae = new Ge(),
+            xe = new Ee(),
+            ge = new D(),
+            Qe = {
                 background: null,
                 fog: null,
                 environment: null,
                 overrideMaterial: null,
                 isScene: !0
             };
 
-        function we() {
-            return b === null ? B : 1;
+        function Re() {
+            return T === null ? K : 1;
         }
-        let F = n;
+        let O = n;
 
-        function lt(y, U) {
-            for (let G = 0; G < y.length; G++) {
-                const V = y[G],
-                    k = t.getContext(V, U);
-                if (k !== null)
-                    return k;
+        function Je(C, H) {
+            for (let Y = 0; Y < C.length; Y++) {
+                const j = C[Y],
+                    X = t.getContext(j, H);
+                if (X !== null)
+                    return X;
             }
             return null;
         }
         try {
-            const y = {
+            const C = {
                 alpha: !0,
-                depth: r,
-                stencil: s,
-                antialias: o,
+                depth: i,
+                stencil: r,
+                antialias: a,
                 premultipliedAlpha: l,
                 preserveDrawingBuffer: c,
                 powerPreference: u,
-                failIfMajorPerformanceCaveat: f
+                failIfMajorPerformanceCaveat: d
             };
-            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${uo}`), t.addEventListener("webglcontextlost", $e, !1), t.addEventListener("webglcontextrestored", D, !1), t.addEventListener("webglcontextcreationerror", re, !1), F === null) {
-                const U = ["webgl2", "webgl", "experimental-webgl"];
-                if (_.isWebGL1Renderer === !0 && U.shift(), F = lt(U, y), F === null)
-                    throw lt(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
+            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Ya}`), t.addEventListener("webglcontextlost", nt, !1), t.addEventListener("webglcontextrestored", F, !1), t.addEventListener("webglcontextcreationerror", ce, !1), O === null) {
+                const H = ["webgl2", "webgl", "experimental-webgl"];
+                if (S.isWebGL1Renderer === !0 && H.shift(), O = Je(H, C), O === null)
+                    throw Je(H) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
             }
-            typeof WebGLRenderingContext < "u" && F instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), F.getShaderPrecisionFormat === void 0 && (F.getShaderPrecisionFormat = function() {
+            typeof WebGLRenderingContext < "u" && O instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), O.getShaderPrecisionFormat === void 0 && (O.getShaderPrecisionFormat = function() {
                 return {
                     rangeMin: 1,
                     rangeMax: 1,
                     precision: 1
                 };
             });
-        } catch (y) {
-            throw console.error("THREE.WebGLRenderer: " + y.message), y;
+        } catch (C) {
+            throw console.error("THREE.WebGLRenderer: " + C.message), C;
         }
-        let Me, Ne, ye, qe, Ie, Be, Je, w, x, X, Q, te, $, Le, Ae, se, ce, Re, C, le, ve, fe, he, _e;
+        let Te, Ie, Me, ze, Oe, we, Ke, w, M, k, Z, re, ie, Be, Pe, oe, de, De, R, ue, Se, me, _e, ve;
 
-        function De() {
-            Me = new lm(F), Ne = new nm(F, Me, e), Me.init(Ne), fe = new Yg(F, Me, Ne), ye = new Xg(F, Me, Ne), qe = new fm(F), Ie = new Lg(), Be = new qg(F, Me, ye, Ie, Ne, fe, qe), Je = new rm(_), w = new am(_), x = new _h(F, Ne), he = new em(F, Me, x, Ne), X = new cm(F, x, qe, he), Q = new mm(F, X, x, qe), C = new pm(F, Ne, Be), se = new im(Ie), te = new Pg(_, Je, w, Me, Ne, he, se), $ = new t_(_, Ie), Le = new Ig(), Ae = new zg(Me, Ne), Re = new $p(_, Je, w, ye, Q, h, l), ce = new Wg(_, Q, Ne), _e = new n_(F, qe, Ne, ye), le = new tm(F, Me, qe, Ne), ve = new um(F, Me, qe, Ne), qe.programs = te.programs, _.capabilities = Ne, _.extensions = Me, _.properties = Ie, _.renderLists = Le, _.shadowMap = ce, _.state = ye, _.info = qe;
+        function Le() {
+            Te = new sg(O), Ie = new Jm(O, Te, e), Te.init(Ie), me = new ru(O, Te, Ie), Me = new H0(O, Te, Ie), ze = new og(O), Oe = new C0(), we = new G0(O, Te, Me, Oe, Ie, me, ze), Ke = new eg(S), w = new ig(S), M = new hh(O, Ie), _e = new Zm(O, Te, M, Ie), k = new rg(O, M, ze, _e), Z = new dg(O, k, M, ze), R = new ug(O, Ie, we), oe = new $m(Oe), re = new b0(S, Ke, w, Te, Ie, _e, oe), ie = new Z0(S, Oe), Be = new R0(), Pe = new U0(Te, Ie), De = new Km(S, Ke, w, Me, Z, f, l), de = new z0(S, Z, Ie), ve = new Q0(O, ze, Ie, Me), ue = new Qm(O, Te, ze, Ie), Se = new ag(O, Te, ze, Ie), ze.programs = re.programs, S.capabilities = Ie, S.extensions = Te, S.properties = Oe, S.renderLists = Be, S.shadowMap = de, S.state = Me, S.info = ze;
         }
-        De();
-        const Ue = new $g(_, F);
-        this.xr = Ue, this.getContext = function() {
-            return F;
+        Le();
+        const Ne = new j0(S, O);
+        this.xr = Ne, this.getContext = function() {
+            return O;
         }, this.getContextAttributes = function() {
-            return F.getContextAttributes();
+            return O.getContextAttributes();
         }, this.forceContextLoss = function() {
-            const y = Me.get("WEBGL_lose_context");
-            y && y.loseContext();
+            const C = Te.get("WEBGL_lose_context");
+            C && C.loseContext();
         }, this.forceContextRestore = function() {
-            const y = Me.get("WEBGL_lose_context");
-            y && y.restoreContext();
+            const C = Te.get("WEBGL_lose_context");
+            C && C.restoreContext();
         }, this.getPixelRatio = function() {
-            return B;
-        }, this.setPixelRatio = function(y) {
-            y !== void 0 && (B = y, this.setSize(N, O, !1));
-        }, this.getSize = function(y) {
-            return y.set(N, O);
-        }, this.setSize = function(y, U, G = !0) {
-            if (Ue.isPresenting) {
+            return K;
+        }, this.setPixelRatio = function(C) {
+            C !== void 0 && (K = C, this.setSize(I, z, !1));
+        }, this.getSize = function(C) {
+            return C.set(I, z);
+        }, this.setSize = function(C, H, Y = !0) {
+            if (Ne.isPresenting) {
                 console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                 return;
             }
-            N = y, O = U, t.width = Math.floor(y * B), t.height = Math.floor(U * B), G === !0 && (t.style.width = y + "px", t.style.height = U + "px"), this.setViewport(0, 0, y, U);
-        }, this.getDrawingBufferSize = function(y) {
-            return y.set(N * B, O * B).floor();
-        }, this.setDrawingBufferSize = function(y, U, G) {
-            N = y, O = U, B = G, t.width = Math.floor(y * G), t.height = Math.floor(U * G), this.setViewport(0, 0, y, U);
-        }, this.getCurrentViewport = function(y) {
-            return y.copy(S);
-        }, this.getViewport = function(y) {
-            return y.copy(J);
-        }, this.setViewport = function(y, U, G, V) {
-            y.isVector4 ? J.set(y.x, y.y, y.z, y.w) : J.set(y, U, G, V), ye.viewport(S.copy(J).multiplyScalar(B).round());
-        }, this.getScissor = function(y) {
-            return y.copy(ne);
-        }, this.setScissor = function(y, U, G, V) {
-            y.isVector4 ? ne.set(y.x, y.y, y.z, y.w) : ne.set(y, U, G, V), ye.scissor(T.copy(ne).multiplyScalar(B).round());
+            I = C, z = H, t.width = Math.floor(C * K), t.height = Math.floor(H * K), Y === !0 && (t.style.width = C + "px", t.style.height = H + "px"), this.setViewport(0, 0, C, H);
+        }, this.getDrawingBufferSize = function(C) {
+            return C.set(I * K, z * K).floor();
+        }, this.setDrawingBufferSize = function(C, H, Y) {
+            I = C, z = H, K = Y, t.width = Math.floor(C * Y), t.height = Math.floor(H * Y), this.setViewport(0, 0, C, H);
+        }, this.getCurrentViewport = function(C) {
+            return C.copy(x);
+        }, this.getViewport = function(C) {
+            return C.copy(Q);
+        }, this.setViewport = function(C, H, Y, j) {
+            C.isVector4 ? Q.set(C.x, C.y, C.z, C.w) : Q.set(C, H, Y, j), Me.viewport(x.copy(Q).multiplyScalar(K).round());
+        }, this.getScissor = function(C) {
+            return C.copy(te);
+        }, this.setScissor = function(C, H, Y, j) {
+            C.isVector4 ? te.set(C.x, C.y, C.z, C.w) : te.set(C, H, Y, j), Me.scissor(A.copy(te).multiplyScalar(K).round());
         }, this.getScissorTest = function() {
-            return ue;
-        }, this.setScissorTest = function(y) {
-            ye.setScissorTest(ue = y);
-        }, this.setOpaqueSort = function(y) {
-            j = y;
-        }, this.setTransparentSort = function(y) {
-            q = y;
-        }, this.getClearColor = function(y) {
-            return y.copy(Re.getClearColor());
+            return fe;
+        }, this.setScissorTest = function(C) {
+            Me.setScissorTest(fe = C);
+        }, this.setOpaqueSort = function(C) {
+            G = C;
+        }, this.setTransparentSort = function(C) {
+            q = C;
+        }, this.getClearColor = function(C) {
+            return C.copy(De.getClearColor());
         }, this.setClearColor = function() {
-            Re.setClearColor.apply(Re, arguments);
+            De.setClearColor.apply(De, arguments);
         }, this.getClearAlpha = function() {
-            return Re.getClearAlpha();
+            return De.getClearAlpha();
         }, this.setClearAlpha = function() {
-            Re.setClearAlpha.apply(Re, arguments);
-        }, this.clear = function(y = !0, U = !0, G = !0) {
-            let V = 0;
-            if (y) {
-                let k = !1;
-                if (b !== null) {
-                    const de = b.texture.format;
-                    k = de === po || de === Hl || de === ho;
-                }
-                if (k) {
-                    const de = b.texture.type,
-                        Se = de === Gn || de === nn || de === fo || de === si || de === kl || de === Gl,
-                        Ee = Re.getClearColor(),
-                        Ce = Re.getClearAlpha(),
-                        Xe = Ee.r,
-                        Fe = Ee.g,
-                        ze = Ee.b;
-                    Se ? (p[0] = Xe, p[1] = Fe, p[2] = ze, p[3] = Ce, F.clearBufferuiv(F.COLOR, 0, p)) : (g[0] = Xe, g[1] = Fe, g[2] = ze, g[3] = Ce, F.clearBufferiv(F.COLOR, 0, g));
+            De.setClearAlpha.apply(De, arguments);
+        }, this.clear = function(C = !0, H = !0, Y = !0) {
+            let j = 0;
+            if (C) {
+                let X = !1;
+                if (T !== null) {
+                    const ye = T.texture.format;
+                    X = ye === Za || ye === Bc || ye === Ka;
+                }
+                if (X) {
+                    const ye = T.texture.type,
+                        Ce = ye === In || ye === fn || ye === ja || ye === vi || ye === Ic || ye === Uc,
+                        Fe = De.getClearColor(),
+                        ke = De.getClearAlpha(),
+                        Ze = Fe.r,
+                        He = Fe.g,
+                        We = Fe.b;
+                    Ce ? (h[0] = Ze, h[1] = He, h[2] = We, h[3] = ke, O.clearBufferuiv(O.COLOR, 0, h)) : (g[0] = Ze, g[1] = He, g[2] = We, g[3] = ke, O.clearBufferiv(O.COLOR, 0, g));
                 } else
-                    V |= F.COLOR_BUFFER_BIT;
+                    j |= O.COLOR_BUFFER_BIT;
             }
-            U && (V |= F.DEPTH_BUFFER_BIT), G && (V |= F.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), F.clear(V);
+            H && (j |= O.DEPTH_BUFFER_BIT), Y && (j |= O.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), O.clear(j);
         }, this.clearColor = function() {
             this.clear(!0, !1, !1);
         }, this.clearDepth = function() {
             this.clear(!1, !0, !1);
         }, this.clearStencil = function() {
             this.clear(!1, !1, !0);
         }, this.dispose = function() {
-            t.removeEventListener("webglcontextlost", $e, !1), t.removeEventListener("webglcontextrestored", D, !1), t.removeEventListener("webglcontextcreationerror", re, !1), Le.dispose(), Ae.dispose(), Ie.dispose(), Je.dispose(), w.dispose(), Q.dispose(), he.dispose(), _e.dispose(), te.dispose(), Ue.dispose(), Ue.removeEventListener("sessionstart", Nt), Ue.removeEventListener("sessionend", tt), pe && (pe.dispose(), pe = null), At.stop();
+            t.removeEventListener("webglcontextlost", nt, !1), t.removeEventListener("webglcontextrestored", F, !1), t.removeEventListener("webglcontextcreationerror", ce, !1), Be.dispose(), Pe.dispose(), Oe.dispose(), Ke.dispose(), w.dispose(), Z.dispose(), _e.dispose(), ve.dispose(), re.dispose(), Ne.dispose(), Ne.removeEventListener("sessionstart", jt), Ne.removeEventListener("sessionend", st), se && (se.dispose(), se = null), Ft.stop();
         };
 
-        function $e(y) {
-            y.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = !0;
+        function nt(C) {
+            C.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), y = !0;
         }
 
-        function D() {
-            console.log("THREE.WebGLRenderer: Context Restored."), A = !1;
-            const y = qe.autoReset,
-                U = ce.enabled,
-                G = ce.autoUpdate,
-                V = ce.needsUpdate,
-                k = ce.type;
-            De(), qe.autoReset = y, ce.enabled = U, ce.autoUpdate = G, ce.needsUpdate = V, ce.type = k;
+        function F() {
+            console.log("THREE.WebGLRenderer: Context Restored."), y = !1;
+            const C = ze.autoReset,
+                H = de.enabled,
+                Y = de.autoUpdate,
+                j = de.needsUpdate,
+                X = de.type;
+            Le(), ze.autoReset = C, de.enabled = H, de.autoUpdate = Y, de.needsUpdate = j, de.type = X;
         }
 
-        function re(y) {
-            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", y.statusMessage);
+        function ce(C) {
+            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", C.statusMessage);
         }
 
-        function z(y) {
-            const U = y.target;
-            U.removeEventListener("dispose", z), ie(U);
+        function W(C) {
+            const H = C.target;
+            H.removeEventListener("dispose", W), ae(H);
         }
 
-        function ie(y) {
-            ae(y), Ie.remove(y);
+        function ae(C) {
+            pe(C), Oe.remove(C);
         }
 
-        function ae(y) {
-            const U = Ie.get(y).programs;
-            U !== void 0 && (U.forEach(function(G) {
-                te.releaseProgram(G);
-            }), y.isShaderMaterial && te.releaseShaderCache(y));
-        }
-        this.renderBufferDirect = function(y, U, G, V, k, de) {
-            U === null && (U = Ke);
-            const Se = k.isMesh && k.matrixWorld.determinant() < 0,
-                Ee = Mc(y, U, G, V, k);
-            ye.setMaterial(V, Se);
-            let Ce = G.index,
-                Xe = 1;
-            if (V.wireframe === !0) {
-                if (Ce = X.getWireframeAttribute(G), Ce === void 0)
+        function pe(C) {
+            const H = Oe.get(C).programs;
+            H !== void 0 && (H.forEach(function(Y) {
+                re.releaseProgram(Y);
+            }), C.isShaderMaterial && re.releaseShaderCache(C));
+        }
+        this.renderBufferDirect = function(C, H, Y, j, X, ye) {
+            H === null && (H = Qe);
+            const Ce = X.isMesh && X.matrixWorld.determinant() < 0,
+                Fe = mu(C, H, Y, j, X);
+            Me.setMaterial(j, Ce);
+            let ke = Y.index,
+                Ze = 1;
+            if (j.wireframe === !0) {
+                if (ke = k.getWireframeAttribute(Y), ke === void 0)
                     return;
-                Xe = 2;
+                Ze = 2;
             }
-            const Fe = G.drawRange,
-                ze = G.attributes.position;
-            let ot = Fe.start * Xe,
-                Lt = (Fe.start + Fe.count) * Xe;
-            de !== null && (ot = Math.max(ot, de.start * Xe), Lt = Math.min(Lt, (de.start + de.count) * Xe)), Ce !== null ? (ot = Math.max(ot, 0), Lt = Math.min(Lt, Ce.count)) : ze != null && (ot = Math.max(ot, 0), Lt = Math.min(Lt, ze.count));
-            const dt = Lt - ot;
-            if (dt < 0 || dt === 1 / 0)
+            const He = Y.drawRange,
+                We = Y.attributes.position;
+            let ht = He.start * Ze,
+                Ht = (He.start + He.count) * Ze;
+            ye !== null && (ht = Math.max(ht, ye.start * Ze), Ht = Math.min(Ht, (ye.start + ye.count) * Ze)), ke !== null ? (ht = Math.max(ht, 0), Ht = Math.min(Ht, ke.count)) : We != null && (ht = Math.max(ht, 0), Ht = Math.min(Ht, We.count));
+            const yt = Ht - ht;
+            if (yt < 0 || yt === 1 / 0)
                 return;
-            he.setup(k, V, Ee, G, Ce);
-            let dn, rt = le;
-            if (Ce !== null && (dn = x.get(Ce), rt = ve, rt.setIndex(dn)), k.isMesh)
-                V.wireframe === !0 ? (ye.setLineWidth(V.wireframeLinewidth * we()), rt.setMode(F.LINES)) : rt.setMode(F.TRIANGLES);
-            else if (k.isLine) {
-                let Ve = V.linewidth;
-                Ve === void 0 && (Ve = 1), ye.setLineWidth(Ve * we()), k.isLineSegments ? rt.setMode(F.LINES) : k.isLineLoop ? rt.setMode(F.LINE_LOOP) : rt.setMode(F.LINE_STRIP);
+            _e.setup(X, j, Fe, Y, ke);
+            let Mn, lt = ue;
+            if (ke !== null && (Mn = M.get(ke), lt = Se, lt.setIndex(Mn)), X.isMesh)
+                j.wireframe === !0 ? (Me.setLineWidth(j.wireframeLinewidth * Re()), lt.setMode(O.LINES)) : lt.setMode(O.TRIANGLES);
+            else if (X.isLine) {
+                let Ye = j.linewidth;
+                Ye === void 0 && (Ye = 1), Me.setLineWidth(Ye * Re()), X.isLineSegments ? lt.setMode(O.LINES) : X.isLineLoop ? lt.setMode(O.LINE_LOOP) : lt.setMode(O.LINE_STRIP);
             } else
-                k.isPoints ? rt.setMode(F.POINTS) : k.isSprite && rt.setMode(F.TRIANGLES);
-            if (k.isBatchedMesh)
-                rt.renderMultiDraw(k._multiDrawStarts, k._multiDrawCounts, k._multiDrawCount);
-            else if (k.isInstancedMesh)
-                rt.renderInstances(ot, dt, k.count);
-            else if (G.isInstancedBufferGeometry) {
-                const Ve = G._maxInstanceCount !== void 0 ? G._maxInstanceCount : 1 / 0,
-                    cs = Math.min(G.instanceCount, Ve);
-                rt.renderInstances(ot, dt, cs);
+                X.isPoints ? lt.setMode(O.POINTS) : X.isSprite && lt.setMode(O.TRIANGLES);
+            if (X.isBatchedMesh)
+                lt.renderMultiDraw(X._multiDrawStarts, X._multiDrawCounts, X._multiDrawCount);
+            else if (X.isInstancedMesh)
+                lt.renderInstances(ht, yt, X.count);
+            else if (Y.isInstancedBufferGeometry) {
+                const Ye = Y._maxInstanceCount !== void 0 ? Y._maxInstanceCount : 1 / 0,
+                    Nr = Math.min(Y.instanceCount, Ye);
+                lt.renderInstances(ht, yt, Nr);
             } else
-                rt.render(ot, dt);
+                lt.render(ht, yt);
         };
 
-        function Oe(y, U, G) {
-            y.transparent === !0 && y.side === en && y.forceSinglePass === !1 ? (y.side = Pt, y.needsUpdate = !0, pr(y, U, G), y.side = hn, y.needsUpdate = !0, pr(y, U, G), y.side = en) : pr(y, U, G);
+        function Ve(C, H, Y) {
+            C.transparent === !0 && C.side === un && C.forceSinglePass === !1 ? (C.side = zt, C.needsUpdate = !0, Os(C, H, Y), C.side = yn, C.needsUpdate = !0, Os(C, H, Y), C.side = un) : Os(C, H, Y);
         }
-        this.compile = function(y, U, G = null) {
-            G === null && (G = y), m = Ae.get(G), m.init(), M.push(m), G.traverseVisible(function(k) {
-                k.isLight && k.layers.test(U.layers) && (m.pushLight(k), k.castShadow && m.pushShadow(k));
-            }), y !== G && y.traverseVisible(function(k) {
-                k.isLight && k.layers.test(U.layers) && (m.pushLight(k), k.castShadow && m.pushShadow(k));
-            }), m.setupLights(_._useLegacyLights);
-            const V = /* @__PURE__ */ new Set();
-            return y.traverse(function(k) {
-                const de = k.material;
-                if (de)
-                    if (Array.isArray(de))
-                        for (let Se = 0; Se < de.length; Se++) {
-                            const Ee = de[Se];
-                            Oe(Ee, G, k), V.add(Ee);
+        this.compile = function(C, H, Y = null) {
+            Y === null && (Y = C), m = Pe.get(Y), m.init(), v.push(m), Y.traverseVisible(function(X) {
+                X.isLight && X.layers.test(H.layers) && (m.pushLight(X), X.castShadow && m.pushShadow(X));
+            }), C !== Y && C.traverseVisible(function(X) {
+                X.isLight && X.layers.test(H.layers) && (m.pushLight(X), X.castShadow && m.pushShadow(X));
+            }), m.setupLights(S._useLegacyLights);
+            const j = /* @__PURE__ */ new Set();
+            return C.traverse(function(X) {
+                const ye = X.material;
+                if (ye)
+                    if (Array.isArray(ye))
+                        for (let Ce = 0; Ce < ye.length; Ce++) {
+                            const Fe = ye[Ce];
+                            Ve(Fe, Y, X), j.add(Fe);
                         }
                 else
-                    Oe(de, G, k), V.add(de);
-            }), M.pop(), m = null, V;
-        }, this.compileAsync = function(y, U, G = null) {
-            const V = this.compile(y, U, G);
-            return new Promise((k) => {
-                function de() {
-                    if (V.forEach(function(Se) {
-                            Ie.get(Se).currentProgram.isReady() && V.delete(Se);
-                        }), V.size === 0) {
-                        k(y);
+                    Ve(ye, Y, X), j.add(ye);
+            }), v.pop(), m = null, j;
+        }, this.compileAsync = function(C, H, Y = null) {
+            const j = this.compile(C, H, Y);
+            return new Promise((X) => {
+                function ye() {
+                    if (j.forEach(function(Ce) {
+                            Oe.get(Ce).currentProgram.isReady() && j.delete(Ce);
+                        }), j.size === 0) {
+                        X(C);
                         return;
                     }
-                    setTimeout(de, 10);
+                    setTimeout(ye, 10);
                 }
-                Me.get("KHR_parallel_shader_compile") !== null ? de() : setTimeout(de, 10);
+                Te.get("KHR_parallel_shader_compile") !== null ? ye() : setTimeout(ye, 10);
             });
         };
-        let et = null;
+        let it = null;
 
-        function _t(y) {
-            et && et(y);
+        function At(C) {
+            it && it(C);
         }
 
-        function Nt() {
-            At.stop();
+        function jt() {
+            Ft.stop();
         }
 
-        function tt() {
-            At.start();
+        function st() {
+            Ft.start();
         }
-        const At = new sc();
-        At.setAnimationLoop(_t), typeof self < "u" && At.setContext(self), this.setAnimationLoop = function(y) {
-            et = y, Ue.setAnimationLoop(y), y === null ? At.stop() : At.start();
-        }, Ue.addEventListener("sessionstart", Nt), Ue.addEventListener("sessionend", tt), this.render = function(y, U) {
-            if (U !== void 0 && U.isCamera !== !0) {
+        const Ft = new $c();
+        Ft.setAnimationLoop(At), typeof self < "u" && Ft.setContext(self), this.setAnimationLoop = function(C) {
+            it = C, Ne.setAnimationLoop(C), C === null ? Ft.stop() : Ft.start();
+        }, Ne.addEventListener("sessionstart", jt), Ne.addEventListener("sessionend", st), this.render = function(C, H) {
+            if (H !== void 0 && H.isCamera !== !0) {
                 console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                 return;
             }
-            if (A === !0)
+            if (y === !0)
                 return;
-            y.matrixWorldAutoUpdate === !0 && y.updateMatrixWorld(), U.parent === null && U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(), Ue.enabled === !0 && Ue.isPresenting === !0 && (Ue.cameraAutoUpdate === !0 && Ue.updateCamera(U), U = Ue.getCamera()), y.isScene === !0 && y.onBeforeRender(_, y, U, b), m = Ae.get(y, M.length), m.init(), M.push(m), Te.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse), Z.setFromProjectionMatrix(Te), ee = this.localClippingEnabled, H = se.init(this.clippingPlanes, ee), v = Le.get(y, d.length), v.init(), d.push(v), rn(y, U, 0, _.sortObjects), v.finish(), _.sortObjects === !0 && v.sort(j, q), this.info.render.frame++, H === !0 && se.beginShadows();
-            const G = m.state.shadowsArray;
-            if (ce.render(G, y, U), H === !0 && se.endShadows(), this.info.autoReset === !0 && this.info.reset(), (Ue.enabled === !1 || Ue.isPresenting === !1 || Ue.hasDepthSensing() === !1) && Re.render(v, y), m.setupLights(_._useLegacyLights), U.isArrayCamera) {
-                const V = U.cameras;
-                for (let k = 0, de = V.length; k < de; k++) {
-                    const Se = V[k];
-                    Ao(v, y, Se, Se.viewport);
+            C.matrixWorldAutoUpdate === !0 && C.updateMatrixWorld(), H.parent === null && H.matrixWorldAutoUpdate === !0 && H.updateMatrixWorld(), Ne.enabled === !0 && Ne.isPresenting === !0 && (Ne.cameraAutoUpdate === !0 && Ne.updateCamera(H), H = Ne.getCamera()), C.isScene === !0 && C.onBeforeRender(S, C, H, T), m = Pe.get(C, v.length), m.init(), v.push(m), Ae.multiplyMatrices(H.projectionMatrix, H.matrixWorldInverse), ne.setFromProjectionMatrix(Ae), J = this.localClippingEnabled, V = oe.init(this.clippingPlanes, J), _ = Be.get(C, p.length), _.init(), p.push(_), hn(C, H, 0, S.sortObjects), _.finish(), S.sortObjects === !0 && _.sort(G, q), this.info.render.frame++, V === !0 && oe.beginShadows();
+            const Y = m.state.shadowsArray;
+            if (de.render(Y, C, H), V === !0 && oe.endShadows(), this.info.autoReset === !0 && this.info.reset(), (Ne.enabled === !1 || Ne.isPresenting === !1 || Ne.hasDepthSensing() === !1) && De.render(_, C), m.setupLights(S._useLegacyLights), H.isArrayCamera) {
+                const j = H.cameras;
+                for (let X = 0, ye = j.length; X < ye; X++) {
+                    const Ce = j[X];
+                    uo(_, C, Ce, Ce.viewport);
                 }
             } else
-                Ao(v, y, U);
-            b !== null && (Be.updateMultisampleRenderTarget(b), Be.updateRenderTargetMipmap(b)), y.isScene === !0 && y.onAfterRender(_, y, U), he.resetDefaultState(), I = -1, W = null, M.pop(), M.length > 0 ? m = M[M.length - 1] : m = null, d.pop(), d.length > 0 ? v = d[d.length - 1] : v = null;
+                uo(_, C, H);
+            T !== null && (we.updateMultisampleRenderTarget(T), we.updateRenderTargetMipmap(T)), C.isScene === !0 && C.onAfterRender(S, C, H), _e.resetDefaultState(), L = -1, B = null, v.pop(), v.length > 0 ? m = v[v.length - 1] : m = null, p.pop(), p.length > 0 ? _ = p[p.length - 1] : _ = null;
         };
 
-        function rn(y, U, G, V) {
-            if (y.visible === !1)
+        function hn(C, H, Y, j) {
+            if (C.visible === !1)
                 return;
-            if (y.layers.test(U.layers)) {
-                if (y.isGroup)
-                    G = y.renderOrder;
-                else if (y.isLOD)
-                    y.autoUpdate === !0 && y.update(U);
-                else if (y.isLight)
-                    m.pushLight(y), y.castShadow && m.pushShadow(y);
-                else if (y.isSprite) {
-                    if (!y.frustumCulled || Z.intersectsSprite(y)) {
-                        V && ge.setFromMatrixPosition(y.matrixWorld).applyMatrix4(Te);
-                        const Se = Q.update(y),
-                            Ee = y.material;
-                        Ee.visible && v.push(y, Se, Ee, G, ge.z, null);
+            if (C.layers.test(H.layers)) {
+                if (C.isGroup)
+                    Y = C.renderOrder;
+                else if (C.isLOD)
+                    C.autoUpdate === !0 && C.update(H);
+                else if (C.isLight)
+                    m.pushLight(C), C.castShadow && m.pushShadow(C);
+                else if (C.isSprite) {
+                    if (!C.frustumCulled || ne.intersectsSprite(C)) {
+                        j && ge.setFromMatrixPosition(C.matrixWorld).applyMatrix4(Ae);
+                        const Ce = Z.update(C),
+                            Fe = C.material;
+                        Fe.visible && _.push(C, Ce, Fe, Y, ge.z, null);
                     }
-                } else if ((y.isMesh || y.isLine || y.isPoints) && (!y.frustumCulled || Z.intersectsObject(y))) {
-                    const Se = Q.update(y),
-                        Ee = y.material;
-                    if (V && (y.boundingSphere !== void 0 ? (y.boundingSphere === null && y.computeBoundingSphere(), ge.copy(y.boundingSphere.center)) : (Se.boundingSphere === null && Se.computeBoundingSphere(), ge.copy(Se.boundingSphere.center)), ge.applyMatrix4(y.matrixWorld).applyMatrix4(Te)), Array.isArray(Ee)) {
-                        const Ce = Se.groups;
-                        for (let Xe = 0, Fe = Ce.length; Xe < Fe; Xe++) {
-                            const ze = Ce[Xe],
-                                ot = Ee[ze.materialIndex];
-                            ot && ot.visible && v.push(y, Se, ot, G, ge.z, ze);
+                } else if ((C.isMesh || C.isLine || C.isPoints) && (!C.frustumCulled || ne.intersectsObject(C))) {
+                    const Ce = Z.update(C),
+                        Fe = C.material;
+                    if (j && (C.boundingSphere !== void 0 ? (C.boundingSphere === null && C.computeBoundingSphere(), ge.copy(C.boundingSphere.center)) : (Ce.boundingSphere === null && Ce.computeBoundingSphere(), ge.copy(Ce.boundingSphere.center)), ge.applyMatrix4(C.matrixWorld).applyMatrix4(Ae)), Array.isArray(Fe)) {
+                        const ke = Ce.groups;
+                        for (let Ze = 0, He = ke.length; Ze < He; Ze++) {
+                            const We = ke[Ze],
+                                ht = Fe[We.materialIndex];
+                            ht && ht.visible && _.push(C, Ce, ht, Y, ge.z, We);
                         }
                     } else
-                        Ee.visible && v.push(y, Se, Ee, G, ge.z, null);
+                        Fe.visible && _.push(C, Ce, Fe, Y, ge.z, null);
                 }
             }
-            const de = y.children;
-            for (let Se = 0, Ee = de.length; Se < Ee; Se++)
-                rn(de[Se], U, G, V);
+            const ye = C.children;
+            for (let Ce = 0, Fe = ye.length; Ce < Fe; Ce++)
+                hn(ye[Ce], H, Y, j);
         }
 
-        function Ao(y, U, G, V) {
-            const k = y.opaque,
-                de = y.transmissive,
-                Se = y.transparent;
-            m.setupLightsView(G), H === !0 && se.setGlobalState(_.clippingPlanes, G), de.length > 0 && Sc(k, de, U, G), V && ye.viewport(S.copy(V)), k.length > 0 && dr(k, U, G), de.length > 0 && dr(de, U, G), Se.length > 0 && dr(Se, U, G), ye.buffers.depth.setTest(!0), ye.buffers.depth.setMask(!0), ye.buffers.color.setMask(!0), ye.setPolygonOffset(!1);
+        function uo(C, H, Y, j) {
+            const X = C.opaque,
+                ye = C.transmissive,
+                Ce = C.transparent;
+            m.setupLightsView(Y), V === !0 && oe.setGlobalState(S.clippingPlanes, Y), ye.length > 0 && pu(X, ye, H, Y), j && Me.viewport(x.copy(j)), X.length > 0 && Bs(X, H, Y), ye.length > 0 && Bs(ye, H, Y), Ce.length > 0 && Bs(Ce, H, Y), Me.buffers.depth.setTest(!0), Me.buffers.depth.setMask(!0), Me.buffers.color.setMask(!0), Me.setPolygonOffset(!1);
         }
 
-        function Sc(y, U, G, V) {
-            if ((G.isScene === !0 ? G.overrideMaterial : null) !== null)
+        function pu(C, H, Y, j) {
+            if ((Y.isScene === !0 ? Y.overrideMaterial : null) !== null)
                 return;
-            const de = Ne.isWebGL2;
-            pe === null && (pe = new Vn(1, 1, {
+            const ye = Ie.isWebGL2;
+            se === null && (se = new ti(1, 1, {
                 generateMipmaps: !0,
-                type: Me.has("EXT_color_buffer_half_float") ? Gi : Gn,
-                minFilter: ni,
-                samples: de ? 4 : 0
-            })), _.getDrawingBufferSize(xe), de ? pe.setSize(xe.x, xe.y) : pe.setSize(Zr(xe.x), Zr(xe.y));
-            const Se = _.getRenderTarget();
-            _.setRenderTarget(pe), _.getClearColor(K), L = _.getClearAlpha(), L < 1 && _.setClearColor(16777215, 0.5), _.clear();
-            const Ee = _.toneMapping;
-            _.toneMapping = kn, dr(y, G, V), Be.updateMultisampleRenderTarget(pe), Be.updateRenderTargetMipmap(pe);
-            let Ce = !1;
-            for (let Xe = 0, Fe = U.length; Xe < Fe; Xe++) {
-                const ze = U[Xe],
-                    ot = ze.object,
-                    Lt = ze.geometry,
-                    dt = ze.material,
-                    dn = ze.group;
-                if (dt.side === en && ot.layers.test(V.layers)) {
-                    const rt = dt.side;
-                    dt.side = Pt, dt.needsUpdate = !0, Eo(ot, G, V, Lt, dt, dn), dt.side = rt, dt.needsUpdate = !0, Ce = !0;
-                }
-            }
-            Ce === !0 && (Be.updateMultisampleRenderTarget(pe), Be.updateRenderTargetMipmap(pe)), _.setRenderTarget(Se), _.setClearColor(K, L), _.toneMapping = Ee;
-        }
-
-        function dr(y, U, G) {
-            const V = U.isScene === !0 ? U.overrideMaterial : null;
-            for (let k = 0, de = y.length; k < de; k++) {
-                const Se = y[k],
-                    Ee = Se.object,
-                    Ce = Se.geometry,
-                    Xe = V === null ? Se.material : V,
-                    Fe = Se.group;
-                Ee.layers.test(G.layers) && Eo(Ee, U, G, Ce, Xe, Fe);
+                type: Te.has("EXT_color_buffer_half_float") ? xi : In,
+                minFilter: mi,
+                samples: ye ? 4 : 0
+            })), S.getDrawingBufferSize(xe), ye ? se.setSize(xe.x, xe.y) : se.setSize(Ar(xe.x), Ar(xe.y));
+            const Ce = S.getRenderTarget();
+            S.setRenderTarget(se), S.getClearColor(N), P = S.getClearAlpha(), P < 1 && S.setClearColor(16777215, 0.5), S.clear();
+            const Fe = S.toneMapping;
+            S.toneMapping = $n, Bs(C, Y, j), we.updateMultisampleRenderTarget(se), we.updateRenderTargetMipmap(se);
+            let ke = !1;
+            for (let Ze = 0, He = H.length; Ze < He; Ze++) {
+                const We = H[Ze],
+                    ht = We.object,
+                    Ht = We.geometry,
+                    yt = We.material,
+                    Mn = We.group;
+                if (yt.side === un && ht.layers.test(j.layers)) {
+                    const lt = yt.side;
+                    yt.side = zt, yt.needsUpdate = !0, fo(ht, Y, j, Ht, yt, Mn), yt.side = lt, yt.needsUpdate = !0, ke = !0;
+                }
+            }
+            ke === !0 && (we.updateMultisampleRenderTarget(se), we.updateRenderTargetMipmap(se)), S.setRenderTarget(Ce), S.setClearColor(N, P), S.toneMapping = Fe;
+        }
+
+        function Bs(C, H, Y) {
+            const j = H.isScene === !0 ? H.overrideMaterial : null;
+            for (let X = 0, ye = C.length; X < ye; X++) {
+                const Ce = C[X],
+                    Fe = Ce.object,
+                    ke = Ce.geometry,
+                    Ze = j === null ? Ce.material : j,
+                    He = Ce.group;
+                Fe.layers.test(Y.layers) && fo(Fe, H, Y, ke, Ze, He);
             }
         }
 
-        function Eo(y, U, G, V, k, de) {
-            y.onBeforeRender(_, U, G, V, k, de), y.modelViewMatrix.multiplyMatrices(G.matrixWorldInverse, y.matrixWorld), y.normalMatrix.getNormalMatrix(y.modelViewMatrix), k.onBeforeRender(_, U, G, V, y, de), k.transparent === !0 && k.side === en && k.forceSinglePass === !1 ? (k.side = Pt, k.needsUpdate = !0, _.renderBufferDirect(G, U, V, k, y, de), k.side = hn, k.needsUpdate = !0, _.renderBufferDirect(G, U, V, k, y, de), k.side = en) : _.renderBufferDirect(G, U, V, k, y, de), y.onAfterRender(_, U, G, V, k, de);
-        }
-
-        function pr(y, U, G) {
-            U.isScene !== !0 && (U = Ke);
-            const V = Ie.get(y),
-                k = m.state.lights,
-                de = m.state.shadowsArray,
-                Se = k.state.version,
-                Ee = te.getParameters(y, k.state, de, U, G),
-                Ce = te.getProgramCacheKey(Ee);
-            let Xe = V.programs;
-            V.environment = y.isMeshStandardMaterial ? U.environment : null, V.fog = U.fog, V.envMap = (y.isMeshStandardMaterial ? w : Je).get(y.envMap || V.environment), V.envMapRotation = V.environment !== null && y.envMap === null ? U.environmentRotation : y.envMapRotation, Xe === void 0 && (y.addEventListener("dispose", z), Xe = /* @__PURE__ */ new Map(), V.programs = Xe);
-            let Fe = Xe.get(Ce);
-            if (Fe !== void 0) {
-                if (V.currentProgram === Fe && V.lightsStateVersion === Se)
-                    return To(y, Ee), Fe;
+        function fo(C, H, Y, j, X, ye) {
+            C.onBeforeRender(S, H, Y, j, X, ye), C.modelViewMatrix.multiplyMatrices(Y.matrixWorldInverse, C.matrixWorld), C.normalMatrix.getNormalMatrix(C.modelViewMatrix), X.onBeforeRender(S, H, Y, j, C, ye), X.transparent === !0 && X.side === un && X.forceSinglePass === !1 ? (X.side = zt, X.needsUpdate = !0, S.renderBufferDirect(Y, H, j, X, C, ye), X.side = yn, X.needsUpdate = !0, S.renderBufferDirect(Y, H, j, X, C, ye), X.side = un) : S.renderBufferDirect(Y, H, j, X, C, ye), C.onAfterRender(S, H, Y, j, X, ye);
+        }
+
+        function Os(C, H, Y) {
+            H.isScene !== !0 && (H = Qe);
+            const j = Oe.get(C),
+                X = m.state.lights,
+                ye = m.state.shadowsArray,
+                Ce = X.state.version,
+                Fe = re.getParameters(C, X.state, ye, H, Y),
+                ke = re.getProgramCacheKey(Fe);
+            let Ze = j.programs;
+            j.environment = C.isMeshStandardMaterial ? H.environment : null, j.fog = H.fog, j.envMap = (C.isMeshStandardMaterial ? w : Ke).get(C.envMap || j.environment), j.envMapRotation = j.environment !== null && C.envMap === null ? H.environmentRotation : C.envMapRotation, Ze === void 0 && (C.addEventListener("dispose", W), Ze = /* @__PURE__ */ new Map(), j.programs = Ze);
+            let He = Ze.get(ke);
+            if (He !== void 0) {
+                if (j.currentProgram === He && j.lightsStateVersion === Ce)
+                    return po(C, Fe), He;
             } else
-                Ee.uniforms = te.getUniforms(y), y.onBuild(G, Ee, _), y.onBeforeCompile(Ee, _), Fe = te.acquireProgram(Ee, Ce), Xe.set(Ce, Fe), V.uniforms = Ee.uniforms;
-            const ze = V.uniforms;
-            return (!y.isShaderMaterial && !y.isRawShaderMaterial || y.clipping === !0) && (ze.clippingPlanes = se.uniform), To(y, Ee), V.needsLights = Ac(y), V.lightsStateVersion = Se, V.needsLights && (ze.ambientLightColor.value = k.state.ambient, ze.lightProbe.value = k.state.probe, ze.directionalLights.value = k.state.directional, ze.directionalLightShadows.value = k.state.directionalShadow, ze.spotLights.value = k.state.spot, ze.spotLightShadows.value = k.state.spotShadow, ze.rectAreaLights.value = k.state.rectArea, ze.ltc_1.value = k.state.rectAreaLTC1, ze.ltc_2.value = k.state.rectAreaLTC2, ze.pointLights.value = k.state.point, ze.pointLightShadows.value = k.state.pointShadow, ze.hemisphereLights.value = k.state.hemi, ze.directionalShadowMap.value = k.state.directionalShadowMap, ze.directionalShadowMatrix.value = k.state.directionalShadowMatrix, ze.spotShadowMap.value = k.state.spotShadowMap, ze.spotLightMatrix.value = k.state.spotLightMatrix, ze.spotLightMap.value = k.state.spotLightMap, ze.pointShadowMap.value = k.state.pointShadowMap, ze.pointShadowMatrix.value = k.state.pointShadowMatrix), V.currentProgram = Fe, V.uniformsList = null, Fe;
-        }
-
-        function bo(y) {
-            if (y.uniformsList === null) {
-                const U = y.currentProgram.getUniforms();
-                y.uniformsList = Vr.seqWithValue(U.seq, y.uniforms);
-            }
-            return y.uniformsList;
-        }
-
-        function To(y, U) {
-            const G = Ie.get(y);
-            G.outputColorSpace = U.outputColorSpace, G.batching = U.batching, G.instancing = U.instancing, G.instancingColor = U.instancingColor, G.instancingMorph = U.instancingMorph, G.skinning = U.skinning, G.morphTargets = U.morphTargets, G.morphNormals = U.morphNormals, G.morphColors = U.morphColors, G.morphTargetsCount = U.morphTargetsCount, G.numClippingPlanes = U.numClippingPlanes, G.numIntersection = U.numClipIntersection, G.vertexAlphas = U.vertexAlphas, G.vertexTangents = U.vertexTangents, G.toneMapping = U.toneMapping;
-        }
-
-        function Mc(y, U, G, V, k) {
-            U.isScene !== !0 && (U = Ke), Be.resetTextureUnits();
-            const de = U.fog,
-                Se = V.isMeshStandardMaterial ? U.environment : null,
-                Ee = b === null ? _.outputColorSpace : b.isXRRenderTarget === !0 ? b.texture.colorSpace : Wn,
-                Ce = (V.isMeshStandardMaterial ? w : Je).get(V.envMap || Se),
-                Xe = V.vertexColors === !0 && !!G.attributes.color && G.attributes.color.itemSize === 4,
-                Fe = !!G.attributes.tangent && (!!V.normalMap || V.anisotropy > 0),
-                ze = !!G.morphAttributes.position,
-                ot = !!G.morphAttributes.normal,
-                Lt = !!G.morphAttributes.color;
-            let dt = kn;
-            V.toneMapped && (b === null || b.isXRRenderTarget === !0) && (dt = _.toneMapping);
-            const dn = G.morphAttributes.position || G.morphAttributes.normal || G.morphAttributes.color,
-                rt = dn !== void 0 ? dn.length : 0,
-                Ve = Ie.get(V),
-                cs = m.state.lights;
-            if (H === !0 && (ee === !0 || y !== W)) {
-                const Bt = y === W && V.id === I;
-                se.setState(V, y, Bt);
-            }
-            let it = !1;
-            V.version === Ve.__version ? (Ve.needsLights && Ve.lightsStateVersion !== cs.state.version || Ve.outputColorSpace !== Ee || k.isBatchedMesh && Ve.batching === !1 || !k.isBatchedMesh && Ve.batching === !0 || k.isInstancedMesh && Ve.instancing === !1 || !k.isInstancedMesh && Ve.instancing === !0 || k.isSkinnedMesh && Ve.skinning === !1 || !k.isSkinnedMesh && Ve.skinning === !0 || k.isInstancedMesh && Ve.instancingColor === !0 && k.instanceColor === null || k.isInstancedMesh && Ve.instancingColor === !1 && k.instanceColor !== null || k.isInstancedMesh && Ve.instancingMorph === !0 && k.morphTexture === null || k.isInstancedMesh && Ve.instancingMorph === !1 && k.morphTexture !== null || Ve.envMap !== Ce || V.fog === !0 && Ve.fog !== de || Ve.numClippingPlanes !== void 0 && (Ve.numClippingPlanes !== se.numPlanes || Ve.numIntersection !== se.numIntersection) || Ve.vertexAlphas !== Xe || Ve.vertexTangents !== Fe || Ve.morphTargets !== ze || Ve.morphNormals !== ot || Ve.morphColors !== Lt || Ve.toneMapping !== dt || Ne.isWebGL2 === !0 && Ve.morphTargetsCount !== rt) && (it = !0) : (it = !0, Ve.__version = V.version);
-            let Xn = Ve.currentProgram;
-            it === !0 && (Xn = pr(V, U, k));
-            let wo = !1,
-                $i = !1,
-                us = !1;
-            const St = Xn.getUniforms(),
-                qn = Ve.uniforms;
-            if (ye.useProgram(Xn.program) && (wo = !0, $i = !0, us = !0), V.id !== I && (I = V.id, $i = !0), wo || W !== y) {
-                St.setValue(F, "projectionMatrix", y.projectionMatrix), St.setValue(F, "viewMatrix", y.matrixWorldInverse);
-                const Bt = St.map.cameraPosition;
-                Bt !== void 0 && Bt.setValue(F, ge.setFromMatrixPosition(y.matrixWorld)), Ne.logarithmicDepthBuffer && St.setValue(
-                    F,
+                Fe.uniforms = re.getUniforms(C), C.onBuild(Y, Fe, S), C.onBeforeCompile(Fe, S), He = re.acquireProgram(Fe, ke), Ze.set(ke, He), j.uniforms = Fe.uniforms;
+            const We = j.uniforms;
+            return (!C.isShaderMaterial && !C.isRawShaderMaterial || C.clipping === !0) && (We.clippingPlanes = oe.uniform), po(C, Fe), j.needsLights = _u(C), j.lightsStateVersion = Ce, j.needsLights && (We.ambientLightColor.value = X.state.ambient, We.lightProbe.value = X.state.probe, We.directionalLights.value = X.state.directional, We.directionalLightShadows.value = X.state.directionalShadow, We.spotLights.value = X.state.spot, We.spotLightShadows.value = X.state.spotShadow, We.rectAreaLights.value = X.state.rectArea, We.ltc_1.value = X.state.rectAreaLTC1, We.ltc_2.value = X.state.rectAreaLTC2, We.pointLights.value = X.state.point, We.pointLightShadows.value = X.state.pointShadow, We.hemisphereLights.value = X.state.hemi, We.directionalShadowMap.value = X.state.directionalShadowMap, We.directionalShadowMatrix.value = X.state.directionalShadowMatrix, We.spotShadowMap.value = X.state.spotShadowMap, We.spotLightMatrix.value = X.state.spotLightMatrix, We.spotLightMap.value = X.state.spotLightMap, We.pointShadowMap.value = X.state.pointShadowMap, We.pointShadowMatrix.value = X.state.pointShadowMatrix), j.currentProgram = He, j.uniformsList = null, He;
+        }
+
+        function ho(C) {
+            if (C.uniformsList === null) {
+                const H = C.currentProgram.getUniforms();
+                C.uniformsList = hr.seqWithValue(H.seq, C.uniforms);
+            }
+            return C.uniformsList;
+        }
+
+        function po(C, H) {
+            const Y = Oe.get(C);
+            Y.outputColorSpace = H.outputColorSpace, Y.batching = H.batching, Y.instancing = H.instancing, Y.instancingColor = H.instancingColor, Y.instancingMorph = H.instancingMorph, Y.skinning = H.skinning, Y.morphTargets = H.morphTargets, Y.morphNormals = H.morphNormals, Y.morphColors = H.morphColors, Y.morphTargetsCount = H.morphTargetsCount, Y.numClippingPlanes = H.numClippingPlanes, Y.numIntersection = H.numClipIntersection, Y.vertexAlphas = H.vertexAlphas, Y.vertexTangents = H.vertexTangents, Y.toneMapping = H.toneMapping;
+        }
+
+        function mu(C, H, Y, j, X) {
+            H.isScene !== !0 && (H = Qe), we.resetTextureUnits();
+            const ye = H.fog,
+                Ce = j.isMeshStandardMaterial ? H.environment : null,
+                Fe = T === null ? S.outputColorSpace : T.isXRRenderTarget === !0 ? T.texture.colorSpace : ni,
+                ke = (j.isMeshStandardMaterial ? w : Ke).get(j.envMap || Ce),
+                Ze = j.vertexColors === !0 && !!Y.attributes.color && Y.attributes.color.itemSize === 4,
+                He = !!Y.attributes.tangent && (!!j.normalMap || j.anisotropy > 0),
+                We = !!Y.morphAttributes.position,
+                ht = !!Y.morphAttributes.normal,
+                Ht = !!Y.morphAttributes.color;
+            let yt = $n;
+            j.toneMapped && (T === null || T.isXRRenderTarget === !0) && (yt = S.toneMapping);
+            const Mn = Y.morphAttributes.position || Y.morphAttributes.normal || Y.morphAttributes.color,
+                lt = Mn !== void 0 ? Mn.length : 0,
+                Ye = Oe.get(j),
+                Nr = m.state.lights;
+            if (V === !0 && (J === !0 || C !== B)) {
+                const Kt = C === B && j.id === L;
+                oe.setState(j, C, Kt);
+            }
+            let ot = !1;
+            j.version === Ye.__version ? (Ye.needsLights && Ye.lightsStateVersion !== Nr.state.version || Ye.outputColorSpace !== Fe || X.isBatchedMesh && Ye.batching === !1 || !X.isBatchedMesh && Ye.batching === !0 || X.isInstancedMesh && Ye.instancing === !1 || !X.isInstancedMesh && Ye.instancing === !0 || X.isSkinnedMesh && Ye.skinning === !1 || !X.isSkinnedMesh && Ye.skinning === !0 || X.isInstancedMesh && Ye.instancingColor === !0 && X.instanceColor === null || X.isInstancedMesh && Ye.instancingColor === !1 && X.instanceColor !== null || X.isInstancedMesh && Ye.instancingMorph === !0 && X.morphTexture === null || X.isInstancedMesh && Ye.instancingMorph === !1 && X.morphTexture !== null || Ye.envMap !== ke || j.fog === !0 && Ye.fog !== ye || Ye.numClippingPlanes !== void 0 && (Ye.numClippingPlanes !== oe.numPlanes || Ye.numIntersection !== oe.numIntersection) || Ye.vertexAlphas !== Ze || Ye.vertexTangents !== He || Ye.morphTargets !== We || Ye.morphNormals !== ht || Ye.morphColors !== Ht || Ye.toneMapping !== yt || Ie.isWebGL2 === !0 && Ye.morphTargetsCount !== lt) && (ot = !0) : (ot = !0, Ye.__version = j.version);
+            let ii = Ye.currentProgram;
+            ot === !0 && (ii = Os(j, H, X));
+            let mo = !1,
+                vs = !1,
+                kr = !1;
+            const wt = ii.getUniforms(),
+                si = Ye.uniforms;
+            if (Me.useProgram(ii.program) && (mo = !0, vs = !0, kr = !0), j.id !== L && (L = j.id, vs = !0), mo || B !== C) {
+                wt.setValue(O, "projectionMatrix", C.projectionMatrix), wt.setValue(O, "viewMatrix", C.matrixWorldInverse);
+                const Kt = wt.map.cameraPosition;
+                Kt !== void 0 && Kt.setValue(O, ge.setFromMatrixPosition(C.matrixWorld)), Ie.logarithmicDepthBuffer && wt.setValue(
+                    O,
                     "logDepthBufFC",
-                    2 / (Math.log(y.far + 1) / Math.LN2)
-                ), (V.isMeshPhongMaterial || V.isMeshToonMaterial || V.isMeshLambertMaterial || V.isMeshBasicMaterial || V.isMeshStandardMaterial || V.isShaderMaterial) && St.setValue(F, "isOrthographic", y.isOrthographicCamera === !0), W !== y && (W = y, $i = !0, us = !0);
+                    2 / (Math.log(C.far + 1) / Math.LN2)
+                ), (j.isMeshPhongMaterial || j.isMeshToonMaterial || j.isMeshLambertMaterial || j.isMeshBasicMaterial || j.isMeshStandardMaterial || j.isShaderMaterial) && wt.setValue(O, "isOrthographic", C.isOrthographicCamera === !0), B !== C && (B = C, vs = !0, kr = !0);
             }
-            if (k.isSkinnedMesh) {
-                St.setOptional(F, k, "bindMatrix"), St.setOptional(F, k, "bindMatrixInverse");
-                const Bt = k.skeleton;
-                Bt && (Ne.floatVertexTextures ? (Bt.boneTexture === null && Bt.computeBoneTexture(), St.setValue(F, "boneTexture", Bt.boneTexture, Be)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
-            }
-            k.isBatchedMesh && (St.setOptional(F, k, "batchingTexture"), St.setValue(F, "batchingTexture", k._matricesTexture, Be));
-            const fs = G.morphAttributes;
-            if ((fs.position !== void 0 || fs.normal !== void 0 || fs.color !== void 0 && Ne.isWebGL2 === !0) && C.update(k, G, Xn), ($i || Ve.receiveShadow !== k.receiveShadow) && (Ve.receiveShadow = k.receiveShadow, St.setValue(F, "receiveShadow", k.receiveShadow)), V.isMeshGouraudMaterial && V.envMap !== null && (qn.envMap.value = Ce, qn.flipEnvMap.value = Ce.isCubeTexture && Ce.isRenderTargetTexture === !1 ? -1 : 1), $i && (St.setValue(F, "toneMappingExposure", _.toneMappingExposure), Ve.needsLights && yc(qn, us), de && V.fog === !0 && $.refreshFogUniforms(qn, de), $.refreshMaterialUniforms(qn, V, B, O, pe), Vr.upload(F, bo(Ve), qn, Be)), V.isShaderMaterial && V.uniformsNeedUpdate === !0 && (Vr.upload(F, bo(Ve), qn, Be), V.uniformsNeedUpdate = !1), V.isSpriteMaterial && St.setValue(F, "center", k.center), St.setValue(F, "modelViewMatrix", k.modelViewMatrix), St.setValue(F, "normalMatrix", k.normalMatrix), St.setValue(F, "modelMatrix", k.matrixWorld), V.isShaderMaterial || V.isRawShaderMaterial) {
-                const Bt = V.uniformsGroups;
-                for (let hs = 0, Ec = Bt.length; hs < Ec; hs++)
-                    if (Ne.isWebGL2) {
-                        const Co = Bt[hs];
-                        _e.update(Co, Xn), _e.bind(Co, Xn);
+            if (X.isSkinnedMesh) {
+                wt.setOptional(O, X, "bindMatrix"), wt.setOptional(O, X, "bindMatrixInverse");
+                const Kt = X.skeleton;
+                Kt && (Ie.floatVertexTextures ? (Kt.boneTexture === null && Kt.computeBoneTexture(), wt.setValue(O, "boneTexture", Kt.boneTexture, we)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
+            }
+            X.isBatchedMesh && (wt.setOptional(O, X, "batchingTexture"), wt.setValue(O, "batchingTexture", X._matricesTexture, we));
+            const zr = Y.morphAttributes;
+            if ((zr.position !== void 0 || zr.normal !== void 0 || zr.color !== void 0 && Ie.isWebGL2 === !0) && R.update(X, Y, ii), (vs || Ye.receiveShadow !== X.receiveShadow) && (Ye.receiveShadow = X.receiveShadow, wt.setValue(O, "receiveShadow", X.receiveShadow)), j.isMeshGouraudMaterial && j.envMap !== null && (si.envMap.value = ke, si.flipEnvMap.value = ke.isCubeTexture && ke.isRenderTargetTexture === !1 ? -1 : 1), vs && (wt.setValue(O, "toneMappingExposure", S.toneMappingExposure), Ye.needsLights && gu(si, kr), ye && j.fog === !0 && ie.refreshFogUniforms(si, ye), ie.refreshMaterialUniforms(si, j, K, z, se), hr.upload(O, ho(Ye), si, we)), j.isShaderMaterial && j.uniformsNeedUpdate === !0 && (hr.upload(O, ho(Ye), si, we), j.uniformsNeedUpdate = !1), j.isSpriteMaterial && wt.setValue(O, "center", X.center), wt.setValue(O, "modelViewMatrix", X.modelViewMatrix), wt.setValue(O, "normalMatrix", X.normalMatrix), wt.setValue(O, "modelMatrix", X.matrixWorld), j.isShaderMaterial || j.isRawShaderMaterial) {
+                const Kt = j.uniformsGroups;
+                for (let Hr = 0, Su = Kt.length; Hr < Su; Hr++)
+                    if (Ie.isWebGL2) {
+                        const go = Kt[Hr];
+                        ve.update(go, ii), ve.bind(go, ii);
                     } else
                         console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
             }
-            return Xn;
+            return ii;
         }
 
-        function yc(y, U) {
-            y.ambientLightColor.needsUpdate = U, y.lightProbe.needsUpdate = U, y.directionalLights.needsUpdate = U, y.directionalLightShadows.needsUpdate = U, y.pointLights.needsUpdate = U, y.pointLightShadows.needsUpdate = U, y.spotLights.needsUpdate = U, y.spotLightShadows.needsUpdate = U, y.rectAreaLights.needsUpdate = U, y.hemisphereLights.needsUpdate = U;
+        function gu(C, H) {
+            C.ambientLightColor.needsUpdate = H, C.lightProbe.needsUpdate = H, C.directionalLights.needsUpdate = H, C.directionalLightShadows.needsUpdate = H, C.pointLights.needsUpdate = H, C.pointLightShadows.needsUpdate = H, C.spotLights.needsUpdate = H, C.spotLightShadows.needsUpdate = H, C.rectAreaLights.needsUpdate = H, C.hemisphereLights.needsUpdate = H;
         }
 
-        function Ac(y) {
-            return y.isMeshLambertMaterial || y.isMeshToonMaterial || y.isMeshPhongMaterial || y.isMeshStandardMaterial || y.isShadowMaterial || y.isShaderMaterial && y.lights === !0;
+        function _u(C) {
+            return C.isMeshLambertMaterial || C.isMeshToonMaterial || C.isMeshPhongMaterial || C.isMeshStandardMaterial || C.isShadowMaterial || C.isShaderMaterial && C.lights === !0;
         }
         this.getActiveCubeFace = function() {
-            return R;
+            return b;
         }, this.getActiveMipmapLevel = function() {
             return E;
         }, this.getRenderTarget = function() {
-            return b;
-        }, this.setRenderTargetTextures = function(y, U, G) {
-            Ie.get(y.texture).__webglTexture = U, Ie.get(y.depthTexture).__webglTexture = G;
-            const V = Ie.get(y);
-            V.__hasExternalTextures = !0, V.__autoAllocateDepthBuffer = G === void 0, V.__autoAllocateDepthBuffer || Me.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), V.__useRenderToTexture = !1);
-        }, this.setRenderTargetFramebuffer = function(y, U) {
-            const G = Ie.get(y);
-            G.__webglFramebuffer = U, G.__useDefaultFramebuffer = U === void 0;
-        }, this.setRenderTarget = function(y, U = 0, G = 0) {
-            b = y, R = U, E = G;
-            let V = !0,
-                k = null,
-                de = !1,
-                Se = !1;
-            if (y) {
-                const Ce = Ie.get(y);
-                Ce.__useDefaultFramebuffer !== void 0 ? (ye.bindFramebuffer(F.FRAMEBUFFER, null), V = !1) : Ce.__webglFramebuffer === void 0 ? Be.setupRenderTarget(y) : Ce.__hasExternalTextures && Be.rebindTextures(y, Ie.get(y.texture).__webglTexture, Ie.get(y.depthTexture).__webglTexture);
-                const Xe = y.texture;
-                (Xe.isData3DTexture || Xe.isDataArrayTexture || Xe.isCompressedArrayTexture) && (Se = !0);
-                const Fe = Ie.get(y).__webglFramebuffer;
-                y.isWebGLCubeRenderTarget ? (Array.isArray(Fe[U]) ? k = Fe[U][G] : k = Fe[U], de = !0) : Ne.isWebGL2 && y.samples > 0 && Be.useMultisampledRTT(y) === !1 ? k = Ie.get(y).__webglMultisampledFramebuffer : Array.isArray(Fe) ? k = Fe[G] : k = Fe, S.copy(y.viewport), T.copy(y.scissor), Y = y.scissorTest;
+            return T;
+        }, this.setRenderTargetTextures = function(C, H, Y) {
+            Oe.get(C.texture).__webglTexture = H, Oe.get(C.depthTexture).__webglTexture = Y;
+            const j = Oe.get(C);
+            j.__hasExternalTextures = !0, j.__autoAllocateDepthBuffer = Y === void 0, j.__autoAllocateDepthBuffer || Te.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), j.__useRenderToTexture = !1);
+        }, this.setRenderTargetFramebuffer = function(C, H) {
+            const Y = Oe.get(C);
+            Y.__webglFramebuffer = H, Y.__useDefaultFramebuffer = H === void 0;
+        }, this.setRenderTarget = function(C, H = 0, Y = 0) {
+            T = C, b = H, E = Y;
+            let j = !0,
+                X = null,
+                ye = !1,
+                Ce = !1;
+            if (C) {
+                const ke = Oe.get(C);
+                ke.__useDefaultFramebuffer !== void 0 ? (Me.bindFramebuffer(O.FRAMEBUFFER, null), j = !1) : ke.__webglFramebuffer === void 0 ? we.setupRenderTarget(C) : ke.__hasExternalTextures && we.rebindTextures(C, Oe.get(C.texture).__webglTexture, Oe.get(C.depthTexture).__webglTexture);
+                const Ze = C.texture;
+                (Ze.isData3DTexture || Ze.isDataArrayTexture || Ze.isCompressedArrayTexture) && (Ce = !0);
+                const He = Oe.get(C).__webglFramebuffer;
+                C.isWebGLCubeRenderTarget ? (Array.isArray(He[H]) ? X = He[H][Y] : X = He[H], ye = !0) : Ie.isWebGL2 && C.samples > 0 && we.useMultisampledRTT(C) === !1 ? X = Oe.get(C).__webglMultisampledFramebuffer : Array.isArray(He) ? X = He[Y] : X = He, x.copy(C.viewport), A.copy(C.scissor), U = C.scissorTest;
             } else
-                S.copy(J).multiplyScalar(B).floor(), T.copy(ne).multiplyScalar(B).floor(), Y = ue;
-            if (ye.bindFramebuffer(F.FRAMEBUFFER, k) && Ne.drawBuffers && V && ye.drawBuffers(y, k), ye.viewport(S), ye.scissor(T), ye.setScissorTest(Y), de) {
-                const Ce = Ie.get(y.texture);
-                F.framebufferTexture2D(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, F.TEXTURE_CUBE_MAP_POSITIVE_X + U, Ce.__webglTexture, G);
-            } else if (Se) {
-                const Ce = Ie.get(y.texture),
-                    Xe = U || 0;
-                F.framebufferTextureLayer(F.FRAMEBUFFER, F.COLOR_ATTACHMENT0, Ce.__webglTexture, G || 0, Xe);
-            }
-            I = -1;
-        }, this.readRenderTargetPixels = function(y, U, G, V, k, de, Se) {
-            if (!(y && y.isWebGLRenderTarget)) {
+                x.copy(Q).multiplyScalar(K).floor(), A.copy(te).multiplyScalar(K).floor(), U = fe;
+            if (Me.bindFramebuffer(O.FRAMEBUFFER, X) && Ie.drawBuffers && j && Me.drawBuffers(C, X), Me.viewport(x), Me.scissor(A), Me.setScissorTest(U), ye) {
+                const ke = Oe.get(C.texture);
+                O.framebufferTexture2D(O.FRAMEBUFFER, O.COLOR_ATTACHMENT0, O.TEXTURE_CUBE_MAP_POSITIVE_X + H, ke.__webglTexture, Y);
+            } else if (Ce) {
+                const ke = Oe.get(C.texture),
+                    Ze = H || 0;
+                O.framebufferTextureLayer(O.FRAMEBUFFER, O.COLOR_ATTACHMENT0, ke.__webglTexture, Y || 0, Ze);
+            }
+            L = -1;
+        }, this.readRenderTargetPixels = function(C, H, Y, j, X, ye, Ce) {
+            if (!(C && C.isWebGLRenderTarget)) {
                 console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                 return;
             }
-            let Ee = Ie.get(y).__webglFramebuffer;
-            if (y.isWebGLCubeRenderTarget && Se !== void 0 && (Ee = Ee[Se]), Ee) {
-                ye.bindFramebuffer(F.FRAMEBUFFER, Ee);
+            let Fe = Oe.get(C).__webglFramebuffer;
+            if (C.isWebGLCubeRenderTarget && Ce !== void 0 && (Fe = Fe[Ce]), Fe) {
+                Me.bindFramebuffer(O.FRAMEBUFFER, Fe);
                 try {
-                    const Ce = y.texture,
-                        Xe = Ce.format,
-                        Fe = Ce.type;
-                    if (Xe !== Vt && fe.convert(Xe) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_FORMAT)) {
+                    const ke = C.texture,
+                        Ze = ke.format,
+                        He = ke.type;
+                    if (Ze !== kt && me.convert(Ze) !== O.getParameter(O.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                         console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                         return;
                     }
-                    const ze = Fe === Gi && (Me.has("EXT_color_buffer_half_float") || Ne.isWebGL2 && Me.has("EXT_color_buffer_float"));
-                    if (Fe !== Gn && fe.convert(Fe) !== F.getParameter(F.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
-                        !(Fe === an && (Ne.isWebGL2 || Me.has("OES_texture_float") || Me.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
-                        !ze) {
+                    const We = He === xi && (Te.has("EXT_color_buffer_half_float") || Ie.isWebGL2 && Te.has("EXT_color_buffer_float"));
+                    if (He !== In && me.convert(He) !== O.getParameter(O.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
+                        !(He === gn && (Ie.isWebGL2 || Te.has("OES_texture_float") || Te.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
+                        !We) {
                         console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                         return;
                     }
-                    U >= 0 && U <= y.width - V && G >= 0 && G <= y.height - k && F.readPixels(U, G, V, k, fe.convert(Xe), fe.convert(Fe), de);
+                    H >= 0 && H <= C.width - j && Y >= 0 && Y <= C.height - X && O.readPixels(H, Y, j, X, me.convert(Ze), me.convert(He), ye);
                 } finally {
-                    const Ce = b !== null ? Ie.get(b).__webglFramebuffer : null;
-                    ye.bindFramebuffer(F.FRAMEBUFFER, Ce);
+                    const ke = T !== null ? Oe.get(T).__webglFramebuffer : null;
+                    Me.bindFramebuffer(O.FRAMEBUFFER, ke);
                 }
             }
-        }, this.copyFramebufferToTexture = function(y, U, G = 0) {
-            const V = Math.pow(2, -G),
-                k = Math.floor(U.image.width * V),
-                de = Math.floor(U.image.height * V);
-            Be.setTexture2D(U, 0), F.copyTexSubImage2D(F.TEXTURE_2D, G, 0, 0, y.x, y.y, k, de), ye.unbindTexture();
-        }, this.copyTextureToTexture = function(y, U, G, V = 0) {
-            const k = U.image.width,
-                de = U.image.height,
-                Se = fe.convert(G.format),
-                Ee = fe.convert(G.type);
-            Be.setTexture2D(G, 0), F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, G.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, G.unpackAlignment), U.isDataTexture ? F.texSubImage2D(F.TEXTURE_2D, V, y.x, y.y, k, de, Se, Ee, U.image.data) : U.isCompressedTexture ? F.compressedTexSubImage2D(F.TEXTURE_2D, V, y.x, y.y, U.mipmaps[0].width, U.mipmaps[0].height, Se, U.mipmaps[0].data) : F.texSubImage2D(F.TEXTURE_2D, V, y.x, y.y, Se, Ee, U.image), V === 0 && G.generateMipmaps && F.generateMipmap(F.TEXTURE_2D), ye.unbindTexture();
-        }, this.copyTextureToTexture3D = function(y, U, G, V, k = 0) {
-            if (_.isWebGL1Renderer) {
+        }, this.copyFramebufferToTexture = function(C, H, Y = 0) {
+            const j = Math.pow(2, -Y),
+                X = Math.floor(H.image.width * j),
+                ye = Math.floor(H.image.height * j);
+            we.setTexture2D(H, 0), O.copyTexSubImage2D(O.TEXTURE_2D, Y, 0, 0, C.x, C.y, X, ye), Me.unbindTexture();
+        }, this.copyTextureToTexture = function(C, H, Y, j = 0) {
+            const X = H.image.width,
+                ye = H.image.height,
+                Ce = me.convert(Y.format),
+                Fe = me.convert(Y.type);
+            we.setTexture2D(Y, 0), O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, Y.flipY), O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Y.premultiplyAlpha), O.pixelStorei(O.UNPACK_ALIGNMENT, Y.unpackAlignment), H.isDataTexture ? O.texSubImage2D(O.TEXTURE_2D, j, C.x, C.y, X, ye, Ce, Fe, H.image.data) : H.isCompressedTexture ? O.compressedTexSubImage2D(O.TEXTURE_2D, j, C.x, C.y, H.mipmaps[0].width, H.mipmaps[0].height, Ce, H.mipmaps[0].data) : O.texSubImage2D(O.TEXTURE_2D, j, C.x, C.y, Ce, Fe, H.image), j === 0 && Y.generateMipmaps && O.generateMipmap(O.TEXTURE_2D), Me.unbindTexture();
+        }, this.copyTextureToTexture3D = function(C, H, Y, j, X = 0) {
+            if (S.isWebGL1Renderer) {
                 console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                 return;
             }
-            const de = Math.round(y.max.x - y.min.x),
-                Se = Math.round(y.max.y - y.min.y),
-                Ee = y.max.z - y.min.z + 1,
-                Ce = fe.convert(V.format),
-                Xe = fe.convert(V.type);
-            let Fe;
-            if (V.isData3DTexture)
-                Be.setTexture3D(V, 0), Fe = F.TEXTURE_3D;
-            else if (V.isDataArrayTexture || V.isCompressedArrayTexture)
-                Be.setTexture2DArray(V, 0), Fe = F.TEXTURE_2D_ARRAY;
+            const ye = Math.round(C.max.x - C.min.x),
+                Ce = Math.round(C.max.y - C.min.y),
+                Fe = C.max.z - C.min.z + 1,
+                ke = me.convert(j.format),
+                Ze = me.convert(j.type);
+            let He;
+            if (j.isData3DTexture)
+                we.setTexture3D(j, 0), He = O.TEXTURE_3D;
+            else if (j.isDataArrayTexture || j.isCompressedArrayTexture)
+                we.setTexture2DArray(j, 0), He = O.TEXTURE_2D_ARRAY;
             else {
                 console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                 return;
             }
-            F.pixelStorei(F.UNPACK_FLIP_Y_WEBGL, V.flipY), F.pixelStorei(F.UNPACK_PREMULTIPLY_ALPHA_WEBGL, V.premultiplyAlpha), F.pixelStorei(F.UNPACK_ALIGNMENT, V.unpackAlignment);
-            const ze = F.getParameter(F.UNPACK_ROW_LENGTH),
-                ot = F.getParameter(F.UNPACK_IMAGE_HEIGHT),
-                Lt = F.getParameter(F.UNPACK_SKIP_PIXELS),
-                dt = F.getParameter(F.UNPACK_SKIP_ROWS),
-                dn = F.getParameter(F.UNPACK_SKIP_IMAGES),
-                rt = G.isCompressedTexture ? G.mipmaps[k] : G.image;
-            F.pixelStorei(F.UNPACK_ROW_LENGTH, rt.width), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, rt.height), F.pixelStorei(F.UNPACK_SKIP_PIXELS, y.min.x), F.pixelStorei(F.UNPACK_SKIP_ROWS, y.min.y), F.pixelStorei(F.UNPACK_SKIP_IMAGES, y.min.z), G.isDataTexture || G.isData3DTexture ? F.texSubImage3D(Fe, k, U.x, U.y, U.z, de, Se, Ee, Ce, Xe, rt.data) : V.isCompressedArrayTexture ? F.compressedTexSubImage3D(Fe, k, U.x, U.y, U.z, de, Se, Ee, Ce, rt.data) : F.texSubImage3D(Fe, k, U.x, U.y, U.z, de, Se, Ee, Ce, Xe, rt), F.pixelStorei(F.UNPACK_ROW_LENGTH, ze), F.pixelStorei(F.UNPACK_IMAGE_HEIGHT, ot), F.pixelStorei(F.UNPACK_SKIP_PIXELS, Lt), F.pixelStorei(F.UNPACK_SKIP_ROWS, dt), F.pixelStorei(F.UNPACK_SKIP_IMAGES, dn), k === 0 && V.generateMipmaps && F.generateMipmap(Fe), ye.unbindTexture();
-        }, this.initTexture = function(y) {
-            y.isCubeTexture ? Be.setTextureCube(y, 0) : y.isData3DTexture ? Be.setTexture3D(y, 0) : y.isDataArrayTexture || y.isCompressedArrayTexture ? Be.setTexture2DArray(y, 0) : Be.setTexture2D(y, 0), ye.unbindTexture();
+            O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, j.flipY), O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha), O.pixelStorei(O.UNPACK_ALIGNMENT, j.unpackAlignment);
+            const We = O.getParameter(O.UNPACK_ROW_LENGTH),
+                ht = O.getParameter(O.UNPACK_IMAGE_HEIGHT),
+                Ht = O.getParameter(O.UNPACK_SKIP_PIXELS),
+                yt = O.getParameter(O.UNPACK_SKIP_ROWS),
+                Mn = O.getParameter(O.UNPACK_SKIP_IMAGES),
+                lt = Y.isCompressedTexture ? Y.mipmaps[X] : Y.image;
+            O.pixelStorei(O.UNPACK_ROW_LENGTH, lt.width), O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, lt.height), O.pixelStorei(O.UNPACK_SKIP_PIXELS, C.min.x), O.pixelStorei(O.UNPACK_SKIP_ROWS, C.min.y), O.pixelStorei(O.UNPACK_SKIP_IMAGES, C.min.z), Y.isDataTexture || Y.isData3DTexture ? O.texSubImage3D(He, X, H.x, H.y, H.z, ye, Ce, Fe, ke, Ze, lt.data) : j.isCompressedArrayTexture ? O.compressedTexSubImage3D(He, X, H.x, H.y, H.z, ye, Ce, Fe, ke, lt.data) : O.texSubImage3D(He, X, H.x, H.y, H.z, ye, Ce, Fe, ke, Ze, lt), O.pixelStorei(O.UNPACK_ROW_LENGTH, We), O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, ht), O.pixelStorei(O.UNPACK_SKIP_PIXELS, Ht), O.pixelStorei(O.UNPACK_SKIP_ROWS, yt), O.pixelStorei(O.UNPACK_SKIP_IMAGES, Mn), X === 0 && j.generateMipmaps && O.generateMipmap(He), Me.unbindTexture();
+        }, this.initTexture = function(C) {
+            C.isCubeTexture ? we.setTextureCube(C, 0) : C.isData3DTexture ? we.setTexture3D(C, 0) : C.isDataArrayTexture || C.isCompressedArrayTexture ? we.setTexture2DArray(C, 0) : we.setTexture2D(C, 0), Me.unbindTexture();
         }, this.resetState = function() {
-            R = 0, E = 0, b = null, ye.reset(), he.reset();
+            b = 0, E = 0, T = null, Me.reset(), _e.reset();
         }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
             detail: this
         }));
     }
     get coordinateSystem() {
-        return Mn;
+        return Dn;
     }
     get outputColorSpace() {
         return this._outputColorSpace;
     }
     set outputColorSpace(e) {
         this._outputColorSpace = e;
         const t = this.getContext();
-        t.drawingBufferColorSpace = e === mo ? "display-p3" : "srgb", t.unpackColorSpace = Ze.workingColorSpace === os ? "display-p3" : "srgb";
+        t.drawingBufferColorSpace = e === Qa ? "display-p3" : "srgb", t.unpackColorSpace = tt.workingColorSpace === Ir ? "display-p3" : "srgb";
     }
     get useLegacyLights() {
         return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
     }
     set useLegacyLights(e) {
         console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
     }
 }
-class i_ extends hc {}
-i_.prototype.isWebGL1Renderer = !0;
-class r_ extends gt {
+class J0 extends au {}
+J0.prototype.isWebGL1Renderer = !0;
+class $0 extends Et {
     constructor() {
-        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new bn(), this.environmentRotation = new bn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
+        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Nn(), this.environmentRotation = new Nn(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
             detail: this
         }));
     }
     copy(e, t) {
         return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
     }
     toJSON(e) {
         const t = super.toJSON(e);
         return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), t.object.environmentRotation = this.environmentRotation.toArray(), t;
     }
 }
-class Or extends Tt {
-    constructor(e = null, t = 1, n = 1, r, s, a, o, l, c = vt, u = vt, f, h) {
-        super(null, a, o, l, c, u, r, s, f, h), this.isDataTexture = !0, this.image = {
+class or extends Ot {
+    constructor(e = null, t = 1, n = 1, i, r, o, a, l, c = bt, u = bt, d, f) {
+        super(null, o, a, l, c, u, i, r, d, f), this.isDataTexture = !0, this.image = {
             data: e,
             width: t,
             height: n
         }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
     }
 }
-class s_ extends Wt {
-    constructor(e, t, n, r = 1) {
-        super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r;
+class e_ extends en {
+    constructor(e, t, n, i = 1) {
+        super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
     }
     copy(e) {
         return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
     }
     toJSON() {
         const e = super.toJSON();
         return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
     }
 }
-class hr extends Yt {
-    constructor(e = 1, t = 1, n = 1, r = 32, s = 1, a = !1, o = 0, l = Math.PI * 2) {
+class Is extends sn {
+    constructor(e = 1, t = 1, n = 1, i = 32, r = 1, o = !1, a = 0, l = Math.PI * 2) {
         super(), this.type = "CylinderGeometry", this.parameters = {
             radiusTop: e,
             radiusBottom: t,
             height: n,
-            radialSegments: r,
-            heightSegments: s,
-            openEnded: a,
-            thetaStart: o,
+            radialSegments: i,
+            heightSegments: r,
+            openEnded: o,
+            thetaStart: a,
             thetaLength: l
         };
         const c = this;
-        r = Math.floor(r), s = Math.floor(s);
+        i = Math.floor(i), r = Math.floor(r);
         const u = [],
+            d = [],
             f = [],
-            h = [],
-            p = [];
+            h = [];
         let g = 0;
-        const v = [],
+        const _ = [],
             m = n / 2;
-        let d = 0;
-        M(), a === !1 && (e > 0 && _(!0), t > 0 && _(!1)), this.setIndex(u), this.setAttribute("position", new Ft(f, 3)), this.setAttribute("normal", new Ft(h, 3)), this.setAttribute("uv", new Ft(p, 2));
+        let p = 0;
+        v(), o === !1 && (e > 0 && S(!0), t > 0 && S(!1)), this.setIndex(u), this.setAttribute("position", new Yt(d, 3)), this.setAttribute("normal", new Yt(f, 3)), this.setAttribute("uv", new Yt(h, 2));
 
-        function M() {
-            const A = new P(),
-                R = new P();
+        function v() {
+            const y = new D(),
+                b = new D();
             let E = 0;
-            const b = (t - e) / n;
-            for (let I = 0; I <= s; I++) {
-                const W = [],
-                    S = I / s,
-                    T = S * (t - e) + e;
-                for (let Y = 0; Y <= r; Y++) {
-                    const K = Y / r,
-                        L = K * l + o,
-                        N = Math.sin(L),
-                        O = Math.cos(L);
-                    R.x = T * N, R.y = -S * n + m, R.z = T * O, f.push(R.x, R.y, R.z), A.set(N, b, O).normalize(), h.push(A.x, A.y, A.z), p.push(K, 1 - S), W.push(g++);
-                }
-                v.push(W);
-            }
-            for (let I = 0; I < r; I++)
-                for (let W = 0; W < s; W++) {
-                    const S = v[W][I],
-                        T = v[W + 1][I],
-                        Y = v[W + 1][I + 1],
-                        K = v[W][I + 1];
-                    u.push(S, T, K), u.push(T, Y, K), E += 6;
-                }
-            c.addGroup(d, E, 0), d += E;
-        }
-
-        function _(A) {
-            const R = g,
-                E = new me(),
-                b = new P();
-            let I = 0;
-            const W = A === !0 ? e : t,
-                S = A === !0 ? 1 : -1;
-            for (let Y = 1; Y <= r; Y++)
-                f.push(0, m * S, 0), h.push(0, S, 0), p.push(0.5, 0.5), g++;
-            const T = g;
-            for (let Y = 0; Y <= r; Y++) {
-                const L = Y / r * l + o,
-                    N = Math.cos(L),
-                    O = Math.sin(L);
-                b.x = W * O, b.y = m * S, b.z = W * N, f.push(b.x, b.y, b.z), h.push(0, S, 0), E.x = N * 0.5 + 0.5, E.y = O * 0.5 * S + 0.5, p.push(E.x, E.y), g++;
-            }
-            for (let Y = 0; Y < r; Y++) {
-                const K = R + Y,
-                    L = T + Y;
-                A === !0 ? u.push(L, L + 1, K) : u.push(L + 1, L, K), I += 3;
+            const T = (t - e) / n;
+            for (let L = 0; L <= r; L++) {
+                const B = [],
+                    x = L / r,
+                    A = x * (t - e) + e;
+                for (let U = 0; U <= i; U++) {
+                    const N = U / i,
+                        P = N * l + a,
+                        I = Math.sin(P),
+                        z = Math.cos(P);
+                    b.x = A * I, b.y = -x * n + m, b.z = A * z, d.push(b.x, b.y, b.z), y.set(I, T, z).normalize(), f.push(y.x, y.y, y.z), h.push(N, 1 - x), B.push(g++);
+                }
+                _.push(B);
+            }
+            for (let L = 0; L < i; L++)
+                for (let B = 0; B < r; B++) {
+                    const x = _[B][L],
+                        A = _[B + 1][L],
+                        U = _[B + 1][L + 1],
+                        N = _[B][L + 1];
+                    u.push(x, A, N), u.push(A, U, N), E += 6;
+                }
+            c.addGroup(p, E, 0), p += E;
+        }
+
+        function S(y) {
+            const b = g,
+                E = new Ee(),
+                T = new D();
+            let L = 0;
+            const B = y === !0 ? e : t,
+                x = y === !0 ? 1 : -1;
+            for (let U = 1; U <= i; U++)
+                d.push(0, m * x, 0), f.push(0, x, 0), h.push(0.5, 0.5), g++;
+            const A = g;
+            for (let U = 0; U <= i; U++) {
+                const P = U / i * l + a,
+                    I = Math.cos(P),
+                    z = Math.sin(P);
+                T.x = B * z, T.y = m * x, T.z = B * I, d.push(T.x, T.y, T.z), f.push(0, x, 0), E.x = I * 0.5 + 0.5, E.y = z * 0.5 * x + 0.5, h.push(E.x, E.y), g++;
+            }
+            for (let U = 0; U < i; U++) {
+                const N = b + U,
+                    P = A + U;
+                y === !0 ? u.push(P, P + 1, N) : u.push(P + 1, P, N), L += 3;
             }
-            c.addGroup(d, I, A === !0 ? 1 : 2), d += I;
+            c.addGroup(p, L, y === !0 ? 1 : 2), p += L;
         }
     }
     copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
     }
     static fromJSON(e) {
-        return new hr(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
+        return new Is(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
     }
 }
-class So extends hr {
-    constructor(e = 1, t = 1, n = 32, r = 1, s = !1, a = 0, o = Math.PI * 2) {
-        super(0, e, t, n, r, s, a, o), this.type = "ConeGeometry", this.parameters = {
+class io extends Is {
+    constructor(e = 1, t = 1, n = 32, i = 1, r = !1, o = 0, a = Math.PI * 2) {
+        super(0, e, t, n, i, r, o, a), this.type = "ConeGeometry", this.parameters = {
             radius: e,
             height: t,
             radialSegments: n,
-            heightSegments: r,
-            openEnded: s,
-            thetaStart: a,
-            thetaLength: o
+            heightSegments: i,
+            openEnded: r,
+            thetaStart: o,
+            thetaLength: a
         };
     }
     static fromJSON(e) {
-        return new So(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
+        return new io(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
     }
 }
-class es extends Yt {
-    constructor(e = 1, t = 32, n = 16, r = 0, s = Math.PI * 2, a = 0, o = Math.PI) {
+class br extends sn {
+    constructor(e = 1, t = 32, n = 16, i = 0, r = Math.PI * 2, o = 0, a = Math.PI) {
         super(), this.type = "SphereGeometry", this.parameters = {
             radius: e,
             widthSegments: t,
             heightSegments: n,
-            phiStart: r,
-            phiLength: s,
-            thetaStart: a,
-            thetaLength: o
+            phiStart: i,
+            phiLength: r,
+            thetaStart: o,
+            thetaLength: a
         }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
-        const l = Math.min(a + o, Math.PI);
+        const l = Math.min(o + a, Math.PI);
         let c = 0;
         const u = [],
-            f = new P(),
-            h = new P(),
-            p = [],
+            d = new D(),
+            f = new D(),
+            h = [],
             g = [],
-            v = [],
+            _ = [],
             m = [];
-        for (let d = 0; d <= n; d++) {
-            const M = [],
-                _ = d / n;
-            let A = 0;
-            d === 0 && a === 0 ? A = 0.5 / t : d === n && l === Math.PI && (A = -0.5 / t);
-            for (let R = 0; R <= t; R++) {
-                const E = R / t;
-                f.x = -e * Math.cos(r + E * s) * Math.sin(a + _ * o), f.y = e * Math.cos(a + _ * o), f.z = e * Math.sin(r + E * s) * Math.sin(a + _ * o), g.push(f.x, f.y, f.z), h.copy(f).normalize(), v.push(h.x, h.y, h.z), m.push(E + A, 1 - _), M.push(c++);
-            }
-            u.push(M);
-        }
-        for (let d = 0; d < n; d++)
-            for (let M = 0; M < t; M++) {
-                const _ = u[d][M + 1],
-                    A = u[d][M],
-                    R = u[d + 1][M],
-                    E = u[d + 1][M + 1];
-                (d !== 0 || a > 0) && p.push(_, A, E), (d !== n - 1 || l < Math.PI) && p.push(A, R, E);
+        for (let p = 0; p <= n; p++) {
+            const v = [],
+                S = p / n;
+            let y = 0;
+            p === 0 && o === 0 ? y = 0.5 / t : p === n && l === Math.PI && (y = -0.5 / t);
+            for (let b = 0; b <= t; b++) {
+                const E = b / t;
+                d.x = -e * Math.cos(i + E * r) * Math.sin(o + S * a), d.y = e * Math.cos(o + S * a), d.z = e * Math.sin(i + E * r) * Math.sin(o + S * a), g.push(d.x, d.y, d.z), f.copy(d).normalize(), _.push(f.x, f.y, f.z), m.push(E + y, 1 - S), v.push(c++);
+            }
+            u.push(v);
+        }
+        for (let p = 0; p < n; p++)
+            for (let v = 0; v < t; v++) {
+                const S = u[p][v + 1],
+                    y = u[p][v],
+                    b = u[p + 1][v],
+                    E = u[p + 1][v + 1];
+                (p !== 0 || o > 0) && h.push(S, y, E), (p !== n - 1 || l < Math.PI) && h.push(y, b, E);
             }
-        this.setIndex(p), this.setAttribute("position", new Ft(g, 3)), this.setAttribute("normal", new Ft(v, 3)), this.setAttribute("uv", new Ft(m, 2));
+        this.setIndex(h), this.setAttribute("position", new Yt(g, 3)), this.setAttribute("normal", new Yt(_, 3)), this.setAttribute("uv", new Yt(m, 2));
     }
     copy(e) {
         return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
     }
     static fromJSON(e) {
-        return new es(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
+        return new br(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
     }
 }
-class o_ extends Yt {
+class t_ extends sn {
     constructor() {
         super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
     }
     copy(e) {
         return super.copy(e), this.instanceCount = e.instanceCount, this;
     }
     toJSON() {
         const e = super.toJSON();
         return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e;
     }
 }
-class nl {
+class Wl {
     constructor(e = 1, t = 0, n = 0) {
         return this.radius = e, this.phi = t, this.theta = n, this;
     }
     set(e, t, n) {
         return this.radius = e, this.phi = t, this.theta = n, this;
     }
     copy(e) {
@@ -17507,1232 +17535,2851 @@
     makeSafe() {
         return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
     }
     setFromVector3(e) {
         return this.setFromCartesianCoords(e.x, e.y, e.z);
     }
     setFromCartesianCoords(e, t, n) {
-        return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(xt(t / this.radius, -1, 1))), this;
+        return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(Ct(t / this.radius, -1, 1))), this;
     }
     clone() {
         return new this.constructor().copy(this);
     }
 }
 typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
     detail: {
-        revision: uo
+        revision: Ya
     }
 }));
-typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = uo);
-const Ye = class Ye {
-    constructor(e) {
-        Pe(this, "getSplatScaleAndRotation", function() {
-            const e = new ke(),
-                t = new ke(),
-                n = new ke(),
-                r = new P();
-            return function(s, a, o, l) {
-                const c = s * Ye.ScaleComponentCount;
-                a.set(
-                    this.fbf(this.scaleArray[c]),
-                    this.fbf(this.scaleArray[c + 1]),
-                    this.fbf(this.scaleArray[c + 2])
-                );
-                const u = s * Ye.RotationComponentCount;
-                o.set(
-                    this.fbf(this.rotationArray[u + 1]),
-                    this.fbf(this.rotationArray[u + 2]),
-                    this.fbf(this.rotationArray[u + 3]),
-                    this.fbf(this.rotationArray[u])
-                ), l && (e.makeScale(a.x, a.y, a.z), t.makeRotationFromQuaternion(o), n.copy(e).multiply(t).multiply(l), n.decompose(r, o, a));
-            };
-        }());
-        this.headerBufferData = new ArrayBuffer(Ye.HeaderSizeBytes), this.headerArrayUint8 = new Uint8Array(this.headerBufferData), this.headerArrayUint32 = new Uint32Array(this.headerBufferData), this.headerArrayFloat32 = new Float32Array(this.headerBufferData), this.headerArrayUint8.set(new Uint8Array(e, 0, Ye.HeaderSizeBytes)), this.versionMajor = this.headerArrayUint8[0], this.versionMinor = this.headerArrayUint8[1], this.headerExtraK = this.headerArrayUint8[2], this.compressionLevel = this.headerArrayUint8[3], this.splatCount = this.headerArrayUint32[1], this.bucketSize = this.headerArrayUint32[2], this.bucketCount = this.headerArrayUint32[3], this.bucketBlockSize = this.headerArrayFloat32[4], this.halfBucketBlockSize = this.bucketBlockSize / 2, this.bytesPerBucket = this.headerArrayUint32[5], this.compressionScaleRange = this.headerArrayUint32[6] || Ye.CompressionLevels[this.compressionLevel].ScaleRange, this.compressionScaleFactor = this.halfBucketBlockSize / this.compressionScaleRange;
-        const t = e.byteLength - Ye.HeaderSizeBytes;
-        this.splatBufferData = new ArrayBuffer(t), new Uint8Array(this.splatBufferData).set(new Uint8Array(e, Ye.HeaderSizeBytes, t)), this.bytesPerCenter = Ye.CompressionLevels[this.compressionLevel].BytesPerCenter, this.bytesPerScale = Ye.CompressionLevels[this.compressionLevel].BytesPerScale, this.bytesPerColor = Ye.CompressionLevels[this.compressionLevel].BytesPerColor, this.bytesPerRotation = Ye.CompressionLevels[this.compressionLevel].BytesPerRotation, this.bytesPerSplat = this.bytesPerCenter + this.bytesPerScale + this.bytesPerColor + this.bytesPerRotation, this.linkBufferArrays();
-    }
-    linkBufferArrays() {
-        let e = this.compressionLevel === 0 ? Float32Array : Uint16Array;
-        this.centerArray = new e(this.splatBufferData, 0, this.splatCount * Ye.CenterComponentCount), this.scaleArray = new e(
-            this.splatBufferData,
-            this.bytesPerCenter * this.splatCount,
-            this.splatCount * Ye.ScaleComponentCount
-        ), this.colorArray = new Uint8Array(
-            this.splatBufferData,
-            (this.bytesPerCenter + this.bytesPerScale) * this.splatCount,
-            this.splatCount * Ye.ColorComponentCount
-        ), this.rotationArray = new e(
-            this.splatBufferData,
-            (this.bytesPerCenter + this.bytesPerScale + this.bytesPerColor) * this.splatCount,
-            this.splatCount * Ye.RotationComponentCount
-        ), this.bucketsBase = this.splatCount * this.bytesPerSplat;
-    }
-    fbf(e) {
-        return this.compressionLevel === 0 ? e : $r.fromHalfFloat(e);
-    }
-    getHeaderBufferData() {
-        return this.headerBufferData;
-    }
-    getSplatBufferData() {
-        return this.splatBufferData;
-    }
-    getSplatCount() {
-        return this.splatCount;
-    }
-    getSplatCenter(e, t, n) {
-        let r = [0, 0, 0];
-        const s = e * Ye.CenterComponentCount;
-        if (this.compressionLevel > 0) {
-            const a = this.compressionScaleFactor,
-                o = this.compressionScaleRange,
-                l = Math.floor(e / this.bucketSize);
-            r = new Float32Array(this.splatBufferData, this.bucketsBase + l * this.bytesPerBucket, 3), t.x = (this.centerArray[s] - o) * a + r[0], t.y = (this.centerArray[s + 1] - o) * a + r[1], t.z = (this.centerArray[s + 2] - o) * a + r[2];
-        } else
-            t.x = this.centerArray[s], t.y = this.centerArray[s + 1], t.z = this.centerArray[s + 2];
-        n && t.applyMatrix4(n);
-    }
-    getSplatColor(e, t, n) {
-        const r = e * Ye.ColorComponentCount;
-        t.set(
-            this.colorArray[r],
-            this.colorArray[r + 1],
-            this.colorArray[r + 2],
-            this.colorArray[r + 3]
-        );
-    }
-    fillSplatCenterArray(e, t, n) {
-        const r = this.splatCount;
-        let s = [0, 0, 0];
-        const a = new P();
-        for (let o = 0; o < r; o++) {
-            const l = o * Ye.CenterComponentCount,
-                c = (o + t) * Ye.CenterComponentCount;
-            if (this.compressionLevel > 0) {
-                const u = Math.floor(o / this.bucketSize);
-                s = new Float32Array(this.splatBufferData, this.bucketsBase + u * this.bytesPerBucket, 3);
-                const f = this.compressionScaleFactor,
-                    h = this.compressionScaleRange;
-                a.x = (this.centerArray[l] - h) * f + s[0], a.y = (this.centerArray[l + 1] - h) * f + s[1], a.z = (this.centerArray[l + 2] - h) * f + s[2];
-            } else
-                a.x = this.centerArray[l], a.y = this.centerArray[l + 1], a.z = this.centerArray[l + 2];
-            n && a.applyMatrix4(n), e[c] = a.x, e[c + 1] = a.y, e[c + 2] = a.z;
-        }
-    }
-    fillSplatCovarianceArray(e, t, n) {
-        const r = this.splatCount,
-            s = new P(),
-            a = new wt(),
-            o = new be(),
-            l = new be(),
-            c = new be(),
-            u = new be(),
-            f = new be(),
-            h = new be(),
-            p = new ke();
-        for (let g = 0; g < r; g++) {
-            const v = g * Ye.ScaleComponentCount;
-            s.set(
-                this.fbf(this.scaleArray[v]),
-                this.fbf(this.scaleArray[v + 1]),
-                this.fbf(this.scaleArray[v + 2])
-            ), p.makeScale(s.x, s.y, s.z), l.setFromMatrix4(p);
-            const m = g * Ye.RotationComponentCount;
-            a.set(
-                this.fbf(this.rotationArray[m + 1]),
-                this.fbf(this.rotationArray[m + 2]),
-                this.fbf(this.rotationArray[m + 3]),
-                this.fbf(this.rotationArray[m])
-            ), p.makeRotationFromQuaternion(a), o.setFromMatrix4(p), c.copy(o).multiply(l), u.copy(c).transpose().premultiply(c);
-            const d = Ye.CovarianceSizeFloats * (g + t);
-            n && (f.setFromMatrix4(n), h.copy(f).transpose(), u.multiply(h), u.premultiply(f)), e[d] = u.elements[0], e[d + 1] = u.elements[3], e[d + 2] = u.elements[6], e[d + 3] = u.elements[4], e[d + 4] = u.elements[7], e[d + 5] = u.elements[8];
-        }
-    }
-    fillSplatColorArray(e, t, n) {
-        const r = this.splatCount;
-        for (let s = 0; s < r; s++) {
-            const a = s * Ye.ColorComponentCount,
-                o = (s + t) * Ye.ColorComponentCount;
-            e[o] = this.colorArray[a], e[o + 1] = this.colorArray[a + 1], e[o + 2] = this.colorArray[a + 2], e[o + 3] = this.colorArray[a + 3];
-        }
-    }
-};
-Pe(Ye, "CenterComponentCount", 3), Pe(Ye, "ScaleComponentCount", 3), Pe(Ye, "RotationComponentCount", 4), Pe(Ye, "ColorComponentCount", 4), Pe(Ye, "CompressionLevels", {
-    0: {
-        BytesPerCenter: 12,
-        BytesPerScale: 12,
-        BytesPerColor: 4,
-        BytesPerRotation: 16,
-        ScaleRange: 1
-    },
-    1: {
-        BytesPerCenter: 6,
-        BytesPerScale: 6,
-        BytesPerColor: 4,
-        BytesPerRotation: 8,
-        ScaleRange: 32767
-    }
-}), Pe(Ye, "CovarianceSizeFloats", 6), Pe(Ye, "CovarianceSizeBytes", 24), Pe(Ye, "HeaderSizeBytes", 1024);
-let $t = Ye;
-class cn {
+typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Ya);
+const pi = class pi {
     constructor(e, t) {
-        let n, r;
-        this.promise = new Promise((o, l) => {
-            n = o.bind(this), r = l.bind(this);
+        let n, i;
+        this.promise = new Promise((a, l) => {
+            n = a.bind(this), i = l.bind(this);
         });
-        const s = (...o) => {
-                n(...o);
+        const r = (...a) => {
+                n(...a);
             },
-            a = (o) => {
-                r(o);
+            o = (a) => {
+                i(a);
             };
-        e(s.bind(this), a.bind(this)), this.abortHandler = t;
+        e(r.bind(this), o.bind(this)), this.abortHandler = t, this.id = pi.idGen++;
     }
     then(e) {
-        return new cn((t, n) => {
-            this.promise = this.promise.then((...r) => {
-                const s = e(...r);
-                s instanceof Promise || s instanceof cn ? s.then((...a) => {
-                    t(...a);
-                }) : t(s);
-            }).catch((r) => {
-                n(r);
+        return new pi((t, n) => {
+            this.promise = this.promise.then((...i) => {
+                const r = e(...i);
+                r instanceof Promise || r instanceof pi ? r.then((...o) => {
+                    t(...o);
+                }) : t(r);
+            }).catch((i) => {
+                n(i);
             });
         }, this.abortHandler);
     }
     catch (e) {
-        return new cn((t) => {
+        return new pi((t) => {
             this.promise = this.promise.then((...n) => {
                 t(...n);
             }).catch(e);
         }, this.abortHandler);
     }
     abort() {
         this.abortHandler && this.abortHandler();
     }
-    static resolve(e) {
-        return new cn((t) => {
-            t(e);
-        });
-    }
-    static reject(e) {
-        return new cn((t, n) => {
-            n(e);
-        });
+};
+le(pi, "idGen", 0);
+let gi = pi;
+class pr extends Error {
+    constructor(e) {
+        super(e);
     }
 }
 (function() {
-    const i = new Float32Array(1),
-        e = new Int32Array(i.buffer);
+    const s = new Float32Array(1),
+        e = new Int32Array(s.buffer);
     return function(t) {
-        i[0] = t;
+        s[0] = t;
         const n = e[0];
-        let r = n >> 16 & 32768,
-            s = n >> 12 & 2047;
-        const a = n >> 23 & 255;
-        return a < 103 ? r : a > 142 ? (r |= 31744, r |= (a == 255 ? 0 : 1) && n & 8388607, r) : a < 113 ? (s |= 2048, r |= (s >> 114 - a) + (s >> 113 - a & 1), r) : (r |= a - 112 << 10 | s >> 1, r += s & 1, r);
+        let i = n >> 16 & 32768,
+            r = n >> 12 & 2047;
+        const o = n >> 23 & 255;
+        return o < 103 ? i : o > 142 ? (i |= 31744, i |= (o == 255 ? 0 : 1) && n & 8388607, i) : o < 113 ? (r |= 2048, i |= (r >> 114 - o) + (r >> 113 - o & 1), i) : (i |= o - 112 << 10 | r >> 1, i += r & 1, i);
     };
 })();
-const js = function() {
-        const i = new Float32Array(1),
-            e = new Int32Array(i.buffer);
+const Aa = function() {
+        const s = new Float32Array(1),
+            e = new Int32Array(s.buffer);
         return function(t) {
-            return i[0] = t, e[0];
+            return s[0] = t, e[0];
         };
     }(),
-    a_ = function(i, e, t, n) {
-        return i + (e << 8) + (t << 16) + (n << 24);
+    n_ = function(s, e) {
+        return s[e] + (s[e + 1] << 8) + (s[e + 2] << 16) + (s[e + 3] << 24);
     },
-    dc = function(i, e) {
-        const t = new AbortController(),
-            n = t.signal;
+    so = function(s, e, t = !0) {
+        const n = new AbortController(),
+            i = n.signal;
         let r = !1,
-            s = null;
+            o = null;
         const a = () => {
-            t.abort(), s("Fetch aborted"), r = !0;
+            n.abort(), o(new pr("Fetch aborted.")), r = !0;
         };
-        return new cn((o, l) => {
-            s = l, fetch(i, {
-                signal: n
-            }).then(async (c) => {
-                const u = c.body.getReader();
+        return new gi((l, c) => {
+            o = c, fetch(s, {
+                signal: i
+            }).then(async (u) => {
+                const d = u.body.getReader();
                 let f = 0,
-                    h = c.headers.get("Content-Length"),
-                    p = h ? parseInt(h) : void 0;
-                const g = [];
+                    h = u.headers.get("Content-Length"),
+                    g = h ? parseInt(h) : void 0;
+                const _ = [];
                 for (; !r;)
                     try {
                         const {
-                            value: v,
-                            done: m
-                        } = await u.read();
-                        if (m) {
-                            e && e(100, "100%", v);
-                            const _ = new Blob(g).arrayBuffer();
-                            o(_);
+                            value: m,
+                            done: p
+                        } = await d.read();
+                        if (p) {
+                            if (e && e(100, "100%", m, g), t) {
+                                const y = new Blob(_).arrayBuffer();
+                                l(y);
+                            } else
+                                l();
                             break;
                         }
-                        f += v.length;
-                        let d, M;
-                        p !== void 0 && (d = f / p * 100, M = `${d.toFixed(2)}%`), g.push(v), e && e(d, M, v);
-                    } catch (v) {
-                        l(v);
+                        f += m.length;
+                        let v, S;
+                        g !== void 0 && (v = f / g * 100, S = `${v.toFixed(2)}%`), t && _.push(m), e && e(v, S, m, g) && (t = !1);
+                    } catch (m) {
+                        c(m);
                         break;
                     }
             });
         }, a);
     },
-    Ks = function(i, e, t) {
-        return Math.max(Math.min(i, t), e);
+    qt = function(s, e, t) {
+        return Math.max(Math.min(s, t), e);
     },
-    Ri = function() {
+    Wi = function() {
         return performance.now() / 1e3;
     },
-    Ii = (i) => {
-        if (i.geometry && (i.geometry.dispose(), i.geometry = null), i.material && (i.material.dispose(), i.material = null), i.children)
-            for (let e of i.children)
-                Ii(e);
+    Zi = (s) => {
+        if (s.geometry && (s.geometry.dispose(), s.geometry = null), s.material && (s.material.dispose(), s.material = null), s.children)
+            for (let e of s.children)
+                Zi(e);
     },
-    l_ = 256,
-    c_ = 5;
-class u_ {
-    constructor() {
-        this.splatCount = 0, this.scale_0 = [], this.scale_1 = [], this.scale_2 = [], this.rot_0 = [], this.rot_1 = [], this.rot_2 = [], this.rot_3 = [], this.x = [], this.y = [], this.z = [], this.f_dc_0 = [], this.f_dc_1 = [], this.f_dc_2 = [], this.opacity = [];
-    }
-    addSplat(e, t, n, r, s, a, o, l, c, u, f, h, p, g) {
-        this.x.push(e), this.y.push(t), this.z.push(n), this.scale_0.push(r), this.scale_1.push(s), this.scale_2.push(a), this.rot_0.push(o), this.rot_1.push(l), this.rot_2.push(c), this.rot_3.push(u), this.f_dc_0.push(f), this.f_dc_1.push(h), this.f_dc_2.push(p), this.opacity.push(g), this.splatCount++;
-    }
-}
-class Xi {
-    constructor(e = 0, t = 1, n = c_, r = l_) {
-        this.compressionLevel = e, this.minimumAlpha = t, this.bucketSize = r, this.blockSize = n;
-    }
-    static createEmptyUncompressedSplatArray() {
-        return new u_();
-    }
-    uncompressedSplatArrayToSplatBuffer(e) {
-        const t = Xi.createEmptyUncompressedSplatArray();
-        t.addSplat(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0);
-        for (let L = 0; L < e.splatCount; L++) {
-            let N;
-            e.opacity[L] ? N = e.opacity[L] : N = 255, N >= this.minimumAlpha && t.addSplat(
-                e.x[L],
-                e.y[L],
-                e.z[L],
-                e.scale_0[L],
-                e.scale_1[L],
-                e.scale_2[L],
-                e.rot_0[L],
-                e.rot_1[L],
-                e.rot_2[L],
-                e.rot_3[L],
-                e.f_dc_0[L],
-                e.f_dc_1[L],
-                e.f_dc_2[L],
-                e.opacity[L]
+    Ln = (s, e) => new Promise((t) => {
+        window.setTimeout(() => {
+            t(s());
+        }, e ? 1 : 50);
+    }),
+    Us = (s = 0) => {
+        switch (s) {
+            case 1:
+                return 9;
+            case 2:
+                return 24;
+        }
+        return 0;
+    },
+    i_ = 14,
+    Rs = class Rs {
+        constructor(e = 0) {
+            this.sphericalHarmonicsDegree = e, this.sphericalHarmonicsCount = Us(this.sphericalHarmonicsDegree), this.componentCount = this.sphericalHarmonicsCount + i_, this.defaultSphericalHarmonics = new Array(this.sphericalHarmonicsCount).fill(0), this.splats = [], this.splatCount = 0;
+        }
+        static createSplat(e = 0) {
+            const t = [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
+            let n = Us(e);
+            for (let i = 0; i < n; i++)
+                t.push(0);
+            return t;
+        }
+        addSplat(e) {
+            this.splats.push(e), this.splatCount++;
+        }
+        getSplat(e) {
+            return this.splats[e];
+        }
+        addDefaultSplat() {
+            const e = Rs.createSplat(this.sphericalHarmonicsDegree);
+            return this.addSplat(e), e;
+        }
+        addSplatFromComonents(e, t, n, i, r, o, a, l, c, u, d, f, h, g, ..._) {
+            const m = [e, t, n, i, r, o, a, l, c, u, d, f, h, g, ...this.defaultSphericalHarmonics];
+            for (let p = 0; p < _.length && p < this.sphericalHarmonicsCount; p++)
+                m[p] = _[p];
+            return this.addSplat(m), m;
+        }
+        addSplatFromArray(e, t) {
+            const n = e.splats[t],
+                i = Rs.createSplat(this.sphericalHarmonicsDegree);
+            for (let r = 0; r < this.componentCount && r < n.length; r++)
+                i[r] = n[r];
+            this.addSplat(i);
+        }
+    };
+le(Rs, "OFFSET", {
+    X: 0,
+    Y: 1,
+    Z: 2,
+    SCALE0: 3,
+    SCALE1: 4,
+    SCALE2: 5,
+    ROTATION0: 6,
+    ROTATION1: 7,
+    ROTATION2: 8,
+    ROTATION3: 9,
+    FDC0: 10,
+    FDC1: 11,
+    FDC2: 12,
+    OPACITY: 13,
+    FRC0: 14,
+    FRC1: 15,
+    FRC2: 16,
+    FRC3: 17,
+    FRC4: 18,
+    FRC5: 19,
+    FRC6: 20,
+    FRC7: 21,
+    FRC8: 22,
+    FRC9: 23,
+    FRC10: 24,
+    FRC11: 25,
+    FRC12: 26,
+    FRC13: 27,
+    FRC14: 28,
+    FRC15: 29,
+    FRC16: 30,
+    FRC17: 31,
+    FRC18: 32,
+    FRC19: 33,
+    FRC20: 34,
+    FRC21: 35,
+    FRC22: 36,
+    FRC23: 37
+});
+let ee = Rs;
+class rt {}
+le(rt, "DepthMapRange", 65536), le(rt, "MemoryPageSize", 65536), le(rt, "BytesPerFloat", 4), le(rt, "BytesPerInt", 4), le(rt, "MaxScenes", 32), le(rt, "StreamingSectionSize", 524288), le(rt, "SphericalHarmonics8BitCompressionRange", 3);
+const mr = rt.SphericalHarmonics8BitCompressionRange / 2,
+    gt = Fs.toHalfFloat.bind(Fs),
+    gr = (s) => (s = qt(s, -mr, mr), qt(Math.floor((s * (0.5 / mr) + 0.5) * 255), 0, 255)),
+    s_ = (s) => s / 255 * rt.SphericalHarmonics8BitCompressionRange - mr,
+    ou = Fs.fromHalfFloat.bind(Fs),
+    r_ = (s) => gr(ou(s)),
+    Tt = (s, e, t = !1) => {
+        if (e === 0)
+            return s;
+        if (e === 1 || e === 2 && !t)
+            return Fs.fromHalfFloat(s);
+        if (e === 2)
+            return s_(s);
+    },
+    ct = (s, e, t, n = !1) => t === 0 ? s.getFloat32(e * 4, !0) : t === 1 || t === 2 && !n ? s.getUint16(e * 2, !0) : s.getUint8(e, !0),
+    $ = class $ {
+        constructor(e, t = !0) {
+            le(this, "getSplatScaleAndRotation", function() {
+                const e = new Ge(),
+                    t = new Ge(),
+                    n = new Ge(),
+                    i = new D(),
+                    r = new D(),
+                    o = new St();
+                return function(a, l, c, u) {
+                    const d = this.globalSplatIndexToSectionMap[a],
+                        f = this.sections[d],
+                        h = a - f.splatCountOffset,
+                        g = f.bytesPerSplat * h + $.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,
+                        _ = new DataView(this.bufferData, f.dataBase + g);
+                    r.set(
+                        Tt(ct(_, 0, this.compressionLevel), this.compressionLevel),
+                        Tt(ct(_, 1, this.compressionLevel), this.compressionLevel),
+                        Tt(ct(_, 2, this.compressionLevel), this.compressionLevel)
+                    ), o.set(
+                        Tt(ct(_, 4, this.compressionLevel), this.compressionLevel),
+                        Tt(ct(_, 5, this.compressionLevel), this.compressionLevel),
+                        Tt(ct(_, 6, this.compressionLevel), this.compressionLevel),
+                        Tt(ct(_, 3, this.compressionLevel), this.compressionLevel)
+                    ), u ? (e.makeScale(r.x, r.y, r.z), t.makeRotationFromQuaternion(o), n.copy(e).multiply(t).multiply(u), n.decompose(i, c, l)) : (l.copy(r), c.copy(o));
+                };
+            }());
+            le(this, "fillSphericalHarmonicsArray", function() {
+                for (let x = 0; x < 15; x++)
+                    new D();
+                const e = new Ue(),
+                    t = [],
+                    n = [],
+                    i = [],
+                    r = [],
+                    o = [],
+                    a = [],
+                    l = [],
+                    c = [],
+                    u = [],
+                    d = [],
+                    f = [],
+                    h = [],
+                    g = [],
+                    _ = [],
+                    m = [],
+                    p = [],
+                    v = [],
+                    S = [],
+                    y = (x) => x,
+                    b = (x, A, U, N) => {
+                        x[0] = A, x[1] = U, x[2] = N;
+                    },
+                    E = (x, A, U, N, P) => {
+                        x[0] = ct(A, N, P, !0), x[1] = ct(A, N + U, P, !0), x[2] = ct(A, N + U + U, P, !0);
+                    },
+                    T = (x, A) => {
+                        A[0] = x[0], A[1] = x[1], A[2] = x[2];
+                    },
+                    L = (x, A, U, N) => {
+                        A[U] = N(x[0]), A[U + 1] = N(x[1]), A[U + 2] = N(x[2]);
+                    },
+                    B = (x, A, U) => (A[0] = Tt(x[0], U, !0), A[1] = Tt(x[1], U, !0), A[2] = Tt(x[2], U, !0), A);
+                return function(x, A, U, N, P, I, z) {
+                    const K = this.splatCount;
+                    N = N || 0, P = P || K - 1, I === void 0 && (I = N), U && A >= 1 && (e.setFromMatrix4(U), b(t, e.elements[4], -e.elements[7], e.elements[1]), b(n, -e.elements[5], e.elements[8], -e.elements[2]), b(i, e.elements[3], -e.elements[6], e.elements[0]));
+                    for (let G = N; G <= P; G++) {
+                        const q = this.globalSplatIndexToSectionMap[G],
+                            Q = this.sections[q];
+                        A = Math.min(A, Q.sphericalHarmonicsDegree);
+                        const te = Us(A),
+                            fe = G - Q.splatCountOffset,
+                            ne = Q.bytesPerSplat * fe + $.CompressionLevels[this.compressionLevel].SphericalHarmonicsOffsetBytes,
+                            V = new DataView(this.bufferData, Q.dataBase + ne),
+                            J = (G - N + I) * te;
+                        let se = U ? 0 : this.compressionLevel,
+                            Ae = y;
+                        se !== z && (se === 1 ? z === 0 ? Ae = ou : z == 2 && (Ae = r_) : se === 0 && (z === 1 ? Ae = gt : z == 2 && (Ae = gr))), A >= 1 && (E(u, V, 3, 0, this.compressionLevel), E(d, V, 3, 1, this.compressionLevel), E(f, V, 3, 2, this.compressionLevel), U ? (B(u, u, this.compressionLevel), B(d, d, this.compressionLevel), B(f, f, this.compressionLevel), $.rotateSphericalHarmonics3(u, d, f, t, n, i, _, m, p)) : (T(u, _), T(d, m), T(f, p)), L(_, x, J, Ae), L(m, x, J + 3, Ae), L(p, x, J + 6, Ae), A >= 2 && (E(u, V, 5, 9, this.compressionLevel), E(d, V, 5, 10, this.compressionLevel), E(f, V, 5, 11, this.compressionLevel), E(h, V, 5, 12, this.compressionLevel), E(g, V, 5, 13, this.compressionLevel), U ? (B(u, u, this.compressionLevel), B(d, d, this.compressionLevel), B(f, f, this.compressionLevel), B(h, h, this.compressionLevel), B(g, g, this.compressionLevel), $.rotateSphericalHarmonics5(
+                            u,
+                            d,
+                            f,
+                            h,
+                            g,
+                            t,
+                            n,
+                            i,
+                            r,
+                            o,
+                            a,
+                            l,
+                            c,
+                            _,
+                            m,
+                            p,
+                            v,
+                            S
+                        )) : (T(u, _), T(d, m), T(f, p), T(h, v), T(g, S)), L(_, x, J + 9, Ae), L(m, x, J + 12, Ae), L(p, x, J + 15, Ae), L(v, x, J + 18, Ae), L(S, x, J + 21, Ae)));
+                    }
+                };
+            }());
+            this.constructFromBuffer(e, t);
+        }
+        getSplatCount() {
+            return this.splatCount;
+        }
+        getMaxSplatCount() {
+            return this.maxSplatCount;
+        }
+        getMinSphericalHarmonicsDegree() {
+            let e = 0;
+            for (let t = 0; t < this.sections.length; t++) {
+                const n = this.sections[t];
+                (t === 0 || n.sphericalHarmonicsDegree < e) && (e = n.sphericalHarmonicsDegree);
+            }
+            return e;
+        }
+        getBucketIndex(e, t) {
+            let n;
+            const i = e.fullBucketCount * e.bucketSize;
+            if (t < i)
+                n = Math.floor(t / e.bucketSize);
+            else {
+                let r = i;
+                n = e.fullBucketCount;
+                let o = 0;
+                for (; r < e.splatCount;) {
+                    let a = e.partiallyFilledBucketLengths[o];
+                    if (t >= r && t < r + a)
+                        break;
+                    r += a, n++, o++;
+                }
+            }
+            return n;
+        }
+        getSplatCenter(e, t, n) {
+            const i = this.globalSplatIndexToSectionMap[e],
+                r = this.sections[i],
+                o = e - r.splatCountOffset,
+                a = r.bytesPerSplat * o,
+                l = new DataView(this.bufferData, r.dataBase + a),
+                c = ct(l, 0, this.compressionLevel),
+                u = ct(l, 1, this.compressionLevel),
+                d = ct(l, 2, this.compressionLevel);
+            if (this.compressionLevel >= 1) {
+                const h = this.getBucketIndex(r, o) * $.BucketStorageSizeFloats,
+                    g = r.compressionScaleFactor,
+                    _ = r.compressionScaleRange;
+                t.x = (c - _) * g + r.bucketArray[h], t.y = (u - _) * g + r.bucketArray[h + 1], t.z = (d - _) * g + r.bucketArray[h + 2];
+            } else
+                t.x = c, t.y = u, t.z = d;
+            n && t.applyMatrix4(n);
+        }
+        getSplatColor(e, t) {
+            const n = this.globalSplatIndexToSectionMap[e],
+                i = this.sections[n],
+                r = e - i.splatCountOffset,
+                o = i.bytesPerSplat * r + $.CompressionLevels[this.compressionLevel].ColorOffsetBytes,
+                a = new Uint8Array(this.bufferData, i.dataBase + o, 4);
+            t.set(
+                a[0],
+                a[1],
+                a[2],
+                a[3]
             );
         }
-        const n = this.computeBucketsForUncompressedSplatArray(t),
-            r = n.length * this.bucketSize,
-            s = $t.HeaderSizeBytes,
-            a = new Uint8Array(new ArrayBuffer(s));
-        a[3] = this.compressionLevel, new Uint32Array(a.buffer, 4, 1)[0] = r;
-        let o = $t.CompressionLevels[this.compressionLevel].BytesPerCenter,
-            l = $t.CompressionLevels[this.compressionLevel].BytesPerScale,
-            c = $t.CompressionLevels[this.compressionLevel].BytesPerColor,
-            u = $t.CompressionLevels[this.compressionLevel].BytesPerRotation;
-        const f = new ArrayBuffer(o * r),
-            h = new ArrayBuffer(l * r),
-            p = new ArrayBuffer(c * r),
-            g = new ArrayBuffer(u * r),
-            v = this.blockSize / 2,
-            m = $t.CompressionLevels[this.compressionLevel].ScaleRange,
-            d = m / v,
-            M = m * 2 + 1,
-            _ = new P(),
-            A = new P();
-        let R = 0;
-        for (let L = 0; L < n.length; L++) {
-            const N = n[L];
-            _.fromArray(N.center);
-            for (let O = 0; O < N.splats.length; O++) {
-                let B = N.splats[O],
-                    j = !1;
-                if (B === 0 && (j = !0), this.compressionLevel === 0) {
-                    const J = new Float32Array(f, R * o, 3),
-                        ne = new Float32Array(h, R * l, 3),
-                        ue = new Float32Array(g, R * u, 4);
-                    if (t.scale_0[B] !== void 0) {
-                        const Z = new wt(
-                            t.rot_1[B],
-                            t.rot_2[B],
-                            t.rot_3[B],
-                            t.rot_0[B]
-                        );
-                        Z.normalize(), ue.set([Z.w, Z.x, Z.y, Z.z]), ne.set([t.scale_0[B], t.scale_1[B], t.scale_2[B]]);
-                    } else
-                        ne.set([0.01, 0.01, 0.01]), ue.set([1, 0, 0, 0]);
-                    J.set([t.x[B], t.y[B], t.z[B]]);
-                } else {
-                    const J = new Uint16Array(f, R * o, 3),
-                        ne = new Uint16Array(h, R * l, 3),
-                        ue = new Uint16Array(g, R * u, 4),
-                        Z = $r.toHalfFloat.bind($r);
-                    if (t.scale_0[B] !== void 0) {
-                        const H = new wt(
-                            t.rot_1[B],
-                            t.rot_2[B],
-                            t.rot_3[B],
-                            t.rot_0[B]
+        fillSplatCenterArray(e, t, n, i, r) {
+            const o = this.splatCount;
+            n = n || 0, i = i || o - 1, r === void 0 && (r = n);
+            const a = new D();
+            for (let l = n; l <= i; l++) {
+                const c = this.globalSplatIndexToSectionMap[l],
+                    u = this.sections[c],
+                    d = l - u.splatCountOffset,
+                    f = (l - n + r) * $.CenterComponentCount,
+                    h = u.bytesPerSplat * d,
+                    g = new DataView(this.bufferData, u.dataBase + h),
+                    _ = ct(g, 0, this.compressionLevel),
+                    m = ct(g, 1, this.compressionLevel),
+                    p = ct(g, 2, this.compressionLevel);
+                if (this.compressionLevel >= 1) {
+                    const S = this.getBucketIndex(u, d) * $.BucketStorageSizeFloats,
+                        y = u.compressionScaleFactor,
+                        b = u.compressionScaleRange;
+                    a.x = (_ - b) * y + u.bucketArray[S], a.y = (m - b) * y + u.bucketArray[S + 1], a.z = (p - b) * y + u.bucketArray[S + 2];
+                } else
+                    a.x = _, a.y = m, a.z = p;
+                t && a.applyMatrix4(t), e[f] = a.x, e[f + 1] = a.y, e[f + 2] = a.z;
+            }
+        }
+        fillSplatCovarianceArray(e, t, n, i, r, o) {
+            const a = this.splatCount,
+                l = new D(),
+                c = new St();
+            n = n || 0, i = i || a - 1, r === void 0 && (r = n);
+            for (let u = n; u <= i; u++) {
+                const d = this.globalSplatIndexToSectionMap[u],
+                    f = this.sections[d],
+                    h = u - f.splatCountOffset,
+                    g = (u - n + r) * $.CovarianceComponentCount,
+                    _ = f.bytesPerSplat * h + $.CompressionLevels[this.compressionLevel].ScaleOffsetBytes,
+                    m = new DataView(this.bufferData, f.dataBase + _);
+                l.set(
+                    Tt(ct(m, 0, this.compressionLevel), this.compressionLevel),
+                    Tt(ct(m, 1, this.compressionLevel), this.compressionLevel),
+                    Tt(ct(m, 2, this.compressionLevel), this.compressionLevel)
+                ), c.set(
+                    Tt(ct(m, 4, this.compressionLevel), this.compressionLevel),
+                    Tt(ct(m, 5, this.compressionLevel), this.compressionLevel),
+                    Tt(ct(m, 6, this.compressionLevel), this.compressionLevel),
+                    Tt(ct(m, 3, this.compressionLevel), this.compressionLevel)
+                ), $.computeCovariance(l, c, t, e, g, o);
+            }
+        }
+        fillSplatColorArray(e, t, n, i, r) {
+            const o = this.splatCount;
+            n = n || 0, i = i || o - 1, r === void 0 && (r = n);
+            for (let a = n; a <= i; a++) {
+                const l = this.globalSplatIndexToSectionMap[a],
+                    c = this.sections[l],
+                    u = a - c.splatCountOffset,
+                    d = (a - n + r) * $.ColorComponentCount,
+                    f = c.bytesPerSplat * u + $.CompressionLevels[this.compressionLevel].ColorOffsetBytes,
+                    h = new Uint8Array(this.bufferData, c.dataBase + f);
+                let g = h[3];
+                g = g >= t ? g : 0, e[d] = h[0], e[d + 1] = h[1], e[d + 2] = h[2], e[d + 3] = g;
+            }
+        }
+        static parseHeader(e) {
+            const t = new Uint8Array(e, 0, $.HeaderSizeBytes),
+                n = new Uint16Array(e, 0, $.HeaderSizeBytes / 2),
+                i = new Uint32Array(e, 0, $.HeaderSizeBytes / 4),
+                r = new Float32Array(e, 0, $.HeaderSizeBytes / 4),
+                o = t[0],
+                a = t[1],
+                l = i[1],
+                c = i[2],
+                u = i[3],
+                d = i[4],
+                f = n[10],
+                h = new D(r[6], r[7], r[8]);
+            return {
+                versionMajor: o,
+                versionMinor: a,
+                maxSectionCount: l,
+                sectionCount: c,
+                maxSplatCount: u,
+                splatCount: d,
+                compressionLevel: f,
+                sceneCenter: h
+            };
+        }
+        static writeHeaderCountsToBuffer(e, t, n) {
+            const i = new Uint32Array(n, 0, $.HeaderSizeBytes / 4);
+            i[2] = e, i[4] = t;
+        }
+        static writeHeaderToBuffer(e, t) {
+            const n = new Uint8Array(t, 0, $.HeaderSizeBytes),
+                i = new Uint16Array(t, 0, $.HeaderSizeBytes / 2),
+                r = new Uint32Array(t, 0, $.HeaderSizeBytes / 4),
+                o = new Float32Array(t, 0, $.HeaderSizeBytes / 4);
+            n[0] = e.versionMajor, n[1] = e.versionMinor, n[2] = 0, n[3] = 0, r[1] = e.maxSectionCount, r[2] = e.sectionCount, r[3] = e.maxSplatCount, r[4] = e.splatCount, i[10] = e.compressionLevel, o[6] = e.sceneCenter.x, o[7] = e.sceneCenter.y, o[8] = e.sceneCenter.z;
+        }
+        static parseSectionHeaders(e, t, n = 0, i) {
+            const r = e.compressionLevel,
+                o = e.maxSectionCount,
+                a = new Uint16Array(t, n, o * $.SectionHeaderSizeBytes / 2),
+                l = new Uint32Array(t, n, o * $.SectionHeaderSizeBytes / 4),
+                c = new Float32Array(t, n, o * $.SectionHeaderSizeBytes / 4),
+                u = [];
+            let d = 0,
+                f = d / 2,
+                h = d / 4,
+                g = $.HeaderSizeBytes + e.maxSectionCount * $.SectionHeaderSizeBytes,
+                _ = 0;
+            for (let m = 0; m < o; m++) {
+                const p = l[h + 1],
+                    v = l[h + 2],
+                    S = l[h + 3],
+                    y = c[h + 4],
+                    b = y / 2,
+                    E = a[f + 10],
+                    T = l[h + 6] || $.CompressionLevels[r].ScaleRange,
+                    L = l[h + 8],
+                    B = l[h + 9],
+                    x = B * 4,
+                    A = E * S + x,
+                    U = a[f + 20],
+                    {
+                        bytesPerSplat: N
+                    } = $.calculateComponentStorage(r, U),
+                    P = N * p,
+                    I = P + A,
+                    z = {
+                        bytesPerSplat: N,
+                        splatCountOffset: _,
+                        splatCount: i ? p : 0,
+                        maxSplatCount: p,
+                        bucketSize: v,
+                        bucketCount: S,
+                        bucketBlockSize: y,
+                        halfBucketBlockSize: b,
+                        bucketStorageSizeBytes: E,
+                        bucketsStorageSizeBytes: A,
+                        splatDataStorageSizeBytes: P,
+                        storageSizeBytes: I,
+                        compressionScaleRange: T,
+                        compressionScaleFactor: b / T,
+                        base: g,
+                        bucketsBase: g + x,
+                        dataBase: g + A,
+                        fullBucketCount: L,
+                        partiallyFilledBucketCount: B,
+                        sphericalHarmonicsDegree: U
+                    };
+                u[m] = z, g += I, d += $.SectionHeaderSizeBytes, f = d / 2, h = d / 4, _ += p;
+            }
+            return u;
+        }
+        static writeSectionHeaderToBuffer(e, t, n, i = 0) {
+            const r = new Uint16Array(n, i, $.SectionHeaderSizeBytes / 2),
+                o = new Uint32Array(n, i, $.SectionHeaderSizeBytes / 4),
+                a = new Float32Array(n, i, $.SectionHeaderSizeBytes / 4);
+            o[0] = e.splatCount, o[1] = e.maxSplatCount, o[2] = t >= 1 ? e.bucketSize : 0, o[3] = t >= 1 ? e.bucketCount : 0, a[4] = t >= 1 ? e.bucketBlockSize : 0, r[10] = t >= 1 ? $.BucketStorageSizeBytes : 0, o[6] = t >= 1 ? e.compressionScaleRange : 0, o[7] = e.storageSizeBytes, o[8] = t >= 1 ? e.fullBucketCount : 0, o[9] = t >= 1 ? e.partiallyFilledBucketCount : 0, r[20] = e.sphericalHarmonicsDegree;
+        }
+        static writeSectionHeaderSplatCountToBuffer(e, t, n = 0) {
+            const i = new Uint32Array(t, n, $.SectionHeaderSizeBytes / 4);
+            i[0] = e;
+        }
+        constructFromBuffer(e, t) {
+            this.bufferData = e, this.globalSplatIndexToLocalSplatIndexMap = [], this.globalSplatIndexToSectionMap = [];
+            const n = $.parseHeader(this.bufferData);
+            this.versionMajor = n.versionMajor, this.versionMinor = n.versionMinor, this.maxSectionCount = n.maxSectionCount, this.sectionCount = t ? n.maxSectionCount : 0, this.maxSplatCount = n.maxSplatCount, this.splatCount = t ? n.maxSplatCount : 0, this.compressionLevel = n.compressionLevel, this.sceneCenter = new D().copy(n.sceneCenter), this.sections = $.parseSectionHeaders(n, this.bufferData, $.HeaderSizeBytes, t), this.linkBufferArrays(), this.buildMaps();
+        }
+        static calculateComponentStorage(e, t) {
+            const n = $.CompressionLevels[e].BytesPerCenter,
+                i = $.CompressionLevels[e].BytesPerScale,
+                r = $.CompressionLevels[e].BytesPerRotation,
+                o = $.CompressionLevels[e].BytesPerColor,
+                a = Us(t),
+                l = $.CompressionLevels[e].BytesPerSphericalHarmonicsComponent * a,
+                c = n + i + r + o + l;
+            return {
+                bytesPerCenter: n,
+                bytesPerScale: i,
+                bytesPerRotation: r,
+                bytesPerColor: o,
+                sphericalHarmonicsComponentsPerSplat: a,
+                sphericalHarmonicsBytesPerSplat: l,
+                bytesPerSplat: c
+            };
+        }
+        linkBufferArrays() {
+            for (let e = 0; e < this.maxSectionCount; e++) {
+                const t = this.sections[e];
+                t.bucketArray = new Float32Array(
+                    this.bufferData,
+                    t.bucketsBase,
+                    t.bucketCount * $.BucketStorageSizeFloats
+                ), t.partiallyFilledBucketCount > 0 && (t.partiallyFilledBucketLengths = new Uint32Array(
+                    this.bufferData,
+                    t.base,
+                    t.partiallyFilledBucketCount
+                ));
+            }
+        }
+        buildMaps() {
+            let e = 0;
+            for (let t = 0; t < this.maxSectionCount; t++) {
+                const n = this.sections[t];
+                for (let i = 0; i < n.maxSplatCount; i++) {
+                    const r = e + i;
+                    this.globalSplatIndexToLocalSplatIndexMap[r] = i, this.globalSplatIndexToSectionMap[r] = t;
+                }
+                e += n.maxSplatCount;
+            }
+        }
+        updateLoadedCounts(e, t) {
+            $.writeHeaderCountsToBuffer(e, t, this.bufferData), this.sectionCount = e, this.splatCount = t;
+        }
+        updateSectionLoadedCounts(e, t) {
+            const n = $.HeaderSizeBytes + $.SectionHeaderSizeBytes * e;
+            $.writeSectionHeaderSplatCountToBuffer(t, this.bufferData, n), this.sections[e].splatCount = t;
+        }
+        static generateFromUncompressedSplatArrays(e, t, n, i, r, o, a = []) {
+            const l = (A, U, N, P, I = 0) => {
+                const z = new Uint8Array(A, U),
+                    K = new Uint8Array(N, P);
+                for (let G = 0; G < I; G++)
+                    K[G] = z[G];
+            };
+            let c = 0;
+            for (let A = 0; A < e.length; A++) {
+                const U = e[A];
+                if (A === 0 || U.sphericalHarmonicsDegree < c) {
+                    if (A > 0 && U.sphericalHarmonicsDegree !== c) {
+                        const N = "SplatBuffer::generateFromUncompressedSplatArrays() -> all splat arrays must have the same spherical harmonics degree.";
+                        throw new Error(N);
+                    }
+                    c = U.sphericalHarmonicsDegree;
+                }
+            }
+            const {
+                bytesPerCenter: u,
+                bytesPerScale: d,
+                bytesPerRotation: f,
+                bytesPerColor: h,
+                sphericalHarmonicsComponentsPerSplat: g,
+                sphericalHarmonicsBytesPerSplat: _,
+                bytesPerSplat: m
+            } = $.calculateComponentStorage(n, c), p = $.CompressionLevels[n].ScaleRange, v = [], S = [];
+            let y = 0;
+            const b = new St();
+            for (let A = 0; A < e.length; A++) {
+                const U = e[A],
+                    N = a[A] || {},
+                    P = (N.blockSizeFactor || 1) * (r || $.BucketBlockSize),
+                    I = Math.ceil((N.bucketSizeFactor || 1) * (o || $.BucketSize)),
+                    z = new ee(c);
+                for (let we = 0; we < U.splatCount; we++) {
+                    const Ke = U.splats[we];
+                    let w;
+                    Ke[ee.OFFSET.OPACITY] ? w = Ke[ee.OFFSET.OPACITY] : w = 255, w >= t && z.addSplat(Ke);
+                }
+                const K = $.computeBucketsForUncompressedSplatArray(z, P, I),
+                    G = K.fullBuckets.length,
+                    q = K.partiallyFullBuckets.map((we) => we.splats.length),
+                    Q = q.length,
+                    te = [...K.fullBuckets, ...K.partiallyFullBuckets],
+                    fe = z.splats.length * m,
+                    ne = Q * 4,
+                    V = n >= 1 ? te.length * $.BucketStorageSizeBytes + ne : 0,
+                    J = fe + V,
+                    se = new ArrayBuffer(J),
+                    Ae = P / 2,
+                    xe = p / Ae,
+                    ge = p * 2 + 1,
+                    Qe = new ArrayBuffer(u),
+                    Re = new ArrayBuffer(d),
+                    O = new ArrayBuffer(f),
+                    Je = new ArrayBuffer(h),
+                    Te = new ArrayBuffer(_),
+                    Ie = new D(),
+                    Me = new D();
+                let ze = 0;
+                for (let we = 0; we < te.length; we++) {
+                    const Ke = te[we];
+                    Ie.fromArray(Ke.center);
+                    for (let w = 0; w < Ke.splats.length; w++) {
+                        let M = Ke.splats[w];
+                        const k = z.splats[M],
+                            Z = V + ze * m,
+                            re = Z + u,
+                            ie = re + d,
+                            Be = ie + f,
+                            Pe = Be + h;
+                        if (n === 0) {
+                            const de = new Float32Array(se, Z, $.CenterComponentCount),
+                                De = new Float32Array(se, ie, $.RotationComponentCount),
+                                R = new Float32Array(se, re, $.ScaleComponentCount);
+                            if (k[ee.OFFSET.SCALE0] !== void 0 ? (b.set(
+                                    k[ee.OFFSET.ROTATION0],
+                                    k[ee.OFFSET.ROTATION1],
+                                    k[ee.OFFSET.ROTATION2],
+                                    k[ee.OFFSET.ROTATION3]
+                                ), b.normalize(), De.set([b.x, b.y, b.z, b.w]), R.set([
+                                    k[ee.OFFSET.SCALE0],
+                                    k[ee.OFFSET.SCALE1],
+                                    k[ee.OFFSET.SCALE2]
+                                ])) : (De.set([1, 0, 0, 0]), R.set([0.01, 0.01, 0.01])), de.set([
+                                    k[ee.OFFSET.X],
+                                    k[ee.OFFSET.Y],
+                                    k[ee.OFFSET.Z]
+                                ]), c > 0) {
+                                const ue = new Float32Array(se, Pe, g);
+                                if (c >= 1) {
+                                    for (let Se = 0; Se < 9; Se++)
+                                        ue[Se] = k[ee.OFFSET.FRC0 + Se];
+                                    if (c >= 2)
+                                        for (let Se = 0; Se < 15; Se++)
+                                            ue[Se + 9] = k[ee.OFFSET.FRC9 + Se];
+                                }
+                            }
+                        } else {
+                            const de = new Uint16Array(Qe, 0, $.CenterComponentCount),
+                                De = new Uint16Array(O, 0, $.RotationComponentCount),
+                                R = new Uint16Array(Re, 0, $.ScaleComponentCount);
+                            if (k[ee.OFFSET.SCALE0] !== void 0 ? (b.set(
+                                    k[ee.OFFSET.ROTATION0],
+                                    k[ee.OFFSET.ROTATION1],
+                                    k[ee.OFFSET.ROTATION2],
+                                    k[ee.OFFSET.ROTATION3]
+                                ), b.normalize(), De.set([
+                                    gt(b.x),
+                                    gt(b.y),
+                                    gt(b.z),
+                                    gt(b.w)
+                                ]), R.set([
+                                    gt(k[ee.OFFSET.SCALE0]),
+                                    gt(k[ee.OFFSET.SCALE1]),
+                                    gt(k[ee.OFFSET.SCALE2])
+                                ])) : (De.set([gt(1), 0, 0, 0]), R.set([gt(0.01), gt(0.01), gt(0.01)])), Me.set(
+                                    k[ee.OFFSET.X],
+                                    k[ee.OFFSET.Y],
+                                    k[ee.OFFSET.Z]
+                                ).sub(Ie), Me.x = Math.round(Me.x * xe) + p, Me.x = qt(Me.x, 0, ge), Me.y = Math.round(Me.y * xe) + p, Me.y = qt(Me.y, 0, ge), Me.z = Math.round(Me.z * xe) + p, Me.z = qt(Me.z, 0, ge), de.set([Me.x, Me.y, Me.z]), c > 0) {
+                                const ue = n === 1 ? Uint16Array : Uint8Array,
+                                    Se = n === 1 ? 2 : 1,
+                                    me = new ue(Te, 0, g);
+                                if (c >= 1) {
+                                    for (let ve = 0; ve < 9; ve++) {
+                                        const Le = k[ee.OFFSET.FRC0 + ve];
+                                        me[ve] = n === 1 ? gt(Le) : gr(Le);
+                                    }
+                                    const _e = 9 * Se;
+                                    if (l(me.buffer, 0, se, Pe, _e), c >= 2) {
+                                        for (let Le = 0; Le < 15; Le++) {
+                                            const Ne = k[ee.OFFSET.FRC9 + Le];
+                                            me[Le + 9] = n === 1 ? gt(Ne) : gr(Ne);
+                                        }
+                                        const ve = 15 * Se;
+                                        l(
+                                            me.buffer,
+                                            _e,
+                                            se,
+                                            Pe + _e,
+                                            ve
+                                        );
+                                    }
+                                }
+                            }
+                            l(de.buffer, 0, se, Z, 6), l(R.buffer, 0, se, re, 6), l(De.buffer, 0, se, ie, 8);
+                        }
+                        const oe = new Uint8ClampedArray(Je, 0, 4);
+                        k[ee.OFFSET.FDC0] !== void 0 ? oe.set([
+                            k[ee.OFFSET.FDC0],
+                            k[ee.OFFSET.FDC1],
+                            k[ee.OFFSET.FDC2]
+                        ]) : oe.set([255, 0, 0]), k[ee.OFFSET.OPACITY] !== void 0 ? oe[3] = k[ee.OFFSET.OPACITY] : oe[3] = 255, l(oe.buffer, 0, se, Be, 4), ze++;
+                    }
+                }
+                if (y += ze, n >= 1) {
+                    const we = new Uint32Array(se, 0, q.length * 4);
+                    for (let w = 0; w < q.length; w++)
+                        we[w] = q[w];
+                    const Ke = new Float32Array(
+                        se,
+                        ne,
+                        te.length * $.BucketStorageSizeFloats
+                    );
+                    for (let w = 0; w < te.length; w++) {
+                        const M = te[w],
+                            k = w * 3;
+                        Ke[k] = M.center[0], Ke[k + 1] = M.center[1], Ke[k + 2] = M.center[2];
+                    }
+                }
+                v.push(se);
+                const Oe = new ArrayBuffer($.SectionHeaderSizeBytes);
+                $.writeSectionHeaderToBuffer({
+                    maxSplatCount: ze,
+                    splatCount: ze,
+                    bucketSize: I,
+                    bucketCount: te.length,
+                    bucketBlockSize: P,
+                    compressionScaleRange: p,
+                    storageSizeBytes: J,
+                    fullBucketCount: G,
+                    partiallyFilledBucketCount: Q,
+                    sphericalHarmonicsDegree: c
+                }, n, Oe, 0), S.push(Oe);
+            }
+            let E = 0;
+            for (let A of v)
+                E += A.byteLength;
+            const T = $.HeaderSizeBytes + $.SectionHeaderSizeBytes * v.length + E,
+                L = new ArrayBuffer(T);
+            $.writeHeaderToBuffer({
+                versionMajor: 0,
+                versionMinor: 1,
+                maxSectionCount: v.length,
+                sectionCount: v.length,
+                maxSplatCount: y,
+                splatCount: y,
+                compressionLevel: n,
+                sceneCenter: i
+            }, L);
+            let B = $.HeaderSizeBytes;
+            for (let A of S)
+                new Uint8Array(L, B, $.SectionHeaderSizeBytes).set(new Uint8Array(A)), B += $.SectionHeaderSizeBytes;
+            for (let A of v)
+                new Uint8Array(L, B, A.byteLength).set(new Uint8Array(A)), B += A.byteLength;
+            return new $(L);
+        }
+        static computeBucketsForUncompressedSplatArray(e, t, n) {
+            let i = e.splatCount;
+            const r = t / 2,
+                o = new D(),
+                a = new D();
+            for (let _ = 0; _ < i; _++) {
+                const m = e.splats[_],
+                    p = [
+                        m[ee.OFFSET.X],
+                        m[ee.OFFSET.Y],
+                        m[ee.OFFSET.Z]
+                    ];
+                (_ === 0 || p[0] < o.x) && (o.x = p[0]), (_ === 0 || p[0] > a.x) && (a.x = p[0]), (_ === 0 || p[1] < o.y) && (o.y = p[1]), (_ === 0 || p[1] > a.y) && (a.y = p[1]), (_ === 0 || p[2] < o.z) && (o.z = p[2]), (_ === 0 || p[2] > a.z) && (a.z = p[2]);
+            }
+            const l = new D().copy(a).sub(o),
+                c = Math.ceil(l.y / t),
+                u = Math.ceil(l.z / t),
+                d = new D(),
+                f = [],
+                h = {};
+            for (let _ = 0; _ < i; _++) {
+                const m = e.splats[_],
+                    p = [
+                        m[ee.OFFSET.X],
+                        m[ee.OFFSET.Y],
+                        m[ee.OFFSET.Z]
+                    ],
+                    v = Math.floor((p[0] - o.x) / t),
+                    S = Math.floor((p[1] - o.y) / t),
+                    y = Math.floor((p[2] - o.z) / t);
+                d.x = v * t + o.x + r, d.y = S * t + o.y + r, d.z = y * t + o.z + r;
+                const b = v * (c * u) + S * u + y;
+                let E = h[b];
+                E || (h[b] = E = {
+                    splats: [],
+                    center: d.toArray()
+                }), E.splats.push(_), E.splats.length >= n && (f.push(E), h[b] = null);
+            }
+            const g = [];
+            for (let _ in h)
+                if (h.hasOwnProperty(_)) {
+                    const m = h[_];
+                    m && g.push(m);
+                }
+            return {
+                fullBuckets: f,
+                partiallyFullBuckets: g
+            };
+        }
+    };
+le($, "CurrentMajorVersion", 0), le($, "CurrentMinorVersion", 1), le($, "CenterComponentCount", 3), le($, "ScaleComponentCount", 3), le($, "RotationComponentCount", 4), le($, "ColorComponentCount", 4), le($, "CovarianceComponentCount", 6), le($, "SplatScaleOffsetFloat", 3), le($, "SplatRotationOffsetFloat", 6), le($, "CompressionLevels", {
+    0: {
+        BytesPerCenter: 12,
+        BytesPerScale: 12,
+        BytesPerRotation: 16,
+        BytesPerColor: 4,
+        ScaleOffsetBytes: 12,
+        RotationffsetBytes: 24,
+        ColorOffsetBytes: 40,
+        SphericalHarmonicsOffsetBytes: 44,
+        ScaleRange: 1,
+        BytesPerSphericalHarmonicsComponent: 4,
+        SphericalHarmonicsOffsetFloat: 11,
+        SphericalHarmonicsDegrees: {
+            0: {
+                BytesPerSplat: 44
+            },
+            1: {
+                BytesPerSplat: 80
+            },
+            2: {
+                BytesPerSplat: 140
+            }
+        }
+    },
+    1: {
+        BytesPerCenter: 6,
+        BytesPerScale: 6,
+        BytesPerRotation: 8,
+        BytesPerColor: 4,
+        ScaleOffsetBytes: 6,
+        RotationffsetBytes: 12,
+        ColorOffsetBytes: 20,
+        SphericalHarmonicsOffsetBytes: 24,
+        ScaleRange: 32767,
+        BytesPerSphericalHarmonicsComponent: 2,
+        SphericalHarmonicsOffsetFloat: 12,
+        SphericalHarmonicsDegrees: {
+            0: {
+                BytesPerSplat: 24
+            },
+            1: {
+                BytesPerSplat: 42
+            },
+            2: {
+                BytesPerSplat: 72
+            }
+        }
+    },
+    2: {
+        BytesPerCenter: 6,
+        BytesPerScale: 6,
+        BytesPerRotation: 8,
+        BytesPerColor: 4,
+        ScaleOffsetBytes: 6,
+        RotationffsetBytes: 12,
+        ColorOffsetBytes: 20,
+        SphericalHarmonicsOffsetBytes: 24,
+        ScaleRange: 32767,
+        BytesPerSphericalHarmonicsComponent: 1,
+        SphericalHarmonicsOffsetFloat: 12,
+        SphericalHarmonicsDegrees: {
+            0: {
+                BytesPerSplat: 24
+            },
+            1: {
+                BytesPerSplat: 33
+            },
+            2: {
+                BytesPerSplat: 48
+            }
+        }
+    }
+}), le($, "CovarianceSizeFloats", 6), le($, "HeaderSizeBytes", 4096), le($, "SectionHeaderSizeBytes", 1024), le($, "BucketStorageSizeBytes", 12), le($, "BucketStorageSizeFloats", 3), le($, "BucketBlockSize", 5), le($, "BucketSize", 256), le($, "computeCovariance", function() {
+    const e = new Ge(),
+        t = new Ue(),
+        n = new Ue(),
+        i = new Ue(),
+        r = new Ue(),
+        o = new Ue(),
+        a = new Ue();
+    return function(l, c, u, d, f = 0, h) {
+        e.makeScale(l.x, l.y, l.z), t.setFromMatrix4(e), e.makeRotationFromQuaternion(c), n.setFromMatrix4(e), i.copy(n).multiply(t), r.copy(i).transpose().premultiply(i), u && (o.setFromMatrix4(u), a.copy(o).transpose(), r.multiply(a), r.premultiply(o)), h >= 1 ? (d[f] = gt(r.elements[0]), d[f + 1] = gt(r.elements[3]), d[f + 2] = gt(r.elements[6]), d[f + 3] = gt(r.elements[4]), d[f + 4] = gt(r.elements[7]), d[f + 5] = gt(r.elements[8])) : (d[f] = r.elements[0], d[f + 1] = r.elements[3], d[f + 2] = r.elements[6], d[f + 3] = r.elements[4], d[f + 4] = r.elements[7], d[f + 5] = r.elements[8]);
+    };
+}()), le($, "dot3", (e, t, n, i, r) => {
+    r[0] = r[1] = r[2] = 0;
+    const o = i[0],
+        a = i[1],
+        l = i[2];
+    $.addInto3(e[0] * o, e[1] * o, e[2] * o, r), $.addInto3(t[0] * a, t[1] * a, t[2] * a, r), $.addInto3(n[0] * l, n[1] * l, n[2] * l, r);
+}), le($, "addInto3", (e, t, n, i) => {
+    i[0] = i[0] + e, i[1] = i[1] + t, i[2] = i[2] + n;
+}), le($, "dot5", (e, t, n, i, r, o, a) => {
+    a[0] = a[1] = a[2] = 0;
+    const l = o[0],
+        c = o[1],
+        u = o[2],
+        d = o[3],
+        f = o[4];
+    $.addInto3(e[0] * l, e[1] * l, e[2] * l, a), $.addInto3(t[0] * c, t[1] * c, t[2] * c, a), $.addInto3(n[0] * u, n[1] * u, n[2] * u, a), $.addInto3(i[0] * d, i[1] * d, i[2] * d, a), $.addInto3(r[0] * f, r[1] * f, r[2] * f, a);
+}), le($, "rotateSphericalHarmonics3", (e, t, n, i, r, o, a, l, c) => {
+    $.dot3(e, t, n, i, a), $.dot3(e, t, n, r, l), $.dot3(e, t, n, o, c);
+}), le($, "rotateSphericalHarmonics5", (e, t, n, i, r, o, a, l, c, u, d, f, h, g, _, m, p, v) => {
+    const S = Math.sqrt(0.25),
+        y = Math.sqrt(3 / 4),
+        b = Math.sqrt(1 / 3),
+        E = Math.sqrt(4 / 3),
+        T = Math.sqrt(1 / 12);
+    c[0] = S * (l[2] * o[0] + l[0] * o[2] + (o[2] * l[0] + o[0] * l[2])), c[1] = l[1] * o[0] + o[1] * l[0], c[2] = y * (l[1] * o[1] + o[1] * l[1]), c[3] = l[1] * o[2] + o[1] * l[2], c[4] = S * (l[2] * o[2] - l[0] * o[0] + (o[2] * l[2] - o[0] * l[0])), $.dot5(e, t, n, i, r, c, g), u[0] = S * (a[2] * o[0] + a[0] * o[2] + (o[2] * a[0] + o[0] * a[2])), u[1] = a[1] * o[0] + o[1] * a[0], u[2] = y * (a[1] * o[1] + o[1] * a[1]), u[3] = a[1] * o[2] + o[1] * a[2], u[4] = S * (a[2] * o[2] - a[0] * o[0] + (o[2] * a[2] - o[0] * a[0])), $.dot5(e, t, n, i, r, u, _), d[0] = b * (a[2] * a[0] + a[0] * a[2]) + -T * (l[2] * l[0] + l[0] * l[2] + (o[2] * o[0] + o[0] * o[2])), d[1] = E * a[1] * a[0] + -b * (l[1] * l[0] + o[1] * o[0]), d[2] = a[1] * a[1] + -S * (l[1] * l[1] + o[1] * o[1]), d[3] = E * a[1] * a[2] + -b * (l[1] * l[2] + o[1] * o[2]), d[4] = b * (a[2] * a[2] - a[0] * a[0]) + -T * (l[2] * l[2] - l[0] * l[0] + (o[2] * o[2] - o[0] * o[0])), $.dot5(e, t, n, i, r, d, m), f[0] = S * (a[2] * l[0] + a[0] * l[2] + (l[2] * a[0] + l[0] * a[2])), f[1] = a[1] * l[0] + l[1] * a[0], f[2] = y * (a[1] * l[1] + l[1] * a[1]), f[3] = a[1] * l[2] + l[1] * a[2], f[4] = S * (a[2] * l[2] - a[0] * l[0] + (l[2] * a[2] - l[0] * a[0])), $.dot5(e, t, n, i, r, f, p), h[0] = S * (l[2] * l[0] + l[0] * l[2] - (o[2] * o[0] + o[0] * o[2])), h[1] = l[1] * l[0] - o[1] * o[0], h[2] = y * (l[1] * l[1] - o[1] * o[1]), h[3] = l[1] * l[2] - o[1] * o[2], h[4] = S * (l[2] * l[2] - l[0] * l[0] - (o[2] * o[2] - o[0] * o[0])), $.dot5(e, t, n, i, r, h, v);
+});
+let be = $;
+const Xl = new Uint8Array([112, 108, 121, 10]),
+    ql = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]),
+    Ta = "end_header",
+    ba = /* @__PURE__ */ new Map([
+        ["char", Int8Array],
+        ["uchar", Uint8Array],
+        ["short", Int16Array],
+        ["ushort", Uint16Array],
+        ["int", Int32Array],
+        ["uint", Uint32Array],
+        ["float", Float32Array],
+        ["double", Float64Array]
+    ]),
+    Sn = (s, e) => {
+        const t = (1 << e) - 1;
+        return (s & t) / t;
+    },
+    Yl = (s, e) => {
+        s.x = Sn(e >>> 21, 11), s.y = Sn(e >>> 11, 10), s.z = Sn(e, 11);
+    },
+    a_ = (s, e) => {
+        s.x = Sn(e >>> 24, 8), s.y = Sn(e >>> 16, 8), s.z = Sn(e >>> 8, 8), s.w = Sn(e, 8);
+    },
+    o_ = (s, e) => {
+        const t = 1 / (Math.sqrt(2) * 0.5),
+            n = (Sn(e >>> 20, 10) - 0.5) * t,
+            i = (Sn(e >>> 10, 10) - 0.5) * t,
+            r = (Sn(e, 10) - 0.5) * t,
+            o = Math.sqrt(1 - (n * n + i * i + r * r));
+        switch (e >>> 30) {
+            case 0:
+                s.set(o, n, i, r);
+                break;
+            case 1:
+                s.set(n, o, i, r);
+                break;
+            case 2:
+                s.set(n, i, o, r);
+                break;
+            case 3:
+                s.set(n, i, r, o);
+                break;
+        }
+    },
+    Xi = (s, e, t) => s * (1 - t) + e * t,
+    Dt = (s, e) => {
+        var t;
+        return (t = s.properties.find((n) => n.name === e && n.storage)) == null ? void 0 : t.storage;
+    },
+    Xt = class Xt {
+        static decodeHeaderText(e) {
+            let t, n, i;
+            const r = e.split(`
+`).filter((l) => !l.startsWith("comment "));
+            let o = 0,
+                a = !1;
+            for (let l = 1; l < r.length; ++l) {
+                const c = r[l].split(" ");
+                switch (c[0]) {
+                    case "format":
+                        if (c[1] !== "binary_little_endian")
+                            throw new Error("Unsupported ply format");
+                        break;
+                    case "element":
+                        t = {
+                            name: c[1],
+                            count: parseInt(c[2], 10),
+                            properties: [],
+                            storageSizeBytes: 0
+                        }, t.name === "chunk" ? n = t : t.name === "vertex" && (i = t);
+                        break;
+                    case "property": {
+                        if (!ba.has(c[1]))
+                            throw new Error(
+                                `Unrecognized property data type '${c[1]}' in ply header`
+                            );
+                        const u = ba.get(c[1]),
+                            d = u.BYTES_PER_ELEMENT * t.count;
+                        t.name === "vertex" && (o += u.BYTES_PER_ELEMENT), t.properties.push({
+                            type: c[1],
+                            name: c[2],
+                            storage: null,
+                            byteSize: u.BYTES_PER_ELEMENT,
+                            storageSizeByes: d
+                        }), t.storageSizeBytes += d;
+                        break;
+                    }
+                    case Ta:
+                        a = !0;
+                        break;
+                    default:
+                        throw new Error(
+                            `Unrecognized header value '${c[0]}' in ply header`
                         );
-                        H.normalize(), ue.set([Z(H.w), Z(H.x), Z(H.y), Z(H.z)]), ne.set([Z(t.scale_0[B]), Z(t.scale_1[B]), Z(t.scale_2[B])]);
-                    } else
-                        ne.set([Z(0.01), Z(0.01), Z(0.01)]), ue.set([Z(1), 0, 0, 0]);
-                    A.set(t.x[B], t.y[B], t.z[B]).sub(_), A.x = Math.round(A.x * d) + m, A.x = Ks(A.x, 0, M), A.y = Math.round(A.y * d) + m, A.y = Ks(A.y, 0, M), A.z = Math.round(A.z * d) + m, A.z = Ks(A.z, 0, M), J.set([A.x, A.y, A.z]);
                 }
-                const q = new Uint8ClampedArray(p, R * c, 4);
-                j ? (q[0] = 255, q[1] = 0, q[2] = 0, q[3] = 0) : (t.f_dc_0[B] !== void 0 ? q.set([t.f_dc_0[B], t.f_dc_1[B], t.f_dc_2[B]]) : q.set([255, 0, 0]), t.opacity[B] !== void 0 ? q[3] = t.opacity[B] : q[3] = 255), R++;
+                if (a)
+                    break;
             }
+            return {
+                chunkElement: n,
+                vertexElement: i,
+                bytesPerSplat: o,
+                headerSizeBytes: e.indexOf(Ta) + Ta.length + 1
+            };
         }
-        const E = 12,
-            b = E * n.length,
-            I = f.byteLength + h.byteLength + p.byteLength + g.byteLength,
-            W = new Uint32Array(a.buffer),
-            S = new Float32Array(a.buffer);
-        let T = s + I;
-        this.compressionLevel > 0 && (T += b, W[2] = this.bucketSize, W[3] = n.length, S[4] = this.blockSize, W[5] = E, W[6] = $t.CompressionLevels[this.compressionLevel].ScaleRange);
-        const Y = new ArrayBuffer(T);
-        if (new Uint8Array(Y, 0, s).set(a), new Uint8Array(Y, s, f.byteLength).set(new Uint8Array(f)), new Uint8Array(Y, s + f.byteLength, h.byteLength).set(new Uint8Array(h)), new Uint8Array(
-                Y,
-                s + f.byteLength + h.byteLength,
-                p.byteLength
-            ).set(new Uint8Array(p)), new Uint8Array(
-                Y,
-                s + f.byteLength + h.byteLength + p.byteLength,
-                g.byteLength
-            ).set(new Uint8Array(g)), this.compressionLevel > 0) {
-            const L = new Float32Array(Y, s + I, n.length * 3);
-            for (let N = 0; N < n.length; N++) {
-                const O = n[N],
-                    B = N * 3;
-                L[B] = O.center[0], L[B + 1] = O.center[1], L[B + 2] = O.center[2];
-            }
-        }
-        return new $t(Y);
-    }
-    computeBucketsForUncompressedSplatArray(e) {
-        let t = e.splatCount;
-        const n = this.blockSize,
-            r = n / 2,
-            s = new P(),
-            a = new P();
-        for (let p = 1; p < t; p++) {
-            const g = [e.x[p], e.y[p], e.z[p]];
-            (p === 0 || g[0] < s.x) && (s.x = g[0]), (p === 0 || g[0] > a.x) && (a.x = g[0]), (p === 0 || g[1] < s.y) && (s.y = g[1]), (p === 0 || g[1] > a.y) && (a.y = g[1]), (p === 0 || g[2] < s.z) && (s.z = g[2]), (p === 0 || g[2] > a.z) && (a.z = g[2]);
-        }
-        const o = new P().copy(a).sub(s),
-            l = Math.ceil(o.y / n),
-            c = Math.ceil(o.z / n),
-            u = new P(),
-            f = [],
-            h = {};
-        for (let p = 1; p < t; p++) {
-            const g = [e.x[p], e.y[p], e.z[p]],
-                v = Math.ceil((g[0] - s.x) / n),
-                m = Math.ceil((g[1] - s.y) / n),
-                d = Math.ceil((g[2] - s.z) / n);
-            u.x = (v - 1) * n + s.x + r, u.y = (m - 1) * n + s.y + r, u.z = (d - 1) * n + s.z + r;
-            const M = v * (l * c) + m * c + d;
-            let _ = h[M];
-            _ || (h[M] = _ = {
-                splats: [],
-                center: u.toArray()
-            }), _.splats.push(p), _.splats.length >= this.bucketSize && (f.push(_), h[M] = null);
-        }
-        for (let p in h)
-            if (h.hasOwnProperty(p)) {
-                const g = h[p];
-                if (g) {
-                    for (; g.splats.length < this.bucketSize;)
-                        g.splats.push(0);
-                    f.push(g);
+        static decodeHeader(e) {
+            const t = (u, d) => {
+                    const f = u.length - d.length;
+                    let h, g;
+                    for (h = 0; h <= f; ++h) {
+                        for (g = 0; g < d.length && u[h + g] === d[g]; ++g)
+                        ;
+                        if (g === d.length)
+                            return h;
+                    }
+                    return -1;
+                },
+                n = (u, d) => {
+                    if (u.length < d.length)
+                        return !1;
+                    for (let f = 0; f < d.length; ++f)
+                        if (u[f] !== d[f])
+                            return !1;
+                    return !0;
+                };
+            let i = new Uint8Array(e),
+                r;
+            if (i.length >= Xl.length && !n(i, Xl))
+                throw new Error("Invalid PLY header");
+            if (r = t(i, ql), r === -1)
+                throw new Error("End of PLY header not found");
+            const o = new TextDecoder("ascii").decode(
+                    i.slice(0, r)
+                ),
+                {
+                    chunkElement: a,
+                    vertexElement: l,
+                    bytesPerSplat: c
+                } = Xt.decodeHeaderText(o);
+            return {
+                headerSizeBytes: r + ql.length,
+                bytesPerSplat: c,
+                chunkElement: a,
+                vertexElement: l
+            };
+        }
+        static readElementData(e, t, n, i, r, o = null) {
+            let a = t instanceof DataView ? t : new DataView(t);
+            i = i || 0, r = r || e.count - 1;
+            for (let l = i; l <= r; ++l)
+                for (let c = 0; c < e.properties.length; ++c) {
+                    const u = e.properties[c],
+                        d = ba.get(u.type),
+                        f = d.BYTES_PER_ELEMENT * e.count;
+                    if ((!u.storage || u.storage.byteLength < f) && (!o || o(u.name)) && (u.storage = new d(e.count)), u.storage)
+                        switch (u.type) {
+                            case "char":
+                                u.storage[l] = a.getInt8(n);
+                                break;
+                            case "uchar":
+                                u.storage[l] = a.getUint8(n);
+                                break;
+                            case "short":
+                                u.storage[l] = a.getInt16(n, !0);
+                                break;
+                            case "ushort":
+                                u.storage[l] = a.getUint16(n, !0);
+                                break;
+                            case "int":
+                                u.storage[l] = a.getInt32(n, !0);
+                                break;
+                            case "uint":
+                                u.storage[l] = a.getUint32(n, !0);
+                                break;
+                            case "float":
+                                u.storage[l] = a.getFloat32(n, !0);
+                                break;
+                            case "double":
+                                u.storage[l] = a.getFloat64(n, !0);
+                                break;
+                        }
+                    n += u.byteSize;
                 }
+            return n;
+        }
+        static readPly(e, t = null) {
+            const n = Xt.decodeHeader(e);
+            let i = Xt.readElementData(n.chunkElement, e, n.headerSizeBytes, null, null, t);
+            return Xt.readElementData(n.vertexElement, e, i, null, null, t), {
+                chunkElement: n.chunkElement,
+                vertexElement: n.vertexElement
+            };
+        }
+        static getElementStorageArrays(e, t) {
+            const n = Dt(e, "min_x"),
+                i = Dt(e, "min_y"),
+                r = Dt(e, "min_z"),
+                o = Dt(e, "max_x"),
+                a = Dt(e, "max_y"),
+                l = Dt(e, "max_z"),
+                c = Dt(e, "min_scale_x"),
+                u = Dt(e, "min_scale_y"),
+                d = Dt(e, "min_scale_z"),
+                f = Dt(e, "max_scale_x"),
+                h = Dt(e, "max_scale_y"),
+                g = Dt(e, "max_scale_z"),
+                _ = Dt(t, "packed_position"),
+                m = Dt(t, "packed_rotation"),
+                p = Dt(t, "packed_scale"),
+                v = Dt(t, "packed_color");
+            return {
+                positionExtremes: {
+                    minX: n,
+                    maxX: o,
+                    minY: i,
+                    maxY: a,
+                    minZ: r,
+                    maxZ: l
+                },
+                scaleExtremes: {
+                    minScaleX: c,
+                    maxScaleX: f,
+                    minScaleY: u,
+                    maxScaleY: h,
+                    minScaleZ: d,
+                    maxScaleZ: g
+                },
+                position: _,
+                rotation: m,
+                scale: p,
+                color: v
+            };
+        }
+        static parseToUncompressedSplatBufferSection(e, t, n, i, r, o, a, l, c, u = null) {
+            Xt.readElementData(t, o, a, n, i, u);
+            const d = be.CompressionLevels[0].BytesPerCenter,
+                f = be.CompressionLevels[0].BytesPerScale,
+                h = be.CompressionLevels[0].BytesPerRotation,
+                g = be.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,
+                {
+                    positionExtremes: _,
+                    scaleExtremes: m,
+                    position: p,
+                    rotation: v,
+                    scale: S,
+                    color: y
+                } = Xt.getElementStorageArrays(e, t),
+                b = ee.OFFSET,
+                E = ee.createSplat();
+            for (let T = n; T <= i; ++T) {
+                Xt.decompressSplat(
+                    T,
+                    r,
+                    p,
+                    _,
+                    S,
+                    m,
+                    v,
+                    y,
+                    E
+                );
+                const L = T * g + c,
+                    B = new Float32Array(l, L, 3),
+                    x = new Float32Array(l, L + d, 3),
+                    A = new Float32Array(l, L + d + f, 4),
+                    U = new Uint8Array(l, L + d + f + h, 4);
+                B[0] = E[b.X], B[1] = E[b.Y], B[2] = E[b.Z], x[0] = E[b.SCALE0], x[1] = E[b.SCALE1], x[2] = E[b.SCALE2], A[0] = E[b.ROTATION0], A[1] = E[b.ROTATION1], A[2] = E[b.ROTATION2], A[3] = E[b.ROTATION3], U[0] = E[b.FDC0], U[1] = E[b.FDC1], U[2] = E[b.FDC2], U[3] = E[b.OPACITY];
             }
-        return f;
+        }
+        static parseToUncompressedSplatArray(e) {
+            const {
+                chunkElement: t,
+                vertexElement: n
+            } = Xt.readPly(e), i = new ee(), {
+                positionExtremes: r,
+                scaleExtremes: o,
+                position: a,
+                rotation: l,
+                scale: c,
+                color: u
+            } = Xt.getElementStorageArrays(t, n);
+            for (let f = 0; f < n.count; ++f) {
+                i.addDefaultSplat();
+                const h = i.getSplat(i.splatCount - 1);
+                Xt.decompressSplat(f, 0, a, r, c, o, l, u, h);
+            }
+            return new Ge().identity(), i;
+        }
+    };
+le(Xt, "decompressSplat", function() {
+    const e = new D(),
+        t = new St(),
+        n = new D(),
+        i = new _t(),
+        r = ee.OFFSET;
+    return function(o, a, l, c, u, d, f, h, g) {
+        g = g || ee.createSplat();
+        const _ = Math.floor((a + o) / 256);
+        return Yl(e, l[o]), o_(t, f[o]), Yl(n, u[o]), a_(i, h[o]), g[r.X] = Xi(c.minX[_], c.maxX[_], e.x), g[r.Y] = Xi(c.minY[_], c.maxY[_], e.y), g[r.Z] = Xi(c.minZ[_], c.maxZ[_], e.z), g[r.ROTATION0] = t.x, g[r.ROTATION1] = t.y, g[r.ROTATION2] = t.z, g[r.ROTATION3] = t.w, g[r.SCALE0] = Math.exp(Xi(d.minScaleX[_], d.maxScaleX[_], n.x)), g[r.SCALE1] = Math.exp(Xi(d.minScaleY[_], d.maxScaleY[_], n.y)), g[r.SCALE2] = Math.exp(Xi(d.minScaleZ[_], d.maxScaleZ[_], n.z)), g[r.FDC0] = qt(Math.floor(i.x * 255), 0, 255), g[r.FDC1] = qt(Math.floor(i.y * 255), 0, 255), g[r.FDC2] = qt(Math.floor(i.z * 255), 0, 255), g[r.OPACITY] = qt(Math.floor(i.w * 255), 0, 255), g;
+    };
+}());
+let ss = Xt;
+const ut = class ut {
+    static checkTextForEndHeader(e) {
+        return !!e.includes(ut.HeaderEndToken);
+    }
+    static checkBufferForEndHeader(e, t, n, i) {
+        const r = new Uint8Array(e, Math.max(0, t - n), n),
+            o = i.decode(r);
+        return ut.checkTextForEndHeader(o);
     }
-}
-class f_ {
-    constructor(e) {
-        this.plyBuffer = e;
+    static decodeHeaderText(e) {
+        const t = e.split(`
+`),
+            n = [];
+        let i = 0,
+            r = {},
+            o = !1;
+        for (let m = 0; m < t.length; m++) {
+            const p = t[m].trim();
+            if (n.push(p), p.startsWith("element chunk") || p.match(/[A-Za-z]*packed_[A-Za-z]*/))
+                o = !0;
+            else if (p.startsWith("element vertex")) {
+                const v = p.match(/\d+/);
+                v && (i = parseInt(v[0]));
+            } else if (p.startsWith("property")) {
+                const v = p.match(/(\w+)\s+(\w+)\s+(\w+)/);
+                if (v) {
+                    const S = v[2],
+                        y = v[3];
+                    r[y] = S;
+                }
+            } else if (p === ut.HeaderEndToken)
+                break;
+        }
+        let a = 0,
+            l = {};
+        const c = {
+                double: 8,
+                int: 4,
+                uint: 4,
+                float: 4,
+                short: 2,
+                ushort: 2,
+                uchar: 1
+            },
+            u = [];
+        for (let m in r)
+            if (r.hasOwnProperty(m)) {
+                u.push(m);
+                const p = r[m];
+                l[m] = a, a += c[p];
+            }
+        let d = 0,
+            f = 0;
+        for (let m of u)
+            m.startsWith("f_rest") && d++;
+        f = d / 3;
+        let h = 0;
+        f >= 3 && (h = 1), f >= 8 && (h = 2);
+        let g = [];
+        if (h >= 1)
+            for (let m = 0; m < 3; m++)
+                for (let p = 0; p < 3; p++)
+                    g.push("f_rest_" + (p + f * m));
+        let _ = [];
+        if (h >= 2)
+            for (let m = 0; m < 3; m++)
+                for (let p = 0; p < 5; p++)
+                    _.push("f_rest_" + (p + f * m + 3));
+        return {
+            splatCount: i,
+            propertyTypes: r,
+            compressed: o,
+            headerText: e,
+            headerLines: n,
+            headerSizeBytes: e.indexOf(ut.HeaderEndToken) + ut.HeaderEndToken.length + 1,
+            bytesPerSplat: a,
+            fieldOffsets: l,
+            sphericalHarmonicsDegree: h,
+            sphericalHarmonicsCoefficientsPerChannel: f,
+            sphericalHarmonicsDegree1Fields: g,
+            sphericalHarmonicsDegree2Fields: _
+        };
     }
-    decodeHeader(e) {
+    static decodeHeadeFromBuffer(e) {
         const t = new TextDecoder();
         let n = 0,
-            r = "";
-        console.log(".PLY size: " + e.byteLength + " bytes");
-        const s = 100;
+            i = "";
+        const r = 100;
         for (;;) {
-            if (n + s >= e.byteLength)
+            if (n + r >= e.byteLength)
                 throw new Error("End of file reached while searching for end of header");
-            const f = new Uint8Array(e, n, s);
-            r += t.decode(f), n += s;
-            const h = new Uint8Array(e, Math.max(0, n - s * 2), s * 2);
-            if (t.decode(h).includes("end_header"))
+            const o = new Uint8Array(e, n, r);
+            if (i += t.decode(o), n += r, ut.checkBufferForEndHeader(e, n, r * 2, t))
                 break;
         }
-        const a = r.split(`
-`);
-        let o = 0,
-            l = {};
-        for (let f = 0; f < a.length; f++) {
-            const h = a[f].trim();
-            if (h.startsWith("element vertex")) {
-                const p = h.match(/\d+/);
-                p && (o = parseInt(p[0]));
-            } else if (h.startsWith("property")) {
-                const p = h.match(/(\w+)\s+(\w+)\s+(\w+)/);
-                if (p) {
-                    const g = p[2],
-                        v = p[3];
-                    l[v] = g;
-                }
-            } else if (h === "end_header")
-                break;
+        return ut.decodeHeaderText(i);
+    }
+    static findVertexData(e, t) {
+        return new DataView(e, t.headerSizeBytes);
+    }
+    static readRawVertexFast(e, t, n, i, r, o) {
+        let a = o || {};
+        for (let l of i) {
+            const c = r[l];
+            c === "float" ? a[l] = e.getFloat32(t + n[l], !0) : c === "uchar" && (a[l] = e.getUint8(t + n[l]) / 255);
+        }
+    }
+    static parseToUncompressedSplatBufferSection(e, t, n, i, r, o, a, l = 0) {
+        l = Math.min(l, e.sphericalHarmonicsDegree);
+        const c = be.CompressionLevels[0].BytesPerCenter,
+            u = be.CompressionLevels[0].BytesPerScale,
+            d = be.CompressionLevels[0].BytesPerRotation,
+            f = be.CompressionLevels[0].BytesPerColor,
+            h = be.CompressionLevels[0].SphericalHarmonicsDegrees[l].BytesPerSplat;
+        for (let g = t; g <= n; g++) {
+            const _ = ut.parseToUncompressedSplat(i, g, e, r, l),
+                m = g * h + a,
+                p = new Float32Array(o, m, 3),
+                v = new Float32Array(o, m + c, 3),
+                S = new Float32Array(o, m + c + u, 4),
+                y = new Uint8Array(o, m + c + u + d, 4);
+            if (p[0] = _[ee.OFFSET.X], p[1] = _[ee.OFFSET.Y], p[2] = _[ee.OFFSET.Z], v[0] = _[ee.OFFSET.SCALE0], v[1] = _[ee.OFFSET.SCALE1], v[2] = _[ee.OFFSET.SCALE2], S[0] = _[ee.OFFSET.ROTATION0], S[1] = _[ee.OFFSET.ROTATION1], S[2] = _[ee.OFFSET.ROTATION2], S[3] = _[ee.OFFSET.ROTATION3], y[0] = _[ee.OFFSET.FDC0], y[1] = _[ee.OFFSET.FDC1], y[2] = _[ee.OFFSET.FDC2], y[3] = _[ee.OFFSET.OPACITY], l >= 1) {
+                const b = new Float32Array(
+                    o,
+                    m + c + u + d + f,
+                    _.sphericalHarmonicsCount
+                );
+                for (let E = 0; E <= 8; E++)
+                    b[E] = _[ee.OFFSET.FRC0 + E];
+                if (l >= 2)
+                    for (let E = 9; E <= 23; E++)
+                        b[E] = _[ee.OFFSET.FRC0 + E];
+            }
         }
-        const c = r.indexOf("end_header") + 10 + 1,
-            u = new DataView(e, c);
-        return {
-            splatCount: o,
-            propertyTypes: l,
-            vertexData: u,
-            headerOffset: n
-        };
     }
-    readRawVertexFast(e, t, n, r, s, a) {
-        let o = a || {};
-        for (let l of r) {
-            const c = s[l];
-            c === "float" ? o[l] = e.getFloat32(t + n[l], !0) : c === "uchar" && (o[l] = e.getUint8(t + n[l]) / 255);
+    static parseToUncompressedSplatArray(e, t = 0) {
+        const n = ut.decodeHeadeFromBuffer(e);
+        if (n.compressed)
+            return ss.parseToUncompressedSplatArray(e);
+        {
+            const i = n.splatCount,
+                r = ut.findVertexData(e, n),
+                o = new ee(t);
+            for (let a = 0; a < i; a++) {
+                const l = ut.parseToUncompressedSplat(r, a, n, 0, t);
+                o.addSplat(l);
+            }
+            return o;
         }
     }
-    parseToSplatBuffer(e, t, n, r) {
-        const s = performance.now();
-        console.log("Parsing PLY to SPLAT...");
-        const {
-            splatCount: a,
-            propertyTypes: o,
-            vertexData: l
-        } = this.decodeHeader(this.plyBuffer);
-        let c = 0;
-        for (const R in o)
-            R.startsWith("f_rest_") && (c += 1);
-        const u = c / 3;
-        console.log("Detected degree", 0, "with ", u, "coefficients per color");
-        let h = 0,
-            p = {};
-        const g = {
-            double: 8,
-            int: 4,
-            uint: 4,
-            float: 4,
-            short: 2,
-            ushort: 2,
-            uchar: 1
-        };
-        for (let R in o)
-            if (o.hasOwnProperty(R)) {
-                const E = o[R];
-                p[R] = h, h += g[E];
-            }
-        let v = {};
-        const m = [
-                "scale_0",
-                "scale_1",
-                "scale_2",
-                "rot_0",
-                "rot_1",
-                "rot_2",
-                "rot_3",
-                "x",
-                "y",
-                "z",
-                "f_dc_0",
-                "f_dc_1",
-                "f_dc_2",
-                "opacity"
-            ],
-            d = Xi.createEmptyUncompressedSplatArray();
-        for (let R = 0; R < a; R++) {
-            if (this.readRawVertexFast(l, R * h, p, m, o, v), v.scale_0 !== void 0 ? (d.scale_0[R] = Math.exp(v.scale_0), d.scale_1[R] = Math.exp(v.scale_1), d.scale_2[R] = Math.exp(v.scale_2)) : (d.scale_0[R] = 0.01, d.scale_1[R] = 0.01, d.scale_2[R] = 0.01), v.f_dc_0 !== void 0) {
-                const E = 0.28209479177387814;
-                d.f_dc_0[R] = (0.5 + E * v.f_dc_0) * 255, d.f_dc_1[R] = (0.5 + E * v.f_dc_1) * 255, d.f_dc_2[R] = (0.5 + E * v.f_dc_2) * 255;
+};
+le(ut, "HeaderEndToken", "end_header"), le(ut, "BaseFields", [
+    "scale_0",
+    "scale_1",
+    "scale_2",
+    "rot_0",
+    "rot_1",
+    "rot_2",
+    "rot_3",
+    "x",
+    "y",
+    "z",
+    "f_dc_0",
+    "f_dc_1",
+    "f_dc_2",
+    "red",
+    "green",
+    "blue",
+    "opacity"
+]), le(ut, "SphericalHarmonicsFields", Array.from(Array(45)).map((e, t) => `f_rest_${t}`)), le(ut, "Fields", [
+    [...ut.BaseFields],
+    [...ut.BaseFields, ...ut.SphericalHarmonicsFields]
+]), le(ut, "parseToUncompressedSplat", function() {
+    let e = {};
+    const t = new St();
+    return function(n, i, r, o = 0, a = 0) {
+        a = Math.min(a, r.sphericalHarmonicsDegree), ut.readRawVertexFast(
+            n,
+            i * r.bytesPerSplat + o,
+            r.fieldOffsets,
+            ut.Fields[a > 0 ? 1 : 0],
+            r.propertyTypes,
+            e
+        );
+        const l = ee.createSplat(a);
+        if (e.scale_0 !== void 0 ? (l[ee.OFFSET.SCALE0] = Math.exp(e.scale_0), l[ee.OFFSET.SCALE1] = Math.exp(e.scale_1), l[ee.OFFSET.SCALE2] = Math.exp(e.scale_2)) : (l[ee.OFFSET.SCALE0] = 0.01, l[ee.OFFSET.SCALE1] = 0.01, l[ee.OFFSET.SCALE2] = 0.01), e.f_dc_0 !== void 0) {
+            const c = 0.28209479177387814;
+            l[ee.OFFSET.FDC0] = (0.5 + c * e.f_dc_0) * 255, l[ee.OFFSET.FDC1] = (0.5 + c * e.f_dc_1) * 255, l[ee.OFFSET.FDC2] = (0.5 + c * e.f_dc_2) * 255;
+        } else
+            e.red !== void 0 ? (l[ee.OFFSET.FDC0] = e.red * 255, l[ee.OFFSET.FDC1] = e.green * 255, l[ee.OFFSET.FDC2] = e.blue * 255) : (l[ee.OFFSET.FDC0] = 0, l[ee.OFFSET.FDC1] = 0, l[ee.OFFSET.FDC2] = 0);
+        if (e.opacity !== void 0 && (l[ee.OFFSET.OPACITY] = 1 / (1 + Math.exp(-e.opacity)) * 255), l[ee.OFFSET.FDC0] = qt(Math.floor(l[ee.OFFSET.FDC0]), 0, 255), l[ee.OFFSET.FDC1] = qt(Math.floor(l[ee.OFFSET.FDC1]), 0, 255), l[ee.OFFSET.FDC2] = qt(Math.floor(l[ee.OFFSET.FDC2]), 0, 255), l[ee.OFFSET.OPACITY] = qt(Math.floor(l[ee.OFFSET.OPACITY]), 0, 255), a >= 1)
+            if (e.f_rest_0 !== void 0) {
+                for (let c = 0; c < 9; c++)
+                    l[ee.OFFSET.FRC0 + c] = e[r.sphericalHarmonicsDegree1Fields[c]];
+                if (a >= 2)
+                    for (let c = 0; c < 15; c++)
+                        l[ee.OFFSET.FRC9 + c] = e[r.sphericalHarmonicsDegree2Fields[c]];
             } else
-                d.f_dc_0[R] = 0, d.f_dc_1[R] = 0, d.f_dc_2[R] = 0;
-            v.opacity !== void 0 && (d.opacity[R] = 1 / (1 + Math.exp(-v.opacity)) * 255), d.rot_0[R] = v.rot_0, d.rot_1[R] = v.rot_1, d.rot_2[R] = v.rot_2, d.rot_3[R] = v.rot_3, d.x[R] = v.x, d.y[R] = v.y, d.z[R] = v.z, d.splatCount++;
+                l[ee.OFFSET.FRC0] = 0, l[ee.OFFSET.FRC1] = 0, l[ee.OFFSET.FRC2] = 0;
+        return t.set(e.rot_0, e.rot_1, e.rot_2, e.rot_3), t.normalize(), l[ee.OFFSET.ROTATION0] = t.x, l[ee.OFFSET.ROTATION1] = t.y, l[ee.OFFSET.ROTATION2] = t.z, l[ee.OFFSET.ROTATION3] = t.w, l[ee.OFFSET.X] = e.x, l[ee.OFFSET.Y] = e.y, l[ee.OFFSET.Z] = e.z, l;
+    };
+}());
+let $i = ut;
+class ro {
+    constructor(e, t, n, i) {
+        this.sectionCount = e, this.sectionFilters = t, this.groupingParameters = n, this.partitionGenerator = i;
+    }
+    partitionUncompressedSplatArray(e) {
+        let t, n, i;
+        if (this.partitionGenerator) {
+            const o = this.partitionGenerator(e);
+            t = o.groupingParameters, n = o.sectionCount, i = o.sectionFilters;
+        } else
+            t = this.groupingParameters, n = this.sectionCount, i = this.sectionFilters;
+        const r = [];
+        for (let o = 0; o < n; o++) {
+            const a = new ee(e.sphericalHarmonicsDegree),
+                l = i[o];
+            for (let c = 0; c < e.splatCount; c++)
+                l(c) && a.addSplatFromArray(e, c);
+            r.push(a);
         }
-        const _ = new Xi(e, t, n, r).uncompressedSplatArrayToSplatBuffer(d);
-        console.log("Total valid splats: ", _.getSplatCount(), "out of", a);
-        const A = performance.now();
-        return console.log("Parsing PLY to SPLAT complete!"), console.log("Total time: ", (A - s).toFixed(2) + " ms"), _;
+        return {
+            splatArrays: r,
+            parameters: t
+        };
+    }
+    static getStandardPartitioner(e = 0, t = new D(), n = be.BucketBlockSize, i = be.BucketSize) {
+        const r = (o) => {
+            e <= 0 && (e = o.splatCount);
+            const a = new D(),
+                l = new D(),
+                c = 0.5,
+                u = (_) => {
+                    _.x = Math.floor(_.x / c) * c, _.y = Math.floor(_.y / c) * c, _.z = Math.floor(_.z / c) * c;
+                };
+            o.splats.sort((_, m) => {
+                a.set(
+                    _[ee.OFFSET.X],
+                    _[ee.OFFSET.Y],
+                    _[ee.OFFSET.Z]
+                ).sub(t), u(a);
+                const p = a.lengthSq();
+                l.set(
+                    m[ee.OFFSET.X],
+                    m[ee.OFFSET.Y],
+                    m[ee.OFFSET.Z]
+                ).sub(t), u(l);
+                const v = l.lengthSq();
+                return p > v ? 1 : -1;
+            });
+            const d = [],
+                f = [];
+            e = Math.min(o.splatCount, e);
+            const h = Math.ceil(o.splatCount / e);
+            let g = 0;
+            for (let _ = 0; _ < h; _++) {
+                let m = g;
+                d.push((p) => p >= m && p < m + e), f.push({
+                    blocksSize: n,
+                    bucketSize: i
+                }), g += e;
+            }
+            return {
+                sectionCount: d.length,
+                sectionFilters: d,
+                groupingParameters: f
+            };
+        };
+        return new ro(void 0, void 0, void 0, r);
     }
 }
-class il {
-    constructor() {
-        this.splatBuffer = null;
+class Or {
+    constructor(e, t, n, i, r, o, a) {
+        this.splatPartitioner = e, this.alphaRemovalThreshold = t, this.compressionLevel = n, this.sectionSize = i, this.sceneCenter = r ? new D().copy(r) : void 0, this.blockSize = o, this.bucketSize = a;
+    }
+    generateFromUncompressedSplatArray(e) {
+        const t = this.splatPartitioner.partitionUncompressedSplatArray(e);
+        return be.generateFromUncompressedSplatArrays(
+            t.splatArrays,
+            this.alphaRemovalThreshold,
+            this.compressionLevel,
+            this.sceneCenter,
+            this.blockSize,
+            this.bucketSize,
+            t.parameters
+        );
     }
-    loadFromURL(e, t, n, r, s, a) {
-        return dc(e, t).then((o) => {
-            const c = new f_(o).parseToSplatBuffer(n, r, s, a);
-            return this.splatBuffer = c, c;
-        });
+    static getStandardGenerator(e = 1, t = 1, n = 0, i = new D(), r = be.BucketBlockSize, o = be.BucketSize) {
+        const a = ro.getStandardPartitioner(n, i, r, o);
+        return new Or(
+            a,
+            e,
+            t,
+            n,
+            i,
+            r,
+            o
+        );
     }
 }
-const Wr = {
-    Splat: 0,
-    KSplat: 1,
-    Ply: 2
+const Lt = {
+    Downloading: 0,
+    Processing: 1,
+    Done: 2
 };
-class Bn {
-    constructor(e = null) {
-        this.splatBuffer = e, this.downLoadLink = null;
-    }
-    static isFileSplatFormat(e) {
-        return Bn.isCustomSplatFormat(e) || Bn.isStandardSplatFormat(e);
+
+function jl(s, e) {
+    let t = 0;
+    for (let i of s)
+        t += i.sizeBytes;
+    (!e || e.byteLength < t) && (e = new ArrayBuffer(t));
+    let n = 0;
+    for (let i of s)
+        new Uint8Array(e, n, i.sizeBytes).set(i.data), n += i.sizeBytes;
+    return e;
+}
+class ao {
+    static loadFromURL(e, t, n, i, r, o, a = 0, l, c, u, d) {
+        const f = rt.StreamingSectionSize,
+            h = be.HeaderSizeBytes + be.SectionHeaderSizeBytes,
+            g = 1;
+        let _, m, p, v, S = 0,
+            y = 0,
+            b = !1,
+            E = !1,
+            T = !1,
+            L, B = new Promise((G) => {
+                L = G;
+            }),
+            x = 0,
+            A = 0,
+            U = 0,
+            N = "",
+            P = null,
+            I = [];
+        const z = new TextDecoder();
+        return so(e, (G, q, Q) => {
+            const te = G >= 100;
+            if (n) {
+                if (Q && (I.push({
+                        data: Q,
+                        sizeBytes: Q.byteLength,
+                        startBytes: U,
+                        endBytes: U + Q.byteLength
+                    }), U += Q.byteLength), b) {
+                    if (T && !E) {
+                        const fe = P.headerSizeBytes + P.chunkElement.storageSizeBytes;
+                        v = jl(I, v), v.byteLength >= fe && (ss.readElementData(P.chunkElement, v, P.headerSizeBytes), x = fe, A = fe, E = !0);
+                    }
+                } else if (N += z.decode(Q), $i.checkTextForEndHeader(N)) {
+                    P = $i.decodeHeaderText(N), a = Math.min(a, P.sphericalHarmonicsDegree), T = P.compressed, T ? (P = ss.decodeHeaderText(N), S = P.vertexElement.count) : (S = P.splatCount, E = !0);
+                    const fe = be.CompressionLevels[0].SphericalHarmonicsDegrees[a],
+                        ne = h + fe.BytesPerSplat * S;
+                    m = new ArrayBuffer(ne), be.writeHeaderToBuffer({
+                        versionMajor: be.CurrentMajorVersion,
+                        versionMinor: be.CurrentMinorVersion,
+                        maxSectionCount: g,
+                        sectionCount: g,
+                        maxSplatCount: S,
+                        splatCount: y,
+                        compressionLevel: 0,
+                        sceneCenter: new D()
+                    }, m), x = P.headerSizeBytes, A = P.headerSizeBytes, b = !0;
+                }
+                if (b && E) {
+                    if (I.length > 0 && (_ = jl(I, _), U - x > f || te)) {
+                        const ne = U - A,
+                            V = Math.floor(ne / P.bytesPerSplat),
+                            J = V * P.bytesPerSplat,
+                            se = ne - J,
+                            Ae = y + V,
+                            xe = A - I[0].startBytes,
+                            ge = new DataView(_, xe, J),
+                            Qe = be.CompressionLevels[0].SphericalHarmonicsDegrees[a],
+                            Re = y * Qe.BytesPerSplat + h;
+                        if (T ? ss.parseToUncompressedSplatBufferSection(
+                                P.chunkElement,
+                                P.vertexElement,
+                                0,
+                                V - 1,
+                                y,
+                                ge,
+                                0,
+                                m,
+                                Re
+                            ) : $i.parseToUncompressedSplatBufferSection(
+                                P,
+                                0,
+                                V - 1,
+                                ge,
+                                0,
+                                m,
+                                Re,
+                                a
+                            ), y = Ae, p || (be.writeSectionHeaderToBuffer({
+                                maxSplatCount: S,
+                                splatCount: y,
+                                bucketSize: 0,
+                                bucketCount: 0,
+                                bucketBlockSize: 0,
+                                compressionScaleRange: 0,
+                                storageSizeBytes: 0,
+                                fullBucketCount: 0,
+                                partiallyFilledBucketCount: 0,
+                                sphericalHarmonicsDegree: a
+                            }, 0, m, be.HeaderSizeBytes), p = new be(m, !1)), p.updateLoadedCounts(1, y), i(p, te), x += f, A += J, se === 0)
+                            I = [];
+                        else {
+                            let O = [],
+                                Je = 0;
+                            for (let Te = I.length - 1; Te >= 0; Te--) {
+                                const Ie = I[Te];
+                                if (Je += Ie.sizeBytes, O.unshift(Ie), Je >= se)
+                                    break;
+                            }
+                            I = O;
+                        }
+                    }
+                    te && L(p);
+                }
+            }
+            t && t(G, q, Lt.Downloading);
+        }, !n).then((G) => (t && t(0, "0%", Lt.Processing), (n ? B : ao.loadFromFileData(
+            G,
+            r,
+            o,
+            a,
+            l,
+            c,
+            u,
+            d
+        )).then((Q) => (t && t(100, "100%", Lt.Done), Q))));
     }
-    static isCustomSplatFormat(e) {
-        return e.endsWith(".ksplat");
+    static loadFromFileData(e, t, n, i = 0, r, o, a, l) {
+        return Ln(() => $i.parseToUncompressedSplatArray(e, i)).then((c) => Or.getStandardGenerator(
+            t,
+            n,
+            r,
+            o,
+            a,
+            l
+        ).generateFromUncompressedSplatArray(c));
     }
-    static isStandardSplatFormat(e) {
-        return e.endsWith(".splat");
-    }
-    loadFromURL(e, t, n, r, s, a, o) {
-        return dc(e, t).then((l) => {
-            const c = o === Wr.KSplat || Bn.isCustomSplatFormat(e);
-            let u;
-            if (c)
-                u = new $t(l);
-            else {
-                const f = new Xi(n, r, s, a),
-                    h = Bn.parseStandardSplatToUncompressedSplatArray(l);
-                u = f.uncompressedSplatArrayToSplatBuffer(h);
-            }
-            return u;
-        });
+}
+const ft = class ft {
+    static parseToUncompressedSplatBufferSection(e, t, n, i, r, o) {
+        const a = be.CompressionLevels[0].BytesPerCenter,
+            l = be.CompressionLevels[0].BytesPerScale,
+            c = be.CompressionLevels[0].BytesPerRotation,
+            u = be.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat;
+        for (let d = e; d <= t; d++) {
+            const f = d * ft.RowSizeBytes + i,
+                h = new Float32Array(n, f, 3),
+                g = new Float32Array(n, f + ft.CenterSizeBytes, 3),
+                _ = new Uint8Array(n, f + ft.CenterSizeBytes + ft.ScaleSizeBytes, 4),
+                m = new Uint8Array(n, f + ft.CenterSizeBytes + ft.ScaleSizeBytes + ft.RotationSizeBytes, 4),
+                p = new St(
+                    (m[1] - 128) / 128,
+                    (m[2] - 128) / 128,
+                    (m[3] - 128) / 128,
+                    (m[0] - 128) / 128
+                );
+            p.normalize();
+            const v = d * u + o,
+                S = new Float32Array(r, v, 3),
+                y = new Float32Array(r, v + a, 3),
+                b = new Float32Array(r, v + a + l, 4),
+                E = new Uint8Array(r, v + a + l + c, 4);
+            S[0] = h[0], S[1] = h[1], S[2] = h[2], y[0] = g[0], y[1] = g[1], y[2] = g[2], b[0] = p.w, b[1] = p.x, b[2] = p.y, b[3] = p.z, E[0] = _[0], E[1] = _[1], E[2] = _[2], E[3] = _[3];
+        }
     }
     static parseStandardSplatToUncompressedSplatArray(e) {
-        const n = e.byteLength / 32,
-            r = Xi.createEmptyUncompressedSplatArray();
-        for (let s = 0; s < n; s++) {
-            const c = s * 32,
-                u = new Float32Array(e, c, 3),
-                f = new Float32Array(e, c + 12, 3),
-                h = new Uint8Array(e, c + 12 + 12, 4),
-                p = new Uint8Array(e, c + 12 + 12 + 4, 4),
-                g = new wt(
-                    (p[1] - 128) / 128,
-                    (p[2] - 128) / 128,
-                    (p[3] - 128) / 128,
-                    (p[0] - 128) / 128
+        const t = e.byteLength / ft.RowSizeBytes,
+            n = new ee();
+        for (let i = 0; i < t; i++) {
+            const r = i * ft.RowSizeBytes,
+                o = new Float32Array(e, r, 3),
+                a = new Float32Array(e, r + ft.CenterSizeBytes, 3),
+                l = new Uint8Array(e, r + ft.CenterSizeBytes + ft.ScaleSizeBytes, 4),
+                c = new Uint8Array(e, r + ft.CenterSizeBytes + ft.ScaleSizeBytes + ft.ColorSizeBytes, 4),
+                u = new St(
+                    (c[1] - 128) / 128,
+                    (c[2] - 128) / 128,
+                    (c[3] - 128) / 128,
+                    (c[0] - 128) / 128
                 );
-            g.normalize(), r.addSplat(
-                u[0],
-                u[1],
-                u[2],
-                f[0],
-                f[1],
-                f[2],
-                g.w,
-                g.x,
-                g.y,
-                g.z,
-                h[0],
-                h[1],
-                h[2],
-                h[3]
+            u.normalize(), n.addSplatFromComonents(
+                o[0],
+                o[1],
+                o[2],
+                a[0],
+                a[1],
+                a[2],
+                u.w,
+                u.x,
+                u.y,
+                u.z,
+                l[0],
+                l[1],
+                l[2],
+                l[3]
             );
         }
-        return r;
+        return n;
     }
-    setFromBuffer(e) {
-        this.splatBuffer = e;
+};
+le(ft, "RowSizeBytes", 32), le(ft, "CenterSizeBytes", 12), le(ft, "ScaleSizeBytes", 12), le(ft, "RotationSizeBytes", 4), le(ft, "ColorSizeBytes", 4);
+let es = ft;
+class oo {
+    static loadFromURL(e, t, n, i, r, o, a, l, c, u, d) {
+        const f = be.HeaderSizeBytes + be.SectionHeaderSizeBytes,
+            h = rt.StreamingSectionSize,
+            g = 1;
+        let _, m, p, v = 0,
+            S = 0,
+            y, b = new Promise((B) => {
+                y = B;
+            }),
+            E = 0,
+            T = 0;
+        return so(e, (B, x, A, U) => {
+            const N = B >= 100;
+            if (U || (n = !1), n) {
+                if (!_) {
+                    v = U / es.RowSizeBytes, _ = new ArrayBuffer(U);
+                    const P = be.CompressionLevels[0].SphericalHarmonicsDegrees[0].BytesPerSplat,
+                        I = f + P * v;
+                    m = new ArrayBuffer(I), be.writeHeaderToBuffer({
+                        versionMajor: be.CurrentMajorVersion,
+                        versionMinor: be.CurrentMinorVersion,
+                        maxSectionCount: g,
+                        sectionCount: g,
+                        maxSplatCount: v,
+                        splatCount: S,
+                        compressionLevel: 0,
+                        sceneCenter: new D()
+                    }, m);
+                }
+                if (A) {
+                    new Uint8Array(_, T, A.byteLength).set(new Uint8Array(A)), T += A.byteLength;
+                    const P = T - E;
+                    if (P > h || N) {
+                        const z = (N ? P : h) / es.RowSizeBytes,
+                            K = S + z;
+                        es.parseToUncompressedSplatBufferSection(
+                            S,
+                            K - 1,
+                            _,
+                            0,
+                            m,
+                            f
+                        ), S = K, p || (be.writeSectionHeaderToBuffer({
+                            maxSplatCount: v,
+                            splatCount: S,
+                            bucketSize: 0,
+                            bucketCount: 0,
+                            bucketBlockSize: 0,
+                            compressionScaleRange: 0,
+                            storageSizeBytes: 0,
+                            fullBucketCount: 0,
+                            partiallyFilledBucketCount: 0
+                        }, 0, m, be.HeaderSizeBytes), p = new be(m, !1)), p.updateLoadedCounts(1, S), i(p, N), E += h;
+                    }
+                }
+                N && y(p);
+            }
+            return t && t(B, x, Lt.Downloading), n;
+        }, !0).then((B) => (t && t(0, "0%", Lt.Processing), (n ? b : oo.loadFromFileData(
+            B,
+            r,
+            o,
+            a,
+            l,
+            c,
+            u,
+            d
+        )).then((A) => (t && t(100, "100%", Lt.Done), A))));
     }
-    downloadFile(e) {
-        const t = new Uint8Array(this.splatBuffer.getHeaderBufferData()),
-            n = new Uint8Array(this.splatBuffer.getSplatBufferData()),
-            r = new Blob([t.buffer, n.buffer], {
-                type: "application/octet-stream"
-            });
-        this.downLoadLink || (this.downLoadLink = document.createElement("a"), document.body.appendChild(this.downLoadLink)), this.downLoadLink.download = e, this.downLoadLink.href = URL.createObjectURL(r), this.downLoadLink.click();
+    static loadFromFileData(e, t, n, i, r, o, a, l) {
+        return Ln(() => {
+            const c = es.parseStandardSplatToUncompressedSplatArray(e);
+            return i ? Or.getStandardGenerator(
+                t,
+                n,
+                r,
+                o,
+                a,
+                l
+            ).generateFromUncompressedSplatArray(c) : be.generateFromUncompressedSplatArrays([c], t, 0, new D());
+        });
     }
 }
-const rl = {
+const ns = class ns {
+    static checkVersion(e) {
+        const t = be.CurrentMajorVersion,
+            n = be.CurrentMinorVersion,
+            i = be.parseHeader(e);
+        if (i.versionMajor === t && i.versionMinor >= n || i.versionMajor > t)
+            return !0;
+        throw new Error(`KSplat version not supported: v${i.versionMajor}.${i.versionMinor}. Minimum required: v${t}.${n}`);
+    }
+    static loadFromURL(e, t, n, i) {
+        let r, o, a, l, c = !1,
+            u = !1,
+            d, f = [],
+            h = !1,
+            g = !1,
+            _ = 0,
+            m = 0,
+            p = rt.StreamingSectionSize,
+            v = 0,
+            S = !1,
+            y = [],
+            b, E = new Promise((N) => {
+                b = N;
+            });
+        const T = () => {
+            !c && !u && _ >= be.HeaderSizeBytes && (u = !0, new Blob(y).arrayBuffer().then((P) => {
+                a = new ArrayBuffer(be.HeaderSizeBytes), new Uint8Array(a).set(new Uint8Array(P, 0, be.HeaderSizeBytes)), ns.checkVersion(a), u = !1, c = !0, l = be.parseHeader(a), window.setTimeout(() => {
+                    x();
+                }, 1);
+            }));
+        };
+        let L = 0;
+        const B = () => {
+                L === 0 && (L++, window.setTimeout(() => {
+                    L--, A();
+                }, 1));
+            },
+            x = () => {
+                const N = () => {
+                    g = !0, new Blob(y).arrayBuffer().then((I) => {
+                        g = !1, h = !0, d = new ArrayBuffer(l.maxSectionCount * be.SectionHeaderSizeBytes), new Uint8Array(d).set(new Uint8Array(
+                            I,
+                            be.HeaderSizeBytes,
+                            l.maxSectionCount * be.SectionHeaderSizeBytes
+                        )), f = be.parseSectionHeaders(l, d, 0, !1);
+                        let z = 0;
+                        for (let G = 0; G < l.maxSectionCount; G++)
+                            z += f[G].storageSizeBytes;
+                        const K = be.HeaderSizeBytes + l.maxSectionCount * be.SectionHeaderSizeBytes + z;
+                        if (!r) {
+                            r = new ArrayBuffer(K);
+                            let G = 0;
+                            for (let q = 0; q < y.length; q++) {
+                                const Q = y[q];
+                                new Uint8Array(r, G, Q.byteLength).set(new Uint8Array(Q)), G += Q.byteLength;
+                            }
+                        }
+                        v = be.HeaderSizeBytes + be.SectionHeaderSizeBytes * l.maxSectionCount;
+                        for (let G = 0; G <= f.length && G < l.maxSectionCount; G++)
+                            v += f[G].storageSizeBytes;
+                        B();
+                    });
+                };
+                !g && !h && c && _ >= be.HeaderSizeBytes + be.SectionHeaderSizeBytes * l.maxSectionCount && N();
+            },
+            A = () => {
+                if (h) {
+                    if (S)
+                        return;
+                    if (S = _ >= v, _ - m > p || S) {
+                        m = _, o || (o = new be(r, !1));
+                        const P = be.HeaderSizeBytes + be.SectionHeaderSizeBytes * l.maxSectionCount;
+                        let I = 0,
+                            z = 0,
+                            K = 0;
+                        for (let G = 0; G < l.maxSectionCount; G++) {
+                            const q = f[G],
+                                Q = I + q.partiallyFilledBucketCount * 4 + q.bucketStorageSizeBytes * q.bucketCount,
+                                te = P + Q;
+                            if (_ >= te) {
+                                z++;
+                                const fe = _ - te,
+                                    J = be.CompressionLevels[l.compressionLevel].SphericalHarmonicsDegrees[q.sphericalHarmonicsDegree].BytesPerSplat;
+                                let se = Math.floor(fe / J);
+                                se = Math.min(se, q.maxSplatCount), K += se, o.updateLoadedCounts(z, K), o.updateSectionLoadedCounts(G, se);
+                            } else
+                                break;
+                            I += q.storageSizeBytes;
+                        }
+                        i(o, S), S && b(o);
+                    }
+                }
+            };
+        return so(e, (N, P, I) => {
+            I && (y.push(I), r && new Uint8Array(r, _, I.byteLength).set(new Uint8Array(I)), _ += I.byteLength), n && (T(), x(), A()), t && t(N, P, Lt.Downloading);
+        }, !n).then((N) => (t && t(0, "0%", Lt.Processing), (n ? E : ns.loadFromFileData(N)).then((I) => (t && t(100, "100%", Lt.Done), I))));
+    }
+    static loadFromFileData(e) {
+        return Ln(() => (ns.checkVersion(e), new be(e)));
+    }
+};
+le(ns, "downloadFile", /* @__PURE__ */ function() {
+    let e;
+    return function(t, n) {
+        const i = new Blob([t.bufferData], {
+            type: "application/octet-stream"
+        });
+        e || (e = document.createElement("a"), document.body.appendChild(e)), e.download = n, e.href = URL.createObjectURL(i), e.click();
+    };
+}());
+let za = ns;
+const Rn = {
+        Splat: 0,
+        KSplat: 1,
+        Ply: 2
+    },
+    Kl = (s) => s.endsWith(".ply") ? Rn.Ply : s.endsWith(".splat") ? Rn.Splat : s.endsWith(".ksplat") ? Rn.KSplat : null,
+    Zl = {
         type: "change"
     },
-    Qs = {
+    Ca = {
         type: "start"
     },
-    sl = {
+    Ql = {
         type: "end"
     },
-    zr = new Ql(),
-    ol = new Fn(),
-    h_ = Math.cos(70 * Xl.DEG2RAD);
-class d_ extends ui {
+    lr = new Wc(),
+    Jl = new jn(),
+    l_ = Math.cos(70 * kc.DEG2RAD);
+class cr extends Ti {
     constructor(e, t) {
-        super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new P(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
+        super(), this.object = e, this.domElement = t, this.domElement.style.touchAction = "none", this.enabled = !0, this.target = new D(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = {
             LEFT: "KeyA",
             UP: "KeyW",
             RIGHT: "KeyD",
             BOTTOM: "KeyS"
         }, this.mouseButtons = {
-            LEFT: fi.ROTATE,
-            MIDDLE: fi.DOLLY,
-            RIGHT: fi.PAN
+            LEFT: bi.ROTATE,
+            MIDDLE: bi.DOLLY,
+            RIGHT: bi.PAN
         }, this.touches = {
-            ONE: hi.ROTATE,
-            TWO: hi.DOLLY_PAN
+            ONE: Ci.ROTATE,
+            TWO: Ci.DOLLY_PAN
         }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this.getPolarAngle = function() {
-            return o.phi;
+            return a.phi;
         }, this.getAzimuthalAngle = function() {
-            return o.theta;
+            return a.theta;
         }, this.getDistance = function() {
             return this.object.position.distanceTo(this.target);
-        }, this.listenToKeyEvents = function(C) {
-            C.addEventListener("keydown", Q), this._domElementKeyEvents = C;
+        }, this.listenToKeyEvents = function(R) {
+            R.addEventListener("keydown", Z), this._domElementKeyEvents = R;
         }, this.stopListenToKeyEvents = function() {
-            this._domElementKeyEvents.removeEventListener("keydown", Q), this._domElementKeyEvents = null;
+            this._domElementKeyEvents.removeEventListener("keydown", Z), this._domElementKeyEvents = null;
         }, this.saveState = function() {
             n.target0.copy(n.target), n.position0.copy(n.object.position), n.zoom0 = n.object.zoom;
         }, this.reset = function() {
-            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, n.object.updateProjectionMatrix(), n.dispatchEvent(rl), n.update(), s = r.NONE;
+            n.target.copy(n.target0), n.object.position.copy(n.position0), n.object.zoom = n.zoom0, this.clearDampedRotation(), this.clearDampedPan(), n.object.updateProjectionMatrix(), n.dispatchEvent(Zl), n.update(), r = i.NONE;
+        }, this.clearDampedRotation = function() {
+            l.theta = 0, l.phi = 0;
+        }, this.clearDampedPan = function() {
+            u.set(0, 0, 0);
         }, this.update = function() {
-            const C = new P(),
-                le = new wt().setFromUnitVectors(e.up, new P(0, 1, 0)),
-                ve = le.clone().invert(),
-                fe = new P(),
-                he = new wt(),
-                _e = new P(),
-                De = 2 * Math.PI;
+            const R = new D(),
+                ue = new St().setFromUnitVectors(e.up, new D(0, 1, 0)),
+                Se = ue.clone().invert(),
+                me = new D(),
+                _e = new St(),
+                ve = new D(),
+                Le = 2 * Math.PI;
             return function() {
-                le.setFromUnitVectors(e.up, new P(0, 1, 0)), ve.copy(le).invert();
-                const $e = n.object.position;
-                C.copy($e).sub(n.target), C.applyQuaternion(le), o.setFromVector3(C), n.autoRotate && s === r.NONE && T(W()), n.enableDamping ? (o.theta += l.theta * n.dampingFactor, o.phi += l.phi * n.dampingFactor) : (o.theta += l.theta, o.phi += l.phi);
-                let D = n.minAzimuthAngle,
-                    re = n.maxAzimuthAngle;
-                isFinite(D) && isFinite(re) && (D < -Math.PI ? D += De : D > Math.PI && (D -= De), re < -Math.PI ? re += De : re > Math.PI && (re -= De), D <= re ? o.theta = Math.max(D, Math.min(re, o.theta)) : o.theta = o.theta > (D + re) / 2 ? Math.max(D, o.theta) : Math.min(re, o.theta)), o.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, o.phi)), o.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), n.zoomToCursor && E || n.object.isOrthographicCamera ? o.radius = q(o.radius) : o.radius = q(o.radius * c), C.setFromSpherical(o), C.applyQuaternion(ve), $e.copy(n.target).add(C), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0));
-                let z = !1;
+                ue.setFromUnitVectors(e.up, new D(0, 1, 0)), Se.copy(ue).invert();
+                const nt = n.object.position;
+                R.copy(nt).sub(n.target), R.applyQuaternion(ue), a.setFromVector3(R), n.autoRotate && r === i.NONE && A(B()), n.enableDamping ? (a.theta += l.theta * n.dampingFactor, a.phi += l.phi * n.dampingFactor) : (a.theta += l.theta, a.phi += l.phi);
+                let F = n.minAzimuthAngle,
+                    ce = n.maxAzimuthAngle;
+                isFinite(F) && isFinite(ce) && (F < -Math.PI ? F += Le : F > Math.PI && (F -= Le), ce < -Math.PI ? ce += Le : ce > Math.PI && (ce -= Le), F <= ce ? a.theta = Math.max(F, Math.min(ce, a.theta)) : a.theta = a.theta > (F + ce) / 2 ? Math.max(F, a.theta) : Math.min(ce, a.theta)), a.phi = Math.max(n.minPolarAngle, Math.min(n.maxPolarAngle, a.phi)), a.makeSafe(), n.enableDamping === !0 ? n.target.addScaledVector(u, n.dampingFactor) : n.target.add(u), n.zoomToCursor && E || n.object.isOrthographicCamera ? a.radius = q(a.radius) : a.radius = q(a.radius * c), R.setFromSpherical(a), R.applyQuaternion(Se), nt.copy(n.target).add(R), n.object.lookAt(n.target), n.enableDamping === !0 ? (l.theta *= 1 - n.dampingFactor, l.phi *= 1 - n.dampingFactor, u.multiplyScalar(1 - n.dampingFactor)) : (l.set(0, 0, 0), u.set(0, 0, 0));
+                let W = !1;
                 if (n.zoomToCursor && E) {
-                    let ie = null;
+                    let ae = null;
                     if (n.object.isPerspectiveCamera) {
-                        const ae = C.length();
-                        ie = q(ae * c);
-                        const Oe = ae - ie;
-                        n.object.position.addScaledVector(A, Oe), n.object.updateMatrixWorld();
+                        const pe = R.length();
+                        ae = q(pe * c);
+                        const Ve = pe - ae;
+                        n.object.position.addScaledVector(y, Ve), n.object.updateMatrixWorld();
                     } else if (n.object.isOrthographicCamera) {
-                        const ae = new P(R.x, R.y, 0);
-                        ae.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), z = !0;
-                        const Oe = new P(R.x, R.y, 0);
-                        Oe.unproject(n.object), n.object.position.sub(Oe).add(ae), n.object.updateMatrixWorld(), ie = C.length();
+                        const pe = new D(b.x, b.y, 0);
+                        pe.unproject(n.object), n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), W = !0;
+                        const Ve = new D(b.x, b.y, 0);
+                        Ve.unproject(n.object), n.object.position.sub(Ve).add(pe), n.object.updateMatrixWorld(), ae = R.length();
                     } else
                         console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), n.zoomToCursor = !1;
-                    ie !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(ie).add(n.object.position) : (zr.origin.copy(n.object.position), zr.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(zr.direction)) < h_ ? e.lookAt(n.target) : (ol.setFromNormalAndCoplanarPoint(n.object.up, n.target), zr.intersectPlane(ol, n.target))));
+                    ae !== null && (this.screenSpacePanning ? n.target.set(0, 0, -1).transformDirection(n.object.matrix).multiplyScalar(ae).add(n.object.position) : (lr.origin.copy(n.object.position), lr.direction.set(0, 0, -1).transformDirection(n.object.matrix), Math.abs(n.object.up.dot(lr.direction)) < l_ ? e.lookAt(n.target) : (Jl.setFromNormalAndCoplanarPoint(n.object.up, n.target), lr.intersectPlane(Jl, n.target))));
                 } else
-                    n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), z = !0);
-                return c = 1, E = !1, z || fe.distanceToSquared(n.object.position) > a || 8 * (1 - he.dot(n.object.quaternion)) > a || _e.distanceToSquared(n.target) > 0 ? (n.dispatchEvent(rl), fe.copy(n.object.position), he.copy(n.object.quaternion), _e.copy(n.target), z = !1, !0) : !1;
+                    n.object.isOrthographicCamera && (n.object.zoom = Math.max(n.minZoom, Math.min(n.maxZoom, n.object.zoom / c)), n.object.updateProjectionMatrix(), W = !0);
+                return c = 1, E = !1, W || me.distanceToSquared(n.object.position) > o || 8 * (1 - _e.dot(n.object.quaternion)) > o || ve.distanceToSquared(n.target) > 0 ? (n.dispatchEvent(Zl), me.copy(n.object.position), _e.copy(n.object.quaternion), ve.copy(n.target), W = !1, !0) : !1;
             };
         }(), this.dispose = function() {
-            n.domElement.removeEventListener("contextmenu", Le), n.domElement.removeEventListener("pointerdown", Ie), n.domElement.removeEventListener("pointercancel", Je), n.domElement.removeEventListener("wheel", X), n.domElement.removeEventListener("pointermove", Be), n.domElement.removeEventListener("pointerup", Je), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", Q), n._domElementKeyEvents = null);
+            n.domElement.removeEventListener("contextmenu", Be), n.domElement.removeEventListener("pointerdown", Oe), n.domElement.removeEventListener("pointercancel", Ke), n.domElement.removeEventListener("wheel", k), n.domElement.removeEventListener("pointermove", we), n.domElement.removeEventListener("pointerup", Ke), n._domElementKeyEvents !== null && (n._domElementKeyEvents.removeEventListener("keydown", Z), n._domElementKeyEvents = null);
         };
         const n = this,
-            r = {
+            i = {
                 NONE: -1,
                 ROTATE: 0,
                 DOLLY: 1,
                 PAN: 2,
                 TOUCH_ROTATE: 3,
                 TOUCH_PAN: 4,
                 TOUCH_DOLLY_PAN: 5,
                 TOUCH_DOLLY_ROTATE: 6
             };
-        let s = r.NONE;
-        const a = 1e-6,
-            o = new nl(),
-            l = new nl();
+        let r = i.NONE;
+        const o = 1e-6,
+            a = new Wl(),
+            l = new Wl();
         let c = 1;
-        const u = new P(),
-            f = new me(),
-            h = new me(),
-            p = new me(),
-            g = new me(),
-            v = new me(),
-            m = new me(),
-            d = new me(),
-            M = new me(),
-            _ = new me(),
-            A = new P(),
-            R = new me();
+        const u = new D(),
+            d = new Ee(),
+            f = new Ee(),
+            h = new Ee(),
+            g = new Ee(),
+            _ = new Ee(),
+            m = new Ee(),
+            p = new Ee(),
+            v = new Ee(),
+            S = new Ee(),
+            y = new D(),
+            b = new Ee();
         let E = !1;
-        const b = [],
-            I = {};
+        const T = [],
+            L = {};
 
-        function W() {
+        function B() {
             return 2 * Math.PI / 60 / 60 * n.autoRotateSpeed;
         }
 
-        function S() {
+        function x() {
             return Math.pow(0.95, n.zoomSpeed);
         }
 
-        function T(C) {
-            l.theta -= C;
+        function A(R) {
+            l.theta -= R;
         }
 
-        function Y(C) {
-            l.phi -= C;
+        function U(R) {
+            l.phi -= R;
         }
-        const K = function() {
-                const C = new P();
-                return function(ve, fe) {
-                    C.setFromMatrixColumn(fe, 0), C.multiplyScalar(-ve), u.add(C);
+        const N = function() {
+                const R = new D();
+                return function(Se, me) {
+                    R.setFromMatrixColumn(me, 0), R.multiplyScalar(-Se), u.add(R);
                 };
             }(),
-            L = function() {
-                const C = new P();
-                return function(ve, fe) {
-                    n.screenSpacePanning === !0 ? C.setFromMatrixColumn(fe, 1) : (C.setFromMatrixColumn(fe, 0), C.crossVectors(n.object.up, C)), C.multiplyScalar(ve), u.add(C);
+            P = function() {
+                const R = new D();
+                return function(Se, me) {
+                    n.screenSpacePanning === !0 ? R.setFromMatrixColumn(me, 1) : (R.setFromMatrixColumn(me, 0), R.crossVectors(n.object.up, R)), R.multiplyScalar(Se), u.add(R);
                 };
             }(),
-            N = function() {
-                const C = new P();
-                return function(ve, fe) {
-                    const he = n.domElement;
+            I = function() {
+                const R = new D();
+                return function(Se, me) {
+                    const _e = n.domElement;
                     if (n.object.isPerspectiveCamera) {
-                        const _e = n.object.position;
-                        C.copy(_e).sub(n.target);
-                        let De = C.length();
-                        De *= Math.tan(n.object.fov / 2 * Math.PI / 180), K(2 * ve * De / he.clientHeight, n.object.matrix), L(2 * fe * De / he.clientHeight, n.object.matrix);
+                        const ve = n.object.position;
+                        R.copy(ve).sub(n.target);
+                        let Le = R.length();
+                        Le *= Math.tan(n.object.fov / 2 * Math.PI / 180), N(2 * Se * Le / _e.clientHeight, n.object.matrix), P(2 * me * Le / _e.clientHeight, n.object.matrix);
                     } else
-                        n.object.isOrthographicCamera ? (K(ve * (n.object.right - n.object.left) / n.object.zoom / he.clientWidth, n.object.matrix), L(fe * (n.object.top - n.object.bottom) / n.object.zoom / he.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
+                        n.object.isOrthographicCamera ? (N(Se * (n.object.right - n.object.left) / n.object.zoom / _e.clientWidth, n.object.matrix), P(me * (n.object.top - n.object.bottom) / n.object.zoom / _e.clientHeight, n.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), n.enablePan = !1);
                 };
             }();
 
-        function O(C) {
-            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= C : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
+        function z(R) {
+            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c /= R : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
         }
 
-        function B(C) {
-            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= C : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
+        function K(R) {
+            n.object.isPerspectiveCamera || n.object.isOrthographicCamera ? c *= R : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), n.enableZoom = !1);
         }
 
-        function j(C) {
+        function G(R) {
             if (!n.zoomToCursor)
                 return;
             E = !0;
-            const le = n.domElement.getBoundingClientRect(),
-                ve = C.clientX - le.left,
-                fe = C.clientY - le.top,
-                he = le.width,
-                _e = le.height;
-            R.x = ve / he * 2 - 1, R.y = -(fe / _e) * 2 + 1, A.set(R.x, R.y, 1).unproject(e).sub(e.position).normalize();
+            const ue = n.domElement.getBoundingClientRect(),
+                Se = R.clientX - ue.left,
+                me = R.clientY - ue.top,
+                _e = ue.width,
+                ve = ue.height;
+            b.x = Se / _e * 2 - 1, b.y = -(me / ve) * 2 + 1, y.set(b.x, b.y, 1).unproject(e).sub(e.position).normalize();
         }
 
-        function q(C) {
-            return Math.max(n.minDistance, Math.min(n.maxDistance, C));
+        function q(R) {
+            return Math.max(n.minDistance, Math.min(n.maxDistance, R));
         }
 
-        function J(C) {
-            f.set(C.clientX, C.clientY);
+        function Q(R) {
+            d.set(R.clientX, R.clientY);
         }
 
-        function ne(C) {
-            j(C), d.set(C.clientX, C.clientY);
+        function te(R) {
+            G(R), p.set(R.clientX, R.clientY);
         }
 
-        function ue(C) {
-            g.set(C.clientX, C.clientY);
+        function fe(R) {
+            g.set(R.clientX, R.clientY);
         }
 
-        function Z(C) {
-            h.set(C.clientX, C.clientY), p.subVectors(h, f).multiplyScalar(n.rotateSpeed);
-            const le = n.domElement;
-            T(2 * Math.PI * p.x / le.clientHeight), Y(2 * Math.PI * p.y / le.clientHeight), f.copy(h), n.update();
+        function ne(R) {
+            f.set(R.clientX, R.clientY), h.subVectors(f, d).multiplyScalar(n.rotateSpeed);
+            const ue = n.domElement;
+            A(2 * Math.PI * h.x / ue.clientHeight), U(2 * Math.PI * h.y / ue.clientHeight), d.copy(f), n.update();
         }
 
-        function H(C) {
-            M.set(C.clientX, C.clientY), _.subVectors(M, d), _.y > 0 ? O(S()) : _.y < 0 && B(S()), d.copy(M), n.update();
+        function V(R) {
+            v.set(R.clientX, R.clientY), S.subVectors(v, p), S.y > 0 ? z(x()) : S.y < 0 && K(x()), p.copy(v), n.update();
         }
 
-        function ee(C) {
-            v.set(C.clientX, C.clientY), m.subVectors(v, g).multiplyScalar(n.panSpeed), N(m.x, m.y), g.copy(v), n.update();
+        function J(R) {
+            _.set(R.clientX, R.clientY), m.subVectors(_, g).multiplyScalar(n.panSpeed), I(m.x, m.y), g.copy(_), n.update();
         }
 
-        function pe(C) {
-            j(C), C.deltaY < 0 ? B(S()) : C.deltaY > 0 && O(S()), n.update();
+        function se(R) {
+            G(R), R.deltaY < 0 ? K(x()) : R.deltaY > 0 && z(x()), n.update();
         }
 
-        function Te(C) {
-            let le = !1;
-            switch (C.code) {
+        function Ae(R) {
+            let ue = !1;
+            switch (R.code) {
                 case n.keys.UP:
-                    C.ctrlKey || C.metaKey || C.shiftKey ? Y(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(0, n.keyPanSpeed), le = !0;
+                    R.ctrlKey || R.metaKey || R.shiftKey ? U(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(0, n.keyPanSpeed), ue = !0;
                     break;
                 case n.keys.BOTTOM:
-                    C.ctrlKey || C.metaKey || C.shiftKey ? Y(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(0, -n.keyPanSpeed), le = !0;
+                    R.ctrlKey || R.metaKey || R.shiftKey ? U(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(0, -n.keyPanSpeed), ue = !0;
                     break;
                 case n.keys.LEFT:
-                    C.ctrlKey || C.metaKey || C.shiftKey ? T(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(n.keyPanSpeed, 0), le = !0;
+                    R.ctrlKey || R.metaKey || R.shiftKey ? A(2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(n.keyPanSpeed, 0), ue = !0;
                     break;
                 case n.keys.RIGHT:
-                    C.ctrlKey || C.metaKey || C.shiftKey ? T(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : N(-n.keyPanSpeed, 0), le = !0;
+                    R.ctrlKey || R.metaKey || R.shiftKey ? A(-2 * Math.PI * n.rotateSpeed / n.domElement.clientHeight) : I(-n.keyPanSpeed, 0), ue = !0;
                     break;
             }
-            le && (C.preventDefault(), n.update());
+            ue && (R.preventDefault(), n.update());
         }
 
         function xe() {
-            if (b.length === 1)
-                f.set(b[0].pageX, b[0].pageY);
+            if (T.length === 1)
+                d.set(T[0].pageX, T[0].pageY);
             else {
-                const C = 0.5 * (b[0].pageX + b[1].pageX),
-                    le = 0.5 * (b[0].pageY + b[1].pageY);
-                f.set(C, le);
+                const R = 0.5 * (T[0].pageX + T[1].pageX),
+                    ue = 0.5 * (T[0].pageY + T[1].pageY);
+                d.set(R, ue);
             }
         }
 
         function ge() {
-            if (b.length === 1)
-                g.set(b[0].pageX, b[0].pageY);
+            if (T.length === 1)
+                g.set(T[0].pageX, T[0].pageY);
             else {
-                const C = 0.5 * (b[0].pageX + b[1].pageX),
-                    le = 0.5 * (b[0].pageY + b[1].pageY);
-                g.set(C, le);
+                const R = 0.5 * (T[0].pageX + T[1].pageX),
+                    ue = 0.5 * (T[0].pageY + T[1].pageY);
+                g.set(R, ue);
             }
         }
 
-        function Ke() {
-            const C = b[0].pageX - b[1].pageX,
-                le = b[0].pageY - b[1].pageY,
-                ve = Math.sqrt(C * C + le * le);
-            d.set(0, ve);
+        function Qe() {
+            const R = T[0].pageX - T[1].pageX,
+                ue = T[0].pageY - T[1].pageY,
+                Se = Math.sqrt(R * R + ue * ue);
+            p.set(0, Se);
         }
 
-        function we() {
-            n.enableZoom && Ke(), n.enablePan && ge();
+        function Re() {
+            n.enableZoom && Qe(), n.enablePan && ge();
         }
 
-        function F() {
-            n.enableZoom && Ke(), n.enableRotate && xe();
+        function O() {
+            n.enableZoom && Qe(), n.enableRotate && xe();
         }
 
-        function lt(C) {
-            if (b.length == 1)
-                h.set(C.pageX, C.pageY);
+        function Je(R) {
+            if (T.length == 1)
+                f.set(R.pageX, R.pageY);
             else {
-                const ve = Re(C),
-                    fe = 0.5 * (C.pageX + ve.x),
-                    he = 0.5 * (C.pageY + ve.y);
-                h.set(fe, he);
-            }
-            p.subVectors(h, f).multiplyScalar(n.rotateSpeed);
-            const le = n.domElement;
-            T(2 * Math.PI * p.x / le.clientHeight), Y(2 * Math.PI * p.y / le.clientHeight), f.copy(h);
+                const Se = De(R),
+                    me = 0.5 * (R.pageX + Se.x),
+                    _e = 0.5 * (R.pageY + Se.y);
+                f.set(me, _e);
+            }
+            h.subVectors(f, d).multiplyScalar(n.rotateSpeed);
+            const ue = n.domElement;
+            A(2 * Math.PI * h.x / ue.clientHeight), U(2 * Math.PI * h.y / ue.clientHeight), d.copy(f);
         }
 
-        function Me(C) {
-            if (b.length === 1)
-                v.set(C.pageX, C.pageY);
+        function Te(R) {
+            if (T.length === 1)
+                _.set(R.pageX, R.pageY);
             else {
-                const le = Re(C),
-                    ve = 0.5 * (C.pageX + le.x),
-                    fe = 0.5 * (C.pageY + le.y);
-                v.set(ve, fe);
+                const ue = De(R),
+                    Se = 0.5 * (R.pageX + ue.x),
+                    me = 0.5 * (R.pageY + ue.y);
+                _.set(Se, me);
             }
-            m.subVectors(v, g).multiplyScalar(n.panSpeed), N(m.x, m.y), g.copy(v);
+            m.subVectors(_, g).multiplyScalar(n.panSpeed), I(m.x, m.y), g.copy(_);
         }
 
-        function Ne(C) {
-            const le = Re(C),
-                ve = C.pageX - le.x,
-                fe = C.pageY - le.y,
-                he = Math.sqrt(ve * ve + fe * fe);
-            M.set(0, he), _.set(0, Math.pow(M.y / d.y, n.zoomSpeed)), O(_.y), d.copy(M);
+        function Ie(R) {
+            const ue = De(R),
+                Se = R.pageX - ue.x,
+                me = R.pageY - ue.y,
+                _e = Math.sqrt(Se * Se + me * me);
+            v.set(0, _e), S.set(0, Math.pow(v.y / p.y, n.zoomSpeed)), z(S.y), p.copy(v);
         }
 
-        function ye(C) {
-            n.enableZoom && Ne(C), n.enablePan && Me(C);
+        function Me(R) {
+            n.enableZoom && Ie(R), n.enablePan && Te(R);
         }
 
-        function qe(C) {
-            n.enableZoom && Ne(C), n.enableRotate && lt(C);
+        function ze(R) {
+            n.enableZoom && Ie(R), n.enableRotate && Je(R);
         }
 
-        function Ie(C) {
-            n.enabled !== !1 && (b.length === 0 && (n.domElement.setPointerCapture(C.pointerId), n.domElement.addEventListener("pointermove", Be), n.domElement.addEventListener("pointerup", Je)), Ae(C), C.pointerType === "touch" ? te(C) : w(C));
+        function Oe(R) {
+            n.enabled !== !1 && (T.length === 0 && (n.domElement.setPointerCapture(R.pointerId), n.domElement.addEventListener("pointermove", we), n.domElement.addEventListener("pointerup", Ke)), Pe(R), R.pointerType === "touch" ? re(R) : w(R));
         }
 
-        function Be(C) {
-            n.enabled !== !1 && (C.pointerType === "touch" ? $(C) : x(C));
+        function we(R) {
+            n.enabled !== !1 && (R.pointerType === "touch" ? ie(R) : M(R));
         }
 
-        function Je(C) {
-            se(C), b.length === 0 && (n.domElement.releasePointerCapture(C.pointerId), n.domElement.removeEventListener("pointermove", Be), n.domElement.removeEventListener("pointerup", Je)), n.dispatchEvent(sl), s = r.NONE;
+        function Ke(R) {
+            oe(R), T.length === 0 && (n.domElement.releasePointerCapture(R.pointerId), n.domElement.removeEventListener("pointermove", we), n.domElement.removeEventListener("pointerup", Ke)), n.dispatchEvent(Ql), r = i.NONE;
         }
 
-        function w(C) {
-            let le;
-            switch (C.button) {
+        function w(R) {
+            let ue;
+            switch (R.button) {
                 case 0:
-                    le = n.mouseButtons.LEFT;
+                    ue = n.mouseButtons.LEFT;
                     break;
                 case 1:
-                    le = n.mouseButtons.MIDDLE;
+                    ue = n.mouseButtons.MIDDLE;
                     break;
                 case 2:
-                    le = n.mouseButtons.RIGHT;
+                    ue = n.mouseButtons.RIGHT;
                     break;
                 default:
-                    le = -1;
+                    ue = -1;
             }
-            switch (le) {
-                case fi.DOLLY:
+            switch (ue) {
+                case bi.DOLLY:
                     if (n.enableZoom === !1)
                         return;
-                    ne(C), s = r.DOLLY;
+                    te(R), r = i.DOLLY;
                     break;
-                case fi.ROTATE:
-                    if (C.ctrlKey || C.metaKey || C.shiftKey) {
+                case bi.ROTATE:
+                    if (R.ctrlKey || R.metaKey || R.shiftKey) {
                         if (n.enablePan === !1)
                             return;
-                        ue(C), s = r.PAN;
+                        fe(R), r = i.PAN;
                     } else {
                         if (n.enableRotate === !1)
                             return;
-                        J(C), s = r.ROTATE;
+                        Q(R), r = i.ROTATE;
                     }
                     break;
-                case fi.PAN:
-                    if (C.ctrlKey || C.metaKey || C.shiftKey) {
+                case bi.PAN:
+                    if (R.ctrlKey || R.metaKey || R.shiftKey) {
                         if (n.enableRotate === !1)
                             return;
-                        J(C), s = r.ROTATE;
+                        Q(R), r = i.ROTATE;
                     } else {
                         if (n.enablePan === !1)
                             return;
-                        ue(C), s = r.PAN;
+                        fe(R), r = i.PAN;
                     }
                     break;
                 default:
-                    s = r.NONE;
+                    r = i.NONE;
             }
-            s !== r.NONE && n.dispatchEvent(Qs);
+            r !== i.NONE && n.dispatchEvent(Ca);
         }
 
-        function x(C) {
-            switch (s) {
-                case r.ROTATE:
+        function M(R) {
+            switch (r) {
+                case i.ROTATE:
                     if (n.enableRotate === !1)
                         return;
-                    Z(C);
+                    ne(R);
                     break;
-                case r.DOLLY:
+                case i.DOLLY:
                     if (n.enableZoom === !1)
                         return;
-                    H(C);
+                    V(R);
                     break;
-                case r.PAN:
+                case i.PAN:
                     if (n.enablePan === !1)
                         return;
-                    ee(C);
+                    J(R);
                     break;
             }
         }
 
-        function X(C) {
-            n.enabled === !1 || n.enableZoom === !1 || s !== r.NONE || (C.preventDefault(), n.dispatchEvent(Qs), pe(C), n.dispatchEvent(sl));
+        function k(R) {
+            n.enabled === !1 || n.enableZoom === !1 || r !== i.NONE || (R.preventDefault(), n.dispatchEvent(Ca), se(R), n.dispatchEvent(Ql));
         }
 
-        function Q(C) {
-            n.enabled === !1 || n.enablePan === !1 || Te(C);
+        function Z(R) {
+            n.enabled === !1 || n.enablePan === !1 || Ae(R);
         }
 
-        function te(C) {
-            switch (ce(C), b.length) {
+        function re(R) {
+            switch (de(R), T.length) {
                 case 1:
                     switch (n.touches.ONE) {
-                        case hi.ROTATE:
+                        case Ci.ROTATE:
                             if (n.enableRotate === !1)
                                 return;
-                            xe(), s = r.TOUCH_ROTATE;
+                            xe(), r = i.TOUCH_ROTATE;
                             break;
-                        case hi.PAN:
+                        case Ci.PAN:
                             if (n.enablePan === !1)
                                 return;
-                            ge(), s = r.TOUCH_PAN;
+                            ge(), r = i.TOUCH_PAN;
                             break;
                         default:
-                            s = r.NONE;
+                            r = i.NONE;
                     }
                     break;
                 case 2:
                     switch (n.touches.TWO) {
-                        case hi.DOLLY_PAN:
+                        case Ci.DOLLY_PAN:
                             if (n.enableZoom === !1 && n.enablePan === !1)
                                 return;
-                            we(), s = r.TOUCH_DOLLY_PAN;
+                            Re(), r = i.TOUCH_DOLLY_PAN;
                             break;
-                        case hi.DOLLY_ROTATE:
+                        case Ci.DOLLY_ROTATE:
                             if (n.enableZoom === !1 && n.enableRotate === !1)
                                 return;
-                            F(), s = r.TOUCH_DOLLY_ROTATE;
+                            O(), r = i.TOUCH_DOLLY_ROTATE;
                             break;
                         default:
-                            s = r.NONE;
+                            r = i.NONE;
                     }
                     break;
                 default:
-                    s = r.NONE;
+                    r = i.NONE;
             }
-            s !== r.NONE && n.dispatchEvent(Qs);
+            r !== i.NONE && n.dispatchEvent(Ca);
         }
 
-        function $(C) {
-            switch (ce(C), s) {
-                case r.TOUCH_ROTATE:
+        function ie(R) {
+            switch (de(R), r) {
+                case i.TOUCH_ROTATE:
                     if (n.enableRotate === !1)
                         return;
-                    lt(C), n.update();
+                    Je(R), n.update();
                     break;
-                case r.TOUCH_PAN:
+                case i.TOUCH_PAN:
                     if (n.enablePan === !1)
                         return;
-                    Me(C), n.update();
+                    Te(R), n.update();
                     break;
-                case r.TOUCH_DOLLY_PAN:
+                case i.TOUCH_DOLLY_PAN:
                     if (n.enableZoom === !1 && n.enablePan === !1)
                         return;
-                    ye(C), n.update();
+                    Me(R), n.update();
                     break;
-                case r.TOUCH_DOLLY_ROTATE:
+                case i.TOUCH_DOLLY_ROTATE:
                     if (n.enableZoom === !1 && n.enableRotate === !1)
                         return;
-                    qe(C), n.update();
+                    ze(R), n.update();
                     break;
                 default:
-                    s = r.NONE;
+                    r = i.NONE;
             }
         }
 
-        function Le(C) {
-            n.enabled !== !1 && C.preventDefault();
+        function Be(R) {
+            n.enabled !== !1 && R.preventDefault();
         }
 
-        function Ae(C) {
-            b.push(C);
+        function Pe(R) {
+            T.push(R);
         }
 
-        function se(C) {
-            delete I[C.pointerId];
-            for (let le = 0; le < b.length; le++)
-                if (b[le].pointerId == C.pointerId) {
-                    b.splice(le, 1);
+        function oe(R) {
+            delete L[R.pointerId];
+            for (let ue = 0; ue < T.length; ue++)
+                if (T[ue].pointerId == R.pointerId) {
+                    T.splice(ue, 1);
                     return;
                 }
         }
 
-        function ce(C) {
-            let le = I[C.pointerId];
-            le === void 0 && (le = new me(), I[C.pointerId] = le), le.set(C.pageX, C.pageY);
+        function de(R) {
+            let ue = L[R.pointerId];
+            ue === void 0 && (ue = new Ee(), L[R.pointerId] = ue), ue.set(R.pageX, R.pageY);
         }
 
-        function Re(C) {
-            const le = C.pointerId === b[0].pointerId ? b[1] : b[0];
-            return I[le.pointerId];
+        function De(R) {
+            const ue = R.pointerId === T[0].pointerId ? T[1] : T[0];
+            return L[ue.pointerId];
         }
-        n.domElement.addEventListener("contextmenu", Le), n.domElement.addEventListener("pointerdown", Ie), n.domElement.addEventListener("pointercancel", Je), n.domElement.addEventListener("wheel", X, {
+        n.domElement.addEventListener("contextmenu", Be), n.domElement.addEventListener("pointerdown", Oe), n.domElement.addEventListener("pointercancel", Ke), n.domElement.addEventListener("wheel", k, {
             passive: !1
         }), this.update();
     }
 }
-class p_ {
-    constructor(e, t) {
-        this.message = e || "Loading...", this.container = t || document.body, this.spinnerDivContainerOuter = document.createElement("div"), this.spinnerDivContainerOuter.className = "outerContainer", this.spinnerDivContainerOuter.style.display = "none", this.spinnerDivContainer = document.createElement("div"), this.spinnerDivContainer.className = "container", this.spinnerDiv = document.createElement("div"), this.spinnerDiv.className = "loader", this.messageDiv = document.createElement("div"), this.messageDiv.className = "message", this.messageDiv.innerHTML = this.message, this.spinnerDivContainer.appendChild(this.spinnerDiv), this.spinnerDivContainer.appendChild(this.messageDiv), this.spinnerDivContainerOuter.appendChild(this.spinnerDivContainer), this.container.appendChild(this.spinnerDivContainerOuter);
-        const n = document.createElement("style");
-        n.innerHTML = `
-
-            .message {
-                font-family: arial;
-                font-size: 12pt;
-                color: #ffffff;
-                text-align: center;
-                padding-top:15px;
-                width: 180px;
-            }
+const c_ = (s, e, t, n, i) => {
+        const r = performance.now();
+        let o = s.style.display === "none" ? 0 : parseFloat(s.style.opacity);
+        isNaN(o) && (o = 1);
+        const a = window.setInterval(() => {
+            const c = performance.now() - r;
+            let u = Math.min(c / n, 1);
+            u > 0.999 && (u = 1);
+            let d;
+            e ? (d = (1 - u) * o, d < 1e-4 && (d = 0)) : d = (1 - o) * u + o, d > 0 ? (s.style.display = t, s.style.opacity = d) : s.style.display = "none", u >= 1 && (i && i(), window.clearInterval(a));
+        }, 16);
+        return a;
+    },
+    u_ = 500,
+    Pr = class Pr {
+        constructor(e, t) {
+            this.taskIDGen = 0, this.elementID = Pr.elementIDGen++, this.tasks = [], this.message = e || "Loading...", this.container = t || document.body, this.spinnerContainerOuter = document.createElement("div"), this.spinnerContainerOuter.className = `spinnerOuterContainer${this.elementID}`, this.spinnerContainerOuter.style.display = "none", this.spinnerContainerPrimary = document.createElement("div"), this.spinnerContainerPrimary.className = `spinnerContainerPrimary${this.elementID}`, this.spinnerPrimary = document.createElement("div"), this.spinnerPrimary.classList.add(`spinner${this.elementID}`, `spinnerPrimary${this.elementID}`), this.messageContainerPrimary = document.createElement("div"), this.messageContainerPrimary.classList.add(`messageContainer${this.elementID}`, `messageContainerPrimary${this.elementID}`), this.messageContainerPrimary.innerHTML = this.message, this.spinnerContainerMin = document.createElement("div"), this.spinnerContainerMin.className = `spinnerContainerMin${this.elementID}`, this.spinnerMin = document.createElement("div"), this.spinnerMin.classList.add(`spinner${this.elementID}`, `spinnerMin${this.elementID}`), this.messageContainerMin = document.createElement("div"), this.messageContainerMin.classList.add(`messageContainer${this.elementID}`, `messageContainerMin${this.elementID}`), this.messageContainerMin.innerHTML = this.message, this.spinnerContainerPrimary.appendChild(this.spinnerPrimary), this.spinnerContainerPrimary.appendChild(this.messageContainerPrimary), this.spinnerContainerOuter.appendChild(this.spinnerContainerPrimary), this.spinnerContainerMin.appendChild(this.spinnerMin), this.spinnerContainerMin.appendChild(this.messageContainerMin), this.spinnerContainerOuter.appendChild(this.spinnerContainerMin);
+            const n = document.createElement("style");
+            n.innerHTML = `
 
-            .outerContainer {
+            .spinnerOuterContainer${this.elementID} {
                 width: 100%;
                 height: 100%;
+                margin: 0;
+                top: 0;
+                left: 0;
+                position: absolute;
+                pointer-events: none;
             }
 
-            .container {
-                position: absolute;
-                top: 50%;
-                left: 50%;
-                transform: translate(-80px, -80px);
-                width: 180px;
+            .messageContainer${this.elementID} {
+                height: 20px;
+                font-family: arial;
+                font-size: 12pt;
+                color: #ffffff;
+                text-align: center;
+                vertical-align: middle;
             }
 
-            .loader {
-                width: 120px;        /* the size */
-                padding: 15px;       /* the border thickness */
-                background: #07e8d6; /* the color */
+            .spinner${this.elementID} {
+                padding: 15px;
+                background: #07e8d6;
                 z-index:99999;
             
                 aspect-ratio: 1;
                 border-radius: 50%;
                 --_m: 
                     conic-gradient(#0000,#000),
                     linear-gradient(#000 0 0) content-box;
                 -webkit-mask: var(--_m);
                     mask: var(--_m);
                 -webkit-mask-composite: source-out;
                     mask-composite: subtract;
                 box-sizing: border-box;
                 animation: load 1s linear infinite;
+            }
+
+            .spinnerContainerPrimary${this.elementID} {
+                z-index:99999;
+                background-color: rgba(128, 128, 128, 0.75);
+                border: #666666 1px solid;
+                border-radius: 5px;
+                padding-top: 20px;
+                padding-bottom: 10px;
+                margin: 0;
+                position: absolute;
+                top: 50%;
+                left: 50%;
+                transform: translate(-80px, -80px);
+                width: 180px;
+                pointer-events: auto;
+            }
+
+            .spinnerPrimary${this.elementID} {
+                width: 120px;
                 margin-left: 30px;
             }
+
+            .messageContainerPrimary${this.elementID} {
+                padding-top: 15px;
+            }
+
+            .spinnerContainerMin${this.elementID} {
+                z-index:99999;
+                background-color: rgba(128, 128, 128, 0.75);
+                border: #666666 1px solid;
+                border-radius: 5px;
+                padding-top: 20px;
+                padding-bottom: 15px;
+                margin: 0;
+                position: absolute;
+                bottom: 50px;
+                left: 50%;
+                transform: translate(-50%, 0);
+                display: flex;
+                flex-direction: left;
+                pointer-events: auto;
+                min-width: 250px;
+            }
+
+            .messageContainerMin${this.elementID} {
+                margin-right: 15px;
+            }
+
+            .spinnerMin${this.elementID} {
+                width: 50px;
+                height: 50px;
+                margin-left: 15px;
+                margin-right: 25px;
+            }
+
+            .messageContainerMin${this.elementID} {
+                padding-top: 15px;
+            }
             
             @keyframes load {
                 to{transform: rotate(1turn)}
             }
 
-        `, this.spinnerDivContainerOuter.appendChild(n);
+        `, this.spinnerContainerOuter.appendChild(n), this.container.appendChild(this.spinnerContainerOuter), this.setMinimized(!1, !0), this.fadeTransitions = [];
+        }
+        addTask(e) {
+            const t = {
+                message: e,
+                id: this.taskIDGen++
+            };
+            return this.tasks.push(t), this.update(), t.id;
+        }
+        removeTask(e) {
+            let t = 0;
+            for (let n of this.tasks) {
+                if (n.id === e) {
+                    this.tasks.splice(t, 1);
+                    break;
+                }
+                t++;
+            }
+            this.update();
+        }
+        removeAllTasks() {
+            this.tasks = [], this.update();
+        }
+        setMessageForTask(e, t) {
+            for (let n of this.tasks)
+                if (n.id === e) {
+                    n.message = t;
+                    break;
+                }
+            this.update();
+        }
+        update() {
+            this.tasks.length > 0 ? (this.show(), this.setMessage(this.tasks[this.tasks.length - 1].message)) : this.hide();
+        }
+        show() {
+            this.spinnerContainerOuter.style.display = "block", this.visible = !0;
+        }
+        hide() {
+            this.spinnerContainerOuter.style.display = "none", this.visible = !1;
+        }
+        setContainer(e) {
+            this.container && this.container.removeChild(this.spinnerContainerOuter), e && (this.container = e, this.container.appendChild(this.spinnerContainerOuter), this.spinnerContainerOuter.style.zIndex = this.container.style.zIndex + 1);
+        }
+        setMinimized(e, t) {
+            const n = (i, r, o, a, l) => {
+                o ? i.style.display = r ? a : "none" : this.fadeTransitions[l] = c_(i, !r, a, u_, () => {
+                    this.fadeTransitions[l] = null;
+                });
+            };
+            n(this.spinnerContainerPrimary, !e, t, "block", 0), n(this.spinnerContainerMin, e, t, "flex", 1), this.minimized = e;
+        }
+        setMessage(e) {
+            this.messageContainerPrimary.innerHTML = e, this.messageContainerMin.innerHTML = e;
+        }
+    };
+le(Pr, "elementIDGen", 0);
+let Ha = Pr;
+class d_ {
+    constructor(e) {
+        this.idGen = 0, this.tasks = [], this.container = e || document.body, this.progressBarContainerOuter = document.createElement("div"), this.progressBarContainerOuter.className = "progressBarOuterContainer", this.progressBarContainerOuter.style.display = "none", this.progressBarBox = document.createElement("div"), this.progressBarBox.className = "progressBarBox", this.progressBarBackground = document.createElement("div"), this.progressBarBackground.className = "progressBarBackground", this.progressBar = document.createElement("div"), this.progressBar.className = "progressBar", this.progressBarBackground.appendChild(this.progressBar), this.progressBarBox.appendChild(this.progressBarBackground), this.progressBarContainerOuter.appendChild(this.progressBarBox);
+        const t = document.createElement("style");
+        t.innerHTML = `
+
+            .progressBarOuterContainer {
+                width: 100%;
+                height: 100%;
+                margin: 0;
+                top: 0;
+                left: 0;
+                position: absolute;
+                pointer-events: none;
+            }
+
+            .progressBarBox {
+                z-index:99999;
+                padding: 7px 9px 5px 7px;
+                background-color: rgba(190, 190, 190, 0.75);
+                border: #555555 1px solid;
+                border-radius: 15px;
+                margin: 0;
+                position: absolute;
+                bottom: 50px;
+                left: 50%;
+                transform: translate(-50%, 0);
+                width: 180px;
+                height: 30px;
+                pointer-events: auto;
+            }
+
+            .progressBarBackground {
+                width: 100%;
+                height: 25px;
+                border-radius:10px;
+                background-color: rgba(128, 128, 128, 0.75);
+                border: #444444 1px solid;
+                box-shadow: inset 0 0 10px #333333;
+            }
+
+            .progressBar {
+                height: 25px;
+                width: 0px;
+                border-radius:10px;
+                background-color: rgba(0, 200, 0, 0.75);
+                box-shadow: inset 0 0 10px #003300;
+            }
+
+        `, this.progressBarContainerOuter.appendChild(t), this.container.appendChild(this.progressBarContainerOuter);
     }
     show() {
-        this.spinnerDivContainerOuter.style.display = "block";
+        this.progressBarContainerOuter.style.display = "block";
     }
     hide() {
-        this.spinnerDivContainerOuter.style.display = "none";
+        this.progressBarContainerOuter.style.display = "none";
+    }
+    setProgress(e) {
+        this.progressBar.style.width = e + "%";
+    }
+    setContainer(e) {
+        this.container && this.container.removeChild(this.progressBarContainerOuter), e && (this.container = e, this.container.appendChild(this.progressBarContainerOuter), this.progressBarContainerOuter.style.zIndex = this.container.style.zIndex + 1);
+    }
+}
+class f_ {
+    constructor(e) {
+        le(this, "update", function(e, t, n, i, r, o, a, l, c, u, d, f, h, g) {
+            const _ = `${t.x.toFixed(5)}, ${t.y.toFixed(5)}, ${t.z.toFixed(5)}`;
+            if (this.infoCells.cameraPosition.innerHTML !== _ && (this.infoCells.cameraPosition.innerHTML = _), n) {
+                const p = n,
+                    v = `${p.x.toFixed(5)}, ${p.y.toFixed(5)}, ${p.z.toFixed(5)}`;
+                this.infoCells.cameraLookAt.innerHTML !== v && (this.infoCells.cameraLookAt.innerHTML = v);
+            }
+            const m = `${i.x.toFixed(5)}, ${i.y.toFixed(5)}, ${i.z.toFixed(5)}`;
+            if (this.infoCells.cameraUp.innerHTML !== m && (this.infoCells.cameraUp.innerHTML = m), this.infoCells.orthographicCamera.innerHTML = r ? "Orthographic" : "Perspective", o) {
+                const p = o,
+                    v = `${p.x.toFixed(5)}, ${p.y.toFixed(5)}, ${p.z.toFixed(5)}`;
+                this.infoCells.cursorPosition.innerHTML = v;
+            } else
+                this.infoCells.cursorPosition.innerHTML = "N/A";
+            this.infoCells.fps.innerHTML = a, this.infoCells.renderWindow.innerHTML = `${e.x} x ${e.y}`, this.infoCells.renderSplatCount.innerHTML = `${c} splats out of ${l} (${u.toFixed(2)}%)`, this.infoCells.sortTime.innerHTML = `${d.toFixed(3)} ms`, this.infoCells.focalAdjustment.innerHTML = `${f.toFixed(3)}`, this.infoCells.splatScale.innerHTML = `${h.toFixed(3)}`, this.infoCells.pointCloudMode.innerHTML = `${g}`;
+        });
+        this.container = e || document.body, this.infoCells = {};
+        const t = [
+            ["Camera position", "cameraPosition"],
+            ["Camera look-at", "cameraLookAt"],
+            ["Camera up", "cameraUp"],
+            ["Camera mode", "orthographicCamera"],
+            ["Cursor position", "cursorPosition"],
+            ["FPS", "fps"],
+            ["Rendering:", "renderSplatCount"],
+            ["Sort time", "sortTime"],
+            ["Render window", "renderWindow"],
+            ["Focal adjustment", "focalAdjustment"],
+            ["Splat scale", "splatScale"],
+            ["Point cloud mode", "pointCloudMode"]
+        ];
+        this.infoPanelContainer = document.createElement("div");
+        const n = document.createElement("style");
+        n.innerHTML = `
+
+            .infoPanel {
+                width: 430px;
+                padding: 10px;
+                background-color: rgba(50, 50, 50, 0.85);
+                border: #555555 2px solid;
+                color: #dddddd;
+                border-radius: 10px;
+                z-index: 9999;
+                font-family: arial;
+                font-size: 11pt;
+                text-align: left;
+                margin: 0;
+                top: 10px;
+                left:10px;
+                position: absolute;
+                pointer-events: auto;
+            }
+
+            .info-panel-cell {
+                margin-bottom: 5px;
+                padding-bottom: 2px;
+            }
+
+            .label-cell {
+                font-weight: bold;
+                font-size: 12pt;
+                width: 140px;
+            }
+
+        `, this.infoPanelContainer.append(n), this.infoPanel = document.createElement("div"), this.infoPanel.className = "infoPanel";
+        const i = document.createElement("div");
+        i.style.display = "table";
+        for (let r of t) {
+            const o = document.createElement("div");
+            o.style.display = "table-row", o.className = "info-panel-row";
+            const a = document.createElement("div");
+            a.style.display = "table-cell", a.innerHTML = `${r[0]}: `, a.classList.add("info-panel-cell", "label-cell");
+            const l = document.createElement("div");
+            l.style.display = "table-cell", l.style.width = "10px", l.innerHTML = " ", l.className = "info-panel-cell";
+            const c = document.createElement("div");
+            c.style.display = "table-cell", c.innerHTML = "", c.className = "info-panel-cell", this.infoCells[r[1]] = c, o.appendChild(a), o.appendChild(l), o.appendChild(c), i.appendChild(o);
+        }
+        this.infoPanel.appendChild(i), this.infoPanelContainer.append(this.infoPanel), this.infoPanelContainer.style.display = "none", this.container.appendChild(this.infoPanelContainer), this.visible = !1;
     }
     setContainer(e) {
-        this.container && this.container.removeChild(this.spinnerDivContainerOuter), this.container = e, this.container.appendChild(this.spinnerDivContainerOuter), this.spinnerDivContainerOuter.style.zIndex = this.container.style.zIndex + 1;
+        this.container && this.container.removeChild(this.infoPanelContainer), e && (this.container = e, this.container.appendChild(this.infoPanelContainer), this.infoPanelContainer.style.zIndex = this.container.style.zIndex + 1);
     }
-    setMessage(e) {
-        this.messageDiv.innerHTML = e;
+    show() {
+        this.infoPanelContainer.style.display = "block", this.visible = !0;
+    }
+    hide() {
+        this.infoPanelContainer.style.display = "none", this.visible = !1;
     }
 }
-class m_ extends gt {
-    constructor(e = new P(0, 0, 1), t = new P(0, 0, 0), n = 1, r = 0.1, s = 16776960, a = n * 0.2, o = a * 0.2) {
+class h_ extends Et {
+    constructor(e = new D(0, 0, 1), t = new D(0, 0, 0), n = 1, i = 0.1, r = 16776960, o = n * 0.2, a = o * 0.2) {
         super(), this.type = "ArrowHelper";
-        const l = new hr(r, r, n, 32);
+        const l = new Is(i, i, n, 32);
         l.translate(0, n / 2, 0);
-        const c = new hr(0, o, a, 32);
-        c.translate(0, n, 0), this.position.copy(t), this.line = new at(l, new oi({
-            color: s,
+        const c = new Is(0, a, o, 32);
+        c.translate(0, n, 0), this.position.copy(t), this.line = new pt(l, new yi({
+            color: r,
             toneMapped: !1
-        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new at(c, new oi({
-            color: s,
+        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new pt(c, new yi({
+            color: r,
             toneMapped: !1
         })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e);
     }
     setDirection(e) {
         if (e.y > 0.99999)
             this.quaternion.set(0, 0, 0, 1);
         else if (e.y < -0.99999)
@@ -18749,38 +20396,41 @@
     copy(e) {
         return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this;
     }
     dispose() {
         this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
     }
 }
-class ar {
+class Cs {
     constructor(e) {
-        Pe(this, "updateFocusMarker", function() {
-            const e = new P(),
-                t = new ke();
-            return function(n, r, s) {
-                t.copy(r.matrixWorld).invert(), e.copy(n).applyMatrix4(t), e.normalize().multiplyScalar(10), e.applyMatrix4(r.matrixWorld), this.focusMarker.position.copy(e), this.focusMarker.material.uniforms.realFocusPosition.value.copy(n), this.focusMarker.material.uniforms.viewport.value.copy(s), this.focusMarker.material.uniformsNeedUpdate = !0;
+        le(this, "updateFocusMarker", function() {
+            const e = new D(),
+                t = new Ge(),
+                n = new D();
+            return function(i, r, o) {
+                t.copy(r.matrixWorld).invert(), e.copy(i).applyMatrix4(t), e.normalize().multiplyScalar(10), e.applyMatrix4(r.matrixWorld), n.copy(r.position).sub(i);
+                const a = n.length();
+                this.focusMarker.position.copy(i), this.focusMarker.scale.set(a, a, a), this.focusMarker.material.uniforms.realFocusPosition.value.copy(i), this.focusMarker.material.uniforms.viewport.value.copy(o), this.focusMarker.material.uniformsNeedUpdate = !0;
             };
         }());
-        Pe(this, "positionAndOrientControlPlane", function() {
-            const e = new wt(),
-                t = new P(0, 1, 0);
-            return function(n, r) {
-                e.setFromUnitVectors(t, r), this.controlPlane.position.copy(n), this.controlPlane.quaternion.copy(e);
+        le(this, "positionAndOrientControlPlane", function() {
+            const e = new St(),
+                t = new D(0, 1, 0);
+            return function(n, i) {
+                e.setFromUnitVectors(t, i), this.controlPlane.position.copy(n), this.controlPlane.quaternion.copy(e);
             };
         }());
         this.threeScene = e, this.splatRenderTarget = null, this.renderTargetCopyQuad = null, this.renderTargetCopyCamera = null, this.meshCursor = null, this.focusMarker = null, this.controlPlane = null, this.debugRoot = null, this.secondaryDebugRoot = null;
     }
     updateSplatRenderTargetForRenderDimensions(e, t) {
-        this.destroySplatRendertarget(), this.splatRenderTarget = new Vn(e, t, {
-            format: Vt,
+        this.destroySplatRendertarget(), this.splatRenderTarget = new ti(e, t, {
+            format: kt,
             stencilBuffer: !1,
             depthBuffer: !0
-        }), this.splatRenderTarget.depthTexture = new xo(e, t), this.splatRenderTarget.depthTexture.format = Hn, this.splatRenderTarget.depthTexture.type = nn;
+        }), this.splatRenderTarget.depthTexture = new no(e, t), this.splatRenderTarget.depthTexture.format = ei, this.splatRenderTarget.depthTexture.type = fn;
     }
     destroySplatRendertarget() {
         this.splatRenderTarget && (this.splatRenderTarget = null);
     }
     setupRenderTargetCopyObjects() {
         const e = {
                 sourceColorTexture: {
@@ -18788,15 +20438,15 @@
                     value: null
                 },
                 sourceDepthTexture: {
                     type: "t",
                     value: null
                 }
             },
-            t = new Xt({
+            t = new tn({
                 vertexShader: `
                 varying vec2 vUv;
                 void main() {
                     vUv = uv;
                     gl_Position = vec4( position.xy, 0.0, 1.0 );    
                 }
             `,
@@ -18813,124 +20463,127 @@
                     gl_FragColor = vec4(color.rgb, color.a * 2.0);
               }
             `,
                 uniforms: e,
                 depthWrite: !1,
                 depthTest: !1,
                 transparent: !0,
-                blending: Nl,
-                blendSrc: cr,
-                blendSrcAlpha: cr,
-                blendDst: ur,
-                blendDstAlpha: ur
+                blending: Pc,
+                blendSrc: Ps,
+                blendSrcAlpha: Ps,
+                blendDst: Ds,
+                blendDstAlpha: Ds
             });
-        t.extensions.fragDepth = !0, this.renderTargetCopyQuad = new at(new Wi(2, 2), t), this.renderTargetCopyCamera = new oc(-1, 1, 1, -1, 0, 1);
+        t.extensions.fragDepth = !0, this.renderTargetCopyQuad = new pt(new ds(2, 2), t), this.renderTargetCopyCamera = new eo(-1, 1, 1, -1, 0, 1);
     }
     destroyRenderTargetCopyObjects() {
-        this.renderTargetCopyQuad && (Ii(this.renderTargetCopyQuad), this.renderTargetCopyQuad = null);
+        this.renderTargetCopyQuad && (Zi(this.renderTargetCopyQuad), this.renderTargetCopyQuad = null);
     }
     setupMeshCursor() {
         if (!this.meshCursor) {
-            const e = new So(0.5, 1.5, 32),
-                t = new oi({
+            const e = new io(0.5, 1.5, 32),
+                t = new yi({
                     color: 16777215
                 }),
-                n = new at(e, t);
+                n = new pt(e, t);
             n.rotation.set(0, 0, Math.PI), n.position.set(0, 1, 0);
-            const r = new at(e, t);
-            r.position.set(0, -1, 0);
-            const s = new at(e, t);
-            s.rotation.set(0, 0, Math.PI / 2), s.position.set(1, 0, 0);
-            const a = new at(e, t);
-            a.rotation.set(0, 0, -Math.PI / 2), a.position.set(-1, 0, 0), this.meshCursor = new gt(), this.meshCursor.add(n), this.meshCursor.add(r), this.meshCursor.add(s), this.meshCursor.add(a), this.meshCursor.scale.set(0.1, 0.1, 0.1), this.threeScene.add(this.meshCursor), this.meshCursor.visible = !1;
+            const i = new pt(e, t);
+            i.position.set(0, -1, 0);
+            const r = new pt(e, t);
+            r.rotation.set(0, 0, Math.PI / 2), r.position.set(1, 0, 0);
+            const o = new pt(e, t);
+            o.rotation.set(0, 0, -Math.PI / 2), o.position.set(-1, 0, 0), this.meshCursor = new Et(), this.meshCursor.add(n), this.meshCursor.add(i), this.meshCursor.add(r), this.meshCursor.add(o), this.meshCursor.scale.set(0.1, 0.1, 0.1), this.threeScene.add(this.meshCursor), this.meshCursor.visible = !1;
         }
     }
     destroyMeshCursor() {
-        this.meshCursor && (Ii(this.meshCursor), this.threeScene.remove(this.meshCursor), this.meshCursor = null);
+        this.meshCursor && (Zi(this.meshCursor), this.threeScene.remove(this.meshCursor), this.meshCursor = null);
     }
     setMeshCursorVisibility(e) {
         this.meshCursor.visible = e;
     }
+    getMeschCursorVisibility() {
+        return this.meshCursor.visible;
+    }
     setMeshCursorPosition(e) {
         this.meshCursor.position.copy(e);
     }
     positionAndOrientMeshCursor(e, t) {
         this.meshCursor.position.copy(e), this.meshCursor.up.copy(t.up), this.meshCursor.lookAt(t.position);
     }
     setupFocusMarker() {
         if (!this.focusMarker) {
-            const e = new es(0.5, 32, 32),
-                t = ar.buildFocusMarkerMaterial();
-            t.depthTest = !1, t.depthWrite = !1, t.transparent = !0, this.focusMarker = new at(e, t);
+            const e = new br(0.5, 32, 32),
+                t = Cs.buildFocusMarkerMaterial();
+            t.depthTest = !1, t.depthWrite = !1, t.transparent = !0, this.focusMarker = new pt(e, t);
         }
     }
     destroyFocusMarker() {
-        this.focusMarker && (Ii(this.focusMarker), this.focusMarker = null);
+        this.focusMarker && (Zi(this.focusMarker), this.focusMarker = null);
     }
     setFocusMarkerVisibility(e) {
         this.focusMarker.visible = e;
     }
     setFocusMarkerOpacity(e) {
         this.focusMarker.material.uniforms.opacity.value = e, this.focusMarker.material.uniformsNeedUpdate = !0;
     }
     getFocusMarkerOpacity() {
         return this.focusMarker.material.uniforms.opacity.value;
     }
     setupControlPlane() {
         if (!this.controlPlane) {
-            const e = new Wi(1, 1);
+            const e = new ds(1, 1);
             e.rotateX(-Math.PI / 2);
-            const t = new oi({
+            const t = new yi({
                 color: 16777215
             });
-            t.transparent = !0, t.opacity = 0.6, t.depthTest = !1, t.depthWrite = !1, t.side = en;
-            const n = new at(e, t),
-                r = new P(0, 1, 0);
-            r.normalize();
-            const s = new P(0, 0, 0),
-                a = 0.5,
-                o = 0.01,
+            t.transparent = !0, t.opacity = 0.6, t.depthTest = !1, t.depthWrite = !1, t.side = un;
+            const n = new pt(e, t),
+                i = new D(0, 1, 0);
+            i.normalize();
+            const r = new D(0, 0, 0),
+                o = 0.5,
+                a = 0.01,
                 l = 56576,
-                c = new m_(r, s, a, o, l, 0.1, 0.03);
-            this.controlPlane = new gt(), this.controlPlane.add(n), this.controlPlane.add(c);
+                c = new h_(i, r, o, a, l, 0.1, 0.03);
+            this.controlPlane = new Et(), this.controlPlane.add(n), this.controlPlane.add(c);
         }
     }
     destroyControlPlane() {
-        this.controlPlane && (Ii(this.controlPlane), this.controlPlane = null);
+        this.controlPlane && (Zi(this.controlPlane), this.controlPlane = null);
     }
     setControlPlaneVisibility(e) {
         this.controlPlane.visible = e;
     }
     addDebugMeshes() {
         this.debugRoot = this.createDebugMeshes(), this.secondaryDebugRoot = this.createSecondaryDebugMeshes(), this.threeScene.add(this.debugRoot), this.threeScene.add(this.secondaryDebugRoot);
     }
     destroyDebugMeshes() {
         for (let e of [this.debugRoot, this.secondaryDebugRoot])
-            e && (Ii(e), this.threeScene.remove(e));
+            e && (Zi(e), this.threeScene.remove(e));
         this.debugRoot = null, this.secondaryDebugRoot = null;
     }
     createDebugMeshes(e) {
-        const t = new es(1, 32, 32),
-            n = new gt(),
-            r = (s, a) => {
-                let o = new at(t, ar.buildDebugMaterial(s));
-                o.renderOrder = e, n.add(o), o.position.fromArray(a);
+        const t = new br(1, 32, 32),
+            n = new Et(),
+            i = (r, o) => {
+                let a = new pt(t, Cs.buildDebugMaterial(r));
+                a.renderOrder = e, n.add(a), a.position.fromArray(o);
             };
-        return r(16711680, [-50, 0, 0]), r(16711680, [50, 0, 0]), r(65280, [0, 0, -50]), r(65280, [0, 0, 50]), r(16755200, [5, 0, 5]), n;
+        return i(16711680, [-50, 0, 0]), i(16711680, [50, 0, 0]), i(65280, [0, 0, -50]), i(65280, [0, 0, 50]), i(16755200, [5, 0, 5]), n;
     }
     createSecondaryDebugMeshes(e) {
-        const t = new Qi(3, 3, 3),
-            n = new gt();
-        let r = 12303291;
-        const s = (o) => {
-            let l = new at(t, ar.buildDebugMaterial(r));
-            l.renderOrder = e, n.add(l), l.position.fromArray(o);
+        const t = new gs(3, 3, 3),
+            n = new Et();
+        let i = 12303291;
+        const r = (a) => {
+            let l = new pt(t, Cs.buildDebugMaterial(i));
+            l.renderOrder = e, n.add(l), l.position.fromArray(a);
         };
-        let a = 10;
-        return s([-a, 0, -a]), s([-a, 0, a]), s([a, 0, -a]), s([a, 0, a]), n;
+        let o = 10;
+        return r([-o, 0, -o]), r([-o, 0, o]), r([o, 0, -o]), r([o, 0, o]), n;
     }
     static buildDebugMaterial(e) {
         const t = `
             #include <common>
             varying float ndcDepth;
 
             void main() {
@@ -18948,30 +20601,30 @@
             uniform vec3 color;
             varying float ndcDepth;
             void main() {
                 gl_FragDepth = (ndcDepth + 1.0) / 2.0;
                 gl_FragColor = vec4(color.rgb, 0.0);
             }
         `,
-            r = {
+            i = {
                 color: {
                     type: "v3",
-                    value: new Qe(e)
+                    value: new et(e)
                 }
             },
-            s = new Xt({
-                uniforms: r,
+            r = new tn({
+                uniforms: i,
                 vertexShader: t,
                 fragmentShader: n,
                 transparent: !1,
                 depthTest: !0,
                 depthWrite: !0,
-                side: hn
+                side: yn
             });
-        return s.extensions.fragDepth = !0, s;
+        return r.extensions.fragDepth = !0, r;
     }
     static buildFocusMarkerMaterial(e) {
         const t = `
             #include <common>
 
             uniform vec2 viewport;
             uniform vec3 realFocusPosition;
@@ -19023,603 +20676,955 @@
                 float radius = 0.06 * viewport.y;
                 float radDiff = abs(projectedRadius - radius) - lineWidth;
                 float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); 
 
                 gl_FragColor = vec4(color.rgb, alpha * opacity);
             }
         `,
-            r = {
+            i = {
                 color: {
                     type: "v3",
-                    value: new Qe(e)
+                    value: new et(e)
                 },
                 realFocusPosition: {
                     type: "v3",
-                    value: new P()
+                    value: new D()
                 },
                 viewport: {
                     type: "v2",
-                    value: new me()
+                    value: new Ee()
                 },
                 opacity: {
                     value: 0
                 }
             };
-        return new Xt({
-            uniforms: r,
+        return new tn({
+            uniforms: i,
             vertexShader: t,
             fragmentShader: n,
             transparent: !0,
             depthTest: !1,
             depthWrite: !1,
-            side: hn
+            side: yn
         });
     }
     dispose() {
         this.destroyMeshCursor(), this.destroyFocusMarker(), this.destroyDebugMeshes(), this.destroyControlPlane(), this.destroyRenderTargetCopyObjects(), this.destroySplatRendertarget();
     }
 }
-const g_ = new P(1, 0, 0),
-    __ = new P(0, 1, 0),
-    v_ = new P(0, 0, 1);
-class Zs {
-    constructor(e = new P(), t = new P()) {
-        Pe(this, "intersectBox", function() {
-            const e = new P(),
+const p_ = new D(1, 0, 0),
+    m_ = new D(0, 1, 0),
+    g_ = new D(0, 0, 1);
+class wa {
+    constructor(e = new D(), t = new D()) {
+        le(this, "intersectBox", function() {
+            const e = new D(),
                 t = [],
                 n = [],
-                r = [];
-            return function(s, a) {
-                if (n[0] = this.origin.x, n[1] = this.origin.y, n[2] = this.origin.z, r[0] = this.direction.x, r[1] = this.direction.y, r[2] = this.direction.z, this.boxContainsPoint(s, this.origin, 1e-4))
-                    return a && (a.origin.copy(this.origin), a.normal.set(0, 0, 0), a.distance = -1), !0;
-                for (let o = 0; o < 3; o++) {
-                    if (r[o] == 0)
+                i = [];
+            return function(r, o) {
+                if (n[0] = this.origin.x, n[1] = this.origin.y, n[2] = this.origin.z, i[0] = this.direction.x, i[1] = this.direction.y, i[2] = this.direction.z, this.boxContainsPoint(r, this.origin, 1e-4))
+                    return o && (o.origin.copy(this.origin), o.normal.set(0, 0, 0), o.distance = -1), !0;
+                for (let a = 0; a < 3; a++) {
+                    if (i[a] == 0)
                         continue;
-                    const l = o == 0 ? g_ : o == 1 ? __ : v_,
-                        c = r[o] < 0 ? s.max : s.min;
-                    let u = -Math.sign(r[o]);
-                    t[0] = o == 0 ? c.x : o == 1 ? c.y : c.z;
-                    let f = t[0] - n[o];
-                    if (f * u < 0) {
-                        const h = (o + 1) % 3,
-                            p = (o + 2) % 3;
-                        if (t[2] = r[h] / r[o] * f + n[h], t[1] = r[p] / r[o] * f + n[p], e.set(
-                                t[o],
-                                t[p],
-                                t[h]
-                            ), this.boxContainsPoint(s, e, 1e-4))
-                            return a && (a.origin.copy(e), a.normal.copy(l).multiplyScalar(u), a.distance = e.sub(this.origin).length()), !0;
+                    const l = a == 0 ? p_ : a == 1 ? m_ : g_,
+                        c = i[a] < 0 ? r.max : r.min;
+                    let u = -Math.sign(i[a]);
+                    t[0] = a == 0 ? c.x : a == 1 ? c.y : c.z;
+                    let d = t[0] - n[a];
+                    if (d * u < 0) {
+                        const f = (a + 1) % 3,
+                            h = (a + 2) % 3;
+                        if (t[2] = i[f] / i[a] * d + n[f], t[1] = i[h] / i[a] * d + n[h], e.set(
+                                t[a],
+                                t[h],
+                                t[f]
+                            ), this.boxContainsPoint(r, e, 1e-4))
+                            return o && (o.origin.copy(e), o.normal.copy(l).multiplyScalar(u), o.distance = e.sub(this.origin).length()), !0;
                     }
                 }
                 return !1;
             };
         }());
-        Pe(this, "intersectSphere", function() {
-            const e = new P();
-            return function(t, n, r) {
+        le(this, "intersectSphere", function() {
+            const e = new D();
+            return function(t, n, i) {
                 e.copy(t).sub(this.origin);
-                const s = e.dot(this.direction),
-                    a = s * s,
-                    l = e.dot(e) - a,
+                const r = e.dot(this.direction),
+                    o = r * r,
+                    l = e.dot(e) - o,
                     c = n * n;
                 if (l > c)
                     return !1;
                 const u = Math.sqrt(c - l),
-                    f = s - u,
-                    h = s + u;
-                if (h < 0)
+                    d = r - u,
+                    f = r + u;
+                if (f < 0)
                     return !1;
-                let p = f < 0 ? h : f;
-                return r && (r.origin.copy(this.origin).addScaledVector(this.direction, p), r.normal.copy(r.origin).sub(t).normalize(), r.distance = p), !0;
+                let h = d < 0 ? f : d;
+                return i && (i.origin.copy(this.origin).addScaledVector(this.direction, h), i.normal.copy(i.origin).sub(t).normalize(), i.distance = h), !0;
             };
         }());
-        this.origin = new P(), this.direction = new P(), this.setParameters(e, t);
+        this.origin = new D(), this.direction = new D(), this.setParameters(e, t);
     }
     setParameters(e, t) {
         this.origin.copy(e), this.direction.copy(t).normalize();
     }
     boxContainsPoint(e, t, n) {
         return !(t.x < e.min.x - n || t.x > e.max.x + n || t.y < e.min.y - n || t.y > e.max.y + n || t.z < e.min.z - n || t.z > e.max.z + n);
     }
 }
-class Mo {
+class lo {
     constructor() {
-        this.origin = new P(), this.normal = new P(), this.distance = 0, this.splatIndex = 0;
+        this.origin = new D(), this.normal = new D(), this.distance = 0, this.splatIndex = 0;
     }
-    set(e, t, n, r) {
-        this.origin.copy(e), this.normal.copy(t), this.distance = n, this.splatIndex = r;
+    set(e, t, n, i) {
+        this.origin.copy(e), this.normal.copy(t), this.distance = n, this.splatIndex = i;
     }
     clone() {
-        const e = new Mo();
+        const e = new lo();
         return e.origin.copy(this.origin), e.normal.copy(this.normal), e.distance = this.distance, e.splatIndex = this.splatIndex, e;
     }
 }
-class x_ {
+class __ {
     constructor(e, t, n = !1) {
-        Pe(this, "setFromCameraAndScreenPosition", function() {
-            const e = new me();
-            return function(t, n, r) {
-                if (e.x = n.x / r.x * 2 - 1, e.y = (r.y - n.y) / r.y * 2 - 1, t.isPerspectiveCamera)
+        le(this, "setFromCameraAndScreenPosition", function() {
+            const e = new Ee();
+            return function(t, n, i) {
+                if (e.x = n.x / i.x * 2 - 1, e.y = (i.y - n.y) / i.y * 2 - 1, t.isPerspectiveCamera)
                     this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t;
                 else if (t.isOrthographicCamera)
                     this.ray.origin.set(
-                        n.x,
-                        n.y,
+                        e.x,
+                        e.y,
                         (t.near + t.far) / (t.near - t.far)
                     ).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t;
                 else
                     throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");
             };
         }());
-        Pe(this, "intersectSplatMesh", function() {
-            const e = new ke(),
-                t = new ke(),
-                n = new ke(),
-                r = new Zs(),
-                s = new P();
-            return function(a, o = []) {
-                const l = a.getSplatTree();
-                for (let c = 0; c < l.subTrees.length; c++) {
-                    const u = l.subTrees[c];
-                    t.copy(a.matrixWorld), a.getSceneTransform(c, n), t.multiply(n), e.copy(t).invert(), r.origin.copy(this.ray.origin).applyMatrix4(e), r.direction.copy(this.ray.origin).add(this.ray.direction), r.direction.applyMatrix4(e).sub(r.origin).normalize();
-                    const f = [];
-                    u.rootNode && this.castRayAtSplatTreeNode(r, l, u.rootNode, f), f.forEach((h) => {
-                        h.origin.applyMatrix4(t), h.normal.applyMatrix4(t).normalize(), h.distance = s.copy(h.origin).sub(this.ray.origin).length();
-                    }), o.push(...f);
+        le(this, "intersectSplatMesh", function() {
+            const e = new Ge(),
+                t = new Ge(),
+                n = new Ge(),
+                i = new wa(),
+                r = new D();
+            return function(o, a = []) {
+                const l = o.getSplatTree();
+                if (l) {
+                    for (let c = 0; c < l.subTrees.length; c++) {
+                        const u = l.subTrees[c];
+                        t.copy(o.matrixWorld), o.dynamicMode && (o.getSceneTransform(c, n), t.multiply(n)), e.copy(t).invert(), i.origin.copy(this.ray.origin).applyMatrix4(e), i.direction.copy(this.ray.origin).add(this.ray.direction), i.direction.applyMatrix4(e).sub(i.origin).normalize();
+                        const d = [];
+                        u.rootNode && this.castRayAtSplatTreeNode(i, l, u.rootNode, d), d.forEach((f) => {
+                            f.origin.applyMatrix4(t), f.normal.applyMatrix4(t).normalize(), f.distance = r.copy(f.origin).sub(this.ray.origin).length();
+                        }), a.push(...d);
+                    }
+                    return a.sort((c, u) => c.distance > u.distance ? 1 : -1), a;
                 }
-                return o.sort((c, u) => c.distance > u.distance ? 1 : -1), o;
             };
         }());
-        Pe(this, "castRayAtSplatTreeNode", function() {
-            const e = new ut(),
-                t = new P(),
-                n = new P(),
-                r = new wt(),
-                s = new Mo(),
-                a = 1e-7,
-                o = new P(0, 0, 0),
-                l = new ke(),
-                c = new ke(),
-                u = new ke(),
-                f = new ke(),
-                h = new ke(),
-                p = new Zs();
-            return function(g, v, m, d = []) {
+        le(this, "castRayAtSplatTreeNode", function() {
+            const e = new _t(),
+                t = new D(),
+                n = new D(),
+                i = new St(),
+                r = new lo(),
+                o = 1e-7,
+                a = new D(0, 0, 0),
+                l = new Ge(),
+                c = new Ge(),
+                u = new Ge(),
+                d = new Ge(),
+                f = new Ge(),
+                h = new wa();
+            return function(g, _, m, p = []) {
                 if (g.intersectBox(m.boundingBox)) {
-                    if (m.data.indexes && m.data.indexes.length > 0)
-                        for (let M = 0; M < m.data.indexes.length; M++) {
-                            const _ = m.data.indexes[M];
-                            if (v.splatMesh.getSplatColor(_, e, !1), v.splatMesh.getSplatCenter(_, t, !1), v.splatMesh.getSplatScaleAndRotation(_, n, r, !1), !(n.x <= a || n.y <= a || n.z <= a))
+                    if (m.data && m.data.indexes && m.data.indexes.length > 0)
+                        for (let v = 0; v < m.data.indexes.length; v++) {
+                            const S = m.data.indexes[v];
+                            if (_.splatMesh.getSplatColor(S, e), _.splatMesh.getSplatCenter(S, t), _.splatMesh.getSplatScaleAndRotation(S, n, i), !(n.x <= o || n.y <= o || n.z <= o))
                                 if (this.raycastAgainstTrueSplatEllipsoid) {
-                                    c.makeScale(n.x, n.y, n.z), u.makeRotationFromQuaternion(r);
-                                    const A = Math.log10(e.w) * 2;
-                                    if (l.makeScale(A, A, A), h.copy(l).multiply(u).multiply(c), f.copy(h).invert(), p.origin.copy(g.origin).sub(t).applyMatrix4(f), p.direction.copy(g.origin).add(g.direction).sub(t), p.direction.applyMatrix4(f).sub(p.origin).normalize(), p.intersectSphere(o, 1, s)) {
-                                        const R = s.clone();
-                                        R.splatIndex = _, R.origin.applyMatrix4(h).add(t), d.push(R);
+                                    c.makeScale(n.x, n.y, n.z), u.makeRotationFromQuaternion(i);
+                                    const y = Math.log10(e.w) * 2;
+                                    if (l.makeScale(y, y, y), f.copy(l).multiply(u).multiply(c), d.copy(f).invert(), h.origin.copy(g.origin).sub(t).applyMatrix4(d), h.direction.copy(g.origin).add(g.direction).sub(t), h.direction.applyMatrix4(d).sub(h.origin).normalize(), h.intersectSphere(a, 1, r)) {
+                                        const b = r.clone();
+                                        b.splatIndex = S, b.origin.applyMatrix4(f).add(t), p.push(b);
                                     }
                                 } else {
-                                    const A = (n.x + n.y + n.z) / 3;
-                                    if (g.intersectSphere(t, A, s)) {
-                                        const R = s.clone();
-                                        R.splatIndex = _, d.push(R);
+                                    const y = (n.x + n.y + n.z) / 3;
+                                    if (g.intersectSphere(t, y, r)) {
+                                        const b = r.clone();
+                                        b.splatIndex = S, p.push(b);
                                     }
                                 }
                         }
                     if (m.children && m.children.length > 0)
-                        for (let M of m.children)
-                            this.castRayAtSplatTreeNode(g, v, M, d);
-                    return d;
+                        for (let v of m.children)
+                            this.castRayAtSplatTreeNode(g, _, v, p);
+                    return p;
                 }
             };
         }());
-        this.ray = new Zs(e, t), this.raycastAgainstTrueSplatEllipsoid = n;
+        this.ray = new wa(e, t), this.raycastAgainstTrueSplatEllipsoid = n;
     }
 }
 class S_ {
-    constructor(e, t = new P(), n = new wt(), r = new P(1, 1, 1)) {
-        this.splatBuffer = e, this.position = t.clone(), this.quaternion = n.clone(), this.scale = r.clone(), this.transform = new ke(), this.updateTransform();
+    constructor(e, t = new D(), n = new St(), i = new D(1, 1, 1), r = 1) {
+        this.splatBuffer = e, this.position = t.clone(), this.quaternion = n.clone(), this.scale = i.clone(), this.transform = new Ge(), this.minimumAlpha = r, this.updateTransform();
     }
     copyTransformData(e) {
         this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.transform.copy(e.transform);
     }
     updateTransform() {
         this.transform.compose(this.position, this.quaternion, this.scale);
     }
 }
-let M_ = 0;
-class al {
-    constructor(e, t, n, r) {
-        this.min = new P().copy(e), this.max = new P().copy(t), this.boundingBox = new Rt(this.min, this.max), this.center = new P().copy(this.max).sub(this.min).multiplyScalar(0.5).add(this.min), this.depth = n, this.children = [], this.data = null, this.id = r || M_++;
-    }
-}
-class y_ {
-    constructor(e, t) {
-        this.maxDepth = e, this.maxCentersPerNode = t, this.sceneDimensions = new P(), this.sceneMin = new P(), this.sceneMax = new P(), this.splatMesh = null, this.rootNode = null, this.addedIndexes = {}, this.nodesWithIndexes = [];
+const Dr = class Dr {
+    constructor(e, t, n, i) {
+        this.min = new D().copy(e), this.max = new D().copy(t), this.boundingBox = new Un(this.min, this.max), this.center = new D().copy(this.max).sub(this.min).multiplyScalar(0.5).add(this.min), this.depth = n, this.children = [], this.data = null, this.id = i || Dr.idGen++;
     }
-}
-class lr {
+};
+le(Dr, "idGen", 0);
+let Ga = Dr;
+class ws {
     constructor(e, t) {
-        this.maxDepth = e, this.maxCentersPerNode = t, this.splatMesh = null, this.subTrees = [];
+        this.maxDepth = e, this.maxCentersPerNode = t, this.sceneDimensions = new D(), this.sceneMin = new D(), this.sceneMax = new D(), this.rootNode = null, this.nodesWithIndexes = [], this.splatMesh = null;
     }
-    processSplatMesh(e, t = () => !0) {
-        this.splatMesh = e, this.subTrees = [];
-        const n = new P(),
-            r = function(s, a, o, l) {
-                const c = new y_(o, l);
-                let u = 0;
-                const f = [];
-                for (let h = 0; h < a; h++) {
-                    const p = h + s;
-                    t(p) && (e.getSplatCenter(p, n), (u === 0 || n.x < c.sceneMin.x) && (c.sceneMin.x = n.x), (u === 0 || n.x > c.sceneMax.x) && (c.sceneMax.x = n.x), (u === 0 || n.y < c.sceneMin.y) && (c.sceneMin.y = n.y), (u === 0 || n.y > c.sceneMax.y) && (c.sceneMax.y = n.y), (u === 0 || n.z < c.sceneMin.z) && (c.sceneMin.z = n.z), (u === 0 || n.z > c.sceneMax.z) && (c.sceneMax.z = n.z), u++, f.push(p));
-                }
-                return c.sceneDimensions.copy(c.sceneMax).sub(c.sceneMin), c.rootNode = new al(c.sceneMin, c.sceneMax, 0), c.rootNode.data = {
-                    indexes: f
-                }, c;
+    static convertWorkerSubTreeNode(e) {
+        const t = new D().fromArray(e.min),
+            n = new D().fromArray(e.max),
+            i = new Ga(t, n, e.depth, e.id);
+        if (e.data.indexes) {
+            i.data = {
+                indexes: []
             };
-        if (e.dynamicMode) {
-            let s = 0;
-            for (let a = 0; a < e.scenes.length; a++) {
-                const l = e.getScene(a).splatBuffer.getSplatCount(),
-                    c = r(s, l, this.maxDepth, this.maxCentersPerNode);
-                this.subTrees[a] = c, lr.processNode(c, c.rootNode, e), s += l;
-            }
-        } else {
-            const s = r(0, e.getSplatCount(), this.maxDepth, this.maxCentersPerNode);
-            this.subTrees[0] = s, lr.processNode(s, s.rootNode, e);
+            for (let r of e.data.indexes)
+                i.data.indexes.push(r);
         }
+        if (e.children)
+            for (let r of e.children)
+                i.children.push(ws.convertWorkerSubTreeNode(r));
+        return i;
     }
-    static processNode(e, t, n) {
-        const r = t.data.indexes.length;
-        if (r < e.maxCentersPerNode || t.depth > e.maxDepth) {
-            const f = [];
-            for (let h = 0; h < t.data.indexes.length; h++)
-                e.addedIndexes[t.data.indexes[h]] || (f.push(t.data.indexes[h]), e.addedIndexes[t.data.indexes[h]] = !0);
-            t.data.indexes = f, e.nodesWithIndexes.push(t);
+    static convertWorkerSubTree(e, t) {
+        const n = new ws(e.maxDepth, e.maxCentersPerNode);
+        n.sceneMin = new D().fromArray(e.sceneMin), n.sceneMax = new D().fromArray(e.sceneMax), n.splatMesh = t, n.rootNode = ws.convertWorkerSubTreeNode(e.rootNode);
+        const i = (r, o) => {
+            r.children.length === 0 && o(r);
+            for (let a of r.children)
+                i(a, o);
+        };
+        return n.nodesWithIndexes = [], i(n.rootNode, (r) => {
+            r.data && r.data.indexes && r.data.indexes.length > 0 && n.nodesWithIndexes.push(r);
+        }), n;
+    }
+}
+
+function v_(s) {
+    let e = 0;
+    class t {
+        constructor(l, c) {
+            this.min = [l[0], l[1], l[2]], this.max = [c[0], c[1], c[2]];
+        }
+        containsPoint(l) {
+            return l[0] >= this.min[0] && l[0] <= this.max[0] && l[1] >= this.min[1] && l[1] <= this.max[1] && l[2] >= this.min[2] && l[2] <= this.max[2];
+        }
+    }
+    class n {
+        constructor(l, c) {
+            this.maxDepth = l, this.maxCentersPerNode = c, this.sceneDimensions = [], this.sceneMin = [], this.sceneMax = [], this.rootNode = null, this.addedIndexes = {}, this.nodesWithIndexes = [], this.splatMesh = null, this.disposed = !1;
+        }
+    }
+    class i {
+        constructor(l, c, u, d) {
+            this.min = [l[0], l[1], l[2]], this.max = [c[0], c[1], c[2]], this.center = [
+                (c[0] - l[0]) * 0.5 + l[0],
+                (c[1] - l[1]) * 0.5 + l[1],
+                (c[2] - l[2]) * 0.5 + l[2]
+            ], this.depth = u, this.children = [], this.data = null, this.id = d || e++;
+        }
+    }
+    processSplatTreeNode = function(a, l, c, u) {
+        const d = l.data.indexes.length;
+        if (d < a.maxCentersPerNode || l.depth > a.maxDepth) {
+            const v = [];
+            for (let S = 0; S < l.data.indexes.length; S++)
+                a.addedIndexes[l.data.indexes[S]] || (v.push(l.data.indexes[S]), a.addedIndexes[l.data.indexes[S]] = !0);
+            l.data.indexes = v, l.data.indexes.sort((S, y) => S > y ? 1 : -1), a.nodesWithIndexes.push(l);
             return;
         }
-        const s = new P().copy(t.max).sub(t.min),
-            a = new P().copy(s).multiplyScalar(0.5),
-            o = new P().copy(t.min).add(a),
-            l = [
+        const f = [
+                l.max[0] - l.min[0],
+                l.max[1] - l.min[1],
+                l.max[2] - l.min[2]
+            ],
+            h = [
+                f[0] * 0.5,
+                f[1] * 0.5,
+                f[2] * 0.5
+            ],
+            g = [
+                l.min[0] + h[0],
+                l.min[1] + h[1],
+                l.min[2] + h[2]
+            ],
+            _ = [
                 // top section, clockwise from upper-left (looking from above, +Y)
-                new Rt(
-                    new P(o.x - a.x, o.y, o.z - a.z),
-                    new P(o.x, o.y + a.y, o.z)
+                new t(
+                    [g[0] - h[0], g[1], g[2] - h[2]],
+                    [g[0], g[1] + h[1], g[2]]
                 ),
-                new Rt(
-                    new P(o.x, o.y, o.z - a.z),
-                    new P(o.x + a.x, o.y + a.y, o.z)
+                new t(
+                    [g[0], g[1], g[2] - h[2]],
+                    [g[0] + h[0], g[1] + h[1], g[2]]
                 ),
-                new Rt(
-                    new P(o.x, o.y, o.z),
-                    new P(
-                        o.x + a.x,
-                        o.y + a.y,
-                        o.z + a.z
-                    )
+                new t(
+                    [g[0], g[1], g[2]],
+                    [g[0] + h[0], g[1] + h[1], g[2] + h[2]]
                 ),
-                new Rt(
-                    new P(o.x - a.x, o.y, o.z),
-                    new P(o.x, o.y + a.y, o.z + a.z)
+                new t(
+                    [g[0] - h[0], g[1], g[2]],
+                    [g[0], g[1] + h[1], g[2] + h[2]]
                 ),
                 // bottom section, clockwise from lower-left (looking from above, +Y)
-                new Rt(
-                    new P(
-                        o.x - a.x,
-                        o.y - a.y,
-                        o.z - a.z
-                    ),
-                    new P(o.x, o.y, o.z)
+                new t(
+                    [g[0] - h[0], g[1] - h[1], g[2] - h[2]],
+                    [g[0], g[1], g[2]]
                 ),
-                new Rt(
-                    new P(o.x, o.y - a.y, o.z - a.z),
-                    new P(o.x + a.x, o.y, o.z)
+                new t(
+                    [g[0], g[1] - h[1], g[2] - h[2]],
+                    [g[0] + h[0], g[1], g[2]]
                 ),
-                new Rt(
-                    new P(o.x, o.y - a.y, o.z),
-                    new P(o.x + a.x, o.y, o.z + a.z)
+                new t(
+                    [g[0], g[1] - h[1], g[2]],
+                    [g[0] + h[0], g[1], g[2] + h[2]]
                 ),
-                new Rt(
-                    new P(o.x - a.x, o.y - a.y, o.z),
-                    new P(o.x, o.y, o.z + a.z)
+                new t(
+                    [g[0] - h[0], g[1] - h[1], g[2]],
+                    [g[0], g[1], g[2] + h[2]]
                 )
             ],
-            c = [];
-        for (let f = 0; f < l.length; f++)
-            c[f] = [];
-        const u = new P();
-        for (let f = 0; f < r; f++) {
-            const h = t.data.indexes[f];
-            n.getSplatCenter(h, u);
-            for (let p = 0; p < l.length; p++)
-                l[p].containsPoint(u) && c[p].push(h);
-        }
-        for (let f = 0; f < l.length; f++) {
-            const h = new al(l[f].min, l[f].max, t.depth + 1);
-            h.data = {
-                indexes: c[f]
-            }, t.children.push(h);
-        }
-        t.data = {};
-        for (let f of t.children)
-            lr.processNode(e, f, n);
+            m = [];
+        for (let v = 0; v < _.length; v++)
+            m[v] = [];
+        const p = [0, 0, 0];
+        for (let v = 0; v < d; v++) {
+            const S = l.data.indexes[v],
+                y = c[S];
+            p[0] = u[y], p[1] = u[y + 1], p[2] = u[y + 2];
+            for (let b = 0; b < _.length; b++)
+                _[b].containsPoint(p) && m[b].push(S);
+        }
+        for (let v = 0; v < _.length; v++) {
+            const S = new i(_[v].min, _[v].max, l.depth + 1);
+            S.data = {
+                indexes: m[v]
+            }, l.children.push(S);
+        }
+        l.data = {};
+        for (let v of l.children)
+            processSplatTreeNode(a, v, c, u);
+    };
+    const r = (a, l, c) => {
+        const u = [0, 0, 0],
+            d = [0, 0, 0],
+            f = [],
+            h = Math.floor(a.length / 4);
+        for (let _ = 0; _ < h; _++) {
+            const m = _ * 4,
+                p = a[m],
+                v = a[m + 1],
+                S = a[m + 2],
+                y = Math.round(a[m + 3]);
+            (_ === 0 || p < u[0]) && (u[0] = p), (_ === 0 || p > d[0]) && (d[0] = p), (_ === 0 || v < u[1]) && (u[1] = v), (_ === 0 || v > d[1]) && (d[1] = v), (_ === 0 || S < u[2]) && (u[2] = S), (_ === 0 || S > d[2]) && (d[2] = S), f.push(y);
+        }
+        const g = new n(l, c);
+        return g.sceneMin = u, g.sceneMax = d, g.rootNode = new i(g.sceneMin, g.sceneMax, 0), g.rootNode.data = {
+            indexes: f
+        }, g;
+    };
+
+    function o(a, l, c) {
+        const u = [];
+        for (let f of a) {
+            const h = Math.floor(f.length / 4);
+            for (let g = 0; g < h; g++) {
+                const _ = g * 4,
+                    m = Math.round(f[_ + 3]);
+                u[m] = _;
+            }
+        }
+        const d = [];
+        for (let f of a) {
+            const h = r(f, l, c);
+            d.push(h), processSplatTreeNode(h, h.rootNode, u, f);
+        }
+        s.postMessage({
+            subTrees: d
+        });
+    }
+    s.onmessage = (a) => {
+        a.data.process && o(a.data.process.centers, a.data.process.maxDepth, a.data.process.maxCentersPerNode);
+    };
+}
+
+function x_(s, e, t, n, i) {
+    s.postMessage({
+        process: {
+            centers: e,
+            maxDepth: n,
+            maxCentersPerNode: i
+        }
+    }, t);
+}
+
+function y_() {
+    return new Worker(
+        URL.createObjectURL(
+            new Blob(["(", v_.toString(), ")(self)"], {
+                type: "application/javascript"
+            })
+        )
+    );
+}
+class M_ {
+    constructor(e, t) {
+        /**
+         * Construct this instance of SplatTree from an instance of SplatMesh.
+         *
+         * @param {SplatMesh} splatMesh The instance of SplatMesh from which to construct this splat tree.
+         * @param {function} filterFunc Optional function to filter out unwanted splats.
+         * @param {function} onIndexesUpload Function to be called when the upload of splat centers to the splat tree
+         *                                   builder worker starts and finishes.
+         * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from
+         *                                           the format produced by the splat tree builder worker starts and ends.
+         * @return {undefined}
+         */
+        le(this, "processSplatMesh", function(e, t = () => !0, n, i) {
+            this.splatTreeWorker || (this.splatTreeWorker = y_()), this.splatMesh = e, this.subTrees = [];
+            const r = new D(),
+                o = (a, l) => {
+                    const c = new Float32Array(l * 4);
+                    let u = 0;
+                    for (let d = 0; d < l; d++) {
+                        const f = d + a;
+                        if (t(f)) {
+                            e.getSplatCenter(f, r);
+                            const h = u * 4;
+                            c[h] = r.x, c[h + 1] = r.y, c[h + 2] = r.z, c[h + 3] = f, u++;
+                        }
+                    }
+                    return c;
+                };
+            return new Promise((a) => {
+                const l = () => this.disposed ? (this.diposeSplatTreeWorker(), a(), !0) : !1;
+                n && n(!1), Ln(() => {
+                    if (l())
+                        return;
+                    const c = [];
+                    if (e.dynamicMode) {
+                        let u = 0;
+                        for (let d = 0; d < e.scenes.length; d++) {
+                            const h = e.getScene(d).splatBuffer.getSplatCount(),
+                                g = o(u, h);
+                            c.push(g), u += h;
+                        }
+                    } else {
+                        const u = o(0, e.getSplatCount());
+                        c.push(u);
+                    }
+                    this.splatTreeWorker.onmessage = (u) => {
+                        l() || u.data.subTrees && (i && i(!1), Ln(() => {
+                            if (!l()) {
+                                for (let d of u.data.subTrees) {
+                                    const f = ws.convertWorkerSubTree(d, e);
+                                    this.subTrees.push(f);
+                                }
+                                this.diposeSplatTreeWorker(), i && i(!0), Ln(() => {
+                                    a();
+                                });
+                            }
+                        }));
+                    }, Ln(() => {
+                        if (l())
+                            return;
+                        n && n(!0);
+                        const u = c.map((d) => d.buffer);
+                        x_(this.splatTreeWorker, c, u, this.maxDepth, this.maxCentersPerNode);
+                    });
+                });
+            });
+        });
+        this.maxDepth = e, this.maxCentersPerNode = t, this.subTrees = [], this.splatMesh = null;
+    }
+    dispose() {
+        this.diposeSplatTreeWorker(), this.disposed = !0;
+    }
+    diposeSplatTreeWorker() {
+        this.splatTreeWorker && this.splatTreeWorker.terminate(), this.splatTreeWorker = null;
     }
     countLeaves() {
         let e = 0;
         return this.visitLeaves(() => {
             e++;
         }), e;
     }
     visitLeaves(e) {
-        const t = (n, r) => {
-            n.children.length === 0 && r(n);
-            for (let s of n.children)
-                t(s, r);
+        const t = (n, i) => {
+            n.children.length === 0 && i(n);
+            for (let r of n.children)
+                t(r, i);
         };
         for (let n of this.subTrees)
             t(n.rootNode, e);
     }
 }
-class mt {}
-Pe(mt, "DepthMapRange", 65536), Pe(mt, "MemoryPageSize", 65536), Pe(mt, "BytesPerFloat", 4), Pe(mt, "BytesPerInt", 4), Pe(mt, "MaxScenes", 32);
-const ll = new Yt(),
-    A_ = new oi();
-class kt extends at {
-    constructor(t = !0, n = !1, r = 1, s = !0, a = !1) {
-        super(ll, A_);
-        Pe(this, "updateUniforms", function() {
-            const t = new me();
-            return function(n, r, s) {
+
+function E_(s) {
+    const e = {};
+
+    function t(n) {
+        if (e[n] !== void 0)
+            return e[n];
+        let i;
+        switch (n) {
+            case "WEBGL_depth_texture":
+                i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
+                break;
+            case "EXT_texture_filter_anisotropic":
+                i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
+                break;
+            case "WEBGL_compressed_texture_s3tc":
+                i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
+                break;
+            case "WEBGL_compressed_texture_pvrtc":
+                i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
+                break;
+            default:
+                i = s.getExtension(n);
+        }
+        return e[n] = i, i;
+    }
+    return {
+        has: function(n) {
+            return t(n) !== null;
+        },
+        init: function(n) {
+            n.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
+        },
+        get: function(n) {
+            const i = t(n);
+            return i === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), i;
+        }
+    };
+}
+
+function A_(s, e, t) {
+    let n;
+
+    function i() {
+        if (n !== void 0)
+            return n;
+        if (e.has("EXT_texture_filter_anisotropic") === !0) {
+            const T = e.get("EXT_texture_filter_anisotropic");
+            n = s.getParameter(T.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
+        } else
+            n = 0;
+        return n;
+    }
+
+    function r(T) {
+        if (T === "highp") {
+            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
+                return "highp";
+            T = "mediump";
+        }
+        return T === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
+    }
+    const o = typeof WebGL2RenderingContext < "u" && s.constructor.name === "WebGL2RenderingContext";
+    let a = t.precision !== void 0 ? t.precision : "highp";
+    const l = r(a);
+    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
+    const c = o || e.has("WEBGL_draw_buffers"),
+        u = t.logarithmicDepthBuffer === !0,
+        d = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
+        f = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
+        h = s.getParameter(s.MAX_TEXTURE_SIZE),
+        g = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
+        _ = s.getParameter(s.MAX_VERTEX_ATTRIBS),
+        m = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
+        p = s.getParameter(s.MAX_VARYING_VECTORS),
+        v = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
+        S = f > 0,
+        y = o || e.has("OES_texture_float"),
+        b = S && y,
+        E = o ? s.getParameter(s.MAX_SAMPLES) : 0;
+    return {
+        isWebGL2: o,
+        drawBuffers: c,
+        getMaxAnisotropy: i,
+        getMaxPrecision: r,
+        precision: a,
+        logarithmicDepthBuffer: u,
+        maxTextures: d,
+        maxVertexTextures: f,
+        maxTextureSize: h,
+        maxCubemapSize: g,
+        maxAttributes: _,
+        maxVertexUniforms: m,
+        maxVaryings: p,
+        maxFragmentUniforms: v,
+        vertexTextures: S,
+        floatFragmentTextures: y,
+        floatVertexTextures: b,
+        maxSamples: E
+    };
+}
+const _r = {
+        Default: 0,
+        Gradual: 1,
+        Instant: 2
+    },
+    rs = {
+        None: 0,
+        Error: 1,
+        Warning: 2,
+        Info: 3,
+        Debug: 4
+    },
+    $l = new sn(),
+    T_ = new yi(),
+    ur = 6,
+    b_ = 4,
+    Ra = 4,
+    Pa = 4,
+    ec = 1,
+    C_ = 0.012,
+    w_ = 3e-3,
+    tc = 1;
+class Bt extends pt {
+    constructor(t = !0, n = !1, i = 1, r = !0, o = !1, a = !1, l = 2048, c = rs.None, u = 0) {
+        super($l, T_);
+        /**
+         * Build an instance of SplatTree (a specialized octree) for the given splat mesh.
+         * @param {Array<number>} minAlphas Array of minimum splat slphas for each scene
+         * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree
+         *                                            builder worker starts and finishes.
+         * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from
+         *                                           the format produced by the splat tree builder worker starts and ends.
+         * @return {SplatTree}
+         */
+        le(this, "buildSplatTree", function(t = [], n, i) {
+            return new Promise((r) => {
+                this.disposeSplatTree(), this.baseSplatTree = new M_(8, 1e3);
+                const o = performance.now(),
+                    a = new _t();
+                this.baseSplatTree.processSplatMesh(this, (l) => {
+                    this.getSplatColor(l, a);
+                    const c = this.getSceneIndexForSplat(l),
+                        u = t[c] || 1;
+                    return a.w >= u;
+                }, n, i).then(() => {
+                    const l = performance.now() - o;
+                    if (this.logLevel >= rs.Info && console.log("SplatTree build: " + l + " ms"), this.disposed)
+                        r();
+                    else {
+                        this.splatTree = this.baseSplatTree, this.baseSplatTree = null;
+                        let c = 0,
+                            u = 0,
+                            d = 0;
+                        this.splatTree.visitLeaves((f) => {
+                            const h = f.data.indexes.length;
+                            h > 0 && (u += h, d++, c++);
+                        }), this.logLevel >= rs.Info && (console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`), console.log(`SplatTree leaves with splats:${c}`), u = u / d, console.log(`Avg splat count per node: ${u}`), console.log(`Total splat count: ${this.getSplatCount()}`)), r();
+                    }
+                });
+            });
+        });
+        le(this, "updateUniforms", function() {
+            const t = new Ee();
+            return function(n, i, r, o, a, l) {
                 if (this.getSplatCount() > 0) {
                     if (t.set(
                             n.x * this.devicePixelRatio,
                             n.y * this.devicePixelRatio
-                        ), this.material.uniforms.viewport.value.copy(t), this.material.uniforms.basisViewport.value.set(1 / t.x, 1 / t.y), this.material.uniforms.focal.value.set(r, s), this.dynamicMode)
-                        for (let o = 0; o < this.scenes.length; o++)
-                            this.material.uniforms.transforms.value[o].copy(this.getScene(o).transform);
+                        ), this.material.uniforms.viewport.value.copy(t), this.material.uniforms.basisViewport.value.set(1 / t.x, 1 / t.y), this.material.uniforms.focal.value.set(i, r), this.material.uniforms.orthographicMode.value = o ? 1 : 0, this.material.uniforms.orthoZoom.value = a, this.material.uniforms.inverseFocalAdjustment.value = l, this.dynamicMode)
+                        for (let u = 0; u < this.scenes.length; u++)
+                            this.material.uniforms.transforms.value[u].copy(this.getScene(u).transform);
                     this.material.uniformsNeedUpdate = !0;
                 }
             };
         }());
-        Pe(this, "setupDistancesComputationTransformFeedback", function() {
-            let t, n;
+        le(this, "setupDistancesComputationTransformFeedback", /* @__PURE__ */ function() {
+            let t;
             return function() {
-                const r = this.getSplatCount();
-                if (!this.renderer || t === this.renderer && n === r)
+                const n = this.getMaxSplatCount();
+                if (!this.renderer)
+                    return;
+                const i = this.lastRenderer !== this.renderer,
+                    r = t !== n;
+                if (!i && !r)
                     return;
-                const s = t !== this.renderer,
-                    a = n !== r;
-                s ? this.disposeDistancesComputationGPUResources() : a && this.disposeDistancesComputationGPUBufferResources();
+                i ? this.disposeDistancesComputationGPUResources() : r && this.disposeDistancesComputationGPUBufferResources();
                 const o = this.renderer.getContext(),
-                    l = (p, g, v) => {
-                        const m = p.createShader(g);
+                    a = (h, g, _) => {
+                        const m = h.createShader(g);
                         if (!m)
                             return console.error("Fatal error: gl could not create a shader object."), null;
-                        if (p.shaderSource(m, v), p.compileShader(m), !p.getShaderParameter(m, p.COMPILE_STATUS)) {
-                            let M = "unknown";
-                            g === p.VERTEX_SHADER ? M = "vertex shader" : g === p.FRAGMENT_SHADER && (M = "fragement shader");
-                            const _ = p.getShaderInfoLog(m);
-                            return console.error("Failed to compile " + M + " with these errors:" + _), p.deleteShader(m), null;
+                        if (h.shaderSource(m, _), h.compileShader(m), !h.getShaderParameter(m, h.COMPILE_STATUS)) {
+                            let v = "unknown";
+                            g === h.VERTEX_SHADER ? v = "vertex shader" : g === h.FRAGMENT_SHADER && (v = "fragement shader");
+                            const S = h.getShaderInfoLog(m);
+                            return console.error("Failed to compile " + v + " with these errors:" + S), h.deleteShader(m), null;
                         }
                         return m;
                     };
-                let c;
-                this.integerBasedDistancesComputation ? (c = `#version 300 es
+                let l;
+                this.integerBasedDistancesComputation ? (l = `#version 300 es
                 in ivec4 center;
-                flat out int distance;`, this.dynamicMode ? c += `
+                flat out int distance;`, this.dynamicMode ? l += `
                         in uint transformIndex;
-                        uniform ivec4 transforms[${mt.MaxScenes}];
+                        uniform ivec4 transforms[${rt.MaxScenes}];
                         void main(void) {
                             ivec4 transform = transforms[transformIndex];
                             distance = center.x * transform.x + center.y * transform.y + center.z * transform.z + transform.w * center.w;
                         }
-                    ` : c += `
+                    ` : l += `
                         uniform ivec3 modelViewProj;
                         void main(void) {
                             distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                         }
-                    `) : (c = `#version 300 es
-                in vec3 center;
-                flat out float distance;`, this.dynamicMode ? c += `
+                    `) : (l = `#version 300 es
+                in vec4 center;
+                flat out float distance;`, this.dynamicMode ? l += `
                         in uint transformIndex;
-                        uniform mat4 transforms[${mt.MaxScenes}];
+                        uniform mat4 transforms[${rt.MaxScenes}];
                         void main(void) {
-                            vec4 transformedCenter = transforms[transformIndex] * vec4(center, 1.0);
+                            vec4 transformedCenter = transforms[transformIndex] * vec4(center.xyz, 1.0);
                             distance = transformedCenter.z;
                         }
-                    ` : c += `
+                    ` : l += `
                         uniform vec3 modelViewProj;
                         void main(void) {
                             distance = center.x * modelViewProj.x + center.y * modelViewProj.y + center.z * modelViewProj.z;
                         }
                     `);
-                const u = `#version 300 es
+                const c = `#version 300 es
                 precision lowp float;
                 out vec4 fragColor;
                 void main(){}
             `,
-                    f = o.getParameter(o.VERTEX_ARRAY_BINDING),
-                    h = o.getParameter(o.CURRENT_PROGRAM);
-                if (s && (this.distancesTransformFeedback.vao = o.createVertexArray()), o.bindVertexArray(this.distancesTransformFeedback.vao), s) {
-                    const p = o.createProgram(),
-                        g = l(o, o.VERTEX_SHADER, c),
-                        v = l(o, o.FRAGMENT_SHADER, u);
-                    if (!g || !v)
+                    u = o.getParameter(o.VERTEX_ARRAY_BINDING),
+                    d = o.getParameter(o.CURRENT_PROGRAM),
+                    f = d ? o.getProgramParameter(d, o.DELETE_STATUS) : !1;
+                if (i && (this.distancesTransformFeedback.vao = o.createVertexArray()), o.bindVertexArray(this.distancesTransformFeedback.vao), i) {
+                    const h = o.createProgram(),
+                        g = a(o, o.VERTEX_SHADER, l),
+                        _ = a(o, o.FRAGMENT_SHADER, c);
+                    if (!g || !_)
                         throw new Error("Could not compile shaders for distances computation on GPU.");
-                    if (o.attachShader(p, g), o.attachShader(p, v), o.transformFeedbackVaryings(p, ["distance"], o.SEPARATE_ATTRIBS), o.linkProgram(p), !o.getProgramParameter(p, o.LINK_STATUS)) {
-                        const d = o.getProgramInfoLog(p);
-                        throw console.error("Fatal error: Failed to link program: " + d), o.deleteProgram(p), o.deleteShader(v), o.deleteShader(g), new Error("Could not link shaders for distances computation on GPU.");
+                    if (o.attachShader(h, g), o.attachShader(h, _), o.transformFeedbackVaryings(h, ["distance"], o.SEPARATE_ATTRIBS), o.linkProgram(h), !o.getProgramParameter(h, o.LINK_STATUS)) {
+                        const p = o.getProgramInfoLog(h);
+                        throw console.error("Fatal error: Failed to link program: " + p), o.deleteProgram(h), o.deleteShader(_), o.deleteShader(g), new Error("Could not link shaders for distances computation on GPU.");
                     }
-                    this.distancesTransformFeedback.program = p, this.distancesTransformFeedback.vertexShader = g, this.distancesTransformFeedback.vertexShader = v;
+                    this.distancesTransformFeedback.program = h, this.distancesTransformFeedback.vertexShader = g, this.distancesTransformFeedback.vertexShader = _;
                 }
                 if (o.useProgram(this.distancesTransformFeedback.program), this.distancesTransformFeedback.centersLoc = o.getAttribLocation(this.distancesTransformFeedback.program, "center"), this.dynamicMode) {
                     this.distancesTransformFeedback.transformIndexesLoc = o.getAttribLocation(this.distancesTransformFeedback.program, "transformIndex");
-                    for (let p = 0; p < this.scenes.length; p++)
-                        this.distancesTransformFeedback.transformsLocs[p] = o.getUniformLocation(this.distancesTransformFeedback.program, `transforms[${p}]`);
+                    for (let h = 0; h < this.scenes.length; h++)
+                        this.distancesTransformFeedback.transformsLocs[h] = o.getUniformLocation(this.distancesTransformFeedback.program, `transforms[${h}]`);
                 } else
                     this.distancesTransformFeedback.modelViewProjLoc = o.getUniformLocation(this.distancesTransformFeedback.program, "modelViewProj");
-                (s || a) && (this.distancesTransformFeedback.centersBuffer = o.createBuffer(), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc), this.integerBasedDistancesComputation ? o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, o.INT, 0, 0) : o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 3, o.FLOAT, !1, 0, 0), this.dynamicMode && (this.distancesTransformFeedback.transformIndexesBuffer = o.createBuffer(), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), o.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc), o.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc, 1, o.UNSIGNED_INT, 0, 0))), (s || a) && (this.distancesTransformFeedback.outDistancesBuffer = o.createBuffer()), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer), o.bufferData(o.ARRAY_BUFFER, r * 4, o.STATIC_READ), s && (this.distancesTransformFeedback.id = o.createTransformFeedback()), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id), o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer), h && o.useProgram(h), f && o.bindVertexArray(f), t = this.renderer, n = r;
+                (i || r) && (this.distancesTransformFeedback.centersBuffer = o.createBuffer(), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc), this.integerBasedDistancesComputation ? o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, o.INT, 0, 0) : o.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 4, o.FLOAT, !1, 0, 0), this.dynamicMode && (this.distancesTransformFeedback.transformIndexesBuffer = o.createBuffer(), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), o.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc), o.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc, 1, o.UNSIGNED_INT, 0, 0))), (i || r) && (this.distancesTransformFeedback.outDistancesBuffer = o.createBuffer()), o.bindBuffer(o.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer), o.bufferData(o.ARRAY_BUFFER, n * 4, o.STATIC_READ), i && (this.distancesTransformFeedback.id = o.createTransformFeedback()), o.bindTransformFeedback(o.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id), o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer), d && f !== !0 && o.useProgram(d), u && o.bindVertexArray(u), this.lastRenderer = this.renderer, t = n;
             };
         }());
         /**
          * Fill 'array' with the transforms for each scene in this splat mesh.
          * @param {Array} array Empty array to be filled with scene transforms. If not empty, contents will be overwritten.
          */
-        Pe(this, "fillTransformsArray", function() {
+        le(this, "fillTransformsArray", /* @__PURE__ */ function() {
             const t = [];
             return function(n) {
                 t.length !== n.length && (t.length = n.length);
-                for (let r = 0; r < this.scenes.length; r++) {
-                    const a = this.getScene(r).transform.elements;
-                    for (let o = 0; o < 16; o++)
-                        t[r * 16 + o] = a[o];
+                for (let i = 0; i < this.scenes.length; i++) {
+                    const o = this.getScene(i).transform.elements;
+                    for (let a = 0; a < 16; a++)
+                        t[i * 16 + a] = o[a];
                 }
                 n.set(t);
             };
         }());
-        Pe(this, "computeDistancesOnGPU", function() {
-            const t = new ke();
-            return function(n, r) {
+        le(this, "computeDistancesOnGPU", function() {
+            const t = new Ge();
+            return function(n, i) {
                 if (!this.renderer)
                     return;
-                const s = this.renderer.getContext(),
-                    a = s.getParameter(s.VERTEX_ARRAY_BINDING),
-                    o = s.getParameter(s.CURRENT_PROGRAM);
-                if (s.bindVertexArray(this.distancesTransformFeedback.vao), s.useProgram(this.distancesTransformFeedback.program), s.enable(s.RASTERIZER_DISCARD), this.dynamicMode)
-                    for (let u = 0; u < this.scenes.length; u++)
-                        if (t.copy(this.getScene(u).transform), t.premultiply(n), this.integerBasedDistancesComputation) {
-                            const f = kt.getIntegerMatrixArray(t),
+                const r = this.renderer.getContext(),
+                    o = r.getParameter(r.VERTEX_ARRAY_BINDING),
+                    a = r.getParameter(r.CURRENT_PROGRAM),
+                    l = a ? r.getProgramParameter(a, r.DELETE_STATUS) : !1;
+                if (r.bindVertexArray(this.distancesTransformFeedback.vao), r.useProgram(this.distancesTransformFeedback.program), r.enable(r.RASTERIZER_DISCARD), this.dynamicMode)
+                    for (let d = 0; d < this.scenes.length; d++)
+                        if (t.copy(this.getScene(d).transform), t.premultiply(n), this.integerBasedDistancesComputation) {
+                            const f = Bt.getIntegerMatrixArray(t),
                                 h = [f[2], f[6], f[10], f[14]];
-                            s.uniform4i(
-                                this.distancesTransformFeedback.transformsLocs[u],
+                            r.uniform4i(
+                                this.distancesTransformFeedback.transformsLocs[d],
                                 h[0],
                                 h[1],
                                 h[2],
                                 h[3]
                             );
                         } else
-                            s.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[u], !1, t.elements);
+                            r.uniformMatrix4fv(this.distancesTransformFeedback.transformsLocs[d], !1, t.elements);
                 else if (this.integerBasedDistancesComputation) {
-                    const u = kt.getIntegerMatrixArray(n),
-                        f = [u[2], u[6], u[10]];
-                    s.uniform3i(this.distancesTransformFeedback.modelViewProjLoc, f[0], f[1], f[2]);
+                    const d = Bt.getIntegerMatrixArray(n),
+                        f = [d[2], d[6], d[10]];
+                    r.uniform3i(this.distancesTransformFeedback.modelViewProjLoc, f[0], f[1], f[2]);
                 } else {
-                    const u = [n.elements[2], n.elements[6], n.elements[10]];
-                    s.uniform3f(this.distancesTransformFeedback.modelViewProjLoc, u[0], u[1], u[2]);
+                    const d = [n.elements[2], n.elements[6], n.elements[10]];
+                    r.uniform3f(this.distancesTransformFeedback.modelViewProjLoc, d[0], d[1], d[2]);
                 }
-                s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), s.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc), this.integerBasedDistancesComputation ? s.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, s.INT, 0, 0) : s.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 3, s.FLOAT, !1, 0, 0), this.dynamicMode && (s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), s.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc), s.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc, 1, s.UNSIGNED_INT, 0, 0)), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id), s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer), s.beginTransformFeedback(s.POINTS), s.drawArrays(s.POINTS, 0, this.getSplatCount()), s.endTransformFeedback(), s.bindBufferBase(s.TRANSFORM_FEEDBACK_BUFFER, 0, null), s.bindTransformFeedback(s.TRANSFORM_FEEDBACK, null), s.disable(s.RASTERIZER_DISCARD);
-                const l = s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE, 0);
-                s.flush();
-                const c = new Promise((u) => {
+                r.bindBuffer(r.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), r.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc), this.integerBasedDistancesComputation ? r.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc, 4, r.INT, 0, 0) : r.vertexAttribPointer(this.distancesTransformFeedback.centersLoc, 4, r.FLOAT, !1, 0, 0), this.dynamicMode && (r.bindBuffer(r.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), r.enableVertexAttribArray(this.distancesTransformFeedback.transformIndexesLoc), r.vertexAttribIPointer(this.distancesTransformFeedback.transformIndexesLoc, 1, r.UNSIGNED_INT, 0, 0)), r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, this.distancesTransformFeedback.id), r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, 0, this.distancesTransformFeedback.outDistancesBuffer), r.beginTransformFeedback(r.POINTS), r.drawArrays(r.POINTS, 0, this.getSplatCount()), r.endTransformFeedback(), r.bindBufferBase(r.TRANSFORM_FEEDBACK_BUFFER, 0, null), r.bindTransformFeedback(r.TRANSFORM_FEEDBACK, null), r.disable(r.RASTERIZER_DISCARD);
+                const c = r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE, 0);
+                r.flush();
+                const u = new Promise((d) => {
                     const f = () => {
-                        switch (s.clientWaitSync(l, 0, 0)) {
-                            case s.TIMEOUT_EXPIRED:
-                                return setTimeout(f);
-                            case s.WAIT_FAILED:
-                                throw new Error("should never get here");
-                            default:
-                                s.deleteSync(l);
-                                const v = s.getParameter(s.VERTEX_ARRAY_BINDING);
-                                s.bindVertexArray(this.distancesTransformFeedback.vao), s.bindBuffer(s.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer), s.getBufferSubData(s.ARRAY_BUFFER, 0, r), s.bindBuffer(s.ARRAY_BUFFER, null), v && s.bindVertexArray(v), u();
-                        }
+                        if (this.disposed)
+                            d();
+                        else
+                            switch (r.clientWaitSync(c, 0, 0)) {
+                                case r.TIMEOUT_EXPIRED:
+                                    return this.computeDistancesOnGPUSyncTimeout = setTimeout(f), this.computeDistancesOnGPUSyncTimeout;
+                                case r.WAIT_FAILED:
+                                    throw new Error("should never get here");
+                                default:
+                                    this.computeDistancesOnGPUSyncTimeout = null, r.deleteSync(c);
+                                    const m = r.getParameter(r.VERTEX_ARRAY_BINDING);
+                                    r.bindVertexArray(this.distancesTransformFeedback.vao), r.bindBuffer(r.ARRAY_BUFFER, this.distancesTransformFeedback.outDistancesBuffer), r.getBufferSubData(r.ARRAY_BUFFER, 0, i), r.bindBuffer(r.ARRAY_BUFFER, null), m && r.bindVertexArray(m), d();
+                            }
                     };
-                    setTimeout(f);
+                    this.computeDistancesOnGPUSyncTimeout = setTimeout(f);
                 });
-                return o && s.useProgram(o), a && s.bindVertexArray(a), c;
+                return a && l !== !0 && r.useProgram(a), o && r.bindVertexArray(o), u;
             };
         }());
         /**
          * Get the center for a splat, transformed as appropriate.
          * @param {number} globalIndex Global index of splat
          * @param {THREE.Vector3} outCenter THREE.Vector3 instance in which to store splat center
          * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at
          *                                      'globalIndex' belongs will be applied to the splat center. If 'applySceneTransform' is true,
          *                                      the scene transform will always be applied and if 'applySceneTransform' is false, the
          *                                      scene transform will never be applied. If undefined, the default behavior will apply.
          */
-        Pe(this, "getSplatCenter", function() {
+        le(this, "getSplatCenter", /* @__PURE__ */ function() {
             const t = {};
-            return function(n, r, s) {
-                this.getLocalSplatParameters(n, t, s), t.splatBuffer.getSplatCenter(t.localIndex, r, t.sceneTransform);
+            return function(n, i, r) {
+                this.getLocalSplatParameters(n, t, r), t.splatBuffer.getSplatCenter(t.localIndex, i, t.sceneTransform);
             };
         }());
         /**
          * Get the scale and rotation for a splat, transformed as appropriate.
          * @param {number} globalIndex Global index of splat
          * @param {THREE.Vector3} outScale THREE.Vector3 instance in which to store splat scale
          * @param {THREE.Quaternion} outRotation THREE.Quaternion instance in which to store splat rotation
          * @param {boolean} applySceneTransform By default, if the splat mesh is static, the transform of the scene to which the splat at
          *                                      'globalIndex' belongs will be applied to the splat scale and rotation. If
          *                                      'applySceneTransform' is true, the scene transform will always be applied and if
          *                                      'applySceneTransform' is false, the scene transform will never be applied. If undefined,
          *                                      the default behavior will apply.
          */
-        Pe(this, "getSplatScaleAndRotation", function() {
+        le(this, "getSplatScaleAndRotation", /* @__PURE__ */ function() {
             const t = {};
-            return function(n, r, s, a) {
-                this.getLocalSplatParameters(n, t, a), t.splatBuffer.getSplatScaleAndRotation(t.localIndex, r, s, t.sceneTransform);
+            return function(n, i, r, o) {
+                this.getLocalSplatParameters(n, t, o), t.splatBuffer.getSplatScaleAndRotation(t.localIndex, i, r, t.sceneTransform);
             };
         }());
         /**
          * Get the color for a splat.
          * @param {number} globalIndex Global index of splat
          * @param {THREE.Vector4} outColor THREE.Vector4 instance in which to store splat color
          */
-        Pe(this, "getSplatColor", function() {
+        le(this, "getSplatColor", /* @__PURE__ */ function() {
             const t = {};
-            return function(n, r) {
-                this.getLocalSplatParameters(n, t), t.splatBuffer.getSplatColor(t.localIndex, r, t.sceneTransform);
+            return function(n, i) {
+                this.getLocalSplatParameters(n, t), t.splatBuffer.getSplatColor(t.localIndex, i);
             };
         }());
-        this.renderer = void 0, this.halfPrecisionCovariancesOnGPU = n, this.dynamicMode = t, this.devicePixelRatio = r, this.enableDistancesComputationOnGPU = s, this.integerBasedDistancesComputation = a, this.scenes = [], this.splatTree = null, this.splatDataTextures = null, this.distancesTransformFeedback = {
+        this.renderer = void 0, this.halfPrecisionCovariancesOnGPU = n, this.dynamicMode = t, this.devicePixelRatio = i, this.enableDistancesComputationOnGPU = r, this.integerBasedDistancesComputation = o, this.antialiased = a, this.maxScreenSpaceSplatSize = l, this.logLevel = c, this.sphericalHarmonicsDegree = u, this.minSphericalHarmonicsDegree = 0, this.scenes = [], this.splatTree = null, this.baseSplatTree = null, this.splatDataTextures = {}, this.distancesTransformFeedback = {
             id: null,
             vertexShader: null,
             fragmentShader: null,
             program: null,
             centersBuffer: null,
             transformIndexesBuffer: null,
             outDistancesBuffer: null,
             centersLoc: -1,
             modelViewProjLoc: -1,
             transformIndexesLoc: -1,
             transformsLocs: []
-        }, this.globalSplatIndexToLocalSplatIndexMap = [], this.globalSplatIndexToSceneIndexMap = [];
+        }, this.globalSplatIndexToLocalSplatIndexMap = [], this.globalSplatIndexToSceneIndexMap = [], this.lastBuildSplatCount = 0, this.lastBuildScenes = [], this.lastBuildMaxSplatCount = 0, this.lastBuildSceneCount = 0, this.firstRenderTime = -1, this.finalBuild = !1, this.webGLUtils = null, this.boundingBox = new Un(), this.calculatedSceneCenter = new D(), this.maxSplatDistanceFromSceneCenter = 0, this.visibleRegionBufferRadius = 0, this.visibleRegionRadius = 0, this.visibleRegionFadeStartRadius = 0, this.visibleRegionChanging = !1, this.splatScale = 1, this.pointCloudModeEnabled = !1, this.disposed = !1, this.lastRenderer = null, this.visible = !1;
     }
     /**
      * Build the Three.js material that is used to render the splats.
      * @param {number} dynamicMode If true, it means the scene geometry represented by this splat mesh is not stationary or
      *                             that the splat count might change
+     * @param {boolean} antialiased If true, calculate compensation factor to deal with gaussians being rendered at a significantly
+     *                              different resolution than that of their training
+     * @param {number} maxScreenSpaceSplatSize The maximum clip space splat size
+     * @param {number} splatScale Value by which all splats are scaled in screen-space (default is 1.0)
+     * @param {number} pointCloudModeEnabled Render all splats as screen-space circles
+     * @param {number} maxSphericalHarmonicsDegree Degree of spherical harmonics to utilize in rendering splats
      * @return {THREE.ShaderMaterial}
      */
-    static buildMaterial(t = !1) {
-        let n = `
+    static buildMaterial(t = !1, n = !1, i = 2048, r = 1, o = !1, a = 0) {
+        let l = `
             precision highp float;
             #include <common>
 
             attribute uint splatIndex;
 
             uniform highp sampler2D covariancesTexture;
-            uniform highp usampler2D centersColorsTexture;`;
-        t && (n += `
+            uniform highp usampler2D centersColorsTexture;
+            uniform highp sampler2D sphericalHarmonicsTexture;`;
+        t && (l += `
                 uniform highp usampler2D transformIndexesTexture;
-                uniform highp mat4 transforms[${mt.MaxScenes}];
+                uniform highp mat4 transforms[${rt.MaxScenes}];
                 uniform vec2 transformIndexesTextureSize;
-            `), n += `
+            `), l += `
             uniform vec2 focal;
+            uniform float orthoZoom;
+            uniform int orthographicMode;
+            uniform int pointCloudModeEnabled;
+            uniform float inverseFocalAdjustment;
             uniform vec2 viewport;
             uniform vec2 basisViewport;
             uniform vec2 covariancesTextureSize;
             uniform vec2 centersColorsTextureSize;
+            uniform int sphericalHarmonicsDegree;
+            uniform vec2 sphericalHarmonicsTextureSize;
+            uniform int sphericalHarmonics8BitMode;
+            uniform float visibleRegionRadius;
+            uniform float visibleRegionFadeStartRadius;
+            uniform float firstRenderTime;
+            uniform float currentTime;
+            uniform int fadeInComplete;
+            uniform vec3 sceneCenter;
+            uniform float splatScale;
 
             varying vec4 vColor;
             varying vec2 vUv;
 
             varying vec2 vPosition;
 
             const float sqrt8 = sqrt(8.0);
+            const float minAlpha = 1.0 / 255.0;
 
             const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);
             const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));
             const uvec4 shift4 = uvec4(0, 8, 16, 24);
             vec4 uintToRGBAVec (uint u) {
                uvec4 urgba = mask4 & u;
                urgba = urgba >> shift4;
@@ -19631,69 +21636,186 @@
                 vec2 samplerUV = vec2(0.0, 0.0);
                 float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;
                 samplerUV.y = float(floor(d)) / dimensions.y;
                 samplerUV.x = fract(d);
                 return samplerUV;
             }
 
+            vec2 getDataUVF(in uint sIndex, in float stride, in uint offset, in vec2 dimensions) {
+                vec2 samplerUV = vec2(0.0, 0.0);
+                float d = float(uint(float(sIndex) * stride) + offset) / dimensions.x;
+                samplerUV.y = float(floor(d)) / dimensions.y;
+                samplerUV.x = fract(d);
+                return samplerUV;
+            }
+
+            const float SH_C1 = 0.4886025119029199f;
+            const float[5] SH_C2 = float[](1.0925484, -1.0925484, 0.3153916, -1.0925484, 0.5462742);
+
+            const float SphericalHarmonics8BitCompressionRange = ${rt.SphericalHarmonics8BitCompressionRange.toFixed(1)};
+            const float SphericalHarmonics8BitCompressionHalfRange = SphericalHarmonics8BitCompressionRange / 2.0;
+            const vec3 vec8BitSHShift = vec3(SphericalHarmonics8BitCompressionHalfRange);
+
             void main () {
 
+                uint oddOffset = splatIndex & uint(0x00000001);
+                uint doubleOddOffset = oddOffset * uint(2);
+                bool isEven = oddOffset == uint(0);
+                uint nearestEvenIndex = splatIndex - oddOffset;
+                float fOddOffset = float(oddOffset);
+
                 uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));
-                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));`, t ? n += `
+                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));`, t ? l += `
                     uint transformIndex = texture(transformIndexesTexture, getDataUV(1, 0, transformIndexesTextureSize)).r;
                     mat4 transform = transforms[transformIndex];
                     mat4 transformModelViewMatrix = modelViewMatrix * transform;
-                ` : n += "mat4 transformModelViewMatrix = modelViewMatrix;", n += `
+                ` : l += "mat4 transformModelViewMatrix = modelViewMatrix;", l += `
                 vec4 viewCenter = transformModelViewMatrix * vec4(splatCenter, 1.0);
 
                 vec4 clipCenter = projectionMatrix * viewCenter;
 
                 float clip = 1.2 * clipCenter.w;
                 if (clipCenter.z < -clip || clipCenter.x < -clip || clipCenter.x > clip || clipCenter.y < -clip || clipCenter.y > clip) {
                     gl_Position = vec4(0.0, 0.0, 2.0, 1.0);
                     return;
                 }
 
                 vPosition = position.xy;
                 vColor = uintToRGBAVec(sampledCenterColor.r);
+            `, a >= 1 && (l += `   
+                if (sphericalHarmonicsDegree >= 1) {
+                `, t ? l += `
+                        mat4 mTransform = modelMatrix * transform;
+                        vec3 worldViewDir = normalize(splatCenter - vec3(inverse(mTransform) * vec4(cameraPosition, 1.0)));
+                    ` : l += `
+                        vec3 worldViewDir = normalize(splatCenter - cameraPosition);
+                    `, a >= 2 ? l += `
+                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, getDataUV(6, 0, sphericalHarmonicsTextureSize));
+                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, getDataUV(6, 1, sphericalHarmonicsTextureSize));
+                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, getDataUV(6, 2, sphericalHarmonicsTextureSize));
+                        vec3 sh1 = sampledSH0123.rgb;
+                        vec3 sh2 = vec3(sampledSH0123.a, sampledSH4567.rg);
+                        vec3 sh3 = vec3(sampledSH4567.ba, sampledSH891011.r);
+                    ` : l += `
+                        vec2 shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset, sphericalHarmonicsTextureSize);
+                        vec4 sampledSH0123 = texture(sphericalHarmonicsTexture, shUV);
+                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(1), sphericalHarmonicsTextureSize);
+                        vec4 sampledSH4567 = texture(sphericalHarmonicsTexture, shUV);
+                        shUV = getDataUVF(nearestEvenIndex, 2.5, doubleOddOffset + uint(2), sphericalHarmonicsTextureSize);
+                        vec4 sampledSH891011 = texture(sphericalHarmonicsTexture, shUV);
+
+                        vec3 sh1 = vec3(sampledSH0123.rgb) * (1.0 - fOddOffset) + vec3(sampledSH0123.ba, sampledSH4567.r) * fOddOffset;
+                        vec3 sh2 = vec3(sampledSH0123.a, sampledSH4567.rg) * (1.0 - fOddOffset) + vec3(sampledSH4567.gba) * fOddOffset;
+                        vec3 sh3 = vec3(sampledSH4567.ba, sampledSH891011.r) * (1.0 - fOddOffset) + vec3(sampledSH891011.rgb) * fOddOffset;
+                    `, l += `
+                        if (sphericalHarmonics8BitMode == 1) {
+                            sh1 = sh1 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                            sh2 = sh2 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                            sh3 = sh3 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                        }
+                        float x = worldViewDir.x;
+                        float y = worldViewDir.y;
+                        float z = worldViewDir.z;
+                        vColor.rgb += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);
+                `, a >= 2 && (l += `
+                        if (sphericalHarmonicsDegree >= 2) {
+                            float xx = x * x;
+                            float yy = y * y;
+                            float zz = z * z;
+                            float xy = x * y;
+                            float yz = y * z;
+                            float xz = x * z;
+
+                            vec4 sampledSH12131415 = texture(sphericalHarmonicsTexture, getDataUV(6, 3, sphericalHarmonicsTextureSize));
+                            vec4 sampledSH16171819 = texture(sphericalHarmonicsTexture, getDataUV(6, 4, sphericalHarmonicsTextureSize));
+                            vec4 sampledSH20212223 = texture(sphericalHarmonicsTexture, getDataUV(6, 5, sphericalHarmonicsTextureSize));
+
+                            vec3 sh4 = sampledSH891011.gba;
+                            vec3 sh5 = sampledSH12131415.rgb;
+                            vec3 sh6 = vec3(sampledSH12131415.a, sampledSH16171819.rg);
+                            vec3 sh7 = vec3(sampledSH16171819.ba, sampledSH20212223.r);
+                            vec3 sh8 = sampledSH20212223.gba;
+
+                            if (sphericalHarmonics8BitMode == 1) {
+                                sh4 = sh4 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                                sh5 = sh5 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                                sh6 = sh6 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                                sh7 = sh7 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                                sh8 = sh8 * SphericalHarmonics8BitCompressionRange - vec8BitSHShift;
+                            }
 
-                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;
-                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;
-                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;
+                            vColor.rgb +=
+                                (SH_C2[0] * xy) * sh4 +
+                                (SH_C2[1] * yz) * sh5 +
+                                (SH_C2[2] * (2.0 * zz - xx - yy)) * sh6 +
+                                (SH_C2[3] * xz) * sh7 +
+                                (SH_C2[4] * (xx - yy)) * sh8;
+                        }
+                    `), l += `
+               
+                }
+
+                `), l += `
 
-                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);
-                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);
+                vec4 sampledCovarianceA = texture(covariancesTexture,
+                                                  getDataUVF(nearestEvenIndex, 1.5, oddOffset, covariancesTextureSize));
+                vec4 sampledCovarianceB = texture(covariancesTexture,
+                                                  getDataUVF(nearestEvenIndex, 1.5, oddOffset + uint(1), covariancesTextureSize));
+
+                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rgb) * (1.0 - fOddOffset) +
+                                         vec3(sampledCovarianceA.ba, sampledCovarianceB.r) * fOddOffset;
+                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceA.a, sampledCovarianceB.rg) * (1.0 - fOddOffset) +
+                                         vec3(sampledCovarianceB.gba) * fOddOffset;
 
                 // Construct the 3D covariance matrix
                 mat3 Vrk = mat3(
                     cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,
                     cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,
                     cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z
                 );
 
-                // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
-                // 3D covariance matrix instead of using the actual projection matrix because that transformation would
-                // require a non-linear component (perspective division) which would yield a non-gaussian result. (This assumes
-                // the current projection is a perspective projection).
-                float s = 1.0 / (viewCenter.z * viewCenter.z);
-                mat3 J = mat3(
-                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
-                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
-                    0., 0., 0.
-                );
+                mat3 J;
+                if (orthographicMode == 1) {
+                    // Since the projection is linear, we don't need an approximation
+                    J = transpose(mat3(orthoZoom, 0.0, 0.0,
+                                       0.0, orthoZoom, 0.0,
+                                       0.0, 0.0, 0.0));
+                } else {
+                    // Construct the Jacobian of the affine approximation of the projection matrix. It will be used to transform the
+                    // 3D covariance matrix instead of using the actual projection matrix because that transformation would
+                    // require a non-linear component (perspective division) which would yield a non-gaussian result.
+                    float s = 1.0 / (viewCenter.z * viewCenter.z);
+                    J = mat3(
+                        focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,
+                        0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,
+                        0., 0., 0.
+                    );
+                }
 
                 // Concatenate the projection approximation with the model-view transformation
                 mat3 W = transpose(mat3(transformModelViewMatrix));
                 mat3 T = W * J;
 
                 // Transform the 3D covariance matrix (Vrk) to compute the 2D covariance matrix
                 mat3 cov2Dm = transpose(T) * Vrk * T;
+                `, n ? l += `
+                    float detOrig = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
+                    cov2Dm[0][0] += 0.3;
+                    cov2Dm[1][1] += 0.3;
+                    float detBlur = cov2Dm[0][0] * cov2Dm[1][1] - cov2Dm[0][1] * cov2Dm[0][1];
+                    float compensation = sqrt(max(detOrig / detBlur, 0.0));
+                ` : l += `
+                    cov2Dm[0][0] += 0.3;
+                    cov2Dm[1][1] += 0.3;
+                    float compensation = 1.0;
+                `, l += `
+
+                vColor.a *= compensation;
 
-                cov2Dm[0][0] += 0.3;
-                cov2Dm[1][1] += 0.3;
+                if (vColor.a < minAlpha) return;
 
                 // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because
                 // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],
                 // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't
                 // need cov2Dm[1][0] because it is a symetric matrix.
                 vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);
 
@@ -19718,34 +21840,52 @@
                 float D = a * d - b * b;
                 float trace = a + d;
                 float traceOver2 = 0.5 * trace;
                 float term2 = sqrt(max(0.1f, traceOver2 * traceOver2 - D));
                 float eigenValue1 = traceOver2 + term2;
                 float eigenValue2 = traceOver2 - term2;
 
-                float transparentAdjust = step(1.0 / 255.0, vColor.a);
-                eigenValue2 = eigenValue2 * transparentAdjust; // hide splat if alpha is zero
+                if (pointCloudModeEnabled == 1) {
+                    eigenValue1 = eigenValue2 = 0.2;
+                }
+
+                if (eigenValue2 <= 0.0) return;
 
                 vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));
                 // since the eigen vectors are orthogonal, we derive the second one from the first
                 vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);
 
                 // We use sqrt(8) standard deviations instead of 3 to eliminate more of the splat with a very low opacity.
-                vec2 basisVector1 = eigenVector1 * sqrt8 * sqrt(eigenValue1);
-                vec2 basisVector2 = eigenVector2 * sqrt8 * sqrt(eigenValue2);
+                vec2 basisVector1 = eigenVector1 * splatScale * min(sqrt8 * sqrt(eigenValue1), ${parseInt(i)}.0);
+                vec2 basisVector2 = eigenVector2 * splatScale * min(sqrt8 * sqrt(eigenValue2), ${parseInt(i)}.0);
 
-                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport * 2.0;
+                if (fadeInComplete == 0) {
+                    float opacityAdjust = 1.0;
+                    float centerDist = length(splatCenter - sceneCenter);
+                    float renderTime = max(currentTime - firstRenderTime, 0.0);
+
+                    float fadeDistance = 0.75;
+                    float distanceLoadFadeInFactor = step(visibleRegionFadeStartRadius, centerDist);
+                    distanceLoadFadeInFactor = (1.0 - distanceLoadFadeInFactor) +
+                                               (1.0 - clamp((centerDist - visibleRegionFadeStartRadius) / fadeDistance, 0.0, 1.0)) *
+                                               distanceLoadFadeInFactor;
+                    opacityAdjust *= distanceLoadFadeInFactor;
+                    vColor.a *= opacityAdjust;
+                }
 
-                // Similarly scale the position data we send to the fragment shader
-                vPosition *= sqrt8;
+                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) *
+                                 basisViewport * 2.0 * inverseFocalAdjustment;
 
-                gl_Position = vec4(ndcCenter.xy  + ndcOffset, ndcCenter.z, 1.0);
+                vec4 quadPos = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);
+                gl_Position = quadPos;
 
+                // Scale the position data we send to the fragment shader
+                vPosition *= sqrt8;
             }`;
-        const r = `
+        const c = `
             precision highp float;
             #include <common>
  
             uniform vec3 debugColor;
 
             varying vec4 vColor;
             varying vec2 vUv;
@@ -19765,92 +21905,152 @@
                 // Since the rendered splat is scaled by sqrt(8), the inverse covariance matrix that is part of
                 // the gaussian formula becomes the identity matrix. We're then left with (X - mean) * (X - mean),
                 // and since 'mean' is zero, we have X * X, which is the same as A:
                 float opacity = exp(-0.5 * A) * vColor.a;
 
                 gl_FragColor = vec4(color.rgb, opacity);
             }`,
-            s = {
+            u = {
+                sceneCenter: {
+                    type: "v3",
+                    value: new D()
+                },
+                fadeInComplete: {
+                    type: "i",
+                    value: 0
+                },
+                orthographicMode: {
+                    type: "i",
+                    value: 0
+                },
+                visibleRegionFadeStartRadius: {
+                    type: "f",
+                    value: 0
+                },
+                visibleRegionRadius: {
+                    type: "f",
+                    value: 0
+                },
+                currentTime: {
+                    type: "f",
+                    value: 0
+                },
+                firstRenderTime: {
+                    type: "f",
+                    value: 0
+                },
                 covariancesTexture: {
                     type: "t",
                     value: null
                 },
                 centersColorsTexture: {
                     type: "t",
                     value: null
                 },
+                sphericalHarmonicsTexture: {
+                    type: "t",
+                    value: null
+                },
                 focal: {
                     type: "v2",
-                    value: new me()
+                    value: new Ee()
+                },
+                orthoZoom: {
+                    type: "f",
+                    value: 1
+                },
+                inverseFocalAdjustment: {
+                    type: "f",
+                    value: 1
                 },
                 viewport: {
                     type: "v2",
-                    value: new me()
+                    value: new Ee()
                 },
                 basisViewport: {
                     type: "v2",
-                    value: new me()
+                    value: new Ee()
                 },
                 debugColor: {
                     type: "v3",
-                    value: new Qe()
+                    value: new et()
                 },
                 covariancesTextureSize: {
                     type: "v2",
-                    value: new me(1024, 1024)
+                    value: new Ee(1024, 1024)
                 },
                 centersColorsTextureSize: {
                     type: "v2",
-                    value: new me(1024, 1024)
+                    value: new Ee(1024, 1024)
+                },
+                sphericalHarmonicsDegree: {
+                    type: "i",
+                    value: a
+                },
+                sphericalHarmonicsTextureSize: {
+                    type: "v2",
+                    value: new Ee(1024, 1024)
+                },
+                sphericalHarmonics8BitMode: {
+                    type: "i",
+                    value: 0
+                },
+                splatScale: {
+                    type: "f",
+                    value: r
+                },
+                pointCloudModeEnabled: {
+                    type: "i",
+                    value: o ? 1 : 0
                 }
             };
         if (t) {
-            s.transformIndexesTexture = {
+            u.transformIndexesTexture = {
                 type: "t",
                 value: null
             };
-            const o = [];
-            for (let l = 0; l < mt.MaxScenes; l++)
-                o.push(new ke());
-            s.transforms = {
+            const f = [];
+            for (let h = 0; h < rt.MaxScenes; h++)
+                f.push(new Ge());
+            u.transforms = {
                 type: "mat4",
-                value: o
-            }, s.transformIndexesTextureSize = {
+                value: f
+            }, u.transformIndexesTextureSize = {
                 type: "v2",
-                value: new me(1024, 1024)
+                value: new Ee(1024, 1024)
             };
         }
-        return new Xt({
-            uniforms: s,
-            vertexShader: n,
-            fragmentShader: r,
+        return new tn({
+            uniforms: u,
+            vertexShader: l,
+            fragmentShader: c,
             transparent: !0,
             alphaTest: 1,
-            blending: ri,
+            blending: Si,
             depthTest: !0,
             depthWrite: !1,
-            side: en
+            side: un
         });
     }
     /**
      * Build the Three.js geometry that will be used to render the splats. The geometry is instanced and is made up of
      * vertices for a single quad as well as an attribute buffer for the splat indexes.
      * @param {number} maxSplatCount The maximum number of splats that the geometry will need to accomodate
      * @return {THREE.InstancedBufferGeometry}
      */
     static buildGeomtery(t) {
-        const n = new Yt();
+        const n = new sn();
         n.setIndex([0, 1, 2, 0, 2, 3]);
-        const r = new Float32Array(4 * 3),
-            s = new Wt(r, 3);
-        n.setAttribute("position", s), s.setXYZ(0, -1, -1, 0), s.setXYZ(1, -1, 1, 0), s.setXYZ(2, 1, 1, 0), s.setXYZ(3, 1, -1, 0), s.needsUpdate = !0;
-        const a = new o_().copy(n),
-            o = new Uint32Array(t),
-            l = new s_(o, 1, !1);
-        return l.setUsage(wf), a.setAttribute("splatIndex", l), a.instanceCount = t, a;
+        const i = new Float32Array(4 * 3),
+            r = new en(i, 3);
+        n.setAttribute("position", r), r.setXYZ(0, -1, -1, 0), r.setXYZ(1, -1, 1, 0), r.setXYZ(2, 1, 1, 0), r.setXYZ(3, 1, -1, 0), r.needsUpdate = !0;
+        const o = new t_().copy(n),
+            a = new Uint32Array(t),
+            l = new e_(a, 1, !1);
+        return l.setUsage(Ef), o.setAttribute("splatIndex", l), o.instanceCount = 0, o;
     }
     /**
      * Build a container for each scene managed by this splat mesh based on an instance of SplatBuffer, along with optional
      * transform data (position, scale, rotation) passed to the splat mesh during the build process.
      * @param {Array<THREE.Matrix4>} splatBuffers SplatBuffer instances containing splats for each scene
      * @param {Array<object>} sceneOptions Array of options objects: {
      *
@@ -19859,259 +22059,604 @@
      *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
      *
      *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
      * }
      * @return {Array<THREE.Matrix4>}
      */
     static buildScenes(t, n) {
-        const r = [];
-        r.length = t.length;
-        for (let s = 0; s < t.length; s++) {
-            const a = t[s],
-                o = n[s] || {};
-            let l = o.position || [0, 0, 0],
-                c = o.rotation || [0, 0, 0, 1],
-                u = o.scale || [1, 1, 1];
-            const f = new P().fromArray(l),
-                h = new wt().fromArray(c),
-                p = new P().fromArray(u);
-            r[s] = kt.createScene(a, f, h, p);
+        const i = [];
+        i.length = t.length;
+        for (let r = 0; r < t.length; r++) {
+            const o = t[r],
+                a = n[r] || {};
+            let l = a.position || [0, 0, 0],
+                c = a.rotation || [0, 0, 0, 1],
+                u = a.scale || [1, 1, 1];
+            const d = new D().fromArray(l),
+                f = new St().fromArray(c),
+                h = new D().fromArray(u);
+            i[r] = Bt.createScene(o, d, f, h, a.splatAlphaRemovalThreshold || 1);
         }
-        return r;
+        return i;
     }
-    static createScene(t, n, r, s) {
-        return new S_(t, n, r, s);
+    static createScene(t, n, i, r, o) {
+        return new S_(t, n, i, r, o);
     }
     /**
      * Build data structures that map global splat indexes (based on a unified index across all splat buffers) to
      * local data within a single scene.
      * @param {Array<SplatBuffer>} splatBuffers Instances of SplatBuffer off which to build the maps
      * @return {object}
      */
     static buildSplatIndexMaps(t) {
         const n = [],
-            r = [];
-        let s = 0;
-        for (let a = 0; a < t.length; a++) {
-            const l = t[a].getSplatCount();
+            i = [];
+        let r = 0;
+        for (let o = 0; o < t.length; o++) {
+            const l = t[o].getMaxSplatCount();
             for (let c = 0; c < l; c++)
-                n[s] = c, r[s] = a, s++;
+                n[r] = c, i[r] = o, r++;
         }
         return {
             localSplatIndexMap: n,
-            sceneIndexMap: r
+            sceneIndexMap: i
         };
     }
     /**
-     * Build an instance of SplatTree (a specialized octree) for the given splat mesh.
-     * @param {SplatMesh} splatMesh SplatMesh instance for which the splat tree will be built
-     * @param {Array<number>} minAlphas Array of minimum splat slphas for each scene
-     * @return {SplatTree}
-     */
-    static buildSplatTree(t, n = []) {
-        const r = new lr(8, 1e3);
-        console.time("SplatTree build");
-        const s = new ut();
-        r.processSplatMesh(t, (c) => {
-            t.getSplatColor(c, s);
-            const u = t.getSceneIndexForSplat(c),
-                f = n[u] || 1;
-            return s.w >= f;
-        }), console.timeEnd("SplatTree build");
-        let a = 0,
-            o = 0,
-            l = 0;
-        return r.visitLeaves((c) => {
-            const u = c.data.indexes.length;
-            u > 0 && (o += u, l++, a++);
-        }), console.log(`SplatTree leaves: ${r.countLeaves()}`), console.log(`SplatTree leaves with splats:${a}`), o = o / l, console.log(`Avg splat count per node: ${o}`), console.log(`Total splat count: ${t.getSplatCount()}`), r;
-    }
-    /**
      * Construct this instance of SplatMesh.
      * @param {Array<SplatBuffer>} splatBuffers The base splat data, instances of SplatBuffer
      * @param {Array<object>} sceneOptions Dynamic options for each scene {
      *
      *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
      *                                     value (valid range: 0 - 255), defaults to 1
      *
      *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
      *
      *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
      *
      *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
      *
      * }
-     * @param {Boolean} keepSceneTransforms For a scene that already exists and is being overwritten, this flag
+     * @param {boolean} keepSceneTransforms For a scene that already exists and is being overwritten, this flag
      *                                      says to keep the transform from the existing scene.
+     * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?
+     * @param {function} onSplatTreeIndexesUpload Function to be called when the upload of splat centers to the splat tree
+     *                                            builder worker starts and finishes.
+     * @param {function} onSplatTreeConstruction Function to be called when the conversion of the local splat tree from
+     *                                           the format produced by the splat tree builder worker starts and ends.
+     * @return {object} Object containing info about the splats that are updated
      */
-    build(t, n, r = !0) {
-        this.disposeMeshData();
-        const s = kt.getTotalSplatCountForSplatBuffers(t),
-            a = kt.buildScenes(t, n);
-        if (r)
-            for (let l = 0; l < this.scenes.length && l < a.length; l++) {
-                const c = a[l],
-                    u = this.getScene(l);
-                c.copyTransformData(u);
-            }
-        this.scenes = a, this.geometry = kt.buildGeomtery(s), this.material = kt.buildMaterial(this.dynamicMode);
-        const o = kt.buildSplatIndexMaps(t);
-        this.globalSplatIndexToLocalSplatIndexMap = o.localSplatIndexMap, this.globalSplatIndexToSceneIndexMap = o.sceneIndexMap, this.splatTree = kt.buildSplatTree(this, n.map((l) => l.splatAlphaRemovalThreshold || 1)), this.enableDistancesComputationOnGPU && this.setupDistancesComputationTransformFeedback(), this.resetDataFromSplatBuffers();
+    build(t, n, i = !0, r = !1, o, a) {
+        this.sceneOptions = n, this.finalBuild = r;
+        const l = Bt.getTotalMaxSplatCountForSplatBuffers(t),
+            c = Bt.buildScenes(t, n);
+        if (i)
+            for (let _ = 0; _ < this.scenes.length && _ < c.length; _++) {
+                const m = c[_],
+                    p = this.getScene(_);
+                m.copyTransformData(p);
+            }
+        this.scenes = c;
+        let u = 3;
+        for (let _ of t) {
+            const m = _.getMinSphericalHarmonicsDegree();
+            m < u && (u = m);
+        }
+        this.minSphericalHarmonicsDegree = Math.min(u, this.sphericalHarmonicsDegree);
+        let d = !1;
+        if (t.length !== this.lastBuildScenes.length)
+            d = !0;
+        else
+            for (let _ = 0; _ < t.length; _++)
+                if (t[_] !== this.lastBuildScenes[_].splatBuffer) {
+                    d = !0;
+                    break;
+                }
+        let f = !0;
+        if ((this.scenes.length !== 1 || this.lastBuildSceneCount !== this.scenes.length || this.lastBuildMaxSplatCount !== l || d) && (f = !1), !f) {
+            this.boundingBox = new Un(), this.maxSplatDistanceFromSceneCenter = 0, this.visibleRegionBufferRadius = 0, this.visibleRegionRadius = 0, this.visibleRegionFadeStartRadius = 0, this.firstRenderTime = -1, this.lastBuildScenes = [], this.lastBuildSplatCount = 0, this.lastBuildMaxSplatCount = 0, this.disposeMeshData(), this.geometry = Bt.buildGeomtery(l), this.material = Bt.buildMaterial(
+                this.dynamicMode,
+                this.antialiased,
+                this.maxScreenSpaceSplatSize,
+                this.splatScale,
+                this.pointCloudModeEnabled,
+                this.minSphericalHarmonicsDegree
+            );
+            const _ = Bt.buildSplatIndexMaps(t);
+            this.globalSplatIndexToLocalSplatIndexMap = _.localSplatIndexMap, this.globalSplatIndexToSceneIndexMap = _.sceneIndexMap;
+        }
+        const h = this.getSplatCount();
+        this.enableDistancesComputationOnGPU && this.setupDistancesComputationTransformFeedback();
+        const g = this.refreshGPUDataFromSplatBuffers(f);
+        for (let _ = 0; _ < this.scenes.length; _++)
+            this.lastBuildScenes[_] = this.scenes[_];
+        return this.lastBuildSplatCount = h, this.lastBuildMaxSplatCount = this.getMaxSplatCount(), this.lastBuildSceneCount = this.scenes.length, r && this.scenes.length > 0 && this.buildSplatTree(
+            n.map((_) => _.splatAlphaRemovalThreshold || 1),
+            o,
+            a
+        ).then(() => {
+            this.onSplatTreeReadyCallback && this.onSplatTreeReadyCallback(this.splatTree);
+        }), this.visible = this.scenes.length > 0, g;
     }
     /**
      * Dispose all resources held by the splat mesh
      */
     dispose() {
-        this.disposeMeshData(), this.enableDistancesComputationOnGPU && this.disposeDistancesComputationGPUResources();
+        this.disposeMeshData(), this.disposeTextures(), this.disposeSplatTree(), this.enableDistancesComputationOnGPU && (this.computeDistancesOnGPUSyncTimeout && (clearTimeout(this.computeDistancesOnGPUSyncTimeout), this.computeDistancesOnGPUSyncTimeout = null), this.disposeDistancesComputationGPUResources()), this.scenes = [], this.distancesTransformFeedback = {
+            id: null,
+            vertexShader: null,
+            fragmentShader: null,
+            program: null,
+            centersBuffer: null,
+            transformIndexesBuffer: null,
+            outDistancesBuffer: null,
+            centersLoc: -1,
+            modelViewProjLoc: -1,
+            transformIndexesLoc: -1,
+            transformsLocs: []
+        }, this.renderer = null, this.globalSplatIndexToLocalSplatIndexMap = [], this.globalSplatIndexToSceneIndexMap = [], this.lastBuildSplatCount = 0, this.lastBuildScenes = [], this.lastBuildMaxSplatCount = 0, this.lastBuildSceneCount = 0, this.firstRenderTime = -1, this.finalBuild = !1, this.webGLUtils = null, this.boundingBox = new Un(), this.calculatedSceneCenter = new D(), this.maxSplatDistanceFromSceneCenter = 0, this.visibleRegionBufferRadius = 0, this.visibleRegionRadius = 0, this.visibleRegionFadeStartRadius = 0, this.visibleRegionChanging = !1, this.splatScale = 1, this.pointCloudModeEnabled = !1, this.disposed = !0, this.lastRenderer = null, this.visible = !1;
     }
     /**
      * Dispose of only the Three.js mesh resources (geometry, material, and texture)
      */
     disposeMeshData() {
-        this.geometry && this.geometry !== ll && (this.geometry.dispose(), this.geometry = null);
+        this.geometry && this.geometry !== $l && (this.geometry.dispose(), this.geometry = null), this.material && (this.material.dispose(), this.material = null);
+    }
+    disposeTextures() {
         for (let t in this.splatDataTextures)
             if (this.splatDataTextures.hasOwnProperty(t)) {
                 const n = this.splatDataTextures[t];
                 n.texture && (n.texture.dispose(), n.texture = null);
             }
-        this.splatDataTextures = null, this.material && (this.material.dispose(), this.material = null), this.splatTree = null;
+        this.splatDataTextures = null;
+    }
+    disposeSplatTree() {
+        this.splatTree ? (this.splatTree.dispose(), this.splatTree = null) : this.baseSplatTree && (this.baseSplatTree.dispose(), this.baseSplatTree = null);
     }
     getSplatTree() {
         return this.splatTree;
     }
+    onSplatTreeReady(t) {
+        this.onSplatTreeReadyCallback = t;
+    }
     /**
-     * Refresh data textures and GPU buffers for splat distance pre-computation with data from the splat buffers for this mesh.
+     * Get copies of data that are necessary for splat distance computation: splat center positions and splat
+     * scene indexes (necessary for applying dynamic scene transformations during distance computation)
+     * @param {*} start The index at which to start copying data
+     * @param {*} end  The index at which to stop copying data
+     * @return {object}
      */
-    resetDataFromSplatBuffers() {
-        this.uploadSplatDataToTextures(), this.enableDistancesComputationOnGPU && (this.updateGPUCentersBufferForDistancesComputation(), this.updateGPUTransformIndexesBufferForDistancesComputation());
+    getDataForDistancesComputation(t, n) {
+        const i = this.integerBasedDistancesComputation ? this.getIntegerCenters(t, n, !0) : this.getFloatCenters(t, n, !0),
+            r = this.getSceneIndexes(t, n);
+        return {
+            centers: i,
+            sceneIndexes: r
+        };
+    }
+    /**
+     * Refresh data textures and GPU buffers with splat data from the splat buffers belonging to this mesh.
+     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.
+     * @return {object}
+     */
+    refreshGPUDataFromSplatBuffers(t) {
+        const n = this.getSplatCount();
+        this.refreshDataTexturesFromSplatBuffers(t);
+        const i = t ? this.lastBuildSplatCount : 0,
+            {
+                centers: r,
+                sceneIndexes: o
+            } = this.getDataForDistancesComputation(i, n - 1);
+        return this.enableDistancesComputationOnGPU && this.refreshGPUBuffersForDistancesComputation(r, o, t), {
+            from: i,
+            to: n - 1,
+            count: n - i,
+            centers: r,
+            sceneIndexes: o
+        };
+    }
+    /**
+     * Update the GPU buffers that are used for computing splat distances on the GPU.
+     * @param {Array<number>} centers Splat center positions
+     * @param {Array<number>} sceneIndexes Indexes of the scene to which each splat belongs
+     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.
+     */
+    refreshGPUBuffersForDistancesComputation(t, n, i = !1) {
+        const r = i ? this.lastBuildSplatCount : 0;
+        this.updateGPUCentersBufferForDistancesComputation(i, t, r), this.updateGPUTransformIndexesBufferForDistancesComputation(i, n, r);
     }
     /**
      * Refresh data textures with data from the splat buffers for this mesh.
+     * @param {boolean} sinceLastBuildOnly Specify whether or not to only update for splats that have been added since the last build.
      */
-    uploadSplatDataToTextures() {
-        const t = this.getSplatCount(),
-            n = new Float32Array(t * 6),
-            r = new Float32Array(t * 3),
-            s = new Uint8Array(t * 4);
-        this.fillSplatDataArrays(n, r, s);
-        const a = 2,
-            o = 4,
-            l = 1,
-            c = new me(4096, 1024);
-        for (; c.x * c.y * a < t * 6;)
-            c.y *= 2;
-        const u = new me(4096, 1024);
-        for (; u.x * u.y * o < t * 4;)
-            u.y *= 2;
-        let f, h;
-        if (this.halfPrecisionCovariancesOnGPU) {
-            h = new Uint16Array(c.x * c.y * a);
-            for (let v = 0; v < n.length; v++)
-                h[v] = $r.toHalfFloat(n[v]);
-            f = new Or(
-                h,
-                c.x,
-                c.y,
-                io,
-                Gi
-            );
-        } else
-            h = new Float32Array(c.x * c.y * a), h.set(n), f = new Or(
-                h,
-                c.x,
-                c.y,
-                io,
-                an
-            );
-        f.needsUpdate = !0, this.material.uniforms.covariancesTexture.value = f, this.material.uniforms.covariancesTextureSize.value.copy(c);
-        const p = new Uint32Array(u.x * u.y * o);
-        for (let v = 0; v < t; v++) {
-            const m = v * 4,
-                d = v * 3,
-                M = v * 4;
-            p[M] = a_(
-                s[m],
-                s[m + 1],
-                s[m + 2],
-                s[m + 3]
-            ), p[M + 1] = js(r[d]), p[M + 2] = js(r[d + 1]), p[M + 3] = js(r[d + 2]);
-        }
-        const g = new Or(
-            p,
-            u.x,
-            u.y,
-            po,
-            nn
+    refreshDataTexturesFromSplatBuffers(t) {
+        t ? this.updateDataTextures() : this.setupDataTextures(), this.updateVisibleRegion(t);
+    }
+    setupDataTextures() {
+        const t = this.getMaxSplatCount(),
+            n = this.getSplatCount();
+        this.disposeTextures();
+        const i = (E, T) => {
+                const L = new Ee(4096, 1024);
+                for (; L.x * L.y * E < t * T;)
+                    L.y *= 2;
+                return L;
+            },
+            r = this.getTargetCovarianceCompressionLevel(),
+            o = this.getTargetSphericalHarmonicsCompressionLevel(),
+            a = new Float32Array(t * ur),
+            l = new Float32Array(t * 3),
+            c = new Uint8Array(t * 4);
+        let u = Float32Array;
+        o === 1 ? u = Uint16Array : o === 2 && (u = Uint8Array);
+        const d = Us(this.minSphericalHarmonicsDegree);
+        let f = d;
+        f % 2 !== 0 && f++;
+        const h = this.minSphericalHarmonicsDegree ? new u(t * d) : void 0;
+        this.fillSplatDataArrays(
+            a,
+            l,
+            c,
+            h,
+            void 0,
+            r,
+            o
+        );
+        const g = i(Ra, 6);
+        let _ = r >= 1 ? Uint16Array : Float32Array,
+            m = r >= 1 ? xi : gn;
+        const p = new _(g.x * g.y * Ra);
+        p.set(a);
+        const v = new or(p, g.x, g.y, kt, m);
+        v.needsUpdate = !0, this.material.uniforms.covariancesTexture.value = v, this.material.uniforms.covariancesTextureSize.value.copy(g);
+        const S = i(Pa, 4),
+            y = new Uint32Array(S.x * S.y * Pa);
+        Bt.updateCenterColorsPaddedData(0, n, l, c, y);
+        const b = new or(
+            y,
+            S.x,
+            S.y,
+            Za,
+            fn
         );
-        if (g.internalFormat = "RGBA32UI", g.needsUpdate = !0, this.material.uniforms.centersColorsTexture.value = g, this.material.uniforms.centersColorsTextureSize.value.copy(u), this.material.uniformsNeedUpdate = !0, this.splatDataTextures = {
+        if (b.internalFormat = "RGBA32UI", b.needsUpdate = !0, this.material.uniforms.centersColorsTexture.value = b, this.material.uniforms.centersColorsTextureSize.value.copy(S), this.material.uniformsNeedUpdate = !0, this.splatDataTextures = {
+                baseData: {
+                    covariances: a,
+                    centers: l,
+                    colors: c,
+                    sphericalHarmonics: h
+                },
                 covariances: {
-                    data: h,
-                    texture: f,
-                    size: c
+                    data: p,
+                    texture: v,
+                    size: g,
+                    compressionLevel: r
                 },
                 centerColors: {
-                    data: p,
-                    texture: g,
-                    size: u
-                }
-            }, this.dynamicMode) {
-            const v = new me(4096, 1024);
-            for (; v.x * v.y * l < t;)
-                v.y *= 2;
-            const m = new Uint32Array(v.x * v.y * l);
-            for (let M = 0; M < t; M++)
-                m[M] = this.globalSplatIndexToSceneIndexMap[M];
-            const d = new Or(
-                m,
-                v.x,
-                v.y,
-                ho,
-                nn
+                    data: y,
+                    texture: b,
+                    size: S
+                }
+            }, h) {
+            const T = i(
+                    4,
+                    f
+                ),
+                L = T.x * T.y * 4,
+                B = new u(L);
+            for (let U = 0; U < n; U++) {
+                const N = d * U,
+                    P = f * U;
+                for (let I = 0; I < d; I++)
+                    B[P + I] = h[N + I];
+            }
+            const x = o === 2 ? In : xi,
+                A = new or(
+                    B,
+                    T.x,
+                    T.y,
+                    kt,
+                    x
+                );
+            A.needsUpdate = !0, this.material.uniforms.sphericalHarmonicsTexture.value = A, this.material.uniforms.sphericalHarmonicsTextureSize.value.copy(T), o === 2 && (this.material.uniforms.sphericalHarmonics8BitMode.value = 1), this.material.uniformsNeedUpdate = !0, this.splatDataTextures.sphericalHarmonics = {
+                componentCount: d,
+                paddedComponentCount: f,
+                data: B,
+                texture: A,
+                size: T,
+                compressionLevel: o
+            };
+        }
+        if (this.dynamicMode) {
+            const E = i(ec, 4),
+                T = new Uint32Array(E.x * E.y * ec);
+            for (let B = 0; B < n; B++)
+                T[B] = this.globalSplatIndexToSceneIndexMap[B];
+            const L = new or(
+                T,
+                E.x,
+                E.y,
+                Ka,
+                fn
             );
-            d.internalFormat = "R32UI", d.needsUpdate = !0, this.material.uniforms.transformIndexesTexture.value = d, this.material.uniforms.transformIndexesTextureSize.value.copy(v), this.material.uniformsNeedUpdate = !0, this.splatDataTextures.tansformIndexes = {
-                data: m,
-                texture: d,
-                size: v
+            L.internalFormat = "R32UI", L.needsUpdate = !0, this.material.uniforms.transformIndexesTexture.value = L, this.material.uniforms.transformIndexesTextureSize.value.copy(E), this.material.uniformsNeedUpdate = !0, this.splatDataTextures.tansformIndexes = {
+                data: T,
+                texture: L,
+                size: E
             };
         }
     }
+    updateDataTextures() {
+        const t = this.getSplatCount(),
+            n = this.splatDataTextures.covariances.compressionLevel,
+            i = this.splatDataTextures.sphericalHarmonics,
+            r = i ? i.compressionLevel : 0;
+        this.fillSplatDataArrays(
+            this.splatDataTextures.baseData.covariances,
+            this.splatDataTextures.baseData.centers,
+            this.splatDataTextures.baseData.colors,
+            this.splatDataTextures.baseData.sphericalHarmonics,
+            void 0,
+            n,
+            r,
+            this.lastBuildSplatCount,
+            t - 1,
+            this.lastBuildSplatCount
+        );
+        const o = this.splatDataTextures.covariances,
+            a = o.data,
+            l = o.texture,
+            c = this.lastBuildSplatCount * ur,
+            u = t * ur;
+        for (let m = c; m < u; m++) {
+            const p = this.splatDataTextures.baseData.covariances[m];
+            a[m] = p;
+        }
+        const d = this.renderer ? this.renderer.properties.get(l) : null;
+        if (!d || !d.__webglTexture)
+            l.needsUpdate = !0;
+        else {
+            const m = n ? 2 : 4;
+            this.updateDataTexture(
+                a,
+                o,
+                d,
+                Ra,
+                ur,
+                m,
+                this.lastBuildSplatCount,
+                t - 1
+            );
+        }
+        const f = this.splatDataTextures.centerColors,
+            h = f.data,
+            g = f.texture;
+        Bt.updateCenterColorsPaddedData(
+            this.lastBuildSplatCount,
+            t,
+            this.splatDataTextures.baseData.centers,
+            this.splatDataTextures.baseData.colors,
+            h
+        );
+        const _ = this.renderer ? this.renderer.properties.get(g) : null;
+        if (!_ || !_.__webglTexture ? g.needsUpdate = !0 : this.updateDataTexture(
+                h,
+                f,
+                _,
+                Pa,
+                b_,
+                4,
+                this.lastBuildSplatCount,
+                t - 1
+            ), this.splatDataTextures.baseData.sphericalHarmonics) {
+            const m = i.componentCount,
+                p = i.paddedComponentCount,
+                v = i.data;
+            for (let b = this.lastBuildSplatCount; b < t; b++) {
+                const E = m * b,
+                    T = p * b;
+                for (let L = 0; L < m; L++)
+                    v[T + L] = this.splatDataTextures.baseData.sphericalHarmonics[E + L];
+            }
+            const S = i.texture,
+                y = this.renderer ? this.renderer.properties.get(S) : null;
+            if (!y || !y.__webglTexture)
+                S.needsUpdate = !0;
+            else {
+                let E = 4;
+                r === 1 ? E = 2 : r === 2 && (E = 1), this.updateDataTexture(
+                    v,
+                    i,
+                    y,
+                    4,
+                    p,
+                    E,
+                    this.lastBuildSplatCount,
+                    t - 1
+                );
+            }
+        }
+        if (this.dynamicMode) {
+            const m = this.splatDataTextures.tansformIndexes,
+                p = m.data;
+            for (let y = this.lastBuildSplatCount; y < t; y++)
+                p[y] = this.globalSplatIndexToSceneIndexMap[y];
+            const v = m.texture,
+                S = this.renderer ? this.renderer.properties.get(v) : null;
+            !S || !S.__webglTexture ? v.needsUpdate = !0 : this.updateDataTexture(
+                p,
+                m,
+                S,
+                1,
+                1,
+                1,
+                this.lastBuildSplatCount,
+                t - 1
+            );
+        }
+    }
+    getTargetCovarianceCompressionLevel() {
+        return this.halfPrecisionCovariancesOnGPU ? 1 : 0;
+    }
+    getTargetSphericalHarmonicsCompressionLevel() {
+        return Math.max(1, this.getMaximumSplatBufferCompressionLevel());
+    }
+    getMaximumSplatBufferCompressionLevel() {
+        let t;
+        for (let n = 0; n < this.scenes.length; n++) {
+            const r = this.getScene(n).splatBuffer;
+            (n === 0 || r.compressionLevel > t) && (t = r.compressionLevel);
+        }
+        return t;
+    }
+    getMinimumSplatBufferCompressionLevel() {
+        let t;
+        for (let n = 0; n < this.scenes.length; n++) {
+            const r = this.getScene(n).splatBuffer;
+            (n === 0 || r.compressionLevel < t) && (t = r.compressionLevel);
+        }
+        return t;
+    }
+    static computeTextureUpdateRegion(t, n, i, r, o) {
+        const a = o / r,
+            l = t * a,
+            c = Math.floor(l / i),
+            u = c * i * r,
+            d = n * a,
+            f = Math.floor(d / i),
+            h = f * i * r + i * r;
+        return {
+            dataStart: u,
+            dataEnd: h,
+            startRow: c,
+            endRow: f
+        };
+    }
+    updateDataTexture(t, n, i, r, o, a, l, c) {
+        const u = this.renderer.getContext(),
+            d = Bt.computeTextureUpdateRegion(l, c, n.size.x, r, o),
+            f = d.dataEnd - d.dataStart,
+            h = new t.constructor(
+                t.buffer,
+                d.dataStart * a,
+                f
+            ),
+            g = d.endRow - d.startRow + 1,
+            _ = n.texture,
+            m = this.webGLUtils.convert(_.type),
+            p = this.webGLUtils.convert(_.format, _.colorSpace),
+            v = u.getParameter(u.TEXTURE_BINDING_2D);
+        u.bindTexture(u.TEXTURE_2D, i.__webglTexture), u.texSubImage2D(
+            u.TEXTURE_2D,
+            0,
+            0,
+            d.startRow,
+            n.size.x,
+            g,
+            p,
+            m,
+            h
+        ), u.bindTexture(u.TEXTURE_2D, v);
+    }
+    static updateCenterColorsPaddedData(t, n, i, r, o) {
+        for (let a = t; a < n; a++) {
+            const l = a * 4,
+                c = a * 3,
+                u = a * 4;
+            o[u] = n_(r, l), o[u + 1] = Aa(i[c]), o[u + 2] = Aa(i[c + 1]), o[u + 3] = Aa(i[c + 2]);
+        }
+    }
+    updateVisibleRegion(t) {
+        const n = this.getSplatCount(),
+            i = new D();
+        if (!t) {
+            const o = new D();
+            this.scenes.forEach((a) => {
+                o.add(a.splatBuffer.sceneCenter);
+            }), o.multiplyScalar(1 / this.scenes.length), this.calculatedSceneCenter.copy(o), this.material.uniforms.sceneCenter.value.copy(this.calculatedSceneCenter), this.material.uniformsNeedUpdate = !0;
+        }
+        const r = t ? this.lastBuildSplatCount : 0;
+        for (let o = r; o < n; o++) {
+            this.getSplatCenter(o, i, !1);
+            const a = i.sub(this.calculatedSceneCenter).length();
+            a > this.maxSplatDistanceFromSceneCenter && (this.maxSplatDistanceFromSceneCenter = a);
+        }
+        this.maxSplatDistanceFromSceneCenter - this.visibleRegionBufferRadius > tc && (this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter, this.visibleRegionRadius = Math.max(this.visibleRegionBufferRadius - tc, 0)), this.finalBuild && (this.visibleRegionRadius = this.visibleRegionBufferRadius = this.maxSplatDistanceFromSceneCenter), this.updateVisibleRegionFadeDistance();
+    }
+    updateVisibleRegionFadeDistance(t = _r.Default) {
+        const n = C_,
+            i = w_,
+            r = this.finalBuild ? n : i,
+            o = t === _r.Default ? r : i;
+        this.visibleRegionFadeStartRadius = (this.visibleRegionRadius - this.visibleRegionFadeStartRadius) * o + this.visibleRegionFadeStartRadius;
+        const l = (this.visibleRegionBufferRadius > 0 ? this.visibleRegionFadeStartRadius / this.visibleRegionBufferRadius : 0) > 0.99,
+            c = l || t === _r.Instant ? 1 : 0;
+        this.material.uniforms.visibleRegionFadeStartRadius.value = this.visibleRegionFadeStartRadius, this.material.uniforms.visibleRegionRadius.value = this.visibleRegionRadius, this.material.uniforms.firstRenderTime.value = this.firstRenderTime, this.material.uniforms.currentTime.value = performance.now(), this.material.uniforms.fadeInComplete.value = c, this.material.uniformsNeedUpdate = !0, this.visibleRegionChanging = !l;
+    }
     /**
      * Set the indexes of splats that should be rendered; should be sorted in desired render order.
      * @param {Uint32Array} globalIndexes Sorted index list of splats to be rendered
      * @param {number} renderSplatCount Total number of splats to be rendered. Necessary because we may not want to render
      *                                  every splat.
      */
     updateRenderIndexes(t, n) {
-        const r = this.geometry;
-        r.attributes.splatIndex.set(t), r.attributes.splatIndex.needsUpdate = !0, r.instanceCount = n;
+        const i = this.geometry;
+        i.attributes.splatIndex.set(t), i.attributes.splatIndex.needsUpdate = !0, n > 0 && this.firstRenderTime === -1 && (this.firstRenderTime = performance.now()), i.instanceCount = n;
     }
     /**
      * Update the transforms for each scene in this splat mesh from their individual components (position,
      * quaternion, and scale)
      */
     updateTransforms() {
         for (let t = 0; t < this.scenes.length; t++)
             this.getScene(t).updateTransform();
     }
+    setSplatScale(t = 1) {
+        this.splatScale = t, this.material.uniforms.splatScale.value = t, this.material.uniformsNeedUpdate = !0;
+    }
+    getSplatScale() {
+        return this.splatScale;
+    }
+    setPointCloudModeEnabled(t) {
+        this.pointCloudModeEnabled = t, this.material.uniforms.pointCloudModeEnabled.value = t ? 1 : 0, this.material.uniformsNeedUpdate = !0;
+    }
+    getPointCloudModeEnabled() {
+        return this.pointCloudModeEnabled;
+    }
     getSplatDataTextures() {
         return this.splatDataTextures;
     }
     getSplatCount() {
-        return kt.getTotalSplatCountForScenes(this.scenes);
+        return Bt.getTotalSplatCountForScenes(this.scenes);
     }
     static getTotalSplatCountForScenes(t) {
         let n = 0;
-        for (let r of t)
-            r && r.splatBuffer && (n += r.splatBuffer.getSplatCount());
+        for (let i of t)
+            i && i.splatBuffer && (n += i.splatBuffer.getSplatCount());
         return n;
     }
     static getTotalSplatCountForSplatBuffers(t) {
         let n = 0;
-        for (let r of t)
-            n += r.getSplatCount();
+        for (let i of t)
+            n += i.getSplatCount();
+        return n;
+    }
+    getMaxSplatCount() {
+        return Bt.getTotalMaxSplatCountForScenes(this.scenes);
+    }
+    static getTotalMaxSplatCountForScenes(t) {
+        let n = 0;
+        for (let i of t)
+            i && i.splatBuffer && (n += i.splatBuffer.getMaxSplatCount());
+        return n;
+    }
+    static getTotalMaxSplatCountForSplatBuffers(t) {
+        let n = 0;
+        for (let i of t)
+            n += i.getMaxSplatCount();
         return n;
     }
     disposeDistancesComputationGPUResources() {
         if (!this.renderer)
             return;
         const t = this.renderer.getContext();
         this.distancesTransformFeedback.vao && (t.deleteVertexArray(this.distancesTransformFeedback.vao), this.distancesTransformFeedback.vao = null), this.distancesTransformFeedback.program && (t.deleteProgram(this.distancesTransformFeedback.program), t.deleteShader(this.distancesTransformFeedback.vertexShader), t.deleteShader(this.distancesTransformFeedback.fragmentShader), this.distancesTransformFeedback.program = null, this.distancesTransformFeedback.vertexShader = null, this.distancesTransformFeedback.fragmentShader = null), this.disposeDistancesComputationGPUBufferResources(), this.distancesTransformFeedback.id && (t.deleteTransformFeedback(this.distancesTransformFeedback.id), this.distancesTransformFeedback.id = null);
@@ -20123,129 +22668,189 @@
         this.distancesTransformFeedback.centersBuffer && (this.distancesTransformFeedback.centersBuffer = null, t.deleteBuffer(this.distancesTransformFeedback.centersBuffer)), this.distancesTransformFeedback.outDistancesBuffer && (t.deleteBuffer(this.distancesTransformFeedback.outDistancesBuffer), this.distancesTransformFeedback.outDistancesBuffer = null);
     }
     /**
      * Set the Three.js renderer used by this splat mesh
      * @param {THREE.WebGLRenderer} renderer Instance of THREE.WebGLRenderer
      */
     setRenderer(t) {
-        t !== this.renderer && (this.renderer = t, this.enableDistancesComputationOnGPU && this.getSplatCount() > 0 && (this.setupDistancesComputationTransformFeedback(), this.updateGPUCentersBufferForDistancesComputation(), this.updateGPUTransformIndexesBufferForDistancesComputation()));
+        if (t !== this.renderer) {
+            this.renderer = t;
+            const n = this.renderer.getContext(),
+                i = new E_(n),
+                r = new A_(n, i, {});
+            if (i.init(r), this.webGLUtils = new ru(n, i, r), this.enableDistancesComputationOnGPU && this.getSplatCount() > 0) {
+                this.setupDistancesComputationTransformFeedback();
+                const {
+                    centers: o,
+                    sceneIndexes: a
+                } = this.getDataForDistancesComputation(0, this.getSplatCount() - 1);
+                this.refreshGPUBuffersForDistancesComputation(o, a);
+            }
+        }
     }
     /**
      * Refresh GPU buffers used for computing splat distances with centers data from the scenes for this mesh.
+     * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill
+     * @param {Array<number>} centers The splat centers data
+     * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats
      */
-    updateGPUCentersBufferForDistancesComputation() {
+    updateGPUCentersBufferForDistancesComputation(t, n, i) {
         if (!this.renderer)
             return;
-        const t = this.renderer.getContext(),
-            n = t.getParameter(t.VERTEX_ARRAY_BINDING);
-        if (t.bindVertexArray(this.distancesTransformFeedback.vao), t.bindBuffer(t.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), this.integerBasedDistancesComputation) {
-            const r = this.getIntegerCenters(!0);
-            t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW);
-        } else {
-            const r = this.getFloatCenters(!1);
-            t.bufferData(t.ARRAY_BUFFER, r, t.STATIC_DRAW);
+        const r = this.renderer.getContext(),
+            o = r.getParameter(r.VERTEX_ARRAY_BINDING);
+        r.bindVertexArray(this.distancesTransformFeedback.vao);
+        const a = this.integerBasedDistancesComputation ? Uint32Array : Float32Array,
+            l = 16,
+            c = i * l;
+        if (r.bindBuffer(r.ARRAY_BUFFER, this.distancesTransformFeedback.centersBuffer), t)
+            r.bufferSubData(r.ARRAY_BUFFER, c, n);
+        else {
+            const u = new a(this.getMaxSplatCount() * l);
+            u.set(n), r.bufferData(r.ARRAY_BUFFER, u, r.STATIC_DRAW);
         }
-        t.bindBuffer(t.ARRAY_BUFFER, null), n && t.bindVertexArray(n);
+        r.bindBuffer(r.ARRAY_BUFFER, null), o && r.bindVertexArray(o);
     }
     /**
      * Refresh GPU buffers used for pre-computing splat distances with centers data from the scenes for this mesh.
+     * @param {boolean} isUpdate Specify whether or not to update the GPU buffer or to initialize & fill
+     * @param {Array<number>} transformIndexes The splat transform indexes
+     * @param {number} offsetSplats Offset in the GPU buffer at which to start updating data, specified in splats
      */
-    updateGPUTransformIndexesBufferForDistancesComputation() {
+    updateGPUTransformIndexesBufferForDistancesComputation(t, n, i) {
         if (!this.renderer || !this.dynamicMode)
             return;
-        const t = this.renderer.getContext(),
-            n = t.getParameter(t.VERTEX_ARRAY_BINDING);
-        t.bindVertexArray(this.distancesTransformFeedback.vao), t.bindBuffer(t.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), t.bufferData(t.ARRAY_BUFFER, this.getTransformIndexes(), t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, null), n && t.bindVertexArray(n);
+        const r = this.renderer.getContext(),
+            o = r.getParameter(r.VERTEX_ARRAY_BINDING);
+        r.bindVertexArray(this.distancesTransformFeedback.vao);
+        const a = i * 4;
+        if (r.bindBuffer(r.ARRAY_BUFFER, this.distancesTransformFeedback.transformIndexesBuffer), t)
+            r.bufferSubData(r.ARRAY_BUFFER, a, n);
+        else {
+            const l = new Uint32Array(this.getMaxSplatCount() * 4);
+            l.set(n), r.bufferData(r.ARRAY_BUFFER, l, r.STATIC_DRAW);
+        }
+        r.bindBuffer(r.ARRAY_BUFFER, null), o && r.bindVertexArray(o);
     }
     /**
      * Get a typed array containing a mapping from global splat indexes to their scene index.
+     * @param {number} start Starting splat index to store
+     * @param {number} end Ending splat index to store
      * @return {Uint32Array}
      */
-    getTransformIndexes() {
-        const t = new Uint32Array(this.globalSplatIndexToSceneIndexMap.length);
-        return t.set(this.globalSplatIndexToSceneIndexMap), t;
+    getSceneIndexes(t, n) {
+        let i;
+        const r = n - t + 1;
+        i = new Uint32Array(r);
+        for (let o = t; o <= n; o++)
+            i[o] = this.globalSplatIndexToSceneIndexMap[o];
+        return i;
     }
     /**
      * Given a global splat index, return corresponding local data (splat buffer, index of splat in that splat
      * buffer, and the corresponding transform)
      * @param {number} globalIndex Global splat index
      * @param {object} paramsObj Object in which to store local data
      * @param {boolean} returnSceneTransform By default, the transform of the scene to which the splat at 'globalIndex' belongs will be
      *                                       returned via the 'sceneTransform' property of 'paramsObj' only if the splat mesh is static.
      *                                       If 'returnSceneTransform' is true, the 'sceneTransform' property will always contain the scene
      *                                       transform, and if 'returnSceneTransform' is false, the 'sceneTransform' property will always
      *                                       be null.
      */
-    getLocalSplatParameters(t, n, r) {
-        r == null && (r = !this.dynamicMode), n.splatBuffer = this.getSplatBufferForSplat(t), n.localIndex = this.getSplatLocalIndex(t), n.sceneTransform = r ? this.getSceneTransformForSplat(t) : null;
+    getLocalSplatParameters(t, n, i) {
+        i == null && (i = !this.dynamicMode), n.splatBuffer = this.getSplatBufferForSplat(t), n.localIndex = this.getSplatLocalIndex(t), n.sceneTransform = i ? this.getSceneTransformForSplat(t) : null;
     }
     /**
      * Fill arrays with splat data and apply transforms if appropriate. Each array is optional.
      * @param {Float32Array} covariances Target storage for splat covariances
      * @param {Float32Array} centers Target storage for splat centers
      * @param {Uint8Array} colors Target storage for splat colors
+     * @param {Float32Array} sphericalHarmonics Target storage for spherical harmonics
      * @param {boolean} applySceneTransform By default, scene transforms are applied to relevant splat data only if the splat mesh is
      *                                      static. If 'applySceneTransform' is true, scene transforms will always be applied and if
      *                                      it is false, they will never be applied. If undefined, the default behavior will apply.
+     * @param {number} covarianceCompressionLevel The compression level for covariances in the destination array
+     * @param {number} sphericalHarmonicsCompressionLevel The compression level for spherical harmonics in the destination array
+     * @param {number} srcStart The start location from which to pull source data
+     * @param {number} srcEnd The end location from which to pull source data
+     * @param {number} destStart The start location from which to write data
      */
-    fillSplatDataArrays(t, n, r, s) {
-        let a = 0;
-        for (let o = 0; o < this.scenes.length; o++) {
-            s == null && (s = !this.dynamicMode);
-            const l = this.getScene(o),
-                c = l.splatBuffer,
-                u = s ? l.transform : null;
-            t && c.fillSplatCovarianceArray(t, a, u), n && c.fillSplatCenterArray(n, a, u), r && c.fillSplatColorArray(r, a, u), a += c.getSplatCount();
+    fillSplatDataArrays(t, n, i, r, o, a = 0, l = 1, c, u, d = 0) {
+        for (let f = 0; f < this.scenes.length; f++) {
+            o == null && (o = !this.dynamicMode);
+            const h = this.getScene(f),
+                g = h.splatBuffer,
+                _ = o ? h.transform : null;
+            t && g.fillSplatCovarianceArray(
+                t,
+                _,
+                c,
+                u,
+                d,
+                a
+            ), n && g.fillSplatCenterArray(n, _, c, u, d), i && g.fillSplatColorArray(i, h.minimumAlpha, c, u, d), r && g.fillSphericalHarmonicsArray(
+                r,
+                this.minSphericalHarmonicsDegree,
+                _,
+                c,
+                u,
+                d,
+                l
+            ), d += g.getSplatCount();
         }
     }
     /**
      * Convert splat centers, which are floating point values, to an array of integers and multiply
      * each by 1000. Centers will get transformed as appropriate before conversion to integer.
-     * @param {number} padFour Enforce alignement of 4 by inserting a 1000 after every 3 values
+     * @param {number} start The index at which to start retrieving data
+     * @param {number} end The index at which to stop retrieving data
+     * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values
      * @return {Int32Array}
      */
-    getIntegerCenters(t) {
-        const n = this.getSplatCount(),
-            r = new Float32Array(n * 3);
-        this.fillSplatDataArrays(null, r, null);
-        let s, a = t ? 4 : 3;
-        s = new Int32Array(n * a);
-        for (let o = 0; o < n; o++) {
-            for (let l = 0; l < 3; l++)
-                s[o * a + l] = Math.round(r[o * 3 + l] * 1e3);
-            t && (s[o * a + 3] = 1e3);
+    getIntegerCenters(t, n, i = !1) {
+        const r = n - t + 1,
+            o = new Float32Array(r * 3);
+        this.fillSplatDataArrays(null, o, null, null, void 0, void 0, void 0, t);
+        let a, l = i ? 4 : 3;
+        a = new Int32Array(r * l);
+        for (let c = 0; c < r; c++) {
+            for (let u = 0; u < 3; u++)
+                a[c * l + u] = Math.round(o[c * 3 + u] * 1e3);
+            i && (a[c * l + 3] = 1e3);
         }
-        return s;
+        return a;
     }
     /**
      * Returns an array of splat centers, transformed as appropriate, optionally padded.
-     * @param {number} padFour Enforce alignement of 4 by inserting a 1 after every 3 values
+     * @param {number} start The index at which to start retrieving data
+     * @param {number} end The index at which to stop retrieving data
+     * @param {boolean} padFour Enforce alignment of 4 by inserting a 1 after every 3 values
      * @return {Float32Array}
      */
-    getFloatCenters(t) {
-        const n = this.getSplatCount(),
-            r = new Float32Array(n * 3);
-        if (this.fillSplatDataArrays(null, r, null), !t)
-            return r;
-        let s = new Float32Array(n * 4);
-        for (let a = 0; a < n; a++) {
-            for (let o = 0; o < 3; o++)
-                s[a * 4 + o] = r[a * 3 + o];
-            s[a * 4 + 3] = 1;
+    getFloatCenters(t, n, i = !1) {
+        const r = n - t + 1,
+            o = new Float32Array(r * 3);
+        if (this.fillSplatDataArrays(null, o, null, null, void 0, void 0, void 0, t), !i)
+            return o;
+        let a = new Float32Array(r * 4);
+        for (let l = 0; l < r; l++) {
+            for (let c = 0; c < 3; c++)
+                a[l * 4 + c] = o[l * 3 + c];
+            a[l * 4 + 3] = 1;
         }
-        return s;
+        return a;
     }
     /**
      * Store the transform of the scene at 'sceneIndex' in 'outTransform'.
      * @param {number} sceneIndex Index of the desired scene
      * @param {THREE.Matrix4} outTransform Instance of THREE.Matrix4 in which to store the scene's transform
      */
     getSceneTransform(t, n) {
-        const r = this.getScene(t);
-        r.updateTransform(), n.copy(r.transform);
+        const i = this.getScene(t);
+        i.updateTransform(), n.copy(i.transform);
     }
     /**
      * Get the scene at 'sceneIndex'.
      * @param {number} sceneIndex Index of the desired scene
      * @return {SplatScene}
      */
     getScene(t) {
@@ -20263,2312 +22868,2754 @@
         return this.getScene(this.globalSplatIndexToSceneIndexMap[t]).transform;
     }
     getSplatLocalIndex(t) {
         return this.globalSplatIndexToLocalSplatIndexMap[t];
     }
     static getIntegerMatrixArray(t) {
         const n = t.elements,
-            r = [];
-        for (let s = 0; s < 16; s++)
-            r[s] = Math.round(n[s] * 1e3);
-        return r;
-    }
-}
-var E_ = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHOQMRX193YXNtX2NhbGxfY3RvcnMAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgrHEAMDAAELuxAFAXwDewJ/A30CfiALIAprIQwCQCAOBEAgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIA4gBSAOSBshDiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAgsgDwRAQfj///8HIQ5BiICAgHghDSALIAxNDQJBfyEPIAwhAgNAIA8gByAAIAJBAnQiFGooAgAiFUECdGooAgAiCkcEQAJ+IAX9CQIIIAggCkEGdGoiD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gH95AEgBf0JAjggD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gH95AEiEf0fArv9FCAR/R8Du/0iAf0MAAAAAABAj0AAAAAAAECPQCIS/fIBIhP9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGQJ+IBP9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiETAn4gEf0fALv9FCAR/R8Bu/0iASAS/fIBIhH9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGiATIBn9HgEhEgJ+IBH9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiAa/R4BIBL9DQABAgMICQoLEBESExgZGhshEiAKIQ8LIAMgFGogASAVQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIBH9GwNqIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAILAn8gBSoCGLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEKAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQ5BiICAgHghDSALIAxNDQEgAv0RIAr9HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIA4gAiAOSBshDiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAQsgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQEgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAFBAWoiASALRw0ACwwBCwJAIA9FBEAgCyAMSw0BQYiAgIB4IQ1B+P///wchDgwCC0H4////ByEOQYiAgIB4IQ0gCyAMTQ0BQX8hDyAMIQIDQCAPIAcgACACQQJ0IhRqKAIAQQJ0IhVqKAIAIgpHBEAgBf0JAgggCCAKQQZ0aiIP/QkCACAPKgIQ/SABIA8qAiD9IAIgDyoCMP0gA/3mASAF/QkCGCAP/QkCBCAPKgIU/SABIA8qAiT9IAIgDyoCNP0gA/3mAf3kASAF/QkCKCAP/QkCCCAPKgIY/SABIA8qAij9IAIgDyoCOP0gA/3mAf3kASAF/QkCOCAP/QkCDCAPKgIc/SABIA8qAiz9IAIgDyoCPP0gA/3mAf3kASERIAohDwsgAyAUagJ/IBEgASAVQQJ0IgpqKQIA/RL95gEiEv0fACAS/R8BkiARIBH9DQgJCgsMDQ4PAAAAAAAAAAAgASAKQQhyaikCAP0S/eYBIhL9HwCSIBL9HwGSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAELIAUqAighFiAFKgIYIRcgBSoCCCEYQfj///8HIQ5BiICAgHghDSAMIQUDQAJ/IBggASAAIAVBAnQiB2ooAgBBBHRqIgIqAgCUIBcgAioCBJSSIBYgAioCCJSSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQogAyAHaiAKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAVBAWoiBSALRw0ACwsgCyAMSwRAIAlBAWuzIA2yIA6yk5UhFiAMIQ0DQAJ/IBYgAyANQQJ0aiIBKAIAIA5rspQiF4tDAAAAT10EQCAXqAwBC0GAgICAeAshCiABIAo2AgAgBCAKQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhDgNAIAQgDkECdGoiASABKAIAIA1qIg02AgAgDkEBaiIOIAlHDQALCyAMQQBKBEAgDCEOA0AgBiAOQQFrIgFBAnQiAmogACACaigCADYCACAOQQFKIQIgASEOIAINAAsLIAsgDEoEQCALIQ4DQCAGIAsgBCADIA5BAWsiDkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgDCAOSA0ACwsLBABBAAs=";
-
-function b_(i) {
-    let e, t, n, r, s, a, o, l, c, u, f, h, p, g, v, m, d;
-
-    function M(_, A, R, E, b, I, W) {
-        const S = performance.now();
-        if (!n && (new Uint32Array(t, o, b.byteLength / d.BytesPerInt).set(b), new Float32Array(t, u, W.byteLength / d.BytesPerFloat).set(W), E)) {
-            let O;
-            r ? O = new Int32Array(
+            i = [];
+        for (let r = 0; r < 16; r++)
+            i[r] = Math.round(n[r] * 1e3);
+        return i;
+    }
+}
+var R_ = "AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEbA2AAAGAQf39/f39/f39/f39/f39/fwBgAAF/AhIBA2VudgZtZW1vcnkCAwCAgAQDBAMAAQIHOQMRX193YXNtX2NhbGxfY3RvcnMAAAtzb3J0SW5kZXhlcwABE2Vtc2NyaXB0ZW5fdGxzX2luaXQAAgrHEAMDAAELuxAFAXwDewJ/A30CfiALIAprIQwCQCAOBEAgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQIgDCEBA0AgAyABQQJ0IgVqIAIgACAFaigCAEECdGooAgAiBTYCACAFIA4gBSAOSBshDiAFIA0gBSANShshDSABQQFqIgEgC0cNAAsMAgsgDwRAQfj///8HIQ5BiICAgHghDSALIAxNDQJBfyEPIAwhAgNAIA8gByAAIAJBAnQiFGooAgAiFUECdGooAgAiCkcEQAJ+IAX9CQIIIAggCkEGdGoiD/0JAgAgDyoCEP0gASAPKgIg/SACIA8qAjD9IAP95gEgBf0JAhggD/0JAgQgDyoCFP0gASAPKgIk/SACIA8qAjT9IAP95gH95AEgBf0JAiggD/0JAgggDyoCGP0gASAPKgIo/SACIA8qAjj9IAP95gH95AEgBf0JAjggD/0JAgwgDyoCHP0gASAPKgIs/SACIA8qAjz9IAP95gH95AEiEf0fArv9FCAR/R8Du/0iAf0MAAAAAABAj0AAAAAAAECPQCIS/fIBIhP9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGQJ+IBP9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiETAn4gEf0fALv9FCAR/R8Bu/0iASAS/fIBIhH9IQEiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwshGiATIBn9HgEhEgJ+IBH9IQAiEJlEAAAAAAAA4ENjBEAgELAMAQtCgICAgICAgICAfwv9EiAa/R4BIBL9DQABAgMICQoLEBESExgZGhshEiAKIQ8LIAMgFGogASAVQQR0av0AAAAgEv21ASIR/RsAIBH9GwFqIBH9GwJqIBH9GwNqIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAILAn8gBSoCGLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEKAn8gBSoCCLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyECAn8gBSoCKLtEAAAAAABAj0CiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEFQfj///8HIQ5BiICAgHghDSALIAxNDQEgAv0RIAr9HAEgBf0cAiESIAwhBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAS/bUBIhH9GwAgEf0bAWogEf0bAmoiAjYCACACIA4gAiAOSBshDiACIA0gAiANShshDSAFQQFqIgUgC0cNAAsMAQsgDQRAQfj///8HIQ5BiICAgHghDSALIAxNDQEgDCEBA0AgAyABQQJ0IgVqAn8gAiAAIAVqKAIAQQJ0aioCALtEAAAAAAAAsECiIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyIKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAFBAWoiASALRw0ACwwBCwJAIA9FBEAgCyAMSw0BQYiAgIB4IQ1B+P///wchDgwCC0H4////ByEOQYiAgIB4IQ0gCyAMTQ0BQX8hDyAMIQIDQCAPIAcgACACQQJ0IhRqKAIAQQJ0IhVqKAIAIgpHBEAgBf0JAgggCCAKQQZ0aiIP/QkCACAPKgIQ/SABIA8qAiD9IAIgDyoCMP0gA/3mASAF/QkCGCAP/QkCBCAPKgIU/SABIA8qAiT9IAIgDyoCNP0gA/3mAf3kASAF/QkCKCAP/QkCCCAPKgIY/SABIA8qAij9IAIgDyoCOP0gA/3mAf3kASAF/QkCOCAP/QkCDCAPKgIc/SABIA8qAiz9IAIgDyoCPP0gA/3mAf3kASERIAohDwsgAyAUagJ/IBEgASAVQQJ0IgpqKQIA/RL95gEiEv0fACAS/R8BkiARIBH9DQgJCgsMDQ4PAAAAAAAAAAAgASAKQQhyaikCAP0S/eYBIhL9HwCSIBL9HwGSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIgo2AgAgCiAOIAogDkgbIQ4gCiANIAogDUobIQ0gAkEBaiICIAtHDQALDAELIAUqAighFiAFKgIYIRcgBSoCCCEYQfj///8HIQ5BiICAgHghDSAMIQUDQAJ/IBggASAAIAVBAnQiB2ooAgBBBHRqIgIqAgCUIBcgAioCBJSSIBYgAioCCJSSu0QAAAAAAACwQKIiEJlEAAAAAAAA4EFjBEAgEKoMAQtBgICAgHgLIQogAyAHaiAKNgIAIAogDiAKIA5IGyEOIAogDSAKIA1KGyENIAVBAWoiBSALRw0ACwsgCyAMSwRAIAlBAWuzIA2yIA6yk5UhFiAMIQ0DQAJ/IBYgAyANQQJ0aiIBKAIAIA5rspQiF4tDAAAAT10EQCAXqAwBC0GAgICAeAshCiABIAo2AgAgBCAKQQJ0aiIBIAEoAgBBAWo2AgAgDUEBaiINIAtHDQALCyAJQQJPBEAgBCgCACENQQEhDgNAIAQgDkECdGoiASABKAIAIA1qIg02AgAgDkEBaiIOIAlHDQALCyAMQQBKBEAgDCEOA0AgBiAOQQFrIgFBAnQiAmogACACaigCADYCACAOQQFKIQIgASEOIAINAAsLIAsgDEoEQCALIQ4DQCAGIAsgBCADIA5BAWsiDkECdCIBaigCAEECdGoiAigCACIFa0ECdGogACABaigCADYCACACIAVBAWs2AgAgDCAOSA0ACwsLBABBAAs=";
+
+function P_(s) {
+    let e, t, n, i, r, o, a, l, c, u, d, f, h, g, _, m, p, v;
+
+    function S(y, b, E, T, L, B, x) {
+        const A = performance.now();
+        if (!n && (new Uint32Array(t, a, L.byteLength / v.BytesPerInt).set(L), new Float32Array(t, u, x.byteLength / v.BytesPerFloat).set(x), T)) {
+            let z;
+            i ? z = new Int32Array(
                 t,
-                f,
-                I.byteLength / d.BytesPerInt
-            ) : O = new Float32Array(
+                d,
+                B.byteLength / v.BytesPerInt
+            ) : z = new Float32Array(
                 t,
-                f,
-                I.byteLength / d.BytesPerFloat
-            ), O.set(I);
+                d,
+                B.byteLength / v.BytesPerFloat
+            ), z.set(B);
         }
-        m || (m = new Uint32Array(d.DepthMapRange)), new Float32Array(t, v, 16).set(R), new Uint32Array(t, p, d.DepthMapRange).set(m), e.exports.sortIndexes(
-            o,
+        m || (m = new Uint32Array(v.DepthMapRange)), new Float32Array(t, _, 16).set(E), new Uint32Array(t, h, v.DepthMapRange).set(m), e.exports.sortIndexes(
+            a,
             g,
+            d,
             f,
             h,
-            p,
-            v,
+            _,
             l,
             c,
             u,
-            d.DepthMapRange,
-            _,
-            A,
-            a,
-            E,
-            r,
-            s
+            v.DepthMapRange,
+            y,
+            b,
+            o,
+            T,
+            i,
+            r
         );
-        const T = {
-                sortDone: !0,
-                splatSortCount: _,
-                splatRenderCount: A,
-                sortTime: 0
-            },
-            Y = [];
+        const U = {
+            sortDone: !0,
+            splatSortCount: y,
+            splatRenderCount: b,
+            sortTime: 0
+        };
         if (!n) {
-            const L = new Uint32Array(t, l, A),
-                N = new Uint32Array(A);
-            N.set(L), T.sortedIndexes = N.buffer, Y.push(N.buffer);
-        }
-        const K = performance.now();
-        T.sortTime = K - S, i.postMessage(T, Y);
-    }
-    i.onmessage = (_) => {
-        if (_.data.centers)
-            centers = _.data.centers, transformIndexes = _.data.transformIndexes, r ? new Int32Array(t, g, a * 4).set(new Int32Array(centers)) : new Float32Array(t, g, a * 4).set(new Float32Array(centers)), s && new Uint32Array(t, c, a).set(new Uint32Array(transformIndexes)), i.postMessage({
-                sortSetupComplete: !0
+            const P = new Uint32Array(t, l, b);
+            (!p || p.length < b) && (p = new Uint32Array(b)), p.set(P), U.sortedIndexes = p;
+        }
+        const N = performance.now();
+        U.sortTime = N - A, s.postMessage(U);
+    }
+    s.onmessage = (y) => {
+        if (y.data.centers)
+            centers = y.data.centers, transformIndexes = y.data.transformIndexes, i ? new Int32Array(
+                t,
+                g + y.data.range.from * v.BytesPerInt * 4,
+                y.data.range.count * 4
+            ).set(new Int32Array(centers)) : new Float32Array(
+                t,
+                g + y.data.range.from * v.BytesPerFloat * 4,
+                y.data.range.count * 4
+            ).set(new Float32Array(centers)), r && new Uint32Array(
+                t,
+                c + y.data.range.from * 4,
+                y.data.range.count
+            ).set(new Uint32Array(transformIndexes)), s.postMessage({
+                centerDataSet: !0
             });
-        else if (_.data.sort) {
-            const A = _.data.sort.splatRenderCount || 0,
-                R = _.data.sort.splatSortCount || 0,
-                E = _.data.sort.usePrecomputedDistances;
-            let b, I, W;
-            n || (b = _.data.sort.indexesToSort, W = _.data.sort.transforms, E && (I = _.data.sort.precomputedDistances)), M(
-                R,
-                A,
-                _.data.sort.modelViewProj,
+        else if (y.data.sort) {
+            const b = y.data.sort.splatRenderCount || 0,
+                E = y.data.sort.splatSortCount || 0,
+                T = y.data.sort.usePrecomputedDistances;
+            let L, B, x;
+            n || (L = y.data.sort.indexesToSort, x = y.data.sort.transforms, T && (B = y.data.sort.precomputedDistances)), S(
                 E,
                 b,
-                I,
-                W
+                y.data.sort.modelViewProj,
+                T,
+                L,
+                B,
+                x
             );
-        } else if (_.data.init) {
-            d = _.data.init.Constants, a = _.data.init.splatCount, n = _.data.init.useSharedMemory, r = _.data.init.integerBasedSort, s = _.data.init.dynamicMode;
-            const A = r ? d.BytesPerInt * 4 : d.BytesPerFloat * 4,
-                R = new Uint8Array(_.data.init.sorterWasmBytes),
-                E = 16 * d.BytesPerFloat,
-                b = a * d.BytesPerInt,
-                I = a * A,
-                W = E,
-                S = r ? a * d.BytesPerInt : a * d.BytesPerFloat,
-                T = a * d.BytesPerInt,
-                Y = a * d.BytesPerInt,
-                K = d.DepthMapRange * d.BytesPerInt * 2,
-                L = s ? a * d.BytesPerInt : 0,
-                N = s ? d.MaxScenes * E : 0,
-                O = d.MemoryPageSize * 32,
-                B = b + I + W + S + T + K + Y + L + N + O,
-                j = Math.floor(B / d.MemoryPageSize) + 1,
-                q = {
+        } else if (y.data.init) {
+            v = y.data.init.Constants, o = y.data.init.splatCount, n = y.data.init.useSharedMemory, i = y.data.init.integerBasedSort, r = y.data.init.dynamicMode;
+            const b = i ? v.BytesPerInt * 4 : v.BytesPerFloat * 4,
+                E = new Uint8Array(y.data.init.sorterWasmBytes),
+                T = 16 * v.BytesPerFloat,
+                L = o * v.BytesPerInt,
+                B = o * b,
+                x = T,
+                A = i ? o * v.BytesPerInt : o * v.BytesPerFloat,
+                U = o * v.BytesPerInt,
+                N = o * v.BytesPerInt,
+                P = v.DepthMapRange * v.BytesPerInt * 2,
+                I = r ? o * v.BytesPerInt : 0,
+                z = r ? v.MaxScenes * T : 0,
+                K = v.MemoryPageSize * 32,
+                G = L + B + x + A + U + P + N + I + z + K,
+                q = Math.floor(G / v.MemoryPageSize) + 1,
+                Q = {
                     module: {},
                     env: {
                         memory: new WebAssembly.Memory({
-                            initial: j * 2,
-                            maximum: j * 4,
+                            initial: q * 2,
+                            maximum: q * 4,
                             shared: !0
                         })
                     }
                 };
-            WebAssembly.compile(R).then((J) => WebAssembly.instantiate(J, q)).then((J) => {
-                e = J, o = 0, g = o + b, v = g + I, f = v + W, h = f + S, p = h + T, l = p + K, c = l + Y, u = c + L, t = q.env.memory.buffer, n ? i.postMessage({
+            WebAssembly.compile(E).then((te) => WebAssembly.instantiate(te, Q)).then((te) => {
+                e = te, a = 0, g = a + L, _ = g + B, d = _ + x, f = d + A, h = f + U, l = h + P, c = l + N, u = c + I, t = Q.env.memory.buffer, n ? s.postMessage({
                     sortSetupPhase1Complete: !0,
                     indexesToSortBuffer: t,
-                    indexesToSortOffset: o,
+                    indexesToSortOffset: a,
                     sortedIndexesBuffer: t,
                     sortedIndexesOffset: l,
                     precomputedDistancesBuffer: t,
-                    precomputedDistancesOffset: f,
+                    precomputedDistancesOffset: d,
                     transformsBuffer: t,
                     transformsOffset: u
-                }) : i.postMessage({
+                }) : s.postMessage({
                     sortSetupPhase1Complete: !0
                 });
             });
         }
     };
 }
 
-function T_(i, e, t, n) {
-    const r = new Worker(
+function D_(s, e, t, n) {
+    const i = new Worker(
             URL.createObjectURL(
-                new Blob(["(", b_.toString(), ")(self)"], {
+                new Blob(["(", P_.toString(), ")(self)"], {
                     type: "application/javascript"
                 })
             )
         ),
-        s = atob(E_),
-        a = new Uint8Array(s.length);
-    for (let o = 0; o < s.length; o++)
-        a[o] = s.charCodeAt(o);
-    return r.postMessage({
+        r = atob(R_),
+        o = new Uint8Array(r.length);
+    for (let a = 0; a < r.length; a++)
+        o[a] = r.charCodeAt(a);
+    return i.postMessage({
         init: {
-            sorterWasmBytes: a.buffer,
-            splatCount: i,
+            sorterWasmBytes: o.buffer,
+            splatCount: s,
             useSharedMemory: e,
             integerBasedSort: t,
             dynamicMode: n,
             // Super hacky
             Constants: {
-                BytesPerFloat: mt.BytesPerFloat,
-                BytesPerInt: mt.BytesPerInt,
-                DepthMapRange: mt.DepthMapRange,
-                MemoryPageSize: mt.MemoryPageSize,
-                MaxScenes: mt.MaxScenes
+                BytesPerFloat: rt.BytesPerFloat,
+                BytesPerInt: rt.BytesPerInt,
+                DepthMapRange: rt.DepthMapRange,
+                MemoryPageSize: rt.MemoryPageSize,
+                MaxScenes: rt.MaxScenes
             }
         }
-    }), r;
+    }), i;
 }
-const kr = {
+const qi = {
     None: 0,
     VR: 1,
     AR: 2
 };
-class qi {
+class fs {
     static createButton(e) {
         const t = document.createElement("button");
 
         function n() {
             let l = null;
-            async function c(h) {
-                h.addEventListener("end", u), await e.xr.setSession(h), t.textContent = "EXIT VR", l = h;
+            async function c(f) {
+                f.addEventListener("end", u), await e.xr.setSession(f), t.textContent = "EXIT VR", l = f;
             }
 
             function u() {
                 l.removeEventListener("end", u), t.textContent = "ENTER VR", l = null;
             }
             t.style.display = "", t.style.cursor = "pointer", t.style.left = "calc(50% - 50px)", t.style.width = "100px", t.textContent = "ENTER VR";
-            const f = {
+            const d = {
                 optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"]
             };
             t.onmouseenter = function() {
                 t.style.opacity = "1.0";
             }, t.onmouseleave = function() {
                 t.style.opacity = "0.5";
             }, t.onclick = function() {
-                l === null ? navigator.xr.requestSession("immersive-vr", f).then(c) : (l.end(), navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", f).then(c).catch((h) => {
-                    console.warn(h);
+                l === null ? navigator.xr.requestSession("immersive-vr", d).then(c) : (l.end(), navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", d).then(c).catch((f) => {
+                    console.warn(f);
                 }));
-            }, navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", f).then(c).catch((h) => {
-                console.warn(h);
+            }, navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-vr", d).then(c).catch((f) => {
+                console.warn(f);
             });
         }
 
-        function r() {
+        function i() {
             t.style.display = "", t.style.cursor = "auto", t.style.left = "calc(50% - 75px)", t.style.width = "150px", t.onmouseenter = null, t.onmouseleave = null, t.onclick = null;
         }
 
-        function s() {
-            r(), t.textContent = "VR NOT SUPPORTED";
+        function r() {
+            i(), t.textContent = "VR NOT SUPPORTED";
         }
 
-        function a(l) {
-            r(), console.warn("Exception when trying to call xr.isSessionSupported", l), t.textContent = "VR NOT ALLOWED";
+        function o(l) {
+            i(), console.warn("Exception when trying to call xr.isSessionSupported", l), t.textContent = "VR NOT ALLOWED";
         }
 
-        function o(l) {
+        function a(l) {
             l.style.position = "absolute", l.style.bottom = "20px", l.style.padding = "12px 6px", l.style.border = "1px solid #fff", l.style.borderRadius = "4px", l.style.background = "rgba(0,0,0,0.1)", l.style.color = "#fff", l.style.font = "normal 13px sans-serif", l.style.textAlign = "center", l.style.opacity = "0.5", l.style.outline = "none", l.style.zIndex = "999";
         }
         if ("xr" in navigator)
-            return t.id = "VRButton", t.style.display = "none", o(t), navigator.xr.isSessionSupported("immersive-vr").then(function(l) {
-                l ? n() : s(), l && qi.xrSessionIsGranted && t.click();
-            }).catch(a), t;
+            return t.id = "VRButton", t.style.display = "none", a(t), navigator.xr.isSessionSupported("immersive-vr").then(function(l) {
+                l ? n() : r(), l && fs.xrSessionIsGranted && t.click();
+            }).catch(o), t;
         {
             const l = document.createElement("a");
-            return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", o(l), l;
+            return window.isSecureContext === !1 ? (l.href = document.location.href.replace(/^http:/, "https:"), l.innerHTML = "WEBXR NEEDS HTTPS") : (l.href = "https://immersiveweb.dev/", l.innerHTML = "WEBXR NOT AVAILABLE"), l.style.left = "calc(50% - 90px)", l.style.width = "180px", l.style.textDecoration = "none", a(l), l;
         }
     }
     static registerSessionGrantedListener() {
         if (typeof navigator < "u" && "xr" in navigator) {
             if (/WebXRViewer\//i.test(navigator.userAgent))
                 return;
             navigator.xr.addEventListener("sessiongranted", () => {
-                qi.xrSessionIsGranted = !0;
+                fs.xrSessionIsGranted = !0;
             });
         }
     }
 }
-qi.xrSessionIsGranted = !1;
-qi.registerSessionGrantedListener();
-class w_ {
+fs.xrSessionIsGranted = !1;
+fs.registerSessionGrantedListener();
+class L_ {
     static createButton(e, t = {}) {
         const n = document.createElement("button");
 
-        function r() {
+        function i() {
             if (t.domOverlay === void 0) {
-                const h = document.createElement("div");
-                h.style.display = "none", document.body.appendChild(h);
-                const p = document.createElementNS("http://www.w3.org/2000/svg", "svg");
-                p.setAttribute("width", 38), p.setAttribute("height", 38), p.style.position = "absolute", p.style.right = "20px", p.style.top = "20px", p.addEventListener("click", function() {
+                const f = document.createElement("div");
+                f.style.display = "none", document.body.appendChild(f);
+                const h = document.createElementNS("http://www.w3.org/2000/svg", "svg");
+                h.setAttribute("width", 38), h.setAttribute("height", 38), h.style.position = "absolute", h.style.right = "20px", h.style.top = "20px", h.addEventListener("click", function() {
                     c.end();
-                }), h.appendChild(p);
+                }), f.appendChild(h);
                 const g = document.createElementNS("http://www.w3.org/2000/svg", "path");
-                g.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), g.setAttribute("stroke", "#fff"), g.setAttribute("stroke-width", 2), p.appendChild(g), t.optionalFeatures === void 0 && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
-                    root: h
+                g.setAttribute("d", "M 12,12 L 28,28 M 28,12 12,28"), g.setAttribute("stroke", "#fff"), g.setAttribute("stroke-width", 2), h.appendChild(g), t.optionalFeatures === void 0 && (t.optionalFeatures = []), t.optionalFeatures.push("dom-overlay"), t.domOverlay = {
+                    root: f
                 };
             }
             let c = null;
-            async function u(h) {
-                h.addEventListener("end", f), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(h), n.textContent = "STOP AR", t.domOverlay.root.style.display = "", c = h;
+            async function u(f) {
+                f.addEventListener("end", d), e.xr.setReferenceSpaceType("local"), await e.xr.setSession(f), n.textContent = "STOP AR", t.domOverlay.root.style.display = "", c = f;
             }
 
-            function f() {
-                c.removeEventListener("end", f), n.textContent = "START AR", t.domOverlay.root.style.display = "none", c = null;
+            function d() {
+                c.removeEventListener("end", d), n.textContent = "START AR", t.domOverlay.root.style.display = "none", c = null;
             }
             n.style.display = "", n.style.cursor = "pointer", n.style.left = "calc(50% - 50px)", n.style.width = "100px", n.textContent = "START AR", n.onmouseenter = function() {
                 n.style.opacity = "1.0";
             }, n.onmouseleave = function() {
                 n.style.opacity = "0.5";
             }, n.onclick = function() {
-                c === null ? navigator.xr.requestSession("immersive-ar", t).then(u) : (c.end(), navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-ar", t).then(u).catch((h) => {
-                    console.warn(h);
+                c === null ? navigator.xr.requestSession("immersive-ar", t).then(u) : (c.end(), navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-ar", t).then(u).catch((f) => {
+                    console.warn(f);
                 }));
-            }, navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-ar", t).then(u).catch((h) => {
-                console.warn(h);
+            }, navigator.xr.offerSession !== void 0 && navigator.xr.offerSession("immersive-ar", t).then(u).catch((f) => {
+                console.warn(f);
             });
         }
 
-        function s() {
+        function r() {
             n.style.display = "", n.style.cursor = "auto", n.style.left = "calc(50% - 75px)", n.style.width = "150px", n.onmouseenter = null, n.onmouseleave = null, n.onclick = null;
         }
 
-        function a() {
-            s(), n.textContent = "AR NOT SUPPORTED";
+        function o() {
+            r(), n.textContent = "AR NOT SUPPORTED";
         }
 
-        function o(c) {
-            s(), console.warn("Exception when trying to call xr.isSessionSupported", c), n.textContent = "AR NOT ALLOWED";
+        function a(c) {
+            r(), console.warn("Exception when trying to call xr.isSessionSupported", c), n.textContent = "AR NOT ALLOWED";
         }
 
         function l(c) {
             c.style.position = "absolute", c.style.bottom = "20px", c.style.padding = "12px 6px", c.style.border = "1px solid #fff", c.style.borderRadius = "4px", c.style.background = "rgba(0,0,0,0.1)", c.style.color = "#fff", c.style.font = "normal 13px sans-serif", c.style.textAlign = "center", c.style.opacity = "0.5", c.style.outline = "none", c.style.zIndex = "999";
         }
         if ("xr" in navigator)
             return n.id = "ARButton", n.style.display = "none", l(n), navigator.xr.isSessionSupported("immersive-ar").then(function(c) {
-                c ? r() : a();
-            }).catch(o), n;
+                c ? i() : o();
+            }).catch(a), n;
         {
             const c = document.createElement("a");
             return window.isSecureContext === !1 ? (c.href = document.location.href.replace(/^http:/, "https:"), c.innerHTML = "WEBXR NEEDS HTTPS") : (c.href = "https://immersiveweb.dev/", c.innerHTML = "WEBXR NOT AVAILABLE"), c.style.left = "calc(50% - 90px)", c.style.width = "180px", c.style.textDecoration = "none", l(c), c;
         }
     }
 }
-const C_ = 50,
-    R_ = 0.75;
-class P_ {
-    constructor(e = {}) {
-        Pe(this, "onKeyDown", function() {
-            const e = new P(),
-                t = new ke(),
-                n = new ke();
-            return function(r) {
-                switch (e.set(0, 0, -1), e.transformDirection(this.camera.matrixWorld), t.makeRotationAxis(e, Math.PI / 128), n.makeRotationAxis(e, -Math.PI / 128), r.code) {
-                    case "ArrowLeft":
-                        this.camera.up.transformDirection(t);
-                        break;
-                    case "ArrowRight":
-                        this.camera.up.transformDirection(n);
-                        break;
-                    case "KeyC":
-                        this.showMeshCursor = !this.showMeshCursor;
-                        break;
-                    case "KeyP":
-                        this.showControlPlane = !this.showControlPlane;
-                        break;
-                    case "KeyI":
-                        this.showInfo = !this.showInfo, this.showInfo ? this.infoPanel.style.display = "block" : this.infoPanel.style.display = "none";
-                        break;
-                }
-            };
-        }());
-        Pe(this, "onMouseUp", function() {
-            const e = new me();
-            return function(t) {
-                e.copy(this.mousePosition).sub(this.mouseDownPosition), Ri() - this.mouseDownTime < 0.5 && e.length() < 2 && this.onMouseClick(t);
-            };
-        }());
-        Pe(this, "checkForFocalPointChange", function() {
-            const e = new me(),
-                t = new P(),
-                n = [];
-            return function() {
-                if (!this.transitioningCameraTarget && (this.getRenderDimensions(e), n.length = 0, this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, e), this.raycaster.intersectSplatMesh(this.splatMesh, n), n.length > 0)) {
-                    const s = n[0].origin;
-                    t.copy(s).sub(this.camera.position), t.length() > R_ && (this.previousCameraTarget.copy(this.controls.target), this.nextCameraTarget.copy(s), this.transitioningCameraTarget = !0, this.transitioningCameraTargetStartTime = Ri());
-                }
-            };
-        }());
-        Pe(this, "updateSplatMesh", function() {
-            const e = new me();
-            return function() {
-                if (!this.splatMesh)
-                    return;
-                this.splatMesh.getSplatCount() > 0 && (this.splatMesh.updateTransforms(), this.getRenderDimensions(e), this.cameraFocalLengthX = this.camera.projectionMatrix.elements[0] * this.devicePixelRatio * e.x * 0.45, this.cameraFocalLengthY = this.camera.projectionMatrix.elements[5] * this.devicePixelRatio * e.y * 0.45, this.splatMesh.updateUniforms(e, this.cameraFocalLengthX, this.cameraFocalLengthY));
-            };
-        }());
-        /**
-         * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer and set up the sorting web worker.
-         * This function will terminate the existing sort worker (if there is one).
-         */
-        Pe(this, "addSplatBuffers", function() {
-            let e, t = 0;
-            return function(n, r = [], s = !0) {
-                this.splatRenderingInitialized = !1, t++;
-                const a = () => new Promise((o) => {
-                    s && (this.loadingSpinner.show(), this.loadingSpinner.setMessage("Processing splats...")), window.setTimeout(() => {
-                        this.disposeSortWorker(), this.addSplatBuffersToMesh(n, r), this.setupSortWorker(this.splatMesh).then(() => {
-                            t--, t === 0 && (s && this.loadingSpinner.hide(), this.splatRenderingInitialized = !0), o();
-                        });
-                    }, 1);
-                });
-                return e ? e = e.then(() => a()) : e = a(), e;
-            };
-        }());
-        Pe(this, "render", function() {
-            return function() {
-                if (!this.initialized || !this.splatRenderingInitialized)
-                    return;
-                const e = (n) => {
-                        for (let r of n.children)
-                            if (r.visible)
-                                return !0;
-                        return !1;
-                    },
-                    t = this.renderer.autoClear;
-                this.renderer.autoClear = !1, e(this.threeScene) && this.renderer.render(this.threeScene, this.camera), this.renderer.render(this.splatMesh, this.camera), this.sceneHelper.getFocusMarkerOpacity() > 0 && this.renderer.render(this.sceneHelper.focusMarker, this.camera), this.showControlPlane && this.renderer.render(this.sceneHelper.controlPlane, this.camera), this.renderer.autoClear = t;
-            };
-        }());
-        Pe(this, "updateFPS", function() {
-            let e = Ri(),
-                t = 0;
-            return function() {
-                const n = Ri();
-                n - e >= 1 ? (this.currentFPS = t, t = 0, e = n) : t++;
-            };
-        }());
-        Pe(this, "updateForRendererSizeChanges", function() {
-            const e = new me(),
-                t = new me();
-            return function() {
-                this.renderer.getSize(t), (t.x !== e.x || t.y !== e.y) && (this.usingExternalCamera || (this.camera.aspect = t.x / t.y, this.camera.updateProjectionMatrix()), e.copy(t));
-            };
-        }());
-        Pe(this, "timingSensitiveUpdates", function() {
-            let e;
-            return function() {
-                const t = Ri();
-                e || (e = t);
-                const n = t - e;
-                this.updateCameraTransition(t), this.updateFocusMarker(n), e = t;
-            };
-        }());
-        Pe(this, "updateCameraTransition", function() {
-            let e = new P(),
-                t = new P(),
-                n = new P();
-            return function(r) {
-                if (this.transitioningCameraTarget) {
-                    t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(), n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();
-                    const s = Math.acos(t.dot(n)),
-                        o = (s / (Math.PI / 3) * 0.65 + 0.3) / s * (r - this.transitioningCameraTargetStartTime);
-                    e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget, o), this.camera.lookAt(e), this.controls.target.copy(e), o >= 1 && (this.transitioningCameraTarget = !1);
-                }
-            };
-        }());
-        Pe(this, "updateFocusMarker", function() {
-            const e = new me();
-            let t = !1;
-            return function(n) {
-                this.getRenderDimensions(e);
-                const r = 10,
-                    s = 2.5;
-                if (this.transitioningCameraTarget) {
-                    this.sceneHelper.setFocusMarkerVisibility(!0);
-                    const a = Math.max(this.sceneHelper.getFocusMarkerOpacity(), 0);
-                    let o = Math.min(a + r * n, 1);
-                    this.sceneHelper.setFocusMarkerOpacity(o), this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e), t = !0;
-                } else {
-                    let a;
-                    if (t ? a = 1 : a = Math.min(this.sceneHelper.getFocusMarkerOpacity(), 1), a > 0) {
-                        this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e);
-                        let o = Math.max(a - s * n, 0);
-                        this.sceneHelper.setFocusMarkerOpacity(o), o === 0 && this.sceneHelper.setFocusMarkerVisibility(!1);
-                    }
-                    t = !1;
-                }
-            };
-        }());
-        Pe(this, "updateMeshCursor", function() {
-            const e = [],
-                t = new me();
-            return function() {
-                this.showMeshCursor ? (this.getRenderDimensions(t), e.length = 0, this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, t), this.raycaster.intersectSplatMesh(this.splatMesh, e), e.length > 0 ? (this.sceneHelper.setMeshCursorVisibility(!0), this.sceneHelper.positionAndOrientMeshCursor(e[0].origin, this.camera)) : this.sceneHelper.setMeshCursorVisibility(!1)) : this.sceneHelper.setMeshCursorVisibility(!1);
-            };
-        }());
-        Pe(this, "updateInfoPanel", function() {
-            const e = new me();
-            return function() {
-                if (!this.showInfo)
-                    return;
-                const t = this.splatMesh.getSplatCount();
-                this.getRenderDimensions(e);
-                const n = this.camera.position,
-                    r = `[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;
-                if (this.infoPanelCells.cameraPosition.innerHTML = r, this.controls) {
-                    const l = this.controls.target,
-                        c = `[${l.x.toFixed(5)}, ${l.y.toFixed(5)}, ${l.z.toFixed(5)}]`;
-                    this.infoPanelCells.cameraLookAt.innerHTML = c;
-                }
-                const s = this.camera.up,
-                    a = `[${s.x.toFixed(5)}, ${s.y.toFixed(5)}, ${s.z.toFixed(5)}]`;
-                if (this.infoPanelCells.cameraUp.innerHTML = a, this.showMeshCursor) {
-                    const l = this.sceneHelper.meshCursor.position,
-                        c = `[${l.x.toFixed(5)}, ${l.y.toFixed(5)}, ${l.z.toFixed(5)}]`;
-                    this.infoPanelCells.cursorPosition.innerHTML = c;
-                } else
-                    this.infoPanelCells.cursorPosition.innerHTML = "N/A";
-                this.infoPanelCells.fps.innerHTML = this.currentFPS, this.infoPanelCells.renderWindow.innerHTML = `${e.x} x ${e.y}`;
-                const o = this.splatRenderCount / t * 100;
-                this.infoPanelCells.renderSplatCount.innerHTML = `${this.splatRenderCount} splats out of ${t} (${o.toFixed(2)}%)`, this.infoPanelCells.sortTime.innerHTML = `${this.lastSortTime.toFixed(3)} ms`;
-            };
-        }());
-        Pe(this, "updateSplatSort", function() {
-            const e = new ke(),
-                t = [],
-                n = new P(0, 0, -1),
-                r = new P(0, 0, -1),
-                s = new P(),
-                a = new P(),
-                o = [];
-            let l = 0;
-            const c = [{
-                angleThreshold: 0.55,
-                sortFractions: [0.125, 0.33333, 0.75]
-            }, {
-                angleThreshold: 0.65,
-                sortFractions: [0.33333, 0.66667]
-            }, {
-                angleThreshold: 0.8,
-                sortFractions: [0.5]
-            }];
-            return async function(u = !1, f = !1) {
-                if (this.sortRunning || !this.initialized || !this.splatRenderingInitialized)
-                    return;
-                let h = 0,
-                    p = 0,
-                    g = !1,
-                    v = !1;
-                if (r.set(0, 0, -1).applyQuaternion(this.camera.quaternion), h = r.dot(n), p = a.copy(this.camera.position).sub(s).length(), !u && !this.splatMesh.dynamicMode && o.length === 0 && l > 0 && (h <= 0.95 && (g = !0), p >= 1 && (v = !0), !g && !v))
-                    return;
-                if (this.sortRunning = !0, this.splatRenderCount = this.gatherSceneNodesForSort(f), this.sortPromise = new Promise((M) => {
-                        this.sortPromiseResolver = M;
-                    }), e.copy(this.camera.matrixWorld).invert(), e.premultiply(this.camera.projectionMatrix), e.multiply(this.splatMesh.matrixWorld), this.gpuAcceleratedSort && (o.length <= 1 || o.length % 2 === 0) && await this.splatMesh.computeDistancesOnGPU(e, this.sortWorkerPrecomputedDistances), this.splatMesh.dynamicMode)
-                    o.push(this.splatRenderCount);
-                else if (o.length === 0) {
-                    for (let M of c)
-                        if (h < M.angleThreshold) {
-                            for (let _ of M.sortFractions)
-                                o.push(Math.floor(this.splatRenderCount * _));
+const Da = {
+        Always: 0,
+        OnChange: 1,
+        Never: 2
+    },
+    F_ = 50,
+    I_ = 0.75,
+    U_ = 15e5,
+    B_ = 10,
+    O_ = 2.5,
+    N_ = 60,
+    Kn = class Kn {
+        constructor(e = {}) {
+            le(this, "onKeyDown", function() {
+                const e = new D(),
+                    t = new Ge(),
+                    n = new Ge();
+                return function(i) {
+                    switch (e.set(0, 0, -1), e.transformDirection(this.camera.matrixWorld), t.makeRotationAxis(e, Math.PI / 128), n.makeRotationAxis(e, -Math.PI / 128), i.code) {
+                        case "KeyG":
+                            this.focalAdjustment += 0.02, this.forceRenderNextFrame();
+                            break;
+                        case "KeyF":
+                            this.focalAdjustment -= 0.02, this.forceRenderNextFrame();
+                            break;
+                        case "ArrowLeft":
+                            this.camera.up.transformDirection(t);
+                            break;
+                        case "ArrowRight":
+                            this.camera.up.transformDirection(n);
+                            break;
+                        case "KeyC":
+                            this.showMeshCursor = !this.showMeshCursor;
+                            break;
+                        case "KeyU":
+                            this.showControlPlane = !this.showControlPlane;
+                            break;
+                        case "KeyI":
+                            this.showInfo = !this.showInfo, this.showInfo ? this.infoPanel.show() : this.infoPanel.hide();
                             break;
+                        case "KeyO":
+                            this.usingExternalCamera || this.setOrthographicMode(!this.camera.isOrthographicCamera);
+                            break;
+                        case "KeyP":
+                            this.usingExternalCamera || this.splatMesh.setPointCloudModeEnabled(!this.splatMesh.getPointCloudModeEnabled());
+                            break;
+                        case "Equal":
+                            this.usingExternalCamera || this.splatMesh.setSplatScale(this.splatMesh.getSplatScale() + 0.05);
+                            break;
+                        case "Minus":
+                            this.usingExternalCamera || this.splatMesh.setSplatScale(Math.max(this.splatMesh.getSplatScale() - 0.05, 0));
+                            break;
+                    }
+                };
+            }());
+            le(this, "onMouseUp", function() {
+                const e = new Ee();
+                return function(t) {
+                    e.copy(this.mousePosition).sub(this.mouseDownPosition), Wi() - this.mouseDownTime < 0.5 && e.length() < 2 && this.onMouseClick(t);
+                };
+            }());
+            le(this, "checkForFocalPointChange", function() {
+                const e = new Ee(),
+                    t = new D(),
+                    n = [];
+                return function() {
+                    if (!this.transitioningCameraTarget && (this.getRenderDimensions(e), n.length = 0, this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, e), this.raycaster.intersectSplatMesh(this.splatMesh, n), n.length > 0)) {
+                        const r = n[0].origin;
+                        t.copy(r).sub(this.camera.position), t.length() > I_ && (this.previousCameraTarget.copy(this.controls.target), this.nextCameraTarget.copy(r), this.transitioningCameraTarget = !0, this.transitioningCameraTargetStartTime = Wi());
+                    }
+                };
+            }());
+            le(this, "updateSplatMesh", function() {
+                const e = new Ee();
+                return function() {
+                    if (!this.splatMesh)
+                        return;
+                    if (this.splatMesh.getSplatCount() > 0) {
+                        this.splatMesh.updateTransforms(), this.getRenderDimensions(e);
+                        const n = this.camera.projectionMatrix.elements[0] * 0.5 * this.devicePixelRatio * e.x,
+                            i = this.camera.projectionMatrix.elements[5] * 0.5 * this.devicePixelRatio * e.y,
+                            r = this.camera.isOrthographicCamera ? 1 / this.devicePixelRatio : 1,
+                            o = this.focalAdjustment * r,
+                            a = 1 / o;
+                        this.adjustForWebXRStereo(e), this.splatMesh.updateUniforms(
+                            e,
+                            n * o,
+                            i * o,
+                            this.camera.isOrthographicCamera,
+                            this.camera.zoom || 1,
+                            a
+                        );
+                    }
+                };
+            }());
+            /**
+             * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer and set up the sorting web worker.
+             * This function will terminate the existing sort worker (if there is one).
+             */
+            le(this, "addSplatBuffers", /* @__PURE__ */ function() {
+                return function(e, t = [], n = !0, i = !0, r = !0) {
+                    if (this.isDisposingOrDisposed())
+                        return Promise.resolve();
+                    this.splatRenderReady = !1;
+                    let o = null;
+                    const a = (l) => {
+                        this.isDisposingOrDisposed() || (o !== null && (this.loadingSpinner.removeTask(o), o = null), !this.gpuAcceleratedSort && this.sortWorker && this.sortWorker.postMessage({
+                            centers: l.centers.buffer,
+                            transformIndexes: l.sceneIndexes.buffer,
+                            range: {
+                                from: l.from,
+                                to: l.to,
+                                count: l.count
+                            }
+                        }), this.splatRenderReady = !0, this.sortNeededForSceneChange = !0);
+                    };
+                    return new Promise((l) => {
+                        i && (o = this.loadingSpinner.addTask("Processing splats...")), Ln(() => {
+                            if (this.isDisposingOrDisposed())
+                                l();
+                            else {
+                                const c = this.addSplatBuffersToMesh(
+                                        e,
+                                        t,
+                                        n,
+                                        r
+                                    ),
+                                    u = this.splatMesh.getMaxSplatCount();
+                                this.sortWorker && this.sortWorker.maxSplatCount !== u && this.disposeSortWorker(), (!this.sortWorker && u > 0 ? this.setupSortWorker(this.splatMesh) : Promise.resolve()).then(() => {
+                                    a(c), l();
+                                });
+                            }
+                        }, !0);
+                    });
+                };
+            }());
+            le(this, "shouldRender", function() {
+                let e = 0;
+                const t = new D(),
+                    n = new St(),
+                    i = 1e-4;
+                return function() {
+                    let r = !1,
+                        o = !1;
+                    if (this.camera) {
+                        const a = this.camera.position,
+                            l = this.camera.quaternion;
+                        o = Math.abs(a.x - t.x) > i || Math.abs(a.y - t.y) > i || Math.abs(a.z - t.z) > i || Math.abs(l.x - n.x) > i || Math.abs(l.y - n.y) > i || Math.abs(l.z - n.z) > i || Math.abs(l.w - n.w) > i;
+                    }
+                    return r = this.renderMode !== Da.Never && (e === 0 || this.splatMesh.visibleRegionChanging || o || this.renderMode === Da.Always || this.dynamicMode === !0 || this.renderNextFrame), this.camera && (t.copy(this.camera.position), n.copy(this.camera.quaternion)), e++, r;
+                };
+            }());
+            le(this, "render", /* @__PURE__ */ function() {
+                return function() {
+                    if (!this.initialized || !this.splatRenderReady)
+                        return;
+                    const e = (n) => {
+                            for (let i of n.children)
+                                if (i.visible)
+                                    return !0;
+                            return !1;
+                        },
+                        t = this.renderer.autoClear;
+                    e(this.threeScene) && (this.renderer.render(this.threeScene, this.camera), this.renderer.autoClear = !1), this.renderer.render(this.splatMesh, this.camera), this.renderer.autoClear = !1, this.sceneHelper.getFocusMarkerOpacity() > 0 && this.renderer.render(this.sceneHelper.focusMarker, this.camera), this.showControlPlane && this.renderer.render(this.sceneHelper.controlPlane, this.camera), this.renderer.autoClear = t;
+                };
+            }());
+            le(this, "updateFPS", function() {
+                let e = Wi(),
+                    t = 0;
+                return function() {
+                    if (this.consecutiveRenderFrames > N_) {
+                        const n = Wi();
+                        n - e >= 1 ? (this.currentFPS = t, t = 0, e = n) : t++;
+                    } else
+                        this.currentFPS = null;
+                };
+            }());
+            le(this, "updateForRendererSizeChanges", function() {
+                const e = new Ee(),
+                    t = new Ee();
+                let n;
+                return function() {
+                    this.usingExternalCamera || (this.renderer.getSize(t), (n === void 0 || n !== this.camera.isOrthographicCamera || t.x !== e.x || t.y !== e.y) && (this.camera.isOrthographicCamera ? (this.camera.left = -t.x / 2, this.camera.right = t.x / 2, this.camera.top = t.y / 2, this.camera.bottom = -t.y / 2) : this.camera.aspect = t.x / t.y, this.camera.updateProjectionMatrix(), e.copy(t), n = this.camera.isOrthographicCamera));
+                };
+            }());
+            le(this, "timingSensitiveUpdates", /* @__PURE__ */ function() {
+                let e;
+                return function() {
+                    const t = Wi();
+                    e || (e = t);
+                    const n = t - e;
+                    this.updateCameraTransition(t), this.updateFocusMarker(n), e = t;
+                };
+            }());
+            le(this, "updateCameraTransition", function() {
+                let e = new D(),
+                    t = new D(),
+                    n = new D();
+                return function(i) {
+                    if (this.transitioningCameraTarget) {
+                        t.copy(this.previousCameraTarget).sub(this.camera.position).normalize(), n.copy(this.nextCameraTarget).sub(this.camera.position).normalize();
+                        const r = Math.acos(t.dot(n)),
+                            a = (r / (Math.PI / 3) * 0.65 + 0.3) / r * (i - this.transitioningCameraTargetStartTime);
+                        e.copy(this.previousCameraTarget).lerp(this.nextCameraTarget, a), this.camera.lookAt(e), this.controls.target.copy(e), a >= 1 && (this.transitioningCameraTarget = !1);
+                    }
+                };
+            }());
+            le(this, "updateFocusMarker", function() {
+                const e = new Ee();
+                let t = !1;
+                return function(n) {
+                    if (this.getRenderDimensions(e), this.transitioningCameraTarget) {
+                        this.sceneHelper.setFocusMarkerVisibility(!0);
+                        const i = Math.max(this.sceneHelper.getFocusMarkerOpacity(), 0);
+                        let r = Math.min(i + B_ * n, 1);
+                        this.sceneHelper.setFocusMarkerOpacity(r), this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e), t = !0, this.forceRenderNextFrame();
+                    } else {
+                        let i;
+                        if (t ? i = 1 : i = Math.min(this.sceneHelper.getFocusMarkerOpacity(), 1), i > 0) {
+                            this.sceneHelper.updateFocusMarker(this.nextCameraTarget, this.camera, e);
+                            let r = Math.max(i - O_ * n, 0);
+                            this.sceneHelper.setFocusMarkerOpacity(r), r === 0 && this.sceneHelper.setFocusMarkerVisibility(!1);
                         }
-                    o.push(this.splatRenderCount);
-                }
-                const m = Math.min(o.shift(), this.splatRenderCount);
-                t[0] = this.camera.position.x, t[1] = this.camera.position.y, t[2] = this.camera.position.z;
-                const d = {
-                    modelViewProj: e.elements,
-                    cameraPosition: t,
-                    splatRenderCount: this.splatRenderCount,
-                    splatSortCount: m,
-                    usePrecomputedDistances: this.gpuAcceleratedSort
+                        i > 0 && this.forceRenderNextFrame(), t = !1;
+                    }
                 };
-                this.splatMesh.dynamicMode && this.splatMesh.fillTransformsArray(this.sortWorkerTransforms), this.sharedMemoryForWorkers || (d.indexesToSort = this.sortWorkerIndexesToSort, d.transforms = this.sortWorkerTransforms, this.gpuAcceleratedSort && (d.precomputedDistances = this.sortWorkerPrecomputedDistances)), this.sortWorker.postMessage({
-                    sort: d
-                }), o.length === 0 && (s.copy(this.camera.position), n.copy(r)), l++;
-            };
-        }());
-        /**
-         * Determine which splats to render by checking which are inside or close to the view frustum
-         */
-        Pe(this, "gatherSceneNodesForSort", function() {
-            const e = [],
-                t = new P(),
-                n = new P(),
-                r = new P(),
-                s = new ke(),
-                a = new ke(),
-                o = new ke(),
-                l = new P(),
-                c = new P(0, 0, -1),
-                u = new P(),
-                f = (p) => u.copy(p.max).sub(p.min).length(),
-                h = 125;
-            return function(p) {
-                this.getRenderDimensions(l);
-                const g = l.y / 2 / Math.tan(this.camera.fov / 2 * Xl.DEG2RAD),
-                    v = Math.atan(l.x / 2 / g),
-                    m = Math.atan(l.y / 2 / g),
-                    d = Math.cos(v),
-                    M = Math.cos(m),
-                    _ = this.splatMesh.getSplatTree();
-                a.copy(this.camera.matrixWorld).invert(), a.multiply(this.splatMesh.matrixWorld);
-                let A = 0,
-                    R = 0;
-                for (let b = 0; b < _.subTrees.length; b++) {
-                    const I = _.subTrees[b];
-                    s.copy(a), this.splatMesh.dynamicMode && (this.splatMesh.getSceneTransform(b, o), s.multiply(o));
-                    const W = I.nodesWithIndexes.length;
-                    for (let S = 0; S < W; S++) {
-                        const T = I.nodesWithIndexes[S];
-                        r.copy(T.center).applyMatrix4(s);
-                        const Y = r.length();
-                        r.normalize(), t.copy(r).setX(0).normalize(), n.copy(r).setY(0).normalize();
-                        const K = c.dot(n),
-                            L = c.dot(t),
-                            N = f(T),
-                            O = L < M - 0.6,
-                            B = K < d - 0.6;
-                        !p && (B || O || Y > h) && Y > N || (R += T.data.indexes.length, e[A] = T, T.data.distanceToNode = Y, A++);
+            }());
+            le(this, "updateMeshCursor", function() {
+                const e = [],
+                    t = new Ee();
+                return function() {
+                    this.showMeshCursor ? (this.forceRenderNextFrame(), this.getRenderDimensions(t), e.length = 0, this.raycaster.setFromCameraAndScreenPosition(this.camera, this.mousePosition, t), this.raycaster.intersectSplatMesh(this.splatMesh, e), e.length > 0 ? (this.sceneHelper.setMeshCursorVisibility(!0), this.sceneHelper.positionAndOrientMeshCursor(e[0].origin, this.camera)) : this.sceneHelper.setMeshCursorVisibility(!1)) : (this.sceneHelper.getMeschCursorVisibility() && this.forceRenderNextFrame(), this.sceneHelper.setMeshCursorVisibility(!1));
+                };
+            }());
+            le(this, "updateInfoPanel", function() {
+                const e = new Ee();
+                return function() {
+                    if (!this.showInfo)
+                        return;
+                    const t = this.splatMesh.getSplatCount();
+                    this.getRenderDimensions(e);
+                    const n = this.controls ? this.controls.target : null,
+                        i = this.showMeshCursor ? this.sceneHelper.meshCursor.position : null,
+                        r = t > 0 ? this.splatRenderCount / t * 100 : 0;
+                    this.infoPanel.update(
+                        e,
+                        this.camera.position,
+                        n,
+                        this.camera.up,
+                        this.camera.isOrthographicCamera,
+                        i,
+                        this.currentFPS || "N/A",
+                        t,
+                        this.splatRenderCount,
+                        r,
+                        this.lastSortTime,
+                        this.focalAdjustment,
+                        this.splatMesh.getSplatScale(),
+                        this.splatMesh.getPointCloudModeEnabled()
+                    );
+                };
+            }());
+            le(this, "updateSplatSort", function() {
+                const e = new Ge(),
+                    t = [],
+                    n = new D(0, 0, -1),
+                    i = new D(0, 0, -1),
+                    r = new D(),
+                    o = new D(),
+                    a = [],
+                    l = [{
+                        angleThreshold: 0.55,
+                        sortFractions: [0.125, 0.33333, 0.75]
+                    }, {
+                        angleThreshold: 0.65,
+                        sortFractions: [0.33333, 0.66667]
+                    }, {
+                        angleThreshold: 0.8,
+                        sortFractions: [0.5]
+                    }];
+                return async function(c = !1) {
+                    if (this.sortRunning || this.splatMesh.getSplatCount() <= 0)
+                        return;
+                    let u = 0,
+                        d = 0,
+                        f = !1,
+                        h = !1;
+                    if (i.set(0, 0, -1).applyQuaternion(this.camera.quaternion), u = i.dot(n), d = o.copy(this.camera.position).sub(r).length(), !c && !this.sortNeededForSceneChange && !this.splatMesh.dynamicMode && a.length === 0 && (u <= 0.99 && (f = !0), d >= 1 && (h = !0), !f && !h))
+                        return;
+                    this.sortRunning = !0;
+                    const {
+                        splatRenderCount: g,
+                        shouldSortAll: _
+                    } = this.gatherSceneNodesForSort();
+                    this.splatRenderCount = g, e.copy(this.camera.matrixWorld).invert();
+                    const m = this.perspectiveCamera || this.camera;
+                    if (e.premultiply(m.projectionMatrix), e.multiply(this.splatMesh.matrixWorld), this.gpuAcceleratedSort && (a.length <= 1 || a.length % 2 === 0) && await this.splatMesh.computeDistancesOnGPU(e, this.sortWorkerPrecomputedDistances), this.splatMesh.dynamicMode || _)
+                        a.push(this.splatRenderCount);
+                    else if (a.length === 0) {
+                        for (let S of l)
+                            if (u < S.angleThreshold) {
+                                for (let y of S.sortFractions)
+                                    a.push(Math.floor(this.splatRenderCount * y));
+                                break;
+                            }
+                        a.push(this.splatRenderCount);
                     }
-                }
-                e.length = A, e.sort((b, I) => b.data.distanceToNode < I.data.distanceToNode ? -1 : 1);
-                let E = R * mt.BytesPerInt;
-                for (let b = 0; b < A; b++) {
-                    const I = e[b],
-                        W = I.data.indexes.length,
-                        S = W * mt.BytesPerInt;
-                    new Uint32Array(this.sortWorkerIndexesToSort.buffer, E - S, W).set(I.data.indexes), E -= S;
-                }
-                return R;
-            };
-        }());
-        e.cameraUp || (e.cameraUp = [0, 1, 0]), this.cameraUp = new P().fromArray(e.cameraUp), e.initialCameraPosition || (e.initialCameraPosition = [0, 10, 15]), this.initialCameraPosition = new P().fromArray(e.initialCameraPosition), e.initialCameraLookAt || (e.initialCameraLookAt = [0, 0, 0]), this.initialCameraLookAt = new P().fromArray(e.initialCameraLookAt), this.dropInMode = e.dropInMode || !1, (e.selfDrivenMode === void 0 || e.selfDrivenMode === null) && (e.selfDrivenMode = !0), this.selfDrivenMode = e.selfDrivenMode && !this.dropInMode, this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this), e.useBuiltInControls === void 0 && (e.useBuiltInControls = !0), this.useBuiltInControls = e.useBuiltInControls, this.rootElement = e.rootElement, this.ignoreDevicePixelRatio = e.ignoreDevicePixelRatio || !1, this.devicePixelRatio = this.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio, (e.halfPrecisionCovariancesOnGPU === void 0 || e.halfPrecisionCovariancesOnGPU === null) && (e.halfPrecisionCovariancesOnGPU = !0), this.halfPrecisionCovariancesOnGPU = e.halfPrecisionCovariancesOnGPU, this.threeScene = e.threeScene, this.renderer = e.renderer, this.camera = e.camera, this.gpuAcceleratedSort = e.gpuAcceleratedSort, this.gpuAcceleratedSort !== !0 && this.gpuAcceleratedSort !== !1 && (this.isMobile() ? this.gpuAcceleratedSort = !1 : this.gpuAcceleratedSort = !0), (e.integerBasedSort === void 0 || e.integerBasedSort === null) && (e.integerBasedSort = !0), this.integerBasedSort = e.integerBasedSort, (e.sharedMemoryForWorkers === void 0 || e.sharedMemoryForWorkers === null) && (e.sharedMemoryForWorkers = !0), this.sharedMemoryForWorkers = e.sharedMemoryForWorkers;
-        const t = !!e.dynamicScene;
-        this.splatMesh = new kt(
-            t,
-            this.halfPrecisionCovariancesOnGPU,
-            this.devicePixelRatio,
-            this.gpuAcceleratedSort,
-            this.integerBasedSort
-        ), this.webXRMode = e.webXRMode || kr.None, this.controls = null, this.showMeshCursor = !1, this.showControlPlane = !1, this.showInfo = !1, this.sceneHelper = null, this.sortWorker = null, this.sortRunning = !1, this.splatRenderCount = 0, this.sortWorkerIndexesToSort = null, this.sortWorkerSortedIndexes = null, this.sortWorkerPrecomputedDistances = null, this.sortWorkerTransforms = null, this.selfDrivenModeRunning = !1, this.splatRenderingInitialized = !1, this.raycaster = new x_(), this.infoPanel = null, this.infoPanelCells = {}, this.currentFPS = 0, this.lastSortTime = 0, this.previousCameraTarget = new P(), this.nextCameraTarget = new P(), this.mousePosition = new me(), this.mouseDownPosition = new me(), this.mouseDownTime = null, this.resizeObserver = null, this.mouseMoveListener = null, this.mouseDownListener = null, this.mouseUpListener = null, this.keyDownListener = null, this.sortPromise = null, this.sortPromiseResolver = null, this.loadingSpinner = new p_(null, this.rootElement || document.body), this.loadingSpinner.hide(), this.usingExternalCamera = !!(this.dropInMode || this.camera), this.usingExternalRenderer = !!(this.dropInMode || this.renderer), this.initialized = !1, this.dropInMode || this.init();
-    }
-    init() {
-        if (this.initialized)
-            return;
-        this.rootElement || (this.usingExternalRenderer ? this.rootElement = this.renderer.domElement.parentElement || document.body : (this.rootElement = document.createElement("div"), this.rootElement.style.width = "100%", this.rootElement.style.height = "100%", this.rootElement.style.position = "absolute", document.body.appendChild(this.rootElement)));
-        const e = new me();
-        this.getRenderDimensions(e), this.usingExternalCamera || (this.camera = new Ht(C_, e.x / e.y, 0.1, 500), this.camera.position.copy(this.initialCameraPosition), this.camera.up.copy(this.cameraUp).normalize(), this.camera.lookAt(this.initialCameraLookAt)), this.usingExternalRenderer || (this.renderer = new hc({
-            antialias: !1,
-            precision: "highp"
-        }), this.renderer.setPixelRatio(this.devicePixelRatio), this.renderer.autoClear = !0, this.renderer.setClearColor(new Qe(0), 0), this.renderer.setSize(e.x, e.y), this.resizeObserver = new ResizeObserver(() => {
-            this.getRenderDimensions(e), this.renderer.setSize(e.x, e.y);
-        }), this.resizeObserver.observe(this.rootElement), this.rootElement.appendChild(this.renderer.domElement)), this.webXRMode && (this.webXRMode === kr.VR ? this.rootElement.appendChild(qi.createButton(this.renderer)) : this.webXRMode === kr.AR && this.rootElement.appendChild(w_.createButton(this.renderer)), this.renderer.xr.enabled = !0, this.camera.up.copy(this.cameraUp).normalize(), this.camera.lookAt(this.initialCameraLookAt)), this.threeScene = this.threeScene || new r_(), this.sceneHelper = new ar(this.threeScene), this.sceneHelper.setupMeshCursor(), this.sceneHelper.setupFocusMarker(), this.sceneHelper.setupControlPlane(), this.useBuiltInControls && this.webXRMode === kr.None && (this.controls = new d_(this.camera, this.renderer.domElement), this.controls.listenToKeyEvents(window), this.controls.rotateSpeed = 0.5, this.controls.maxPolarAngle = Math.PI * 0.75, this.controls.minPolarAngle = 0.1, this.controls.enableDamping = !0, this.controls.dampingFactor = 0.05, this.controls.target.copy(this.initialCameraLookAt), this.mouseMoveListener = this.onMouseMove.bind(this), this.rootElement.addEventListener("pointermove", this.mouseMoveListener, !1), this.mouseDownListener = this.onMouseDown.bind(this), this.rootElement.addEventListener("pointerdown", this.mouseDownListener, !1), this.mouseUpListener = this.onMouseUp.bind(this), this.rootElement.addEventListener("pointerup", this.mouseUpListener, !1), this.keyDownListener = this.onKeyDown.bind(this), window.addEventListener("keydown", this.keyDownListener, !1)), this.setupInfoPanel(), this.loadingSpinner.setContainer(this.rootElement), this.initialized = !0;
-    }
-    removeEventHandlers() {
-        this.useBuiltInControls && (this.rootElement.removeEventListener("pointermove", this.mouseMoveListener), this.mouseMoveListener = null, this.rootElement.removeEventListener("pointerdown", this.mouseDownListener), this.mouseDownListener = null, this.rootElement.removeEventListener("pointerup", this.mouseUpListener), this.mouseUpListener = null, window.removeEventListener("keydown", this.keyDownListener), this.keyDownListener = null);
-    }
-    onMouseMove(e) {
-        this.mousePosition.set(e.offsetX, e.offsetY);
-    }
-    onMouseDown() {
-        this.mouseDownPosition.copy(this.mousePosition), this.mouseDownTime = Ri();
-    }
-    onMouseClick(e) {
-        this.mousePosition.set(e.offsetX, e.offsetY), this.checkForFocalPointChange();
-    }
-    getRenderDimensions(e) {
-        this.rootElement ? (e.x = this.rootElement.offsetWidth, e.y = this.rootElement.offsetHeight) : this.renderer.getSize(e);
-    }
-    setupInfoPanel() {
-        this.infoPanel = document.createElement("div"), this.infoPanel.style.position = "absolute", this.infoPanel.style.padding = "10px", this.infoPanel.style.backgroundColor = "#cccccc", this.infoPanel.style.border = "#aaaaaa 1px solid", this.infoPanel.style.zIndex = 100, this.infoPanel.style.width = "375px", this.infoPanel.style.fontFamily = "arial", this.infoPanel.style.fontSize = "10pt", this.infoPanel.style.textAlign = "left";
-        const e = [
-                ["Camera position", "cameraPosition"],
-                ["Camera look-at", "cameraLookAt"],
-                ["Camera up", "cameraUp"],
-                ["Cursor position", "cursorPosition"],
-                ["FPS", "fps"],
-                ["Render window", "renderWindow"],
-                ["Rendering:", "renderSplatCount"],
-                ["Sort time", "sortTime"]
-            ],
-            t = document.createElement("div");
-        t.style.display = "table";
-        for (let n of e) {
-            const r = document.createElement("div");
-            r.style.display = "table-row";
-            const s = document.createElement("div");
-            s.style.display = "table-cell", s.style.width = "110px", s.innerHTML = `${n[0]}: `;
-            const a = document.createElement("div");
-            a.style.display = "table-cell", a.style.width = "10px", a.innerHTML = " ";
-            const o = document.createElement("div");
-            o.style.display = "table-cell", o.innerHTML = "", this.infoPanelCells[n[1]] = o, r.appendChild(s), r.appendChild(a), r.appendChild(o), t.appendChild(r);
+                    let p = Math.min(a.shift(), this.splatRenderCount);
+                    t[0] = this.camera.position.x, t[1] = this.camera.position.y, t[2] = this.camera.position.z;
+                    const v = {
+                        modelViewProj: e.elements,
+                        cameraPosition: t,
+                        splatRenderCount: this.splatRenderCount,
+                        splatSortCount: p,
+                        usePrecomputedDistances: this.gpuAcceleratedSort
+                    };
+                    this.splatMesh.dynamicMode && this.splatMesh.fillTransformsArray(this.sortWorkerTransforms), this.sharedMemoryForWorkers || (v.indexesToSort = this.sortWorkerIndexesToSort, v.transforms = this.sortWorkerTransforms, this.gpuAcceleratedSort && (v.precomputedDistances = this.sortWorkerPrecomputedDistances)), this.sortPromise = new Promise((S) => {
+                        this.sortPromiseResolver = S;
+                    }), this.sortWorker.postMessage({
+                        sort: v
+                    }), a.length === 0 && (r.copy(this.camera.position), n.copy(i)), this.sortNeededForSceneChange = !1;
+                };
+            }());
+            /**
+             * Determine which splats to render by checking which are inside or close to the view frustum
+             */
+            le(this, "gatherSceneNodesForSort", function() {
+                const e = [];
+                let t = null;
+                const n = new D(),
+                    i = new D(),
+                    r = new D(),
+                    o = new Ge(),
+                    a = new Ge(),
+                    l = new Ge(),
+                    c = new D(),
+                    u = new D(0, 0, -1),
+                    d = new D(),
+                    f = (h) => d.copy(h.max).sub(h.min).length();
+                return function(h = !1) {
+                    this.getRenderDimensions(c);
+                    const g = c.y / 2 / Math.tan(this.camera.fov / 2 * kc.DEG2RAD),
+                        _ = Math.atan(c.x / 2 / g),
+                        m = Math.atan(c.y / 2 / g),
+                        p = Math.cos(_),
+                        v = Math.cos(m),
+                        S = this.splatMesh.getSplatTree();
+                    if (S) {
+                        a.copy(this.camera.matrixWorld).invert(), a.multiply(this.splatMesh.matrixWorld);
+                        let y = 0,
+                            b = 0;
+                        for (let T = 0; T < S.subTrees.length; T++) {
+                            const L = S.subTrees[T];
+                            o.copy(a), this.splatMesh.dynamicMode && (this.splatMesh.getSceneTransform(T, l), o.multiply(l));
+                            const B = L.nodesWithIndexes.length;
+                            for (let x = 0; x < B; x++) {
+                                const A = L.nodesWithIndexes[x];
+                                if (!A.data || !A.data.indexes || A.data.indexes.length === 0)
+                                    continue;
+                                r.copy(A.center).applyMatrix4(o);
+                                const U = r.length();
+                                r.normalize(), n.copy(r).setX(0).normalize(), i.copy(r).setY(0).normalize();
+                                const N = u.dot(i),
+                                    P = u.dot(n),
+                                    I = f(A),
+                                    z = P < v - 0.6,
+                                    K = N < p - 0.6;
+                                !h && (K || z) && U > I || (b += A.data.indexes.length, e[y] = A, A.data.distanceToNode = U, y++);
+                            }
+                        }
+                        e.length = y, e.sort((T, L) => T.data.distanceToNode < L.data.distanceToNode ? -1 : 1);
+                        let E = b * rt.BytesPerInt;
+                        for (let T = 0; T < y; T++) {
+                            const L = e[T],
+                                B = L.data.indexes.length,
+                                x = B * rt.BytesPerInt;
+                            new Uint32Array(
+                                this.sortWorkerIndexesToSort.buffer,
+                                E - x,
+                                B
+                            ).set(L.data.indexes), E -= x;
+                        }
+                        return {
+                            splatRenderCount: b,
+                            shouldSortAll: !1
+                        };
+                    } else {
+                        const y = this.splatMesh.getSplatCount();
+                        if (!t || t.length !== y) {
+                            t = new Uint32Array(y);
+                            for (let b = 0; b < y; b++)
+                                t[b] = b;
+                        }
+                        return this.sortWorkerIndexesToSort.set(t), {
+                            splatRenderCount: y,
+                            shouldSortAll: !0
+                        };
+                    }
+                };
+            }());
+            e.cameraUp || (e.cameraUp = [0, 1, 0]), this.cameraUp = new D().fromArray(e.cameraUp), e.initialCameraPosition || (e.initialCameraPosition = [0, 10, 15]), this.initialCameraPosition = new D().fromArray(e.initialCameraPosition), e.initialCameraLookAt || (e.initialCameraLookAt = [0, 0, 0]), this.initialCameraLookAt = new D().fromArray(e.initialCameraLookAt), this.dropInMode = e.dropInMode || !1, (e.selfDrivenMode === void 0 || e.selfDrivenMode === null) && (e.selfDrivenMode = !0), this.selfDrivenMode = e.selfDrivenMode && !this.dropInMode, this.selfDrivenUpdateFunc = this.selfDrivenUpdate.bind(this), e.useBuiltInControls === void 0 && (e.useBuiltInControls = !0), this.useBuiltInControls = e.useBuiltInControls, this.rootElement = e.rootElement, this.ignoreDevicePixelRatio = e.ignoreDevicePixelRatio || !1, this.devicePixelRatio = this.ignoreDevicePixelRatio ? 1 : window.devicePixelRatio, this.halfPrecisionCovariancesOnGPU = e.halfPrecisionCovariancesOnGPU || !1, this.threeScene = e.threeScene, this.renderer = e.renderer, this.camera = e.camera, this.gpuAcceleratedSort = e.gpuAcceleratedSort || !1, (e.integerBasedSort === void 0 || e.integerBasedSort === null) && (e.integerBasedSort = !0), this.integerBasedSort = e.integerBasedSort, (e.sharedMemoryForWorkers === void 0 || e.sharedMemoryForWorkers === null) && (e.sharedMemoryForWorkers = !0), this.sharedMemoryForWorkers = e.sharedMemoryForWorkers, this.dynamicScene = !!e.dynamicScene, this.antialiased = e.antialiased || !1, this.webXRMode = e.webXRMode || qi.None, this.webXRMode !== qi.None && (this.gpuAcceleratedSort = !1), this.webXRActive = !1, this.renderMode = e.renderMode || Da.Always, this.sceneRevealMode = e.sceneRevealMode || _r.Default, this.focalAdjustment = e.focalAdjustment || 1, this.maxScreenSpaceSplatSize = e.maxScreenSpaceSplatSize || 2048, this.logLevel = e.logLevel || rs.None, this.sphericalHarmonicsDegree = e.sphericalHarmonicsDegree || 0, this.createSplatMesh(), this.controls = null, this.perspectiveControls = null, this.orthographicControls = null, this.orthographicCamera = null, this.perspectiveCamera = null, this.showMeshCursor = !1, this.showControlPlane = !1, this.showInfo = !1, this.sceneHelper = null, this.sortWorker = null, this.sortRunning = !1, this.splatRenderCount = 0, this.sortWorkerIndexesToSort = null, this.sortWorkerSortedIndexes = null, this.sortWorkerPrecomputedDistances = null, this.sortWorkerTransforms = null, this.runAfterFirstSort = [], this.selfDrivenModeRunning = !1, this.splatRenderReady = !1, this.raycaster = new __(), this.infoPanel = null, this.startInOrthographicMode = !1, this.currentFPS = 0, this.lastSortTime = 0, this.consecutiveRenderFrames = 0, this.previousCameraTarget = new D(), this.nextCameraTarget = new D(), this.mousePosition = new Ee(), this.mouseDownPosition = new Ee(), this.mouseDownTime = null, this.resizeObserver = null, this.mouseMoveListener = null, this.mouseDownListener = null, this.mouseUpListener = null, this.keyDownListener = null, this.sortPromise = null, this.sortPromiseResolver = null, this.splatSceneDownloadPromises = {}, this.splatSceneDownloadAndBuildPromise = null, this.splatSceneRemovalPromise = null, this.loadingSpinner = new Ha(null, this.rootElement || document.body), this.loadingSpinner.hide(), this.loadingProgressBar = new d_(this.rootElement || document.body), this.loadingProgressBar.hide(), this.infoPanel = new f_(this.rootElement || document.body), this.infoPanel.hide(), this.usingExternalCamera = !!(this.dropInMode || this.camera), this.usingExternalRenderer = !!(this.dropInMode || this.renderer), this.initialized = !1, this.disposing = !1, this.disposed = !1, this.dropInMode || this.init();
         }
-        this.infoPanel.appendChild(t), this.infoPanel.style.display = "none", this.renderer.domElement.parentElement.prepend(this.infoPanel);
-    }
-    /**
-     * Add a splat scene to the viewer.
-     * @param {string} path Path to splat scene to be loaded
-     * @param {object} options {
-     *
-     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
-     *                                     value (valid range: 0 - 255), defaults to 1
-     *
-     *         showLoadingSpinner:         Display a loading spinner while the scene is loading, defaults to true
-     *
-     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
-     *
-     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
-     *
-     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
-     *
-     *         onProgress:                 Function to be called as file data are received
-     *
-     * }
-     * @return {AbortablePromise}
-     */
-    addSplatScene(e, t = {}) {
-        t.showLoadingSpinner !== !1 && (t.showLoadingSpinner = !0), t.showLoadingSpinner && this.loadingSpinner.show();
-        const n = (s, a) => {
-                if (t.showLoadingSpinner)
-                    if (s == 100)
-                        this.loadingSpinner.setMessage("Download complete!");
+        createSplatMesh() {
+            this.splatMesh = new Bt(
+                this.dynamicScene,
+                this.halfPrecisionCovariancesOnGPU,
+                this.devicePixelRatio,
+                this.gpuAcceleratedSort,
+                this.integerBasedSort,
+                this.antialiased,
+                this.maxScreenSpaceSplatSize,
+                this.logLevel,
+                this.sphericalHarmonicsDegree
+            ), this.splatMesh.frustumCulled = !1;
+        }
+        init() {
+            this.initialized || (this.rootElement || (this.usingExternalRenderer ? this.rootElement = this.renderer.domElement.parentElement || document.body : (this.rootElement = document.createElement("div"), this.rootElement.style.width = "100%", this.rootElement.style.height = "100%", this.rootElement.style.position = "absolute", document.body.appendChild(this.rootElement))), this.setupCamera(), this.setupRenderer(), this.setupWebXR(), this.setupControls(), this.setupEventHandlers(), this.threeScene = this.threeScene || new $0(), this.sceneHelper = new Cs(this.threeScene), this.sceneHelper.setupMeshCursor(), this.sceneHelper.setupFocusMarker(), this.sceneHelper.setupControlPlane(), this.loadingProgressBar.setContainer(this.rootElement), this.loadingSpinner.setContainer(this.rootElement), this.infoPanel.setContainer(this.rootElement), this.initialized = !0);
+        }
+        setupCamera() {
+            if (!this.usingExternalCamera) {
+                const e = new Ee();
+                this.getRenderDimensions(e), this.perspectiveCamera = new $t(F_, e.x / e.y, 0.1, 1e3), this.orthographicCamera = new eo(
+                    e.x / -2,
+                    e.x / 2,
+                    e.y / 2,
+                    e.y / -2,
+                    0.1,
+                    1e3
+                ), this.camera = this.startInOrthographicMode ? this.orthographicCamera : this.perspectiveCamera, this.camera.position.copy(this.initialCameraPosition), this.camera.up.copy(this.cameraUp).normalize(), this.camera.lookAt(this.initialCameraLookAt);
+            }
+        }
+        setupRenderer() {
+            if (!this.usingExternalRenderer) {
+                const e = new Ee();
+                this.getRenderDimensions(e), this.renderer = new au({
+                    antialias: !1,
+                    precision: "highp"
+                }), this.renderer.setPixelRatio(this.devicePixelRatio), this.renderer.autoClear = !0, this.renderer.setClearColor(new et(0), 0), this.renderer.setSize(e.x, e.y), this.resizeObserver = new ResizeObserver(() => {
+                    this.getRenderDimensions(e), this.renderer.setSize(e.x, e.y), this.forceRenderNextFrame();
+                }), this.resizeObserver.observe(this.rootElement), this.rootElement.appendChild(this.renderer.domElement);
+            }
+        }
+        setupWebXR() {
+            this.webXRMode && (this.webXRMode === qi.VR ? this.rootElement.appendChild(fs.createButton(this.renderer)) : this.webXRMode === qi.AR && this.rootElement.appendChild(L_.createButton(this.renderer)), this.renderer.xr.addEventListener("sessionstart", (e) => {
+                this.webXRActive = !0;
+            }), this.renderer.xr.addEventListener("sessionend", (e) => {
+                this.webXRActive = !1;
+            }), this.renderer.xr.enabled = !0, this.camera.position.copy(this.initialCameraPosition), this.camera.up.copy(this.cameraUp).normalize(), this.camera.lookAt(this.initialCameraLookAt));
+        }
+        setupControls() {
+            if (this.useBuiltInControls && this.webXRMode === qi.None) {
+                this.usingExternalCamera ? this.camera.isOrthographicCamera ? this.orthographicControls = new cr(this.camera, this.renderer.domElement) : this.perspectiveControls = new cr(this.camera, this.renderer.domElement) : (this.perspectiveControls = new cr(this.perspectiveCamera, this.renderer.domElement), this.orthographicControls = new cr(this.orthographicCamera, this.renderer.domElement));
+                for (let e of [this.perspectiveControls, this.orthographicControls])
+                    e && (e.listenToKeyEvents(window), e.rotateSpeed = 0.5, e.maxPolarAngle = Math.PI * 0.75, e.minPolarAngle = 0.1, e.enableDamping = !0, e.dampingFactor = 0.05, e.target.copy(this.initialCameraLookAt));
+                this.controls = this.camera.isOrthographicCamera ? this.orthographicControls : this.perspectiveControls;
+            }
+        }
+        setupEventHandlers() {
+            this.useBuiltInControls && this.webXRMode === qi.None && (this.mouseMoveListener = this.onMouseMove.bind(this), this.renderer.domElement.addEventListener("pointermove", this.mouseMoveListener, !1), this.mouseDownListener = this.onMouseDown.bind(this), this.renderer.domElement.addEventListener("pointerdown", this.mouseDownListener, !1), this.mouseUpListener = this.onMouseUp.bind(this), this.renderer.domElement.addEventListener("pointerup", this.mouseUpListener, !1), this.keyDownListener = this.onKeyDown.bind(this), window.addEventListener("keydown", this.keyDownListener, !1));
+        }
+        removeEventHandlers() {
+            this.useBuiltInControls && (this.renderer.domElement.removeEventListener("pointermove", this.mouseMoveListener), this.mouseMoveListener = null, this.renderer.domElement.removeEventListener("pointerdown", this.mouseDownListener), this.mouseDownListener = null, this.renderer.domElement.removeEventListener("pointerup", this.mouseUpListener), this.mouseUpListener = null, window.removeEventListener("keydown", this.keyDownListener), this.keyDownListener = null);
+        }
+        setRenderMode(e) {
+            this.renderMode = e;
+        }
+        onMouseMove(e) {
+            this.mousePosition.set(e.offsetX, e.offsetY);
+        }
+        onMouseDown() {
+            this.mouseDownPosition.copy(this.mousePosition), this.mouseDownTime = Wi();
+        }
+        onMouseClick(e) {
+            this.mousePosition.set(e.offsetX, e.offsetY), this.checkForFocalPointChange();
+        }
+        getRenderDimensions(e) {
+            this.rootElement ? (e.x = this.rootElement.offsetWidth, e.y = this.rootElement.offsetHeight) : this.renderer.getSize(e);
+        }
+        setOrthographicMode(e) {
+            if (e === this.camera.isOrthographicCamera)
+                return;
+            const t = this.camera,
+                n = e ? this.orthographicCamera : this.perspectiveCamera;
+            if (n.position.copy(t.position), n.up.copy(t.up), n.rotation.copy(t.rotation), n.quaternion.copy(t.quaternion), n.matrix.copy(t.matrix), this.camera = n, this.controls) {
+                const i = (a) => {
+                        a.saveState(), a.reset();
+                    },
+                    r = this.controls,
+                    o = e ? this.orthographicControls : this.perspectiveControls;
+                i(o), i(r), o.target.copy(r.target), e ? Kn.setCameraZoomFromPosition(n, t, r) : Kn.setCameraPositionFromZoom(n, t, o), this.controls = o, this.camera.lookAt(this.controls.target);
+            }
+        }
+        adjustForWebXRStereo(e) {
+            if (this.camera && this.webXRActive) {
+                const n = this.renderer.xr.getCamera().projectionMatrix.elements[0],
+                    i = this.camera.projectionMatrix.elements[0];
+                e.x *= i / n;
+            }
+        }
+        isLoadingOrUnloading() {
+            return Object.keys(this.splatSceneDownloadPromises).length > 0 || this.splatSceneDownloadAndBuildPromise !== null || this.splatSceneRemovalPromise !== null;
+        }
+        isDisposingOrDisposed() {
+            return this.disposing || this.disposed;
+        }
+        addSplatSceneDownloadPromise(e) {
+            this.splatSceneDownloadPromises[e.id] = e;
+        }
+        removeSplatSceneDownloadPromise(e) {
+            delete this.splatSceneDownloadPromises[e.id];
+        }
+        setSplatSceneDownloadAndBuildPromise(e) {
+            this.splatSceneDownloadAndBuildPromise = e;
+        }
+        clearSplatSceneDownloadAndBuildPromise() {
+            this.splatSceneDownloadAndBuildPromise = null;
+        }
+        /**
+         * Add a splat scene to the viewer and display any loading UI if appropriate.
+         * @param {string} path Path to splat scene to be loaded
+         * @param {object} options {
+         *
+         *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
+         *                                     value (valid range: 0 - 255), defaults to 1
+         *
+         *         showLoadingUI:         Display a loading spinner while the scene is loading, defaults to true
+         *
+         *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
+         *
+         *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
+         *
+         *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
+         *
+         *         onProgress:                 Function to be called as file data are received, or other processing occurs
+         *
+         * }
+         * @return {AbortablePromise}
+         */
+        addSplatScene(e, t = {}) {
+            if (this.isLoadingOrUnloading())
+                throw new Error("Cannot add splat scene while another load or unload is already in progress.");
+            if (this.isDisposingOrDisposed())
+                throw new Error("Cannot add splat scene after dispose() is called.");
+            const n = t.format !== void 0 && t.format !== null ? t.format : Kl(e),
+                i = Kn.isStreamable(n) && t.streamView,
+                r = t.showLoadingUI !== void 0 && t.showLoadingUI !== null ? t.showLoadingUI : !0;
+            let o = null;
+            r && (this.loadingSpinner.removeAllTasks(), o = this.loadingSpinner.addTask("Downloading..."));
+            const a = () => {
+                    this.loadingProgressBar.hide(), this.loadingSpinner.removeAllTasks();
+                },
+                l = (_, m, p) => {
+                    if (r)
+                        if (p === Lt.Downloading)
+                            if (_ == 100)
+                                this.loadingSpinner.setMessageForTask(o, "Download complete!");
+                            else if (i)
+                        this.loadingSpinner.setMessageForTask(o, "Downloading splats...");
                     else {
-                        const o = a ? `: ${a}` : "...";
-                        this.loadingSpinner.setMessage(`Downloading${o}`);
+                        const v = m ? `: ${m}` : "...";
+                        this.loadingSpinner.setMessageForTask(o, `Downloading${v}`);
+                    } else
+                        p === Lt.Processing ? this.loadingSpinner.setMessageForTask(o, "Processing splats...") : this.loadingSpinner.setMessageForTask(o, "Ready!");
+                };
+            let c = !1,
+                u = 0;
+            const d = (_, m) => {
+                    r && ((_ && i || m && !i) && this.runAfterFirstSort.push(() => {
+                        this.loadingSpinner.removeTask(o), !m && !c && this.loadingProgressBar.show();
+                    }), i && (m ? (c = !0, this.loadingProgressBar.hide()) : this.loadingProgressBar.setProgress(u)));
+                },
+                f = (_, m, p) => {
+                    u = _, l(_, m, p), t.onProgress && t.onProgress(_, m, p);
+                },
+                h = (_, m, p) => {
+                    !i && t.onProgress && t.onProgress(0, "0%", Lt.Processing);
+                    const v = {
+                        rotation: t.rotation || t.orientation,
+                        position: t.position,
+                        scale: t.scale,
+                        splatAlphaRemovalThreshold: t.splatAlphaRemovalThreshold
+                    };
+                    return this.addSplatBuffers(
+                        [_],
+                        [v],
+                        p,
+                        m && r,
+                        r
+                    ).then(() => {
+                        !i && t.onProgress && t.onProgress(100, "100%", Lt.Processing), d(m, p);
+                    });
+                };
+            return (i ? this.downloadAndBuildSingleSplatSceneStreaming.bind(this) : this.downloadAndBuildSingleSplatSceneNonStreaming.bind(this))(e, n, t.splatAlphaRemovalThreshold, h.bind(this), f, a.bind(this));
+        }
+        /**
+         * Download a single non-streamed splat scene, convert to splat buffer and then rebuild the viewer's splat mesh
+         * by calling 'buildFunc'. Also sets/clears relevant instance synchronization objects, and calls appropriate functions
+         * on success or failure.
+         * @param {string} path Path to splat scene to be loaded
+         * @param {SceneFormat} format Format of the splat scene file
+         * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)
+         * @param {function} buildFunc Function to build the viewer's splat mesh with the downloaded splat buffer
+         * @param {function} onProgress Function to be called as file data are received, or other processing occurs
+         * @param {function} onException Function to be called when exception occurs
+         * @return {AbortablePromise}
+         */
+        downloadAndBuildSingleSplatSceneNonStreaming(e, t, n, i, r, o) {
+            const a = this.downloadSplatSceneToSplatBuffer(e, n, r, !1, void 0, t).then((l) => (this.removeSplatSceneDownloadPromise(a), i(l, !0, !0).then(() => {
+                this.clearSplatSceneDownloadAndBuildPromise();
+            }))).catch((l) => {
+                if (o && o(), this.clearSplatSceneDownloadAndBuildPromise(), this.removeSplatSceneDownloadPromise(a), !(l instanceof pr))
+                    throw new Error(`Viewer::addSplatScene -> Could not load file ${e}`);
+            });
+            return this.addSplatSceneDownloadPromise(a), this.setSplatSceneDownloadAndBuildPromise(a), a;
+        }
+        /**
+         * Download a single splat scene and convert to splat buffer in a streamed manner, allowing rendering as the file downloads.
+         * As each section is downloaded, the viewer's splat mesh is rebuilt by calling 'buildFunc'
+         * Also sets/clears relevant instance synchronization objects, and calls appropriate functions on success or failure.
+         * @param {string} path Path to splat scene to be loaded
+         * @param {SceneFormat} format Format of the splat scene file
+         * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified value (valid range: 0 - 255)
+         * @param {function} buildFunc Function to rebuild the viewer's splat mesh after a new splat buffer section is downloaded
+         * @param {function} onDownloadProgress Function to be called as file data are received
+         * @param {function} onDownloadException Function to be called when exception occurs at any point during the full download
+         * @return {AbortablePromise}
+         */
+        downloadAndBuildSingleSplatSceneStreaming(e, t, n, i, r, o) {
+            let a, l, c, u, d = 0,
+                f = !1;
+            const h = [],
+                g = () => {
+                    if (h.length > 0 && !f && !this.isDisposingOrDisposed()) {
+                        f = !0;
+                        const S = h.shift();
+                        i(S.splatBuffer, S.firstBuild, S.finalBuild).then(() => {
+                            f = !1, S.firstBuild ? (l = null, a()) : S.finalBuild && (c(), this.clearSplatSceneDownloadAndBuildPromise()), h.length > 0 && Ln(() => g());
+                        });
                     }
-                t.onProgress && t.onProgress(s, a, "downloading");
-            },
-            r = this.loadFileToSplatBuffer(e, t.splatAlphaRemovalThreshold, n, t.format);
-        return new cn((s, a) => {
-            r.then((o) => {
-                t.showLoadingSpinner && this.loadingSpinner.hide(), t.onProgress && t.onProgress(0, "0%", "processing");
-                const l = {
-                    rotation: t.rotation || t.orientation,
-                    position: t.position,
-                    scale: t.scale,
-                    splatAlphaRemovalThreshold: t.splatAlphaRemovalThreshold
+                },
+                _ = (S, y) => {
+                    this.isDisposingOrDisposed() || (y || h.length === 0 || S.getSplatCount() > h[0].splatBuffer.getSplatCount()) && (h.push({
+                        splatBuffer: S,
+                        firstBuild: d === 0,
+                        finalBuild: y
+                    }), d++, g());
                 };
-                this.addSplatBuffers([o], [l], t.showLoadingSpinner).then(() => {
-                    t.onProgress && t.onProgress(100, "100%", "processing"), s();
+            let m = this.downloadSplatSceneToSplatBuffer(
+                e,
+                n,
+                r,
+                !0,
+                _,
+                t
+            );
+            const p = new gi((S, y) => {
+                    a = S, l = y;
+                }, m.abortHandler),
+                v = new gi((S, y) => {
+                    c = S, u = y;
                 });
-            }).catch(() => {
-                t.showLoadingSpinner && this.loadingSpinner.hide(), a(new Error(`Viewer::addSplatScene -> Could not load file ${e}`));
+            return this.addSplatSceneDownloadPromise(m), this.setSplatSceneDownloadAndBuildPromise(v), m.then(() => {
+                this.removeSplatSceneDownloadPromise(m);
+            }).catch((S) => {
+                this.clearSplatSceneDownloadAndBuildPromise(), this.removeSplatSceneDownloadPromise(m), S instanceof pr || (u(S), l && l(S), o && o(S));
+            }), p;
+        }
+        /**
+         * Add multiple splat scenes to the viewer and display any loading UI if appropriate.
+         * @param {Array<object>} sceneOptions Array of per-scene options: {
+         *
+         *         path: Path to splat scene to be loaded
+         *
+         *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
+         *                                     value (valid range: 0 - 255), defaults to 1
+         *
+         *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
+         *
+         *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
+         *
+         *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
+         * }
+         * @param {boolean} showLoadingUI Display a loading spinner while the scene is loading, defaults to true
+         * @param {function} onProgress Function to be called as file data are received
+         * @return {AbortablePromise}
+         */
+        addSplatScenes(e, t = !0, n = void 0) {
+            if (this.isLoadingOrUnloading())
+                throw new Error("Cannot add splat scene while another load or unload is already in progress.");
+            if (this.isDisposingOrDisposed())
+                throw new Error("Cannot add splat scene after dispose() is called.");
+            const i = e.length,
+                r = [];
+            t && (this.loadingSpinner.removeAllTasks(), this.loadingSpinner.show());
+            const o = (d, f, h) => {
+                    r[d] = f;
+                    let g = 0;
+                    for (let _ = 0; _ < i; _++)
+                        g += r[_] || 0;
+                    g = g / i, h = `${g.toFixed(2)}%`, t && this.loadingSpinner.setMessage(g == 100 ? "Download complete!" : `Downloading: ${h}`), n && n(g, h, Lt.Downloading);
+                },
+                a = [],
+                l = [],
+                c = [];
+            for (let d = 0; d < e.length; d++) {
+                const f = e[d],
+                    h = f.format !== void 0 && f.format !== null ? f.format : Kl(f.path),
+                    g = this.downloadSplatSceneToSplatBuffer(
+                        f.path,
+                        f.splatAlphaRemovalThreshold,
+                        o.bind(this, d),
+                        !1,
+                        void 0,
+                        h
+                    );
+                c.push(g.abortHandler), a.push(g), l.push(g.promise), this.addSplatSceneDownloadPromise(g);
+            }
+            const u = new gi((d, f) => {
+                Promise.all(l).then((h) => {
+                    t && this.loadingSpinner.hide(), n && options.onProgress(0, "0%", Lt.Processing), this.addSplatBuffers(h, e, !0, t, t).then(() => {
+                        n && n(100, "100%", Lt.Processing), this.clearSplatSceneDownloadAndBuildPromise(), d();
+                    });
+                }).catch((h) => {
+                    t && this.loadingSpinner.hide(), this.clearSplatSceneDownloadAndBuildPromise(), h instanceof pr ? d() : f(new Error("Viewer::addSplatScenes -> Could not load one or more splat scenes."));
+                }).finally(() => {
+                    for (let h of a)
+                        this.removeSplatSceneDownloadPromise(h);
+                });
+            }, () => {
+                for (let d of c)
+                    d();
             });
-        }, r.abortHandler);
-    }
-    /**
-     * Add multiple splat scenes to the viewer.
-     * @param {Array<object>} sceneOptions Array of per-scene options: {
-     *
-     *         path: Path to splat scene to be loaded
-     *
-     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
-     *                                     value (valid range: 0 - 255), defaults to 1
-     *
-     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
-     *
-     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
-     *
-     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
-     * }
-     * @param {boolean} showLoadingSpinner Display a loading spinner while the scene is loading, defaults to true
-     * @param {function} onProgress Function to be called as file data are received
-     * @return {AbortablePromise}
-     */
-    addSplatScenes(e, t = !0, n = void 0) {
-        const r = e.length,
-            s = [];
-        t && this.loadingSpinner.show();
-        const a = (u, f, h) => {
-                s[u] = f;
-                let p = 0;
-                for (let g = 0; g < r; g++)
-                    p += s[g] || 0;
-                p = p / r, h = `${p.toFixed(2)}%`, t && (p == 100 ? this.loadingSpinner.setMessage("Download complete!") : this.loadingSpinner.setMessage(`Downloading: ${h}`)), n && n(p, h, "downloading");
-            },
-            o = [],
-            l = [];
-        for (let u = 0; u < e.length; u++) {
-            const f = this.loadFileToSplatBuffer(
-                e[u].path,
-                e[u].splatAlphaRemovalThreshold,
-                a.bind(this, u),
-                e.format
-            );
-            l.push(f.abortHandler), o.push(f.promise);
+            return this.setSplatSceneDownloadAndBuildPromise(u), u;
         }
-        const c = () => {
-            for (let u of l)
-                u();
-        };
-        return new cn((u, f) => {
-            Promise.all(o).then((h) => {
-                t && this.loadingSpinner.hide(), n && options.onProgress(0, "0%", "processing"), this.addSplatBuffers(h, e, t).then(() => {
-                    n && n(100, "100%", "processing"), u();
+        /**
+         * Download a splat scene and convert to SplatBuffer instance.
+         * @param {string} path Path to splat scene to be loaded
+         * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified
+         *                                            value (valid range: 0 - 255), defaults to 1
+         *
+         * @param {function} onProgress Function to be called as file data are received
+         * @param {boolean} streamBuiltSections Construct file sections into splat buffers as they are downloaded
+         * @param {function} onSectionBuilt Function to be called when new section is added to the file
+         * @param {string} format File format of the scene
+         * @return {AbortablePromise}
+         */
+        downloadSplatSceneToSplatBuffer(e, t = 1, n = void 0, i = !1, r = void 0, o) {
+            return o === Rn.Splat ? oo.loadFromURL(e, n, i, r, t, 0, !1) : o === Rn.KSplat ? za.loadFromURL(e, n, i, r) : o === Rn.Ply ? ao.loadFromURL(
+                e,
+                n,
+                i,
+                r,
+                t,
+                0,
+                this.sphericalHarmonicsDegree
+            ) : gi.reject(new Error(`Viewer::downloadSplatSceneToSplatBuffer -> File format not supported: ${e}`));
+        }
+        static isStreamable(e) {
+            return e === Rn.Splat || e === Rn.KSplat || e === Rn.Ply;
+        }
+        /**
+         * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer. This function is additive; all splat
+         * buffers contained by the viewer's splat mesh before calling this function will be preserved.
+         * @param {Array<SplatBuffer>} splatBuffers SplatBuffer instances
+         * @param {Array<object>} splatBufferOptions Array of options objects: {
+         *
+         *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
+         *                                     value (valid range: 0 - 255), defaults to 1
+         *
+         *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
+         *
+         *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
+         *
+         *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
+         * }
+         * @param {boolean} finalBuild Will the splat mesh be in its final state after this build?
+         * @param {boolean} showLoadingUIForSplatTreeBuild Whether or not to show the loading spinner during construction of the splat tree.
+         * @return {object} Object containing info about the splats that are updated
+         */
+        addSplatBuffersToMesh(e, t, n = !0, i = !1) {
+            if (this.isDisposingOrDisposed())
+                return;
+            const r = this.splatMesh.splatBuffers || [],
+                o = this.splatMesh.splatBufferOptions || [];
+            r.push(...e), o.push(...t), this.renderer && this.splatMesh.setRenderer(this.renderer);
+            let a;
+            const l = (u) => {
+                    if (this.isDisposingOrDisposed())
+                        return;
+                    const d = this.splatMesh.getSplatCount();
+                    i && d >= U_ && !u && !a && (this.loadingSpinner.setMinimized(!0, !0), a = this.loadingSpinner.addTask("Optimizing splats..."));
+                },
+                c = (u) => {
+                    this.isDisposingOrDisposed() || u && a && this.loadingSpinner.removeTask(a);
+                };
+            return this.splatMesh.build(r, o, !0, n, l, c);
+        }
+        /**
+         * Set up the splat sorting web worker.
+         * @param {SplatMesh} splatMesh SplatMesh instance that contains the splats to be sorted
+         * @return {Promise}
+         */
+        setupSortWorker(e) {
+            if (!this.isDisposingOrDisposed())
+                return new Promise((t) => {
+                    const n = this.integerBasedSort ? Int32Array : Float32Array,
+                        i = e.getSplatCount(),
+                        r = e.getMaxSplatCount();
+                    this.sortWorker = D_(
+                        r,
+                        this.sharedMemoryForWorkers,
+                        this.integerBasedSort,
+                        this.splatMesh.dynamicMode
+                    );
+                    let o = 0;
+                    this.sortWorker.onmessage = (a) => {
+                        if (a.data.sortDone) {
+                            if (this.sortRunning = !1, this.sharedMemoryForWorkers)
+                                this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes, a.data.splatRenderCount);
+                            else {
+                                const l = new Uint32Array(a.data.sortedIndexes.buffer, 0, a.data.splatRenderCount);
+                                this.splatMesh.updateRenderIndexes(l, a.data.splatRenderCount);
+                            }
+                            this.lastSortTime = a.data.sortTime, this.sortPromiseResolver(), this.sortPromiseResolver = null, this.forceRenderNextFrame(), o === 0 && (this.runAfterFirstSort.forEach((l) => {
+                                l();
+                            }), this.runAfterFirstSort.length = 0), o++;
+                        } else if (a.data.sortCanceled)
+                            this.sortRunning = !1;
+                        else if (a.data.sortSetupPhase1Complete) {
+                            this.logLevel >= rs.Info && console.log("Sorting web worker WASM setup complete."), this.sharedMemoryForWorkers ? (this.sortWorkerSortedIndexes = new Uint32Array(
+                                a.data.sortedIndexesBuffer,
+                                a.data.sortedIndexesOffset,
+                                r
+                            ), this.sortWorkerIndexesToSort = new Uint32Array(
+                                a.data.indexesToSortBuffer,
+                                a.data.indexesToSortOffset,
+                                r
+                            ), this.sortWorkerPrecomputedDistances = new n(
+                                a.data.precomputedDistancesBuffer,
+                                a.data.precomputedDistancesOffset,
+                                r
+                            ), this.sortWorkerTransforms = new Float32Array(
+                                a.data.transformsBuffer,
+                                a.data.transformsOffset,
+                                rt.MaxScenes * 16
+                            )) : (this.sortWorkerIndexesToSort = new Uint32Array(r), this.sortWorkerPrecomputedDistances = new n(r), this.sortWorkerTransforms = new Float32Array(rt.MaxScenes * 16));
+                            for (let l = 0; l < i; l++)
+                                this.sortWorkerIndexesToSort[l] = l;
+                            if (this.sortWorker.maxSplatCount = r, this.logLevel >= rs.Info) {
+                                console.log("Sorting web worker ready.");
+                                const l = this.splatMesh.getSplatDataTextures(),
+                                    c = l.covariances.size,
+                                    u = l.centerColors.size;
+                                console.log("Covariances texture size: " + c.x + " x " + c.y), console.log("Centers/colors texture size: " + u.x + " x " + u.y);
+                            }
+                            t();
+                        }
+                    };
                 });
-            }).catch(() => {
-                t && this.loadingSpinner.hide(), f(new Error("Viewer::addSplatScenes -> Could not load one or more splat scenes."));
+        }
+        disposeSortWorker() {
+            this.sortWorker && this.sortWorker.terminate(), this.sortWorker = null, this.sortPromise = null, this.sortPromiseResolver && (this.sortPromiseResolver(), this.sortPromiseResolver = null), this.sortRunning = !1;
+        }
+        removeSplatScene(e, t = !0) {
+            if (this.isLoadingOrUnloading())
+                throw new Error("Cannot remove splat scene while another load or unload is already in progress.");
+            if (this.isDisposingOrDisposed())
+                throw new Error("Cannot remove splat scene after dispose() is called.");
+            let n;
+            return this.splatSceneRemovalPromise = new Promise((i, r) => {
+                let o;
+                t && (this.loadingSpinner.removeAllTasks(), this.loadingSpinner.show(), o = this.loadingSpinner.addTask("Removing splat scene..."));
+                const a = () => {
+                        t && (this.loadingSpinner.hide(), this.loadingSpinner.removeTask(o));
+                    },
+                    l = (u) => {
+                        a(), this.splatSceneRemovalPromise = null, u ? r(u) : i();
+                    },
+                    c = () => this.isDisposingOrDisposed() ? (l(), !0) : !1;
+                n = this.sortPromise || Promise.resolve(), n.then(() => {
+                    if (c())
+                        return;
+                    const u = [],
+                        d = [],
+                        f = [],
+                        h = this.splatMesh.visibleRegionFadeStartRadius;
+                    for (let g = 0; g < this.splatMesh.scenes.length; g++)
+                        if (g !== e) {
+                            const _ = this.splatMesh.scenes[g];
+                            u.push(_.splatBuffer), d.push(this.splatMesh.sceneOptions[g]), f.push({
+                                position: _.position.clone(),
+                                quaternion: _.quaternion.clone(),
+                                scale: _.scale.clone()
+                            });
+                        }
+                    this.disposeSortWorker(), this.splatMesh.dispose(), this.createSplatMesh(), this.addSplatBuffers(u, d, !0, !1, !0).then(() => {
+                        c() || (a(), this.splatMesh.visibleRegionFadeStartRadius = h, this.splatMesh.scenes.forEach((g, _) => {
+                            g.position.copy(f[_].position), g.quaternion.copy(f[_].quaternion), g.scale.copy(f[_].scale);
+                        }), this.splatMesh.updateTransforms(), this.splatRenderReady = !1, this.updateSplatSort(!0).then(() => {
+                            if (c()) {
+                                this.splatRenderReady = !0;
+                                return;
+                            }
+                            n = this.sortPromise || Promise.resolve(), n.then(() => {
+                                this.splatRenderReady = !0, l();
+                            });
+                        }));
+                    }).catch((g) => {
+                        l(g);
+                    });
+                });
+            }), this.splatSceneRemovalPromise;
+        }
+        /**
+         * Start self-driven mode
+         */
+        start() {
+            if (this.selfDrivenMode)
+                this.webXRMode ? this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc) : this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc), this.selfDrivenModeRunning = !0;
+            else
+                throw new Error("Cannot start viewer unless it is in self driven mode.");
+        }
+        /**
+         * Stop self-driven mode
+         */
+        stop() {
+            this.selfDrivenMode && this.selfDrivenModeRunning && (this.webXRMode || cancelAnimationFrame(this.requestFrameId), this.selfDrivenModeRunning = !1);
+        }
+        /**
+         * Dispose of all resources held directly and indirectly by this viewer.
+         */
+        async dispose() {
+            this.disposing = !0;
+            let e = [],
+                t = [];
+            for (let i in this.splatSceneDownloadPromises)
+                if (this.splatSceneDownloadPromises.hasOwnProperty(i)) {
+                    const r = this.splatSceneDownloadPromises[i];
+                    t.push(r), e.push(r.promise);
+                }
+            this.sortPromise && e.push(this.sortPromise);
+            const n = Promise.all(e).finally(() => {
+                this.stop(), this.controls && (this.controls.dispose(), this.controls = null), this.splatMesh && (this.splatMesh.dispose(), this.splatMesh = null), this.sceneHelper && (this.sceneHelper.dispose(), this.sceneHelper = null), this.resizeObserver && (this.resizeObserver.unobserve(this.rootElement), this.resizeObserver = null), this.disposeSortWorker(), this.removeEventHandlers(), this.loadingSpinner.removeAllTasks(), this.loadingSpinner.setContainer(null), this.loadingProgressBar.hide(), this.loadingProgressBar.setContainer(null), this.infoPanel.setContainer(null), this.camera = null, this.threeScene = null, this.splatRenderReady = !1, this.initialized = !1, this.renderer && (this.usingExternalRenderer || (this.rootElement.removeChild(this.renderer.domElement), this.renderer.dispose()), this.renderer = null), this.usingExternalRenderer || document.body.removeChild(this.rootElement), this.sortWorkerSortedIndexes = null, this.sortWorkerIndexesToSort = null, this.sortWorkerPrecomputedDistances = null, this.sortWorkerTransforms = null, this.disposed = !0, this.disposing = !1;
             });
-        }, c);
-    }
-    /**
-     *
-     * @param {string} path Path to splat scene to be loaded
-     * @param {number} splatAlphaRemovalThreshold Ignore any splats with an alpha less than the specified
-     *                                            value (valid range: 0 - 255), defaults to 1
-     *
-     * @param {function} onProgress Function to be called as file data are received
-     * @param {string} format Optional format specifier, if not specified the format will be inferred from the file extension
-     * @return {AbortablePromise}
-     */
-    loadFileToSplatBuffer(e, t = 1, n = void 0, r = void 0) {
-        const s = (a, o) => {
-            n && n(a, o, "downloading");
-        };
-        if (r != null) {
-            if (r === Wr.Splat || r === Wr.KSplat)
-                return new Bn().loadFromURL(e, s, 0, t, void 0, void 0, r);
-            if (r === Wr.Ply)
-                return new il().loadFromURL(e, s, 0, t);
-        } else {
-            if (Bn.isFileSplatFormat(e))
-                return new Bn().loadFromURL(e, s, 0, t);
-            if (e.endsWith(".ply"))
-                return new il().loadFromURL(e, s, 0, t);
+            return t.forEach((i) => {
+                i.abort();
+            }), n;
         }
-        return cn.reject(new Error(`Viewer::loadFileToSplatBuffer -> File format not supported: ${e}`));
-    }
-    disposeSortWorker() {
-        this.sortWorker && this.sortWorker.terminate(), this.sortWorker = null, this.sortRunning = !1;
-    }
-    /**
-     * Add one or more instances of SplatBuffer to the SplatMesh instance managed by the viewer. This function is additive; all splat
-     * buffers contained by the viewer's splat mesh before calling this function will be preserved.
-     * @param {Array<SplatBuffer>} splatBuffers SplatBuffer instances
-     * @param {Array<object>} splatBufferOptions Array of options objects: {
-     *
-     *         splatAlphaRemovalThreshold: Ignore any splats with an alpha less than the specified
-     *                                     value (valid range: 0 - 255), defaults to 1
-     *
-     *         position (Array<number>):   Position of the scene, acts as an offset from its default position, defaults to [0, 0, 0]
-     *
-     *         rotation (Array<number>):   Rotation of the scene represented as a quaternion, defaults to [0, 0, 0, 1]
-     *
-     *         scale (Array<number>):      Scene's scale, defaults to [1, 1, 1]
-     * }
-     */
-    addSplatBuffersToMesh(e, t) {
-        const n = this.splatMesh.splatBuffers || [],
-            r = this.splatMesh.splatBufferOptions || [];
-        n.push(...e), r.push(...t), this.splatMesh.build(n, r, !0), this.renderer && this.splatMesh.setRenderer(this.renderer), this.splatMesh.frustumCulled = !1;
-    }
-    /**
-     * Set up the splat sorting web worker.
-     * @param {SplatMesh} splatMesh SplatMesh instance that contains the splats to be sorted
-     * @return {Promise}
-     */
-    setupSortWorker(e) {
-        return new Promise((t) => {
-            const n = this.integerBasedSort ? Int32Array : Float32Array,
-                r = e.getSplatCount(),
-                s = T_(r, this.sharedMemoryForWorkers, this.integerBasedSort, this.splatMesh.dynamicMode);
-            s.onmessage = (a) => {
-                if (a.data.sortDone) {
-                    if (this.sortRunning = !1, this.sharedMemoryForWorkers)
-                        this.splatMesh.updateRenderIndexes(this.sortWorkerSortedIndexes, a.data.splatRenderCount);
-                    else {
-                        const o = new Uint32Array(a.data.sortedIndexes, 0, a.data.splatRenderCount);
-                        this.splatMesh.updateRenderIndexes(o, a.data.splatRenderCount);
-                    }
-                    this.lastSortTime = a.data.sortTime, this.sortPromiseResolver(), this.sortPromise = null, this.sortPromiseResolver = null;
-                } else if (a.data.sortCanceled)
-                    this.sortRunning = !1;
-                else if (a.data.sortSetupPhase1Complete) {
-                    console.log("Sorting web worker WASM setup complete.");
-                    const o = this.integerBasedSort ? this.splatMesh.getIntegerCenters(!0) : this.splatMesh.getFloatCenters(!0),
-                        l = this.splatMesh.getTransformIndexes();
-                    s.postMessage({
-                        centers: o.buffer,
-                        transformIndexes: l.buffer
-                    }), this.sharedMemoryForWorkers ? (this.sortWorkerSortedIndexes = new Uint32Array(
-                        a.data.sortedIndexesBuffer,
-                        a.data.sortedIndexesOffset,
-                        r
-                    ), this.sortWorkerIndexesToSort = new Uint32Array(
-                        a.data.indexesToSortBuffer,
-                        a.data.indexesToSortOffset,
-                        r
-                    ), this.sortWorkerPrecomputedDistances = new n(
-                        a.data.precomputedDistancesBuffer,
-                        a.data.precomputedDistancesOffset,
-                        r
-                    ), this.sortWorkerTransforms = new Float32Array(
-                        a.data.transformsBuffer,
-                        a.data.transformsOffset,
-                        mt.MaxScenes * 16
-                    )) : (this.sortWorkerIndexesToSort = new Uint32Array(r), this.sortWorkerPrecomputedDistances = new n(r), this.sortWorkerTransforms = new Float32Array(mt.MaxScenes * 16));
-                    for (let c = 0; c < r; c++)
-                        this.sortWorkerIndexesToSort[c] = c;
-                } else if (a.data.sortSetupComplete) {
-                    console.log("Sorting web worker ready.");
-                    const o = this.splatMesh.getSplatDataTextures(),
-                        l = o.covariances.size,
-                        c = o.centerColors.size;
-                    console.log("Covariances texture size: " + l.x + " x " + l.y), console.log("Centers/colors texture size: " + c.x + " x " + c.y), this.sortWorker = s, t();
-                }
-            };
-        });
-    }
-    /**
-     * Start self-driven mode
-     */
-    start() {
-        if (this.selfDrivenMode)
-            this.webXRMode ? this.renderer.setAnimationLoop(this.selfDrivenUpdateFunc) : this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc), this.selfDrivenModeRunning = !0;
-        else
-            throw new Error("Cannot start viewer unless it is in self driven mode.");
-    }
-    /**
-     * Stop self-driven mode
-     */
-    stop() {
-        this.selfDrivenMode && this.selfDrivenModeRunning && (this.webXRMode || cancelAnimationFrame(this.requestFrameId), this.selfDrivenModeRunning = !1);
-    }
-    /**
-     * Dispose of all resources held directly and indirectly by this viewer.
-     */
-    async dispose() {
-        this.sortPromise && await this.sortPromise, this.stop(), this.controls && (this.controls.dispose(), this.controls = null), this.splatMesh && (this.splatMesh.dispose(), this.splatMesh = null), this.sceneHelper && (this.sceneHelper.dispose(), this.sceneHelper = null), this.resizeObserver && (this.resizeObserver.unobserve(this.rootElement), this.resizeObserver = null), this.renderer && (this.usingExternalRenderer || this.renderer.dispose(), this.renderer = null), this.disposeSortWorker(), this.removeEventHandlers(), this.camera = null, this.threeScene = null, this.splatRenderingInitialized = !1, this.initialized = !1;
-    }
-    selfDrivenUpdate() {
-        this.selfDrivenMode && !this.webXRMode && (this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc)), this.update(), this.render();
-    }
-    update(e, t) {
-        this.dropInMode && this.updateForDropInMode(e, t), !(!this.initialized || !this.splatRenderingInitialized) && (this.controls && this.controls.update(), this.updateSplatSort(), this.updateForRendererSizeChanges(), this.updateSplatMesh(), this.updateMeshCursor(), this.updateFPS(), this.timingSensitiveUpdates(), this.updateInfoPanel(), this.updateControlPlane());
-    }
-    updateForDropInMode(e, t) {
-        this.renderer = e, this.splatMesh && this.splatMesh.setRenderer(this.renderer), this.camera = t, this.controls && (this.controls.object = t), this.init();
-    }
-    updateControlPlane() {
-        this.showControlPlane ? (this.sceneHelper.setControlPlaneVisibility(!0), this.sceneHelper.positionAndOrientControlPlane(this.controls.target, this.camera.up)) : this.sceneHelper.setControlPlaneVisibility(!1);
-    }
-    getSplatMesh() {
-        return this.splatMesh;
-    }
-    /**
-     * Get a reference to a splat scene.
-     * @param {number} sceneIndex The index of the scene to which the reference will be returned
-     * @return {SplatScene}
-     */
-    getSplatScene(e) {
-        return this.splatMesh.getScene(e);
-    }
-    isMobile() {
-        return navigator.userAgent.includes("Mobi");
-    }
-}
+        selfDrivenUpdate() {
+            this.selfDrivenMode && !this.webXRMode && (this.requestFrameId = requestAnimationFrame(this.selfDrivenUpdateFunc)), this.update(), this.shouldRender() ? (this.render(), this.consecutiveRenderFrames++) : this.consecutiveRenderFrames = 0, this.renderNextFrame = !1;
+        }
+        forceRenderNextFrame() {
+            this.renderNextFrame = !0;
+        }
+        update(e, t) {
+            this.dropInMode && this.updateForDropInMode(e, t), !(!this.initialized || !this.splatRenderReady) && (this.controls && (this.controls.update(), this.camera.isOrthographicCamera && !this.usingExternalCamera && Kn.setCameraPositionFromZoom(this.camera, this.camera, this.controls)), this.splatMesh.updateVisibleRegionFadeDistance(this.sceneRevealMode), this.updateSplatSort(), this.updateForRendererSizeChanges(), this.updateSplatMesh(), this.updateMeshCursor(), this.updateFPS(), this.timingSensitiveUpdates(), this.updateInfoPanel(), this.updateControlPlane());
+        }
+        updateForDropInMode(e, t) {
+            this.renderer = e, this.splatMesh && this.splatMesh.setRenderer(this.renderer), this.camera = t, this.controls && (this.controls.object = t), this.init();
+        }
+        updateControlPlane() {
+            this.showControlPlane ? (this.sceneHelper.setControlPlaneVisibility(!0), this.sceneHelper.positionAndOrientControlPlane(this.controls.target, this.camera.up)) : this.sceneHelper.setControlPlaneVisibility(!1);
+        }
+        getSplatMesh() {
+            return this.splatMesh;
+        }
+        /**
+         * Get a reference to a splat scene.
+         * @param {number} sceneIndex The index of the scene to which the reference will be returned
+         * @return {SplatScene}
+         */
+        getSplatScene(e) {
+            return this.splatMesh.getScene(e);
+        }
+        isMobile() {
+            return navigator.userAgent.includes("Mobi");
+        }
+    };
+le(Kn, "setCameraPositionFromZoom", function() {
+    const e = new D();
+    return function(t, n, i) {
+        const r = 1 / (n.zoom * 1e-3);
+        e.copy(i.target).sub(t.position).normalize().multiplyScalar(r).negate(), t.position.copy(i.target).add(e);
+    };
+}()), le(Kn, "setCameraZoomFromPosition", function() {
+    const e = new D();
+    return function(t, n, i) {
+        const r = e.copy(i.target).sub(n.position).length();
+        t.zoom = 1 / (r * 1e-3);
+    };
+}());
+let Va = Kn;
 const {
-    SvelteComponent: L_,
-    attr: D_,
-    create_component: I_,
-    destroy_component: U_,
-    detach: cl,
-    element: F_,
-    init: N_,
-    insert: ul,
-    mount_component: B_,
-    safe_not_equal: O_,
-    space: z_,
-    transition_in: k_,
-    transition_out: G_
+    SvelteComponent: k_,
+    attr: z_,
+    create_component: H_,
+    destroy_component: G_,
+    detach: nc,
+    element: V_,
+    init: W_,
+    insert: ic,
+    mount_component: X_,
+    safe_not_equal: q_,
+    space: Y_,
+    transition_in: j_,
+    transition_out: K_
 } = window.__gradio__svelte__internal, {
-    onMount: H_
+    onMount: Z_
 } = window.__gradio__svelte__internal;
 
-function V_(i) {
-    let e, t, n, r;
-    return e = new co({
+function Q_(s) {
+    let e, t, n, i;
+    return e = new qa({
         props: {
             show_label: (
                 /*show_label*/
-                i[1]
+                s[1]
             ),
-            Icon: rs,
+            Icon: Lr,
             label: (
                 /*label*/
-                i[0] || /*i18n*/
-                i[2]("4DGS_model.splat")
+                s[0] || /*i18n*/
+                s[2]("4DGS_model.splat")
             )
         }
     }), {
         c() {
-            I_(e.$$.fragment), t = z_(), n = F_("div"), n.innerHTML = "", D_(n, "class", "model4DGS svelte-1jpyjlj");
+            H_(e.$$.fragment), t = Y_(), n = V_("div"), n.innerHTML = "", z_(n, "class", "model4DGS svelte-jfv6j3");
         },
-        m(s, a) {
-            B_(e, s, a), ul(s, t, a), ul(s, n, a), r = !0;
+        m(r, o) {
+            X_(e, r, o), ic(r, t, o), ic(r, n, o), i = !0;
         },
-        p(s, [a]) {
-            const o = {};
-            a & /*show_label*/
-                2 && (o.show_label = /*show_label*/
-                    s[1]), a & /*label, i18n*/
-                5 && (o.label = /*label*/
-                    s[0] || /*i18n*/
-                    s[2]("4DGS_model.splat")), e.$set(o);
+        p(r, [o]) {
+            const a = {};
+            o & /*show_label*/
+                2 && (a.show_label = /*show_label*/
+                    r[1]), o & /*label, i18n*/
+                5 && (a.label = /*label*/
+                    r[0] || /*i18n*/
+                    r[2]("4DGS_model.splat")), e.$set(a);
         },
-        i(s) {
-            r || (k_(e.$$.fragment, s), r = !0);
+        i(r) {
+            i || (j_(e.$$.fragment, r), i = !0);
         },
-        o(s) {
-            G_(e.$$.fragment, s), r = !1;
+        o(r) {
+            K_(e.$$.fragment, r), i = !1;
         },
-        d(s) {
-            s && (cl(t), cl(n)), U_(e, s);
+        d(r) {
+            r && (nc(t), nc(n)), G_(e, r);
         }
     };
 }
 
-function W_(i, e, t) {
+function J_(s, e, t) {
     let {
         value: n
     } = e, {
-        label: r = ""
+        root: i
+    } = e, {
+        proxy_url: r
+    } = e, {
+        label: o = ""
     } = e, {
-        show_label: s
+        show_label: a
     } = e, {
-        i18n: a
-    } = e, o = 0, l = 1;
-    var c = [];
-    const u = new P(1.25, 1.25, 1.25),
-        f = new P(0.01, 0.01, 0.01);
-    return H_(() => {
-        if (n != null) {
-            const h = document.querySelector(".model4DGS"),
-                p = new P_({
+        i18n: l
+    } = e, c = 0, u = 1;
+    var d = [];
+    const f = new D(1.25, 1.25, 1.25),
+        h = new D(0.01, 0.01, 0.01);
+    return Z_(() => {
+        if (n != null && n.files != null) {
+            const g = document.querySelector(".model4DGS"),
+                _ = new Va({
                     cameraUp: [0, 1, 0],
                     initialCameraPosition: [0, 0, 4],
                     initialCameraLookAt: [0, 0, -1],
                     dynamicScene: !0,
                     sharedMemoryForWorkers: !1,
-                    rootElement: h
+                    rootElement: g
                 });
-            l = n.length;
-            for (let g = 0; g < n.length; g++) {
+            u = n.files.length;
+            let m = n.files;
+            for (let p = 0; p < m.length; p++) {
                 let v = {
-                    // path: "@fs/data/home/cunjun/jwren/gradio-splatting/assets/tiger_4d_model_" + idx + ".ply",
-                    path: "@fs" + n[g].path,
-                    scale: [f, f, f]
+                    path: bc(m[p], i, r).url,
+                    scale: [h, h, h]
                 };
-                c.push(v);
+                d.push(v);
             }
-            p.addSplatScenes(c, !0).then(() => {
-                p.start();
-                let g = performance.now();
+            _.addSplatScenes(d, !0).then(() => {
+                _.start();
+                let p = performance.now();
                 requestAnimationFrame(v);
 
                 function v() {
-                    requestAnimationFrame(v), performance.now() - g > 100 && (p.getSplatScene(o).scale.copy(f), g = performance.now(), o++, o >= l && (o = 0), p.getSplatScene(o).scale.copy(u));
+                    requestAnimationFrame(v), performance.now() - p > 150 && (_.getSplatScene(c).scale.copy(h), p = performance.now(), c++, c >= u && (c = 0), _.getSplatScene(c).scale.copy(f));
                 }
             });
         }
-    }), i.$$set = (h) => {
-        "value" in h && t(3, n = h.value), "label" in h && t(0, r = h.label), "show_label" in h && t(1, s = h.show_label), "i18n" in h && t(2, a = h.i18n);
-    }, [r, s, a, n];
+    }), s.$$set = (g) => {
+        "value" in g && t(3, n = g.value), "root" in g && t(4, i = g.root), "proxy_url" in g && t(5, r = g.proxy_url), "label" in g && t(0, o = g.label), "show_label" in g && t(1, a = g.show_label), "i18n" in g && t(2, l = g.i18n);
+    }, [o, a, l, n, i, r];
 }
-class X_ extends L_ {
+class $_ extends k_ {
     constructor(e) {
-        super(), N_(this, e, W_, V_, O_, {
+        super(), W_(this, e, J_, Q_, q_, {
             value: 3,
+            root: 4,
+            proxy_url: 5,
             label: 0,
             show_label: 1,
             i18n: 2
         });
     }
 }
 
-function Ni(i) {
+function ts(s) {
     let e = ["", "k", "M", "G", "T", "P", "E", "Z"],
         t = 0;
-    for (; i > 1e3 && t < e.length - 1;)
-        i /= 1e3, t++;
+    for (; s > 1e3 && t < e.length - 1;)
+        s /= 1e3, t++;
     let n = e[t];
-    return (Number.isInteger(i) ? i : i.toFixed(1)) + n;
+    return (Number.isInteger(s) ? s : s.toFixed(1)) + n;
 }
 
-function Xr() {}
+function Sr() {}
 
-function q_(i, e) {
-    return i != i ? e == e : i !== e || i && typeof i == "object" || typeof i == "function";
+function eS(s, e) {
+    return s != s ? e == e : s !== e || s && typeof s == "object" || typeof s == "function";
 }
-const pc = typeof window < "u";
-let fl = pc ? () => window.performance.now() : () => Date.now(),
-    mc = pc ? (i) => requestAnimationFrame(i) : Xr;
-const Oi = /* @__PURE__ */ new Set();
+const lu = typeof window < "u";
+let sc = lu ? () => window.performance.now() : () => Date.now(),
+    cu = lu ? (s) => requestAnimationFrame(s) : Sr;
+const as = /* @__PURE__ */ new Set();
 
-function gc(i) {
-    Oi.forEach((e) => {
-        e.c(i) || (Oi.delete(e), e.f());
-    }), Oi.size !== 0 && mc(gc);
+function uu(s) {
+    as.forEach((e) => {
+        e.c(s) || (as.delete(e), e.f());
+    }), as.size !== 0 && cu(uu);
 }
 
-function Y_(i) {
+function tS(s) {
     let e;
-    return Oi.size === 0 && mc(gc), {
+    return as.size === 0 && cu(uu), {
         promise: new Promise((t) => {
-            Oi.add(e = {
-                c: i,
+            as.add(e = {
+                c: s,
                 f: t
             });
         }),
         abort() {
-            Oi.delete(e);
+            as.delete(e);
         }
     };
 }
-const Pi = [];
+const Yi = [];
 
-function j_(i, e = Xr) {
+function nS(s, e = Sr) {
     let t;
     const n = /* @__PURE__ */ new Set();
 
-    function r(o) {
-        if (q_(i, o) && (i = o, t)) {
-            const l = !Pi.length;
+    function i(a) {
+        if (eS(s, a) && (s = a, t)) {
+            const l = !Yi.length;
             for (const c of n)
-                c[1](), Pi.push(c, i);
+                c[1](), Yi.push(c, s);
             if (l) {
-                for (let c = 0; c < Pi.length; c += 2)
-                    Pi[c][0](Pi[c + 1]);
-                Pi.length = 0;
+                for (let c = 0; c < Yi.length; c += 2)
+                    Yi[c][0](Yi[c + 1]);
+                Yi.length = 0;
             }
         }
     }
 
-    function s(o) {
-        r(o(i));
+    function r(a) {
+        i(a(s));
     }
 
-    function a(o, l = Xr) {
-        const c = [o, l];
-        return n.add(c), n.size === 1 && (t = e(r, s) || Xr), o(i), () => {
+    function o(a, l = Sr) {
+        const c = [a, l];
+        return n.add(c), n.size === 1 && (t = e(i, r) || Sr), a(s), () => {
             n.delete(c), n.size === 0 && t && (t(), t = null);
         };
     }
     return {
-        set: r,
-        update: s,
-        subscribe: a
+        set: i,
+        update: r,
+        subscribe: o
     };
 }
 
-function hl(i) {
-    return Object.prototype.toString.call(i) === "[object Date]";
+function rc(s) {
+    return Object.prototype.toString.call(s) === "[object Date]";
 }
 
-function ao(i, e, t, n) {
-    if (typeof t == "number" || hl(t)) {
-        const r = n - t,
-            s = (t - e) / (i.dt || 1 / 60),
-            a = i.opts.stiffness * r,
-            o = i.opts.damping * s,
-            l = (a - o) * i.inv_mass,
-            c = (s + l) * i.dt;
-        return Math.abs(c) < i.opts.precision && Math.abs(r) < i.opts.precision ? n : (i.settled = !1, hl(t) ? new Date(t.getTime() + c) : t + c);
+function Wa(s, e, t, n) {
+    if (typeof t == "number" || rc(t)) {
+        const i = n - t,
+            r = (t - e) / (s.dt || 1 / 60),
+            o = s.opts.stiffness * i,
+            a = s.opts.damping * r,
+            l = (o - a) * s.inv_mass,
+            c = (r + l) * s.dt;
+        return Math.abs(c) < s.opts.precision && Math.abs(i) < s.opts.precision ? n : (s.settled = !1, rc(t) ? new Date(t.getTime() + c) : t + c);
     } else {
         if (Array.isArray(t))
             return t.map(
-                (r, s) => ao(i, e[s], t[s], n[s])
+                (i, r) => Wa(s, e[r], t[r], n[r])
             );
         if (typeof t == "object") {
-            const r = {};
-            for (const s in t)
-                r[s] = ao(i, e[s], t[s], n[s]);
-            return r;
+            const i = {};
+            for (const r in t)
+                i[r] = Wa(s, e[r], t[r], n[r]);
+            return i;
         } else
             throw new Error(`Cannot spring ${typeof t} values`);
     }
 }
 
-function dl(i, e = {}) {
-    const t = j_(i),
+function ac(s, e = {}) {
+    const t = nS(s),
         {
             stiffness: n = 0.15,
-            damping: r = 0.8,
-            precision: s = 0.01
+            damping: i = 0.8,
+            precision: r = 0.01
         } = e;
-    let a, o, l, c = i,
-        u = i,
-        f = 1,
-        h = 0,
-        p = !1;
+    let o, a, l, c = s,
+        u = s,
+        d = 1,
+        f = 0,
+        h = !1;
 
-    function g(m, d = {}) {
+    function g(m, p = {}) {
         u = m;
-        const M = l = {};
-        return i == null || d.hard || v.stiffness >= 1 && v.damping >= 1 ? (p = !0, a = fl(), c = m, t.set(i = u), Promise.resolve()) : (d.soft && (h = 1 / ((d.soft === !0 ? 0.5 : +d.soft) * 60), f = 0), o || (a = fl(), p = !1, o = Y_((_) => {
-            if (p)
-                return p = !1, o = null, !1;
-            f = Math.min(f + h, 1);
-            const A = {
-                    inv_mass: f,
-                    opts: v,
+        const v = l = {};
+        return s == null || p.hard || _.stiffness >= 1 && _.damping >= 1 ? (h = !0, o = sc(), c = m, t.set(s = u), Promise.resolve()) : (p.soft && (f = 1 / ((p.soft === !0 ? 0.5 : +p.soft) * 60), d = 0), a || (o = sc(), h = !1, a = tS((S) => {
+            if (h)
+                return h = !1, a = null, !1;
+            d = Math.min(d + f, 1);
+            const y = {
+                    inv_mass: d,
+                    opts: _,
                     settled: !0,
-                    dt: (_ - a) * 60 / 1e3
+                    dt: (S - o) * 60 / 1e3
                 },
-                R = ao(A, c, i, u);
-            return a = _, c = i, t.set(i = R), A.settled && (o = null), !A.settled;
-        })), new Promise((_) => {
-            o.promise.then(() => {
-                M === l && _();
+                b = Wa(y, c, s, u);
+            return o = S, c = s, t.set(s = b), y.settled && (a = null), !y.settled;
+        })), new Promise((S) => {
+            a.promise.then(() => {
+                v === l && S();
             });
         }));
     }
-    const v = {
+    const _ = {
         set: g,
-        update: (m, d) => g(m(u, i), d),
+        update: (m, p) => g(m(u, s), p),
         subscribe: t.subscribe,
         stiffness: n,
-        damping: r,
-        precision: s
+        damping: i,
+        precision: r
     };
-    return v;
+    return _;
 }
 const {
-    SvelteComponent: K_,
-    append: Zt,
-    attr: je,
-    component_subscribe: pl,
-    detach: Q_,
-    element: Z_,
-    init: J_,
-    insert: $_,
-    noop: ml,
-    safe_not_equal: e0,
-    set_style: Gr,
-    svg_element: Jt,
-    toggle_class: gl
+    SvelteComponent: iS,
+    append: ln,
+    attr: $e,
+    component_subscribe: oc,
+    detach: sS,
+    element: rS,
+    init: aS,
+    insert: oS,
+    noop: lc,
+    safe_not_equal: lS,
+    set_style: dr,
+    svg_element: cn,
+    toggle_class: cc
 } = window.__gradio__svelte__internal, {
-    onMount: t0
+    onMount: cS
 } = window.__gradio__svelte__internal;
 
-function n0(i) {
-    let e, t, n, r, s, a, o, l, c, u, f, h;
+function uS(s) {
+    let e, t, n, i, r, o, a, l, c, u, d, f;
     return {
         c() {
-            e = Z_("div"), t = Jt("svg"), n = Jt("g"), r = Jt("path"), s = Jt("path"), a = Jt("path"), o = Jt("path"), l = Jt("g"), c = Jt("path"), u = Jt("path"), f = Jt("path"), h = Jt("path"), je(r, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), je(r, "fill", "#FF7C00"), je(r, "fill-opacity", "0.4"), je(r, "class", "svelte-43sxxs"), je(s, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), je(s, "fill", "#FF7C00"), je(s, "class", "svelte-43sxxs"), je(a, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), je(a, "fill", "#FF7C00"), je(a, "fill-opacity", "0.4"), je(a, "class", "svelte-43sxxs"), je(o, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), je(o, "fill", "#FF7C00"), je(o, "class", "svelte-43sxxs"), Gr(n, "transform", "translate(" + /*$top*/
-                i[1][0] + "px, " + /*$top*/
-                i[1][1] + "px)"), je(c, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), je(c, "fill", "#FF7C00"), je(c, "fill-opacity", "0.4"), je(c, "class", "svelte-43sxxs"), je(u, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), je(u, "fill", "#FF7C00"), je(u, "class", "svelte-43sxxs"), je(f, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), je(f, "fill", "#FF7C00"), je(f, "fill-opacity", "0.4"), je(f, "class", "svelte-43sxxs"), je(h, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), je(h, "fill", "#FF7C00"), je(h, "class", "svelte-43sxxs"), Gr(l, "transform", "translate(" + /*$bottom*/
-                i[2][0] + "px, " + /*$bottom*/
-                i[2][1] + "px)"), je(t, "viewBox", "-1200 -1200 3000 3000"), je(t, "fill", "none"), je(t, "xmlns", "http://www.w3.org/2000/svg"), je(t, "class", "svelte-43sxxs"), je(e, "class", "svelte-43sxxs"), gl(
+            e = rS("div"), t = cn("svg"), n = cn("g"), i = cn("path"), r = cn("path"), o = cn("path"), a = cn("path"), l = cn("g"), c = cn("path"), u = cn("path"), d = cn("path"), f = cn("path"), $e(i, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), $e(i, "fill", "#FF7C00"), $e(i, "fill-opacity", "0.4"), $e(i, "class", "svelte-43sxxs"), $e(r, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), $e(r, "fill", "#FF7C00"), $e(r, "class", "svelte-43sxxs"), $e(o, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), $e(o, "fill", "#FF7C00"), $e(o, "fill-opacity", "0.4"), $e(o, "class", "svelte-43sxxs"), $e(a, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), $e(a, "fill", "#FF7C00"), $e(a, "class", "svelte-43sxxs"), dr(n, "transform", "translate(" + /*$top*/
+                s[1][0] + "px, " + /*$top*/
+                s[1][1] + "px)"), $e(c, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), $e(c, "fill", "#FF7C00"), $e(c, "fill-opacity", "0.4"), $e(c, "class", "svelte-43sxxs"), $e(u, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), $e(u, "fill", "#FF7C00"), $e(u, "class", "svelte-43sxxs"), $e(d, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), $e(d, "fill", "#FF7C00"), $e(d, "fill-opacity", "0.4"), $e(d, "class", "svelte-43sxxs"), $e(f, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), $e(f, "fill", "#FF7C00"), $e(f, "class", "svelte-43sxxs"), dr(l, "transform", "translate(" + /*$bottom*/
+                s[2][0] + "px, " + /*$bottom*/
+                s[2][1] + "px)"), $e(t, "viewBox", "-1200 -1200 3000 3000"), $e(t, "fill", "none"), $e(t, "xmlns", "http://www.w3.org/2000/svg"), $e(t, "class", "svelte-43sxxs"), $e(e, "class", "svelte-43sxxs"), cc(
                 e,
                 "margin",
                 /*margin*/
-                i[0]
+                s[0]
             );
         },
-        m(p, g) {
-            $_(p, e, g), Zt(e, t), Zt(t, n), Zt(n, r), Zt(n, s), Zt(n, a), Zt(n, o), Zt(t, l), Zt(l, c), Zt(l, u), Zt(l, f), Zt(l, h);
+        m(h, g) {
+            oS(h, e, g), ln(e, t), ln(t, n), ln(n, i), ln(n, r), ln(n, o), ln(n, a), ln(t, l), ln(l, c), ln(l, u), ln(l, d), ln(l, f);
         },
-        p(p, [g]) {
+        p(h, [g]) {
             g & /*$top*/
-                2 && Gr(n, "transform", "translate(" + /*$top*/
-                    p[1][0] + "px, " + /*$top*/
-                    p[1][1] + "px)"), g & /*$bottom*/
-                4 && Gr(l, "transform", "translate(" + /*$bottom*/
-                    p[2][0] + "px, " + /*$bottom*/
-                    p[2][1] + "px)"), g & /*margin*/
-                1 && gl(
+                2 && dr(n, "transform", "translate(" + /*$top*/
+                    h[1][0] + "px, " + /*$top*/
+                    h[1][1] + "px)"), g & /*$bottom*/
+                4 && dr(l, "transform", "translate(" + /*$bottom*/
+                    h[2][0] + "px, " + /*$bottom*/
+                    h[2][1] + "px)"), g & /*margin*/
+                1 && cc(
                     e,
                     "margin",
                     /*margin*/
-                    p[0]
+                    h[0]
                 );
         },
-        i: ml,
-        o: ml,
-        d(p) {
-            p && Q_(e);
+        i: lc,
+        o: lc,
+        d(h) {
+            h && sS(e);
         }
     };
 }
 
-function i0(i, e, t) {
-    let n, r, {
-        margin: s = !0
+function dS(s, e, t) {
+    let n, i;
+    var r = this && this.__awaiter || function(h, g, _, m) {
+        function p(v) {
+            return v instanceof _ ? v : new _(function(S) {
+                S(v);
+            });
+        }
+        return new(_ || (_ = Promise))(function(v, S) {
+            function y(T) {
+                try {
+                    E(m.next(T));
+                } catch (L) {
+                    S(L);
+                }
+            }
+
+            function b(T) {
+                try {
+                    E(m.throw(T));
+                } catch (L) {
+                    S(L);
+                }
+            }
+
+            function E(T) {
+                T.done ? v(T.value) : p(T.value).then(y, b);
+            }
+            E((m = m.apply(h, g || [])).next());
+        });
+    };
+    let {
+        margin: o = !0
     } = e;
-    const a = dl([0, 0]);
-    pl(i, a, (h) => t(1, n = h));
-    const o = dl([0, 0]);
-    pl(i, o, (h) => t(2, r = h));
-    let l;
-    async function c() {
-        await Promise.all([a.set([125, 140]), o.set([-125, -140])]), await Promise.all([a.set([-125, 140]), o.set([125, -140])]), await Promise.all([a.set([-125, 0]), o.set([125, -0])]), await Promise.all([a.set([125, 0]), o.set([-125, 0])]);
+    const a = ac([0, 0]);
+    oc(s, a, (h) => t(1, n = h));
+    const l = ac([0, 0]);
+    oc(s, l, (h) => t(2, i = h));
+    let c;
+
+    function u() {
+        return r(this, void 0, void 0, function*() {
+            yield Promise.all([a.set([125, 140]), l.set([-125, -140])]), yield Promise.all([a.set([-125, 140]), l.set([125, -140])]), yield Promise.all([a.set([-125, 0]), l.set([125, -0])]), yield Promise.all([a.set([125, 0]), l.set([-125, 0])]);
+        });
     }
-    async function u() {
-        await c(), l || u();
+
+    function d() {
+        return r(this, void 0, void 0, function*() {
+            yield u(), c || d();
+        });
     }
-    async function f() {
-        await Promise.all([a.set([125, 0]), o.set([-125, 0])]), u();
+
+    function f() {
+        return r(this, void 0, void 0, function*() {
+            yield Promise.all([a.set([125, 0]), l.set([-125, 0])]), d();
+        });
     }
-    return t0(() => (f(), () => l = !0)), i.$$set = (h) => {
-        "margin" in h && t(0, s = h.margin);
-    }, [s, n, r, a, o];
+    return cS(() => (f(), () => c = !0)), s.$$set = (h) => {
+        "margin" in h && t(0, o = h.margin);
+    }, [o, n, i, a, l];
 }
-class r0 extends K_ {
+class fS extends iS {
     constructor(e) {
-        super(), J_(this, e, i0, n0, e0, {
+        super(), aS(this, e, dS, uS, lS, {
             margin: 0
         });
     }
 }
 const {
-    SvelteComponent: s0,
-    append: ii,
-    attr: un,
-    binding_callbacks: _l,
-    check_outros: _c,
-    create_component: o0,
-    create_slot: a0,
-    destroy_component: l0,
-    destroy_each: vc,
-    detach: Ge,
-    element: yn,
-    empty: Ji,
-    ensure_array_like: ts,
-    get_all_dirty_from_scope: c0,
-    get_slot_changes: u0,
-    group_outros: xc,
-    init: f0,
-    insert: He,
-    mount_component: h0,
-    noop: lo,
-    safe_not_equal: d0,
-    set_data: qt,
-    set_style: On,
-    space: fn,
-    text: st,
-    toggle_class: Gt,
-    transition_in: Yi,
-    transition_out: ji,
-    update_slot_base: p0
+    SvelteComponent: hS,
+    append: _i,
+    attr: vn,
+    binding_callbacks: uc,
+    check_outros: du,
+    create_component: pS,
+    create_slot: mS,
+    destroy_component: gS,
+    destroy_each: fu,
+    detach: Xe,
+    element: Fn,
+    empty: Ss,
+    ensure_array_like: Cr,
+    get_all_dirty_from_scope: _S,
+    get_slot_changes: SS,
+    group_outros: hu,
+    init: vS,
+    insert: qe,
+    mount_component: xS,
+    noop: Xa,
+    safe_not_equal: yS,
+    set_data: nn,
+    set_style: Qn,
+    space: xn,
+    text: dt,
+    toggle_class: Jt,
+    transition_in: hs,
+    transition_out: ps,
+    update_slot_base: MS
 } = window.__gradio__svelte__internal, {
-    tick: m0
+    tick: ES
 } = window.__gradio__svelte__internal, {
-    onDestroy: g0
-} = window.__gradio__svelte__internal, _0 = (i) => ({}), vl = (i) => ({});
+    onDestroy: AS
+} = window.__gradio__svelte__internal, TS = (s) => ({}), dc = (s) => ({});
 
-function xl(i, e, t) {
-    const n = i.slice();
-    return n[38] = e[t], n[40] = t, n;
+function fc(s, e, t) {
+    const n = s.slice();
+    return n[39] = e[t], n[41] = t, n;
 }
 
-function Sl(i, e, t) {
-    const n = i.slice();
-    return n[38] = e[t], n;
+function hc(s, e, t) {
+    const n = s.slice();
+    return n[39] = e[t], n;
 }
 
-function v0(i) {
+function bS(s) {
     let e, t = (
             /*i18n*/
-            i[1]("common.error") + ""
+            s[1]("common.error") + ""
         ),
-        n, r, s;
-    const a = (
+        n, i, r;
+    const o = (
             /*#slots*/
-            i[29].error
+            s[29].error
         ),
-        o = a0(
-            a,
-            i,
+        a = mS(
+            o,
+            s,
             /*$$scope*/
-            i[28],
-            vl
+            s[28],
+            dc
         );
     return {
         c() {
-            e = yn("span"), n = st(t), r = fn(), o && o.c(), un(e, "class", "error svelte-1yserjw");
+            e = Fn("span"), n = dt(t), i = xn(), a && a.c(), vn(e, "class", "error svelte-1txqlrd");
         },
         m(l, c) {
-            He(l, e, c), ii(e, n), He(l, r, c), o && o.m(l, c), s = !0;
+            qe(l, e, c), _i(e, n), qe(l, i, c), a && a.m(l, c), r = !0;
         },
         p(l, c) {
-            (!s || c[0] & /*i18n*/
+            (!r || c[0] & /*i18n*/
                 2) && t !== (t = /*i18n*/
-                l[1]("common.error") + "") && qt(n, t), o && o.p && (!s || c[0] & /*$$scope*/
-                268435456) && p0(
-                o,
+                l[1]("common.error") + "") && nn(n, t), a && a.p && (!r || c[0] & /*$$scope*/
+                268435456) && MS(
                 a,
+                o,
                 l,
                 /*$$scope*/
                 l[28],
-                s ? u0(
-                    a,
+                r ? SS(
+                    o,
                     /*$$scope*/
                     l[28],
                     c,
-                    _0
-                ) : c0(
+                    TS
+                ) : _S(
                     /*$$scope*/
                     l[28]
                 ),
-                vl
+                dc
             );
         },
         i(l) {
-            s || (Yi(o, l), s = !0);
+            r || (hs(a, l), r = !0);
         },
         o(l) {
-            ji(o, l), s = !1;
+            ps(a, l), r = !1;
         },
         d(l) {
-            l && (Ge(e), Ge(r)), o && o.d(l);
+            l && (Xe(e), Xe(i)), a && a.d(l);
         }
     };
 }
 
-function x0(i) {
-    let e, t, n, r, s, a, o, l, c, u = (
+function CS(s) {
+    let e, t, n, i, r, o, a, l, c, u = (
         /*variant*/
-        i[8] === "default" && /*show_eta_bar*/
-        i[18] && /*show_progress*/
-        i[6] === "full" && Ml(i)
+        s[8] === "default" && /*show_eta_bar*/
+        s[18] && /*show_progress*/
+        s[6] === "full" && pc(s)
     );
 
-    function f(_, A) {
+    function d(S, y) {
         if (
             /*progress*/
-            _[7]
+            S[7]
         )
-            return y0;
+            return PS;
         if (
             /*queue_position*/
-            _[2] !== null && /*queue_size*/
-            _[3] !== void 0 && /*queue_position*/
-            _[2] >= 0
+            S[2] !== null && /*queue_size*/
+            S[3] !== void 0 && /*queue_position*/
+            S[2] >= 0
         )
-            return M0;
+            return RS;
         if (
             /*queue_position*/
-            _[2] === 0
+            S[2] === 0
         )
-            return S0;
+            return wS;
     }
-    let h = f(i),
-        p = h && h(i),
+    let f = d(s),
+        h = f && f(s),
         g = (
             /*timer*/
-            i[5] && El(i)
+            s[5] && _c(s)
         );
-    const v = [T0, b0],
+    const _ = [IS, FS],
         m = [];
 
-    function d(_, A) {
+    function p(S, y) {
         return (
             /*last_progress_level*/
-            _[15] != null ? 0 : (
+            S[15] != null ? 0 : (
                 /*show_progress*/
-                _[6] === "full" ? 1 : -1
+                S[6] === "full" ? 1 : -1
             )
         );
     }
-    ~(s = d(i)) && (a = m[s] = v[s](i));
-    let M = ! /*timer*/
-        i[5] && Ll(i);
+    ~(r = p(s)) && (o = m[r] = _[r](s));
+    let v = ! /*timer*/
+        s[5] && Ac(s);
     return {
         c() {
-            u && u.c(), e = fn(), t = yn("div"), p && p.c(), n = fn(), g && g.c(), r = fn(), a && a.c(), o = fn(), M && M.c(), l = Ji(), un(t, "class", "progress-text svelte-1yserjw"), Gt(
+            u && u.c(), e = xn(), t = Fn("div"), h && h.c(), n = xn(), g && g.c(), i = xn(), o && o.c(), a = xn(), v && v.c(), l = Ss(), vn(t, "class", "progress-text svelte-1txqlrd"), Jt(
                 t,
                 "meta-text-center",
                 /*variant*/
-                i[8] === "center"
-            ), Gt(
+                s[8] === "center"
+            ), Jt(
                 t,
                 "meta-text",
                 /*variant*/
-                i[8] === "default"
+                s[8] === "default"
             );
         },
-        m(_, A) {
-            u && u.m(_, A), He(_, e, A), He(_, t, A), p && p.m(t, null), ii(t, n), g && g.m(t, null), He(_, r, A), ~s && m[s].m(_, A), He(_, o, A), M && M.m(_, A), He(_, l, A), c = !0;
+        m(S, y) {
+            u && u.m(S, y), qe(S, e, y), qe(S, t, y), h && h.m(t, null), _i(t, n), g && g.m(t, null), qe(S, i, y), ~r && m[r].m(S, y), qe(S, a, y), v && v.m(S, y), qe(S, l, y), c = !0;
         },
-        p(_, A) {
+        p(S, y) {
             /*variant*/
-            _[8] === "default" && /*show_eta_bar*/
-                _[18] && /*show_progress*/
-                _[6] === "full" ? u ? u.p(_, A) : (u = Ml(_), u.c(), u.m(e.parentNode, e)) : u && (u.d(1), u = null), h === (h = f(_)) && p ? p.p(_, A) : (p && p.d(1), p = h && h(_), p && (p.c(), p.m(t, n))), /*timer*/
-                _[5] ? g ? g.p(_, A) : (g = El(_), g.c(), g.m(t, null)) : g && (g.d(1), g = null), (!c || A[0] & /*variant*/
-                    256) && Gt(
+            S[8] === "default" && /*show_eta_bar*/
+                S[18] && /*show_progress*/
+                S[6] === "full" ? u ? u.p(S, y) : (u = pc(S), u.c(), u.m(e.parentNode, e)) : u && (u.d(1), u = null), f === (f = d(S)) && h ? h.p(S, y) : (h && h.d(1), h = f && f(S), h && (h.c(), h.m(t, n))), /*timer*/
+                S[5] ? g ? g.p(S, y) : (g = _c(S), g.c(), g.m(t, null)) : g && (g.d(1), g = null), (!c || y[0] & /*variant*/
+                    256) && Jt(
                     t,
                     "meta-text-center",
                     /*variant*/
-                    _[8] === "center"
-                ), (!c || A[0] & /*variant*/
-                    256) && Gt(
+                    S[8] === "center"
+                ), (!c || y[0] & /*variant*/
+                    256) && Jt(
                     t,
                     "meta-text",
                     /*variant*/
-                    _[8] === "default"
+                    S[8] === "default"
                 );
-            let R = s;
-            s = d(_), s === R ? ~s && m[s].p(_, A) : (a && (xc(), ji(m[R], 1, 1, () => {
-                    m[R] = null;
-                }), _c()), ~s ? (a = m[s], a ? a.p(_, A) : (a = m[s] = v[s](_), a.c()), Yi(a, 1), a.m(o.parentNode, o)) : a = null), /*timer*/
-                _[5] ? M && (M.d(1), M = null) : M ? M.p(_, A) : (M = Ll(_), M.c(), M.m(l.parentNode, l));
+            let b = r;
+            r = p(S), r === b ? ~r && m[r].p(S, y) : (o && (hu(), ps(m[b], 1, 1, () => {
+                    m[b] = null;
+                }), du()), ~r ? (o = m[r], o ? o.p(S, y) : (o = m[r] = _[r](S), o.c()), hs(o, 1), o.m(a.parentNode, a)) : o = null), /*timer*/
+                S[5] ? v && (v.d(1), v = null) : v ? v.p(S, y) : (v = Ac(S), v.c(), v.m(l.parentNode, l));
         },
-        i(_) {
-            c || (Yi(a), c = !0);
+        i(S) {
+            c || (hs(o), c = !0);
         },
-        o(_) {
-            ji(a), c = !1;
+        o(S) {
+            ps(o), c = !1;
         },
-        d(_) {
-            _ && (Ge(e), Ge(t), Ge(r), Ge(o), Ge(l)), u && u.d(_), p && p.d(), g && g.d(), ~s && m[s].d(_), M && M.d(_);
+        d(S) {
+            S && (Xe(e), Xe(t), Xe(i), Xe(a), Xe(l)), u && u.d(S), h && h.d(), g && g.d(), ~r && m[r].d(S), v && v.d(S);
         }
     };
 }
 
-function Ml(i) {
+function pc(s) {
     let e, t = `translateX(${/*eta_level*/
-  (i[17] || 0) * 100 - 100}%)`;
+  (s[17] || 0) * 100 - 100}%)`;
     return {
         c() {
-            e = yn("div"), un(e, "class", "eta-bar svelte-1yserjw"), On(e, "transform", t);
+            e = Fn("div"), vn(e, "class", "eta-bar svelte-1txqlrd"), Qn(e, "transform", t);
         },
-        m(n, r) {
-            He(n, e, r);
+        m(n, i) {
+            qe(n, e, i);
         },
-        p(n, r) {
-            r[0] & /*eta_level*/
+        p(n, i) {
+            i[0] & /*eta_level*/
                 131072 && t !== (t = `translateX(${/*eta_level*/
-      (n[17] || 0) * 100 - 100}%)`) && On(e, "transform", t);
+      (n[17] || 0) * 100 - 100}%)`) && Qn(e, "transform", t);
         },
         d(n) {
-            n && Ge(e);
+            n && Xe(e);
         }
     };
 }
 
-function S0(i) {
+function wS(s) {
     let e;
     return {
         c() {
-            e = st("processing |");
+            e = dt("processing |");
         },
         m(t, n) {
-            He(t, e, n);
+            qe(t, e, n);
         },
-        p: lo,
+        p: Xa,
         d(t) {
-            t && Ge(e);
+            t && Xe(e);
         }
     };
 }
 
-function M0(i) {
+function RS(s) {
     let e, t = (
             /*queue_position*/
-            i[2] + 1 + ""
+            s[2] + 1 + ""
         ),
-        n, r, s, a;
+        n, i, r, o;
     return {
         c() {
-            e = st("queue: "), n = st(t), r = st("/"), s = st(
+            e = dt("queue: "), n = dt(t), i = dt("/"), r = dt(
                 /*queue_size*/
-                i[3]
-            ), a = st(" |");
+                s[3]
+            ), o = dt(" |");
         },
-        m(o, l) {
-            He(o, e, l), He(o, n, l), He(o, r, l), He(o, s, l), He(o, a, l);
+        m(a, l) {
+            qe(a, e, l), qe(a, n, l), qe(a, i, l), qe(a, r, l), qe(a, o, l);
         },
-        p(o, l) {
+        p(a, l) {
             l[0] & /*queue_position*/
                 4 && t !== (t = /*queue_position*/
-                    o[2] + 1 + "") && qt(n, t), l[0] & /*queue_size*/
-                8 && qt(
-                    s,
+                    a[2] + 1 + "") && nn(n, t), l[0] & /*queue_size*/
+                8 && nn(
+                    r,
                     /*queue_size*/
-                    o[3]
+                    a[3]
                 );
         },
-        d(o) {
-            o && (Ge(e), Ge(n), Ge(r), Ge(s), Ge(a));
+        d(a) {
+            a && (Xe(e), Xe(n), Xe(i), Xe(r), Xe(o));
         }
     };
 }
 
-function y0(i) {
-    let e, t = ts(
+function PS(s) {
+    let e, t = Cr(
             /*progress*/
-            i[7]
+            s[7]
         ),
         n = [];
-    for (let r = 0; r < t.length; r += 1)
-        n[r] = Al(Sl(i, t, r));
+    for (let i = 0; i < t.length; i += 1)
+        n[i] = gc(hc(s, t, i));
     return {
         c() {
-            for (let r = 0; r < n.length; r += 1)
-                n[r].c();
-            e = Ji();
-        },
-        m(r, s) {
-            for (let a = 0; a < n.length; a += 1)
-                n[a] && n[a].m(r, s);
-            He(r, e, s);
+            for (let i = 0; i < n.length; i += 1)
+                n[i].c();
+            e = Ss();
+        },
+        m(i, r) {
+            for (let o = 0; o < n.length; o += 1)
+                n[o] && n[o].m(i, r);
+            qe(i, e, r);
         },
-        p(r, s) {
-            if (s[0] & /*progress*/
+        p(i, r) {
+            if (r[0] & /*progress*/
                 128) {
-                t = ts(
+                t = Cr(
                     /*progress*/
-                    r[7]
+                    i[7]
                 );
-                let a;
-                for (a = 0; a < t.length; a += 1) {
-                    const o = Sl(r, t, a);
-                    n[a] ? n[a].p(o, s) : (n[a] = Al(o), n[a].c(), n[a].m(e.parentNode, e));
+                let o;
+                for (o = 0; o < t.length; o += 1) {
+                    const a = hc(i, t, o);
+                    n[o] ? n[o].p(a, r) : (n[o] = gc(a), n[o].c(), n[o].m(e.parentNode, e));
                 }
-                for (; a < n.length; a += 1)
-                    n[a].d(1);
+                for (; o < n.length; o += 1)
+                    n[o].d(1);
                 n.length = t.length;
             }
         },
-        d(r) {
-            r && Ge(e), vc(n, r);
+        d(i) {
+            i && Xe(e), fu(n, i);
         }
     };
 }
 
-function yl(i) {
+function mc(s) {
     let e, t = (
             /*p*/
-            i[38].unit + ""
+            s[39].unit + ""
         ),
-        n, r, s = " ",
-        a;
+        n, i, r = " ",
+        o;
 
-    function o(u, f) {
+    function a(u, d) {
         return (
             /*p*/
-            u[38].length != null ? E0 : A0
+            u[39].length != null ? LS : DS
         );
     }
-    let l = o(i),
-        c = l(i);
+    let l = a(s),
+        c = l(s);
     return {
         c() {
-            c.c(), e = fn(), n = st(t), r = st(" | "), a = st(s);
+            c.c(), e = xn(), n = dt(t), i = dt(" | "), o = dt(r);
         },
-        m(u, f) {
-            c.m(u, f), He(u, e, f), He(u, n, f), He(u, r, f), He(u, a, f);
+        m(u, d) {
+            c.m(u, d), qe(u, e, d), qe(u, n, d), qe(u, i, d), qe(u, o, d);
         },
-        p(u, f) {
-            l === (l = o(u)) && c ? c.p(u, f) : (c.d(1), c = l(u), c && (c.c(), c.m(e.parentNode, e))), f[0] & /*progress*/
+        p(u, d) {
+            l === (l = a(u)) && c ? c.p(u, d) : (c.d(1), c = l(u), c && (c.c(), c.m(e.parentNode, e))), d[0] & /*progress*/
                 128 && t !== (t = /*p*/
-                    u[38].unit + "") && qt(n, t);
+                    u[39].unit + "") && nn(n, t);
         },
         d(u) {
-            u && (Ge(e), Ge(n), Ge(r), Ge(a)), c.d(u);
+            u && (Xe(e), Xe(n), Xe(i), Xe(o)), c.d(u);
         }
     };
 }
 
-function A0(i) {
-    let e = Ni(
+function DS(s) {
+    let e = ts(
             /*p*/
-            i[38].index || 0
+            s[39].index || 0
         ) + "",
         t;
     return {
         c() {
-            t = st(e);
+            t = dt(e);
         },
-        m(n, r) {
-            He(n, t, r);
+        m(n, i) {
+            qe(n, t, i);
         },
-        p(n, r) {
-            r[0] & /*progress*/
-                128 && e !== (e = Ni(
+        p(n, i) {
+            i[0] & /*progress*/
+                128 && e !== (e = ts(
                     /*p*/
-                    n[38].index || 0
-                ) + "") && qt(t, e);
+                    n[39].index || 0
+                ) + "") && nn(t, e);
         },
         d(n) {
-            n && Ge(t);
+            n && Xe(t);
         }
     };
 }
 
-function E0(i) {
-    let e = Ni(
+function LS(s) {
+    let e = ts(
             /*p*/
-            i[38].index || 0
+            s[39].index || 0
         ) + "",
-        t, n, r = Ni(
+        t, n, i = ts(
             /*p*/
-            i[38].length
+            s[39].length
         ) + "",
-        s;
+        r;
     return {
         c() {
-            t = st(e), n = st("/"), s = st(r);
+            t = dt(e), n = dt("/"), r = dt(i);
         },
-        m(a, o) {
-            He(a, t, o), He(a, n, o), He(a, s, o);
+        m(o, a) {
+            qe(o, t, a), qe(o, n, a), qe(o, r, a);
         },
-        p(a, o) {
-            o[0] & /*progress*/
-                128 && e !== (e = Ni(
+        p(o, a) {
+            a[0] & /*progress*/
+                128 && e !== (e = ts(
                     /*p*/
-                    a[38].index || 0
-                ) + "") && qt(t, e), o[0] & /*progress*/
-                128 && r !== (r = Ni(
+                    o[39].index || 0
+                ) + "") && nn(t, e), a[0] & /*progress*/
+                128 && i !== (i = ts(
                     /*p*/
-                    a[38].length
-                ) + "") && qt(s, r);
+                    o[39].length
+                ) + "") && nn(r, i);
         },
-        d(a) {
-            a && (Ge(t), Ge(n), Ge(s));
+        d(o) {
+            o && (Xe(t), Xe(n), Xe(r));
         }
     };
 }
 
-function Al(i) {
+function gc(s) {
     let e, t = (
         /*p*/
-        i[38].index != null && yl(i)
+        s[39].index != null && mc(s)
     );
     return {
         c() {
-            t && t.c(), e = Ji();
+            t && t.c(), e = Ss();
         },
-        m(n, r) {
-            t && t.m(n, r), He(n, e, r);
+        m(n, i) {
+            t && t.m(n, i), qe(n, e, i);
         },
-        p(n, r) {
+        p(n, i) {
             /*p*/
-            n[38].index != null ? t ? t.p(n, r) : (t = yl(n), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
+            n[39].index != null ? t ? t.p(n, i) : (t = mc(n), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
         },
         d(n) {
-            n && Ge(e), t && t.d(n);
+            n && Xe(e), t && t.d(n);
         }
     };
 }
 
-function El(i) {
+function _c(s) {
     let e, t = (
             /*eta*/
-            i[0] ? `/${/*formatted_eta*/
-    i[19]}` : ""
+            s[0] ? `/${/*formatted_eta*/
+    s[19]}` : ""
         ),
-        n, r;
+        n, i;
     return {
         c() {
-            e = st(
+            e = dt(
                 /*formatted_timer*/
-                i[20]
-            ), n = st(t), r = st("s");
+                s[20]
+            ), n = dt(t), i = dt("s");
         },
-        m(s, a) {
-            He(s, e, a), He(s, n, a), He(s, r, a);
+        m(r, o) {
+            qe(r, e, o), qe(r, n, o), qe(r, i, o);
         },
-        p(s, a) {
-            a[0] & /*formatted_timer*/
-                1048576 && qt(
+        p(r, o) {
+            o[0] & /*formatted_timer*/
+                1048576 && nn(
                     e,
                     /*formatted_timer*/
-                    s[20]
-                ), a[0] & /*eta, formatted_eta*/
+                    r[20]
+                ), o[0] & /*eta, formatted_eta*/
                 524289 && t !== (t = /*eta*/
-                    s[0] ? `/${/*formatted_eta*/
-      s[19]}` : "") && qt(n, t);
+                    r[0] ? `/${/*formatted_eta*/
+      r[19]}` : "") && nn(n, t);
         },
-        d(s) {
-            s && (Ge(e), Ge(n), Ge(r));
+        d(r) {
+            r && (Xe(e), Xe(n), Xe(i));
         }
     };
 }
 
-function b0(i) {
+function FS(s) {
     let e, t;
-    return e = new r0({
+    return e = new fS({
         props: {
             margin: (
                 /*variant*/
-                i[8] === "default"
+                s[8] === "default"
             )
         }
     }), {
         c() {
-            o0(e.$$.fragment);
+            pS(e.$$.fragment);
         },
-        m(n, r) {
-            h0(e, n, r), t = !0;
+        m(n, i) {
+            xS(e, n, i), t = !0;
         },
-        p(n, r) {
-            const s = {};
-            r[0] & /*variant*/
-                256 && (s.margin = /*variant*/
-                    n[8] === "default"), e.$set(s);
+        p(n, i) {
+            const r = {};
+            i[0] & /*variant*/
+                256 && (r.margin = /*variant*/
+                    n[8] === "default"), e.$set(r);
         },
         i(n) {
-            t || (Yi(e.$$.fragment, n), t = !0);
+            t || (hs(e.$$.fragment, n), t = !0);
         },
         o(n) {
-            ji(e.$$.fragment, n), t = !1;
+            ps(e.$$.fragment, n), t = !1;
         },
         d(n) {
-            l0(e, n);
+            gS(e, n);
         }
     };
 }
 
-function T0(i) {
-    let e, t, n, r, s, a = `${/*last_progress_level*/
-  i[15] * 100}%`,
-        o = (
+function IS(s) {
+    let e, t, n, i, r, o = `${/*last_progress_level*/
+  s[15] * 100}%`,
+        a = (
             /*progress*/
-            i[7] != null && bl(i)
+            s[7] != null && Sc(s)
         );
     return {
         c() {
-            e = yn("div"), t = yn("div"), o && o.c(), n = fn(), r = yn("div"), s = yn("div"), un(t, "class", "progress-level-inner svelte-1yserjw"), un(s, "class", "progress-bar svelte-1yserjw"), On(s, "width", a), un(r, "class", "progress-bar-wrap svelte-1yserjw"), un(e, "class", "progress-level svelte-1yserjw");
+            e = Fn("div"), t = Fn("div"), a && a.c(), n = xn(), i = Fn("div"), r = Fn("div"), vn(t, "class", "progress-level-inner svelte-1txqlrd"), vn(r, "class", "progress-bar svelte-1txqlrd"), Qn(r, "width", o), vn(i, "class", "progress-bar-wrap svelte-1txqlrd"), vn(e, "class", "progress-level svelte-1txqlrd");
         },
         m(l, c) {
-            He(l, e, c), ii(e, t), o && o.m(t, null), ii(e, n), ii(e, r), ii(r, s), i[30](s);
+            qe(l, e, c), _i(e, t), a && a.m(t, null), _i(e, n), _i(e, i), _i(i, r), s[30](r);
         },
         p(l, c) {
             /*progress*/
-            l[7] != null ? o ? o.p(l, c) : (o = bl(l), o.c(), o.m(t, null)) : o && (o.d(1), o = null), c[0] & /*last_progress_level*/
-                32768 && a !== (a = `${/*last_progress_level*/
-      l[15] * 100}%`) && On(s, "width", a);
+            l[7] != null ? a ? a.p(l, c) : (a = Sc(l), a.c(), a.m(t, null)) : a && (a.d(1), a = null), c[0] & /*last_progress_level*/
+                32768 && o !== (o = `${/*last_progress_level*/
+      l[15] * 100}%`) && Qn(r, "width", o);
         },
-        i: lo,
-        o: lo,
+        i: Xa,
+        o: Xa,
         d(l) {
-            l && Ge(e), o && o.d(), i[30](null);
+            l && Xe(e), a && a.d(), s[30](null);
         }
     };
 }
 
-function bl(i) {
-    let e, t = ts(
+function Sc(s) {
+    let e, t = Cr(
             /*progress*/
-            i[7]
+            s[7]
         ),
         n = [];
-    for (let r = 0; r < t.length; r += 1)
-        n[r] = Pl(xl(i, t, r));
+    for (let i = 0; i < t.length; i += 1)
+        n[i] = Ec(fc(s, t, i));
     return {
         c() {
-            for (let r = 0; r < n.length; r += 1)
-                n[r].c();
-            e = Ji();
-        },
-        m(r, s) {
-            for (let a = 0; a < n.length; a += 1)
-                n[a] && n[a].m(r, s);
-            He(r, e, s);
+            for (let i = 0; i < n.length; i += 1)
+                n[i].c();
+            e = Ss();
+        },
+        m(i, r) {
+            for (let o = 0; o < n.length; o += 1)
+                n[o] && n[o].m(i, r);
+            qe(i, e, r);
         },
-        p(r, s) {
-            if (s[0] & /*progress_level, progress*/
+        p(i, r) {
+            if (r[0] & /*progress_level, progress*/
                 16512) {
-                t = ts(
+                t = Cr(
                     /*progress*/
-                    r[7]
+                    i[7]
                 );
-                let a;
-                for (a = 0; a < t.length; a += 1) {
-                    const o = xl(r, t, a);
-                    n[a] ? n[a].p(o, s) : (n[a] = Pl(o), n[a].c(), n[a].m(e.parentNode, e));
+                let o;
+                for (o = 0; o < t.length; o += 1) {
+                    const a = fc(i, t, o);
+                    n[o] ? n[o].p(a, r) : (n[o] = Ec(a), n[o].c(), n[o].m(e.parentNode, e));
                 }
-                for (; a < n.length; a += 1)
-                    n[a].d(1);
+                for (; o < n.length; o += 1)
+                    n[o].d(1);
                 n.length = t.length;
             }
         },
-        d(r) {
-            r && Ge(e), vc(n, r);
+        d(i) {
+            i && Xe(e), fu(n, i);
         }
     };
 }
 
-function Tl(i) {
-    let e, t, n, r, s = (
+function vc(s) {
+    let e, t, n, i, r = (
             /*i*/
-            i[40] !== 0 && w0()
+            s[41] !== 0 && US()
         ),
-        a = (
+        o = (
             /*p*/
-            i[38].desc != null && wl(i)
+            s[39].desc != null && xc(s)
         ),
-        o = (
+        a = (
             /*p*/
-            i[38].desc != null && /*progress_level*/
-            i[14] && /*progress_level*/
-            i[14][
+            s[39].desc != null && /*progress_level*/
+            s[14] && /*progress_level*/
+            s[14][
                 /*i*/
-                i[40]
-            ] != null && Cl()
+                s[41]
+            ] != null && yc()
         ),
         l = (
             /*progress_level*/
-            i[14] != null && Rl(i)
+            s[14] != null && Mc(s)
         );
     return {
         c() {
-            s && s.c(), e = fn(), a && a.c(), t = fn(), o && o.c(), n = fn(), l && l.c(), r = Ji();
+            r && r.c(), e = xn(), o && o.c(), t = xn(), a && a.c(), n = xn(), l && l.c(), i = Ss();
         },
         m(c, u) {
-            s && s.m(c, u), He(c, e, u), a && a.m(c, u), He(c, t, u), o && o.m(c, u), He(c, n, u), l && l.m(c, u), He(c, r, u);
+            r && r.m(c, u), qe(c, e, u), o && o.m(c, u), qe(c, t, u), a && a.m(c, u), qe(c, n, u), l && l.m(c, u), qe(c, i, u);
         },
         p(c, u) {
             /*p*/
-            c[38].desc != null ? a ? a.p(c, u) : (a = wl(c), a.c(), a.m(t.parentNode, t)) : a && (a.d(1), a = null), /*p*/
-                c[38].desc != null && /*progress_level*/
+            c[39].desc != null ? o ? o.p(c, u) : (o = xc(c), o.c(), o.m(t.parentNode, t)) : o && (o.d(1), o = null), /*p*/
+                c[39].desc != null && /*progress_level*/
                 c[14] && /*progress_level*/
                 c[14][
                     /*i*/
-                    c[40]
-                ] != null ? o || (o = Cl(), o.c(), o.m(n.parentNode, n)) : o && (o.d(1), o = null), /*progress_level*/
-                c[14] != null ? l ? l.p(c, u) : (l = Rl(c), l.c(), l.m(r.parentNode, r)) : l && (l.d(1), l = null);
+                    c[41]
+                ] != null ? a || (a = yc(), a.c(), a.m(n.parentNode, n)) : a && (a.d(1), a = null), /*progress_level*/
+                c[14] != null ? l ? l.p(c, u) : (l = Mc(c), l.c(), l.m(i.parentNode, i)) : l && (l.d(1), l = null);
         },
         d(c) {
-            c && (Ge(e), Ge(t), Ge(n), Ge(r)), s && s.d(c), a && a.d(c), o && o.d(c), l && l.d(c);
+            c && (Xe(e), Xe(t), Xe(n), Xe(i)), r && r.d(c), o && o.d(c), a && a.d(c), l && l.d(c);
         }
     };
 }
 
-function w0(i) {
+function US(s) {
     let e;
     return {
         c() {
-            e = st(" /");
+            e = dt(" /");
         },
         m(t, n) {
-            He(t, e, n);
+            qe(t, e, n);
         },
         d(t) {
-            t && Ge(e);
+            t && Xe(e);
         }
     };
 }
 
-function wl(i) {
+function xc(s) {
     let e = (
             /*p*/
-            i[38].desc + ""
+            s[39].desc + ""
         ),
         t;
     return {
         c() {
-            t = st(e);
+            t = dt(e);
         },
-        m(n, r) {
-            He(n, t, r);
+        m(n, i) {
+            qe(n, t, i);
         },
-        p(n, r) {
-            r[0] & /*progress*/
+        p(n, i) {
+            i[0] & /*progress*/
                 128 && e !== (e = /*p*/
-                    n[38].desc + "") && qt(t, e);
+                    n[39].desc + "") && nn(t, e);
         },
         d(n) {
-            n && Ge(t);
+            n && Xe(t);
         }
     };
 }
 
-function Cl(i) {
+function yc(s) {
     let e;
     return {
         c() {
-            e = st("-");
+            e = dt("-");
         },
         m(t, n) {
-            He(t, e, n);
+            qe(t, e, n);
         },
         d(t) {
-            t && Ge(e);
+            t && Xe(e);
         }
     };
 }
 
-function Rl(i) {
+function Mc(s) {
     let e = (100 * /*progress_level*/
-            (i[14][
+            (s[14][
                 /*i*/
-                i[40]
+                s[41]
             ] || 0)).toFixed(1) + "",
         t, n;
     return {
         c() {
-            t = st(e), n = st("%");
+            t = dt(e), n = dt("%");
         },
-        m(r, s) {
-            He(r, t, s), He(r, n, s);
+        m(i, r) {
+            qe(i, t, r), qe(i, n, r);
         },
-        p(r, s) {
-            s[0] & /*progress_level*/
+        p(i, r) {
+            r[0] & /*progress_level*/
                 16384 && e !== (e = (100 * /*progress_level*/
-                    (r[14][
+                    (i[14][
                         /*i*/
-                        r[40]
-                    ] || 0)).toFixed(1) + "") && qt(t, e);
+                        i[41]
+                    ] || 0)).toFixed(1) + "") && nn(t, e);
         },
-        d(r) {
-            r && (Ge(t), Ge(n));
+        d(i) {
+            i && (Xe(t), Xe(n));
         }
     };
 }
 
-function Pl(i) {
+function Ec(s) {
     let e, t = (
         /*p*/
-        (i[38].desc != null || /*progress_level*/
-            i[14] && /*progress_level*/
-            i[14][
+        (s[39].desc != null || /*progress_level*/
+            s[14] && /*progress_level*/
+            s[14][
                 /*i*/
-                i[40]
-            ] != null) && Tl(i)
+                s[41]
+            ] != null) && vc(s)
     );
     return {
         c() {
-            t && t.c(), e = Ji();
+            t && t.c(), e = Ss();
         },
-        m(n, r) {
-            t && t.m(n, r), He(n, e, r);
+        m(n, i) {
+            t && t.m(n, i), qe(n, e, i);
         },
-        p(n, r) {
+        p(n, i) {
             /*p*/
-            n[38].desc != null || /*progress_level*/
+            n[39].desc != null || /*progress_level*/
                 n[14] && /*progress_level*/
                 n[14][
                     /*i*/
-                    n[40]
-                ] != null ? t ? t.p(n, r) : (t = Tl(n), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
+                    n[41]
+                ] != null ? t ? t.p(n, i) : (t = vc(n), t.c(), t.m(e.parentNode, e)) : t && (t.d(1), t = null);
         },
         d(n) {
-            n && Ge(e), t && t.d(n);
+            n && Xe(e), t && t.d(n);
         }
     };
 }
 
-function Ll(i) {
+function Ac(s) {
     let e, t;
     return {
         c() {
-            e = yn("p"), t = st(
+            e = Fn("p"), t = dt(
                 /*loading_text*/
-                i[9]
-            ), un(e, "class", "loading svelte-1yserjw");
+                s[9]
+            ), vn(e, "class", "loading svelte-1txqlrd");
         },
-        m(n, r) {
-            He(n, e, r), ii(e, t);
+        m(n, i) {
+            qe(n, e, i), _i(e, t);
         },
-        p(n, r) {
-            r[0] & /*loading_text*/
-                512 && qt(
+        p(n, i) {
+            i[0] & /*loading_text*/
+                512 && nn(
                     t,
                     /*loading_text*/
                     n[9]
                 );
         },
         d(n) {
-            n && Ge(e);
+            n && Xe(e);
         }
     };
 }
 
-function C0(i) {
-    let e, t, n, r, s;
-    const a = [x0, v0],
-        o = [];
+function BS(s) {
+    let e, t, n, i, r;
+    const o = [CS, bS],
+        a = [];
 
     function l(c, u) {
         return (
             /*status*/
             c[4] === "pending" ? 0 : (
                 /*status*/
                 c[4] === "error" ? 1 : -1
             )
         );
     }
-    return ~(t = l(i)) && (n = o[t] = a[t](i)), {
+    return ~(t = l(s)) && (n = a[t] = o[t](s)), {
         c() {
-            e = yn("div"), n && n.c(), un(e, "class", r = "wrap " + /*variant*/
-                i[8] + " " + /*show_progress*/
-                i[6] + " svelte-1yserjw"), Gt(e, "hide", ! /*status*/
-                i[4] || /*status*/
-                i[4] === "complete" || /*show_progress*/
-                i[6] === "hidden"), Gt(
+            e = Fn("div"), n && n.c(), vn(e, "class", i = "wrap " + /*variant*/
+                s[8] + " " + /*show_progress*/
+                s[6] + " svelte-1txqlrd"), Jt(e, "hide", ! /*status*/
+                s[4] || /*status*/
+                s[4] === "complete" || /*show_progress*/
+                s[6] === "hidden"), Jt(
                 e,
                 "translucent",
                 /*variant*/
-                i[8] === "center" && /*status*/
-                (i[4] === "pending" || /*status*/
-                    i[4] === "error") || /*translucent*/
-                i[11] || /*show_progress*/
-                i[6] === "minimal"
-            ), Gt(
+                s[8] === "center" && /*status*/
+                (s[4] === "pending" || /*status*/
+                    s[4] === "error") || /*translucent*/
+                s[11] || /*show_progress*/
+                s[6] === "minimal"
+            ), Jt(
                 e,
                 "generating",
                 /*status*/
-                i[4] === "generating"
-            ), Gt(
+                s[4] === "generating"
+            ), Jt(
                 e,
                 "border",
                 /*border*/
-                i[12]
-            ), On(
+                s[12]
+            ), Qn(
                 e,
                 "position",
                 /*absolute*/
-                i[10] ? "absolute" : "static"
-            ), On(
+                s[10] ? "absolute" : "static"
+            ), Qn(
                 e,
                 "padding",
                 /*absolute*/
-                i[10] ? "0" : "var(--size-8) 0"
+                s[10] ? "0" : "var(--size-8) 0"
             );
         },
         m(c, u) {
-            He(c, e, u), ~t && o[t].m(e, null), i[31](e), s = !0;
+            qe(c, e, u), ~t && a[t].m(e, null), s[31](e), r = !0;
         },
         p(c, u) {
-            let f = t;
-            t = l(c), t === f ? ~t && o[t].p(c, u) : (n && (xc(), ji(o[f], 1, 1, () => {
-                    o[f] = null;
-                }), _c()), ~t ? (n = o[t], n ? n.p(c, u) : (n = o[t] = a[t](c), n.c()), Yi(n, 1), n.m(e, null)) : n = null), (!s || u[0] & /*variant, show_progress*/
-                    320 && r !== (r = "wrap " + /*variant*/
+            let d = t;
+            t = l(c), t === d ? ~t && a[t].p(c, u) : (n && (hu(), ps(a[d], 1, 1, () => {
+                    a[d] = null;
+                }), du()), ~t ? (n = a[t], n ? n.p(c, u) : (n = a[t] = o[t](c), n.c()), hs(n, 1), n.m(e, null)) : n = null), (!r || u[0] & /*variant, show_progress*/
+                    320 && i !== (i = "wrap " + /*variant*/
                         c[8] + " " + /*show_progress*/
-                        c[6] + " svelte-1yserjw")) && un(e, "class", r), (!s || u[0] & /*variant, show_progress, status, show_progress*/
-                    336) && Gt(e, "hide", ! /*status*/
+                        c[6] + " svelte-1txqlrd")) && vn(e, "class", i), (!r || u[0] & /*variant, show_progress, status, show_progress*/
+                    336) && Jt(e, "hide", ! /*status*/
                     c[4] || /*status*/
                     c[4] === "complete" || /*show_progress*/
-                    c[6] === "hidden"), (!s || u[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
-                    2384) && Gt(
+                    c[6] === "hidden"), (!r || u[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
+                    2384) && Jt(
                     e,
                     "translucent",
                     /*variant*/
                     c[8] === "center" && /*status*/
                     (c[4] === "pending" || /*status*/
                         c[4] === "error") || /*translucent*/
                     c[11] || /*show_progress*/
                     c[6] === "minimal"
-                ), (!s || u[0] & /*variant, show_progress, status*/
-                    336) && Gt(
+                ), (!r || u[0] & /*variant, show_progress, status*/
+                    336) && Jt(
                     e,
                     "generating",
                     /*status*/
                     c[4] === "generating"
-                ), (!s || u[0] & /*variant, show_progress, border*/
-                    4416) && Gt(
+                ), (!r || u[0] & /*variant, show_progress, border*/
+                    4416) && Jt(
                     e,
                     "border",
                     /*border*/
                     c[12]
                 ), u[0] & /*absolute*/
-                1024 && On(
+                1024 && Qn(
                     e,
                     "position",
                     /*absolute*/
                     c[10] ? "absolute" : "static"
                 ), u[0] & /*absolute*/
-                1024 && On(
+                1024 && Qn(
                     e,
                     "padding",
                     /*absolute*/
                     c[10] ? "0" : "var(--size-8) 0"
                 );
         },
         i(c) {
-            s || (Yi(n), s = !0);
+            r || (hs(n), r = !0);
         },
         o(c) {
-            ji(n), s = !1;
+            ps(n), r = !1;
         },
         d(c) {
-            c && Ge(e), ~t && o[t].d(), i[31](null);
+            c && Xe(e), ~t && a[t].d(), s[31](null);
         }
     };
 }
-let Hr = [],
-    Js = !1;
-async function R0(i, e = !0) {
-    if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && e !== !0)) {
-        if (Hr.push(i), !Js)
-            Js = !0;
-        else
-            return;
-        await m0(), requestAnimationFrame(() => {
-            let t = [0, 0];
-            for (let n = 0; n < Hr.length; n++) {
-                const s = Hr[n].getBoundingClientRect();
-                (n === 0 || s.top + window.scrollY <= t[0]) && (t[0] = s.top + window.scrollY, t[1] = n);
-            }
-            window.scrollTo({
-                top: t[0] - 20,
-                behavior: "smooth"
-            }), Js = !1, Hr = [];
+var OS = function(s, e, t, n) {
+    function i(r) {
+        return r instanceof t ? r : new t(function(o) {
+            o(r);
         });
     }
+    return new(t || (t = Promise))(function(r, o) {
+        function a(u) {
+            try {
+                c(n.next(u));
+            } catch (d) {
+                o(d);
+            }
+        }
+
+        function l(u) {
+            try {
+                c(n.throw(u));
+            } catch (d) {
+                o(d);
+            }
+        }
+
+        function c(u) {
+            u.done ? r(u.value) : i(u.value).then(a, l);
+        }
+        c((n = n.apply(s, e || [])).next());
+    });
+};
+let fr = [],
+    La = !1;
+
+function NS(s) {
+    return OS(this, arguments, void 0, function*(e, t = !0) {
+        if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && t !== !0)) {
+            if (fr.push(e), !La)
+                La = !0;
+            else
+                return;
+            yield ES(), requestAnimationFrame(() => {
+                let n = [0, 0];
+                for (let i = 0; i < fr.length; i++) {
+                    const o = fr[i].getBoundingClientRect();
+                    (i === 0 || o.top + window.scrollY <= n[0]) && (n[0] = o.top + window.scrollY, n[1] = i);
+                }
+                window.scrollTo({
+                    top: n[0] - 20,
+                    behavior: "smooth"
+                }), La = !1, fr = [];
+            });
+        }
+    });
 }
 
-function P0(i, e, t) {
+function kS(s, e, t) {
     let n, {
-            $$slots: r = {},
-            $$scope: s
-        } = e,
-        {
-            i18n: a
-        } = e,
-        {
-            eta: o = null
-        } = e,
-        {
-            queue_position: l
-        } = e,
-        {
-            queue_size: c
-        } = e,
-        {
-            status: u
-        } = e,
-        {
-            scroll_to_output: f = !1
-        } = e,
-        {
-            timer: h = !0
-        } = e,
-        {
-            show_progress: p = "full"
-        } = e,
-        {
-            message: g = null
-        } = e,
-        {
-            progress: v = null
-        } = e,
-        {
-            variant: m = "default"
-        } = e,
-        {
-            loading_text: d = "Loading..."
-        } = e,
-        {
-            absolute: M = !0
-        } = e,
-        {
-            translucent: _ = !1
-        } = e,
-        {
-            border: A = !1
-        } = e,
-        {
-            autoscroll: R
-        } = e,
-        E, b = !1,
-        I = 0,
-        W = 0,
-        S = null,
-        T = null,
-        Y = 0,
-        K = null,
-        L, N = null,
-        O = !0;
-    const B = () => {
-        t(0, o = t(26, S = t(19, J = null))), t(24, I = performance.now()), t(25, W = 0), b = !0, j();
+        $$slots: i = {},
+        $$scope: r
+    } = e;
+    this && this.__awaiter;
+    let {
+        i18n: o
+    } = e, {
+        eta: a = null
+    } = e, {
+        queue_position: l
+    } = e, {
+        queue_size: c
+    } = e, {
+        status: u
+    } = e, {
+        scroll_to_output: d = !1
+    } = e, {
+        timer: f = !0
+    } = e, {
+        show_progress: h = "full"
+    } = e, {
+        message: g = null
+    } = e, {
+        progress: _ = null
+    } = e, {
+        variant: m = "default"
+    } = e, {
+        loading_text: p = "Loading..."
+    } = e, {
+        absolute: v = !0
+    } = e, {
+        translucent: S = !1
+    } = e, {
+        border: y = !1
+    } = e, {
+        autoscroll: b
+    } = e, E, T = !1, L = 0, B = 0, x = null, A = null, U = 0, N = null, P, I = null, z = !0;
+    const K = () => {
+        t(0, a = t(26, x = t(19, Q = null))), t(24, L = performance.now()), t(25, B = 0), T = !0, G();
     };
 
-    function j() {
+    function G() {
         requestAnimationFrame(() => {
-            t(25, W = (performance.now() - I) / 1e3), b && j();
+            t(25, B = (performance.now() - L) / 1e3), T && G();
         });
     }
 
     function q() {
-        t(25, W = 0), t(0, o = t(26, S = t(19, J = null))), b && (b = !1);
+        t(25, B = 0), t(0, a = t(26, x = t(19, Q = null))), T && (T = !1);
     }
-    g0(() => {
-        b && q();
+    AS(() => {
+        T && q();
     });
-    let J = null;
+    let Q = null;
 
-    function ne(Z) {
-        _l[Z ? "unshift" : "push"](() => {
-            N = Z, t(16, N), t(7, v), t(14, K), t(15, L);
+    function te(ne) {
+        uc[ne ? "unshift" : "push"](() => {
+            I = ne, t(16, I), t(7, _), t(14, N), t(15, P);
         });
     }
 
-    function ue(Z) {
-        _l[Z ? "unshift" : "push"](() => {
-            E = Z, t(13, E);
+    function fe(ne) {
+        uc[ne ? "unshift" : "push"](() => {
+            E = ne, t(13, E);
         });
     }
-    return i.$$set = (Z) => {
-        "i18n" in Z && t(1, a = Z.i18n), "eta" in Z && t(0, o = Z.eta), "queue_position" in Z && t(2, l = Z.queue_position), "queue_size" in Z && t(3, c = Z.queue_size), "status" in Z && t(4, u = Z.status), "scroll_to_output" in Z && t(21, f = Z.scroll_to_output), "timer" in Z && t(5, h = Z.timer), "show_progress" in Z && t(6, p = Z.show_progress), "message" in Z && t(22, g = Z.message), "progress" in Z && t(7, v = Z.progress), "variant" in Z && t(8, m = Z.variant), "loading_text" in Z && t(9, d = Z.loading_text), "absolute" in Z && t(10, M = Z.absolute), "translucent" in Z && t(11, _ = Z.translucent), "border" in Z && t(12, A = Z.border), "autoscroll" in Z && t(23, R = Z.autoscroll), "$$scope" in Z && t(28, s = Z.$$scope);
-    }, i.$$.update = () => {
-        i.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
-            218103809 && (o === null && t(0, o = S), o != null && S !== o && (t(27, T = (performance.now() - I) / 1e3 + o), t(19, J = T.toFixed(1)), t(26, S = o))), i.$$.dirty[0] & /*eta_from_start, timer_diff*/
-            167772160 && t(17, Y = T === null || T <= 0 || !W ? null : Math.min(W / T, 1)), i.$$.dirty[0] & /*progress*/
-            128 && v != null && t(18, O = !1), i.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
-            114816 && (v != null ? t(14, K = v.map((Z) => {
-                if (Z.index != null && Z.length != null)
-                    return Z.index / Z.length;
-                if (Z.progress != null)
-                    return Z.progress;
-            })) : t(14, K = null), K ? (t(15, L = K[K.length - 1]), N && (L === 0 ? t(16, N.style.transition = "0", N) : t(16, N.style.transition = "150ms", N))) : t(15, L = void 0)), i.$$.dirty[0] & /*status*/
-            16 && (u === "pending" ? B() : q()), i.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
-            10493968 && E && f && (u === "pending" || u === "complete") && R0(E, R), i.$$.dirty[0] & /*status, message*/
-            4194320, i.$$.dirty[0] & /*timer_diff*/
-            33554432 && t(20, n = W.toFixed(1));
+    return s.$$set = (ne) => {
+        "i18n" in ne && t(1, o = ne.i18n), "eta" in ne && t(0, a = ne.eta), "queue_position" in ne && t(2, l = ne.queue_position), "queue_size" in ne && t(3, c = ne.queue_size), "status" in ne && t(4, u = ne.status), "scroll_to_output" in ne && t(21, d = ne.scroll_to_output), "timer" in ne && t(5, f = ne.timer), "show_progress" in ne && t(6, h = ne.show_progress), "message" in ne && t(22, g = ne.message), "progress" in ne && t(7, _ = ne.progress), "variant" in ne && t(8, m = ne.variant), "loading_text" in ne && t(9, p = ne.loading_text), "absolute" in ne && t(10, v = ne.absolute), "translucent" in ne && t(11, S = ne.translucent), "border" in ne && t(12, y = ne.border), "autoscroll" in ne && t(23, b = ne.autoscroll), "$$scope" in ne && t(28, r = ne.$$scope);
+    }, s.$$.update = () => {
+        s.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
+            218103809 && (a === null && t(0, a = x), a != null && x !== a && (t(27, A = (performance.now() - L) / 1e3 + a), t(19, Q = A.toFixed(1)), t(26, x = a))), s.$$.dirty[0] & /*eta_from_start, timer_diff*/
+            167772160 && t(17, U = A === null || A <= 0 || !B ? null : Math.min(B / A, 1)), s.$$.dirty[0] & /*progress*/
+            128 && _ != null && t(18, z = !1), s.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
+            114816 && (_ != null ? t(14, N = _.map((ne) => {
+                if (ne.index != null && ne.length != null)
+                    return ne.index / ne.length;
+                if (ne.progress != null)
+                    return ne.progress;
+            })) : t(14, N = null), N ? (t(15, P = N[N.length - 1]), I && (P === 0 ? t(16, I.style.transition = "0", I) : t(16, I.style.transition = "150ms", I))) : t(15, P = void 0)), s.$$.dirty[0] & /*status*/
+            16 && (u === "pending" ? K() : q()), s.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
+            10493968 && E && d && (u === "pending" || u === "complete") && NS(E, b), s.$$.dirty[0] & /*status, message*/
+            4194320, s.$$.dirty[0] & /*timer_diff*/
+            33554432 && t(20, n = B.toFixed(1));
     }, [
-        o,
         a,
+        o,
         l,
         c,
         u,
+        f,
         h,
+        _,
+        m,
         p,
         v,
-        m,
-        d,
-        M,
-        _,
-        A,
+        S,
+        y,
         E,
-        K,
-        L,
         N,
-        Y,
-        O,
-        J,
+        P,
+        I,
+        U,
+        z,
+        Q,
         n,
-        f,
+        d,
         g,
-        R,
-        I,
-        W,
-        S,
-        T,
-        s,
+        b,
+        L,
+        B,
+        x,
+        A,
         r,
-        ne,
-        ue
+        i,
+        te,
+        fe
     ];
 }
-class L0 extends s0 {
+class zS extends hS {
     constructor(e) {
-        super(), f0(
+        super(), vS(
             this,
             e,
-            P0,
-            C0,
-            d0, {
+            kS,
+            BS,
+            yS, {
                 i18n: 1,
                 eta: 0,
                 queue_position: 2,
                 queue_size: 3,
                 status: 4,
                 scroll_to_output: 21,
                 timer: 5,
@@ -22584,518 +25631,540 @@
             },
             null,
             [-1, -1]
         );
     }
 }
 const {
-    SvelteComponent: D0,
-    append: I0,
-    attr: U0,
-    detach: F0,
-    element: N0,
-    init: B0,
-    insert: O0,
-    noop: Dl,
-    safe_not_equal: z0,
-    set_data: k0,
-    text: G0,
-    toggle_class: Li
+    SvelteComponent: HS,
+    append: GS,
+    attr: VS,
+    detach: WS,
+    element: XS,
+    init: qS,
+    insert: YS,
+    noop: Tc,
+    safe_not_equal: jS,
+    set_data: KS,
+    text: ZS,
+    toggle_class: ji
 } = window.__gradio__svelte__internal;
 
-function H0(i) {
+function QS(s) {
     let e, t;
     return {
         c() {
-            e = N0("div"), t = G0(
+            e = XS("div"), t = ZS(
                 /*value*/
-                i[0]
-            ), U0(e, "class", "svelte-1gecy8w"), Li(
+                s[0]
+            ), VS(e, "class", "svelte-1gecy8w"), ji(
                 e,
                 "table",
                 /*type*/
-                i[1] === "table"
-            ), Li(
+                s[1] === "table"
+            ), ji(
                 e,
                 "gallery",
                 /*type*/
-                i[1] === "gallery"
-            ), Li(
+                s[1] === "gallery"
+            ), ji(
                 e,
                 "selected",
                 /*selected*/
-                i[2]
+                s[2]
             );
         },
-        m(n, r) {
-            O0(n, e, r), I0(e, t);
+        m(n, i) {
+            YS(n, e, i), GS(e, t);
         },
-        p(n, [r]) {
-            r & /*value*/
-                1 && k0(
+        p(n, [i]) {
+            i & /*value*/
+                1 && KS(
                     t,
                     /*value*/
                     n[0]
-                ), r & /*type*/
-                2 && Li(
+                ), i & /*type*/
+                2 && ji(
                     e,
                     "table",
                     /*type*/
                     n[1] === "table"
-                ), r & /*type*/
-                2 && Li(
+                ), i & /*type*/
+                2 && ji(
                     e,
                     "gallery",
                     /*type*/
                     n[1] === "gallery"
-                ), r & /*selected*/
-                4 && Li(
+                ), i & /*selected*/
+                4 && ji(
                     e,
                     "selected",
                     /*selected*/
                     n[2]
                 );
         },
-        i: Dl,
-        o: Dl,
+        i: Tc,
+        o: Tc,
         d(n) {
-            n && F0(e);
+            n && WS(e);
         }
     };
 }
 
-function V0(i, e, t) {
+function JS(s, e, t) {
     let {
         value: n
     } = e, {
-        type: r
+        type: i
     } = e, {
-        selected: s = !1
+        selected: r = !1
     } = e;
-    return i.$$set = (a) => {
-        "value" in a && t(0, n = a.value), "type" in a && t(1, r = a.type), "selected" in a && t(2, s = a.selected);
-    }, [n, r, s];
+    return s.$$set = (o) => {
+        "value" in o && t(0, n = o.value), "type" in o && t(1, i = o.type), "selected" in o && t(2, r = o.selected);
+    }, [n, i, r];
 }
-class av extends D0 {
+class vv extends HS {
     constructor(e) {
-        super(), B0(this, e, V0, H0, z0, {
+        super(), qS(this, e, JS, QS, jS, {
             value: 0,
             type: 1,
             selected: 2
         });
     }
 }
 const {
-    SvelteComponent: W0,
-    assign: X0,
-    check_outros: q0,
-    create_component: ai,
-    destroy_component: li,
-    detach: ns,
-    empty: Y0,
-    get_spread_object: j0,
-    get_spread_update: K0,
-    group_outros: Q0,
-    init: Z0,
-    insert: is,
-    mount_component: ci,
-    safe_not_equal: J0,
-    space: yo,
-    transition_in: An,
-    transition_out: En
+    SvelteComponent: $S,
+    add_flush_callback: ev,
+    assign: tv,
+    bind: nv,
+    binding_callbacks: iv,
+    check_outros: sv,
+    create_component: Mi,
+    destroy_component: Ei,
+    detach: wr,
+    empty: rv,
+    get_spread_object: av,
+    get_spread_update: ov,
+    group_outros: lv,
+    init: cv,
+    insert: Rr,
+    mount_component: Ai,
+    safe_not_equal: uv,
+    space: co,
+    transition_in: Bn,
+    transition_out: On
 } = window.__gradio__svelte__internal;
 
-function $0(i) {
-    let e, t, n, r;
-    return e = new co({
+function dv(s) {
+    let e, t, n, i;
+    return e = new qa({
         props: {
             show_label: (
                 /*show_label*/
-                i[6]
+                s[8]
             ),
-            Icon: rs,
+            Icon: Lr,
             label: (
                 /*label*/
-                i[5] || "Splat"
+                s[7] || "Splat"
             )
         }
-    }), n = new Su({
+    }), n = new md({
         props: {
             unpadded_box: !0,
             size: "large",
             $$slots: {
-                default: [tv]
+                default: [hv]
             },
             $$scope: {
-                ctx: i
+                ctx: s
             }
         }
     }), {
         c() {
-            ai(e.$$.fragment), t = yo(), ai(n.$$.fragment);
+            Mi(e.$$.fragment), t = co(), Mi(n.$$.fragment);
         },
-        m(s, a) {
-            ci(e, s, a), is(s, t, a), ci(n, s, a), r = !0;
+        m(r, o) {
+            Ai(e, r, o), Rr(r, t, o), Ai(n, r, o), i = !0;
         },
-        p(s, a) {
-            const o = {};
-            a & /*show_label*/
-                64 && (o.show_label = /*show_label*/
-                    s[6]), a & /*label*/
-                32 && (o.label = /*label*/
-                    s[5] || "Splat"), e.$set(o);
+        p(r, o) {
+            const a = {};
+            o & /*show_label*/
+                256 && (a.show_label = /*show_label*/
+                    r[8]), o & /*label*/
+                128 && (a.label = /*label*/
+                    r[7] || "Splat"), e.$set(a);
             const l = {};
-            a & /*$$scope*/
+            o & /*$$scope*/
                 32768 && (l.$$scope = {
-                    dirty: a,
-                    ctx: s
+                    dirty: o,
+                    ctx: r
                 }), n.$set(l);
         },
-        i(s) {
-            r || (An(e.$$.fragment, s), An(n.$$.fragment, s), r = !0);
+        i(r) {
+            i || (Bn(e.$$.fragment, r), Bn(n.$$.fragment, r), i = !0);
         },
-        o(s) {
-            En(e.$$.fragment, s), En(n.$$.fragment, s), r = !1;
+        o(r) {
+            On(e.$$.fragment, r), On(n.$$.fragment, r), i = !1;
         },
-        d(s) {
-            s && ns(t), li(e, s), li(n, s);
+        d(r) {
+            r && wr(t), Ei(e, r), Ei(n, r);
         }
     };
 }
 
-function ev(i) {
-    let e, t, n, r;
-    return e = new co({
+function fv(s) {
+    let e, t, n, i, r;
+    e = new qa({
         props: {
             show_label: (
                 /*show_label*/
-                i[6]
-            ),
-            Icon: rs,
-            label: (
-                /*label*/
-                i[5] || "Splat"
-            )
-        }
-    }), n = new X_({
-        props: {
-            value: (
-                /*_value*/
-                i[12]
-            ),
-            i18n: (
-                /*gradio*/
-                i[10].i18n
+                s[8]
             ),
+            Icon: Lr,
             label: (
                 /*label*/
-                i[5]
-            ),
-            show_label: (
-                /*show_label*/
-                i[6]
+                s[7] || "Splat"
             )
         }
-    }), {
-        c() {
-            ai(e.$$.fragment), t = yo(), ai(n.$$.fragment);
-        },
-        m(s, a) {
-            ci(e, s, a), is(s, t, a), ci(n, s, a), r = !0;
-        },
-        p(s, a) {
-            const o = {};
-            a & /*show_label*/
-                64 && (o.show_label = /*show_label*/
-                    s[6]), a & /*label*/
-                32 && (o.label = /*label*/
-                    s[5] || "Splat"), e.$set(o);
-            const l = {};
-            a & /*_value*/
-                4096 && (l.value = /*_value*/
-                    s[12]), a & /*gradio*/
-                1024 && (l.i18n = /*gradio*/
-                    s[10].i18n), a & /*label*/
-                32 && (l.label = /*label*/
-                    s[5]), a & /*show_label*/
-                64 && (l.show_label = /*show_label*/
-                    s[6]), n.$set(l);
-        },
-        i(s) {
-            r || (An(e.$$.fragment, s), An(n.$$.fragment, s), r = !0);
-        },
-        o(s) {
-            En(e.$$.fragment, s), En(n.$$.fragment, s), r = !1;
-        },
-        d(s) {
-            s && ns(t), li(e, s), li(n, s);
-        }
+    });
+
+    function o(l) {
+        s[14](l);
+    }
+    let a = {
+        i18n: (
+            /*gradio*/
+            s[12].i18n
+        ),
+        label: (
+            /*label*/
+            s[7]
+        ),
+        show_label: (
+            /*show_label*/
+            s[8]
+        ),
+        root: (
+            /*root*/
+            s[4]
+        ),
+        proxy_url: (
+            /*proxy_url*/
+            s[5]
+        )
     };
+    return (
+        /*value*/
+        s[0] !== void 0 && (a.value = /*value*/
+            s[0]), n = new $_({
+            props: a
+        }), iv.push(() => nv(n, "value", o)), {
+            c() {
+                Mi(e.$$.fragment), t = co(), Mi(n.$$.fragment);
+            },
+            m(l, c) {
+                Ai(e, l, c), Rr(l, t, c), Ai(n, l, c), r = !0;
+            },
+            p(l, c) {
+                const u = {};
+                c & /*show_label*/
+                    256 && (u.show_label = /*show_label*/
+                        l[8]), c & /*label*/
+                    128 && (u.label = /*label*/
+                        l[7] || "Splat"), e.$set(u);
+                const d = {};
+                c & /*gradio*/
+                    4096 && (d.i18n = /*gradio*/
+                        l[12].i18n), c & /*label*/
+                    128 && (d.label = /*label*/
+                        l[7]), c & /*show_label*/
+                    256 && (d.show_label = /*show_label*/
+                        l[8]), c & /*root*/
+                    16 && (d.root = /*root*/
+                        l[4]), c & /*proxy_url*/
+                    32 && (d.proxy_url = /*proxy_url*/
+                        l[5]), !i && c & /*value*/
+                    1 && (i = !0, d.value = /*value*/
+                        l[0], ev(() => i = !1)), n.$set(d);
+            },
+            i(l) {
+                r || (Bn(e.$$.fragment, l), Bn(n.$$.fragment, l), r = !0);
+            },
+            o(l) {
+                On(e.$$.fragment, l), On(n.$$.fragment, l), r = !1;
+            },
+            d(l) {
+                l && wr(t), Ei(e, l), Ei(n, l);
+            }
+        }
+    );
 }
 
-function tv(i) {
+function hv(s) {
     let e, t;
-    return e = new rs({}), {
+    return e = new Lr({}), {
         c() {
-            ai(e.$$.fragment);
+            Mi(e.$$.fragment);
         },
-        m(n, r) {
-            ci(e, n, r), t = !0;
+        m(n, i) {
+            Ai(e, n, i), t = !0;
         },
         i(n) {
-            t || (An(e.$$.fragment, n), t = !0);
+            t || (Bn(e.$$.fragment, n), t = !0);
         },
         o(n) {
-            En(e.$$.fragment, n), t = !1;
+            On(e.$$.fragment, n), t = !1;
         },
         d(n) {
-            li(e, n);
+            Ei(e, n);
         }
     };
 }
 
-function nv(i) {
-    let e, t, n, r, s, a;
-    const o = [{
+function pv(s) {
+    let e, t, n, i, r, o;
+    const a = [{
             autoscroll: (
                 /*gradio*/
-                i[10].autoscroll
+                s[12].autoscroll
             )
         }, {
             i18n: (
                 /*gradio*/
-                i[10].i18n
+                s[12].i18n
             )
         },
         /*loading_status*/
-        i[4]
+        s[6]
     ];
     let l = {};
-    for (let h = 0; h < o.length; h += 1)
-        l = X0(l, o[h]);
-    e = new L0({
+    for (let f = 0; f < a.length; f += 1)
+        l = tv(l, a[f]);
+    e = new zS({
         props: l
     });
-    const c = [ev, $0],
+    const c = [fv, dv],
         u = [];
 
-    function f(h, p) {
+    function d(f, h) {
         return (
             /*value*/
-            h[3] ? 0 : 1
+            f[0] ? 0 : 1
         );
     }
-    return n = f(i), r = u[n] = c[n](i), {
+    return n = d(s), i = u[n] = c[n](s), {
         c() {
-            ai(e.$$.fragment), t = yo(), r.c(), s = Y0();
+            Mi(e.$$.fragment), t = co(), i.c(), r = rv();
         },
-        m(h, p) {
-            ci(e, h, p), is(h, t, p), u[n].m(h, p), is(h, s, p), a = !0;
+        m(f, h) {
+            Ai(e, f, h), Rr(f, t, h), u[n].m(f, h), Rr(f, r, h), o = !0;
         },
-        p(h, p) {
-            const g = p & /*gradio, loading_status*/
-                1040 ? K0(o, [
-                    p & /*gradio*/
-                    1024 && {
+        p(f, h) {
+            const g = h & /*gradio, loading_status*/
+                4160 ? ov(a, [
+                    h & /*gradio*/
+                    4096 && {
                         autoscroll: (
                             /*gradio*/
-                            h[10].autoscroll
+                            f[12].autoscroll
                         )
                     },
-                    p & /*gradio*/
-                    1024 && {
+                    h & /*gradio*/
+                    4096 && {
                         i18n: (
                             /*gradio*/
-                            h[10].i18n
+                            f[12].i18n
                         )
                     },
-                    p & /*loading_status*/
-                    16 && j0(
+                    h & /*loading_status*/
+                    64 && av(
                         /*loading_status*/
-                        h[4]
+                        f[6]
                     )
                 ]) : {};
             e.$set(g);
-            let v = n;
-            n = f(h), n === v ? u[n].p(h, p) : (Q0(), En(u[v], 1, 1, () => {
-                u[v] = null;
-            }), q0(), r = u[n], r ? r.p(h, p) : (r = u[n] = c[n](h), r.c()), An(r, 1), r.m(s.parentNode, s));
+            let _ = n;
+            n = d(f), n === _ ? u[n].p(f, h) : (lv(), On(u[_], 1, 1, () => {
+                u[_] = null;
+            }), sv(), i = u[n], i ? i.p(f, h) : (i = u[n] = c[n](f), i.c()), Bn(i, 1), i.m(r.parentNode, r));
         },
-        i(h) {
-            a || (An(e.$$.fragment, h), An(r), a = !0);
+        i(f) {
+            o || (Bn(e.$$.fragment, f), Bn(i), o = !0);
         },
-        o(h) {
-            En(e.$$.fragment, h), En(r), a = !1;
+        o(f) {
+            On(e.$$.fragment, f), On(i), o = !1;
         },
-        d(h) {
-            h && (ns(t), ns(s)), li(e, h), u[n].d(h);
+        d(f) {
+            f && (wr(t), wr(r)), Ei(e, f), u[n].d(f);
         }
     };
 }
 
-function iv(i) {
+function mv(s) {
     let e, t;
-    return e = new Hc({
+    return e = new Nu({
         props: {
             visible: (
                 /*visible*/
-                i[2]
+                s[3]
             ),
             variant: (
                 /*value*/
-                i[3] === null ? "dashed" : "solid"
+                s[0] === null ? "dashed" : "solid"
             ),
             border_mode: "base",
             padding: !1,
             elem_id: (
                 /*elem_id*/
-                i[0]
+                s[1]
             ),
             elem_classes: (
                 /*elem_classes*/
-                i[1]
+                s[2]
             ),
             container: (
                 /*container*/
-                i[7]
+                s[9]
             ),
             scale: (
                 /*scale*/
-                i[8]
+                s[10]
             ),
             min_width: (
                 /*min_width*/
-                i[9]
+                s[11]
             ),
             height: (
                 /*height*/
-                i[11]
+                s[13]
             ),
             $$slots: {
-                default: [nv]
+                default: [pv]
             },
             $$scope: {
-                ctx: i
+                ctx: s
             }
         }
     }), {
         c() {
-            ai(e.$$.fragment);
+            Mi(e.$$.fragment);
         },
-        m(n, r) {
-            ci(e, n, r), t = !0;
+        m(n, i) {
+            Ai(e, n, i), t = !0;
         },
-        p(n, [r]) {
-            const s = {};
-            r & /*visible*/
-                4 && (s.visible = /*visible*/
-                    n[2]), r & /*value*/
-                8 && (s.variant = /*value*/
-                    n[3] === null ? "dashed" : "solid"), r & /*elem_id*/
-                1 && (s.elem_id = /*elem_id*/
-                    n[0]), r & /*elem_classes*/
-                2 && (s.elem_classes = /*elem_classes*/
-                    n[1]), r & /*container*/
-                128 && (s.container = /*container*/
-                    n[7]), r & /*scale*/
-                256 && (s.scale = /*scale*/
-                    n[8]), r & /*min_width*/
-                512 && (s.min_width = /*min_width*/
-                    n[9]), r & /*height*/
-                2048 && (s.height = /*height*/
-                    n[11]), r & /*$$scope, _value, gradio, label, show_label, value, loading_status*/
-                38008 && (s.$$scope = {
-                    dirty: r,
+        p(n, [i]) {
+            const r = {};
+            i & /*visible*/
+                8 && (r.visible = /*visible*/
+                    n[3]), i & /*value*/
+                1 && (r.variant = /*value*/
+                    n[0] === null ? "dashed" : "solid"), i & /*elem_id*/
+                2 && (r.elem_id = /*elem_id*/
+                    n[1]), i & /*elem_classes*/
+                4 && (r.elem_classes = /*elem_classes*/
+                    n[2]), i & /*container*/
+                512 && (r.container = /*container*/
+                    n[9]), i & /*scale*/
+                1024 && (r.scale = /*scale*/
+                    n[10]), i & /*min_width*/
+                2048 && (r.min_width = /*min_width*/
+                    n[11]), i & /*height*/
+                8192 && (r.height = /*height*/
+                    n[13]), i & /*$$scope, gradio, label, show_label, root, proxy_url, value, loading_status*/
+                37361 && (r.$$scope = {
+                    dirty: i,
                     ctx: n
-                }), e.$set(s);
+                }), e.$set(r);
         },
         i(n) {
-            t || (An(e.$$.fragment, n), t = !0);
+            t || (Bn(e.$$.fragment, n), t = !0);
         },
         o(n) {
-            En(e.$$.fragment, n), t = !1;
+            On(e.$$.fragment, n), t = !1;
         },
         d(n) {
-            li(e, n);
+            Ei(e, n);
         }
     };
 }
 
-function rv(i, e, t) {
+function gv(s, e, t) {
     let {
         elem_id: n = ""
     } = e, {
-        elem_classes: r = []
+        elem_classes: i = []
     } = e, {
-        visible: s = !0
+        visible: r = !0
     } = e, {
-        value: a = null
+        value: o = null
     } = e, {
-        root: o
+        root: a
     } = e, {
         proxy_url: l
     } = e, {
         loading_status: c
     } = e, {
         label: u
     } = e, {
-        show_label: f
+        show_label: d
     } = e, {
-        container: h = !0
+        container: f = !0
     } = e, {
-        scale: p = null
+        scale: h = null
     } = e, {
         min_width: g = void 0
     } = e, {
-        gradio: v
+        gradio: _
     } = e, {
         height: m = void 0
-    } = e, d;
-    return i.$$set = (M) => {
-        "elem_id" in M && t(0, n = M.elem_id), "elem_classes" in M && t(1, r = M.elem_classes), "visible" in M && t(2, s = M.visible), "value" in M && t(3, a = M.value), "root" in M && t(13, o = M.root), "proxy_url" in M && t(14, l = M.proxy_url), "loading_status" in M && t(4, c = M.loading_status), "label" in M && t(5, u = M.label), "show_label" in M && t(6, f = M.show_label), "container" in M && t(7, h = M.container), "scale" in M && t(8, p = M.scale), "min_width" in M && t(9, g = M.min_width), "gradio" in M && t(10, v = M.gradio), "height" in M && t(11, m = M.height);
-    }, i.$$.update = () => {
-        i.$$.dirty & /*value*/
-            8 && t(12, d = a);
+    } = e;
+
+    function p(v) {
+        o = v, t(0, o);
+    }
+    return s.$$set = (v) => {
+        "elem_id" in v && t(1, n = v.elem_id), "elem_classes" in v && t(2, i = v.elem_classes), "visible" in v && t(3, r = v.visible), "value" in v && t(0, o = v.value), "root" in v && t(4, a = v.root), "proxy_url" in v && t(5, l = v.proxy_url), "loading_status" in v && t(6, c = v.loading_status), "label" in v && t(7, u = v.label), "show_label" in v && t(8, d = v.show_label), "container" in v && t(9, f = v.container), "scale" in v && t(10, h = v.scale), "min_width" in v && t(11, g = v.min_width), "gradio" in v && t(12, _ = v.gradio), "height" in v && t(13, m = v.height);
     }, [
+        o,
         n,
+        i,
         r,
-        s,
         a,
+        l,
         c,
         u,
+        d,
         f,
         h,
-        p,
         g,
-        v,
+        _,
         m,
-        d,
-        o,
-        l
+        p
     ];
 }
-class lv extends W0 {
+class xv extends $S {
     constructor(e) {
-        super(), Z0(this, e, rv, iv, J0, {
-            elem_id: 0,
-            elem_classes: 1,
-            visible: 2,
-            value: 3,
-            root: 13,
-            proxy_url: 14,
-            loading_status: 4,
-            label: 5,
-            show_label: 6,
-            container: 7,
-            scale: 8,
-            min_width: 9,
-            gradio: 10,
-            height: 11
+        super(), cv(this, e, gv, mv, uv, {
+            elem_id: 1,
+            elem_classes: 2,
+            visible: 3,
+            value: 0,
+            root: 4,
+            proxy_url: 5,
+            loading_status: 6,
+            label: 7,
+            show_label: 8,
+            container: 9,
+            scale: 10,
+            min_width: 11,
+            gradio: 12,
+            height: 13
         });
     }
 }
 export {
-    av as BaseExample,
-    X_ as BaseModel4DGS,
-    lv as
+    vv as BaseExample,
+    $_ as BaseModel4DGS,
+    xv as
     default
 };
```

### Comparing `gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/component/style.css` & `gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/component/style.css`

 * *Files 16% similar despite different names*

```diff
@@ -1 +1 @@
-.block.svelte-1t38q2d{position:relative;margin:0;box-shadow:var(--block-shadow);border-width:var(--block-border-width);border-color:var(--block-border-color);border-radius:var(--block-radius);background:var(--block-background-fill);width:100%;line-height:var(--line-sm)}.block.border_focus.svelte-1t38q2d{border-color:var(--color-accent)}.padded.svelte-1t38q2d{padding:var(--block-padding)}.hidden.svelte-1t38q2d{display:none}.hide-container.svelte-1t38q2d{margin:0;box-shadow:none;--block-border-width:0;background:transparent;padding:0;overflow:visible}div.svelte-1hnfib2{margin-bottom:var(--spacing-lg);color:var(--block-info-text-color);font-weight:var(--block-info-text-weight);font-size:var(--block-info-text-size);line-height:var(--line-sm)}span.has-info.svelte-22c38v{margin-bottom:var(--spacing-xs)}span.svelte-22c38v:not(.has-info){margin-bottom:var(--spacing-lg)}span.svelte-22c38v{display:inline-block;position:relative;z-index:var(--layer-4);border:solid var(--block-title-border-width) var(--block-title-border-color);border-radius:var(--block-title-radius);background:var(--block-title-background-fill);padding:var(--block-title-padding);color:var(--block-title-text-color);font-weight:var(--block-title-text-weight);font-size:var(--block-title-text-size);line-height:var(--line-sm)}.hide.svelte-22c38v{margin:0;height:0}label.svelte-9gxdi0{display:inline-flex;align-items:center;z-index:var(--layer-2);box-shadow:var(--block-label-shadow);border:var(--block-label-border-width) solid var(--border-color-primary);border-top:none;border-left:none;border-radius:var(--block-label-radius);background:var(--block-label-background-fill);padding:var(--block-label-padding);pointer-events:none;color:var(--block-label-text-color);font-weight:var(--block-label-text-weight);font-size:var(--block-label-text-size);line-height:var(--line-sm)}.gr-group label.svelte-9gxdi0{border-top-left-radius:0}label.float.svelte-9gxdi0{position:absolute;top:var(--block-label-margin);left:var(--block-label-margin)}label.svelte-9gxdi0:not(.float){position:static;margin-top:var(--block-label-margin);margin-left:var(--block-label-margin)}.hide.svelte-9gxdi0{height:0}span.svelte-9gxdi0{opacity:.8;margin-right:var(--size-2);width:calc(var(--block-label-text-size) - 1px);height:calc(var(--block-label-text-size) - 1px)}.hide-label.svelte-9gxdi0{box-shadow:none;border-width:0;background:transparent;overflow:visible}button.svelte-lpi64a{display:flex;justify-content:center;align-items:center;gap:1px;z-index:var(--layer-2);border-radius:var(--radius-sm);color:var(--block-label-text-color);border:1px solid transparent}button[disabled].svelte-lpi64a{opacity:.5;box-shadow:none}button[disabled].svelte-lpi64a:hover{cursor:not-allowed}.padded.svelte-lpi64a{padding:2px;background:var(--bg-color);box-shadow:var(--shadow-drop);border:1px solid var(--button-secondary-border-color)}button.svelte-lpi64a:hover,button.highlight.svelte-lpi64a{cursor:pointer;color:var(--color-accent)}.padded.svelte-lpi64a:hover{border:2px solid var(--button-secondary-border-color-hover);padding:1px;color:var(--block-label-text-color)}span.svelte-lpi64a{padding:0 1px;font-size:10px}div.svelte-lpi64a{padding:2px;display:flex;align-items:flex-end}.small.svelte-lpi64a{width:14px;height:14px}.large.svelte-lpi64a{width:22px;height:22px}.pending.svelte-lpi64a{animation:svelte-lpi64a-flash .5s infinite}@keyframes svelte-lpi64a-flash{0%{opacity:.5}50%{opacity:1}to{opacity:.5}}.transparent.svelte-lpi64a{background:transparent;border:none;box-shadow:none}.empty.svelte-3w3rth{display:flex;justify-content:center;align-items:center;margin-top:calc(0px - var(--size-6));height:var(--size-full)}.icon.svelte-3w3rth{opacity:.5;height:var(--size-5);color:var(--body-text-color)}.small.svelte-3w3rth{min-height:calc(var(--size-32) - 20px)}.large.svelte-3w3rth{min-height:calc(var(--size-64) - 20px)}.unpadded_box.svelte-3w3rth{margin-top:0}.small_parent.svelte-3w3rth{min-height:100%!important}.dropdown-arrow.svelte-145leq6{fill:currentColor}.wrap.svelte-kzcjhc{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:var(--size-60);color:var(--block-label-text-color);line-height:var(--line-md);height:100%;padding-top:var(--size-3)}.or.svelte-kzcjhc{color:var(--body-text-color-subdued);display:flex}.icon-wrap.svelte-kzcjhc{width:30px;margin-bottom:var(--spacing-lg)}@media (--screen-md){.wrap.svelte-kzcjhc{font-size:var(--text-lg)}}.hovered.svelte-kzcjhc{color:var(--color-accent)}div.svelte-ipfyu7{border-top:1px solid transparent;display:flex;max-height:100%;justify-content:center;gap:var(--spacing-sm);height:auto;align-items:flex-end;padding-bottom:var(--spacing-xl);color:var(--block-label-text-color);flex-shrink:0;width:95%}.show_border.svelte-ipfyu7{border-top:1px solid var(--block-border-color);margin-top:var(--spacing-xxl);box-shadow:var(--shadow-drop)}.source-selection.svelte-1jp3vgd{display:flex;align-items:center;justify-content:center;border-top:1px solid var(--border-color-primary);width:95%;bottom:0;left:0;right:0;margin-left:auto;margin-right:auto}.icon.svelte-1jp3vgd{width:22px;height:22px;margin:var(--spacing-lg) var(--spacing-xs);padding:var(--spacing-xs);color:var(--neutral-400);border-radius:var(--radius-md)}.selected.svelte-1jp3vgd{color:var(--color-accent)}.icon.svelte-1jp3vgd:hover,.icon.svelte-1jp3vgd:focus{color:var(--color-accent)}.model4DGS.svelte-1jpyjlj{display:flex;position:relative;width:var(--size-full);height:var(--size-full);min-height:250px}svg.svelte-43sxxs.svelte-43sxxs{width:var(--size-20);height:var(--size-20)}svg.svelte-43sxxs path.svelte-43sxxs{fill:var(--loader-color)}div.svelte-43sxxs.svelte-43sxxs{z-index:var(--layer-2)}.margin.svelte-43sxxs.svelte-43sxxs{margin:var(--size-4)}.wrap.svelte-1yserjw.svelte-1yserjw{display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:var(--layer-top);transition:opacity .1s ease-in-out;border-radius:var(--block-radius);background:var(--block-background-fill);padding:0 var(--size-6);max-height:var(--size-screen-h);overflow:hidden;pointer-events:none}.wrap.center.svelte-1yserjw.svelte-1yserjw{top:0;right:0;left:0}.wrap.default.svelte-1yserjw.svelte-1yserjw{top:0;right:0;bottom:0;left:0}.hide.svelte-1yserjw.svelte-1yserjw{opacity:0;pointer-events:none}.generating.svelte-1yserjw.svelte-1yserjw{animation:svelte-1yserjw-pulse 2s cubic-bezier(.4,0,.6,1) infinite;border:2px solid var(--color-accent);background:transparent;z-index:var(--layer-1)}.translucent.svelte-1yserjw.svelte-1yserjw{background:none}@keyframes svelte-1yserjw-pulse{0%,to{opacity:1}50%{opacity:.5}}.loading.svelte-1yserjw.svelte-1yserjw{z-index:var(--layer-2);color:var(--body-text-color)}.eta-bar.svelte-1yserjw.svelte-1yserjw{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:left;opacity:.8;z-index:var(--layer-1);transition:10ms;background:var(--background-fill-secondary)}.progress-bar-wrap.svelte-1yserjw.svelte-1yserjw{border:1px solid var(--border-color-primary);background:var(--background-fill-primary);width:55.5%;height:var(--size-4)}.progress-bar.svelte-1yserjw.svelte-1yserjw{transform-origin:left;background-color:var(--loader-color);width:var(--size-full);height:var(--size-full)}.progress-level.svelte-1yserjw.svelte-1yserjw{display:flex;flex-direction:column;align-items:center;gap:1;z-index:var(--layer-2);width:var(--size-full)}.progress-level-inner.svelte-1yserjw.svelte-1yserjw{margin:var(--size-2) auto;color:var(--body-text-color);font-size:var(--text-sm);font-family:var(--font-mono)}.meta-text.svelte-1yserjw.svelte-1yserjw{position:absolute;top:0;right:0;z-index:var(--layer-2);padding:var(--size-1) var(--size-2);font-size:var(--text-sm);font-family:var(--font-mono)}.meta-text-center.svelte-1yserjw.svelte-1yserjw{display:flex;position:absolute;top:0;right:0;justify-content:center;align-items:center;transform:translateY(var(--size-6));z-index:var(--layer-2);padding:var(--size-1) var(--size-2);font-size:var(--text-sm);font-family:var(--font-mono);text-align:center}.error.svelte-1yserjw.svelte-1yserjw{box-shadow:var(--shadow-drop);border:solid 1px var(--error-border-color);border-radius:var(--radius-full);background:var(--error-background-fill);padding-right:var(--size-4);padding-left:var(--size-4);color:var(--error-text-color);font-weight:var(--weight-semibold);font-size:var(--text-lg);line-height:var(--line-lg);font-family:var(--font)}.minimal.svelte-1yserjw .progress-text.svelte-1yserjw{background:var(--block-background-fill)}.border.svelte-1yserjw.svelte-1yserjw{border:1px solid var(--border-color-primary)}.toast-body.svelte-solcu7{display:flex;position:relative;right:0;left:0;align-items:center;margin:var(--size-6) var(--size-4);margin:auto;border-radius:var(--container-radius);overflow:hidden;pointer-events:auto}.toast-body.error.svelte-solcu7{border:1px solid var(--color-red-700);background:var(--color-red-50)}.dark .toast-body.error.svelte-solcu7{border:1px solid var(--color-red-500);background-color:var(--color-grey-950)}.toast-body.warning.svelte-solcu7{border:1px solid var(--color-yellow-700);background:var(--color-yellow-50)}.dark .toast-body.warning.svelte-solcu7{border:1px solid var(--color-yellow-500);background-color:var(--color-grey-950)}.toast-body.info.svelte-solcu7{border:1px solid var(--color-grey-700);background:var(--color-grey-50)}.dark .toast-body.info.svelte-solcu7{border:1px solid var(--color-grey-500);background-color:var(--color-grey-950)}.toast-title.svelte-solcu7{display:flex;align-items:center;font-weight:var(--weight-bold);font-size:var(--text-lg);line-height:var(--line-sm);text-transform:capitalize}.toast-title.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-title.error.svelte-solcu7{color:var(--color-red-50)}.toast-title.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-title.warning.svelte-solcu7{color:var(--color-yellow-50)}.toast-title.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-title.info.svelte-solcu7{color:var(--color-grey-50)}.toast-close.svelte-solcu7{margin:0 var(--size-3);border-radius:var(--size-3);padding:0px var(--size-1-5);font-size:var(--size-5);line-height:var(--size-5)}.toast-close.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-close.error.svelte-solcu7{color:var(--color-red-500)}.toast-close.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-close.warning.svelte-solcu7{color:var(--color-yellow-500)}.toast-close.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-close.info.svelte-solcu7{color:var(--color-grey-500)}.toast-text.svelte-solcu7{font-size:var(--text-lg)}.toast-text.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-text.error.svelte-solcu7{color:var(--color-red-50)}.toast-text.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-text.warning.svelte-solcu7{color:var(--color-yellow-50)}.toast-text.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-text.info.svelte-solcu7{color:var(--color-grey-50)}.toast-details.svelte-solcu7{margin:var(--size-3) var(--size-3) var(--size-3) 0;width:100%}.toast-icon.svelte-solcu7{display:flex;position:absolute;position:relative;flex-shrink:0;justify-content:center;align-items:center;margin:var(--size-2);border-radius:var(--radius-full);padding:var(--size-1);padding-left:calc(var(--size-1) - 1px);width:35px;height:35px}.toast-icon.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-icon.error.svelte-solcu7{color:var(--color-red-500)}.toast-icon.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-icon.warning.svelte-solcu7{color:var(--color-yellow-500)}.toast-icon.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-icon.info.svelte-solcu7{color:var(--color-grey-500)}@keyframes svelte-solcu7-countdown{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.timer.svelte-solcu7{position:absolute;bottom:0;left:0;transform-origin:0 0;animation:svelte-solcu7-countdown 10s linear forwards;width:100%;height:var(--size-1)}.timer.error.svelte-solcu7{background:var(--color-red-700)}.dark .timer.error.svelte-solcu7{background:var(--color-red-500)}.timer.warning.svelte-solcu7{background:var(--color-yellow-700)}.dark .timer.warning.svelte-solcu7{background:var(--color-yellow-500)}.timer.info.svelte-solcu7{background:var(--color-grey-700)}.dark .timer.info.svelte-solcu7{background:var(--color-grey-500)}.toast-wrap.svelte-gatr8h{display:flex;position:fixed;top:var(--size-4);right:var(--size-4);flex-direction:column;align-items:end;gap:var(--size-2);z-index:var(--layer-top);width:calc(100% - var(--size-8))}@media (--screen-sm){.toast-wrap.svelte-gatr8h{width:calc(var(--size-96) + var(--size-10))}}.gallery.svelte-1gecy8w{padding:var(--size-1) var(--size-2)}
+.block.svelte-1t38q2d{position:relative;margin:0;box-shadow:var(--block-shadow);border-width:var(--block-border-width);border-color:var(--block-border-color);border-radius:var(--block-radius);background:var(--block-background-fill);width:100%;line-height:var(--line-sm)}.block.border_focus.svelte-1t38q2d{border-color:var(--color-accent)}.padded.svelte-1t38q2d{padding:var(--block-padding)}.hidden.svelte-1t38q2d{display:none}.hide-container.svelte-1t38q2d{margin:0;box-shadow:none;--block-border-width:0;background:transparent;padding:0;overflow:visible}div.svelte-1hnfib2{margin-bottom:var(--spacing-lg);color:var(--block-info-text-color);font-weight:var(--block-info-text-weight);font-size:var(--block-info-text-size);line-height:var(--line-sm)}span.has-info.svelte-22c38v{margin-bottom:var(--spacing-xs)}span.svelte-22c38v:not(.has-info){margin-bottom:var(--spacing-lg)}span.svelte-22c38v{display:inline-block;position:relative;z-index:var(--layer-4);border:solid var(--block-title-border-width) var(--block-title-border-color);border-radius:var(--block-title-radius);background:var(--block-title-background-fill);padding:var(--block-title-padding);color:var(--block-title-text-color);font-weight:var(--block-title-text-weight);font-size:var(--block-title-text-size);line-height:var(--line-sm)}.hide.svelte-22c38v{margin:0;height:0}label.svelte-9gxdi0{display:inline-flex;align-items:center;z-index:var(--layer-2);box-shadow:var(--block-label-shadow);border:var(--block-label-border-width) solid var(--border-color-primary);border-top:none;border-left:none;border-radius:var(--block-label-radius);background:var(--block-label-background-fill);padding:var(--block-label-padding);pointer-events:none;color:var(--block-label-text-color);font-weight:var(--block-label-text-weight);font-size:var(--block-label-text-size);line-height:var(--line-sm)}.gr-group label.svelte-9gxdi0{border-top-left-radius:0}label.float.svelte-9gxdi0{position:absolute;top:var(--block-label-margin);left:var(--block-label-margin)}label.svelte-9gxdi0:not(.float){position:static;margin-top:var(--block-label-margin);margin-left:var(--block-label-margin)}.hide.svelte-9gxdi0{height:0}span.svelte-9gxdi0{opacity:.8;margin-right:var(--size-2);width:calc(var(--block-label-text-size) - 1px);height:calc(var(--block-label-text-size) - 1px)}.hide-label.svelte-9gxdi0{box-shadow:none;border-width:0;background:transparent;overflow:visible}button.svelte-lpi64a{display:flex;justify-content:center;align-items:center;gap:1px;z-index:var(--layer-2);border-radius:var(--radius-sm);color:var(--block-label-text-color);border:1px solid transparent}button[disabled].svelte-lpi64a{opacity:.5;box-shadow:none}button[disabled].svelte-lpi64a:hover{cursor:not-allowed}.padded.svelte-lpi64a{padding:2px;background:var(--bg-color);box-shadow:var(--shadow-drop);border:1px solid var(--button-secondary-border-color)}button.svelte-lpi64a:hover,button.highlight.svelte-lpi64a{cursor:pointer;color:var(--color-accent)}.padded.svelte-lpi64a:hover{border:2px solid var(--button-secondary-border-color-hover);padding:1px;color:var(--block-label-text-color)}span.svelte-lpi64a{padding:0 1px;font-size:10px}div.svelte-lpi64a{padding:2px;display:flex;align-items:flex-end}.small.svelte-lpi64a{width:14px;height:14px}.large.svelte-lpi64a{width:22px;height:22px}.pending.svelte-lpi64a{animation:svelte-lpi64a-flash .5s infinite}@keyframes svelte-lpi64a-flash{0%{opacity:.5}50%{opacity:1}to{opacity:.5}}.transparent.svelte-lpi64a{background:transparent;border:none;box-shadow:none}.empty.svelte-3w3rth{display:flex;justify-content:center;align-items:center;margin-top:calc(0px - var(--size-6));height:var(--size-full)}.icon.svelte-3w3rth{opacity:.5;height:var(--size-5);color:var(--body-text-color)}.small.svelte-3w3rth{min-height:calc(var(--size-32) - 20px)}.large.svelte-3w3rth{min-height:calc(var(--size-64) - 20px)}.unpadded_box.svelte-3w3rth{margin-top:0}.small_parent.svelte-3w3rth{min-height:100%!important}.dropdown-arrow.svelte-145leq6{fill:currentColor}.wrap.svelte-kzcjhc{display:flex;flex-direction:column;justify-content:center;align-items:center;min-height:var(--size-60);color:var(--block-label-text-color);line-height:var(--line-md);height:100%;padding-top:var(--size-3)}.or.svelte-kzcjhc{color:var(--body-text-color-subdued);display:flex}.icon-wrap.svelte-kzcjhc{width:30px;margin-bottom:var(--spacing-lg)}@media (--screen-md){.wrap.svelte-kzcjhc{font-size:var(--text-lg)}}.hovered.svelte-kzcjhc{color:var(--color-accent)}div.svelte-ipfyu7{border-top:1px solid transparent;display:flex;max-height:100%;justify-content:center;gap:var(--spacing-sm);height:auto;align-items:flex-end;padding-bottom:var(--spacing-xl);color:var(--block-label-text-color);flex-shrink:0;width:95%}.show_border.svelte-ipfyu7{border-top:1px solid var(--block-border-color);margin-top:var(--spacing-xxl);box-shadow:var(--shadow-drop)}.source-selection.svelte-1jp3vgd{display:flex;align-items:center;justify-content:center;border-top:1px solid var(--border-color-primary);width:95%;bottom:0;left:0;right:0;margin-left:auto;margin-right:auto}.icon.svelte-1jp3vgd{width:22px;height:22px;margin:var(--spacing-lg) var(--spacing-xs);padding:var(--spacing-xs);color:var(--neutral-400);border-radius:var(--radius-md)}.selected.svelte-1jp3vgd{color:var(--color-accent)}.icon.svelte-1jp3vgd:hover,.icon.svelte-1jp3vgd:focus{color:var(--color-accent)}.model4DGS.svelte-jfv6j3{display:flex;position:relative;width:var(--size-full);height:var(--size-full);min-height:250px}svg.svelte-43sxxs.svelte-43sxxs{width:var(--size-20);height:var(--size-20)}svg.svelte-43sxxs path.svelte-43sxxs{fill:var(--loader-color)}div.svelte-43sxxs.svelte-43sxxs{z-index:var(--layer-2)}.margin.svelte-43sxxs.svelte-43sxxs{margin:var(--size-4)}.wrap.svelte-1txqlrd.svelte-1txqlrd{display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:var(--layer-top);transition:opacity .1s ease-in-out;border-radius:var(--block-radius);background:var(--block-background-fill);padding:0 var(--size-6);max-height:var(--size-screen-h);overflow:hidden;pointer-events:none}.wrap.center.svelte-1txqlrd.svelte-1txqlrd{top:0;right:0;left:0}.wrap.default.svelte-1txqlrd.svelte-1txqlrd{top:0;right:0;bottom:0;left:0}.hide.svelte-1txqlrd.svelte-1txqlrd{opacity:0;pointer-events:none}.generating.svelte-1txqlrd.svelte-1txqlrd{animation:svelte-1txqlrd-pulse 2s cubic-bezier(.4,0,.6,1) infinite;border:2px solid var(--color-accent);background:transparent}.translucent.svelte-1txqlrd.svelte-1txqlrd{background:none}@keyframes svelte-1txqlrd-pulse{0%,to{opacity:1}50%{opacity:.5}}.loading.svelte-1txqlrd.svelte-1txqlrd{z-index:var(--layer-2);color:var(--body-text-color)}.eta-bar.svelte-1txqlrd.svelte-1txqlrd{position:absolute;top:0;right:0;bottom:0;left:0;transform-origin:left;opacity:.8;z-index:var(--layer-1);transition:10ms;background:var(--background-fill-secondary)}.progress-bar-wrap.svelte-1txqlrd.svelte-1txqlrd{border:1px solid var(--border-color-primary);background:var(--background-fill-primary);width:55.5%;height:var(--size-4)}.progress-bar.svelte-1txqlrd.svelte-1txqlrd{transform-origin:left;background-color:var(--loader-color);width:var(--size-full);height:var(--size-full)}.progress-level.svelte-1txqlrd.svelte-1txqlrd{display:flex;flex-direction:column;align-items:center;gap:1;z-index:var(--layer-2);width:var(--size-full)}.progress-level-inner.svelte-1txqlrd.svelte-1txqlrd{margin:var(--size-2) auto;color:var(--body-text-color);font-size:var(--text-sm);font-family:var(--font-mono)}.meta-text.svelte-1txqlrd.svelte-1txqlrd{position:absolute;top:0;right:0;z-index:var(--layer-2);padding:var(--size-1) var(--size-2);font-size:var(--text-sm);font-family:var(--font-mono)}.meta-text-center.svelte-1txqlrd.svelte-1txqlrd{display:flex;position:absolute;top:0;right:0;justify-content:center;align-items:center;transform:translateY(var(--size-6));z-index:var(--layer-2);padding:var(--size-1) var(--size-2);font-size:var(--text-sm);font-family:var(--font-mono);text-align:center}.error.svelte-1txqlrd.svelte-1txqlrd{box-shadow:var(--shadow-drop);border:solid 1px var(--error-border-color);border-radius:var(--radius-full);background:var(--error-background-fill);padding-right:var(--size-4);padding-left:var(--size-4);color:var(--error-text-color);font-weight:var(--weight-semibold);font-size:var(--text-lg);line-height:var(--line-lg);font-family:var(--font)}.minimal.svelte-1txqlrd .progress-text.svelte-1txqlrd{background:var(--block-background-fill)}.border.svelte-1txqlrd.svelte-1txqlrd{border:1px solid var(--border-color-primary)}.toast-body.svelte-solcu7{display:flex;position:relative;right:0;left:0;align-items:center;margin:var(--size-6) var(--size-4);margin:auto;border-radius:var(--container-radius);overflow:hidden;pointer-events:auto}.toast-body.error.svelte-solcu7{border:1px solid var(--color-red-700);background:var(--color-red-50)}.dark .toast-body.error.svelte-solcu7{border:1px solid var(--color-red-500);background-color:var(--color-grey-950)}.toast-body.warning.svelte-solcu7{border:1px solid var(--color-yellow-700);background:var(--color-yellow-50)}.dark .toast-body.warning.svelte-solcu7{border:1px solid var(--color-yellow-500);background-color:var(--color-grey-950)}.toast-body.info.svelte-solcu7{border:1px solid var(--color-grey-700);background:var(--color-grey-50)}.dark .toast-body.info.svelte-solcu7{border:1px solid var(--color-grey-500);background-color:var(--color-grey-950)}.toast-title.svelte-solcu7{display:flex;align-items:center;font-weight:var(--weight-bold);font-size:var(--text-lg);line-height:var(--line-sm);text-transform:capitalize}.toast-title.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-title.error.svelte-solcu7{color:var(--color-red-50)}.toast-title.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-title.warning.svelte-solcu7{color:var(--color-yellow-50)}.toast-title.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-title.info.svelte-solcu7{color:var(--color-grey-50)}.toast-close.svelte-solcu7{margin:0 var(--size-3);border-radius:var(--size-3);padding:0px var(--size-1-5);font-size:var(--size-5);line-height:var(--size-5)}.toast-close.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-close.error.svelte-solcu7{color:var(--color-red-500)}.toast-close.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-close.warning.svelte-solcu7{color:var(--color-yellow-500)}.toast-close.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-close.info.svelte-solcu7{color:var(--color-grey-500)}.toast-text.svelte-solcu7{font-size:var(--text-lg)}.toast-text.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-text.error.svelte-solcu7{color:var(--color-red-50)}.toast-text.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-text.warning.svelte-solcu7{color:var(--color-yellow-50)}.toast-text.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-text.info.svelte-solcu7{color:var(--color-grey-50)}.toast-details.svelte-solcu7{margin:var(--size-3) var(--size-3) var(--size-3) 0;width:100%}.toast-icon.svelte-solcu7{display:flex;position:absolute;position:relative;flex-shrink:0;justify-content:center;align-items:center;margin:var(--size-2);border-radius:var(--radius-full);padding:var(--size-1);padding-left:calc(var(--size-1) - 1px);width:35px;height:35px}.toast-icon.error.svelte-solcu7{color:var(--color-red-700)}.dark .toast-icon.error.svelte-solcu7{color:var(--color-red-500)}.toast-icon.warning.svelte-solcu7{color:var(--color-yellow-700)}.dark .toast-icon.warning.svelte-solcu7{color:var(--color-yellow-500)}.toast-icon.info.svelte-solcu7{color:var(--color-grey-700)}.dark .toast-icon.info.svelte-solcu7{color:var(--color-grey-500)}@keyframes svelte-solcu7-countdown{0%{transform:scaleX(1)}to{transform:scaleX(0)}}.timer.svelte-solcu7{position:absolute;bottom:0;left:0;transform-origin:0 0;animation:svelte-solcu7-countdown 10s linear forwards;width:100%;height:var(--size-1)}.timer.error.svelte-solcu7{background:var(--color-red-700)}.dark .timer.error.svelte-solcu7{background:var(--color-red-500)}.timer.warning.svelte-solcu7{background:var(--color-yellow-700)}.dark .timer.warning.svelte-solcu7{background:var(--color-yellow-500)}.timer.info.svelte-solcu7{background:var(--color-grey-700)}.dark .timer.info.svelte-solcu7{background:var(--color-grey-500)}.toast-wrap.svelte-gatr8h{display:flex;position:fixed;top:var(--size-4);right:var(--size-4);flex-direction:column;align-items:end;gap:var(--size-2);z-index:var(--layer-top);width:calc(100% - var(--size-8))}@media (--screen-sm){.toast-wrap.svelte-gatr8h{width:calc(var(--size-96) + var(--size-10))}}.gallery.svelte-1gecy8w{padding:var(--size-1) var(--size-2)}
```

### Comparing `gradio_model4dgs-0.0.2/backend/gradio_model4dgs/templates/example/index.js` & `gradio_model4dgs-0.0.3/backend/gradio_model4dgs/templates/example/index.js`

 * *Files 5% similar despite different names*

#### js-beautify {}

```diff
@@ -1,30 +1,30 @@
 const {
-    SvelteComponent: f,
-    append: u,
-    attr: d,
+    SvelteComponent: u,
+    append: d,
+    attr: _,
     detach: g,
     element: o,
-    init: v,
-    insert: r,
+    init: r,
+    insert: v,
     noop: c,
     safe_not_equal: y,
     set_data: m,
     text: b,
     toggle_class: i
 } = window.__gradio__svelte__internal;
 
 function w(a) {
     let e, n;
     return {
         c() {
             e = o("div"), n = b(
                 /*value*/
                 a[0]
-            ), d(e, "class", "svelte-1gecy8w"), i(
+            ), _(e, "class", "svelte-1gecy8w"), i(
                 e,
                 "table",
                 /*type*/
                 a[1] === "table"
             ), i(
                 e,
                 "gallery",
@@ -34,15 +34,15 @@
                 e,
                 "selected",
                 /*selected*/
                 a[2]
             );
         },
         m(t, l) {
-            r(t, e, l), u(e, n);
+            v(t, e, l), d(e, n);
         },
         p(t, [l]) {
             l & /*value*/
                 1 && m(
                     n,
                     /*value*/
                     t[0]
@@ -76,26 +76,26 @@
 
 function h(a, e, n) {
     let {
         value: t
     } = e, {
         type: l
     } = e, {
-        selected: _ = !1
+        selected: f = !1
     } = e;
     return a.$$set = (s) => {
-        "value" in s && n(0, t = s.value), "type" in s && n(1, l = s.type), "selected" in s && n(2, _ = s.selected);
-    }, [t, l, _];
+        "value" in s && n(0, t = s.value), "type" in s && n(1, l = s.type), "selected" in s && n(2, f = s.selected);
+    }, [t, l, f];
 }
-class E extends f {
+class q extends u {
     constructor(e) {
-        super(), v(this, e, h, w, y, {
+        super(), r(this, e, h, w, y, {
             value: 0,
             type: 1,
             selected: 2
         });
     }
 }
 export {
-    E as
+    q as
     default
 };
```

### Comparing `gradio_model4dgs-0.0.2/demo/css.css` & `gradio_model4dgs-0.0.3/demo/css.css`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/space.py` & `gradio_model4dgs-0.0.3/demo/space.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     ),
 ) as demo:
     gr.Markdown(
 """
 # `gradio_model4dgs`
 
 <div style="display: flex; gap: 7px;">
-<img alt="Static Badge" src="https://img.shields.io/badge/version%20-%200.0.2%20-%20orange">  
+<a href="https://pypi.org/project/gradio_model4dgs/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_model4dgs"></a>  
 </div>
 
 Python library for easily interacting with trained machine learning models
 """, elem_classes=["md-custom"], header_links=True)
     app.render()
     gr.Markdown(
 """
@@ -38,22 +38,27 @@
 ## Usage
 
 ```python
 import gradio as gr
 from gradio_model4dgs import Model4DGS
 import os
 
-examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
+image_dir = os.path.join(os.path.dirname(__file__), "assets")
+
+if os.path.exists(image_dir) and os.path.isdir(image_dir) and os.listdir(image_dir):
+    examples = [os.path.join(image_dir, file) for file in os.listdir(image_dir)]
+else:
+    examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
 
 with gr.Blocks() as demo:
     with gr.Row():
         Model4DGS(value=examples, label="4D Model")
 
 if __name__ == "__main__":
-    demo.launch()
+    demo.launch(share=True)
 ```
 """, elem_classes=["md-custom"], header_links=True)
 
 
     gr.Markdown("""
 ## `Model4DGS`
```

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_0.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_0.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_1.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_1.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_10.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_10.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_11.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_11.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_12.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_12.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_13.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_13.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_2.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_2.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_3.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_3.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_4.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_4.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_5.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_5.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_6.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_6.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_7.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_7.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_8.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_8.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_4d_model_9.ply` & `gradio_model4dgs-0.0.3/demo/assets/tiger_4d_model_9.ply`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/demo/assets/tiger_rgba.png` & `gradio_model4dgs-0.0.3/demo/tiger_rgba.png`

 * *Files identical despite different names*

### Comparing `gradio_model4dgs-0.0.2/frontend/Index.svelte` & `gradio_model4dgs-0.0.3/frontend/Index.svelte`

 * *Files 22% similar despite different names*

```diff
@@ -1,42 +1,36 @@
 <script context="module" lang="ts">
     export { default as BaseModel4DGS } from "./shared/Model4DGS.svelte";
     export { default as BaseExample } from "./Example.svelte";
 </script>
 
 <script lang="ts">
-    import { type FileData } from "@gradio/client";
+    import type { FileData } from "@gradio/client";
     import Model4DGS from "./shared/Model4DGS.svelte";
     import { BlockLabel, Block, Empty } from "@gradio/atoms";
     import { File } from "@gradio/icons";
-
     import { StatusTracker } from "@gradio/statustracker";
     import type { LoadingStatus } from "@gradio/statustracker";
     import type { Gradio } from "@gradio/utils";
 
     export let elem_id = "";
     export let elem_classes: string[] = [];
     export let visible = true;
-    export let value: null | FileData[] = null;
+    export let value: null | { files: FileData[]; } = null;
     export let root: string;
     export let proxy_url: null | string;
     export let loading_status: LoadingStatus;
     export let label: string;
     export let show_label: boolean;
     export let container = true;
     export let scale: number | null = null;
     export let min_width: number | undefined = undefined;
     export let gradio: Gradio;
     export let height: number | undefined = undefined;
 
-    // export let interactive: boolean;
-
-    let _value: null | FileData[];
-    $: _value = value;
-
     let dragging = false;
 </script>
 
 <Block
     {visible}
     variant={value === null ? "dashed" : "solid"}
     border_mode={dragging ? "focus" : "base"}
@@ -49,18 +43,20 @@
     {height}
 >
     <StatusTracker autoscroll={gradio.autoscroll} i18n={gradio.i18n} {...loading_status} />
 
     {#if value}
         <BlockLabel {show_label} Icon={File} label={label || "Splat"} />
         <Model4DGS
-            value={_value}
+            bind:value
             i18n={gradio.i18n}
             {label}
             {show_label}
+            {root}
+            {proxy_url}
         />
     {:else}
         <BlockLabel {show_label} Icon={File} label={label || "Splat"} />
 
         <Empty unpadded_box={true} size="large"><File /></Empty>
     {/if}
 </Block>
```

#### html2text {}

```diff
@@ -1,7 +1,7 @@
 visible} variant={value === null ? "dashed" : "solid"} border_mode={dragging ?
 "focus" : "base"} padding={false} {elem_id} {elem_classes} {container} {scale}
 {min_width} {height} >
 ...loading_status} /> {#if value}
 show_label} Icon={File} label={label || "Splat"} />
-label} {show_label} /> {:else}
+label} {show_label} {root} {proxy_url} /> {:else}
 show_label} Icon={File} label={label || "Splat"} /> {/if}
```

### Comparing `gradio_model4dgs-0.0.2/frontend/shared/Model4DGS.svelte` & `gradio_model4dgs-0.0.3/frontend/shared/Model4DGS.svelte`

 * *Files 23% similar despite different names*

```diff
@@ -1,63 +1,65 @@
 <script lang="ts">
-    import type { FileData } from "@gradio/client";
+    import { FileData, normalise_file } from "@gradio/client";
     import { BlockLabel } from "@gradio/atoms";
     import { File } from "@gradio/icons";
     import { onMount } from "svelte";
     import * as GaussianSplats3D from "@mkkellogg/gaussian-splats-3d";
     import * as THREE from "three";
     import type { I18nFormatter } from "@gradio/utils";
 
-    export let value: FileData[] | null;
+    export let value: null | { files: FileData[]; };
+    export let root: string;
+    export let proxy_url: null | string;
     export let label = "";
     export let show_label: boolean;
     export let i18n: I18nFormatter;
 
     let currFrameIndex = 0;
     let NUM_FRAMES = 1;
-
+    
     var sceneOptions: Array<object> = []
     const visible_scale = new THREE.Vector3(1.25, 1.25, 1.25);
     const invisible_scale = new THREE.Vector3(0.01, 0.01, 0.01);
 
     onMount(() => {
-        if (value != null) {
+        if (value != null && value.files != null) {    
             const viewerContainer = document.querySelector('.model4DGS');
             const viewer = new GaussianSplats3D.Viewer({
                 cameraUp: [0, 1, 0],
                 initialCameraPosition: [0, 0, 4],
                 initialCameraLookAt: [0, 0, -1],
                 dynamicScene: true,
                 sharedMemoryForWorkers: false,
                 rootElement: viewerContainer
             });
 
-            NUM_FRAMES = value.length;
+            NUM_FRAMES = value.files.length;
+            let files = value.files;
 
-            for (let i = 0; i < value.length; i++) {
+            for (let i = 0; i < files.length; i++) {
                 let opt = {
-                    // path: "@fs/data/home/cunjun/jwren/gradio-splatting/assets/tiger_4d_model_" + idx + ".ply",
-                    path: "@fs" + value[i].path,
+                    path: normalise_file(files[i], root, proxy_url).url,
                     scale: [invisible_scale, invisible_scale, invisible_scale]
                 };
                 sceneOptions.push(opt);
             }
 
             viewer
-                .addSplatScenes(sceneOptions,true,)
+                .addSplatScenes(sceneOptions,true)
                 .then(() => {
                     viewer.start();
 
                     let startTime = performance.now();
                     requestAnimationFrame(update);
                     function update() {
                         requestAnimationFrame(update);
                         const timeDelta = performance.now() - startTime;
 
-                        if (timeDelta > 100) {
+                        if (timeDelta > 150) {
                             const prevSplatScene = viewer.getSplatScene(currFrameIndex);
                             prevSplatScene.scale.copy(invisible_scale);
 
                             startTime = performance.now();
                             currFrameIndex++;
                             if (currFrameIndex >= NUM_FRAMES) currFrameIndex = 0;
 
@@ -78,15 +80,9 @@
     .model4DGS {
         display: flex;
         position: relative;
         width: var(--size-full);
         height: var(--size-full);
         min-height: 250px;
     }
-    canvas {
-        width: var(--size-full);
-        height: var(--size-full);
-        object-fit: contain;
-        overflow: hidden;
-    }
 </style>
```

### Comparing `gradio_model4dgs-0.0.2/README.md` & `gradio_model4dgs-0.0.3/README.md`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,20 @@
+---
+title: gradio-model4dgs
+colorFrom: purple
+colorTo: yellow
+sdk: gradio
+sdk_version: 4.29.0
+app_file: app.py
+pinned: false
+license: mit
+---
 
 # `gradio_model4dgs`
-<img alt="Static Badge" src="https://img.shields.io/badge/version%20-%200.0.2%20-%20orange">  
+<a href="https://pypi.org/project/gradio_model4dgs/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_model4dgs"></a>  
 
 Python library for easily interacting with trained machine learning models
 
 ## Installation
 
 ```bash
 pip install gradio_model4dgs
@@ -13,22 +23,27 @@
 ## Usage
 
 ```python
 import gradio as gr
 from gradio_model4dgs import Model4DGS
 import os
 
-examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
+image_dir = os.path.join(os.path.dirname(__file__), "assets")
+
+if os.path.exists(image_dir) and os.path.isdir(image_dir) and os.listdir(image_dir):
+    examples = [os.path.join(image_dir, file) for file in os.listdir(image_dir)]
+else:
+    examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
 
 with gr.Blocks() as demo:
     with gr.Row():
         Model4DGS(value=examples, label="4D Model")
 
 if __name__ == "__main__":
-    demo.launch()
+    demo.launch(share=True)
 ```
 
 ## `Model4DGS`
 
 ### Initialization
 
 <table>
```

### Comparing `gradio_model4dgs-0.0.2/pyproject.toml` & `gradio_model4dgs-0.0.3/pyproject.toml`

 * *Files 10% similar despite different names*

```diff
@@ -4,20 +4,20 @@
   "hatch-requirements-txt",
   "hatch-fancy-pypi-readme>=22.5.0",
 ]
 build-backend = "hatchling.build"
 
 [project]
 name = "gradio_model4dgs"
-version = "0.0.2"
+version = "0.0.3"
 description = "Python library for easily interacting with trained machine learning models"
 readme = "README.md"
 license = "MIT"
 requires-python = ">=3.8"
-authors = [{ name = "YOUR NAME", email = "YOUREMAIL@domain.com" }]
+authors = [{ name = "Zhang Chi", email = "chi.zhang.helen@gmail.com" }]
 keywords = ["gradio-custom-component", "gradio-template-Fallback"]
 # Add dependencies here
 dependencies = ["gradio>=4.0,<5.0"]
 classifiers = [
   'Development Status :: 3 - Alpha',
   'License :: OSI Approved :: Apache Software License',
   'Operating System :: OS Independent',
@@ -32,11 +32,11 @@
   'Topic :: Scientific/Engineering :: Visualization',
 ]
 
 [project.optional-dependencies]
 dev = ["build", "twine"]
 
 [tool.hatch.build]
-artifacts = ["/backend/gradio_model4dgs/templates", "*.pyi", "backend/gradio_model4dgs/templates", "backend/gradio_model4dgs/templates", "backend/gradio_model4dgs/templates"]
+artifacts = ["/backend/gradio_model4dgs/templates", "*.pyi"]
 
 [tool.hatch.build.targets.wheel]
 packages = ["/backend/gradio_model4dgs"]
```

### Comparing `gradio_model4dgs-0.0.2/PKG-INFO` & `gradio_model4dgs-0.0.3/PKG-INFO`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,12 @@
-Metadata-Version: 2.1
+Metadata-Version: 2.3
 Name: gradio_model4dgs
-Version: 0.0.2
+Version: 0.0.3
 Summary: Python library for easily interacting with trained machine learning models
-Author-email: YOUR NAME <YOUREMAIL@domain.com>
+Author-email: Zhang Chi <chi.zhang.helen@gmail.com>
 License-Expression: MIT
 Keywords: gradio-custom-component,gradio-template-Fallback
 Classifier: Development Status :: 3 - Alpha
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3 :: Only
@@ -20,17 +20,27 @@
 Requires-Python: >=3.8
 Requires-Dist: gradio<5.0,>=4.0
 Provides-Extra: dev
 Requires-Dist: build; extra == 'dev'
 Requires-Dist: twine; extra == 'dev'
 Description-Content-Type: text/markdown
 
+---
+title: gradio-model4dgs
+colorFrom: purple
+colorTo: yellow
+sdk: gradio
+sdk_version: 4.29.0
+app_file: app.py
+pinned: false
+license: mit
+---
 
 # `gradio_model4dgs`
-<img alt="Static Badge" src="https://img.shields.io/badge/version%20-%200.0.2%20-%20orange">  
+<a href="https://pypi.org/project/gradio_model4dgs/" target="_blank"><img alt="PyPI - Version" src="https://img.shields.io/pypi/v/gradio_model4dgs"></a>  
 
 Python library for easily interacting with trained machine learning models
 
 ## Installation
 
 ```bash
 pip install gradio_model4dgs
@@ -39,22 +49,27 @@
 ## Usage
 
 ```python
 import gradio as gr
 from gradio_model4dgs import Model4DGS
 import os
 
-examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
+image_dir = os.path.join(os.path.dirname(__file__), "assets")
+
+if os.path.exists(image_dir) and os.path.isdir(image_dir) and os.listdir(image_dir):
+    examples = [os.path.join(image_dir, file) for file in os.listdir(image_dir)]
+else:
+    examples = [os.path.join(os.path.dirname(__file__), example) for example in Model4DGS().example_inputs()]
 
 with gr.Blocks() as demo:
     with gr.Row():
         Model4DGS(value=examples, label="4D Model")
 
 if __name__ == "__main__":
-    demo.launch()
+    demo.launch(share=True)
 ```
 
 ## `Model4DGS`
 
 ### Initialization
 
 <table>
```


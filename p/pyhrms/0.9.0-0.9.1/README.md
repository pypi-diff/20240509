# Comparing `tmp/pyhrms-0.9.0.zip` & `tmp/pyhrms-0.9.1.zip`

## zipinfo {}

```diff
@@ -1,16 +1,16 @@
-Zip file size: 101775 bytes, number of entries: 14
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-20 23:30 pyhrms-0.9.0/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/
-drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms/
--rw-r--r--  2.0 unx    29957 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/PKG-INFO
--rwx------  2.0 unx      927 b- defN 24-Apr-20 23:18 pyhrms-0.9.0/setup.py
--rw-r--r--  2.0 unx       38 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/setup.cfg
--rwx------  2.0 unx    25411 b- defN 24-Apr-20 23:29 pyhrms-0.9.0/README.rst
--rw-r--r--  2.0 unx    29957 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/PKG-INFO
--rw-r--r--  2.0 unx      204 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/SOURCES.txt
--rw-r--r--  2.0 unx      181 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/requires.txt
--rw-r--r--  2.0 unx        7 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/top_level.txt
--rw-r--r--  2.0 unx        1 b- defN 24-Apr-20 23:30 pyhrms-0.9.0/pyhrms.egg-info/dependency_links.txt
--rwx------  2.0 unx   308434 b- defN 24-Apr-20 23:17 pyhrms-0.9.0/pyhrms/pyhrms.py
--rwx------  2.0 unx     2199 b- defN 24-Apr-20 23:18 pyhrms-0.9.0/pyhrms/__init__.py
-14 files, 397316 bytes uncompressed, 99853 bytes compressed:  74.9%
+Zip file size: 105015 bytes, number of entries: 14
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-09 18:17 pyhrms-0.9.1/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-May-09 18:17 pyhrms-0.9.1/pyhrms/
+-rw-r--r--  2.0 unx    30509 b- defN 24-May-09 18:17 pyhrms-0.9.1/PKG-INFO
+-rwx------  2.0 unx      927 b- defN 24-May-09 18:07 pyhrms-0.9.1/setup.py
+-rw-r--r--  2.0 unx       38 b- defN 24-May-09 18:17 pyhrms-0.9.1/setup.cfg
+-rwx------  2.0 unx    25939 b- defN 24-May-09 18:15 pyhrms-0.9.1/README.rst
+-rw-r--r--  2.0 unx    30509 b- defN 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/PKG-INFO
+-rw-r--r--  2.0 unx      204 b- defN 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/SOURCES.txt
+-rw-r--r--  2.0 unx      181 b- defN 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/requires.txt
+-rw-r--r--  2.0 unx        7 b- defN 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/top_level.txt
+-rw-r--r--  2.0 unx        1 b- defN 24-May-09 18:17 pyhrms-0.9.1/pyhrms.egg-info/dependency_links.txt
+-rwx------  2.0 unx   317974 b- defN 24-May-09 18:06 pyhrms-0.9.1/pyhrms/pyhrms.py
+-rwx------  2.0 unx     2225 b- defN 24-May-09 18:07 pyhrms-0.9.1/pyhrms/__init__.py
+14 files, 408514 bytes uncompressed, 103093 bytes compressed:  74.8%
```

## zipnote {}

```diff
@@ -1,43 +1,43 @@
-Filename: pyhrms-0.9.0/
+Filename: pyhrms-0.9.1/
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/
+Filename: pyhrms-0.9.1/pyhrms.egg-info/
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms/
+Filename: pyhrms-0.9.1/pyhrms/
 Comment: 
 
-Filename: pyhrms-0.9.0/PKG-INFO
+Filename: pyhrms-0.9.1/PKG-INFO
 Comment: 
 
-Filename: pyhrms-0.9.0/setup.py
+Filename: pyhrms-0.9.1/setup.py
 Comment: 
 
-Filename: pyhrms-0.9.0/setup.cfg
+Filename: pyhrms-0.9.1/setup.cfg
 Comment: 
 
-Filename: pyhrms-0.9.0/README.rst
+Filename: pyhrms-0.9.1/README.rst
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/PKG-INFO
+Filename: pyhrms-0.9.1/pyhrms.egg-info/PKG-INFO
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/SOURCES.txt
+Filename: pyhrms-0.9.1/pyhrms.egg-info/SOURCES.txt
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/requires.txt
+Filename: pyhrms-0.9.1/pyhrms.egg-info/requires.txt
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/top_level.txt
+Filename: pyhrms-0.9.1/pyhrms.egg-info/top_level.txt
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms.egg-info/dependency_links.txt
+Filename: pyhrms-0.9.1/pyhrms.egg-info/dependency_links.txt
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms/pyhrms.py
+Filename: pyhrms-0.9.1/pyhrms/pyhrms.py
 Comment: 
 
-Filename: pyhrms-0.9.0/pyhrms/__init__.py
+Filename: pyhrms-0.9.1/pyhrms/__init__.py
 Comment: 
 
 Zip file comment:
```

## Comparing `pyhrms-0.9.0/PKG-INFO` & `pyhrms-0.9.1/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.2
 Name: pyhrms
-Version: 0.9.0
+Version: 0.9.1
 Summary: A powerful GC/LC-HRMS data analysis tool
 Home-page: https://github.com/WangRui5/PyHRMS.git
 Author: Wang Rui
 Author-email: wtrt7009@gmail.com
 License: UNKNOWN
 Description: PyHRMS: Tools For working with High Resolution Mass Spectrometry (HRMS) data in Environmental Science
         =====================================================================================================
@@ -15,23 +15,23 @@
         
         Contributer: Rui Wang
         ======================
         First release date: Nov.15.2021
         
         Update
         ======
-        Apr.20.2024: pyhrms 0.9.0 new features:
+        May.9.2024: pyhrms update Log 0.9.1::
         
-            * Modified evaluate_ms to retain five decimal places;
+            * Updated 'summarize_result' function to now include Source information retrieval.
         
-            * Fixed issue where peak_checking_area returned zeros;
+            * Improved the performance of 'peak_checking_area' for faster processing.
         
-            * Updated gen_DDA_ms2_df;
+            * Updated 'one_step_process_ms2' along with its internal functions to enhance functionality.
         
-            * Resolved issues in post_filter.
+            * Added a new function 'convert_df_to_mgf' to facilitate conversion of DataFrame to MGF files.
         
         pyhrms can be installed and import as following:
         
         .. code-block:: python
         
             pip install pyhrms
         
@@ -104,14 +104,16 @@
         
         * Xia, D., Liu, H., Lu, Y., Liu, Y., Liang, J., Xie, D., Lu, G., Qiu, J., Wang, R., 2023. Utility of a non-target screening method to explore the chlorination of similar sulfonamide antibiotics: Pathways and N Cl intermediates. Sci. Total Environ. 858, 160042. https://doi.org/10.1016/j.scitotenv.2022.160042
         
         * Yang, X., Wang, R., He, Z., Dai, X., Jiang, X., Liu, H., Li, Y., 2023. Abiotic transformation of synthetic progestins in representative soil mineral suspensions. J. Environ. Sci. 127, 375–388. https://doi.org/10.1016/j.jes.2022.06.007
         
         * Liu, H., Wang, R., Zhao, B., Xie, D., 2024. Assessment for the data processing performance of non-target screening analysis based on high-resolution mass spectrometry. Sci. Total Environ. 908, 167967. https://doi.org/10.1016/j.scitotenv.2023.167967
         
+        * Liu, H.; Zhao, B.; Jin, M.; Wang, R.; Ding, Z.; Wang, X.; Xu, W.; Chen, Q.; Tao, R.; Fu, J.; Xie, D. Anthropogenic-Induced Ecological Risks on Marine Ecosystems Indicated by Characterizing Emerging Pollutants in Pearl River Estuary, China. Sci. Total Environ. 2024, 926, 172030. https://doi.org/10.1016/j.scitotenv.2024.172030.
+        
         
         Licensing
         =========
         
         The package is open source and can be utilized under MIT license. Please find the detail in licence file.
         
         
@@ -242,14 +244,15 @@
           |- calculate_mass_percentage
           |- pubchem_search
           |- get_correction_factor_waters
           |- compare_ms_spectra
           |- first_process_ms2
           |- second_process_ms2
           |- one_step_process_ms2
+          |- convert_df_to_mgf
           
         
         Table of Content
         ~~~~~~~~~~~~~~~~~~~
         
         1. Quick start
```

## Comparing `pyhrms-0.9.0/setup.py` & `pyhrms-0.9.1/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -2,15 +2,15 @@
 
 def readme_file():
     with open('README.rst') as rf:
         return rf.read()
 
 setuptools.setup(
     name = 'pyhrms',
-    version = '0.9.0',
+    version = '0.9.1',
     author = 'Wang Rui',
     author_email = 'wtrt7009@gmail.com',
     url = 'https://github.com/WangRui5/PyHRMS.git',
     description = 'A powerful GC/LC-HRMS data analysis tool',
     long_description = readme_file(),
     packages = setuptools.find_packages(),
     install_requires = ['numpy>=1.19.2','pandas>=1.3.3'
```

## Comparing `pyhrms-0.9.0/README.rst` & `pyhrms-0.9.1/README.rst`

 * *Files 2% similar despite different names*

```diff
@@ -7,23 +7,23 @@
 
 Contributer: Rui Wang
 ======================
 First release date: Nov.15.2021
 
 Update
 ======
-Apr.20.2024: pyhrms 0.9.0 new features:
+May.9.2024: pyhrms update Log 0.9.1::
 
-    * Modified evaluate_ms to retain five decimal places;
+    * Updated 'summarize_result' function to now include Source information retrieval.
 
-    * Fixed issue where peak_checking_area returned zeros;
+    * Improved the performance of 'peak_checking_area' for faster processing.
 
-    * Updated gen_DDA_ms2_df;
+    * Updated 'one_step_process_ms2' along with its internal functions to enhance functionality.
 
-    * Resolved issues in post_filter.
+    * Added a new function 'convert_df_to_mgf' to facilitate conversion of DataFrame to MGF files.
 
 pyhrms can be installed and import as following:
 
 .. code-block:: python
 
     pip install pyhrms
 
@@ -96,14 +96,16 @@
 
 * Xia, D., Liu, H., Lu, Y., Liu, Y., Liang, J., Xie, D., Lu, G., Qiu, J., Wang, R., 2023. Utility of a non-target screening method to explore the chlorination of similar sulfonamide antibiotics: Pathways and N Cl intermediates. Sci. Total Environ. 858, 160042. https://doi.org/10.1016/j.scitotenv.2022.160042
 
 * Yang, X., Wang, R., He, Z., Dai, X., Jiang, X., Liu, H., Li, Y., 2023. Abiotic transformation of synthetic progestins in representative soil mineral suspensions. J. Environ. Sci. 127, 375–388. https://doi.org/10.1016/j.jes.2022.06.007
 
 * Liu, H., Wang, R., Zhao, B., Xie, D., 2024. Assessment for the data processing performance of non-target screening analysis based on high-resolution mass spectrometry. Sci. Total Environ. 908, 167967. https://doi.org/10.1016/j.scitotenv.2023.167967
 
+* Liu, H.; Zhao, B.; Jin, M.; Wang, R.; Ding, Z.; Wang, X.; Xu, W.; Chen, Q.; Tao, R.; Fu, J.; Xie, D. Anthropogenic-Induced Ecological Risks on Marine Ecosystems Indicated by Characterizing Emerging Pollutants in Pearl River Estuary, China. Sci. Total Environ. 2024, 926, 172030. https://doi.org/10.1016/j.scitotenv.2024.172030.
+
 
 Licensing
 =========
 
 The package is open source and can be utilized under MIT license. Please find the detail in licence file.
 
 
@@ -234,14 +236,15 @@
   |- calculate_mass_percentage
   |- pubchem_search
   |- get_correction_factor_waters
   |- compare_ms_spectra
   |- first_process_ms2
   |- second_process_ms2
   |- one_step_process_ms2
+  |- convert_df_to_mgf
   
 
 Table of Content
 ~~~~~~~~~~~~~~~~~~~
 
 1. Quick start
```

## Comparing `pyhrms-0.9.0/pyhrms.egg-info/PKG-INFO` & `pyhrms-0.9.1/pyhrms.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.2
 Name: pyhrms
-Version: 0.9.0
+Version: 0.9.1
 Summary: A powerful GC/LC-HRMS data analysis tool
 Home-page: https://github.com/WangRui5/PyHRMS.git
 Author: Wang Rui
 Author-email: wtrt7009@gmail.com
 License: UNKNOWN
 Description: PyHRMS: Tools For working with High Resolution Mass Spectrometry (HRMS) data in Environmental Science
         =====================================================================================================
@@ -15,23 +15,23 @@
         
         Contributer: Rui Wang
         ======================
         First release date: Nov.15.2021
         
         Update
         ======
-        Apr.20.2024: pyhrms 0.9.0 new features:
+        May.9.2024: pyhrms update Log 0.9.1::
         
-            * Modified evaluate_ms to retain five decimal places;
+            * Updated 'summarize_result' function to now include Source information retrieval.
         
-            * Fixed issue where peak_checking_area returned zeros;
+            * Improved the performance of 'peak_checking_area' for faster processing.
         
-            * Updated gen_DDA_ms2_df;
+            * Updated 'one_step_process_ms2' along with its internal functions to enhance functionality.
         
-            * Resolved issues in post_filter.
+            * Added a new function 'convert_df_to_mgf' to facilitate conversion of DataFrame to MGF files.
         
         pyhrms can be installed and import as following:
         
         .. code-block:: python
         
             pip install pyhrms
         
@@ -104,14 +104,16 @@
         
         * Xia, D., Liu, H., Lu, Y., Liu, Y., Liang, J., Xie, D., Lu, G., Qiu, J., Wang, R., 2023. Utility of a non-target screening method to explore the chlorination of similar sulfonamide antibiotics: Pathways and N Cl intermediates. Sci. Total Environ. 858, 160042. https://doi.org/10.1016/j.scitotenv.2022.160042
         
         * Yang, X., Wang, R., He, Z., Dai, X., Jiang, X., Liu, H., Li, Y., 2023. Abiotic transformation of synthetic progestins in representative soil mineral suspensions. J. Environ. Sci. 127, 375–388. https://doi.org/10.1016/j.jes.2022.06.007
         
         * Liu, H., Wang, R., Zhao, B., Xie, D., 2024. Assessment for the data processing performance of non-target screening analysis based on high-resolution mass spectrometry. Sci. Total Environ. 908, 167967. https://doi.org/10.1016/j.scitotenv.2023.167967
         
+        * Liu, H.; Zhao, B.; Jin, M.; Wang, R.; Ding, Z.; Wang, X.; Xu, W.; Chen, Q.; Tao, R.; Fu, J.; Xie, D. Anthropogenic-Induced Ecological Risks on Marine Ecosystems Indicated by Characterizing Emerging Pollutants in Pearl River Estuary, China. Sci. Total Environ. 2024, 926, 172030. https://doi.org/10.1016/j.scitotenv.2024.172030.
+        
         
         Licensing
         =========
         
         The package is open source and can be utilized under MIT license. Please find the detail in licence file.
         
         
@@ -242,14 +244,15 @@
           |- calculate_mass_percentage
           |- pubchem_search
           |- get_correction_factor_waters
           |- compare_ms_spectra
           |- first_process_ms2
           |- second_process_ms2
           |- one_step_process_ms2
+          |- convert_df_to_mgf
           
         
         Table of Content
         ~~~~~~~~~~~~~~~~~~~
         
         1. Quick start
```

## Comparing `pyhrms-0.9.0/pyhrms/pyhrms.py` & `pyhrms-0.9.1/pyhrms/pyhrms.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,14 +24,15 @@
 import itertools
 import bisect
 import re
 from collections import defaultdict
 import requests
 from bs4 import BeautifulSoup
 import networkx as nx
+import shutil
 
 """
 ========================================================================================================
 1. basic function
 ========================================================================================================
 """
 
@@ -859,15 +860,15 @@
         iso_info_s1 = (iso_info_s / iso_info_s.values.max()).sort_index().round(3)
         iso_info_s2 = iso_info_s1[iso_info_s1 > 0.015].to_dict()
         return iso_info_s2
 
 
 def isotope_score(iso_info, formula, mode='pos', i_threshold=2, error=0.015):
     """
-    Calculate the isotope matching score based on the observed isotope distribution and
+    Calculate the isotope matching score based on the observed isotope distribution and 
     the theoretical distribution for a given molecular formula.
 
     Args:
         iso_info (dict): The observed isotope distribution.
         formula (str): The molecular formula.
         mode (str): Analysis mode - 'pos' for positive, 'neg' for negative. Defaults to 'pos'.
         i_threshold (float): The intensity threshold for theoretical isotope distribution. Defaults to 2.
@@ -1586,18 +1587,33 @@
     mz_locators = np.array([left_locator, right_locator]).T
 
     # 3. find the locators of rt
     df_rt = df1.columns.values
     rt_locators = [[argmin(abs(df_rt - (rt - 0.2))), argmin(abs(df_rt - (rt + 0.2)))] for rt in rts]
     rt_locators = [[x[0], x[1] if x[0] != x[1] else x[1] + 1] for x in rt_locators]  # 有时候locators是一样的[616:616] 加个保护机制
     # 4. obtain the peak areas
-    area_all = [round(scipy.integrate.simps(
-        df1.iloc[mz_locators[i][0]:mz_locators[i][1], rt_locators[i][0]:rt_locators[i][1]].values.sum(axis=0) - min(
-            df1.iloc[mz_locators[i][0]:mz_locators[i][1], rt_locators[i][0]:rt_locators[i][1]].values.sum(axis=0))),
-        0) + 1 for i in range(len(mz_locators))]
+    area_all = []
+    #     rt_target_all = []
+    #     eic_target_all = []
+    for i in range(len(mz_locators)):
+        # 截取数据
+        df2 = df1.iloc[mz_locators[i][0]:mz_locators[i][1],
+              rt_locators[i][0]:rt_locators[i][1]]
+        sub_array = df2.values
+        # 按列求和
+        column_sums = sub_array.sum(axis=0)
+        # 计算Simpson积分
+        integral = scipy.integrate.simps(column_sums - min(column_sums))
+        # 对积分结果四舍五入，并加1
+        rounded_integral = round(integral, 0) + 1
+        # 将结果添加到列表中
+        area_all.append(rounded_integral)
+        # 获得原始数据
+    #         rt_target_all.append(str(df2.columns.values))
+    #         eic_target_all.append(str(df2.sum(axis=0).values))
     # Uses the locators found in stepas 2 and 3 to calculate the peak areas for each rt&mz pair in `df1`, using the `scipy.integrate.simps` function.
 
     if sn_info == False:
         sample_area = pd.DataFrame(area_all, index=peak_index, columns=[name])
         return sample_area  # Adds 1 to each value in the resulting data frame and returns it to avoid zero value in result.
     else:
         rt_locators_point = [argmin(abs(df_rt - rt)) for rt in rts]
@@ -1883,28 +1899,28 @@
         centroid_data = pd.Series(name=profile_data.name, dtype='float64')
 
     return centroid_data
 
 
 def gen_DDA_ms2_df(ms1, ms2, i_threshold=0, profile=True, opt=False, more_info=False, message=''):
     """
-    Generates a DataFrame from DDA MS2 data with detailed information on retention times,
+    Generates a DataFrame from DDA MS2 data with detailed information on retention times, 
     precursors, fragments, and additional metrics depending on specified options.
 
     Args:
         ms1 (list): List of MS1 scans.
         ms2 (list): List of MS2 scans.
         i_threshold (float): Minimum intensity threshold for peak consideration. Defaults to 0.
         profile (bool): Indicates if data is in profile mode (True) or centroid mode (False). Defaults to True.
         opt (bool): If True, performs optimization on mass data. Defaults to False.
         more_info (bool): If True, additional information from MS1 is appended to the DataFrame. Defaults to False.
         message (str): Message to display during extended information gathering. Defaults to an empty string.
 
     Returns:
-        pandas.DataFrame: Contains columns for retention time (rt), precursor m/z, fragments (frag),
+        pandas.DataFrame: Contains columns for retention time (rt), precursor m/z, fragments (frag), 
                           intensity, collision energy, mode of ionization, scan index, MS2 spectra,
                           isotope distribution, and optionally optimized fragment m/z and MS1 data.
 
     Note:
         The function supports dynamic generation of data based on the `profile`, `opt`, and `more_info` flags,
         adapting the output DataFrame accordingly. The function requires tqdm and pandas libraries for execution.
     """
@@ -2512,15 +2528,15 @@
     exp_columns = ['new_index', 'rt', 'mz', 'intensity', 'S/N', 'area', 'mz_opt', 'frag_DIA', 'iso_distribution',
                    'resolution', MS2_spec_column]
     assured_columns = [i for i in exp_columns if i in df.columns]
 
     sorted_columns = ['new_index', 'name', 'formula', 'CAS', 'ik', 'Smile', 'rt', 'mz', 'intensity', 'iso_distribution',
                       'S/N', 'area', 'frag_DIA', 'mz_opt', 'resolution', 'MS2_spectra', 'rt_error', 'ms1_error',
                       'ms1_opt_error', 'match_num', 'iso_score',
-                      'match_percent', 'match_info', 'MS2 mode', 'source', 'source info', 'Norman_SusDat_ID',
+                      'match_percent', 'match_info', 'MS2 mode', 'Source', 'Source info', 'Norman_SusDat_ID',
                       'Lowest PNEC Freshwater [µg//l]', 'Lowest PNEC Marine water [µg//l]',
                       'Lowest PNEC Sediments [µg//kg dw]', 'Lowest PNEC Biota (fish) [µg//kg ww]']
     final_result_all = []
     for i in tqdm(range(len(df)), desc='Summarizing matched result'):
 
         cmp = df.loc[i, assured_columns]
         # 1. 把所有信息合并一起
@@ -3033,15 +3049,15 @@
         df = pd.read_excel(file)
         df1 = remove_adducts(df, mode=mode)
         df1.to_excel(file.replace('.xlsx', '_removing_adducts.xlsx'))
 
 
 def DDA_to_DIA_result(path, company, profile):
     """
-  This function processes DDA (Data-Dependent Acquisition) data in mzML format
+  This function processes DDA (Data-Dependent Acquisition) data in mzML format 
   and integrates the results into existing Excel files containing unique company information.
 
   Args:
       path (str): Path to the directory containing mzML files and Excel files.
       company (str): Name of the company associated with the data.
       profile (str): Profile to be used for DDA data processing.
 
@@ -3085,29 +3101,29 @@
 2. Swath data process
 ========================================================================================================
 """
 
 
 def swath_window_checking(file, precursor_ion_start_mass=99.5, mz_overlap=1):
     """
-    Analyzes the precursor ion windows in a given mzML file. This function separates MS1 and MS2 scans,
-    determines unique precursor ions, and calculates the mass spectrum range for each precursor ion window
+    Analyzes the precursor ion windows in a given mzML file. This function separates MS1 and MS2 scans, 
+    determines unique precursor ions, and calculates the mass spectrum range for each precursor ion window 
     based on the starting mass and overlap values.
 
     Parameters:
     - file (str): Path to the mzML file containing mass spectrometry data.
     - precursor_ion_start_mass (float, optional): Specifies the initial mass value for the sequential mass window in ion analysis.
       Defaults to 99.5.
     - mz_overlap (float, optional): Defines the amount of overlap between consecutive MS2 windows in mass units. Defaults to 1.
 
     Returns:
     - dict: A dictionary mapping each precursor ion to its corresponding mass spectrum range [start, end].
 
     Note:
-    The function first calculates the window size for the initial precursor ion manually and then iteratively for the remaining ions,
+    The function first calculates the window size for the initial precursor ion manually and then iteratively for the remaining ions, 
     considering the specified overlap.
     """
 
     ms1, ms2 = sep_scans(file, 'AB')  # 分离ms1和ms2
     # 1. 获得所有selected precursors
     all_precursors = []
     for scan in ms2:
@@ -4254,43 +4270,43 @@
 4. FT-ICRMS data processing
 ========================================================================================================
 """
 
 
 def draw_Van_Krevelen_diagrams(result, name='', path=None, dpi=300):
     """
-    Draws Van Krevelen diagrams to visually classify and compare the elemental composition
-    of organic compounds based on their hydrogen-to-carbon (H/C) and oxygen-to-carbon (O/C) ratios.
-    This function differentiates between compounds containing only carbon, hydrogen, and oxygen (CHO),
-    those also containing nitrogen (CHON), sulfur (CHOS), or both (CHONS), and plots them on the diagram
-    with distinct markers. Additionally, it delineates stoichiometric regions associated with different
+    Draws Van Krevelen diagrams to visually classify and compare the elemental composition 
+    of organic compounds based on their hydrogen-to-carbon (H/C) and oxygen-to-carbon (O/C) ratios. 
+    This function differentiates between compounds containing only carbon, hydrogen, and oxygen (CHO), 
+    those also containing nitrogen (CHON), sulfur (CHOS), or both (CHONS), and plots them on the diagram 
+    with distinct markers. Additionally, it delineates stoichiometric regions associated with different 
     compound classes such as lipids, proteins, lignins, carbohydrates, etc., on the diagram.
 
     Parameters:
-        result (Pandas DataFrame): A DataFrame containing the columns 'C', 'H', 'O', 'N', and 'S'
+        result (Pandas DataFrame): A DataFrame containing the columns 'C', 'H', 'O', 'N', and 'S' 
                                    which represent the count of each element in the compounds. Must not
                                    contain NaN values in the 'C' column.
         name (str, optional): Title of the plot. Defaults to an empty string.
-        path (str, optional): File path where the plot image will be saved. If None, the plot is shown
+        path (str, optional): File path where the plot image will be saved. If None, the plot is shown 
                               using plt.show(). Defaults to None.
         dpi (int, optional): The resolution of the saved plot image in dots per inch. Defaults to 300.
 
     Returns:
         None. Displays the Van Krevelen diagram or saves it as a file, depending on the 'path' parameter.
 
     Raises:
         ValueError: If the 'result' DataFrame does not contain the required columns ('C', 'H', 'O', 'N', 'S').
 
     Example usage:
         draw_Van_Krevelen_diagrams(result_df, name='Sample Van Krevelen Diagram', path='diagram.png', dpi=300)
 
     Note:
-        - This function is specifically designed for analyzing and visualizing elemental compositions
+        - This function is specifically designed for analyzing and visualizing elemental compositions 
           in organic geochemistry and may not be applicable for other types of data.
-        - Ensure the 'result' DataFrame is preprocessed to remove NaN values in 'C' column and contains
+        - Ensure the 'result' DataFrame is preprocessed to remove NaN values in 'C' column and contains 
           the necessary elemental columns before calling this function.
     """
 
     # 数据处理
     result1 = result[~result['C'].isna()]
     CHO = result1[(result1['N'] == 0) & (result1['S'] == 0)]
     CHO_OC = CHO['O/C']
@@ -6296,24 +6312,24 @@
 
 def get_correction_factor_waters(file, lock_mass=556.2771):
     """
     Calculate the correction factor for Waters LC-TOF-MS data based on the lockmass value.
 
     Parameters:
     - file (str): Path to the mzML file containing the LC-TOF-MS data.
-    - lockmass (float, optional): The lockmass value used for correction. Default values are
+    - lockmass (float, optional): The lockmass value used for correction. Default values are 
       556.2771 for positive mode and 554.2615 for negative mode.
 
     Returns:
     tuple: A tuple containing two elements:
         - factor_median (float): The median of the calculated correction factors.
         - factor_mean (float): The mean of the calculated correction factors.
 
-    The function reads the provided mzML file, identifies the lockmass peaks, and calculates the
-    correction factors for mass-to-charge (m/z) values. The median and mean of these factors are
+    The function reads the provided mzML file, identifies the lockmass peaks, and calculates the 
+    correction factors for mass-to-charge (m/z) values. The median and mean of these factors are 
     then returned.
     """
     run = pymzml.run.Reader(file)
     function_nums = [scan.id_dict['function'] for scan in run]
     func_num_max = max(function_nums)
     lockspray = [scan for scan in run if scan.id_dict['function'] == func_num_max]
     mz_corr_factors = []
@@ -6372,15 +6388,37 @@
 
 
 def first_process_ms2(file, company, profile=True,
                       i_threshold=200, SN_threshold=3, peak_width=2, threshold=15,
                       frag_rt_error=0.02, split_n=20, sat_intensity=False, long_rt_split_n=1,
                       orbi=False, message=''):
     """
-    Only for MS2 data
+    Processes High-Resolution Mass Spectrometry (HRMS) MS2 data by performing peak picking
+    and exporting the results to an Excel file.
+
+    Args:
+        file (str): Path to the input .mzML file to be processed.
+        company (str): The manufacturer of the instrument used to generate the data (e.g., 'Waters', 'Agilent').
+        profile (bool): If True, profiles of chromatographic peaks are analyzed; otherwise, profiling is skipped.
+        i_threshold (int): The minimum intensity required for a peak to be considered for analysis.
+        SN_threshold (int): The signal-to-noise ratio below which peaks are ignored.
+        peak_width (int): Expected width of peaks in the chromatogram, used for peak detection.
+        threshold (int): General intensity threshold used across various peak detection algorithms.
+        frag_rt_error (float): Maximum allowed retention time deviation for matching MS2 fragments to their precursor peaks.
+        split_n (int): Number of segments to split the data frame for parallel processing.
+        sat_intensity (bool): If True, adjusts retention times for saturated intensity peaks to ensure accurate m/z measurements.
+        long_rt_split_n (int): Number of segments to split the data for long retention time adjustments.
+        orbi (bool): Set to True if the data originates from an Orbitrap analyzer; False for Time-of-Flight (TOF) data.
+        message (str): Optional message or note regarding the processing details or parameters.
+
+    Returns:
+        None: Instead, the function saves the results as an Excel file in the same directory as the input file, replacing the '.mzML' extension with '_ms2_data.xlsx'.
+
+    Note:
+        Ensure that the required libraries for handling .mzML files and Excel output are properly installed and imported.
     """
 
     mz_round = 4
     ms1, ms2 = sep_scans(file, company, message=message)
     peak_all = ultimate_peak_picking(ms2, profile=profile, split_n=split_n, i_threshold=i_threshold,
                                      peak_width=peak_width, threshold=threshold,
                                      SN_threshold=SN_threshold, sat_intensity=sat_intensity,
@@ -6389,69 +6427,197 @@
     peak_selected = identify_isotopes(peak_all)
     peak_selected = remove_unnamed_columns(peak_selected)
     peak_selected.to_excel(file.replace('.mzML', '_ms2_data.xlsx'))
 
 
 def second_process_ms2(file, ref_all, company, profile=True, long_rt_split_n=1, orbi=False, message=''):
     """
-    Only for MS2 data
+    Analyzes MS2 data by comparing it against a set of reference retention time (rt) and m/z pairs,
+    and calculates the peak area for these reference points. The results are saved to an Excel file.
+
+    Args:
+        file (str): Path to the input .mzML file to be processed.
+        ref_all (DataFrame): DataFrame containing all reference peaks with rt and m/z information.
+        company (str): The manufacturer of the instrument used to generate the data (e.g., 'Waters', 'Agilent').
+        profile (bool): If True, profiles chromatographic peaks; if False, skips profiling.
+        long_rt_split_n (int): Number of segments to split the data for processing long retention times.
+        orbi (bool): Set to True if the data originates from an Orbitrap analyzer; False for Time-of-Flight (TOF) data.
+        message (str): Optional message or note regarding the processing details or parameters.
+
+    Returns:
+        None: Outputs results to an Excel file in the same directory as the input file, with the extension replaced by '_ms2_final_area.xlsx'.
+
+    Note:
+        Ensure that necessary libraries for handling .mzML files and Excel output are properly installed and imported.
     """
+
     ms_round = 4
     ms1, ms2 = sep_scans(file, company, message=message)
 
     name1 = os.path.basename(file).split('.')[0]
     final_result = ultimate_checking_area(ref_all, ms2, name1, profile=profile,
                                           rt_overlap=1, long_rt_split_n=long_rt_split_n, orbi=orbi, message=message)
     final_result.to_excel(file.replace('.mzML', '_ms2_final_area.xlsx'))
 
 
 def one_step_process_ms2(path, company, profile=True, control_group=['lab_blank', 'methanol'],
                          peak_width=2, threshold=15, filter_type=1, split_n=20, sat_intensity=False, long_rt_split_n=1,
                          orbi=False):
     """
-    Only for ms2 data.
+    Processes mzML data in a single-step procedure that includes peak picking and data comparison
+    between sample and control groups, and generates an Excel summary of the differences. This
+    function handles both MS1 and MS2 data processing.
+
+    Args:
+        path (str): File path for the mzML files to be processed, e.g., '../Users/Desktop/my_HRMS_files'.
+        company (str): Manufacturer of the mass spectrometer, e.g., 'Waters', 'Thermo', 'Sciex', 'Agilent'.
+        profile (bool): True if data is in profile mode, False for centroid mode.
+        control_group (list[str]): Labels identifying the control group files.
+        peak_width (int): The expected width of peaks used in peak detection algorithms.
+        threshold (int): Intensity threshold for peak detection.
+        filter_type (int): Operational mode for data analysis.
+            - 1: Computes fold change as the ratio of the sample area to the maximum control area.
+            - 2: For data with triplicates, calculates p-values and fold change as the ratio of 
+              mean sample area to mean control area.
+        split_n (int): Number of segments to split the dataframe for processing.
+        sat_intensity (bool): Adjusts for saturation intensity in peak measurements.
+        long_rt_split_n (int): Number of segments for handling long retention times.
+        orbi (bool): True for Orbitrap data, False for Time-of-Flight (TOF) data.
 
+    Returns:
+        None: Outputs Excel files summarizing differences between control and sample sets.
+
+    Note:
+        Ensure the mzML and Excel handling libraries are installed and properly configured. Calls
+        several other functions (`first_process_ms2`, `second_process_ms2`, etc.) that need to be defined
+        and correctly functioning for this script to work.
     """
+
     print('                                                                            ')
     print('============================================================================')
     print('First process...')
     print('============================================================================')
     print('                                                                            ')
 
     files_mzml = glob(os.path.join(path, '*.mzML'))
 
     files_mzml = [file for file in files_mzml if 'DDA' not in os.path.basename(file)]
     for j, file in enumerate(files_mzml):
+        first_process(file, company=company, profile=profile, ms2_analysis=False,
+                      peak_width=peak_width, threshold=threshold, split_n=split_n, sat_intensity=sat_intensity,
+                      long_rt_split_n=long_rt_split_n, orbi=orbi, message=f'No. {j + 1}_ms1 : ')
         first_process_ms2(file, company=company, profile=profile,
                           peak_width=peak_width, threshold=threshold, split_n=split_n, sat_intensity=sat_intensity,
-                          long_rt_split_n=long_rt_split_n, orbi=orbi, message=f'No. {j + 1} : ')
+                          long_rt_split_n=long_rt_split_n, orbi=orbi, message=f'No. {j + 1}_ms2 : ')
 
     # 中间过程
     files_excel = glob(os.path.join(path, '*.xlsx'))
     peak_alignment(files_excel)
     ref_all = pd.read_excel(os.path.join(path, 'peak_ref.xlsx'), index_col='Unnamed: 0')
 
     # 第二个过程
     print('                                                                            ')
     print('============================================================================')
     print('Second process...')
     print('============================================================================')
     print('                                                                            ')
     for j, file in enumerate(files_mzml):
+        second_process(file, ref_all, company, profile=profile, long_rt_split_n=long_rt_split_n, orbi=orbi,
+                       message=f'No. {j + 1}_ms1 ')
         second_process_ms2(file, ref_all, company, profile=profile, long_rt_split_n=long_rt_split_n, orbi=orbi,
-                           message=f'No. {j + 1} ')
+                           message=f'No. {j + 1}_ms2 ')
 
     # 第三个过程, 做fold change filter
     print('                                                                            ')
     print('============================================================================')
     print('Third process...')
     print('============================================================================')
     print('                                                                            ')
 
-    fold_change_filter(path, control_group=control_group, filter_type=filter_type)
+    # 创建文件夹路径
+    ms1_path = os.path.join(path, 'data_for_ms1')
+    ms2_path = os.path.join(path, 'data_for_ms2')
+    # 创建文件夹
+    if not os.path.exists(ms1_path):
+        os.makedirs(ms1_path)
+    if not os.path.exists(ms2_path):
+        os.makedirs(ms2_path)
+
+    # 先把ms2的文件的弄进去
+    excel_files = glob(os.path.join(path, '*.xlsx'))
+    ms2_names = ['_ms2_data.xlsx', '_ms2_data_alignment.xlsx', '_ms2_final_area.xlsx']
+    for file in excel_files:
+        if any([file.endswith(name) for name in ms2_names]):
+            shutil.move(file, os.path.join(ms2_path, os.path.basename(file)))
+
+    # 再把剩下所有的弄进去
+    excel_files = glob(os.path.join(path, '*.xlsx'))
+    for file in excel_files:
+        shutil.move(file, os.path.join(ms1_path, os.path.basename(file)))
+
+    # 分批处理fold change
+    fold_change_filter(ms1_path, control_group=control_group, filter_type=filter_type)
+    fold_change_filter(ms2_path, control_group=control_group, filter_type=filter_type)
+
+
+def convert_df_to_mgf(df, output_path, ms2_info_column, charge, max_num=None):
+    """
+    Converts a DataFrame containing MS2 spectra information into an MGF (Mascot Generic Format) file.
+
+    Args:
+        df (DataFrame): DataFrame containing unique compounds and their associated MS2 spectra. Each row represents a unique compound.
+        output_path (str): The path where the resulting MGF file will be saved.
+        ms2_info_column (str): Column name in the DataFrame where MS2 spectrum information is stored. This column should contain data structured as series.
+        charge (int): Precursor charge state (e.g., 1, -1) to be recorded in the MGF file.
+        max_num (int, optional): Maximum number of spectra to include in the MGF file. If None, all spectra in the DataFrame will be included.
+
+    Returns:
+        None: The function writes an MGF file to the specified output path, containing the spectra data formatted according to the MGF specifications.
+
+    Note:
+        The function relies on the DataFrame structure where each row contains MS2 data for different compounds, including retention time ('rt'), precursor m/z ('mz'), and intensity values.
+    """
+
+    def create_mgf_file(spectra, file_name=output_path):
+        with open(file_name, 'w') as file:
+            for spectrum in spectra:
+                file.write("BEGIN IONS\n")
+                file.write(f"TITLE={spectrum['title']}\n")
+                pepmass = spectrum['pepmass'][0] if spectrum['pepmass'][
+                                                        1] is None else f"{spectrum['pepmass'][0]} {spectrum['pepmass'][1]}"
+                file.write(f"PEPMASS={pepmass}\n")
+                file.write(f"CHARGE={spectrum['charge']}+\n")
+                if 'rtinseconds' in spectrum:
+                    file.write(f"RTINSECONDS={spectrum['rtinseconds']}\n")
+                for mz, intensity in zip(spectrum['mz_values'], spectrum['intensities']):
+                    file.write(f"{mz} {intensity}\n")
+                file.write("END IONS\n")
+
+    spectra = []
+    for i in tqdm(range(len(df))):
+        s1 = eval2(df.loc[i, ms2_info_column])
+
+        if len(s1) != 0:
+            mz_list = list(s1.index)
+            intensities = list(s1.values)
+            rt_in_second = df.loc[i, 'rt'] * 60
+            precursor = df.loc[i, 'mz']
+            dict2 = {
+                'title': f'MS/MS_of_{precursor},_{charge}_at_{round(rt_in_second / 60, 3)}min',
+                'pepmass': (precursor, None),  # (precursor m/z, intensity)
+                'charge': charge,  # Precursor charge state
+                'mz_values': mz_list,
+                'intensities': intensities,
+                'rtinseconds': rt_in_second  # Optional retention time in seconds
+            }
+            spectra.append(dict2)
+    if max_num is None:
+        create_mgf_file(spectra)
+    else:
+        create_mgf_file(spectra[:max_num])
 
 
 if __name__ == '__main__':
     pass
 # %config InlineBackendlineBackend.figure_format ='retina'
 #  plt.rcParams['font.sans-serif'] = 'Times New Roman'  # 设置全局字体
```

## Comparing `pyhrms-0.9.0/pyhrms/__init__.py` & `pyhrms-0.9.1/pyhrms/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from . import pyhrms
 
-__version__ = "0.9.0"
+__version__ = "0.9.1"
 
 __all__ = [
     "sep_scans",
     "gen_df",
     "peak_picking",
     "split_peak_picking",
     "remove_unnamed_columns",
@@ -82,10 +82,11 @@
     "compare_ms_spectra",
     "swath_window_checking",
     "isotope_score",
     "DDA_to_DIA_result",
     "draw_Van_Krevelen_diagrams",
     "first_process_ms2",
     "second_process_ms2",
-    "one_step_process_ms2"
+    "one_step_process_ms2",
+    "convert_df_to_mgf"
   
 ]
```


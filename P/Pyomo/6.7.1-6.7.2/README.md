# Comparing `tmp/Pyomo-6.7.1.tar.gz` & `tmp/Pyomo-6.7.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "Pyomo-6.7.1.tar", last modified: Wed Feb 21 17:29:35 2024, max compression
+gzip compressed data, was "Pyomo-6.7.2.tar", last modified: Thu May  9 15:34:26 2024, max compression
```

## Comparing `Pyomo-6.7.1.tar` & `Pyomo-6.7.2.tar`

### file list

```diff
@@ -1,1471 +1,1510 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.528348 Pyomo-6.7.1/
--rw-r--r--   0 runner    (1001) docker     (127)     1733 2024-02-21 17:29:26.000000 Pyomo-6.7.1/LICENSE.md
--rw-r--r--   0 runner    (1001) docker     (127)       37 2024-02-21 17:29:26.000000 Pyomo-6.7.1/MANIFEST.in
--rw-r--r--   0 runner    (1001) docker     (127)     6547 2024-02-21 17:29:35.528348 Pyomo-6.7.1/PKG-INFO
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.312348 Pyomo-6.7.1/Pyomo.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     6547 2024-02-21 17:29:34.000000 Pyomo-6.7.1/Pyomo.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)    51814 2024-02-21 17:29:35.000000 Pyomo-6.7.1/Pyomo.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-02-21 17:29:34.000000 Pyomo-6.7.1/Pyomo.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)      203 2024-02-21 17:29:34.000000 Pyomo-6.7.1/Pyomo.egg-info/entry_points.txt
--rw-r--r--   0 runner    (1001) docker     (127)      590 2024-02-21 17:29:34.000000 Pyomo-6.7.1/Pyomo.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)        6 2024-02-21 17:29:34.000000 Pyomo-6.7.1/Pyomo.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)     5211 2024-02-21 17:29:26.000000 Pyomo-6.7.1/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.312348 Pyomo-6.7.1/pyomo/
--rw-r--r--   0 runner    (1001) docker     (127)     3777 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/__future__.py
--rw-r--r--   0 runner    (1001) docker     (127)      595 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.320348 Pyomo-6.7.1/pyomo/common/
--rw-r--r--   0 runner    (1001) docker     (127)     1070 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1215 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/_command.py
--rw-r--r--   0 runner    (1001) docker     (127)     1372 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/_common.py
--rw-r--r--   0 runner    (1001) docker     (127)    12461 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/autoslots.py
--rw-r--r--   0 runner    (1001) docker     (127)      691 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/backports.py
--rw-r--r--   0 runner    (1001) docker     (127)     5014 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/cmake_builder.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.320348 Pyomo-6.7.1/pyomo/common/collections/
--rw-r--r--   0 runner    (1001) docker     (127)      829 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/collections/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6071 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/collections/bunch.py
--rw-r--r--   0 runner    (1001) docker     (127)     6886 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/collections/component_map.py
--rw-r--r--   0 runner    (1001) docker     (127)     4610 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/collections/component_set.py
--rw-r--r--   0 runner    (1001) docker     (127)     2572 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/collections/orderedset.py
--rw-r--r--   0 runner    (1001) docker     (127)    95774 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/config.py
--rw-r--r--   0 runner    (1001) docker     (127)    32346 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/dependencies.py
--rw-r--r--   0 runner    (1001) docker     (127)    21106 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/deprecation.py
--rw-r--r--   0 runner    (1001) docker     (127)    14270 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/download.py
--rw-r--r--   0 runner    (1001) docker     (127)    17402 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/env.py
--rw-r--r--   0 runner    (1001) docker     (127)     1264 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/envvar.py
--rw-r--r--   0 runner    (1001) docker     (127)     7496 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/errors.py
--rw-r--r--   0 runner    (1001) docker     (127)      631 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/extensions.py
--rw-r--r--   0 runner    (1001) docker     (127)     2243 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    26515 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/fileutils.py
--rw-r--r--   0 runner    (1001) docker     (127)    13929 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/formatting.py
--rw-r--r--   0 runner    (1001) docker     (127)     3014 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/gc_manager.py
--rw-r--r--   0 runner    (1001) docker     (127)      650 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/getGSL.py
--rw-r--r--   0 runner    (1001) docker     (127)     1259 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/gsl.py
--rw-r--r--   0 runner    (1001) docker     (127)    13112 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/log.py
--rw-r--r--   0 runner    (1001) docker     (127)     2744 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/modeling.py
--rw-r--r--   0 runner    (1001) docker     (127)     3119 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/multithread.py
--rw-r--r--   0 runner    (1001) docker     (127)    12127 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/numeric_types.py
--rw-r--r--   0 runner    (1001) docker     (127)      658 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/plugin.py
--rw-r--r--   0 runner    (1001) docker     (127)    12089 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/plugin_base.py
--rw-r--r--   0 runner    (1001) docker     (127)      563 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)     1165 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/pyomo_typing.py
--rw-r--r--   0 runner    (1001) docker     (127)     1133 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/shutdown.py
--rw-r--r--   0 runner    (1001) docker     (127)     5115 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/sorting.py
--rw-r--r--   0 runner    (1001) docker     (127)    20308 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tee.py
--rw-r--r--   0 runner    (1001) docker     (127)    16192 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tempfiles.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.324349 Pyomo-6.7.1/pyomo/common/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      565 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      795 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/config_plugin.py
--rw-r--r--   0 runner    (1001) docker     (127)      839 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/dep_mod.py
--rw-r--r--   0 runner    (1001) docker     (127)      582 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/dep_mod_except.py
--rw-r--r--   0 runner    (1001) docker     (127)     1471 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/deps.py
--rw-r--r--   0 runner    (1001) docker     (127)      568 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/import_ex.py
--rw-r--r--   0 runner    (1001) docker     (127)      663 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/relo_mod.py
--rw-r--r--   0 runner    (1001) docker     (127)      592 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/relo_mod_new.py
--rw-r--r--   0 runner    (1001) docker     (127)      969 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/relocated.py
--rw-r--r--   0 runner    (1001) docker     (127)     6472 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_bunch.py
--rw-r--r--   0 runner    (1001) docker     (127)     2810 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_component_map.py
--rw-r--r--   0 runner    (1001) docker     (127)   117909 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_config.py
--rw-r--r--   0 runner    (1001) docker     (127)    16628 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_dependencies.py
--rw-r--r--   0 runner    (1001) docker     (127)    23662 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_deprecated.py
--rw-r--r--   0 runner    (1001) docker     (127)     9834 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_download.py
--rw-r--r--   0 runner    (1001) docker     (127)     5461 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_env.py
--rw-r--r--   0 runner    (1001) docker     (127)     5294 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_errors.py
--rw-r--r--   0 runner    (1001) docker     (127)    19530 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_fileutils.py
--rw-r--r--   0 runner    (1001) docker     (127)     6653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_formatting.py
--rw-r--r--   0 runner    (1001) docker     (127)     2567 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_gc.py
--rw-r--r--   0 runner    (1001) docker     (127)    18755 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_log.py
--rw-r--r--   0 runner    (1001) docker     (127)     1937 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_modeling.py
--rw-r--r--   0 runner    (1001) docker     (127)     4420 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_multithread.py
--rw-r--r--   0 runner    (1001) docker     (127)     3006 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_orderedset.py
--rw-r--r--   0 runner    (1001) docker     (127)    10254 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_plugin.py
--rw-r--r--   0 runner    (1001) docker     (127)     3568 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_sorting.py
--rw-r--r--   0 runner    (1001) docker     (127)    12111 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_tee.py
--rw-r--r--   0 runner    (1001) docker     (127)    21463 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_tempfile.py
--rw-r--r--   0 runner    (1001) docker     (127)    26014 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_timing.py
--rw-r--r--   0 runner    (1001) docker     (127)     1002 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_typing.py
--rw-r--r--   0 runner    (1001) docker     (127)    18954 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/tests/test_unittest.py
--rw-r--r--   0 runner    (1001) docker     (127)    37810 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/timing.py
--rw-r--r--   0 runner    (1001) docker     (127)    33562 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/common/unittest.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.324349 Pyomo-6.7.1/pyomo/contrib/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.324349 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1133 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/build.py
--rw-r--r--   0 runner    (1001) docker     (127)      774 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.328348 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/
--rw-r--r--   0 runner    (1001) docker     (127)     1753 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     4292 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/FindASL.cmake
--rw-r--r--   0 runner    (1001) docker     (127)     6118 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/functions.c
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.328348 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3121 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/tests/test_ampl_function_demo.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.328348 Pyomo-6.7.1/pyomo/contrib/appsi/
--rw-r--r--   0 runner    (1001) docker     (127)      623 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    63910 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/base.py
--rw-r--r--   0 runner    (1001) docker     (127)     4271 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/build.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.328348 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/
--rw-r--r--   0 runner    (1001) docker     (127)     1379 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.328348 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/
--rw-r--r--   0 runner    (1001) docker     (127)     8387 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/cmodel_bindings.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      581 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/common.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      665 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/common.hpp
--rw-r--r--   0 runner    (1001) docker     (127)    67084 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/expression.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    32556 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/expression.hpp
--rw-r--r--   0 runner    (1001) docker     (127)     8598 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/fbbt_model.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2915 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/fbbt_model.hpp
--rw-r--r--   0 runner    (1001) docker     (127)    32839 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/interval.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5791 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/interval.hpp
--rw-r--r--   0 runner    (1001) docker     (127)    14297 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/lp_writer.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     2040 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/lp_writer.hpp
--rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/model_base.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     1586 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/model_base.hpp
--rw-r--r--   0 runner    (1001) docker     (127)    17749 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/nl_writer.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     3027 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/nl_writer.hpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1431 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/tests/test_import.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2343 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/examples/getting_started.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/examples/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/examples/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1214 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/examples/tests/test_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)    11550 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/fbbt.py
--rw-r--r--   0 runner    (1001) docker     (127)     1321 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/
--rw-r--r--   0 runner    (1001) docker     (127)      715 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17906 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/cbc.py
--rw-r--r--   0 runner    (1001) docker     (127)    17354 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/cplex.py
--rw-r--r--   0 runner    (1001) docker     (127)    60681 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/gurobi.py
--rw-r--r--   0 runner    (1001) docker     (127)    29911 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/highs.py
--rw-r--r--   0 runner    (1001) docker     (127)    19890 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/ipopt.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    25704 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_gurobi_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)     4030 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_highs_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)     2323 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_ipopt_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    55590 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_persistent_solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)     7317 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_wntr_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    18805 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/solvers/wntr.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.332348 Pyomo-6.7.1/pyomo/contrib/appsi/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_base.py
--rw-r--r--   0 runner    (1001) docker     (127)     5341 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_fbbt.py
--rw-r--r--   0 runner    (1001) docker     (127)     2864 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_interval.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/appsi/utils/
--rw-r--r--   0 runner    (1001) docker     (127)      653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1970 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/utils/collect_vars_and_named_exprs.py
--rw-r--r--   0 runner    (1001) docker     (127)      867 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/utils/get_objective.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/appsi/utils/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/utils/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2692 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/utils/tests/test_collect_vars_and_named_exprs.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/appsi/writers/
--rw-r--r--   0 runner    (1001) docker     (127)      605 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      638 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/config.py
--rw-r--r--   0 runner    (1001) docker     (127)     7237 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/lp_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)    10362 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/nl_writer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/appsi/writers/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10207 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/appsi/writers/tests/test_nl_writer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/benders/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13708 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/benders_cuts.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/benders/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6539 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/examples/farmer.py
--rw-r--r--   0 runner    (1001) docker     (127)     1882 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/examples/grothey_ex.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/benders/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    16832 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/benders/tests/test_benders.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/community_detection/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9978 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/community_graph.py
--rw-r--r--   0 runner    (1001) docker     (127)    41461 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/detection.py
--rw-r--r--   0 runner    (1001) docker     (127)     7953 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/event_log.py
--rw-r--r--   0 runner    (1001) docker     (127)      609 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.336348 Pyomo-6.7.1/pyomo/contrib/community_detection/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    63466 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/community_detection/tests/test_detection.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/cp/
--rw-r--r--   0 runner    (1001) docker     (127)     1009 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7687 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/interval_var.py
--rw-r--r--   0 runner    (1001) docker     (127)      680 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/cp/repn/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/repn/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    46915 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/repn/docplex_writer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2101 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/precedence_expressions.py
--rw-r--r--   0 runner    (1001) docker     (127)    12078 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/step_function_expressions.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/cp/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    51207 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_docplex_walker.py
--rw-r--r--   0 runner    (1001) docker     (127)    14651 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_docplex_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)     7712 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_interval_var.py
--rwxr-xr-x   0 runner    (1001) docker     (127)    30065 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_logical_to_disjunctive.py
--rw-r--r--   0 runner    (1001) docker     (127)     6880 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_precedence_constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)    19693 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/tests/test_step_function_expressions.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/cp/transform/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/transform/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6040 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/transform/logical_to_disjunctive_program.py
--rw-r--r--   0 runner    (1001) docker     (127)    10354 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/cp/transform/logical_to_disjunctive_walker.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.340348 Pyomo-6.7.1/pyomo/contrib/doe/
--rw-r--r--   0 runner    (1001) docker     (127)      824 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    45304 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/doe.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/doe/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4155 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_compute_FIM.py
--rw-r--r--   0 runner    (1001) docker     (127)     4891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_grid_search.py
--rw-r--r--   0 runner    (1001) docker     (127)     8618 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_kinetics.py
--rw-r--r--   0 runner    (1001) docker     (127)     5062 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_optimize_doe.py
--rw-r--r--   0 runner    (1001) docker     (127)    12721 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/measurements.py
--rw-r--r--   0 runner    (1001) docker     (127)    29614 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/result.py
--rw-r--r--   0 runner    (1001) docker     (127)     6574 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/scenario.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/doe/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2931 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/tests/test_example.py
--rw-r--r--   0 runner    (1001) docker     (127)    12406 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/tests/test_fim_doe.py
--rw-r--r--   0 runner    (1001) docker     (127)     8125 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/doe/tests/test_reactor_example.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/example/
--rw-r--r--   0 runner    (1001) docker     (127)      993 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      549 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/bar.py
--rw-r--r--   0 runner    (1001) docker     (127)      547 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/foo.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/example/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      700 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      994 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/plugins/ex_plugin.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/example/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      575 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      841 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/example/tests/test_example.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/fbbt/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10306 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/expression_bounds_walker.py
--rw-r--r--   0 runner    (1001) docker     (127)    55614 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/fbbt.py
--rw-r--r--   0 runner    (1001) docker     (127)    24721 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/interval.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.344348 Pyomo-6.7.1/pyomo/contrib/fbbt/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14518 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_expression_bounds_walker.py
--rw-r--r--   0 runner    (1001) docker     (127)    43511 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_fbbt.py
--rw-r--r--   0 runner    (1001) docker     (127)    17498 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_interval.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.348348 Pyomo-6.7.1/pyomo/contrib/fme/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fme/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    32588 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fme/fourier_motzkin_elimination.py
--rw-r--r--   0 runner    (1001) docker     (127)      611 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fme/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.348348 Pyomo-6.7.1/pyomo/contrib/fme/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fme/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    38415 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/fme/tests/test_fourier_motzkin_elimination.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.348348 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/
--rw-r--r--   0 runner    (1001) docker     (127)      581 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8438 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/compute_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)     2929 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/info.py
--rw-r--r--   0 runner    (1001) docker     (127)      605 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.348348 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4369 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdp_bounds/tests/test_gdp_bounds.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.352348 Pyomo-6.7.1/pyomo/contrib/gdpopt/
--rw-r--r--   0 runner    (1001) docker     (127)     5881 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/GDPopt.py
--rw-r--r--   0 runner    (1001) docker     (127)      602 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    20536 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/algorithm_base_class.py
--rw-r--r--   0 runner    (1001) docker     (127)    25984 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/branch_and_bound.py
--rw-r--r--   0 runner    (1001) docker     (127)    17323 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/config_options.py
--rw-r--r--   0 runner    (1001) docker     (127)    10492 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/create_oa_subproblems.py
--rw-r--r--   0 runner    (1001) docker     (127)     4094 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/cut_generation.py
--rw-r--r--   0 runner    (1001) docker     (127)    15075 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/discrete_problem_initialize.py
--rw-r--r--   0 runner    (1001) docker     (127)     7840 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/enumerate.py
--rw-r--r--   0 runner    (1001) docker     (127)     9417 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/gloa.py
--rw-r--r--   0 runner    (1001) docker     (127)    13252 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/loa.py
--rw-r--r--   0 runner    (1001) docker     (127)     2301 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/nlp_initialization.py
--rw-r--r--   0 runner    (1001) docker     (127)     3179 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/oa_algorithm_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)      793 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)     4378 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/ric.py
--rw-r--r--   0 runner    (1001) docker     (127)     9462 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/solve_discrete_problem.py
--rw-r--r--   0 runner    (1001) docker     (127)    15973 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/solve_subproblem.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.352348 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3128 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/common_tests.py
--rw-r--r--   0 runner    (1001) docker     (127)    11988 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_LBB.py
--rw-r--r--   0 runner    (1001) docker     (127)     7464 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_enumerate.py
--rw-r--r--   0 runner    (1001) docker     (127)    72681 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_gdpopt.py
--rw-r--r--   0 runner    (1001) docker     (127)    21219 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gdpopt/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.352348 Pyomo-6.7.1/pyomo/contrib/gjh/
--rw-r--r--   0 runner    (1001) docker     (127)     9789 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gjh/GJH.py
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gjh/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2077 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gjh/getGJH.py
--rw-r--r--   0 runner    (1001) docker     (127)      889 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/gjh/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.352348 Pyomo-6.7.1/pyomo/contrib/iis/
--rw-r--r--   0 runner    (1001) docker     (127)      585 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/iis/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4548 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/iis/iis.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.352348 Pyomo-6.7.1/pyomo/contrib/iis/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/iis/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4666 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/iis/tests/test_iis.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.356348 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/
--rw-r--r--   0 runner    (1001) docker     (127)      900 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.356348 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3731 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/dulmage_mendelsohn.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.356348 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5338 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/tests/test_dulmage_mendelsohn.py
--rw-r--r--   0 runner    (1001) docker     (127)     4856 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/config.py
--rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/connected.py
--rw-r--r--   0 runner    (1001) docker     (127)     7095 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/dulmage_mendelsohn.py
--rw-r--r--   0 runner    (1001) docker     (127)     7111 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/incidence.py
--rw-r--r--   0 runner    (1001) docker     (127)    40081 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     3374 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/matching.py
--rw-r--r--   0 runner    (1001) docker     (127)     5836 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/scc_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.356348 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4353 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/models_for_testing.py
--rw-r--r--   0 runner    (1001) docker     (127)     6900 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_connected.py
--rw-r--r--   0 runner    (1001) docker     (127)     8047 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_dulmage_mendelsohn.py
--rw-r--r--   0 runner    (1001) docker     (127)    10051 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_incidence.py
--rw-r--r--   0 runner    (1001) docker     (127)    75674 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     6970 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_matching.py
--rw-r--r--   0 runner    (1001) docker     (127)    20541 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_scc_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)    15890 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_triangularize.py
--rw-r--r--   0 runner    (1001) docker     (127)     8926 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/triangularize.py
--rw-r--r--   0 runner    (1001) docker     (127)      989 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/incidence_analysis/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.356348 Pyomo-6.7.1/pyomo/contrib/interior_point/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/interior_point/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1535 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/examples/ex1.py
--rw-r--r--   0 runner    (1001) docker     (127)    18758 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/interface.py
--rw-r--r--   0 runner    (1001) docker     (127)    27675 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/interior_point.py
--rw-r--r--   0 runner    (1001) docker     (127)     6207 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/inverse_reduced_hessian.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1150 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/base_linear_solver_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     2650 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/ma27_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     5307 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/mumps_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     2140 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/scipy_interface.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5711 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/test_linear_solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)     3327 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/test_realloc.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9378 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_interior_point.py
--rw-r--r--   0 runner    (1001) docker     (127)     5989 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_inverse_reduced_hessian.py
--rw-r--r--   0 runner    (1001) docker     (127)     4030 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_realloc.py
--rw-r--r--   0 runner    (1001) docker     (127)     5286 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_reg.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/latex_printer/
--rw-r--r--   0 runner    (1001) docker     (127)     1451 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/latex_printer/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    46398 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/latex_printer/latex_printer.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.360348 Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    25522 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/test_latex_printer.py
--rw-r--r--   0 runner    (1001) docker     (127)   119853 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/test_latex_printer_vartypes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.364348 Pyomo-6.7.1/pyomo/contrib/mcpp/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3908 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/build.py
--rw-r--r--   0 runner    (1001) docker     (127)     1380 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/getMCPP.py
--rw-r--r--   0 runner    (1001) docker     (127)     4661 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/mcppInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)      831 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)    17193 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/pyomo_mcpp.py
--rw-r--r--   0 runner    (1001) docker     (127)    12658 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mcpp/test_mcpp.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.364348 Pyomo-6.7.1/pyomo/contrib/mindtpy/
--rw-r--r--   0 runner    (1001) docker     (127)     4319 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/MindtPy.py
--rw-r--r--   0 runner    (1001) docker     (127)      565 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   139529 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/algorithm_base_class.py
--rw-r--r--   0 runner    (1001) docker     (127)    26620 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/config_options.py
--rw-r--r--   0 runner    (1001) docker     (127)    19320 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/cut_generation.py
--rw-r--r--   0 runner    (1001) docker     (127)     6962 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/extended_cutting_plane.py
--rw-r--r--   0 runner    (1001) docker     (127)     2709 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/feasibility_pump.py
--rw-r--r--   0 runner    (1001) docker     (127)     4618 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/global_outer_approximation.py
--rw-r--r--   0 runner    (1001) docker     (127)     8012 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/outer_approximation.py
--rw-r--r--   0 runner    (1001) docker     (127)      814 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)    42697 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/single_tree.py
--rw-r--r--   0 runner    (1001) docker     (127)     2020 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tabu_list.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.368348 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     3956 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP2_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2864 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP3_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2208 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP4_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP5_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     4515 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     6265 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP_simple_grey_box.py
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1725 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/constraint_qualification_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     9518 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/eight_process_problem.py
--rw-r--r--   0 runner    (1001) docker     (127)     1978 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/feasibility_pump1.py
--rw-r--r--   0 runner    (1001) docker     (127)     1859 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/feasibility_pump2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1749 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/from_proposal.py
--rw-r--r--   0 runner    (1001) docker     (127)     2439 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex1.py
--rw-r--r--   0 runner    (1001) docker     (127)     3478 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2779 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex3.py
--rw-r--r--   0 runner    (1001) docker     (127)     2464 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex4.py
--rw-r--r--   0 runner    (1001) docker     (127)     1675 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/online_doc_example.py
--rw-r--r--   0 runner    (1001) docker     (127)    20004 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy.py
--rw-r--r--   0 runner    (1001) docker     (127)     3845 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_ECP.py
--rw-r--r--   0 runner    (1001) docker     (127)     4699 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_feas_pump.py
--rw-r--r--   0 runner    (1001) docker     (127)     3786 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_global.py
--rw-r--r--   0 runner    (1001) docker     (127)     4970 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_global_lp_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)     2999 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_grey_box.py
--rw-r--r--   0 runner    (1001) docker     (127)    12046 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_lp_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    10591 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_regularization.py
--rw-r--r--   0 runner    (1001) docker     (127)     5378 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_solution_pool.py
--rw-r--r--   0 runner    (1001) docker     (127)     3375 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/unit_test.py
--rw-r--r--   0 runner    (1001) docker     (127)    37592 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mindtpy/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.368348 Pyomo-6.7.1/pyomo/contrib/mpc/
--rw-r--r--   0 runner    (1001) docker     (127)      778 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.368348 Pyomo-6.7.1/pyomo/contrib/mpc/data/
--rw-r--r--   0 runner    (1001) docker     (127)      954 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6583 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/convert.py
--rw-r--r--   0 runner    (1001) docker     (127)     4930 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/dynamic_data_base.py
--rw-r--r--   0 runner    (1001) docker     (127)     4800 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/find_nearest_index.py
--rw-r--r--   0 runner    (1001) docker     (127)     4540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/get_cuid.py
--rw-r--r--   0 runner    (1001) docker     (127)     8183 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/interval_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     1571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/scalar_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     8356 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/series_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8097 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_convert.py
--rw-r--r--   0 runner    (1001) docker     (127)     8629 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_find_nearest_index.py
--rw-r--r--   0 runner    (1001) docker     (127)     4436 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_get_cuid.py
--rw-r--r--   0 runner    (1001) docker     (127)    14395 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_interval_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     4444 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_scalar_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     8240 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_series_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5274 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/model.py
--rw-r--r--   0 runner    (1001) docker     (127)     5232 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/run_mpc.py
--rw-r--r--   0 runner    (1001) docker     (127)     2927 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/run_openloop.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3613 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/test_mpc.py
--rw-r--r--   0 runner    (1001) docker     (127)     3664 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/test_openloop.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/
--rw-r--r--   0 runner    (1001) docker     (127)      813 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2019 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/copy_values.py
--rw-r--r--   0 runner    (1001) docker     (127)     6137 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/load_data.py
--rw-r--r--   0 runner    (1001) docker     (127)    15717 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/model_interface.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    23841 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/test_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     5756 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/test_var_linker.py
--rw-r--r--   0 runner    (1001) docker     (127)     2424 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/var_linker.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.372348 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/
--rw-r--r--   0 runner    (1001) docker     (127)      768 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2615 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)    12821 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/cost_expressions.py
--rw-r--r--   0 runner    (1001) docker     (127)     6089 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/terminal.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    21740 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_cost_expressions.py
--rw-r--r--   0 runner    (1001) docker     (127)     4936 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_input_constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)     3764 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_terminal.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/multistart/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2505 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/high_conf_stop.py
--rw-r--r--   0 runner    (1001) docker     (127)     9898 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/multi.py
--rw-r--r--   0 runner    (1001) docker     (127)      596 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)     2891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/reinit.py
--rw-r--r--   0 runner    (1001) docker     (127)     5941 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/multistart/test_multi.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/parmest/
--rw-r--r--   0 runner    (1001) docker     (127)     1061 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/parmest/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reaction_kinetics/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reaction_kinetics/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4079 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reaction_kinetics/simple_reaction_parmest_example.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.376348 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1975 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/bootstrap_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     3139 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/datarec_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     3382 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/leaveNout_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     2167 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/likelihood_ratio_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     1910 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/multisensor_data_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     2056 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/parameter_estimation_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     3521 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/reactor_design.py
--rw-r--r--   0 runner    (1001) docker     (127)     2033 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/timeseries_data_example.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.380348 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1810 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/bootstrap_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     1993 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/likelihood_ratio_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     2096 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/parameter_estimation_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     1851 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler.py
--rw-r--r--   0 runner    (1001) docker     (127)     2029 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler_with_constraint.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.380348 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2126 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/parallel_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     1436 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/parameter_estimation_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     1898 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/scenario_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     8627 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/semibatch.py
--rw-r--r--   0 runner    (1001) docker     (127)    21311 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/graphics.py
--rw-r--r--   0 runner    (1001) docker     (127)      682 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/ipopt_solver_wrapper.py
--rw-r--r--   0 runner    (1001) docker     (127)    51671 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/parmest.py
--rw-r--r--   0 runner    (1001) docker     (127)     5567 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/scenariocreator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.380348 Pyomo-6.7.1/pyomo/contrib/parmest/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5803 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)     2024 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_graphics.py
--rw-r--r--   0 runner    (1001) docker     (127)    35608 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_parmest.py
--rw-r--r--   0 runner    (1001) docker     (127)     5818 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_scenariocreator.py
--rw-r--r--   0 runner    (1001) docker     (127)     2200 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)     2225 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_utils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.380348 Pyomo-6.7.1/pyomo/contrib/parmest/utils/
--rw-r--r--   0 runner    (1001) docker     (127)     1000 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13701 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/create_ef.py
--rw-r--r--   0 runner    (1001) docker     (127)     2753 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/ipopt_solver_wrapper.py
--rw-r--r--   0 runner    (1001) docker     (127)     7463 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/model_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     5780 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/mpi_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     4711 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/parmest/utils/scenario_tree.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.380348 Pyomo-6.7.1/pyomo/contrib/piecewise/
--rw-r--r--   0 runner    (1001) docker     (127)     1460 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1770 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/piecewise_linear_expression.py
--rw-r--r--   0 runner    (1001) docker     (127)    21055 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/piecewise_linear_function.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.384348 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3118 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/common_tests.py
--rw-r--r--   0 runner    (1001) docker     (127)     1980 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/models.py
--rw-r--r--   0 runner    (1001) docker     (127)     7437 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_inner_repn_gdp.py
--rw-r--r--   0 runner    (1001) docker     (127)     7551 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_outer_repn_gdp.py
--rw-r--r--   0 runner    (1001) docker     (127)    19998 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_piecewise_linear_function.py
--rw-r--r--   0 runner    (1001) docker     (127)    10633 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_reduced_inner_repn.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.384348 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1705 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/convex_combination.py
--rw-r--r--   0 runner    (1001) docker     (127)     1673 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/disaggregated_convex_combination.py
--rw-r--r--   0 runner    (1001) docker     (127)     5048 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/inner_representation_gdp.py
--rw-r--r--   0 runner    (1001) docker     (127)     1915 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/multiple_choice.py
--rw-r--r--   0 runner    (1001) docker     (127)     5748 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/outer_representation_gdp.py
--rw-r--r--   0 runner    (1001) docker     (127)    10128 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/piecewise_to_gdp_transformation.py
--rw-r--r--   0 runner    (1001) docker     (127)     2193 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/piecewise_to_mip_visitor.py
--rw-r--r--   0 runner    (1001) docker     (127)     6491 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/piecewise/transform/reduced_inner_representation_gdp.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.384348 Pyomo-6.7.1/pyomo/contrib/preprocessing/
--rw-r--r--   0 runner    (1001) docker     (127)      584 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.388348 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)     1330 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5886 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/bounds_to_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     3583 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/constraint_tightener.py
--rw-r--r--   0 runner    (1001) docker     (127)     5709 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/deactivate_trivial_constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)     3174 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/detect_fixed_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     9848 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/equality_propagate.py
--rw-r--r--   0 runner    (1001) docker     (127)    16501 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/induced_linearity.py
--rw-r--r--   0 runner    (1001) docker     (127)     3269 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/init_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     6138 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/int_to_binary.py
--rw-r--r--   0 runner    (1001) docker     (127)     3586 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/remove_zero_terms.py
--rw-r--r--   0 runner    (1001) docker     (127)     4041 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/strip_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)    12957 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/var_aggregator.py
--rw-r--r--   0 runner    (1001) docker     (127)     4215 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/zero_sum_propagator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.388348 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3898 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_bounds_to_vars_xfrm.py
--rw-r--r--   0 runner    (1001) docker     (127)     5033 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_constraint_tightener.py
--rw-r--r--   0 runner    (1001) docker     (127)     5080 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_deactivate_trivial_constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)     1747 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_detect_fixed_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     9049 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_equality_propagate.py
--rw-r--r--   0 runner    (1001) docker     (127)     7574 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_induced_linearity.py
--rw-r--r--   0 runner    (1001) docker     (127)     2893 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_init_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     2891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_int_to_binary.py
--rw-r--r--   0 runner    (1001) docker     (127)     5021 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_strip_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)     8232 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_var_aggregator.py
--rw-r--r--   0 runner    (1001) docker     (127)     4843 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_zero_sum_propagate.py
--rw-r--r--   0 runner    (1001) docker     (127)     2876 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_zero_term_removal.py
--rw-r--r--   0 runner    (1001) docker     (127)     1176 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/preprocessing/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.388348 Pyomo-6.7.1/pyomo/contrib/pynumero/
--rw-r--r--   0 runner    (1001) docker     (127)      616 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.388348 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.392348 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17406 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/cyipopt_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)    24657 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/implicit_functions.py
--rw-r--r--   0 runner    (1001) docker     (127)    16828 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/pyomo_ext_cyipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)    17076 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/scipy_solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)     4701 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/square_solver_base.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.392348 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9150 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_interfaces.py
--rw-r--r--   0 runner    (1001) docker     (127)    11462 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)    13213 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_implicit_functions.py
--rw-r--r--   0 runner    (1001) docker     (127)    14262 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_pyomo_ext_cyipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)    22682 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_scipy_solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)    17183 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/asl.py
--rw-r--r--   0 runner    (1001) docker     (127)     1079 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/build.py
--rw-r--r--   0 runner    (1001) docker     (127)     1140 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/dependencies.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.392348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.392348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1575 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_callback.py
--rw-r--r--   0 runner    (1001) docker     (127)     1194 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_callback_halt.py
--rw-r--r--   0 runner    (1001) docker     (127)     1941 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_functor_callback.py
--rw-r--r--   0 runner    (1001) docker     (127)     1619 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/reactor_design.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.392348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.396348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3533 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/generate_data.py
--rw-r--r--   0 runner    (1001) docker     (127)     9346 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/models.py
--rw-r--r--   0 runner    (1001) docker     (127)     4167 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/perform_estimation.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.396348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2111 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_outputs.py
--rw-r--r--   0 runner    (1001) docker     (127)     9959 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_ratio_residuals.py
--rw-r--r--   0 runner    (1001) docker     (127)     4372 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_outputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    17675 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_residuals.py
--rw-r--r--   0 runner    (1001) docker     (127)     4154 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/feasibility.py
--rw-r--r--   0 runner    (1001) docker     (127)     2811 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/mumps_example.py
--rw-r--r--   0 runner    (1001) docker     (127)     2087 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/nlp_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     3153 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/nlp_interface_2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1721 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/parallel_matvec.py
--rw-r--r--   0 runner    (1001) docker     (127)     1420 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/parallel_vector_ops.py
--rw-r--r--   0 runner    (1001) docker     (127)     4611 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/sensitivity.py
--rw-r--r--   0 runner    (1001) docker     (127)     6891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/sqp.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.396348 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11256 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_cyipopt_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)     2254 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)     1831 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_mpi_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)      831 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/exceptions.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.396348 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/
--rw-r--r--   0 runner    (1001) docker     (127)      828 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    33682 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/ampl_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    15656 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/cyipopt_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)    17577 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/external_grey_box.py
--rw-r--r--   0 runner    (1001) docker     (127)    18890 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/external_pyomo_model.py
--rw-r--r--   0 runner    (1001) docker     (127)    16577 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    15292 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/nlp_projections.py
--rw-r--r--   0 runner    (1001) docker     (127)    33401 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/pyomo_grey_box_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    59656 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/pyomo_nlp.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.400348 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2289 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/compare_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    21711 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/external_grey_box_models.py
--rw-r--r--   0 runner    (1001) docker     (127)     7889 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_cyipopt_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)    23094 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_dynamic_model.py
--rw-r--r--   0 runner    (1001) docker     (127)     2089 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_asl_function.py
--rw-r--r--   0 runner    (1001) docker     (127)    86169 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_grey_box_model.py
--rw-r--r--   0 runner    (1001) docker     (127)    43312 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_block.py
--rw-r--r--   0 runner    (1001) docker     (127)    43190 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_model.py
--rw-r--r--   0 runner    (1001) docker     (127)    35115 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    23319 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_nlp_projections.py
--rw-r--r--   0 runner    (1001) docker     (127)   102434 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_pyomo_grey_box_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)     3522 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     7217 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    18660 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/intrinsic.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.400348 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/
--rw-r--r--   0 runner    (1001) docker     (127)      601 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2840 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/base.py
--rw-r--r--   0 runner    (1001) docker     (127)     6208 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma27.py
--rw-r--r--   0 runner    (1001) docker     (127)     4929 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma27_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     8513 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma57.py
--rw-r--r--   0 runner    (1001) docker     (127)     5373 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma57_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     9707 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/mumps_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     4225 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/scipy_interface.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.400348 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4274 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_linear_solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)     6843 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_ma27.py
--rw-r--r--   0 runner    (1001) docker     (127)     6386 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_ma57.py
--rw-r--r--   0 runner    (1001) docker     (127)     2742 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_mumps_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     1364 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     1806 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.404348 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/
--rw-r--r--   0 runner    (1001) docker     (127)      792 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7123 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/base_block.py
--rw-r--r--   0 runner    (1001) docker     (127)    46318 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/block_matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)    59856 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/block_vector.py
--rw-r--r--   0 runner    (1001) docker     (127)    45374 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/mpi_block_matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)    56271 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/mpi_block_vector.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.404348 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    32251 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_block_matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)    36325 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_block_vector.py
--rw-r--r--   0 runner    (1001) docker     (127)     6251 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_intrinsics.py
--rw-r--r--   0 runner    (1001) docker     (127)    53461 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)    63243 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_vector.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.404348 Pyomo-6.7.1/pyomo/contrib/pynumero/src/
--rw-r--r--   0 runner    (1001) docker     (127)    18075 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/AmplInterface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)     5109 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/AmplInterface.hpp
--rw-r--r--   0 runner    (1001) docker     (127)     1486 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/AssertUtils.hpp
--rw-r--r--   0 runner    (1001) docker     (127)     4132 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)     8077 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/ma27Interface.cpp
--rw-r--r--   0 runner    (1001) docker     (127)    11942 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/ma57Interface.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.404348 Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      216 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/CMakeLists.txt
--rw-r--r--   0 runner    (1001) docker     (127)      712 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/simple_nlp.nl
--rw-r--r--   0 runner    (1001) docker     (127)      745 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/simple_test.cpp
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.404348 Pyomo-6.7.1/pyomo/contrib/pynumero/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pynumero/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.408348 Pyomo-6.7.1/pyomo/contrib/pyros/
--rw-r--r--   0 runner    (1001) docker     (127)      920 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    29327 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/config.py
--rw-r--r--   0 runner    (1001) docker     (127)    34663 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/master_problem_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)    18552 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/pyros.py
--rw-r--r--   0 runner    (1001) docker     (127)    37549 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/pyros_algorithm_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)    50665 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/separation_problem_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)    27267 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/solve_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.408348 Pyomo-6.7.1/pyomo/contrib/pyros/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    20054 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/tests/test_config.py
--rw-r--r--   0 runner    (1001) docker     (127)   250563 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/tests/test_grcs.py
--rw-r--r--   0 runner    (1001) docker     (127)    96732 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/uncertainty_sets.py
--rw-r--r--   0 runner    (1001) docker     (127)    69653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/pyros/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.408348 Pyomo-6.7.1/pyomo/contrib/satsolver/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/satsolver/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11680 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/satsolver/satsolver.py
--rw-r--r--   0 runner    (1001) docker     (127)     8923 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/satsolver/test_satsolver.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.408348 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/
--rw-r--r--   0 runner    (1001) docker     (127)     1115 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.408348 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/
--rwxr-xr-x   0 runner    (1001) docker     (127)     9690 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/HIV_Transmission.py
--rw-r--r--   0 runner    (1001) docker     (127)     1116 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3860 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/feedbackController.py
--rw-r--r--   0 runner    (1001) docker     (127)     4017 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/parameter.py
--rw-r--r--   0 runner    (1001) docker     (127)     3251 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/parameter_kaug.py
--rw-r--r--   0 runner    (1001) docker     (127)     1285 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/rangeInequality.py
--rw-r--r--   0 runner    (1001) docker     (127)     3088 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/rooney_biegler.py
--rw-r--r--   0 runner    (1001) docker     (127)     5335 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/k_aug.py
--rw-r--r--   0 runner    (1001) docker     (127)    28361 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/sens.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.412348 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/
--rw-r--r--   0 runner    (1001) docker     (127)     1122 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5439 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_k_aug_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)    35170 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_sens.py
--rw-r--r--   0 runner    (1001) docker     (127)    35304 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_sens_unit.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.412348 Pyomo-6.7.1/pyomo/contrib/simplemodel/
--rw-r--r--   0 runner    (1001) docker     (127)     1204 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/simplemodel/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.412348 Pyomo-6.7.1/pyomo/contrib/solver/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    19447 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/base.py
--rw-r--r--   0 runner    (1001) docker     (127)    14752 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/config.py
--rw-r--r--   0 runner    (1001) docker     (127)     1194 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    58283 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/gurobi.py
--rw-r--r--   0 runner    (1001) docker     (127)    20374 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/ipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)    20884 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)      893 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/plugins.py
--rw-r--r--   0 runner    (1001) docker     (127)    13770 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/results.py
--rw-r--r--   0 runner    (1001) docker     (127)     9242 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/sol_reader.py
--rw-r--r--   0 runner    (1001) docker     (127)     9110 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/solution.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.412348 Pyomo-6.7.1/pyomo/contrib/solver/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.412348 Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    24875 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_gurobi_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)     2052 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_ipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)    65934 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_solvers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.416348 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.416348 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/sol_files/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/sol_files/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10819 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_base.py
--rw-r--r--   0 runner    (1001) docker     (127)     5348 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_config.py
--rw-r--r--   0 runner    (1001) docker     (127)     9217 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_ipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)     9520 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_results.py
--rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_sol_reader.py
--rw-r--r--   0 runner    (1001) docker     (127)     3564 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_solution.py
--rw-r--r--   0 runner    (1001) docker     (127)     5955 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     4588 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/solver/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.416348 Pyomo-6.7.1/pyomo/contrib/trustregion/
--rw-r--r--   0 runner    (1001) docker     (127)    16856 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/TRF.py
--rw-r--r--   0 runner    (1001) docker     (127)      845 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.416348 Pyomo-6.7.1/pyomo/contrib/trustregion/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      845 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/examples/__init__.py
--rwxr-xr-x   0 runner    (1001) docker     (127)     2294 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/examples/example1.py
--rw-r--r--   0 runner    (1001) docker     (127)     2336 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/examples/example2.py
--rw-r--r--   0 runner    (1001) docker     (127)     2597 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/filter.py
--rw-r--r--   0 runner    (1001) docker     (127)    17456 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/interface.py
--rw-r--r--   0 runner    (1001) docker     (127)      997 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.416348 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      845 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8931 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_TRF.py
--rw-r--r--   0 runner    (1001) docker     (127)     4528 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)     1909 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_filter.py
--rw-r--r--   0 runner    (1001) docker     (127)    20891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_interface.py
--rw-r--r--   0 runner    (1001) docker     (127)     5736 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     4740 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/trustregion/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.420348 Pyomo-6.7.1/pyomo/contrib/viewer/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     7692 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/main.ui
--rw-r--r--   0 runner    (1001) docker     (127)    22058 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/model_browser.py
--rw-r--r--   0 runner    (1001) docker     (127)      518 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/model_browser.ui
--rw-r--r--   0 runner    (1001) docker     (127)     3075 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/model_select.py
--rw-r--r--   0 runner    (1001) docker     (127)     2335 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/model_select.ui
--rw-r--r--   0 runner    (1001) docker     (127)     5167 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/pyomo_viewer.py
--rw-r--r--   0 runner    (1001) docker     (127)     4423 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/qt.py
--rw-r--r--   0 runner    (1001) docker     (127)     5069 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/report.py
--rw-r--r--   0 runner    (1001) docker     (127)     5058 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/residual_table.py
--rw-r--r--   0 runner    (1001) docker     (127)     1323 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/residual_table.ui
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.420348 Pyomo-6.7.1/pyomo/contrib/viewer/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10467 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_data_model_item.py
--rw-r--r--   0 runner    (1001) docker     (127)    10064 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_data_model_tree.py
--rw-r--r--   0 runner    (1001) docker     (127)     8234 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_qt.py
--rw-r--r--   0 runner    (1001) docker     (127)     7270 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_report.py
--rw-r--r--   0 runner    (1001) docker     (127)    10970 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/ui.py
--rw-r--r--   0 runner    (1001) docker     (127)     5024 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/contrib/viewer/ui_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.420348 Pyomo-6.7.1/pyomo/core/
--rw-r--r--   0 runner    (1001) docker     (127)     5425 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.428348 Pyomo-6.7.1/pyomo/core/base/
--rw-r--r--   0 runner    (1001) docker     (127)    34707 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/PyomoModel.py
--rw-r--r--   0 runner    (1001) docker     (127)     4481 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2677 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/action.py
--rw-r--r--   0 runner    (1001) docker     (127)    91900 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/block.py
--rw-r--r--   0 runner    (1001) docker     (127)      959 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/blockutil.py
--rw-r--r--   0 runner    (1001) docker     (127)    22886 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/boolean_var.py
--rw-r--r--   0 runner    (1001) docker     (127)     2818 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/check.py
--rw-r--r--   0 runner    (1001) docker     (127)    40951 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/component.py
--rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/component_namer.py
--rw-r--r--   0 runner    (1001) docker     (127)     1250 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/component_order.py
--rw-r--r--   0 runner    (1001) docker     (127)    26026 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/componentuid.py
--rw-r--r--   0 runner    (1001) docker     (127)     4692 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/config.py
--rw-r--r--   0 runner    (1001) docker     (127)     9322 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/connector.py
--rw-r--r--   0 runner    (1001) docker     (127)    39081 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     5714 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/disable_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)     3058 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/enums.py
--rw-r--r--   0 runner    (1001) docker     (127)    17367 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/expression.py
--rw-r--r--   0 runner    (1001) docker     (127)    29702 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/external.py
--rw-r--r--   0 runner    (1001) docker     (127)     5036 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/global_set.py
--rw-r--r--   0 runner    (1001) docker     (127)    48038 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/indexed_component.py
--rw-r--r--   0 runner    (1001) docker     (127)    41781 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/indexed_component_slice.py
--rw-r--r--   0 runner    (1001) docker     (127)    20432 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/initializer.py
--rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/instance2dat.py
--rw-r--r--   0 runner    (1001) docker     (127)     7061 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/label.py
--rw-r--r--   0 runner    (1001) docker     (127)    20121 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/logical_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)    11983 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/matrix_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     3555 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/misc.py
--rw-r--r--   0 runner    (1001) docker     (127)      623 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/numvalue.py
--rw-r--r--   0 runner    (1001) docker     (127)    20298 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/objective.py
--rw-r--r--   0 runner    (1001) docker     (127)    37418 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/param.py
--rw-r--r--   0 runner    (1001) docker     (127)    58113 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/piecewise.py
--rw-r--r--   0 runner    (1001) docker     (127)     1965 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/plugin.py
--rw-r--r--   0 runner    (1001) docker     (127)    35898 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/range.py
--rw-r--r--   0 runner    (1001) docker     (127)      798 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/rangeset.py
--rw-r--r--   0 runner    (1001) docker     (127)    32922 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/reference.py
--rw-r--r--   0 runner    (1001) docker     (127)   156694 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/set.py
--rw-r--r--   0 runner    (1001) docker     (127)      921 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/set_types.py
--rw-r--r--   0 runner    (1001) docker     (127)      996 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/sets.py
--rw-r--r--   0 runner    (1001) docker     (127)    20893 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/sos.py
--rw-r--r--   0 runner    (1001) docker     (127)    15510 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/suffix.py
--rw-r--r--   0 runner    (1001) docker     (127)     2402 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/symbol_map.py
--rw-r--r--   0 runner    (1001) docker     (127)     1635 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/symbolic.py
--rw-r--r--   0 runner    (1001) docker     (127)      899 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/template_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)     6458 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/transformation.py
--rw-r--r--   0 runner    (1001) docker     (127)    58965 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/units_container.py
--rw-r--r--   0 runner    (1001) docker     (127)     1636 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/util.py
--rw-r--r--   0 runner    (1001) docker     (127)    38189 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/base/var.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.428348 Pyomo-6.7.1/pyomo/core/beta/
--rw-r--r--   0 runner    (1001) docker     (127)      613 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/beta/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8763 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/beta/dict_objects.py
--rw-r--r--   0 runner    (1001) docker     (127)     9958 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/beta/list_objects.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.432348 Pyomo-6.7.1/pyomo/core/expr/
--rw-r--r--   0 runner    (1001) docker     (127)     4915 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15337 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/base.py
--rw-r--r--   0 runner    (1001) docker     (127)     9271 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/boolean_value.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.432348 Pyomo-6.7.1/pyomo/core/expr/calculus/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/calculus/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4930 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/calculus/derivatives.py
--rw-r--r--   0 runner    (1001) docker     (127)    13315 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/calculus/diff_with_pyomo.py
--rw-r--r--   0 runner    (1001) docker     (127)     3832 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/calculus/diff_with_sympy.py
--rw-r--r--   0 runner    (1001) docker     (127)     5700 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/cnf_walker.py
--rw-r--r--   0 runner    (1001) docker     (127)    10343 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/compare.py
--rw-r--r--   0 runner    (1001) docker     (127)     4039 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/current.py
--rw-r--r--   0 runner    (1001) docker     (127)     3423 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/expr_common.py
--rw-r--r--   0 runner    (1001) docker     (127)      764 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/expr_errors.py
--rw-r--r--   0 runner    (1001) docker     (127)    16376 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/logical_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)     1695 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/ndarray.py
--rw-r--r--   0 runner    (1001) docker     (127)   109855 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/numeric_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)    12408 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/numvalue.py
--rw-r--r--   0 runner    (1001) docker     (127)    13852 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/relational_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)     7154 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/symbol_map.py
--rw-r--r--   0 runner    (1001) docker     (127)     8542 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/sympy_tools.py
--rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/taylor_series.py
--rw-r--r--   0 runner    (1001) docker     (127)    38277 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/template_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)    59007 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/expr/visitor.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.436348 Pyomo-6.7.1/pyomo/core/kernel/
--rw-r--r--   0 runner    (1001) docker     (127)     2257 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10382 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/base.py
--rw-r--r--   0 runner    (1001) docker     (127)    20395 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/block.py
--rw-r--r--   0 runner    (1001) docker     (127)      817 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/component_map.py
--rw-r--r--   0 runner    (1001) docker     (127)      817 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/component_set.py
--rw-r--r--   0 runner    (1001) docker     (127)    29748 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/conic.py
--rw-r--r--   0 runner    (1001) docker     (127)    29572 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     3044 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/container_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)     5503 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/dict_container.py
--rw-r--r--   0 runner    (1001) docker     (127)     7899 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/expression.py
--rw-r--r--   0 runner    (1001) docker     (127)    10175 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/heterogeneous_container.py
--rw-r--r--   0 runner    (1001) docker     (127)     2717 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/homogeneous_container.py
--rw-r--r--   0 runner    (1001) docker     (127)     4089 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/list_container.py
--rw-r--r--   0 runner    (1001) docker     (127)    15915 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/matrix_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     2749 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/objective.py
--rw-r--r--   0 runner    (1001) docker     (127)     4229 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/parameter.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.440348 Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/
--rw-r--r--   0 runner    (1001) docker     (127)      700 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    45131 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/transforms.py
--rw-r--r--   0 runner    (1001) docker     (127)    14298 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/transforms_nd.py
--rw-r--r--   0 runner    (1001) docker     (127)     5446 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2480 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/register_numpy_types.py
--rw-r--r--   0 runner    (1001) docker     (127)     1656 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/set_types.py
--rw-r--r--   0 runner    (1001) docker     (127)     3458 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/sos.py
--rw-r--r--   0 runner    (1001) docker     (127)    11500 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/suffix.py
--rw-r--r--   0 runner    (1001) docker     (127)     5288 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/tuple_container.py
--rw-r--r--   0 runner    (1001) docker     (127)    14446 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/kernel/variable.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.440348 Pyomo-6.7.1/pyomo/core/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      594 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.440348 Pyomo-6.7.1/pyomo/core/plugins/transform/
--rw-r--r--   0 runner    (1001) docker     (127)     1176 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6612 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/add_slack_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     4925 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/discrete_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     3410 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/eliminate_fixed_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     4493 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/equality_transform.py
--rw-r--r--   0 runner    (1001) docker     (127)    11988 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/expand_connectors.py
--rw-r--r--   0 runner    (1001) docker     (127)     2482 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/hierarchy.py
--rw-r--r--   0 runner    (1001) docker     (127)    17159 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/logical_to_linear.py
--rw-r--r--   0 runner    (1001) docker     (127)    14795 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/model.py
--rw-r--r--   0 runner    (1001) docker     (127)    16472 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/nonnegative_transform.py
--rw-r--r--   0 runner    (1001) docker     (127)    11620 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/radix_linearization.py
--rw-r--r--   0 runner    (1001) docker     (127)     1173 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/relax_integrality.py
--rw-r--r--   0 runner    (1001) docker     (127)    14480 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/scaling.py
--rw-r--r--   0 runner    (1001) docker     (127)     2815 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/standard_form.py
--rw-r--r--   0 runner    (1001) docker     (127)     7734 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/plugins/transform/util.py
--rw-r--r--   0 runner    (1001) docker     (127)     2053 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/pyomoobject.py
--rw-r--r--   0 runner    (1001) docker     (127)     2896 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/staleflag.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.444348 Pyomo-6.7.1/pyomo/core/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      558 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.444348 Pyomo-6.7.1/pyomo/core/tests/data/
--rw-r--r--   0 runner    (1001) docker     (127)      564 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/data/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5631 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/data/test_odbc_ini.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.444348 Pyomo-6.7.1/pyomo/core/tests/diet/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/diet/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5905 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/diet/test_diet.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.444348 Pyomo-6.7.1/pyomo/core/tests/examples/
--rw-r--r--   0 runner    (1001) docker     (127)      567 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1864 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/pmedian.py
--rw-r--r--   0 runner    (1001) docker     (127)      586 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/pmedian1.py
--rw-r--r--   0 runner    (1001) docker     (127)     1351 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/pmedian2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1680 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/pmedian4.py
--rw-r--r--   0 runner    (1001) docker     (127)     1364 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/test_amplbook2.py
--rw-r--r--   0 runner    (1001) docker     (127)     3313 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/test_kernel_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)    12765 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/test_pyomo.py
--rw-r--r--   0 runner    (1001) docker     (127)     3053 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/examples/test_tutorials.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.444348 Pyomo-6.7.1/pyomo/core/tests/transform/
--rw-r--r--   0 runner    (1001) docker     (127)      573 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/transform/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    24252 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/transform/test_add_slacks.py
--rw-r--r--   0 runner    (1001) docker     (127)    25758 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/transform/test_scaling.py
--rw-r--r--   0 runner    (1001) docker     (127)    29458 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/transform/test_transform.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.460348 Pyomo-6.7.1/pyomo/core/tests/unit/
--rw-r--r--   0 runner    (1001) docker     (127)      563 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.464348 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    89754 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_block.py
--rw-r--r--   0 runner    (1001) docker     (127)     8702 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_component_map.py
--rw-r--r--   0 runner    (1001) docker     (127)     9501 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_component_set.py
--rw-r--r--   0 runner    (1001) docker     (127)    30196 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_conic.py
--rw-r--r--   0 runner    (1001) docker     (127)    67770 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)    37001 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_dict_container.py
--rw-r--r--   0 runner    (1001) docker     (127)    24597 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_expression.py
--rw-r--r--   0 runner    (1001) docker     (127)     8813 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_kernel.py
--rw-r--r--   0 runner    (1001) docker     (127)    40008 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_list_container.py
--rw-r--r--   0 runner    (1001) docker     (127)    44784 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_matrix_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     4819 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_objective.py
--rw-r--r--   0 runner    (1001) docker     (127)    10434 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_parameter.py
--rw-r--r--   0 runner    (1001) docker     (127)    39687 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_piecewise.py
--rw-r--r--   0 runner    (1001) docker     (127)     6547 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_sos.py
--rw-r--r--   0 runner    (1001) docker     (127)    19448 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_suffix.py
--rw-r--r--   0 runner    (1001) docker     (127)    31639 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_tuple_container.py
--rw-r--r--   0 runner    (1001) docker     (127)    37427 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_variable.py
--rw-r--r--   0 runner    (1001) docker     (127)     4668 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_action.py
--rw-r--r--   0 runner    (1001) docker     (127)   119867 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_block.py
--rw-r--r--   0 runner    (1001) docker     (127)     4697 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_block_model.py
--rw-r--r--   0 runner    (1001) docker     (127)     3153 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)     5103 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_check.py
--rw-r--r--   0 runner    (1001) docker     (127)     6953 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_compare.py
--rw-r--r--   0 runner    (1001) docker     (127)     4592 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_component.py
--rw-r--r--   0 runner    (1001) docker     (127)    46512 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_componentuid.py
--rw-r--r--   0 runner    (1001) docker     (127)    56931 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_con.py
--rw-r--r--   0 runner    (1001) docker     (127)     2513 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_concrete.py
--rw-r--r--   0 runner    (1001) docker     (127)    30317 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_connector.py
--rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_deprecation.py
--rw-r--r--   0 runner    (1001) docker     (127)    15985 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_derivs.py
--rw-r--r--   0 runner    (1001) docker     (127)    14215 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_dict_objects.py
--rw-r--r--   0 runner    (1001) docker     (127)     6984 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_disable_methods.py
--rw-r--r--   0 runner    (1001) docker     (127)     2764 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_enums.py
--rw-r--r--   0 runner    (1001) docker     (127)     9087 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_expr_misc.py
--rw-r--r--   0 runner    (1001) docker     (127)    35890 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_expression.py
--rw-r--r--   0 runner    (1001) docker     (127)    23167 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_external.py
--rw-r--r--   0 runner    (1001) docker     (127)    16859 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_indexed.py
--rw-r--r--   0 runner    (1001) docker     (127)    29152 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_indexed_slice.py
--rw-r--r--   0 runner    (1001) docker     (127)    27447 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_initializer.py
--rw-r--r--   0 runner    (1001) docker     (127)     2778 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_kernel_register_numpy_types.py
--rw-r--r--   0 runner    (1001) docker     (127)    10356 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_labelers.py
--rw-r--r--   0 runner    (1001) docker     (127)    14927 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_list_objects.py
--rw-r--r--   0 runner    (1001) docker     (127)     3605 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)    17356 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_expr_expanded.py
--rw-r--r--   0 runner    (1001) docker     (127)    33829 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_to_linear.py
--rw-r--r--   0 runner    (1001) docker     (127)     3768 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_matrix_constraint.py
--rw-r--r--   0 runner    (1001) docker     (127)     6945 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_misc.py
--rw-r--r--   0 runner    (1001) docker     (127)    36091 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_model.py
--rw-r--r--   0 runner    (1001) docker     (127)     3834 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_mutable.py
--rw-r--r--   0 runner    (1001) docker     (127)   195807 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)    41510 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_api.py
--rw-r--r--   0 runner    (1001) docker     (127)   276859 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_dispatcher.py
--rw-r--r--   0 runner    (1001) docker     (127)   250784 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_zerofilter.py
--rw-r--r--   0 runner    (1001) docker     (127)     9244 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numpy_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)    17373 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_numvalue.py
--rw-r--r--   0 runner    (1001) docker     (127)    24638 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_obj.py
--rw-r--r--   0 runner    (1001) docker     (127)    76486 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_param.py
--rw-r--r--   0 runner    (1001) docker     (127)    13318 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_pickle.py
--rw-r--r--   0 runner    (1001) docker     (127)    16810 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_piecewise.py
--rw-r--r--   0 runner    (1001) docker     (127)     1837 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_preprocess.py
--rw-r--r--   0 runner    (1001) docker     (127)    34645 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_range.py
--rw-r--r--   0 runner    (1001) docker     (127)    46110 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_reference.py
--rw-r--r--   0 runner    (1001) docker     (127)    15319 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_relational_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)   224189 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_set.py
--rw-r--r--   0 runner    (1001) docker     (127)   129664 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_sets.py
--rw-r--r--   0 runner    (1001) docker     (127)     5591 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_smap.py
--rw-r--r--   0 runner    (1001) docker     (127)     7818 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_sos.py
--rw-r--r--   0 runner    (1001) docker     (127)    34102 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_sos_v2.py
--rw-r--r--   0 runner    (1001) docker     (127)    76333 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_suffix.py
--rw-r--r--   0 runner    (1001) docker     (127)     4682 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_symbol_map.py
--rw-r--r--   0 runner    (1001) docker     (127)    12593 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_symbolic.py
--rw-r--r--   0 runner    (1001) docker     (127)     2653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_taylor_series.py
--rw-r--r--   0 runner    (1001) docker     (127)    27847 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_template_expr.py
--rw-r--r--   0 runner    (1001) docker     (127)    46156 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_units.py
--rw-r--r--   0 runner    (1001) docker     (127)    64606 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_var.py
--rw-r--r--   0 runner    (1001) docker     (127)    10497 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_var_set_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)    60253 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_visitor.py
--rw-r--r--   0 runner    (1001) docker     (127)     2736 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/test_xfrm_discrete_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)      895 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/uninstantiated_model_linear.py
--rw-r--r--   0 runner    (1001) docker     (127)      790 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/tests/unit/uninstantiated_model_quadratic.py
--rw-r--r--   0 runner    (1001) docker     (127)     7827 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/core/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.468348 Pyomo-6.7.1/pyomo/dae/
--rw-r--r--   0 runner    (1001) docker     (127)      768 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11268 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/contset.py
--rw-r--r--   0 runner    (1001) docker     (127)     9124 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/diffvar.py
--rw-r--r--   0 runner    (1001) docker     (127)    25263 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/flatten.py
--rw-r--r--   0 runner    (1001) docker     (127)     6029 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/initialization.py
--rw-r--r--   0 runner    (1001) docker     (127)     6917 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/integral.py
--rw-r--r--   0 runner    (1001) docker     (127)    18735 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/misc.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.468348 Pyomo-6.7.1/pyomo/dae/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      636 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    27260 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/plugins/colloc.py
--rw-r--r--   0 runner    (1001) docker     (127)    13270 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/plugins/finitedifference.py
--rw-r--r--   0 runner    (1001) docker     (127)    11415 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/set_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    40990 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/simulator.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.468348 Pyomo-6.7.1/pyomo/dae/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      565 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    25266 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_colloc.py
--rw-r--r--   0 runner    (1001) docker     (127)    13287 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_contset.py
--rw-r--r--   0 runner    (1001) docker     (127)     6579 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_diffvar.py
--rw-r--r--   0 runner    (1001) docker     (127)    13717 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_finite_diff.py
--rw-r--r--   0 runner    (1001) docker     (127)    79021 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_flatten.py
--rw-r--r--   0 runner    (1001) docker     (127)     4013 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_initialization.py
--rw-r--r--   0 runner    (1001) docker     (127)     8649 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_integral.py
--rw-r--r--   0 runner    (1001) docker     (127)    35439 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_misc.py
--rw-r--r--   0 runner    (1001) docker     (127)    15323 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_set_utils.py
--rw-r--r--   0 runner    (1001) docker     (127)    49507 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/tests/test_simulator.py
--rw-r--r--   0 runner    (1001) docker     (127)    71365 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dae/utilities.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.472348 Pyomo-6.7.1/pyomo/dataportal/
--rw-r--r--   0 runner    (1001) docker     (127)    14917 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/DataPortal.py
--rw-r--r--   0 runner    (1001) docker     (127)     9273 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/TableData.py
--rw-r--r--   0 runner    (1001) docker     (127)      756 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1603 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/factory.py
--rw-r--r--   0 runner    (1001) docker     (127)    15930 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/parse_datacmds.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.472348 Pyomo-6.7.1/pyomo/dataportal/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      869 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2763 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/csv_table.py
--rw-r--r--   0 runner    (1001) docker     (127)     2026 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/datacommands.py
--rw-r--r--   0 runner    (1001) docker     (127)    23084 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/db_table.py
--rw-r--r--   0 runner    (1001) docker     (127)     8531 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/json_dict.py
--rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/sheet.py
--rw-r--r--   0 runner    (1001) docker     (127)     3264 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/text.py
--rw-r--r--   0 runner    (1001) docker     (127)     4148 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/plugins/xml_table.py
--rw-r--r--   0 runner    (1001) docker     (127)    33443 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/process_data.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.472348 Pyomo-6.7.1/pyomo/dataportal/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      563 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1302 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/tests/test_dat_parser.py
--rw-r--r--   0 runner    (1001) docker     (127)    80503 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/dataportal/tests/test_dataportal.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.472348 Pyomo-6.7.1/pyomo/duality/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9830 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/collect.py
--rw-r--r--   0 runner    (1001) docker     (127)     8181 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/lagrangian_dual.py
--rw-r--r--   0 runner    (1001) docker     (127)     5597 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/plugins.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.472348 Pyomo-6.7.1/pyomo/duality/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      558 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5839 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/duality/tests/test_linear_dual.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.476348 Pyomo-6.7.1/pyomo/environ/
--rw-r--r--   0 runner    (1001) docker     (127)     6074 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/environ/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.476348 Pyomo-6.7.1/pyomo/environ/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/environ/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     5089 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/environ/tests/standalone_minimal_pyomo_driver.py
--rw-r--r--   0 runner    (1001) docker     (127)     6109 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/environ/tests/test_environ.py
--rw-r--r--   0 runner    (1001) docker     (127)     6010 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/environ/tests/test_package_layout.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.476348 Pyomo-6.7.1/pyomo/gdp/
--rw-r--r--   0 runner    (1001) docker     (127)      799 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     6134 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/basic_step.py
--rw-r--r--   0 runner    (1001) docker     (127)    29687 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/disjunct.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.480348 Pyomo-6.7.1/pyomo/gdp/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)     1092 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1928 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/between_steps.py
--rw-r--r--   0 runner    (1001) docker     (127)    21447 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/bigm.py
--rw-r--r--   0 runner    (1001) docker     (127)    10505 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/bigm_mixin.py
--rw-r--r--   0 runner    (1001) docker     (127)     7418 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/bilinear.py
--rw-r--r--   0 runner    (1001) docker     (127)     7208 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/binary_multiplication.py
--rw-r--r--   0 runner    (1001) docker     (127)    16563 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/bound_pretransformation.py
--rw-r--r--   0 runner    (1001) docker     (127)      843 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/chull.py
--rw-r--r--   0 runner    (1001) docker     (127)    51943 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/cuttingplane.py
--rw-r--r--   0 runner    (1001) docker     (127)     6412 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/fix_disjuncts.py
--rw-r--r--   0 runner    (1001) docker     (127)    13543 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/gdp_to_mip_transformation.py
--rw-r--r--   0 runner    (1001) docker     (127)     7720 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/gdp_var_mover.py
--rw-r--r--   0 runner    (1001) docker     (127)    44639 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/hull.py
--rw-r--r--   0 runner    (1001) docker     (127)    33329 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/multiple_bigm.py
--rw-r--r--   0 runner    (1001) docker     (127)    38486 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/partition_disjuncts.py
--rw-r--r--   0 runner    (1001) docker     (127)    12538 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/plugins/transform_current_disjunctive_state.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.484348 Pyomo-6.7.1/pyomo/gdp/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      565 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    73927 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/common_tests.py
--rw-r--r--   0 runner    (1001) docker     (127)    38160 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/models.py
--rw-r--r--   0 runner    (1001) docker     (127)     6209 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_basic_step.py
--rw-r--r--   0 runner    (1001) docker     (127)   113893 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_bigm.py
--rw-r--r--   0 runner    (1001) docker     (127)    12338 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_binary_multiplication.py
--rw-r--r--   0 runner    (1001) docker     (127)    38543 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_bound_pretransformation.py
--rw-r--r--   0 runner    (1001) docker     (127)    49436 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_cuttingplane.py
--rw-r--r--   0 runner    (1001) docker     (127)    26533 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_disjunct.py
--rw-r--r--   0 runner    (1001) docker     (127)     6774 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_fix_disjuncts.py
--rw-r--r--   0 runner    (1001) docker     (127)     9033 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_gdp.py
--rw-r--r--   0 runner    (1001) docker     (127)     2075 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_gdp_reclassification_error.py
--rw-r--r--   0 runner    (1001) docker     (127)   119904 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_hull.py
--rw-r--r--   0 runner    (1001) docker     (127)    43576 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_mbigm.py
--rw-r--r--   0 runner    (1001) docker     (127)    88883 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_partition_disjuncts.py
--rw-r--r--   0 runner    (1001) docker     (127)     4198 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_reclassify.py
--rw-r--r--   0 runner    (1001) docker     (127)    13242 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_transform_current_disjunctive_state.py
--rw-r--r--   0 runner    (1001) docker     (127)     9378 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/tests/test_util.py
--rw-r--r--   0 runner    (1001) docker     (127)     1284 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/transformed_disjunct.py
--rw-r--r--   0 runner    (1001) docker     (127)    24395 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/gdp/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.484348 Pyomo-6.7.1/pyomo/kernel/
--rw-r--r--   0 runner    (1001) docker     (127)     7481 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/kernel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9105 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/kernel/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.484348 Pyomo-6.7.1/pyomo/mpec/
--rw-r--r--   0 runner    (1001) docker     (127)      630 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13778 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/complementarity.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.488348 Pyomo-6.7.1/pyomo/mpec/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      813 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4006 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/mpec1.py
--rw-r--r--   0 runner    (1001) docker     (127)     4815 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/mpec2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1800 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/mpec3.py
--rw-r--r--   0 runner    (1001) docker     (127)     7403 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/mpec4.py
--rw-r--r--   0 runner    (1001) docker     (127)     1810 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/pathampl.py
--rw-r--r--   0 runner    (1001) docker     (127)     5105 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/solver1.py
--rw-r--r--   0 runner    (1001) docker     (127)     3786 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/plugins/solver2.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.488348 Pyomo-6.7.1/pyomo/mpec/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      565 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    17226 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/tests/test_complementarity.py
--rw-r--r--   0 runner    (1001) docker     (127)     4730 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/tests/test_minlp.py
--rw-r--r--   0 runner    (1001) docker     (127)     4402 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/tests/test_nlp.py
--rw-r--r--   0 runner    (1001) docker     (127)     4398 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/mpec/tests/test_path.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.488348 Pyomo-6.7.1/pyomo/neos/
--rw-r--r--   0 runner    (1001) docker     (127)     1537 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15676 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/kestrel.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.488348 Pyomo-6.7.1/pyomo/neos/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)     2487 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/plugins/NEOS.py
--rw-r--r--   0 runner    (1001) docker     (127)      634 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11019 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/plugins/kestrel_plugin.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.488348 Pyomo-6.7.1/pyomo/neos/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      582 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      891 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/tests/model_min_lp.py
--rw-r--r--   0 runner    (1001) docker     (127)     8807 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/neos/tests/test_neos.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/network/
--rw-r--r--   0 runner    (1001) docker     (127)      675 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    15205 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/arc.py
--rw-r--r--   0 runner    (1001) docker     (127)    39211 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/decomposition.py
--rw-r--r--   0 runner    (1001) docker     (127)    34795 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/foqus_graph.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/network/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      599 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     9744 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/plugins/expand_arcs.py
--rw-r--r--   0 runner    (1001) docker     (127)    29429 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/port.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/network/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      567 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    86485 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/tests/test_arc.py
--rw-r--r--   0 runner    (1001) docker     (127)    29150 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/tests/test_decomposition.py
--rw-r--r--   0 runner    (1001) docker     (127)    17236 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/tests/test_port.py
--rw-r--r--   0 runner    (1001) docker     (127)     2495 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/network/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/opt/
--rw-r--r--   0 runner    (1001) docker     (127)     1581 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/opt/base/
--rw-r--r--   0 runner    (1001) docker     (127)     1034 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3595 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/convert.py
--rw-r--r--   0 runner    (1001) docker     (127)      766 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/error.py
--rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/formats.py
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/opt_config.py
--rw-r--r--   0 runner    (1001) docker     (127)     1368 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/problem.py
--rw-r--r--   0 runner    (1001) docker     (127)     1212 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/results.py
--rw-r--r--   0 runner    (1001) docker     (127)    28130 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/base/solvers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/opt/parallel/
--rw-r--r--   0 runner    (1001) docker     (127)      756 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/parallel/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2139 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/parallel/async_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)     2832 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/parallel/local.py
--rw-r--r--   0 runner    (1001) docker     (127)     7550 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/parallel/manager.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.492348 Pyomo-6.7.1/pyomo/opt/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      656 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2709 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/plugins/driver.py
--rw-r--r--   0 runner    (1001) docker     (127)     1854 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/plugins/res.py
--rw-r--r--   0 runner    (1001) docker     (127)    12027 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/plugins/sol.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/problem/
--rw-r--r--   0 runner    (1001) docker     (127)      653 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/problem/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2209 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/problem/ampl.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/results/
--rw-r--r--   0 runner    (1001) docker     (127)     1088 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14767 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/container.py
--rw-r--r--   0 runner    (1001) docker     (127)     1767 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/problem.py
--rw-r--r--   0 runner    (1001) docker     (127)     8052 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/results_.py
--rw-r--r--   0 runner    (1001) docker     (127)     8424 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/solution.py
--rw-r--r--   0 runner    (1001) docker     (127)     8521 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/results/solver.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/solver/
--rw-r--r--   0 runner    (1001) docker     (127)      740 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/solver/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3330 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/solver/ilmcmd.py
--rw-r--r--   0 runner    (1001) docker     (127)    15737 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/solver/shellcmd.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/testing/
--rw-r--r--   0 runner    (1001) docker     (127)      614 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/testing/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3764 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/testing/pyunit.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      562 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/tests/base/
--rw-r--r--   0 runner    (1001) docker     (127)      567 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    11857 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_ampl.py
--rw-r--r--   0 runner    (1001) docker     (127)     6992 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_convert.py
--rw-r--r--   0 runner    (1001) docker     (127)     4307 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     6027 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_sol.py
--rw-r--r--   0 runner    (1001) docker     (127)     9106 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_soln.py
--rw-r--r--   0 runner    (1001) docker     (127)     4454 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/base/test_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/opt/tests/solver/
--rw-r--r--   0 runner    (1001) docker     (127)      574 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/solver/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    13258 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/opt/tests/solver/test_shellcmd.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.496348 Pyomo-6.7.1/pyomo/pysp/
--rw-r--r--   0 runner    (1001) docker     (127)     1554 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/pysp/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.500348 Pyomo-6.7.1/pyomo/repn/
--rw-r--r--   0 runner    (1001) docker     (127)      673 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.500348 Pyomo-6.7.1/pyomo/repn/beta/
--rw-r--r--   0 runner    (1001) docker     (127)      571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/beta/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    24876 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/beta/matrix.py
--rw-r--r--   0 runner    (1001) docker     (127)    29105 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/linear.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.500348 Pyomo-6.7.1/pyomo/repn/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)     1650 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.500348 Pyomo-6.7.1/pyomo/repn/plugins/ampl/
--rw-r--r--   0 runner    (1001) docker     (127)      600 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/ampl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    79844 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/ampl/ampl_.py
--rw-r--r--   0 runner    (1001) docker     (127)    31767 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/baron_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)    39685 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/cpxlp.py
--rw-r--r--   0 runner    (1001) docker     (127)    40243 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/gams_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)    23702 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/lp_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)    32962 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/mps.py
--rw-r--r--   0 runner    (1001) docker     (127)   117411 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/nl_writer.py
--rw-r--r--   0 runner    (1001) docker     (127)    19591 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/plugins/standard_form.py
--rw-r--r--   0 runner    (1001) docker     (127)    13916 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/quadratic.py
--rw-r--r--   0 runner    (1001) docker     (127)     1450 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/standard_aux.py
--rw-r--r--   0 runner    (1001) docker     (127)    59143 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/standard_repn.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.500348 Pyomo-6.7.1/pyomo/repn/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      569 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.504348 Pyomo-6.7.1/pyomo/repn/tests/ampl/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      801 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/helper.py
--rw-r--r--   0 runner    (1001) docker     (127)      677 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/nl_diff.py
--rw-r--r--   0 runner    (1001) docker     (127)     3286 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small10_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1522 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small11_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     4916 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small12_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1200 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small13_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     2075 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small14_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1155 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small15_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1050 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small1_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1047 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small2_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1057 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small3_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1058 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small4_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     2516 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small5_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1974 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small6_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     4029 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small7_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1729 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small8_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     1880 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/small9_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)     5596 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_comparison.py
--rw-r--r--   0 runner    (1001) docker     (127)    15142 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_nl.py
--rw-r--r--   0 runner    (1001) docker     (127)     1473 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_repn.py
--rw-r--r--   0 runner    (1001) docker     (127)    64603 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/test_nlv2.py
--rw-r--r--   0 runner    (1001) docker     (127)     8196 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/ampl/test_suffixes.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.504348 Pyomo-6.7.1/pyomo/repn/tests/baron/
--rw-r--r--   0 runner    (1001) docker     (127)      571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/baron/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1128 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/baron/small14a_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)    11418 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/baron/test_baron.py
--rw-r--r--   0 runner    (1001) docker     (127)     3184 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/baron/test_baron_comparison.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.504348 Pyomo-6.7.1/pyomo/repn/tests/cpxlp/
--rw-r--r--   0 runner    (1001) docker     (127)      571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/cpxlp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    14579 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/cpxlp/test_cpxlp.py
--rw-r--r--   0 runner    (1001) docker     (127)     3880 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/cpxlp/test_lpv2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1744 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/diffutils.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/repn/tests/gams/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/gams/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2047 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/gams/small14a_testCase.py
--rw-r--r--   0 runner    (1001) docker     (127)    16996 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/gams/test_gams.py
--rw-r--r--   0 runner    (1001) docker     (127)     3800 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/gams/test_gams_comparison.py
--rw-r--r--   0 runner    (1001) docker     (127)     2365 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/lp_diff.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/repn/tests/mps/
--rw-r--r--   0 runner    (1001) docker     (127)      569 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/mps/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     8094 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/mps/test_mps.py
--rw-r--r--   0 runner    (1001) docker     (127)     4666 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/nl_diff.py
--rw-r--r--   0 runner    (1001) docker     (127)    62877 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/test_linear.py
--rw-r--r--   0 runner    (1001) docker     (127)    15522 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/test_quadratic.py
--rw-r--r--   0 runner    (1001) docker     (127)   163906 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/test_standard.py
--rw-r--r--   0 runner    (1001) docker     (127)     9499 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/test_standard_form.py
--rw-r--r--   0 runner    (1001) docker     (127)    32193 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/tests/test_util.py
--rw-r--r--   0 runner    (1001) docker     (127)    25765 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/repn/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/scripting/
--rw-r--r--   0 runner    (1001) docker     (127)      606 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1491 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/commands.py
--rw-r--r--   0 runner    (1001) docker     (127)     7228 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/convert.py
--rw-r--r--   0 runner    (1001) docker     (127)    17713 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/driver_help.py
--rw-r--r--   0 runner    (1001) docker     (127)     3325 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/interface.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/scripting/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      769 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3156 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/build_ext.py
--rw-r--r--   0 runner    (1001) docker     (127)     9209 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/convert.py
--rw-r--r--   0 runner    (1001) docker     (127)     3422 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/download.py
--rw-r--r--   0 runner    (1001) docker     (127)     4131 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/extras.py
--rw-r--r--   0 runner    (1001) docker     (127)     8410 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/plugins/solve.py
--rw-r--r--   0 runner    (1001) docker     (127)     4274 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/pyomo_command.py
--rw-r--r--   0 runner    (1001) docker     (127)     3405 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/pyomo_main.py
--rw-r--r--   0 runner    (1001) docker     (127)     3806 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/pyomo_parser.py
--rw-r--r--   0 runner    (1001) docker     (127)    15111 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/solve_config.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/scripting/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      580 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3350 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/tests/test_cmds.py
--rw-r--r--   0 runner    (1001) docker     (127)    42654 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/scripting/util.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/solvers/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2178 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/mockmip.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.508348 Pyomo-6.7.1/pyomo/solvers/plugins/
--rw-r--r--   0 runner    (1001) docker     (127)      638 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.512348 Pyomo-6.7.1/pyomo/solvers/plugins/converter/
--rw-r--r--   0 runner    (1001) docker     (127)      676 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/converter/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3335 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/converter/ampl.py
--rw-r--r--   0 runner    (1001) docker     (127)     4628 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/converter/glpsol.py
--rw-r--r--   0 runner    (1001) docker     (127)    10717 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/converter/model.py
--rw-r--r--   0 runner    (1001) docker     (127)     3566 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/converter/pico.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.516348 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/
--rw-r--r--   0 runner    (1001) docker     (127)     9406 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/ASL.py
--rw-r--r--   0 runner    (1001) docker     (127)    24289 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/BARON.py
--rw-r--r--   0 runner    (1001) docker     (127)    50963 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CBCplugin.py
--rw-r--r--   0 runner    (1001) docker     (127)     5979 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CONOPT.py
--rw-r--r--   0 runner    (1001) docker     (127)    46100 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CPLEX.py
--rw-r--r--   0 runner    (1001) docker     (127)    56842 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GAMS.py
--rw-r--r--   0 runner    (1001) docker     (127)    21966 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GLPK.py
--rw-r--r--   0 runner    (1001) docker     (127)    23357 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GUROBI.py
--rw-r--r--   0 runner    (1001) docker     (127)    13685 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GUROBI_RUN.py
--rw-r--r--   0 runner    (1001) docker     (127)     7894 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/IPOPT.py
--rw-r--r--   0 runner    (1001) docker     (127)    19727 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/SCIPAMPL.py
--rw-r--r--   0 runner    (1001) docker     (127)     1537 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/XPRESS.py
--rw-r--r--   0 runner    (1001) docker     (127)     1553 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    41460 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/cplex_direct.py
--rw-r--r--   0 runner    (1001) docker     (127)     6268 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/cplex_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    13571 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/direct_or_persistent_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)     9294 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/direct_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)    46368 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/gurobi_direct.py
--rw-r--r--   0 runner    (1001) docker     (127)    24856 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/gurobi_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    54556 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/mosek_direct.py
--rw-r--r--   0 runner    (1001) docker     (127)    10610 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/mosek_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    23616 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/persistent_solver.py
--rw-r--r--   0 runner    (1001) docker     (127)     1488 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/pywrapper.py
--rw-r--r--   0 runner    (1001) docker     (127)    43945 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/xpress_direct.py
--rw-r--r--   0 runner    (1001) docker     (127)     8107 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/plugins/solvers/xpress_persistent.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.516348 Pyomo-6.7.1/pyomo/solvers/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      566 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/__init__.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.516348 Pyomo-6.7.1/pyomo/solvers/tests/checks/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3401 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_BARON.py
--rw-r--r--   0 runner    (1001) docker     (127)    19032 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CBCplugin.py
--rw-r--r--   0 runner    (1001) docker     (127)    21968 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CPLEXDirect.py
--rw-r--r--   0 runner    (1001) docker     (127)     4117 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CPLEXPersistent.py
--rw-r--r--   0 runner    (1001) docker     (127)    19199 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_GAMS.py
--rw-r--r--   0 runner    (1001) docker     (127)    11273 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_MOSEKDirect.py
--rw-r--r--   0 runner    (1001) docker     (127)     6415 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_MOSEKPersistent.py
--rw-r--r--   0 runner    (1001) docker     (127)     5285 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_cbc.py
--rw-r--r--   0 runner    (1001) docker     (127)    13367 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_cplex.py
--rw-r--r--   0 runner    (1001) docker     (127)     1919 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi.py
--rw-r--r--   0 runner    (1001) docker     (127)    17227 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi_direct.py
--rw-r--r--   0 runner    (1001) docker     (127)    14556 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi_persistent.py
--rw-r--r--   0 runner    (1001) docker     (127)     4248 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_no_solution_behavior.py
--rw-r--r--   0 runner    (1001) docker     (127)     5756 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_pickle.py
--rw-r--r--   0 runner    (1001) docker     (127)     6807 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_writers.py
--rw-r--r--   0 runner    (1001) docker     (127)    12381 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/checks/test_xpress_persistent.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.520348 Pyomo-6.7.1/pyomo/solvers/tests/mip/
--rw-r--r--   0 runner    (1001) docker     (127)      570 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      789 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/model.py
--rw-r--r--   0 runner    (1001) docker     (127)     4613 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_asl.py
--rw-r--r--   0 runner    (1001) docker     (127)    12781 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_convert.py
--rw-r--r--   0 runner    (1001) docker     (127)     5232 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_factory.py
--rw-r--r--   0 runner    (1001) docker     (127)     8559 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_ipopt.py
--rw-r--r--   0 runner    (1001) docker     (127)      760 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_mip.py
--rw-r--r--   0 runner    (1001) docker     (127)     7353 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_qp.py
--rw-r--r--   0 runner    (1001) docker     (127)     4275 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip.py
--rw-r--r--   0 runner    (1001) docker     (127)     7333 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip_log_data.py
--rw-r--r--   0 runner    (1001) docker     (127)    10703 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip_version.py
--rw-r--r--   0 runner    (1001) docker     (127)     2308 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/mip/test_solver.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.524348 Pyomo-6.7.1/pyomo/solvers/tests/models/
--rw-r--r--   0 runner    (1001) docker     (127)     2681 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_block.py
--rw-r--r--   0 runner    (1001) docker     (127)     9374 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_compiled.py
--rw-r--r--   0 runner    (1001) docker     (127)     1838 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_constant_objective1.py
--rw-r--r--   0 runner    (1001) docker     (127)     1880 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_constant_objective2.py
--rw-r--r--   0 runner    (1001) docker     (127)     4486 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_duals_maximize.py
--rw-r--r--   0 runner    (1001) docker     (127)     4217 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_duals_minimize.py
--rw-r--r--   0 runner    (1001) docker     (127)     4087 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_inactive_index.py
--rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_infeasible1.py
--rw-r--r--   0 runner    (1001) docker     (127)     2407 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_infeasible2.py
--rw-r--r--   0 runner    (1001) docker     (127)     1873 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_piecewise.py
--rw-r--r--   0 runner    (1001) docker     (127)     3741 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     5039 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_trivial_constraints.py
--rw-r--r--   0 runner    (1001) docker     (127)     2315 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unbounded.py
--rw-r--r--   0 runner    (1001) docker     (127)     2604 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unique_duals.py
--rw-r--r--   0 runner    (1001) docker     (127)     6896 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unused_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     2875 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_discrete_var_bounds.py
--rw-r--r--   0 runner    (1001) docker     (127)     2913 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_infeasible1.py
--rw-r--r--   0 runner    (1001) docker     (127)     2240 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2431 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_unbounded.py
--rw-r--r--   0 runner    (1001) docker     (127)     7226 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_unused_vars.py
--rw-r--r--   0 runner    (1001) docker     (127)     2435 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MIQCP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2825 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/MIQP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     4403 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/QCP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2054 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/QP_constant_objective.py
--rw-r--r--   0 runner    (1001) docker     (127)     3628 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/QP_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     2919 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/SOS1_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     4439 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/SOS2_simple.py
--rw-r--r--   0 runner    (1001) docker     (127)     1995 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    18504 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/models/base.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.524348 Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/
--rw-r--r--   0 runner    (1001) docker     (127)      582 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     4432 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_examples.py
--rw-r--r--   0 runner    (1001) docker     (127)     7512 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear.py
--rw-r--r--   0 runner    (1001) docker     (127)     6080 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear_kernel.py
--rw-r--r--   0 runner    (1001) docker     (127)    12977 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/solvers.py
--rw-r--r--   0 runner    (1001) docker     (127)    17619 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/tests/testcases.py
--rw-r--r--   0 runner    (1001) docker     (127)      636 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/solvers/wrappers.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.524348 Pyomo-6.7.1/pyomo/util/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1381 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/blockutil.py
--rw-r--r--   0 runner    (1001) docker     (127)    12295 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/calc_var_value.py
--rw-r--r--   0 runner    (1001) docker     (127)     9972 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/check_units.py
--rw-r--r--   0 runner    (1001) docker     (127)     4353 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/components.py
--rw-r--r--   0 runner    (1001) docker     (127)     1311 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/diagnostics.py
--rw-r--r--   0 runner    (1001) docker     (127)    11712 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/infeasible.py
--rw-r--r--   0 runner    (1001) docker     (127)     6947 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/model_size.py
--rw-r--r--   0 runner    (1001) docker     (127)     6999 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/report_scaling.py
--rw-r--r--   0 runner    (1001) docker     (127)    10600 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/slices.py
--rw-r--r--   0 runner    (1001) docker     (127)    12471 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/subsystems.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.528348 Pyomo-6.7.1/pyomo/util/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      540 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2510 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_blockutil.py
--rw-r--r--   0 runner    (1001) docker     (127)    17371 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_calc_var_value.py
--rw-r--r--   0 runner    (1001) docker     (127)    12096 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_check_units.py
--rw-r--r--   0 runner    (1001) docker     (127)     5047 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_components.py
--rw-r--r--   0 runner    (1001) docker     (127)     8005 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_infeasible.py
--rw-r--r--   0 runner    (1001) docker     (127)     8635 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_model_size.py
--rw-r--r--   0 runner    (1001) docker     (127)     2895 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_report_scaling.py
--rw-r--r--   0 runner    (1001) docker     (127)    28108 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_slices.py
--rw-r--r--   0 runner    (1001) docker     (127)    28274 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/tests/test_subsystems.py
--rw-r--r--   0 runner    (1001) docker     (127)     2184 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/util/vars_from_expressions.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.528348 Pyomo-6.7.1/pyomo/version/
--rw-r--r--   0 runner    (1001) docker     (127)      940 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/version/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3167 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/version/info.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-02-21 17:29:35.528348 Pyomo-6.7.1/pyomo/version/tests/
--rw-r--r--   0 runner    (1001) docker     (127)      542 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/version/tests/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)      727 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/version/tests/check.py
--rw-r--r--   0 runner    (1001) docker     (127)     1688 2024-02-21 17:29:26.000000 Pyomo-6.7.1/pyomo/version/tests/test_version.py
--rw-r--r--   0 runner    (1001) docker     (127)      738 2024-02-21 17:29:35.528348 Pyomo-6.7.1/setup.cfg
--rw-r--r--   0 runner    (1001) docker     (127)    13052 2024-02-21 17:29:26.000000 Pyomo-6.7.1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.571276 Pyomo-6.7.2/
+-rw-r--r--   0 runner    (1001) docker     (127)     1733 2024-05-09 15:34:13.000000 Pyomo-6.7.2/LICENSE.md
+-rw-r--r--   0 runner    (1001) docker     (127)       37 2024-05-09 15:34:13.000000 Pyomo-6.7.2/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (127)     6803 2024-05-09 15:34:26.571276 Pyomo-6.7.2/PKG-INFO
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.367272 Pyomo-6.7.2/Pyomo.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     6803 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)    53451 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      203 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      602 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        6 2024-05-09 15:34:26.000000 Pyomo-6.7.2/Pyomo.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     5443 2024-05-09 15:34:13.000000 Pyomo-6.7.2/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.367272 Pyomo-6.7.2/pyomo/
+-rw-r--r--   0 runner    (1001) docker     (127)     3777 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/__future__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      595 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.371272 Pyomo-6.7.2/pyomo/common/
+-rw-r--r--   0 runner    (1001) docker     (127)     1070 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1215 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/_command.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1372 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/_common.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12461 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/autoslots.py
+-rw-r--r--   0 runner    (1001) docker     (127)      691 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/backports.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5014 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/cmake_builder.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.371272 Pyomo-6.7.2/pyomo/common/collections/
+-rw-r--r--   0 runner    (1001) docker     (127)      829 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/collections/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6071 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/collections/bunch.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6886 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/collections/component_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4610 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/collections/component_set.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2572 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/collections/orderedset.py
+-rw-r--r--   0 runner    (1001) docker     (127)    95866 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39759 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/dependencies.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21105 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/deprecation.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16764 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/download.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5279 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/enums.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17402 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/env.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1264 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/envvar.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7496 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)      631 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/extensions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2243 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27265 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/fileutils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13929 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/formatting.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3014 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/gc_manager.py
+-rw-r--r--   0 runner    (1001) docker     (127)      650 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/getGSL.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1259 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/gsl.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13112 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/log.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2744 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/modeling.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3119 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/multithread.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14294 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/numeric_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)      658 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/plugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12089 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/plugin_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)      563 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1165 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/pyomo_typing.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1133 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/shutdown.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5115 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/sorting.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20308 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tee.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16192 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tempfiles.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/common/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      795 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/config_plugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)      841 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/dep_mod.py
+-rw-r--r--   0 runner    (1001) docker     (127)      582 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/dep_mod_except.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1496 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/deps.py
+-rw-r--r--   0 runner    (1001) docker     (127)      568 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/import_ex.py
+-rw-r--r--   0 runner    (1001) docker     (127)      663 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/relo_mod.py
+-rw-r--r--   0 runner    (1001) docker     (127)      592 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/relo_mod_new.py
+-rw-r--r--   0 runner    (1001) docker     (127)      969 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/relocated.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6472 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_bunch.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2810 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_component_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)   118848 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_config.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16652 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_dependencies.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23726 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_deprecated.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12377 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_download.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3904 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_enums.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5461 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_env.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5294 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19530 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_fileutils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_formatting.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2567 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_gc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18727 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_log.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1937 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_modeling.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4420 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_multithread.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10015 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_numeric_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3006 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_orderedset.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10254 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_plugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3568 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_sorting.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12111 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_tee.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21463 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_tempfile.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25880 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_timing.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1002 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_typing.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18954 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/tests/test_unittest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37810 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/timing.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33700 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/common/unittest.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1133 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/build.py
+-rw-r--r--   0 runner    (1001) docker     (127)      774 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/
+-rw-r--r--   0 runner    (1001) docker     (127)     1753 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     4292 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/FindASL.cmake
+-rw-r--r--   0 runner    (1001) docker     (127)     6118 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/functions.c
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3121 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/tests/test_ampl_function_demo.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/appsi/
+-rw-r--r--   0 runner    (1001) docker     (127)      623 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63435 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4095 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/build.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.379272 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/
+-rw-r--r--   0 runner    (1001) docker     (127)     1379 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.383272 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/
+-rw-r--r--   0 runner    (1001) docker     (127)     8434 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/cmodel_bindings.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      581 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/common.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      665 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/common.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    67338 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/expression.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    32505 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/expression.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     8598 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/fbbt_model.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2915 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/fbbt_model.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    32839 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/interval.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5791 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/interval.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    14297 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/lp_writer.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     2040 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/lp_writer.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/model_base.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1586 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/model_base.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)    17749 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/nl_writer.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     3027 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/nl_writer.hpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.383272 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1431 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/tests/test_import.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.383272 Pyomo-6.7.2/pyomo/contrib/appsi/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2343 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/examples/getting_started.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.383272 Pyomo-6.7.2/pyomo/contrib/appsi/examples/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/examples/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1214 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/examples/tests/test_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11453 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/fbbt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1441 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.383272 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/
+-rw-r--r--   0 runner    (1001) docker     (127)      742 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17796 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/cbc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17228 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/cplex.py
+-rw-r--r--   0 runner    (1001) docker     (127)    60562 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/gurobi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30217 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/highs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19812 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/ipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20101 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/maingo.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10112 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/maingo_solvermodel.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25704 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_gurobi_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4030 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_highs_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2323 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_ipopt_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    57775 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_persistent_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7317 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_wntr_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18744 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/solvers/wntr.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5782 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_fbbt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2864 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_interval.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/utils/
+-rw-r--r--   0 runner    (1001) docker     (127)      653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1970 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/utils/collect_vars_and_named_exprs.py
+-rw-r--r--   0 runner    (1001) docker     (127)      867 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/utils/get_objective.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/utils/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/utils/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2692 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/utils/tests/test_collect_vars_and_named_exprs.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/writers/
+-rw-r--r--   0 runner    (1001) docker     (127)      605 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      638 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7157 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/lp_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10282 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/nl_writer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/appsi/writers/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10207 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/appsi/writers/tests/test_nl_writer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/benders/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13705 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/benders_cuts.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/benders/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6539 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/examples/farmer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1882 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/examples/grothey_ex.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.387272 Pyomo-6.7.2/pyomo/contrib/benders/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16832 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/benders/tests/test_benders.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/community_detection/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9978 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/community_graph.py
+-rw-r--r--   0 runner    (1001) docker     (127)    41445 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/detection.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7953 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/event_log.py
+-rw-r--r--   0 runner    (1001) docker     (127)      609 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/community_detection/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63466 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/community_detection/tests/test_detection.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/cp/
+-rw-r--r--   0 runner    (1001) docker     (127)     1349 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8086 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/interval_var.py
+-rw-r--r--   0 runner    (1001) docker     (127)      680 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/cp/repn/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/repn/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    50331 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/repn/docplex_writer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2115 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/precedence_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2492 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/scheduling_logic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5511 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/sequence_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12030 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/step_function_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5529 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/sequence_var.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.391272 Pyomo-6.7.2/pyomo/contrib/cp/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    67813 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_docplex_walker.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15687 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_docplex_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8401 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_interval_var.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)    30065 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_logical_to_disjunctive.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7469 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_precedence_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5858 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_sequence_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5224 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_sequence_var.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19693 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/tests/test_step_function_expressions.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/cp/transform/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/transform/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5988 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/transform/logical_to_disjunctive_program.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10168 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/cp/transform/logical_to_disjunctive_walker.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/doe/
+-rw-r--r--   0 runner    (1001) docker     (127)      824 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    49775 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/doe.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/doe/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4155 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_compute_FIM.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_grid_search.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8618 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_kinetics.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5062 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_optimize_doe.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13062 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/measurements.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29614 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/result.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6574 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/scenario.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/doe/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2931 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/tests/test_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12406 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/tests/test_fim_doe.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8125 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/doe/tests/test_reactor_example.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/example/
+-rw-r--r--   0 runner    (1001) docker     (127)      993 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      549 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/bar.py
+-rw-r--r--   0 runner    (1001) docker     (127)      547 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/foo.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/example/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      700 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      994 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/plugins/ex_plugin.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/example/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      575 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      841 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/example/tests/test_example.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.395273 Pyomo-6.7.2/pyomo/contrib/fbbt/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10306 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/expression_bounds_walker.py
+-rw-r--r--   0 runner    (1001) docker     (127)    55929 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/fbbt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24721 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/interval.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.399273 Pyomo-6.7.2/pyomo/contrib/fbbt/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14518 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_expression_bounds_walker.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43511 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_fbbt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17498 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_interval.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.399273 Pyomo-6.7.2/pyomo/contrib/fme/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fme/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32586 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fme/fourier_motzkin_elimination.py
+-rw-r--r--   0 runner    (1001) docker     (127)      611 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fme/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.399273 Pyomo-6.7.2/pyomo/contrib/fme/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fme/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38415 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/fme/tests/test_fourier_motzkin_elimination.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.399273 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/
+-rw-r--r--   0 runner    (1001) docker     (127)      581 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8438 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/compute_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2926 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/info.py
+-rw-r--r--   0 runner    (1001) docker     (127)      605 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.399273 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4369 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdp_bounds/tests/test_gdp_bounds.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.403273 Pyomo-6.7.2/pyomo/contrib/gdpopt/
+-rw-r--r--   0 runner    (1001) docker     (127)     5881 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/GDPopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)      602 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20536 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/algorithm_base_class.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25984 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/branch_and_bound.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17323 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/config_options.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10492 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/create_oa_subproblems.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4094 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/cut_generation.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15075 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/discrete_problem_initialize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7840 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/enumerate.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9417 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/gloa.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13252 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/loa.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2301 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/nlp_initialization.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3179 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/oa_algorithm_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)      793 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4378 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/ric.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9462 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/solve_discrete_problem.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15973 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/solve_subproblem.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.403273 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3128 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/common_tests.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12061 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_LBB.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7464 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_enumerate.py
+-rw-r--r--   0 runner    (1001) docker     (127)    73110 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_gdpopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21316 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gdpopt/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.403273 Pyomo-6.7.2/pyomo/contrib/gjh/
+-rw-r--r--   0 runner    (1001) docker     (127)     9789 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gjh/GJH.py
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gjh/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2077 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gjh/getGJH.py
+-rw-r--r--   0 runner    (1001) docker     (127)      889 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/gjh/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.403273 Pyomo-6.7.2/pyomo/contrib/iis/
+-rw-r--r--   0 runner    (1001) docker     (127)      653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4548 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/iis.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17416 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/mis.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.403273 Pyomo-6.7.2/pyomo/contrib/iis/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4666 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/tests/test_iis.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4202 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/tests/test_mis.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1066 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/iis/tests/trivial_mis.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/
+-rw-r--r--   0 runner    (1001) docker     (127)      900 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3731 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/dulmage_mendelsohn.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5338 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/tests/test_dulmage_mendelsohn.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4959 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/connected.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7095 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/dulmage_mendelsohn.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7111 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/incidence.py
+-rw-r--r--   0 runner    (1001) docker     (127)    42797 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3374 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/matching.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6436 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/scc_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4353 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/models_for_testing.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6900 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_connected.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8047 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_dulmage_mendelsohn.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10051 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_incidence.py
+-rw-r--r--   0 runner    (1001) docker     (127)    77033 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6970 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_matching.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20541 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_scc_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15890 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_triangularize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_visualize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8926 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/triangularize.py
+-rw-r--r--   0 runner    (1001) docker     (127)      989 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7631 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/incidence_analysis/visualize.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/interior_point/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.407273 Pyomo-6.7.2/pyomo/contrib/interior_point/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1535 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/examples/ex1.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18758 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27675 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/interior_point.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6207 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/inverse_reduced_hessian.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1150 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/base_linear_solver_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2650 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/ma27_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5307 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/mumps_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2140 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/scipy_interface.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5711 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/test_linear_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3327 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/test_realloc.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9378 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_interior_point.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5989 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_inverse_reduced_hessian.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4030 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_realloc.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5286 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_reg.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/latex_printer/
+-rw-r--r--   0 runner    (1001) docker     (127)      911 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/latex_printer/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46955 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/latex_printer/latex_printer.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27118 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/test_latex_printer.py
+-rw-r--r--   0 runner    (1001) docker     (127)   119853 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/test_latex_printer_vartypes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.411273 Pyomo-6.7.2/pyomo/contrib/mcpp/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3908 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/build.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1380 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/getMCPP.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4661 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/mcppInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)      831 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17223 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/pyomo_mcpp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12658 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mcpp/test_mcpp.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.415273 Pyomo-6.7.2/pyomo/contrib/mindtpy/
+-rw-r--r--   0 runner    (1001) docker     (127)     4319 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/MindtPy.py
+-rw-r--r--   0 runner    (1001) docker     (127)      565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   140954 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/algorithm_base_class.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26872 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/config_options.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19320 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/cut_generation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6962 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/extended_cutting_plane.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2709 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/feasibility_pump.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4618 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/global_outer_approximation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8012 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/outer_approximation.py
+-rw-r--r--   0 runner    (1001) docker     (127)      814 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43087 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/single_tree.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2020 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tabu_list.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.419273 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)     3956 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP2_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2864 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP3_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2208 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP4_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2117 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP5_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4515 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6265 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP_simple_grey_box.py
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1725 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/constraint_qualification_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9518 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/eight_process_problem.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1978 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/feasibility_pump1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1859 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/feasibility_pump2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1749 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/from_proposal.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2439 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3478 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2779 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex3.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2464 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex4.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1675 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/online_doc_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21085 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4031 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_ECP.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4847 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_feas_pump.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3786 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_global.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4970 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_global_lp_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3188 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_grey_box.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12046 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_lp_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10591 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_regularization.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5378 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_solution_pool.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3375 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/unit_test.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37557 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mindtpy/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.419273 Pyomo-6.7.2/pyomo/contrib/mpc/
+-rw-r--r--   0 runner    (1001) docker     (127)      778 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.419273 Pyomo-6.7.2/pyomo/contrib/mpc/data/
+-rw-r--r--   0 runner    (1001) docker     (127)      954 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6583 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4930 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/dynamic_data_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4800 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/find_nearest_index.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/get_cuid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8183 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/interval_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1571 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/scalar_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8356 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/series_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8097 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8629 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_find_nearest_index.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4436 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_get_cuid.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14395 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_interval_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4444 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_scalar_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8240 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_series_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5274 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5232 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/run_mpc.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2927 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/run_openloop.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3613 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/test_mpc.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3664 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/test_openloop.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/
+-rw-r--r--   0 runner    (1001) docker     (127)      813 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2019 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/copy_values.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6137 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/load_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15717 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/model_interface.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23841 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/test_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5756 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/test_var_linker.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2424 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/var_linker.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.423273 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/
+-rw-r--r--   0 runner    (1001) docker     (127)      768 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2615 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12821 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/cost_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6089 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/terminal.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.427273 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21740 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_cost_expressions.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4936 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_input_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3764 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_terminal.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.427273 Pyomo-6.7.2/pyomo/contrib/multistart/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2505 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/high_conf_stop.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9898 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/multi.py
+-rw-r--r--   0 runner    (1001) docker     (127)      596 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/reinit.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5941 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/multistart/test_multi.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.427273 Pyomo-6.7.2/pyomo/contrib/parmest/
+-rw-r--r--   0 runner    (1001) docker     (127)     1061 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.427273 Pyomo-6.7.2/pyomo/contrib/parmest/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.427273 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reaction_kinetics/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reaction_kinetics/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5765 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reaction_kinetics/simple_reaction_parmest_example.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.431273 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1763 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/bootstrap_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1568 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/confidence_region_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4941 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/datarec_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3170 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/leaveNout_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1955 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/likelihood_ratio_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2983 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/multisensor_data_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1413 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/parameter_estimation_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4637 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/reactor_design.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/timeseries_data_example.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.431273 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2002 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/bootstrap_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2185 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/likelihood_ratio_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2288 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/parameter_estimation_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3079 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3290 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler_with_constraint.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.431273 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2126 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/parallel_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1585 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/parameter_estimation_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2036 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/scenario_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9331 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/semibatch.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1117 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/experiment.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21311 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/graphics.py
+-rw-r--r--   0 runner    (1001) docker     (127)      682 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/ipopt_solver_wrapper.py
+-rw-r--r--   0 runner    (1001) docker     (127)    95547 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/parmest.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6285 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/scenariocreator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.431273 Pyomo-6.7.2/pyomo/contrib/parmest/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5860 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2024 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_graphics.py
+-rw-r--r--   0 runner    (1001) docker     (127)    77474 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_parmest.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22344 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_scenariocreator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2200 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2326 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_utils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.435273 Pyomo-6.7.2/pyomo/contrib/parmest/utils/
+-rw-r--r--   0 runner    (1001) docker     (127)     1000 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13701 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/create_ef.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2753 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/ipopt_solver_wrapper.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7993 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/model_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5780 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/mpi_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4703 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/parmest/utils/scenario_tree.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.435273 Pyomo-6.7.2/pyomo/contrib/piecewise/
+-rw-r--r--   0 runner    (1001) docker     (127)     1699 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1770 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/piecewise_linear_expression.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21052 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/piecewise_linear_function.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.435273 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3200 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/common_inner_repn_tests.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3118 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/common_tests.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1980 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/models.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11224 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_disaggregated_logarithmic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5162 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_inner_repn_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6188 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_nested_inner_repn_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7551 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_outer_repn_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19998 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_piecewise_linear_function.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10633 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_reduced_inner_repn.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.435273 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1705 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/convex_combination.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1673 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/disaggregated_convex_combination.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8685 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/disaggregated_logarithmic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5092 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/inner_representation_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1915 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/multiple_choice.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9198 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/nested_inner_repn.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5792 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/outer_representation_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10110 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/piecewise_linear_transformation_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2193 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/piecewise_to_mip_visitor.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6535 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/piecewise/transform/reduced_inner_representation_gdp.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.439273 Pyomo-6.7.2/pyomo/contrib/preprocessing/
+-rw-r--r--   0 runner    (1001) docker     (127)      584 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.439273 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)     1330 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5886 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/bounds_to_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3583 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/constraint_tightener.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5709 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/deactivate_trivial_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3174 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/detect_fixed_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9848 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/equality_propagate.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16501 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/induced_linearity.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3269 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/init_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6138 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/int_to_binary.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3586 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/remove_zero_terms.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4041 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/strip_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13267 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/var_aggregator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4215 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/zero_sum_propagator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.443273 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3898 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_bounds_to_vars_xfrm.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5033 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_constraint_tightener.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5080 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_deactivate_trivial_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1747 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_detect_fixed_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9049 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_equality_propagate.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7574 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_induced_linearity.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2893 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_init_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_int_to_binary.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5021 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_strip_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9537 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_var_aggregator.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4843 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_zero_sum_propagate.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2876 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_zero_term_removal.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1176 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/preprocessing/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.443273 Pyomo-6.7.2/pyomo/contrib/pynumero/
+-rw-r--r--   0 runner    (1001) docker     (127)      616 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.443273 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.443273 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18119 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/cyipopt_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24657 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/implicit_functions.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16823 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/pyomo_ext_cyipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17076 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/scipy_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4701 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/square_solver_base.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.443273 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9150 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11788 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13213 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_implicit_functions.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14262 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_pyomo_ext_cyipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    22682 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_scipy_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17183 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/asl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1079 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/build.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1141 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/dependencies.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1575 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_callback.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1194 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_callback_halt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1941 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_functor_callback.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1619 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/reactor_design.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3533 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/generate_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9346 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/models.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4167 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/perform_estimation.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2111 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_outputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9959 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_ratio_residuals.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4372 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_outputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17675 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_residuals.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4154 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/feasibility.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2811 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/mumps_example.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2087 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/nlp_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3153 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/nlp_interface_2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1721 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/parallel_matvec.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1420 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/parallel_vector_ops.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4611 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/sensitivity.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/sqp.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.447274 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_cyipopt_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2254 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1831 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_mpi_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)      831 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/exceptions.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.451274 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/
+-rw-r--r--   0 runner    (1001) docker     (127)      828 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33682 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/ampl_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15656 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/cyipopt_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17574 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/external_grey_box.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18890 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/external_pyomo_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16577 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15292 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/nlp_projections.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33401 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/pyomo_grey_box_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59480 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/pyomo_nlp.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.451274 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2289 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/compare_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21711 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/external_grey_box_models.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7889 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_cyipopt_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23094 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_dynamic_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2089 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_asl_function.py
+-rw-r--r--   0 runner    (1001) docker     (127)    86169 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_grey_box_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43312 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_block.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43190 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35115 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23319 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_nlp_projections.py
+-rw-r--r--   0 runner    (1001) docker     (127)   102434 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_pyomo_grey_box_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3522 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7217 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18636 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/intrinsic.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.455274 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/
+-rw-r--r--   0 runner    (1001) docker     (127)      601 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2840 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6208 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma27.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4929 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma27_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8513 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma57.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5373 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma57_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9707 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/mumps_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4225 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/scipy_interface.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.455274 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4274 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_linear_solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6843 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_ma27.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6386 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_ma57.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2742 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_mumps_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1364 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1806 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.455274 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/
+-rw-r--r--   0 runner    (1001) docker     (127)      792 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7123 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/base_block.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46318 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/block_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59856 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/block_vector.py
+-rw-r--r--   0 runner    (1001) docker     (127)    45374 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/mpi_block_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56271 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/mpi_block_vector.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.459274 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32251 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_block_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36325 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_block_vector.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6251 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_intrinsics.py
+-rw-r--r--   0 runner    (1001) docker     (127)    53461 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63243 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_vector.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.459274 Pyomo-6.7.2/pyomo/contrib/pynumero/src/
+-rw-r--r--   0 runner    (1001) docker     (127)    18075 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/AmplInterface.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     5109 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/AmplInterface.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     1486 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/AssertUtils.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)     4132 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)     8077 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/ma27Interface.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)    11942 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/ma57Interface.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.459274 Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      216 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/CMakeLists.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      712 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/simple_nlp.nl
+-rw-r--r--   0 runner    (1001) docker     (127)      745 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/simple_test.cpp
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.459274 Pyomo-6.7.2/pyomo/contrib/pynumero/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pynumero/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.459274 Pyomo-6.7.2/pyomo/contrib/pyros/
+-rw-r--r--   0 runner    (1001) docker     (127)      920 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28898 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33145 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/master_problem_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18964 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/pyros.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37868 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/pyros_algorithm_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)    49923 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/separation_problem_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28174 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/solve_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/pyros/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20428 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/tests/test_config.py
+-rw-r--r--   0 runner    (1001) docker     (127)   249981 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/tests/test_grcs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    96732 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/uncertainty_sets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    73256 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/pyros/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/satsolver/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/satsolver/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11680 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/satsolver/satsolver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8923 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/satsolver/test_satsolver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/
+-rw-r--r--   0 runner    (1001) docker     (127)     1115 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/
+-rwxr-xr-x   0 runner    (1001) docker     (127)     9690 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/HIV_Transmission.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1116 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3860 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/feedbackController.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4017 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/parameter.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3251 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/parameter_kaug.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1285 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/rangeInequality.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3088 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/rooney_biegler.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5335 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/k_aug.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28361 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/sens.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)     1122 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5439 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_k_aug_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35170 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_sens.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35304 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_sens_unit.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/simplemodel/
+-rw-r--r--   0 runner    (1001) docker     (127)     1204 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplemodel/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/simplification/
+-rw-r--r--   0 runner    (1001) docker     (127)      574 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7557 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/build.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/simplification/ginac/
+-rw-r--r--   0 runner    (1001) docker     (127)     1955 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/ginac/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.463274 Pyomo-6.7.2/pyomo/contrib/simplification/ginac/src/
+-rw-r--r--   0 runner    (1001) docker     (127)    11202 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/ginac/src/ginac_interface.cpp
+-rw-r--r--   0 runner    (1001) docker     (127)     7359 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/ginac/src/ginac_interface.hpp
+-rw-r--r--   0 runner    (1001) docker     (127)      725 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2729 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/simplify.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/simplification/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4149 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/simplification/tests/test_simplification.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/solver/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23426 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14752 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1345 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)    58164 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/gurobi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15342 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/gurobi_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21106 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/ipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20729 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1098 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/plugins.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13770 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/results.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9242 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/sol_reader.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8938 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/solution.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/solver/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24875 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_gurobi_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2049 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_ipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)    68410 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_solvers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.467274 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/sol_files/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/sol_files/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14956 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5348 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9217 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_ipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9456 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_results.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_sol_reader.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3564 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_solution.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5955 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4588 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/solver/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.471274 Pyomo-6.7.2/pyomo/contrib/trustregion/
+-rw-r--r--   0 runner    (1001) docker     (127)    16856 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/TRF.py
+-rw-r--r--   0 runner    (1001) docker     (127)      845 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.471274 Pyomo-6.7.2/pyomo/contrib/trustregion/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      845 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/examples/__init__.py
+-rwxr-xr-x   0 runner    (1001) docker     (127)     2294 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/examples/example1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2336 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/examples/example2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2597 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/filter.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17456 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)      997 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.471274 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      845 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8931 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_TRF.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4528 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1909 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_filter.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20875 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_interface.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5736 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4740 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/trustregion/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.471274 Pyomo-6.7.2/pyomo/contrib/viewer/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7692 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/main.ui
+-rw-r--r--   0 runner    (1001) docker     (127)    22054 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/model_browser.py
+-rw-r--r--   0 runner    (1001) docker     (127)      518 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/model_browser.ui
+-rw-r--r--   0 runner    (1001) docker     (127)     3075 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/model_select.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2335 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/model_select.ui
+-rw-r--r--   0 runner    (1001) docker     (127)     5167 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/pyomo_viewer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4423 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/qt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5067 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/report.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5058 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/residual_table.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1323 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/residual_table.ui
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.475274 Pyomo-6.7.2/pyomo/contrib/viewer/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10467 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_data_model_item.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10064 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_data_model_tree.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8234 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_qt.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7270 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_report.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10970 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/ui.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5024 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/contrib/viewer/ui_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.475274 Pyomo-6.7.2/pyomo/core/
+-rw-r--r--   0 runner    (1001) docker     (127)     5413 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.483274 Pyomo-6.7.2/pyomo/core/base/
+-rw-r--r--   0 runner    (1001) docker     (127)    34707 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/PyomoModel.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5168 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2677 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/action.py
+-rw-r--r--   0 runner    (1001) docker     (127)    93464 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/block.py
+-rw-r--r--   0 runner    (1001) docker     (127)      959 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/blockutil.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21419 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/boolean_var.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2818 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/check.py
+-rw-r--r--   0 runner    (1001) docker     (127)    41048 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/component.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/component_namer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1250 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/component_order.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26026 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/componentuid.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4692 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9443 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/connector.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36860 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5714 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/disable_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3058 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/enums.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16843 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/expression.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29704 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/external.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5036 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/global_set.py
+-rw-r--r--   0 runner    (1001) docker     (127)    48071 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/indexed_component.py
+-rw-r--r--   0 runner    (1001) docker     (127)    41781 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/indexed_component_slice.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20432 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/initializer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/instance2dat.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7061 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/label.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18913 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/logical_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11979 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/matrix_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3555 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/misc.py
+-rw-r--r--   0 runner    (1001) docker     (127)      623 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/numvalue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19191 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/objective.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37902 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/param.py
+-rw-r--r--   0 runner    (1001) docker     (127)    58237 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/piecewise.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1965 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/plugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35898 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/range.py
+-rw-r--r--   0 runner    (1001) docker     (127)      798 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/rangeset.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32908 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/reference.py
+-rw-r--r--   0 runner    (1001) docker     (127)   157776 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/set.py
+-rw-r--r--   0 runner    (1001) docker     (127)      921 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/set_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)      995 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/sets.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21022 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/sos.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15510 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/suffix.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2402 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/symbol_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1635 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/symbolic.py
+-rw-r--r--   0 runner    (1001) docker     (127)      899 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/template_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6458 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/transformation.py
+-rw-r--r--   0 runner    (1001) docker     (127)    58905 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/units_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1636 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37253 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/base/var.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.483274 Pyomo-6.7.2/pyomo/core/beta/
+-rw-r--r--   0 runner    (1001) docker     (127)      613 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/beta/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8755 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/beta/dict_objects.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9950 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/beta/list_objects.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.483274 Pyomo-6.7.2/pyomo/core/expr/
+-rw-r--r--   0 runner    (1001) docker     (127)     4915 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15317 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9271 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/boolean_value.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.487274 Pyomo-6.7.2/pyomo/core/expr/calculus/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/calculus/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4905 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/calculus/derivatives.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13315 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/calculus/diff_with_pyomo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3832 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/calculus/diff_with_sympy.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5700 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/cnf_walker.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10361 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/compare.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4039 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/current.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3423 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/expr_common.py
+-rw-r--r--   0 runner    (1001) docker     (127)      764 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/expr_errors.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16376 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/logical_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1695 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/ndarray.py
+-rw-r--r--   0 runner    (1001) docker     (127)   109971 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/numeric_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12940 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/numvalue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13852 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/relational_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7154 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/symbol_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8883 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/sympy_tools.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3598 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/taylor_series.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38237 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/template_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63974 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/expr/visitor.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.487274 Pyomo-6.7.2/pyomo/core/kernel/
+-rw-r--r--   0 runner    (1001) docker     (127)     2257 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10382 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/base.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20395 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/block.py
+-rw-r--r--   0 runner    (1001) docker     (127)      817 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/component_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)      817 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/component_set.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29748 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/conic.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29572 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3044 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/container_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5503 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/dict_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7899 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/expression.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10175 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/heterogeneous_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2717 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/homogeneous_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4089 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/list_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15915 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/matrix_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2460 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/objective.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4229 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/parameter.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.491274 Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/
+-rw-r--r--   0 runner    (1001) docker     (127)      700 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    45131 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/transforms.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14298 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/transforms_nd.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5446 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2480 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/register_numpy_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1656 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/set_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3458 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/sos.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11500 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/suffix.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5288 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/tuple_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14446 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/kernel/variable.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.491274 Pyomo-6.7.2/pyomo/core/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      594 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.491274 Pyomo-6.7.2/pyomo/core/plugins/transform/
+-rw-r--r--   0 runner    (1001) docker     (127)     1176 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6547 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/add_slack_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4925 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/discrete_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3408 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/eliminate_fixed_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4491 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/equality_transform.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11986 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/expand_connectors.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2482 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/hierarchy.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17155 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/logical_to_linear.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14793 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/model.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16472 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/nonnegative_transform.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11617 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/radix_linearization.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1173 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/relax_integrality.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14392 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/scaling.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2815 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/standard_form.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7734 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/plugins/transform/util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2053 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/pyomoobject.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2896 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/staleflag.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.491274 Pyomo-6.7.2/pyomo/core/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      558 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.491274 Pyomo-6.7.2/pyomo/core/tests/data/
+-rw-r--r--   0 runner    (1001) docker     (127)      564 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/data/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5631 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/data/test_odbc_ini.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.495274 Pyomo-6.7.2/pyomo/core/tests/diet/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/diet/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5905 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/diet/test_diet.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.495274 Pyomo-6.7.2/pyomo/core/tests/examples/
+-rw-r--r--   0 runner    (1001) docker     (127)      567 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1864 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/pmedian.py
+-rw-r--r--   0 runner    (1001) docker     (127)      586 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/pmedian1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1351 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/pmedian2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1680 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/pmedian4.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2210 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/pmedian_concrete.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1364 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/test_amplbook2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3313 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/test_kernel_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12765 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/test_pyomo.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3053 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/examples/test_tutorials.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.495274 Pyomo-6.7.2/pyomo/core/tests/transform/
+-rw-r--r--   0 runner    (1001) docker     (127)      573 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/transform/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23105 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/transform/test_add_slacks.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25758 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/transform/test_scaling.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29458 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/transform/test_transform.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.507274 Pyomo-6.7.2/pyomo/core/tests/unit/
+-rw-r--r--   0 runner    (1001) docker     (127)      563 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.511275 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    89754 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_block.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8702 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_component_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9501 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_component_set.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30196 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_conic.py
+-rw-r--r--   0 runner    (1001) docker     (127)    67770 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37001 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_dict_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24597 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_expression.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8813 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_kernel.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40008 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_list_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)    44784 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_matrix_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4819 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_objective.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10434 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_parameter.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39687 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_piecewise.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6547 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_sos.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19448 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_suffix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31639 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_tuple_container.py
+-rw-r--r--   0 runner    (1001) docker     (127)    37427 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_variable.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4668 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_action.py
+-rw-r--r--   0 runner    (1001) docker     (127)   122073 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_block.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4697 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_block_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3153 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5103 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_check.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6785 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_compare.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4567 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_component.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46512 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_componentuid.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56914 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_con.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2513 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_concrete.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30317 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_connector.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1788 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_deprecation.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15985 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_derivs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14143 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_dict_objects.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6984 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_disable_methods.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2764 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_enums.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9087 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_expr_misc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35719 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_expression.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23167 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_external.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16859 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_indexed.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29150 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_indexed_slice.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27447 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_initializer.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2778 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_kernel_register_numpy_types.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10356 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_labelers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14855 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_list_objects.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3605 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17356 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_expr_expanded.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33829 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_to_linear.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3768 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_matrix_constraint.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6945 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_misc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    36091 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3834 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_mutable.py
+-rw-r--r--   0 runner    (1001) docker     (127)   188874 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    41414 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_api.py
+-rw-r--r--   0 runner    (1001) docker     (127)   275189 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_dispatcher.py
+-rw-r--r--   0 runner    (1001) docker     (127)   249244 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_zerofilter.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9244 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numpy_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19349 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_numvalue.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24637 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_obj.py
+-rw-r--r--   0 runner    (1001) docker     (127)    76479 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_param.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13318 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_pickle.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16809 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_piecewise.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1837 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_preprocess.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34645 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_range.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46006 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_reference.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15319 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_relational_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)   224135 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_set.py
+-rw-r--r--   0 runner    (1001) docker     (127)   129664 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_sets.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5591 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_smap.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7818 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_sos.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34102 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_sos_v2.py
+-rw-r--r--   0 runner    (1001) docker     (127)    76333 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_suffix.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4682 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_symbol_map.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12593 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_symbolic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_taylor_series.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27798 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_template_expr.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46156 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_units.py
+-rw-r--r--   0 runner    (1001) docker     (127)    64606 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_var.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10496 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_var_set_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59887 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_visitor.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2736 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/test_xfrm_discrete_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)      895 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/uninstantiated_model_linear.py
+-rw-r--r--   0 runner    (1001) docker     (127)      790 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/tests/unit/uninstantiated_model_quadratic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7824 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/core/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.515275 Pyomo-6.7.2/pyomo/dae/
+-rw-r--r--   0 runner    (1001) docker     (127)      768 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11268 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/contset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9124 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/diffvar.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25259 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/flatten.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6029 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/initialization.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6901 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/integral.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18734 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/misc.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.515275 Pyomo-6.7.2/pyomo/dae/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      636 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27260 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/plugins/colloc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13270 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/plugins/finitedifference.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11415 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/set_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40990 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/simulator.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.515275 Pyomo-6.7.2/pyomo/dae/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    25266 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_colloc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13287 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_contset.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6579 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_diffvar.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13717 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_finite_diff.py
+-rw-r--r--   0 runner    (1001) docker     (127)    79021 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_flatten.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4013 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_initialization.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8649 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_integral.py
+-rw-r--r--   0 runner    (1001) docker     (127)    35439 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_misc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15323 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_set_utils.py
+-rw-r--r--   0 runner    (1001) docker     (127)    49507 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/tests/test_simulator.py
+-rw-r--r--   0 runner    (1001) docker     (127)    71365 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dae/utilities.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.519275 Pyomo-6.7.2/pyomo/dataportal/
+-rw-r--r--   0 runner    (1001) docker     (127)    14917 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/DataPortal.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9273 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/TableData.py
+-rw-r--r--   0 runner    (1001) docker     (127)      756 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1603 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15930 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/parse_datacmds.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.519275 Pyomo-6.7.2/pyomo/dataportal/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      869 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2763 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/csv_table.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2026 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/datacommands.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23084 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/db_table.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8531 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/json_dict.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8027 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/sheet.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3264 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/text.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4148 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/plugins/xml_table.py
+-rw-r--r--   0 runner    (1001) docker     (127)    33443 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/process_data.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.519275 Pyomo-6.7.2/pyomo/dataportal/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      563 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1302 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/tests/test_dat_parser.py
+-rw-r--r--   0 runner    (1001) docker     (127)    80503 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/dataportal/tests/test_dataportal.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.519275 Pyomo-6.7.2/pyomo/duality/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9830 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/collect.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8181 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/lagrangian_dual.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5597 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/plugins.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.519275 Pyomo-6.7.2/pyomo/duality/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      558 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5839 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/duality/tests/test_linear_dual.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.523275 Pyomo-6.7.2/pyomo/environ/
+-rw-r--r--   0 runner    (1001) docker     (127)     6110 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/environ/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.523275 Pyomo-6.7.2/pyomo/environ/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      571 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/environ/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5089 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/environ/tests/standalone_minimal_pyomo_driver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6163 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/environ/tests/test_environ.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6065 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/environ/tests/test_package_layout.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.523275 Pyomo-6.7.2/pyomo/gdp/
+-rw-r--r--   0 runner    (1001) docker     (127)      855 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6134 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/basic_step.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29920 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/disjunct.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.527275 Pyomo-6.7.2/pyomo/gdp/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)     1092 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1928 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/between_steps.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21683 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/bigm.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10441 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/bigm_mixin.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7418 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/bilinear.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7210 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/binary_multiplication.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16563 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/bound_pretransformation.py
+-rw-r--r--   0 runner    (1001) docker     (127)      843 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/chull.py
+-rw-r--r--   0 runner    (1001) docker     (127)    51943 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/cuttingplane.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6413 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/fix_disjuncts.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13671 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/gdp_to_mip_transformation.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7719 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/gdp_var_mover.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43373 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/hull.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32832 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/multiple_bigm.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38486 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/partition_disjuncts.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12538 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/plugins/transform_current_disjunctive_state.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.527275 Pyomo-6.7.2/pyomo/gdp/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    73755 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/common_tests.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38160 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/models.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6209 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_basic_step.py
+-rw-r--r--   0 runner    (1001) docker     (127)   115559 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_bigm.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12211 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_binary_multiplication.py
+-rw-r--r--   0 runner    (1001) docker     (127)    38543 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_bound_pretransformation.py
+-rw-r--r--   0 runner    (1001) docker     (127)    49436 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_cuttingplane.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26203 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_disjunct.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6774 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_fix_disjuncts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9033 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_gdp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2075 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_gdp_reclassification_error.py
+-rw-r--r--   0 runner    (1001) docker     (127)   119545 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_hull.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43576 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_mbigm.py
+-rw-r--r--   0 runner    (1001) docker     (127)    88883 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_partition_disjuncts.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4198 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_reclassify.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13242 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_transform_current_disjunctive_state.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9390 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/tests/test_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1281 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/transformed_disjunct.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24508 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/gdp/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.527275 Pyomo-6.7.2/pyomo/kernel/
+-rw-r--r--   0 runner    (1001) docker     (127)     7481 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/kernel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9105 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/kernel/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/mpec/
+-rw-r--r--   0 runner    (1001) docker     (127)      630 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13910 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/complementarity.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/mpec/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      813 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4006 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/mpec1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4815 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/mpec2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1800 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/mpec3.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7403 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/mpec4.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1810 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/pathampl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5105 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/solver1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3786 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/plugins/solver2.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/mpec/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      565 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17226 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/tests/test_complementarity.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4730 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/tests/test_minlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4402 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/tests/test_nlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4398 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/mpec/tests/test_path.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/neos/
+-rw-r--r--   0 runner    (1001) docker     (127)     1537 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15676 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/kestrel.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/neos/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)     2487 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/plugins/NEOS.py
+-rw-r--r--   0 runner    (1001) docker     (127)      634 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11019 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/plugins/kestrel_plugin.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.531275 Pyomo-6.7.2/pyomo/neos/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      582 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      891 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/tests/model_min_lp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8807 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/neos/tests/test_neos.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/network/
+-rw-r--r--   0 runner    (1001) docker     (127)      675 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15315 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/arc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39211 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/decomposition.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34799 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/foqus_graph.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/network/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      599 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9744 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/plugins/expand_arcs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/port.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/network/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      567 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    86485 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/tests/test_arc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    29150 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/tests/test_decomposition.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17236 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/tests/test_port.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2495 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/network/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/opt/
+-rw-r--r--   0 runner    (1001) docker     (127)     1581 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/opt/base/
+-rw-r--r--   0 runner    (1001) docker     (127)     1034 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3595 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)      766 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/error.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/formats.py
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/opt_config.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1368 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/problem.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1212 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/results.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28126 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/base/solvers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/opt/parallel/
+-rw-r--r--   0 runner    (1001) docker     (127)      756 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/parallel/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2139 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/parallel/async_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2832 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/parallel/local.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7550 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/parallel/manager.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.535275 Pyomo-6.7.2/pyomo/opt/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      656 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2709 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/plugins/driver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1854 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/plugins/res.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12027 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/plugins/sol.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/problem/
+-rw-r--r--   0 runner    (1001) docker     (127)      653 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/problem/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2209 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/problem/ampl.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/results/
+-rw-r--r--   0 runner    (1001) docker     (127)     1088 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14767 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/container.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1531 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/problem.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8052 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/results_.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8424 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/solution.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8521 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/results/solver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/solver/
+-rw-r--r--   0 runner    (1001) docker     (127)      740 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/solver/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3330 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/solver/ilmcmd.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15771 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/solver/shellcmd.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/testing/
+-rw-r--r--   0 runner    (1001) docker     (127)      614 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/testing/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3764 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/testing/pyunit.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      562 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/tests/base/
+-rw-r--r--   0 runner    (1001) docker     (127)      567 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11857 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_ampl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6992 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4307 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6027 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_sol.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9106 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_soln.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4454 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/base/test_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/opt/tests/solver/
+-rw-r--r--   0 runner    (1001) docker     (127)      574 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/solver/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13258 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/opt/tests/solver/test_shellcmd.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.539275 Pyomo-6.7.2/pyomo/pysp/
+-rw-r--r--   0 runner    (1001) docker     (127)     1554 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/pysp/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.543275 Pyomo-6.7.2/pyomo/repn/
+-rw-r--r--   0 runner    (1001) docker     (127)      673 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.543275 Pyomo-6.7.2/pyomo/repn/beta/
+-rw-r--r--   0 runner    (1001) docker     (127)      571 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/beta/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24869 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/beta/matrix.py
+-rw-r--r--   0 runner    (1001) docker     (127)    27999 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/linear.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.543275 Pyomo-6.7.2/pyomo/repn/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)     1650 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.543275 Pyomo-6.7.2/pyomo/repn/plugins/ampl/
+-rw-r--r--   0 runner    (1001) docker     (127)      600 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/ampl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    79843 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/ampl/ampl_.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32156 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/baron_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39682 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/cpxlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40619 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/gams_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23702 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/lp_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32960 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/mps.py
+-rw-r--r--   0 runner    (1001) docker     (127)   120531 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/nl_writer.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21877 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/plugins/standard_form.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10560 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/quadratic.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1450 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/standard_aux.py
+-rw-r--r--   0 runner    (1001) docker     (127)    60059 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/standard_repn.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.543275 Pyomo-6.7.2/pyomo/repn/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      569 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.547275 Pyomo-6.7.2/pyomo/repn/tests/ampl/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      801 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/helper.py
+-rw-r--r--   0 runner    (1001) docker     (127)      677 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/nl_diff.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3286 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small10_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1522 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small11_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4916 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small12_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1200 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small13_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2075 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small14_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1155 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small15_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1050 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small1_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1047 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small2_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1057 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small3_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1058 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small4_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2516 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small5_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1974 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small6_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4029 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small7_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1729 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small8_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1880 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/small9_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5596 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_comparison.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15142 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_nl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1473 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_repn.py
+-rw-r--r--   0 runner    (1001) docker     (127)    73520 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/test_nlv2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8196 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/ampl/test_suffixes.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.547275 Pyomo-6.7.2/pyomo/repn/tests/baron/
+-rw-r--r--   0 runner    (1001) docker     (127)      571 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/baron/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1128 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/baron/small14a_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11418 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/baron/test_baron.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3184 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/baron/test_baron_comparison.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/repn/tests/cpxlp/
+-rw-r--r--   0 runner    (1001) docker     (127)      571 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/cpxlp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14579 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/cpxlp/test_cpxlp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3880 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/cpxlp/test_lpv2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1744 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/diffutils.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/repn/tests/gams/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/gams/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2047 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/gams/small14a_testCase.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16996 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/gams/test_gams.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3800 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/gams/test_gams_comparison.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2365 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/lp_diff.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/repn/tests/mps/
+-rw-r--r--   0 runner    (1001) docker     (127)      569 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/mps/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8094 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/mps/test_mps.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4666 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/nl_diff.py
+-rw-r--r--   0 runner    (1001) docker     (127)    63527 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/test_linear.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15522 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/test_quadratic.py
+-rw-r--r--   0 runner    (1001) docker     (127)   163906 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/test_standard.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11405 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/test_standard_form.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32092 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/tests/test_util.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26171 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/repn/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/scripting/
+-rw-r--r--   0 runner    (1001) docker     (127)      606 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1491 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/commands.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7228 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17713 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/driver_help.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3325 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/interface.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/scripting/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      769 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3156 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/build_ext.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9209 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3422 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/download.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4131 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/extras.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8410 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/plugins/solve.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4274 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/pyomo_command.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3405 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/pyomo_main.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3806 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/pyomo_parser.py
+-rw-r--r--   0 runner    (1001) docker     (127)    15111 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/solve_config.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.551275 Pyomo-6.7.2/pyomo/scripting/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      580 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3350 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/tests/test_cmds.py
+-rw-r--r--   0 runner    (1001) docker     (127)    42654 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/scripting/util.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.555276 Pyomo-6.7.2/pyomo/solvers/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1544 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/amplfunc_merge.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2178 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/mockmip.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.555276 Pyomo-6.7.2/pyomo/solvers/plugins/
+-rw-r--r--   0 runner    (1001) docker     (127)      638 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.555276 Pyomo-6.7.2/pyomo/solvers/plugins/converter/
+-rw-r--r--   0 runner    (1001) docker     (127)      676 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/converter/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3335 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/converter/ampl.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4628 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/converter/glpsol.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10717 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/converter/model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3566 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/converter/pico.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.559275 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/
+-rw-r--r--   0 runner    (1001) docker     (127)     9353 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/ASL.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24289 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/BARON.py
+-rw-r--r--   0 runner    (1001) docker     (127)    50930 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CBCplugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5999 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CONOPT.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46074 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CPLEX.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56796 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GAMS.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21992 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GLPK.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23350 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GUROBI.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13685 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GUROBI_RUN.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7862 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/IPOPT.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19887 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/SCIPAMPL.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1537 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/XPRESS.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1553 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    41460 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/cplex_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6266 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/cplex_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13569 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/direct_or_persistent_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9290 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/direct_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)    46352 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/gurobi_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)    24797 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/gurobi_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    54326 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/mosek_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10604 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/mosek_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    23607 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/persistent_solver.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1488 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/pywrapper.py
+-rw-r--r--   0 runner    (1001) docker     (127)    43929 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/xpress_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8105 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/plugins/solvers/xpress_persistent.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.559275 Pyomo-6.7.2/pyomo/solvers/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      566 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.563276 Pyomo-6.7.2/pyomo/solvers/tests/checks/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3401 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_BARON.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18940 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CBCplugin.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21968 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CPLEXDirect.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4116 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CPLEXPersistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)    19199 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_GAMS.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11273 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_MOSEKDirect.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6415 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_MOSEKPersistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6441 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_amplfunc_merge.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5285 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_cbc.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13367 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_cplex.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1919 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17227 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi_direct.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14555 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi_persistent.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4248 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_no_solution_behavior.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5756 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_pickle.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6807 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_writers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12380 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/checks/test_xpress_persistent.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.563276 Pyomo-6.7.2/pyomo/solvers/tests/mip/
+-rw-r--r--   0 runner    (1001) docker     (127)      570 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      789 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/model.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4613 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_asl.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12781 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_convert.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5232 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_factory.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8559 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_ipopt.py
+-rw-r--r--   0 runner    (1001) docker     (127)      760 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_mip.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7353 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_qp.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4587 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7333 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip_log_data.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10703 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip_version.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2308 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/mip/test_solver.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.567276 Pyomo-6.7.2/pyomo/solvers/tests/models/
+-rw-r--r--   0 runner    (1001) docker     (127)     2681 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_block.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9374 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_compiled.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1838 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_constant_objective1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1880 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_constant_objective2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4486 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_duals_maximize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4217 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_duals_minimize.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4087 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_inactive_index.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2359 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_infeasible1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2407 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_infeasible2.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1873 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_piecewise.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3741 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5039 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_trivial_constraints.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2315 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unbounded.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2604 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unique_duals.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6896 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unused_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2875 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_discrete_var_bounds.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2913 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_infeasible1.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2240 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2431 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_unbounded.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7226 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_unused_vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2435 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MIQCP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2825 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/MIQP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4403 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/QCP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2054 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/QP_constant_objective.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3628 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/QP_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2919 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/SOS1_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4439 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/SOS2_simple.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1995 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18504 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/models/base.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.567276 Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/
+-rw-r--r--   0 runner    (1001) docker     (127)      582 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4432 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_examples.py
+-rw-r--r--   0 runner    (1001) docker     (127)     7512 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6080 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear_kernel.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12977 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/solvers.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17619 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/tests/testcases.py
+-rw-r--r--   0 runner    (1001) docker     (127)      636 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/solvers/wrappers.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.571276 Pyomo-6.7.2/pyomo/util/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1381 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/blockutil.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12568 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/calc_var_value.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9972 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/check_units.py
+-rw-r--r--   0 runner    (1001) docker     (127)     4353 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/components.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1311 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/diagnostics.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11712 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/infeasible.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6947 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/model_size.py
+-rw-r--r--   0 runner    (1001) docker     (127)     6985 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/report_scaling.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10599 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/slices.py
+-rw-r--r--   0 runner    (1001) docker     (127)    14322 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/subsystems.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.571276 Pyomo-6.7.2/pyomo/util/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      540 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2510 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_blockutil.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17771 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_calc_var_value.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12096 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_check_units.py
+-rw-r--r--   0 runner    (1001) docker     (127)     5047 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_components.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8005 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_infeasible.py
+-rw-r--r--   0 runner    (1001) docker     (127)     8635 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_model_size.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2895 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_report_scaling.py
+-rw-r--r--   0 runner    (1001) docker     (127)    28108 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_slices.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30544 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/tests/test_subsystems.py
+-rw-r--r--   0 runner    (1001) docker     (127)     2288 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/util/vars_from_expressions.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.571276 Pyomo-6.7.2/pyomo/version/
+-rw-r--r--   0 runner    (1001) docker     (127)      940 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/version/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3167 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/version/info.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-09 15:34:26.571276 Pyomo-6.7.2/pyomo/version/tests/
+-rw-r--r--   0 runner    (1001) docker     (127)      542 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/version/tests/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)      727 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/version/tests/check.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1688 2024-05-09 15:34:13.000000 Pyomo-6.7.2/pyomo/version/tests/test_version.py
+-rw-r--r--   0 runner    (1001) docker     (127)      815 2024-05-09 15:34:26.571276 Pyomo-6.7.2/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (127)    13138 2024-05-09 15:34:13.000000 Pyomo-6.7.2/setup.py
```

### Comparing `Pyomo-6.7.1/LICENSE.md` & `Pyomo-6.7.2/LICENSE.md`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/PKG-INFO` & `Pyomo-6.7.2/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: Pyomo
-Version: 6.7.1
+Version: 6.7.2
 Summary: Pyomo: Python Optimization Modeling Objects
 Home-page: http://pyomo.org
 Maintainer: Pyomo Developer Team
 Maintainer-email: pyomo-developers@googlegroups.com
 License: BSD
 Project-URL: Documentation, https://pyomo.readthedocs.io/
 Project-URL: Source, https://github.com/Pyomo/pyomo
@@ -69,16 +69,19 @@
         
         #### Anaconda [![Anaconda version](https://anaconda.org/conda-forge/pyomo/badges/version.svg)](https://anaconda.org/conda-forge/pyomo) [![Anaconda downloads](https://anaconda.org/conda-forge/pyomo/badges/downloads.svg)](https://anaconda.org/conda-forge/pyomo)
         
             conda install -c conda-forge pyomo
         
         ### Tutorials and Examples
         
+        * [Pyomo — Optimization Modeling in Python](https://link.springer.com/book/10.1007/978-3-030-68928-5)
         * [Pyomo Workshop Slides](https://github.com/Pyomo/pyomo-tutorials/blob/main/Pyomo-Workshop-December-2023.pdf)
         * [Prof. Jeffrey Kantor's Pyomo Cookbook](https://jckantor.github.io/ND-Pyomo-Cookbook/)
+        * The [companion notebooks](https://mobook.github.io/MO-book/intro.html)
+          for *Hands-On Mathematical Optimization with Python*
         * [Pyomo Gallery](https://github.com/Pyomo/PyomoGallery)
         
         ### Getting Help
         
         To get help from the Pyomo community ask a question on one of the following:
         * [Use the #pyomo tag on StackOverflow](https://stackoverflow.com/questions/ask?tags=pyomo)
         * [Pyomo Forum](https://groups.google.com/forum/?hl=en#!forum/pyomo-forum)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `Pyomo-6.7.1/Pyomo.egg-info/PKG-INFO` & `Pyomo-6.7.2/Pyomo.egg-info/PKG-INFO`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: Pyomo
-Version: 6.7.1
+Version: 6.7.2
 Summary: Pyomo: Python Optimization Modeling Objects
 Home-page: http://pyomo.org
 Maintainer: Pyomo Developer Team
 Maintainer-email: pyomo-developers@googlegroups.com
 License: BSD
 Project-URL: Documentation, https://pyomo.readthedocs.io/
 Project-URL: Source, https://github.com/Pyomo/pyomo
@@ -69,16 +69,19 @@
         
         #### Anaconda [![Anaconda version](https://anaconda.org/conda-forge/pyomo/badges/version.svg)](https://anaconda.org/conda-forge/pyomo) [![Anaconda downloads](https://anaconda.org/conda-forge/pyomo/badges/downloads.svg)](https://anaconda.org/conda-forge/pyomo)
         
             conda install -c conda-forge pyomo
         
         ### Tutorials and Examples
         
+        * [Pyomo — Optimization Modeling in Python](https://link.springer.com/book/10.1007/978-3-030-68928-5)
         * [Pyomo Workshop Slides](https://github.com/Pyomo/pyomo-tutorials/blob/main/Pyomo-Workshop-December-2023.pdf)
         * [Prof. Jeffrey Kantor's Pyomo Cookbook](https://jckantor.github.io/ND-Pyomo-Cookbook/)
+        * The [companion notebooks](https://mobook.github.io/MO-book/intro.html)
+          for *Hands-On Mathematical Optimization with Python*
         * [Pyomo Gallery](https://github.com/Pyomo/PyomoGallery)
         
         ### Getting Help
         
         To get help from the Pyomo community ask a question on one of the following:
         * [Use the #pyomo tag on StackOverflow](https://stackoverflow.com/questions/ask?tags=pyomo)
         * [Pyomo Forum](https://groups.google.com/forum/?hl=en#!forum/pyomo-forum)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `Pyomo-6.7.1/Pyomo.egg-info/SOURCES.txt` & `Pyomo-6.7.2/Pyomo.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -17,14 +17,15 @@
 pyomo/common/autoslots.py
 pyomo/common/backports.py
 pyomo/common/cmake_builder.py
 pyomo/common/config.py
 pyomo/common/dependencies.py
 pyomo/common/deprecation.py
 pyomo/common/download.py
+pyomo/common/enums.py
 pyomo/common/env.py
 pyomo/common/envvar.py
 pyomo/common/errors.py
 pyomo/common/extensions.py
 pyomo/common/factory.py
 pyomo/common/fileutils.py
 pyomo/common/formatting.py
@@ -61,22 +62,24 @@
 pyomo/common/tests/relocated.py
 pyomo/common/tests/test_bunch.py
 pyomo/common/tests/test_component_map.py
 pyomo/common/tests/test_config.py
 pyomo/common/tests/test_dependencies.py
 pyomo/common/tests/test_deprecated.py
 pyomo/common/tests/test_download.py
+pyomo/common/tests/test_enums.py
 pyomo/common/tests/test_env.py
 pyomo/common/tests/test_errors.py
 pyomo/common/tests/test_fileutils.py
 pyomo/common/tests/test_formatting.py
 pyomo/common/tests/test_gc.py
 pyomo/common/tests/test_log.py
 pyomo/common/tests/test_modeling.py
 pyomo/common/tests/test_multithread.py
+pyomo/common/tests/test_numeric_types.py
 pyomo/common/tests/test_orderedset.py
 pyomo/common/tests/test_plugin.py
 pyomo/common/tests/test_sorting.py
 pyomo/common/tests/test_tee.py
 pyomo/common/tests/test_tempfile.py
 pyomo/common/tests/test_timing.py
 pyomo/common/tests/test_typing.py
@@ -119,14 +122,16 @@
 pyomo/contrib/appsi/examples/tests/test_examples.py
 pyomo/contrib/appsi/solvers/__init__.py
 pyomo/contrib/appsi/solvers/cbc.py
 pyomo/contrib/appsi/solvers/cplex.py
 pyomo/contrib/appsi/solvers/gurobi.py
 pyomo/contrib/appsi/solvers/highs.py
 pyomo/contrib/appsi/solvers/ipopt.py
+pyomo/contrib/appsi/solvers/maingo.py
+pyomo/contrib/appsi/solvers/maingo_solvermodel.py
 pyomo/contrib/appsi/solvers/wntr.py
 pyomo/contrib/appsi/solvers/tests/__init__.py
 pyomo/contrib/appsi/solvers/tests/test_gurobi_persistent.py
 pyomo/contrib/appsi/solvers/tests/test_highs_persistent.py
 pyomo/contrib/appsi/solvers/tests/test_ipopt_persistent.py
 pyomo/contrib/appsi/solvers/tests/test_persistent_solvers.py
 pyomo/contrib/appsi/solvers/tests/test_wntr_persistent.py
@@ -158,25 +163,30 @@
 pyomo/contrib/community_detection/event_log.py
 pyomo/contrib/community_detection/plugins.py
 pyomo/contrib/community_detection/tests/__init__.py
 pyomo/contrib/community_detection/tests/test_detection.py
 pyomo/contrib/cp/__init__.py
 pyomo/contrib/cp/interval_var.py
 pyomo/contrib/cp/plugins.py
+pyomo/contrib/cp/sequence_var.py
 pyomo/contrib/cp/repn/__init__.py
 pyomo/contrib/cp/repn/docplex_writer.py
 pyomo/contrib/cp/scheduling_expr/__init__.py
 pyomo/contrib/cp/scheduling_expr/precedence_expressions.py
+pyomo/contrib/cp/scheduling_expr/scheduling_logic.py
+pyomo/contrib/cp/scheduling_expr/sequence_expressions.py
 pyomo/contrib/cp/scheduling_expr/step_function_expressions.py
 pyomo/contrib/cp/tests/__init__.py
 pyomo/contrib/cp/tests/test_docplex_walker.py
 pyomo/contrib/cp/tests/test_docplex_writer.py
 pyomo/contrib/cp/tests/test_interval_var.py
 pyomo/contrib/cp/tests/test_logical_to_disjunctive.py
 pyomo/contrib/cp/tests/test_precedence_constraints.py
+pyomo/contrib/cp/tests/test_sequence_expressions.py
+pyomo/contrib/cp/tests/test_sequence_var.py
 pyomo/contrib/cp/tests/test_step_function_expressions.py
 pyomo/contrib/cp/transform/__init__.py
 pyomo/contrib/cp/transform/logical_to_disjunctive_program.py
 pyomo/contrib/cp/transform/logical_to_disjunctive_walker.py
 pyomo/contrib/doe/__init__.py
 pyomo/contrib/doe/doe.py
 pyomo/contrib/doe/measurements.py
@@ -242,39 +252,44 @@
 pyomo/contrib/gdpopt/tests/test_gdpopt.py
 pyomo/contrib/gjh/GJH.py
 pyomo/contrib/gjh/__init__.py
 pyomo/contrib/gjh/getGJH.py
 pyomo/contrib/gjh/plugins.py
 pyomo/contrib/iis/__init__.py
 pyomo/contrib/iis/iis.py
+pyomo/contrib/iis/mis.py
 pyomo/contrib/iis/tests/__init__.py
 pyomo/contrib/iis/tests/test_iis.py
+pyomo/contrib/iis/tests/test_mis.py
+pyomo/contrib/iis/tests/trivial_mis.py
 pyomo/contrib/incidence_analysis/__init__.py
 pyomo/contrib/incidence_analysis/config.py
 pyomo/contrib/incidence_analysis/connected.py
 pyomo/contrib/incidence_analysis/dulmage_mendelsohn.py
 pyomo/contrib/incidence_analysis/incidence.py
 pyomo/contrib/incidence_analysis/interface.py
 pyomo/contrib/incidence_analysis/matching.py
 pyomo/contrib/incidence_analysis/scc_solver.py
 pyomo/contrib/incidence_analysis/triangularize.py
 pyomo/contrib/incidence_analysis/util.py
+pyomo/contrib/incidence_analysis/visualize.py
 pyomo/contrib/incidence_analysis/common/__init__.py
 pyomo/contrib/incidence_analysis/common/dulmage_mendelsohn.py
 pyomo/contrib/incidence_analysis/common/tests/__init__.py
 pyomo/contrib/incidence_analysis/common/tests/test_dulmage_mendelsohn.py
 pyomo/contrib/incidence_analysis/tests/__init__.py
 pyomo/contrib/incidence_analysis/tests/models_for_testing.py
 pyomo/contrib/incidence_analysis/tests/test_connected.py
 pyomo/contrib/incidence_analysis/tests/test_dulmage_mendelsohn.py
 pyomo/contrib/incidence_analysis/tests/test_incidence.py
 pyomo/contrib/incidence_analysis/tests/test_interface.py
 pyomo/contrib/incidence_analysis/tests/test_matching.py
 pyomo/contrib/incidence_analysis/tests/test_scc_solver.py
 pyomo/contrib/incidence_analysis/tests/test_triangularize.py
+pyomo/contrib/incidence_analysis/tests/test_visualize.py
 pyomo/contrib/interior_point/__init__.py
 pyomo/contrib/interior_point/interface.py
 pyomo/contrib/interior_point/interior_point.py
 pyomo/contrib/interior_point/inverse_reduced_hessian.py
 pyomo/contrib/interior_point/examples/__init__.py
 pyomo/contrib/interior_point/examples/ex1.py
 pyomo/contrib/interior_point/linalg/__init__.py
@@ -385,23 +400,25 @@
 pyomo/contrib/multistart/__init__.py
 pyomo/contrib/multistart/high_conf_stop.py
 pyomo/contrib/multistart/multi.py
 pyomo/contrib/multistart/plugins.py
 pyomo/contrib/multistart/reinit.py
 pyomo/contrib/multistart/test_multi.py
 pyomo/contrib/parmest/__init__.py
+pyomo/contrib/parmest/experiment.py
 pyomo/contrib/parmest/graphics.py
 pyomo/contrib/parmest/ipopt_solver_wrapper.py
 pyomo/contrib/parmest/parmest.py
 pyomo/contrib/parmest/scenariocreator.py
 pyomo/contrib/parmest/examples/__init__.py
 pyomo/contrib/parmest/examples/reaction_kinetics/__init__.py
 pyomo/contrib/parmest/examples/reaction_kinetics/simple_reaction_parmest_example.py
 pyomo/contrib/parmest/examples/reactor_design/__init__.py
 pyomo/contrib/parmest/examples/reactor_design/bootstrap_example.py
+pyomo/contrib/parmest/examples/reactor_design/confidence_region_example.py
 pyomo/contrib/parmest/examples/reactor_design/datarec_example.py
 pyomo/contrib/parmest/examples/reactor_design/leaveNout_example.py
 pyomo/contrib/parmest/examples/reactor_design/likelihood_ratio_example.py
 pyomo/contrib/parmest/examples/reactor_design/multisensor_data_example.py
 pyomo/contrib/parmest/examples/reactor_design/parameter_estimation_example.py
 pyomo/contrib/parmest/examples/reactor_design/reactor_design.py
 pyomo/contrib/parmest/examples/reactor_design/timeseries_data_example.py
@@ -429,27 +446,32 @@
 pyomo/contrib/parmest/utils/model_utils.py
 pyomo/contrib/parmest/utils/mpi_utils.py
 pyomo/contrib/parmest/utils/scenario_tree.py
 pyomo/contrib/piecewise/__init__.py
 pyomo/contrib/piecewise/piecewise_linear_expression.py
 pyomo/contrib/piecewise/piecewise_linear_function.py
 pyomo/contrib/piecewise/tests/__init__.py
+pyomo/contrib/piecewise/tests/common_inner_repn_tests.py
 pyomo/contrib/piecewise/tests/common_tests.py
 pyomo/contrib/piecewise/tests/models.py
+pyomo/contrib/piecewise/tests/test_disaggregated_logarithmic.py
 pyomo/contrib/piecewise/tests/test_inner_repn_gdp.py
+pyomo/contrib/piecewise/tests/test_nested_inner_repn_gdp.py
 pyomo/contrib/piecewise/tests/test_outer_repn_gdp.py
 pyomo/contrib/piecewise/tests/test_piecewise_linear_function.py
 pyomo/contrib/piecewise/tests/test_reduced_inner_repn.py
 pyomo/contrib/piecewise/transform/__init__.py
 pyomo/contrib/piecewise/transform/convex_combination.py
 pyomo/contrib/piecewise/transform/disaggregated_convex_combination.py
+pyomo/contrib/piecewise/transform/disaggregated_logarithmic.py
 pyomo/contrib/piecewise/transform/inner_representation_gdp.py
 pyomo/contrib/piecewise/transform/multiple_choice.py
+pyomo/contrib/piecewise/transform/nested_inner_repn.py
 pyomo/contrib/piecewise/transform/outer_representation_gdp.py
-pyomo/contrib/piecewise/transform/piecewise_to_gdp_transformation.py
+pyomo/contrib/piecewise/transform/piecewise_linear_transformation_base.py
 pyomo/contrib/piecewise/transform/piecewise_to_mip_visitor.py
 pyomo/contrib/piecewise/transform/reduced_inner_representation_gdp.py
 pyomo/contrib/preprocessing/__init__.py
 pyomo/contrib/preprocessing/util.py
 pyomo/contrib/preprocessing/plugins/__init__.py
 pyomo/contrib/preprocessing/plugins/bounds_to_vars.py
 pyomo/contrib/preprocessing/plugins/constraint_tightener.py
@@ -609,19 +631,29 @@
 pyomo/contrib/sensitivity_toolbox/examples/rangeInequality.py
 pyomo/contrib/sensitivity_toolbox/examples/rooney_biegler.py
 pyomo/contrib/sensitivity_toolbox/tests/__init__.py
 pyomo/contrib/sensitivity_toolbox/tests/test_k_aug_interface.py
 pyomo/contrib/sensitivity_toolbox/tests/test_sens.py
 pyomo/contrib/sensitivity_toolbox/tests/test_sens_unit.py
 pyomo/contrib/simplemodel/__init__.py
+pyomo/contrib/simplification/__init__.py
+pyomo/contrib/simplification/build.py
+pyomo/contrib/simplification/plugins.py
+pyomo/contrib/simplification/simplify.py
+pyomo/contrib/simplification/ginac/__init__.py
+pyomo/contrib/simplification/ginac/src/ginac_interface.cpp
+pyomo/contrib/simplification/ginac/src/ginac_interface.hpp
+pyomo/contrib/simplification/tests/__init__.py
+pyomo/contrib/simplification/tests/test_simplification.py
 pyomo/contrib/solver/__init__.py
 pyomo/contrib/solver/base.py
 pyomo/contrib/solver/config.py
 pyomo/contrib/solver/factory.py
 pyomo/contrib/solver/gurobi.py
+pyomo/contrib/solver/gurobi_direct.py
 pyomo/contrib/solver/ipopt.py
 pyomo/contrib/solver/persistent.py
 pyomo/contrib/solver/plugins.py
 pyomo/contrib/solver/results.py
 pyomo/contrib/solver/sol_reader.py
 pyomo/contrib/solver/solution.py
 pyomo/contrib/solver/util.py
@@ -796,14 +828,15 @@
 pyomo/core/tests/diet/__init__.py
 pyomo/core/tests/diet/test_diet.py
 pyomo/core/tests/examples/__init__.py
 pyomo/core/tests/examples/pmedian.py
 pyomo/core/tests/examples/pmedian1.py
 pyomo/core/tests/examples/pmedian2.py
 pyomo/core/tests/examples/pmedian4.py
+pyomo/core/tests/examples/pmedian_concrete.py
 pyomo/core/tests/examples/test_amplbook2.py
 pyomo/core/tests/examples/test_kernel_examples.py
 pyomo/core/tests/examples/test_pyomo.py
 pyomo/core/tests/examples/test_tutorials.py
 pyomo/core/tests/transform/__init__.py
 pyomo/core/tests/transform/test_add_slacks.py
 pyomo/core/tests/transform/test_scaling.py
@@ -1137,14 +1170,15 @@
 pyomo/scripting/plugins/convert.py
 pyomo/scripting/plugins/download.py
 pyomo/scripting/plugins/extras.py
 pyomo/scripting/plugins/solve.py
 pyomo/scripting/tests/__init__.py
 pyomo/scripting/tests/test_cmds.py
 pyomo/solvers/__init__.py
+pyomo/solvers/amplfunc_merge.py
 pyomo/solvers/mockmip.py
 pyomo/solvers/wrappers.py
 pyomo/solvers/plugins/__init__.py
 pyomo/solvers/plugins/converter/__init__.py
 pyomo/solvers/plugins/converter/ampl.py
 pyomo/solvers/plugins/converter/glpsol.py
 pyomo/solvers/plugins/converter/model.py
@@ -1181,14 +1215,15 @@
 pyomo/solvers/tests/checks/test_BARON.py
 pyomo/solvers/tests/checks/test_CBCplugin.py
 pyomo/solvers/tests/checks/test_CPLEXDirect.py
 pyomo/solvers/tests/checks/test_CPLEXPersistent.py
 pyomo/solvers/tests/checks/test_GAMS.py
 pyomo/solvers/tests/checks/test_MOSEKDirect.py
 pyomo/solvers/tests/checks/test_MOSEKPersistent.py
+pyomo/solvers/tests/checks/test_amplfunc_merge.py
 pyomo/solvers/tests/checks/test_cbc.py
 pyomo/solvers/tests/checks/test_cplex.py
 pyomo/solvers/tests/checks/test_gurobi.py
 pyomo/solvers/tests/checks/test_gurobi_direct.py
 pyomo/solvers/tests/checks/test_gurobi_persistent.py
 pyomo/solvers/tests/checks/test_no_solution_behavior.py
 pyomo/solvers/tests/checks/test_pickle.py
```

### Comparing `Pyomo-6.7.1/Pyomo.egg-info/requires.txt` & `Pyomo-6.7.2/Pyomo.egg-info/requires.txt`

 * *Files 3% similar despite different names*

```diff
@@ -5,22 +5,22 @@
 sphinx-copybutton
 sphinx_rtd_theme>0.5
 sphinxcontrib-jsmath
 sphinxcontrib-napoleon
 sphinx-toolbox>=2.16.0
 sphinx-jinja2-compat>=0.1.1
 enum_tools
-numpy
+numpy<2.0.0
 scipy
 
 [optional]
 dill
 ipython
 matplotlib!=3.6.1
-numpy
+numpy<2.0.0
 openpyxl
 pint
 plotly
 python-louvain
 pyyaml
 qtconsole
 scipy
```

### Comparing `Pyomo-6.7.1/README.md` & `Pyomo-6.7.2/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -67,16 +67,19 @@
 
 #### Anaconda [![Anaconda version](https://anaconda.org/conda-forge/pyomo/badges/version.svg)](https://anaconda.org/conda-forge/pyomo) [![Anaconda downloads](https://anaconda.org/conda-forge/pyomo/badges/downloads.svg)](https://anaconda.org/conda-forge/pyomo)
 
     conda install -c conda-forge pyomo
 
 ### Tutorials and Examples
 
+* [Pyomo — Optimization Modeling in Python](https://link.springer.com/book/10.1007/978-3-030-68928-5)
 * [Pyomo Workshop Slides](https://github.com/Pyomo/pyomo-tutorials/blob/main/Pyomo-Workshop-December-2023.pdf)
 * [Prof. Jeffrey Kantor's Pyomo Cookbook](https://jckantor.github.io/ND-Pyomo-Cookbook/)
+* The [companion notebooks](https://mobook.github.io/MO-book/intro.html)
+  for *Hands-On Mathematical Optimization with Python*
 * [Pyomo Gallery](https://github.com/Pyomo/PyomoGallery)
 
 ### Getting Help
 
 To get help from the Pyomo community ask a question on one of the following:
 * [Use the #pyomo tag on StackOverflow](https://stackoverflow.com/questions/ask?tags=pyomo)
 * [Pyomo Forum](https://groups.google.com/forum/?hl=en#!forum/pyomo-forum)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `Pyomo-6.7.1/pyomo/__future__.py` & `Pyomo-6.7.2/pyomo/__future__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/__init__.py` & `Pyomo-6.7.2/pyomo/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/__init__.py` & `Pyomo-6.7.2/pyomo/common/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/_command.py` & `Pyomo-6.7.2/pyomo/common/_command.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/_common.py` & `Pyomo-6.7.2/pyomo/common/_common.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/autoslots.py` & `Pyomo-6.7.2/pyomo/common/autoslots.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/backports.py` & `Pyomo-6.7.2/pyomo/common/backports.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/cmake_builder.py` & `Pyomo-6.7.2/pyomo/common/cmake_builder.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/collections/__init__.py` & `Pyomo-6.7.2/pyomo/common/collections/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/collections/bunch.py` & `Pyomo-6.7.2/pyomo/common/collections/bunch.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/collections/component_map.py` & `Pyomo-6.7.2/pyomo/common/collections/component_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/collections/component_set.py` & `Pyomo-6.7.2/pyomo/common/collections/component_set.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/collections/orderedset.py` & `Pyomo-6.7.2/pyomo/common/collections/orderedset.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/config.py` & `Pyomo-6.7.2/pyomo/common/config.py`

 * *Files 0% similar despite different names*

```diff
@@ -1130,15 +1130,19 @@
     return re.sub(r'[^a-zA-Z0-9-_]', '_', name)
 
 
 def _domain_name(domain):
     if domain is None:
         return ""
     elif hasattr(domain, 'domain_name'):
-        return domain.domain_name()
+        dn = domain.domain_name
+        if hasattr(dn, '__call__'):
+            return dn()
+        else:
+            return dn
     elif domain.__class__ is type:
         return domain.__name__
     elif inspect.isfunction(domain):
         return domain.__name__
     else:
         return None
```

### Comparing `Pyomo-6.7.1/pyomo/common/dependencies.py` & `Pyomo-6.7.2/pyomo/common/dependencies.py`

 * *Files 10% similar despite different names*

```diff
@@ -5,21 +5,24 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from collections.abc import Mapping
 import inspect
 import importlib
 import logging
 import sys
 import warnings
 
+from collections.abc import Mapping
+from types import ModuleType
+from typing import List
+
 from .deprecation import deprecated, deprecation_warning, in_testing_environment
 from .errors import DeferredImportError
 
 
 SUPPRESS_DEPENDENCY_WARNINGS = False
 
 
@@ -123,15 +126,15 @@
 
 
 class DeferredImportModule(object):
     """Mock module object to support the deferred import of a module.
 
     This object is returned by :py:func:`attempt_import()` in lieu of
     the module when :py:func:`attempt_import()` is called with
-    ``defer_check=True``.  Any attempts to access attributes on this
+    ``defer_import=True``.  Any attempts to access attributes on this
     object will trigger the actual module import and return either the
     appropriate module attribute or else if the module import fails,
     raise a :py:class:`.DeferredImportError` exception.
 
     """
 
     def __init__(self, indicator, deferred_submodules, submodule_name):
@@ -308,14 +311,20 @@
         self._minimum_version = minimum_version
         self._original_globals = original_globals
         self._callback = callback
         self._importer = importer
         self._module = None
         self._available = None
         self._deferred_submodules = deferred_submodules
+        # If this import has a callback, then record this deferred
+        # import so that any direct imports of this module also trigger
+        # the resolution of this DeferredImportIndicator (and the
+        # corresponding callback)
+        if callback is not None:
+            DeferredImportCallbackFinder._callbacks.setdefault(name, []).append(self)
 
     def __bool__(self):
         self.resolve()
         return self._available
 
     def resolve(self):
         # Only attempt the import once, then cache some form of result
@@ -429,23 +438,101 @@
     version = getattr(module, '__version__', '0.0.0')
     return _parser(min_version) <= _parser(version)
 
 
 check_min_version._parser = None
 
 
+#
+# Note that we are duck-typing the Loader and MetaPathFinder base
+# classes from importlib.abc.  This avoids a (surprisingly costly)
+# import of importlib.abc
+#
+class DeferredImportCallbackLoader:
+    """Custom Loader to resolve registered :py:class:`DeferredImportIndicator` objects
+
+    This :py:class:`importlib.abc.Loader` loader wraps a regular loader
+    and automatically resolves the registered
+    :py:class:`DeferredImportIndicator` objects after the module is
+    loaded.
+
+    """
+
+    def __init__(self, loader, deferred_indicators: List[DeferredImportIndicator]):
+        self._loader = loader
+        self._deferred_indicators = deferred_indicators
+
+    def module_repr(self, module: ModuleType) -> str:
+        return self._loader.module_repr(module)
+
+    def create_module(self, spec) -> ModuleType:
+        return self._loader.create_module(spec)
+
+    def exec_module(self, module: ModuleType) -> None:
+        self._loader.exec_module(module)
+        # Now that the module has been loaded, trigger the resolution of
+        # the deferred indicators (and their associated callbacks)
+        for deferred in self._deferred_indicators:
+            deferred.resolve()
+
+    def load_module(self, fullname) -> ModuleType:
+        return self._loader.load_module(fullname)
+
+
+class DeferredImportCallbackFinder:
+    """Custom Finder that will wrap the normal loader to trigger callbacks
+
+    This :py:class:`importlib.abc.MetaPathFinder` finder will wrap the
+    normal loader returned by ``PathFinder`` with a loader that will
+    trigger custom callbacks after the module is loaded.  We use this to
+    trigger the post import callbacks registered through
+    :py:func:`attempt_import` even when a user imports the target library
+    directly (and not through attribute access on the
+    :py:class:`DeferredImportModule`.
+
+    """
+
+    _callbacks = {}
+
+    def find_spec(self, fullname, path, target=None):
+        if fullname not in self._callbacks:
+            return None
+
+        spec = importlib.machinery.PathFinder.find_spec(fullname, path, target)
+        if spec is None:
+            # Module not found.  Returning None will proceed to the next
+            # finder (which is likely to raise a ModuleNotFoundError)
+            return None
+        spec.loader = DeferredImportCallbackLoader(
+            spec.loader, self._callbacks[fullname]
+        )
+        return spec
+
+    def invalidate_caches(self):
+        pass
+
+
+_DeferredImportCallbackFinder = DeferredImportCallbackFinder()
+# Insert the DeferredImportCallbackFinder at the beginning of the
+# sys.meta_path so that it is found before the standard finders (so that
+# we can correctly inject the resolution of the DeferredImportIndicators
+# -- which triggers the needed callbacks)
+sys.meta_path.insert(0, _DeferredImportCallbackFinder)
+
+
 def attempt_import(
     name,
     error_message=None,
     only_catch_importerror=None,
     minimum_version=None,
     alt_names=None,
     callback=None,
     importer=None,
-    defer_check=True,
+    defer_check=None,
+    defer_import=None,
     deferred_submodules=None,
     catch_exceptions=None,
 ):
     """Attempt to import the specified module.
 
     This will attempt to import the specified module, returning a
     ``(module, available)`` tuple.  If the import was successful, ``module``
@@ -491,45 +578,53 @@
     name: str
         The name of the module to import
 
     error_message: str, optional
         The message for the exception raised by :py:class:`ModuleUnavailable`
 
     only_catch_importerror: bool, optional
-        DEPRECATED: use catch_exceptions instead or only_catch_importerror.
+        DEPRECATED: use ``catch_exceptions`` instead of ``only_catch_importerror``.
+
         If True (the default), exceptions other than ``ImportError`` raised
         during module import will be reraised.  If False, any exception
         will result in returning a :py:class:`ModuleUnavailable` object.
         (deprecated in version 5.7.3)
 
     minimum_version: str, optional
         The minimum acceptable module version (retrieved from
         ``module.__version__``)
 
     alt_names: list, optional
-        DEPRECATED: alt_names no longer needs to be specified and is ignored.
+        DEPRECATED: ``alt_names`` no longer needs to be specified and is ignored.
+
         A list of common alternate names by which to look for this
         module in the ``globals()`` namespaces.  For example, the alt_names
         for NumPy would be ``['np']``.  (deprecated in version 6.0)
 
-    callback: function, optional
-        A function with the signature "``fcn(module, available)``" that
+    callback: Callable[[ModuleType, bool], None], optional
+        A function with the signature ``fcn(module, available)`` that
         will be called after the import is first attempted.
 
     importer: function, optional
         A function that will perform the import and return the imported
         module (or raise an :py:class:`ImportError`).  This is useful
         for cases where there are several equivalent modules and you
         want to import/return the first one that is available.
 
     defer_check: bool, optional
-        If True (the default), then the attempted import is deferred
-        until the first use of either the module or the availability
-        flag.  The method will return instances of :py:class:`DeferredImportModule`
-        and :py:class:`DeferredImportIndicator`.
+        DEPRECATED: renamed to ``defer_import`` (deprecated in version 6.7.2)
+
+    defer_import: bool, optional
+        If True, then the attempted import is deferred until the first
+        use of either the module or the availability flag.  The method
+        will return instances of :py:class:`DeferredImportModule` and
+        :py:class:`DeferredImportIndicator`.  If False, the import will
+        be attempted immediately.  If not set, then the import will be
+        deferred unless the ``name`` is already present in
+        ``sys.modules``.
 
     deferred_submodules: Iterable[str], optional
         If provided, an iterable of submodule names within this module
         that can be accessed without triggering a deferred import of
         this module.  For example, this module uses
         ``deferred_submodules=['pyplot', 'pylab']`` for ``matplotlib``.
 
@@ -572,17 +667,34 @@
         if only_catch_importerror:
             catch_exceptions = (ImportError,)
         else:
             catch_exceptions = (ImportError, Exception)
     if catch_exceptions is None:
         catch_exceptions = (ImportError,)
 
+    if defer_check is not None:
+        deprecation_warning(
+            'defer_check=%s is deprecated.  Please use defer_import' % (defer_check,),
+            version='6.7.2',
+        )
+        assert defer_import is None
+        defer_import = defer_check
+
+    # If the module has already been imported, there is no reason to
+    # further defer things: just import it.
+    if defer_import is None:
+        if name in sys.modules:
+            defer_import = False
+            deferred_submodules = None
+        else:
+            defer_import = True
+
     # If we are going to defer the check until later, return the
     # deferred import module object
-    if defer_check:
+    if defer_import:
         if deferred_submodules:
             if isinstance(deferred_submodules, Mapping):
                 deprecation_warning(
                     'attempt_import(): deferred_submodules takes an iterable '
                     'and not a mapping (the alt_names supplied by the mapping '
                     'are no longer needed and are ignored).',
                     version='6.0',
@@ -617,15 +729,15 @@
             callback=callback,
             importer=importer,
             deferred_submodules=deferred,
         )
         return DeferredImportModule(indicator, deferred, None), indicator
 
     if deferred_submodules:
-        raise ValueError("deferred_submodules is only valid if defer_check==True")
+        raise ValueError("deferred_submodules is only valid if defer_import==True")
 
     return _perform_import(
         name=name,
         error_message=error_message,
         minimum_version=minimum_version,
         callback=callback,
         importer=importer,
@@ -668,14 +780,19 @@
         name, error_message, version_error, import_error, package
     )
     if callback is not None:
         callback(module, False)
     return module, False
 
 
+@deprecated(
+    "``declare_deferred_modules_as_importable()`` is deprecated.  "
+    "Use the :py:class:`declare_modules_as_importable` context manager.",
+    version='6.7.2',
+)
 def declare_deferred_modules_as_importable(globals_dict):
     """Make all :py:class:`DeferredImportModules` in ``globals_dict`` importable
 
     This function will go throughout the specified ``globals_dict``
     dictionary and add any instances of :py:class:`DeferredImportModule`
     that it finds (and any of their deferred submodules) to
     ``sys.modules`` so that the modules can be imported through the
@@ -694,42 +811,110 @@
 
     .. doctest::
 
        >>> scipy, scipy_available = attempt_import(
        ...     'scipy', callback=_finalize_scipy,
        ...     deferred_submodules=['stats', 'sparse', 'spatial', 'integrate'])
        >>> declare_deferred_modules_as_importable(globals())
+       WARNING: DEPRECATED: ...
 
     Which enables users to use:
 
     .. doctest::
 
        >>> import pyomo.common.dependencies.scipy.sparse as spa
 
     If the deferred import has not yet been triggered, then the
     :py:class:`DeferredImportModule` is returned and named ``spa``.
     However, if the import has already been triggered, then ``spa`` will
     either be the ``scipy.sparse`` module, or a
     :py:class:`ModuleUnavailable` instance.
 
     """
-    _global_name = globals_dict['__name__'] + '.'
-    deferred = list(
-        (k, v) for k, v in globals_dict.items() if type(v) is DeferredImportModule
-    )
-    while deferred:
-        name, mod = deferred.pop(0)
-        mod.__path__ = None
-        mod.__spec__ = None
-        sys.modules[_global_name + name] = mod
-        deferred.extend(
-            (name + '.' + k, v)
-            for k, v in mod.__dict__.items()
-            if type(v) is DeferredImportModule
-        )
+    return declare_modules_as_importable(globals_dict).__exit__(None, None, None)
+
+
+class declare_modules_as_importable(object):
+    """Make all :py:class:`ModuleType` and :py:class:`DeferredImportModules`
+    importable through the ``globals_dict`` context.
+
+    This context manager will detect all modules imported into the
+    specified ``globals_dict`` environment (either directly or through
+    :py:func:`attempt_import`) and will make those modules importable
+    from the specified ``globals_dict`` context.  It works by detecting
+    changes in the specified ``globals_dict`` dictionary and adding any new
+    modules or instances of :py:class:`DeferredImportModule` that it
+    finds (and any of their deferred submodules) to ``sys.modules`` so
+    that the modules can be imported through the ``globals_dict``
+    namespace.
+
+    For example, ``pyomo/common/dependencies.py`` declares:
+
+    .. doctest::
+       :hide:
+
+       >>> from pyomo.common.dependencies import (
+       ...     attempt_import, _finalize_scipy, __dict__ as dep_globals,
+       ...     declare_modules_as_importable, )
+       >>> # Sphinx does not provide a proper globals()
+       >>> def globals(): return dep_globals
+
+    .. doctest::
+
+       >>> with declare_modules_as_importable(globals()):
+       ...     scipy, scipy_available = attempt_import(
+       ...        'scipy', callback=_finalize_scipy,
+       ...        deferred_submodules=['stats', 'sparse', 'spatial', 'integrate'])
+
+    Which enables users to use:
+
+    .. doctest::
+
+       >>> import pyomo.common.dependencies.scipy.sparse as spa
+
+    If the deferred import has not yet been triggered, then the
+    :py:class:`DeferredImportModule` is returned and named ``spa``.
+    However, if the import has already been triggered, then ``spa`` will
+    either be the ``scipy.sparse`` module, or a
+    :py:class:`ModuleUnavailable` instance.
+
+    """
+
+    def __init__(self, globals_dict):
+        self.globals_dict = globals_dict
+        self.init_dict = {}
+        self.init_modules = None
+
+    def __enter__(self):
+        self.init_dict.update(self.globals_dict)
+        self.init_modules = set(sys.modules)
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        _global_name = self.globals_dict['__name__'] + '.'
+        deferred = {
+            k: v
+            for k, v in self.globals_dict.items()
+            if k not in self.init_dict
+            and isinstance(v, (ModuleType, DeferredImportModule))
+        }
+        if self.init_modules:
+            for name in set(sys.modules) - self.init_modules:
+                if '.' in name and name.split('.', 1)[0] in deferred:
+                    sys.modules[_global_name + name] = sys.modules[name]
+        while deferred:
+            name, mod = deferred.popitem()
+            sys.modules[_global_name + name] = mod
+            if isinstance(mod, DeferredImportModule):
+                mod.__path__ = None
+                mod.__spec__ = None
+                deferred.update(
+                    (name + '.' + k, v)
+                    for k, v in mod.__dict__.items()
+                    if type(v) is DeferredImportModule
+                )
 
 
 #
 # Common optional dependencies used throughout Pyomo
 #
 
 yaml_load_args = {}
@@ -774,19 +959,26 @@
     # You must switch matplotlib backends *before* importing pyplot.  If
     # we are in the middle of testing, we need to switch the backend to
     # 'Agg', otherwise attempts to generate plots on CI services without
     # terminal windows will fail.
     if in_testing_environment():
         module.use('Agg')
     import matplotlib.pyplot
+    import matplotlib.pylab
+    import matplotlib.backends
 
 
 def _finalize_numpy(np, available):
     if not available:
         return
+    # scipy has a dependence on numpy.testing, and if we don't import it
+    # as part of resolving numpy, then certain deferred scipy imports
+    # fail when run under pytest.
+    import numpy.testing
+
     from . import numeric_types
 
     # Register ndarray as a native type to prevent 1-element ndarrays
     # from accidentally registering ndarray as a native_numeric_type.
     numeric_types.native_types.add(np.ndarray)
     numeric_types.RegisterLogicalType(np.bool_)
     for t in (
@@ -838,45 +1030,46 @@
     # second-level module is imported.  We will arbitrarily choose to
     # check pyutilib.component (as that is the path exercised by the
     # pyomo.common.tempfiles deprecation path)
     importlib.import_module('pyutilib.component')
     return importlib.import_module('pyutilib')
 
 
-# Standard libraries that are slower to import and not strictly required
-# on all platforms / situations.
-ctypes, _ = attempt_import(
-    'ctypes', deferred_submodules=['util'], callback=_finalize_ctypes
-)
-random, _ = attempt_import('random')
+with declare_modules_as_importable(globals()):
+    # Standard libraries that are slower to import and not strictly required
+    # on all platforms / situations.
+    ctypes, _ = attempt_import(
+        'ctypes', deferred_submodules=['util'], callback=_finalize_ctypes
+    )
+    random, _ = attempt_import('random')
 
-# Commonly-used optional dependencies
-dill, dill_available = attempt_import('dill')
-mpi4py, mpi4py_available = attempt_import('mpi4py')
-networkx, networkx_available = attempt_import('networkx')
-numpy, numpy_available = attempt_import('numpy', callback=_finalize_numpy)
-pandas, pandas_available = attempt_import('pandas')
-plotly, plotly_available = attempt_import('plotly')
-pympler, pympler_available = attempt_import('pympler', callback=_finalize_pympler)
-pyutilib, pyutilib_available = attempt_import('pyutilib', importer=_pyutilib_importer)
-scipy, scipy_available = attempt_import(
-    'scipy',
-    callback=_finalize_scipy,
-    deferred_submodules=['stats', 'sparse', 'spatial', 'integrate'],
-)
-yaml, yaml_available = attempt_import('yaml', callback=_finalize_yaml)
+    # Commonly-used optional dependencies
+    dill, dill_available = attempt_import('dill')
+    mpi4py, mpi4py_available = attempt_import('mpi4py')
+    networkx, networkx_available = attempt_import('networkx')
+    numpy, numpy_available = attempt_import('numpy', callback=_finalize_numpy)
+    pandas, pandas_available = attempt_import('pandas')
+    plotly, plotly_available = attempt_import('plotly')
+    pympler, pympler_available = attempt_import('pympler', callback=_finalize_pympler)
+    pyutilib, pyutilib_available = attempt_import(
+        'pyutilib', importer=_pyutilib_importer
+    )
+    scipy, scipy_available = attempt_import(
+        'scipy',
+        callback=_finalize_scipy,
+        deferred_submodules=['stats', 'sparse', 'spatial', 'integrate'],
+    )
+    yaml, yaml_available = attempt_import('yaml', callback=_finalize_yaml)
 
-# Note that matplotlib.pyplot can generate a runtime error on OSX when
-# not installed as a Framework (as is the case in the CI systems)
-matplotlib, matplotlib_available = attempt_import(
-    'matplotlib',
-    callback=_finalize_matplotlib,
-    deferred_submodules=['pyplot', 'pylab'],
-    catch_exceptions=(ImportError, RuntimeError),
-)
+    # Note that matplotlib.pyplot can generate a runtime error on OSX when
+    # not installed as a Framework (as is the case in the CI systems)
+    matplotlib, matplotlib_available = attempt_import(
+        'matplotlib',
+        callback=_finalize_matplotlib,
+        deferred_submodules=['pyplot', 'pylab', 'backends'],
+        catch_exceptions=(ImportError, RuntimeError),
+    )
 
 try:
     import cPickle as pickle
 except ImportError:
     import pickle
-
-declare_deferred_modules_as_importable(globals())
```

### Comparing `Pyomo-6.7.1/pyomo/common/deprecation.py` & `Pyomo-6.7.2/pyomo/common/deprecation.py`

 * *Files 0% similar despite different names*

```diff
@@ -538,15 +538,15 @@
         # still never create an actual instance of renamed, this doesn't
         # affect the API)
         if new_class is not None and new_class not in renamed_bases:
             renamed_bases.append(new_class)
 
         if new_class is None and '__renamed__new_class__' not in classdict:
             if not any(
-                hasattr(base, '__renamed__new_class__')
+                hasattr(mro, '__renamed__new_class__')
                 for mro in itertools.chain.from_iterable(
                     base.__mro__ for base in renamed_bases
                 )
             ):
                 raise TypeError(
                     "Declaring class '%s' using the RenamedClass metaclass, "
                     "but without specifying the __renamed__new_class__ class "
```

### Comparing `Pyomo-6.7.1/pyomo/common/download.py` & `Pyomo-6.7.2/pyomo/common/download.py`

 * *Files 13% similar despite different names*

```diff
@@ -25,14 +25,15 @@
 import pyomo.common
 from pyomo.common.dependencies import attempt_import
 
 request = attempt_import('urllib.request')[0]
 urllib_error = attempt_import('urllib.error')[0]
 ssl = attempt_import('ssl')[0]
 zipfile = attempt_import('zipfile')[0]
+tarfile = attempt_import('tarfile')[0]
 gzip = attempt_import('gzip')[0]
 distro, distro_available = attempt_import('distro')
 
 logger = logging.getLogger('pyomo.common.download')
 
 DownloadFactory = pyomo.common.Factory('library downloaders')
 
@@ -367,15 +368,15 @@
             raise RuntimeError(
                 "Target directory (%s) exists, but is not a directory" % (self._fname,)
             )
         zip_file = zipfile.ZipFile(io.BytesIO(self.retrieve_url(url)))
         # Simple sanity checks
         for info in zip_file.infolist():
             f = info.filename
-            if f[0] in '\\/' or '..' in f:
+            if f[0] in '\\/' or '..' in f or os.path.isabs(f):
                 logger.error(
                     "malformed (potentially insecure) filename (%s) "
                     "found in zip archive.  Skipping file." % (f,)
                 )
                 continue
             target = self._splitpath(f)
             if len(target) <= dirOffset:
@@ -383,14 +384,69 @@
                     logger.warning(
                         "Skipping file (%s) in zip archive due to dirOffset" % (f,)
                     )
                 continue
             info.filename = target[-1] + '/' if f[-1] == '/' else target[-1]
             zip_file.extract(f, os.path.join(self._fname, *tuple(target[dirOffset:-1])))
 
+    def get_tar_archive(self, url, dirOffset=0):
+        if self._fname is None:
+            raise DeveloperError(
+                "target file name has not been initialized "
+                "with set_destination_filename"
+            )
+        if os.path.exists(self._fname) and not os.path.isdir(self._fname):
+            raise RuntimeError(
+                "Target directory (%s) exists, but is not a directory" % (self._fname,)
+            )
+
+        def filter_fcn(info):
+            # this mocks up the `tarfile` filter introduced in Python
+            # 3.12 and backported to later releases of Python (e.g.,
+            # 3.8.17, 3.9.17, 3.10.12, and 3.11.4)
+            f = info.name
+            if os.path.isabs(f) or '..' in f or f.startswith(('/', os.sep)):
+                logger.error(
+                    "malformed or potentially insecure filename (%s).  "
+                    "Skipping file." % (f,)
+                )
+                return False
+            target = self._splitpath(f)
+            if len(target) <= dirOffset:
+                if not info.isdir():
+                    logger.warning(
+                        "Skipping file (%s) in tar archive due to dirOffset." % (f,)
+                    )
+                return False
+            info.name = f = '/'.join(target[dirOffset:])
+            target = os.path.realpath(os.path.join(dest, f))
+            try:
+                if os.path.commonpath([target, dest]) != dest:
+                    logger.error(
+                        "potentially insecure filename (%s) resolves outside target "
+                        "directory.  Skipping file." % (f,)
+                    )
+                    return False
+            except ValueError:
+                # commonpath() will raise ValueError for paths that
+                # don't have anything in common (notably, when files are
+                # on different drives on Windows)
+                logger.error(
+                    "potentially insecure filename (%s) resolves outside target "
+                    "directory.  Skipping file." % (f,)
+                )
+                return False
+            # Strip high bits & group/other write bits
+            info.mode &= 0o755
+            return True
+
+        with tarfile.open(fileobj=io.BytesIO(self.retrieve_url(url))) as TAR:
+            dest = os.path.realpath(self._fname)
+            TAR.extractall(dest, filter(filter_fcn, TAR.getmembers()))
+
     def get_gzipped_binary_file(self, url):
         if self._fname is None:
             raise DeveloperError(
                 "target file name has not been initialized "
                 "with set_destination_filename"
             )
         with open(self._fname, 'wb') as FILE:
```

### Comparing `Pyomo-6.7.1/pyomo/common/env.py` & `Pyomo-6.7.2/pyomo/common/env.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/envvar.py` & `Pyomo-6.7.2/pyomo/common/envvar.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/errors.py` & `Pyomo-6.7.2/pyomo/common/errors.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/extensions.py` & `Pyomo-6.7.2/pyomo/common/extensions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/factory.py` & `Pyomo-6.7.2/pyomo/common/factory.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/fileutils.py` & `Pyomo-6.7.2/pyomo/common/fileutils.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,15 @@
 
 import glob
 import inspect
 import logging
 import os
 import platform
 import importlib.util
+import subprocess
 import sys
 
 from . import envvar
 from .dependencies import ctypes
 from .deprecation import deprecated, relocated_module_attribute
 
 relocated_module_attribute('StreamIndenter', 'pyomo.common.formatting', version='6.2')
@@ -371,17 +372,35 @@
         return lib
     # Search 3: use ctypes.util.find_library (which expects 'lib' and
     # extension to be removed from the name)
     libname_base, ext = os.path.splitext(os.path.basename(libname))
     if libname_base.startswith('lib') and _system() != 'windows':
         libname_base = libname_base[3:]
     if ext.lower().startswith(('.so', '.dll', '.dylib')):
-        return ctypes.util.find_library(libname_base)
+        lib = ctypes.util.find_library(libname_base)
     else:
-        return ctypes.util.find_library(libname)
+        lib = ctypes.util.find_library(libname)
+    if lib and os.path.sep not in lib:
+        # work around https://github.com/python/cpython/issues/65241,
+        # where python does not return the absolute path on *nix
+        try:
+            libname = lib + ' '
+            with subprocess.Popen(
+                ['/sbin/ldconfig', '-p'],
+                stdin=subprocess.DEVNULL,
+                stderr=subprocess.DEVNULL,
+                stdout=subprocess.PIPE,
+                env={'LC_ALL': 'C', 'LANG': 'C'},
+            ) as p:
+                for line in os.fsdecode(p.stdout.read()).splitlines():
+                    if line.lstrip().startswith(libname):
+                        return os.path.realpath(line.split()[-1])
+        except:
+            pass
+    return lib
 
 
 def find_executable(exename, cwd=True, include_PATH=True, pathlist=None):
     """Find an executable using find_file to search typical locations.
 
     Finds a specified executable by searching a specified set of paths.
     This routine will look for the specified file name, as well as
```

### Comparing `Pyomo-6.7.1/pyomo/common/formatting.py` & `Pyomo-6.7.2/pyomo/common/formatting.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/gc_manager.py` & `Pyomo-6.7.2/pyomo/common/gc_manager.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/getGSL.py` & `Pyomo-6.7.2/pyomo/common/getGSL.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/gsl.py` & `Pyomo-6.7.2/pyomo/common/gsl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/log.py` & `Pyomo-6.7.2/pyomo/common/log.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/modeling.py` & `Pyomo-6.7.2/pyomo/common/modeling.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/multithread.py` & `Pyomo-6.7.2/pyomo/common/multithread.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/numeric_types.py` & `Pyomo-6.7.2/pyomo/common/numeric_types.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import logging
 import sys
 
-from pyomo.common.dependencies import numpy_available
 from pyomo.common.deprecation import deprecated, relocated_module_attribute
 from pyomo.common.errors import TemplateExpressionError
 
 logger = logging.getLogger(__name__)
 
 #: Python set used to identify numeric constants, boolean values, strings
 #: and instances of
@@ -46,26 +45,35 @@
 #: Note that :data:`native_numeric_types` does NOT include
 #: :py:`complex`, as that is not a valid constant in Pyomo numeric
 #: expressions.
 native_numeric_types = {int, float}
 native_integer_types = {int}
 native_logical_types = {bool}
 native_complex_types = {complex}
-pyomo_constant_types = set()  # includes NumericConstant
 
 _native_boolean_types = {int, bool, str, bytes}
 relocated_module_attribute(
     'native_boolean_types',
     'pyomo.common.numeric_types._native_boolean_types',
     version='6.6.0',
     msg="The native_boolean_types set will be removed in the future: the set "
     "contains types that were convertible to bool, and not types that should "
     "be treated as if they were bool (as was the case for the other "
     "native_*_types sets).  Users likely should use native_logical_types.",
 )
+_pyomo_constant_types = set()  # includes NumericConstant, _PythonCallbackFunctionID
+relocated_module_attribute(
+    'pyomo_constant_types',
+    'pyomo.common.numeric_types._pyomo_constant_types',
+    version='6.7.2',
+    msg="The pyomo_constant_types set will be removed in the future: the set "
+    "contained only NumericConstant and _PythonCallbackFunctionID, and provided "
+    "no meaningful value to clients or walkers.  Users should likely handle "
+    "these types in the same manner as immutable Params.",
+)
 
 
 #: Python set used to identify numeric constants and related native
 #: types.  This set includes
 #: native Python types as well as numeric types from Python packages
 #: like numpy.
 #:
@@ -190,68 +198,138 @@
     """
     _native_boolean_types.add(new_type)
     native_logical_types.add(new_type)
     native_types.add(new_type)
     nonpyomo_leaf_types.add(new_type)
 
 
+def check_if_native_type(obj):
+    if isinstance(obj, (str, bytes)):
+        native_types.add(obj.__class__)
+        return True
+    if check_if_logical_type(obj):
+        return True
+    if check_if_numeric_type(obj):
+        return True
+    return False
+
+
+def check_if_logical_type(obj):
+    """Test if the argument behaves like a logical type.
+
+    We check for "logical types" by checking if the type returns sane
+    results for Boolean operators (``^``, ``|``, ``&``) and if it maps
+    ``1`` and ``2`` both to the same equivalent instance.  If that
+    works, then we register the type in :py:attr:`native_logical_types`.
+
+    """
+    obj_class = obj.__class__
+    # Do not re-evaluate known native types
+    if obj_class in native_types:
+        return obj_class in native_logical_types
+
+    try:
+        # It is not an error if you can't initialize the type from an
+        # int, but if you can, it should map !0 to True
+        if obj_class(1) != obj_class(2):
+            return False
+    except:
+        pass
+
+    try:
+        # Native logical types *must* be hashable
+        hash(obj)
+        # Native logical types must honor standard Boolean operators
+        if all(
+            (
+                obj_class(False) != obj_class(True),
+                obj_class(False) ^ obj_class(False) == obj_class(False),
+                obj_class(False) ^ obj_class(True) == obj_class(True),
+                obj_class(True) ^ obj_class(False) == obj_class(True),
+                obj_class(True) ^ obj_class(True) == obj_class(False),
+                obj_class(False) | obj_class(False) == obj_class(False),
+                obj_class(False) | obj_class(True) == obj_class(True),
+                obj_class(True) | obj_class(False) == obj_class(True),
+                obj_class(True) | obj_class(True) == obj_class(True),
+                obj_class(False) & obj_class(False) == obj_class(False),
+                obj_class(False) & obj_class(True) == obj_class(False),
+                obj_class(True) & obj_class(False) == obj_class(False),
+                obj_class(True) & obj_class(True) == obj_class(True),
+            )
+        ):
+            RegisterLogicalType(obj_class)
+            return True
+    except:
+        pass
+    return False
+
+
 def check_if_numeric_type(obj):
     """Test if the argument behaves like a numeric type.
 
     We check for "numeric types" by checking if we can add zero to it
     without changing the object's type, and that the object compares to
     0 in a meaningful way.  If that works, then we register the type in
     :py:attr:`native_numeric_types`.
 
     """
     obj_class = obj.__class__
     # Do not re-evaluate known native types
     if obj_class in native_types:
         return obj_class in native_numeric_types
 
-    if 'numpy' in obj_class.__module__:
-        # trigger the resolution of numpy_available and check if this
-        # type was automatically registered
-        bool(numpy_available)
-        if obj_class in native_types:
-            return obj_class in native_numeric_types
-
     try:
         obj_plus_0 = obj + 0
         obj_p0_class = obj_plus_0.__class__
-        # ensure that the object is comparable to 0 in a meaningful way
-        # (among other things, this prevents numpy.ndarray objects from
-        # being added to native_numeric_types)
+        # Native numeric types *must* be hashable
+        hash(obj)
+    except:
+        return False
+    if obj_p0_class is not obj_class and obj_p0_class not in native_numeric_types:
+        return False
+    #
+    # Check if the numeric type behaves like a complex type
+    #
+    try:
+        if 1.41 < abs(obj_class(1j + 1)) < 1.42:
+            RegisterComplexType(obj_class)
+            return False
+    except:
+        pass
+    #
+    # Ensure that the object is comparable to 0 in a meaningful way
+    #
+    try:
         if not ((obj < 0) ^ (obj >= 0)):
             return False
-        # Native types *must* be hashable
-        hash(obj)
     except:
         return False
-    if obj_p0_class is obj_class or obj_p0_class in native_numeric_types:
-        #
-        # If we get here, this is a reasonably well-behaving
-        # numeric type: add it to the native numeric types
-        # so that future lookups will be faster.
-        #
-        RegisterNumericType(obj_class)
-        #
-        # Generate a warning, since Pyomo's management of third-party
-        # numeric types is more robust when registering explicitly.
-        #
-        logger.warning(
-            f"""Dynamically registering the following numeric type:
+    #
+    # If we get here, this is a reasonably well-behaving
+    # numeric type: add it to the native numeric types
+    # so that future lookups will be faster.
+    #
+    RegisterNumericType(obj_class)
+    try:
+        if obj_class(0.4) == obj_class(0):
+            RegisterIntegerType(obj_class)
+    except:
+        pass
+    #
+    # Generate a warning, since Pyomo's management of third-party
+    # numeric types is more robust when registering explicitly.
+    #
+    logger.warning(
+        f"""Dynamically registering the following numeric type:
     {obj_class.__module__}.{obj_class.__name__}
 Dynamic registration is supported for convenience, but there are known
 limitations to this approach.  We recommend explicitly registering
 numeric types using RegisterNumericType() or RegisterIntegerType()."""
-        )
-        return True
-    else:
-        return False
+    )
+    return True
 
 
 def value(obj, exception=True):
     """
     A utility function that returns the value of a Pyomo object or
     expression.
 
@@ -270,45 +348,33 @@
             returns :const:`None` when an exception occurs.
             Default is True.
 
     Returns: A numeric value or None.
     """
     if obj.__class__ in native_types:
         return obj
-    if obj.__class__ in pyomo_constant_types:
-        #
-        # I'm commenting this out for now, but I think we should never expect
-        # to see a numeric constant with value None.
-        #
-        # if exception and obj.value is None:
-        #    raise ValueError(
-        #        "No value for uninitialized NumericConstant object %s"
-        #        % (obj.name,))
-        return obj.value
     #
     # Test if we have a duck typed Pyomo expression
     #
-    try:
-        obj.is_numeric_type()
-    except AttributeError:
+    if not hasattr(obj, 'is_numeric_type'):
         #
         # TODO: Historically we checked for new *numeric* types and
         # raised exceptions for anything else.  That is inconsistent
         # with allowing native_types like None/str/bool to be returned
         # from value().  We should revisit if that is worthwhile to do
         # here.
         #
         if check_if_numeric_type(obj):
             return obj
         else:
             if not exception:
                 return None
             raise TypeError(
                 "Cannot evaluate object with unknown type: %s" % obj.__class__.__name__
-            ) from None
+            )
     #
     # Evaluate the expression object
     #
     if exception:
         #
         # Here, we try to catch the exception
         #
```

### Comparing `Pyomo-6.7.1/pyomo/common/plugin.py` & `Pyomo-6.7.2/pyomo/common/plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/plugin_base.py` & `Pyomo-6.7.2/pyomo/common/plugin_base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/plugins.py` & `Pyomo-6.7.2/pyomo/common/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/pyomo_typing.py` & `Pyomo-6.7.2/pyomo/common/pyomo_typing.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/shutdown.py` & `Pyomo-6.7.2/pyomo/common/shutdown.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/sorting.py` & `Pyomo-6.7.2/pyomo/common/sorting.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tee.py` & `Pyomo-6.7.2/pyomo/common/tee.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tempfiles.py` & `Pyomo-6.7.2/pyomo/common/tempfiles.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/__init__.py` & `Pyomo-6.7.2/pyomo/common/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/config_plugin.py` & `Pyomo-6.7.2/pyomo/common/tests/config_plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/dep_mod.py` & `Pyomo-6.7.2/pyomo/core/kernel/component_set.py`

 * *Files 23% similar despite different names*

```diff
@@ -5,16 +5,15 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import attempt_import
+from pyomo.common.collections import ComponentSet
+from pyomo.common.deprecation import deprecation_warning
 
-__version__ = '1.5'
-
-numpy, numpy_available = attempt_import('numpy', defer_check=True)
-
-bogus_nonexisting_module, bogus_nonexisting_module_available = attempt_import(
-    'bogus_nonexisting_module', alt_names=['bogus_nem'], defer_check=True
+deprecation_warning(
+    'The pyomo.core.kernel.component_set module is deprecated.  '
+    'Import ComponentSet from pyomo.common.collections.',
+    version='5.7.1',
 )
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/dep_mod_except.py` & `Pyomo-6.7.2/pyomo/common/tests/dep_mod_except.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/deps.py` & `Pyomo-6.7.2/pyomo/common/tests/deps.py`

 * *Files 7% similar despite different names*

```diff
@@ -19,23 +19,24 @@
 from pyomo.common.dependencies import attempt_import
 
 from pyomo.common.tests.dep_mod import (
     bogus_nonexisting_module as bogus_nem,
     bogus_nonexisting_module_available as has_bogus_nem,
 )
 
-bogus, bogus_available = attempt_import('nonexisting.module.bogus', defer_check=True)
+bogus, bogus_available = attempt_import('nonexisting.module.bogus', defer_import=True)
 
 pkl_test, pkl_available = attempt_import(
-    'nonexisting.module.pickle_test', deferred_submodules=['submod'], defer_check=True
+    'nonexisting.module.pickle_test', deferred_submodules=['submod'], defer_import=True
 )
 
 pyo, pyo_available = attempt_import(
     'pyomo',
     alt_names=['pyo'],
+    defer_import=True,
     deferred_submodules={'version': None, 'common.tests.dep_mod': ['dm']},
 )
 
 dm = pyo.common.tests.dep_mod
 
 
 def test_access_bogus_hello():
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/import_ex.py` & `Pyomo-6.7.2/pyomo/common/tests/import_ex.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/relo_mod.py` & `Pyomo-6.7.2/pyomo/common/tests/relo_mod.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/relo_mod_new.py` & `Pyomo-6.7.2/pyomo/common/tests/relo_mod_new.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/relocated.py` & `Pyomo-6.7.2/pyomo/common/tests/relocated.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_bunch.py` & `Pyomo-6.7.2/pyomo/common/tests/test_bunch.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_component_map.py` & `Pyomo-6.7.2/pyomo/common/tests/test_component_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_config.py` & `Pyomo-6.7.2/pyomo/common/tests/test_config.py`

 * *Files 1% similar despite different names*

```diff
@@ -2094,30 +2094,28 @@
         LOG = LOG.getvalue().replace('\n', ' ')
         for name in ('block_start', 'block_end', 'item_start', 'item_end', 'item_body'):
             self.assertIn(
                 f"Overriding '{name}' by passing strings to "
                 "generate_documentation is deprecated.",
                 LOG,
             )
-        self.maxDiff = None
         # print(test)
         self.assertEqual(test, reference)
 
         with LoggingIntercept() as LOG:
             test = self.config.generate_documentation(
                 format=String_ConfigFormatter(
                     block_start="startBlock{%s}\n",
                     block_end="endBlock{%s}\n",
                     item_start="startItem{%s}\n",
                     item_body="item{%s}\n",
                     item_end="endItem{%s}\n",
                 )
             )
         self.assertEqual(LOG.getvalue(), "")
-        self.maxDiff = None
         # print(test)
         self.assertEqual(test, reference)
 
         with LoggingIntercept() as LOG:
             test = self.config.generate_documentation(
                 block_start="startBlock\n",
                 block_end="endBlock\n",
@@ -2155,15 +2153,14 @@
             )
         for name in 'item_end':
             self.assertNotIn(
                 f"Overriding '{name}' by passing strings to "
                 "generate_documentation is deprecated.",
                 LOG,
             )
-        self.maxDiff = None
         # print(test)
         self.assertEqual(test, reference)
 
     def test_generate_latex_documentation(self):
         cfg = ConfigDict()
         cfg.declare(
             'int',
@@ -2573,15 +2570,14 @@
         self.config['scenario'].declare(
             'epanet',
             ConfigValue(True, bool, 'Use EPANET as the Water quality model', None),
         ).declare_as_argument(group='Scenario definition')
         parser = argparse.ArgumentParser(prog='tester')
         self.config.initialize_argparse(parser)
         help = parser.format_help()
-        self.maxDiff = None
         self.assertIn(
             """
   -h, --help            show this help message and exit
   --epanet-file EPANET  EPANET network inp file
 
 Scenario definition:
   --scenario-file STR   Scenario generation file, see the TEVASIM
@@ -3102,16 +3098,14 @@
         ):
             cfg2.declare_from(cfg)
 
         with self.assertRaisesRegex(ValueError, "only accepts other ConfigDicts"):
             cfg2.declare_from({})
 
     def test_docstring_decorator(self):
-        self.maxDiff = None
-
         @document_kwargs_from_configdict('CONFIG')
         class ExampleClass(object):
             CONFIG = ExampleConfig()
 
             @document_kwargs_from_configdict(CONFIG)
             def __init__(self):
                 "A simple docstring"
@@ -3261,10 +3255,45 @@
         OUT = StringIO()
         cfg2.display(ostream=OUT)
         self.assertEqual(
             "time_limit: 10.0\nstream_solver: false\n",
             OUT.getvalue().replace('null', 'None'),
         )
 
+    def test_domain_name(self):
+        cfg = ConfigDict()
+
+        cfg.declare('none', ConfigValue())
+        self.assertEqual(cfg.get('none').domain_name(), '')
+
+        def fcn(val):
+            return val
+
+        cfg.declare('fcn', ConfigValue(domain=fcn))
+        self.assertEqual(cfg.get('fcn').domain_name(), 'fcn')
+
+        fcn.domain_name = 'custom fcn'
+        self.assertEqual(cfg.get('fcn').domain_name(), 'custom fcn')
+
+        class functor:
+            def __call__(self, val):
+                return val
+
+        cfg.declare('functor', ConfigValue(domain=functor()))
+        self.assertEqual(cfg.get('functor').domain_name(), 'functor')
+
+        class cfunctor:
+            def __call__(self, val):
+                return val
+
+            def domain_name(self):
+                return 'custom functor'
+
+        cfg.declare('cfunctor', ConfigValue(domain=cfunctor()))
+        self.assertEqual(cfg.get('cfunctor').domain_name(), 'custom functor')
+
+        cfg.declare('type', ConfigValue(domain=int))
+        self.assertEqual(cfg.get('type').domain_name(), 'int')
+
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_dependencies.py` & `Pyomo-6.7.2/pyomo/common/tests/test_dependencies.py`

 * *Files 4% similar despite different names*

```diff
@@ -41,15 +41,15 @@
 
 
 class TestDependencies(unittest.TestCase):
     def test_import_error(self):
         module_obj, module_available = attempt_import(
             '__there_is_no_module_named_this__',
             'Testing import of a non-existent module',
-            defer_check=False,
+            defer_import=False,
         )
         self.assertFalse(module_available)
         with self.assertRaisesRegex(
             DeferredImportError, 'Testing import of a non-existent module'
         ):
             module_obj.try_to_call_a_method()
 
@@ -81,15 +81,15 @@
         new_pkl_test_2 = dill.loads(pkl)
         self.assertIs(deps.new_pkl_test.__class__, new_pkl_test_2.__class__)
         self.assertIsNot(deps.new_pkl_test, new_pkl_test_2)
         self.assertIs(new_pkl_test_2.__class__, ModuleUnavailable)
 
     def test_import_success(self):
         module_obj, module_available = attempt_import(
-            'ply', 'Testing import of ply', defer_check=False
+            'ply', 'Testing import of ply', defer_import=False
         )
         self.assertTrue(module_available)
         import ply
 
         self.assertTrue(module_obj is ply)
 
     def test_local_deferred_import(self):
@@ -119,69 +119,69 @@
         self.assertIs(deps.has_bogus_nem, False)
         self.assertIs(type(deps.bogus_nem), ModuleUnavailable)
         self.assertIs(dep_mod.bogus_nonexisting_module_available, False)
         self.assertIs(type(dep_mod.bogus_nonexisting_module), ModuleUnavailable)
 
     def test_min_version(self):
         mod, avail = attempt_import(
-            'pyomo.common.tests.dep_mod', minimum_version='1.0', defer_check=False
+            'pyomo.common.tests.dep_mod', minimum_version='1.0', defer_import=False
         )
         self.assertTrue(avail)
         self.assertTrue(inspect.ismodule(mod))
         self.assertTrue(check_min_version(mod, '1.0'))
         self.assertFalse(check_min_version(mod, '2.0'))
 
         mod, avail = attempt_import(
-            'pyomo.common.tests.dep_mod', minimum_version='2.0', defer_check=False
+            'pyomo.common.tests.dep_mod', minimum_version='2.0', defer_import=False
         )
         self.assertFalse(avail)
         self.assertIs(type(mod), ModuleUnavailable)
         with self.assertRaisesRegex(
             DeferredImportError,
             "The pyomo.common.tests.dep_mod module "
             "version 1.5 does not satisfy the minimum version 2.0",
         ):
             mod.hello
 
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod',
             error_message="Failed import",
             minimum_version='2.0',
-            defer_check=False,
+            defer_import=False,
         )
         self.assertFalse(avail)
         self.assertIs(type(mod), ModuleUnavailable)
         with self.assertRaisesRegex(
             DeferredImportError,
             "Failed import "
             r"\(version 1.5 does not satisfy the minimum version 2.0\)",
         ):
             mod.hello
 
         # Verify check_min_version works with deferred imports
 
-        mod, avail = attempt_import('pyomo.common.tests.dep_mod', defer_check=True)
+        mod, avail = attempt_import('pyomo.common.tests.dep_mod', defer_import=True)
         self.assertTrue(check_min_version(mod, '1.0'))
 
-        mod, avail = attempt_import('pyomo.common.tests.dep_mod', defer_check=True)
+        mod, avail = attempt_import('pyomo.common.tests.dep_mod', defer_import=True)
         self.assertFalse(check_min_version(mod, '2.0'))
 
         # Verify check_min_version works when called directly
 
         mod, avail = attempt_import('pyomo.common.tests.dep_mod', minimum_version='1.0')
         self.assertTrue(check_min_version(mod, '1.0'))
 
         mod, avail = attempt_import('pyomo.common.tests.bogus', minimum_version='1.0')
         self.assertFalse(check_min_version(mod, '1.0'))
 
     def test_and_or(self):
-        mod0, avail0 = attempt_import('ply', defer_check=True)
-        mod1, avail1 = attempt_import('pyomo.common.tests.dep_mod', defer_check=True)
+        mod0, avail0 = attempt_import('ply', defer_import=True)
+        mod1, avail1 = attempt_import('pyomo.common.tests.dep_mod', defer_import=True)
         mod2, avail2 = attempt_import(
-            'pyomo.common.tests.dep_mod', minimum_version='2.0', defer_check=True
+            'pyomo.common.tests.dep_mod', minimum_version='2.0', defer_import=True
         )
 
         _and = avail0 & avail1
         self.assertIsInstance(_and, _DeferredAnd)
 
         _or = avail1 | avail2
         self.assertIsInstance(_or, _DeferredOr)
@@ -229,70 +229,70 @@
 
     def test_callbacks(self):
         ans = []
 
         def _record_avail(module, avail):
             ans.append(avail)
 
-        mod0, avail0 = attempt_import('ply', defer_check=True, callback=_record_avail)
+        mod0, avail0 = attempt_import('ply', defer_import=True, callback=_record_avail)
         mod1, avail1 = attempt_import(
             'pyomo.common.tests.dep_mod',
             minimum_version='2.0',
-            defer_check=True,
+            defer_import=True,
             callback=_record_avail,
         )
 
         self.assertEqual(ans, [])
         self.assertTrue(avail0)
         self.assertEqual(ans, [True])
         self.assertFalse(avail1)
         self.assertEqual(ans, [True, False])
 
     def test_import_exceptions(self):
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod_except',
-            defer_check=True,
+            defer_import=True,
             only_catch_importerror=True,
         )
         with self.assertRaisesRegex(ValueError, "cannot import module"):
             bool(avail)
         # second test will not re-trigger the exception
         self.assertFalse(avail)
 
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod_except',
-            defer_check=True,
+            defer_import=True,
             only_catch_importerror=False,
         )
         self.assertFalse(avail)
         self.assertFalse(avail)
 
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod_except',
-            defer_check=True,
+            defer_import=True,
             catch_exceptions=(ImportError, ValueError),
         )
         self.assertFalse(avail)
         self.assertFalse(avail)
 
         with self.assertRaisesRegex(
             ValueError,
             'Cannot specify both only_catch_importerror and catch_exceptions',
         ):
             mod, avail = attempt_import(
                 'pyomo.common.tests.dep_mod_except',
-                defer_check=True,
+                defer_import=True,
                 only_catch_importerror=True,
                 catch_exceptions=(ImportError,),
             )
 
     def test_generate_warning(self):
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod_except',
-            defer_check=True,
+            defer_import=True,
             only_catch_importerror=False,
         )
 
         # Test generate warning
         log = StringIO()
         dep = StringIO()
         with LoggingIntercept(dep, 'pyomo.common.tests'):
@@ -320,15 +320,15 @@
         self.assertIn(
             "DEPRECATED: use :py:class:`log_import_warning()`", dep.getvalue()
         )
 
     def test_log_warning(self):
         mod, avail = attempt_import(
             'pyomo.common.tests.dep_mod_except',
-            defer_check=True,
+            defer_import=True,
             only_catch_importerror=False,
         )
         log = StringIO()
         dep = StringIO()
         with LoggingIntercept(dep, 'pyomo'):
             with LoggingIntercept(log, 'pyomo.common'):
                 mod.log_import_warning()
@@ -362,17 +362,17 @@
         self.assertEqual("", dep.getvalue())
 
     def test_importer(self):
         attempted_import = []
 
         def _importer():
             attempted_import.append(True)
-            return attempt_import('pyomo.common.tests.dep_mod', defer_check=False)[0]
+            return attempt_import('pyomo.common.tests.dep_mod', defer_import=False)[0]
 
-        mod, avail = attempt_import('foo', importer=_importer, defer_check=True)
+        mod, avail = attempt_import('foo', importer=_importer, defer_import=True)
 
         self.assertEqual(attempted_import, [])
         self.assertIsInstance(mod, DeferredImportModule)
         self.assertTrue(avail)
         self.assertEqual(attempted_import, [True])
         self.assertIs(mod._indicator_flag._module, dep_mod)
 
@@ -397,25 +397,25 @@
         self.assertEqual(version._submodule_name, '.version')
         # This causes the global objects to be resolved
         self.assertEqual(version.version, pyo_ver)
         self.assertTrue(inspect.ismodule(deps.pyo))
         self.assertTrue(inspect.ismodule(deps.dm))
 
         with self.assertRaisesRegex(
-            ValueError, "deferred_submodules is only valid if defer_check==True"
+            ValueError, "deferred_submodules is only valid if defer_import==True"
         ):
             mod, mod_available = attempt_import(
                 'nonexisting.module',
-                defer_check=False,
+                defer_import=False,
                 deferred_submodules={'submod': None},
             )
 
         mod, mod_available = attempt_import(
             'nonexisting.module',
-            defer_check=True,
+            defer_import=True,
             deferred_submodules={'submod.subsubmod': None},
         )
         self.assertIs(type(mod), DeferredImportModule)
         self.assertFalse(mod_available)
         _mod = mod_available._module
         self.assertIs(type(_mod), ModuleUnavailable)
         self.assertTrue(hasattr(_mod, 'submod'))
@@ -423,15 +423,15 @@
         self.assertTrue(hasattr(_mod.submod, 'subsubmod'))
         self.assertIs(type(_mod.submod.subsubmod), ModuleUnavailable)
 
     def test_UnavailableClass(self):
         module_obj, module_available = attempt_import(
             '__there_is_no_module_named_this__',
             'Testing import of a non-existent module',
-            defer_check=False,
+            defer_import=False,
         )
 
         class A_Class(UnavailableClass(module_obj)):
             pass
 
         with self.assertRaisesRegex(
             DeferredImportError,
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_deprecated.py` & `Pyomo-6.7.2/pyomo/common/tests/test_deprecated.py`

 * *Files 0% similar despite different names*

```diff
@@ -525,15 +525,18 @@
         )
 
         # Inheriting from a class derived from the deprecated class does
         # not generate a warning
         out = StringIO()
         with LoggingIntercept(out):
 
-            class DeprecatedClassSubSubclass(DeprecatedClassSubclass):
+            class otherClass:
+                pass
+
+            class DeprecatedClassSubSubclass(DeprecatedClassSubclass, otherClass):
                 attr = 'DeprecatedClassSubSubclass'
 
         self.assertEqual(out.getvalue(), "")
 
         #
         # Test class creation
         #
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_download.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_parameter.py`

 * *Files 19% similar despite different names*

```diff
@@ -5,261 +5,321 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-import os
-import platform
-import re
-import shutil
-import tempfile
-import subprocess
+import pickle
 
 import pyomo.common.unittest as unittest
-import pyomo.common.envvar as envvar
 
-from pyomo.common import DeveloperError
-from pyomo.common.fileutils import this_file
-from pyomo.common.download import FileDownloader, distro_available
-from pyomo.common.tee import capture_output
-
-
-class Test_FileDownloader(unittest.TestCase):
-    def setUp(self):
-        self.tmpdir = None
-        self.basedir = os.path.abspath(os.path.curdir)
-
-    def tearDown(self):
-        if self.tmpdir:
-            shutil.rmtree(self.tmpdir)
+from pyomo.common.dependencies import dill, dill_available as has_dill
+from pyomo.core.expr.numvalue import (
+    NumericValue,
+    is_fixed,
+    is_constant,
+    is_potentially_variable,
+)
+from pyomo.kernel import pprint
+from pyomo.core.tests.unit.kernel.test_dict_container import (
+    _TestActiveDictContainerBase,
+)
+from pyomo.core.tests.unit.kernel.test_tuple_container import (
+    _TestActiveTupleContainerBase,
+)
+from pyomo.core.tests.unit.kernel.test_list_container import (
+    _TestActiveListContainerBase,
+)
+from pyomo.core.kernel.base import ICategorizedObject
+from pyomo.core.kernel.parameter import (
+    IParameter,
+    parameter,
+    functional_value,
+    parameter_dict,
+    parameter_tuple,
+    parameter_list,
+)
+from pyomo.core.kernel.variable import variable
+from pyomo.core.kernel.block import block
+
+
+class Test_parameter(unittest.TestCase):
+    def test_pprint(self):
+        # Not really testing what the output is, just that
+        # an error does not occur. The pprint functionality
+        # is still in the early stages.
+        p = parameter()
+        pprint(p)
+        b = block()
+        b.p = p
+        pprint(p)
+        pprint(b)
+        m = block()
+        m.b = b
+        pprint(p)
+        pprint(b)
+        pprint(m)
+
+    def test_ctype(self):
+        p = parameter()
+        self.assertIs(p.ctype, IParameter)
+        self.assertIs(type(p), parameter)
+        self.assertIs(type(p)._ctype, IParameter)
+
+    def test_pickle(self):
+        p = parameter(value=1.0)
+        self.assertEqual(p.value, 1.0)
+        self.assertIs(p.parent, None)
+        pup = pickle.loads(pickle.dumps(p))
+        self.assertEqual(pup.value, 1.0)
+        self.assertIs(pup.parent, None)
+        b = block()
+        b.p = p
+        self.assertIs(p.parent, b)
+        bup = pickle.loads(pickle.dumps(b))
+        pup = bup.p
+        self.assertEqual(pup.value, 1.0)
+        self.assertIs(pup.parent, bup)
 
     def test_init(self):
-        f = FileDownloader()
-        self.assertFalse(f.insecure)
-        self.assertIsNone(f.cacert)
-        self.assertIsNone(f._fname)
-
-        f = FileDownloader(True)
-        self.assertTrue(f.insecure)
-        self.assertIsNone(f.cacert)
-        self.assertIsNone(f._fname)
-
-        f = FileDownloader(True, this_file())
-        self.assertTrue(f.insecure)
-        self.assertEqual(f.cacert, this_file())
-        self.assertIsNone(f._fname)
-
-        with self.assertRaisesRegex(
-            RuntimeError,
-            "cacert='nonexistent_file_name' does not refer to a valid file.",
-        ):
-            FileDownloader(True, 'nonexistent_file_name')
-
-    def test_parse(self):
-        f = FileDownloader()
-        f.parse_args([])
-        self.assertFalse(f.insecure)
-        self.assertIsNone(f.cacert)
-        self.assertIsNone(f.target)
-
-        f = FileDownloader()
-        f.parse_args(['--insecure'])
-        self.assertTrue(f.insecure)
-        self.assertIsNone(f.cacert)
-        self.assertIsNone(f.target)
-
-        f = FileDownloader()
-        f.parse_args(['--insecure', '--cacert', this_file()])
-        self.assertTrue(f.insecure)
-        self.assertEqual(f.cacert, this_file())
-        self.assertIsNone(f.target)
-
-        f = FileDownloader()
-        f.parse_args(['--insecure', 'bar', '--cacert', this_file()])
-        self.assertTrue(f.insecure)
-        self.assertEqual(f.cacert, this_file())
-        self.assertEqual(f.target, 'bar')
-
-        f = FileDownloader()
-        with capture_output() as io:
-            with self.assertRaises(SystemExit):
-                f.parse_args(['--cacert'])
-        self.assertIn('argument --cacert: expected one argument', io.getvalue())
-
-        f = FileDownloader()
-        with capture_output() as io:
-            with self.assertRaises(SystemExit):
-                f.parse_args(['--cacert', '--insecure'])
-        self.assertIn('argument --cacert: expected one argument', io.getvalue())
-
-        f = FileDownloader()
-        with self.assertRaisesRegex(
-            RuntimeError,
-            "--cacert='nonexistent_file_name' does not refer to a valid file",
-        ):
-            f.parse_args(['--cacert', 'nonexistent_file_name'])
-
-        f = FileDownloader()
-        with capture_output() as io:
-            with self.assertRaises(SystemExit):
-                f.parse_args(['--foo'])
-        self.assertIn('error: unrecognized arguments: --foo', io.getvalue())
-
-    def test_set_destination_filename(self):
-        self.tmpdir = os.path.abspath(tempfile.mkdtemp())
-
-        f = FileDownloader()
-        self.assertIsNone(f._fname)
-        f.set_destination_filename('foo')
-        self.assertEqual(f._fname, os.path.join(envvar.PYOMO_CONFIG_DIR, 'foo'))
-        # By this point, the CONFIG_DIR is guaranteed to have been created
-        self.assertTrue(os.path.isdir(envvar.PYOMO_CONFIG_DIR))
-
-        f.target = self.tmpdir
-        f.set_destination_filename('foo')
-        target = os.path.join(self.tmpdir, 'foo')
-        self.assertEqual(f._fname, target)
-        self.assertFalse(os.path.exists(target))
-
-        f.target = self.tmpdir
-        f.set_destination_filename(os.path.join('foo', 'bar'))
-        target = os.path.join(self.tmpdir, 'foo', 'bar')
-        self.assertEqual(f._fname, target)
-        self.assertFalse(os.path.exists(target))
-        target_dir = os.path.join(self.tmpdir, 'foo')
-        self.assertTrue(os.path.isdir(target_dir))
-
-    def test_get_sysinfo(self):
-        f = FileDownloader()
-        ans = f.get_sysinfo()
-        self.assertIs(type(ans), tuple)
-        self.assertEqual(len(ans), 2)
-        self.assertTrue(len(ans[0]) > 0)
-        self.assertTrue(platform.system().lower().startswith(ans[0]))
-        self.assertFalse(any(c in ans[0] for c in '.-_'))
-        self.assertIn(ans[1], (32, 64))
-
-    def test_get_os_version(self):
-        f = FileDownloader()
-        _os, _ver = f.get_os_version(normalize=False)
-        _norm = f.get_os_version(normalize=True)
-        # print(_os,_ver,_norm)
-        _sys = f.get_sysinfo()[0]
-        if _sys == 'linux':
-            dist, dist_ver = re.match('^([^0-9]+)(.*)', _norm).groups()
-            self.assertNotIn('.', dist_ver)
-            self.assertGreater(int(dist_ver), 0)
-            if dist == 'ubuntu':
-                self.assertEqual(dist_ver, ''.join(_ver.split('.')[:2]))
-            else:
-                self.assertEqual(dist_ver, _ver.split('.')[0])
-
-            if distro_available:
-                d, v = f._get_distver_from_distro()
-                # print(d,v)
-                self.assertEqual(_os, d)
-                self.assertEqual(_ver, v)
-                self.assertTrue(v.replace('.', '').startswith(dist_ver))
-
-            if os.path.exists('/etc/redhat-release'):
-                d, v = f._get_distver_from_redhat_release()
-                # print(d,v)
-                self.assertEqual(_os, d)
-                self.assertEqual(_ver, v)
-                self.assertTrue(v.replace('.', '').startswith(dist_ver))
-
-            if (
-                subprocess.run(
-                    ['lsb_release'],
-                    stdout=subprocess.DEVNULL,
-                    stderr=subprocess.DEVNULL,
-                ).returncode
-                == 0
-            ):
-                d, v = f._get_distver_from_lsb_release()
-                # print(d,v)
-                self.assertEqual(_os, d)
-                self.assertEqual(_ver, v)
-                self.assertTrue(v.replace('.', '').startswith(dist_ver))
-
-            if os.path.exists('/etc/os-release'):
-                d, v = f._get_distver_from_os_release()
-                # print(d,v)
-                self.assertEqual(_os, d)
-                # Note that (at least on centos), os_release is an
-                # imprecise version string
-                self.assertTrue(_ver.startswith(v))
-                self.assertTrue(v.replace('.', '').startswith(dist_ver))
-
-        elif _sys == 'darwin':
-            dist, dist_ver = re.match('^([^0-9]+)(.*)', _norm).groups()
-            self.assertEqual(_os, 'macos')
-            self.assertEqual(dist, 'macos')
-            self.assertNotIn('.', dist_ver)
-            self.assertGreater(int(dist_ver), 0)
-            self.assertEqual(_norm, _os + ''.join(_ver.split('.')[:2]))
-        elif _sys == 'windows':
-            self.assertEqual(_os, 'win')
-            self.assertEqual(_norm, _os + ''.join(_ver.split('.')[:2]))
-        else:
-            self.assertEqual(ans, '')
-
-        self.assertEqual((_os, _ver), FileDownloader._os_version)
-        # Exercise the fetch from CACHE
-        try:
-            FileDownloader._os_version, tmp = ("test", '2'), FileDownloader._os_version
-            self.assertEqual(f.get_os_version(False), ("test", "2"))
-            self.assertEqual(f.get_os_version(), "test2")
-        finally:
-            FileDownloader._os_version = tmp
-
-    def test_get_platform_url(self):
-        f = FileDownloader()
-        urlmap = {'bogus_sys': 'bogus'}
-        with self.assertRaisesRegex(
-            RuntimeError, "cannot infer the correct url for platform '.*'"
-        ):
-            f.get_platform_url(urlmap)
-
-        urlmap[f.get_sysinfo()[0]] = 'correct'
-        self.assertEqual(f.get_platform_url(urlmap), 'correct')
-
-    def test_get_files_requires_set_destination(self):
-        f = FileDownloader()
-        with self.assertRaisesRegex(
-            DeveloperError, 'target file name has not been initialized'
-        ):
-            f.get_binary_file('bogus')
-
-        with self.assertRaisesRegex(
-            DeveloperError, 'target file name has not been initialized'
-        ):
-            f.get_binary_file_from_zip_archive('bogus', 'bogus')
-
-        with self.assertRaisesRegex(
-            DeveloperError, 'target file name has not been initialized'
-        ):
-            f.get_gzipped_binary_file('bogus')
-
-    def test_get_test_binary_file(self):
-        tmpdir = tempfile.mkdtemp()
-        try:
-            f = FileDownloader()
-
-            # Mock retrieve_url so network connections are not necessary
-            f.retrieve_url = lambda url: bytes("\n", encoding='utf-8')
-
-            # Binary files will preserve line endings
-            target = os.path.join(tmpdir, 'bin.txt')
-            f.set_destination_filename(target)
-            f.get_binary_file(None)
-            self.assertEqual(os.path.getsize(target), 1)
-
-            # Text files will convert line endings to the local platform
-            target = os.path.join(tmpdir, 'txt.txt')
-            f.set_destination_filename(target)
-            f.get_text_file(None)
-            self.assertEqual(os.path.getsize(target), len(os.linesep))
-        finally:
-            shutil.rmtree(tmpdir)
+        p = parameter()
+        self.assertTrue(p.parent is None)
+        self.assertEqual(p.ctype, IParameter)
+        self.assertEqual(p.value, None)
+        self.assertEqual(p(), None)
+        p.value = 1
+        self.assertEqual(p.value, 1)
+        self.assertEqual(p(), 1)
+
+    def test_type(self):
+        p = parameter()
+        self.assertTrue(isinstance(p, ICategorizedObject))
+        self.assertTrue(isinstance(p, IParameter))
+        self.assertTrue(isinstance(p, NumericValue))
+
+    def test_is_constant(self):
+        p = parameter()
+        self.assertEqual(p.is_constant(), False)
+        self.assertEqual(is_constant(p), False)
+        p.value = 1.0
+        self.assertEqual(p.is_constant(), False)
+        self.assertEqual(is_constant(p), False)
+
+    def test_is_fixed(self):
+        p = parameter()
+        self.assertEqual(p.is_fixed(), True)
+        self.assertEqual(is_fixed(p), True)
+        p.value = 1.0
+        self.assertEqual(p.is_fixed(), True)
+        self.assertEqual(is_fixed(p), True)
+
+    def test_potentially_variable(self):
+        p = parameter()
+        self.assertEqual(p.is_potentially_variable(), False)
+        self.assertEqual(is_potentially_variable(p), False)
+        p.value = 1.0
+        self.assertEqual(p.is_potentially_variable(), False)
+        self.assertEqual(is_potentially_variable(p), False)
+
+    def test_polynomial_degree(self):
+        p = parameter()
+        self.assertEqual(p.polynomial_degree(), 0)
+        self.assertEqual((p**2).polynomial_degree(), 0)
+        self.assertEqual(p.value, None)
+        with self.assertRaises(ValueError):
+            (p**2)()
+        p.value = 1.0
+        self.assertEqual(p.polynomial_degree(), 0)
+        self.assertEqual((p**2).polynomial_degree(), 0)
+        self.assertEqual(p.value, 1.0)
+        self.assertEqual((p**2)(), 1.0)
+
+    def test_is_expression_type(self):
+        p = parameter()
+        self.assertEqual(p.is_expression_type(), False)
+
+    def test_is_parameter_type(self):
+        p = parameter()
+        # GH: apparently is_parameter_type has something
+        #     to do with mutability...
+        self.assertEqual(p.is_parameter_type(), False)
+
+
+class Test_functional_value(unittest.TestCase):
+    def test_pprint(self):
+        # Not really testing what the output is, just that
+        # an error does not occur. The pprint functionality
+        # is still in the early stages.
+        f = functional_value()
+        pprint(f)
+        b = block()
+        b.f = f
+        pprint(f)
+        pprint(b)
+        m = block()
+        m.b = b
+        pprint(f)
+        pprint(b)
+        pprint(m)
+
+    def test_ctype(self):
+        f = functional_value()
+        self.assertIs(f.ctype, IParameter)
+        self.assertIs(type(f), functional_value)
+        self.assertIs(type(f)._ctype, IParameter)
+
+    def test_pickle(self):
+        f = functional_value()
+        self.assertIs(f.fn, None)
+        self.assertIs(f.parent, None)
+        fup = pickle.loads(pickle.dumps(f))
+        self.assertIs(fup.fn, None)
+        self.assertIs(fup.parent, None)
+        b = block()
+        b.f = f
+        self.assertIs(f.parent, b)
+        bup = pickle.loads(pickle.dumps(b))
+        fup = bup.f
+        self.assertIs(fup.fn, None)
+        self.assertIs(fup.parent, bup)
+
+    @unittest.skipIf(not has_dill, "The dill module is not available")
+    def test_dill(self):
+        p = parameter(1)
+        f = functional_value(lambda: p())
+        self.assertEqual(f(), 1)
+        fup = dill.loads(dill.dumps(f))
+        p.value = 2
+        self.assertEqual(f(), 2)
+        self.assertEqual(fup(), 1)
+        b = block()
+        b.p = p
+        b.f = f
+        self.assertEqual(b.f(), 2)
+        bup = dill.loads(dill.dumps(b))
+        fup = bup.f
+        b.p.value = 4
+        self.assertEqual(b.f(), 4)
+        self.assertEqual(bup.f(), 2)
+        bup.p.value = 4
+        self.assertEqual(bup.f(), 4)
+
+    def test_call(self):
+        f = functional_value()
+        self.assertEqual(f(), None)
+        self.assertIs(f.fn, None)
+        f.fn = lambda: variable(value=1)
+        self.assertIsNot(f.fn, None)
+        # the function did not return numeric data
+        # (always causes an exception)
+        with self.assertRaises(TypeError):
+            f(exception=False)
+        with self.assertRaises(TypeError):
+            f(exception=True)
+        with self.assertRaises(TypeError):
+            f()
+        f.fn = lambda: None
+        self.assertIsNot(f.fn, None)
+        # the function did not return numeric data
+        # (always causes an exception)
+        with self.assertRaises(TypeError):
+            f(exception=False)
+        with self.assertRaises(TypeError):
+            f(exception=True)
+        with self.assertRaises(TypeError):
+            f()
+
+        def value_error():
+            raise ValueError()
+
+        f.fn = value_error
+        self.assertIsNot(f.fn, None)
+        self.assertEqual(f(exception=False), None)
+        with self.assertRaises(ValueError):
+            f(exception=True)
+        with self.assertRaises(ValueError):
+            f()
+
+    def test_init(self):
+        f = functional_value()
+        self.assertTrue(f.parent is None)
+        self.assertEqual(f.ctype, IParameter)
+        self.assertEqual(f.fn, None)
+        self.assertEqual(f(), None)
+        x = [1, 2]
+        f.fn = lambda: max(x)
+        self.assertEqual(f(), 2)
+        x[0] = 3
+        self.assertEqual(f(), 3)
+
+    def test_type(self):
+        f = functional_value()
+        self.assertTrue(isinstance(f, ICategorizedObject))
+        self.assertTrue(isinstance(f, IParameter))
+        self.assertTrue(isinstance(f, NumericValue))
+
+    def test_is_constant(self):
+        f = functional_value()
+        self.assertEqual(f.is_constant(), False)
+        self.assertEqual(is_constant(f), False)
+        f.fn = lambda: 2
+        self.assertEqual(f.is_constant(), False)
+        self.assertEqual(is_constant(f), False)
+
+    def test_is_fixed(self):
+        f = functional_value()
+        self.assertEqual(f.is_fixed(), True)
+        self.assertEqual(is_fixed(f), True)
+        f.fn = lambda: 2
+        self.assertEqual(f.is_fixed(), True)
+        self.assertEqual(is_fixed(f), True)
+
+    def test_potentially_variable(self):
+        f = functional_value()
+        self.assertEqual(f.is_potentially_variable(), False)
+        self.assertEqual(is_potentially_variable(f), False)
+        f.fn = lambda: 2
+        self.assertEqual(f.is_potentially_variable(), False)
+        self.assertEqual(is_potentially_variable(f), False)
+
+    def test_polynomial_degree(self):
+        f = functional_value()
+        self.assertEqual(f.polynomial_degree(), 0)
+        self.assertEqual((f**2).polynomial_degree(), 0)
+        self.assertIs(f.fn, None)
+        with self.assertRaises(ValueError):
+            (f**2)()
+        f.fn = lambda: 2
+        self.assertEqual(f.polynomial_degree(), 0)
+        self.assertEqual((f**2).polynomial_degree(), 0)
+        self.assertEqual(f(), 2)
+        self.assertEqual((f**2)(), 4)
+
+    def test_is_expression_type(self):
+        f = functional_value()
+        self.assertEqual(f.is_expression_type(), False)
+
+    def test_is_parameter_type(self):
+        f = functional_value()
+        # GH: apparently is_parameter_type has something
+        #     to do with mutability...
+        self.assertEqual(f.is_parameter_type(), False)
+
+
+class Test_parameter_dict(_TestActiveDictContainerBase, unittest.TestCase):
+    _container_type = parameter_dict
+    _ctype_factory = lambda self: parameter()
+
+
+class Test_parameter_tuple(_TestActiveTupleContainerBase, unittest.TestCase):
+    _container_type = parameter_tuple
+    _ctype_factory = lambda self: parameter()
+
+
+class Test_parameter_list(_TestActiveListContainerBase, unittest.TestCase):
+    _container_type = parameter_list
+    _ctype_factory = lambda self: parameter()
+
+
+if __name__ == "__main__":
+    unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_env.py` & `Pyomo-6.7.2/pyomo/common/tests/test_env.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_errors.py` & `Pyomo-6.7.2/pyomo/common/tests/test_errors.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_fileutils.py` & `Pyomo-6.7.2/pyomo/common/tests/test_fileutils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_formatting.py` & `Pyomo-6.7.2/pyomo/common/tests/test_formatting.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_gc.py` & `Pyomo-6.7.2/pyomo/common/tests/test_gc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_log.py` & `Pyomo-6.7.2/pyomo/common/tests/test_log.py`

 * *Files 0% similar despite different names*

```diff
@@ -507,15 +507,14 @@
             "        literal\n"
             "        with a blank line\n"
             "\n"
             "    Finally, an invalid::\n"
             "\n"
             "    quote block\n"
         )
-        self.maxDiff = None
         self.assertEqual(self.stream.getvalue(), ans)
 
 
 class TestLogStream(unittest.TestCase):
     def test_log_stream(self):
         ls = LogStream(logging.INFO, logging.getLogger('pyomo'))
         LI = LoggingIntercept(level=logging.INFO, formatter=pyomo_formatter)
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_modeling.py` & `Pyomo-6.7.2/pyomo/common/tests/test_modeling.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_multithread.py` & `Pyomo-6.7.2/pyomo/common/tests/test_multithread.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_orderedset.py` & `Pyomo-6.7.2/pyomo/common/tests/test_orderedset.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_plugin.py` & `Pyomo-6.7.2/pyomo/common/tests/test_plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_sorting.py` & `Pyomo-6.7.2/pyomo/common/tests/test_sorting.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_tee.py` & `Pyomo-6.7.2/pyomo/common/tests/test_tee.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_tempfile.py` & `Pyomo-6.7.2/pyomo/common/tests/test_tempfile.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_timing.py` & `Pyomo-6.7.2/pyomo/common/tests/test_timing.py`

 * *Files 1% similar despite different names*

```diff
@@ -31,15 +31,15 @@
     AbstractModel,
     ConcreteModel,
     RangeSet,
     Var,
     Any,
     TransformationFactory,
 )
-from pyomo.core.base.var import _VarData
+from pyomo.core.base.var import VarData
 
 
 class _pseudo_component(Var):
     def getname(*args, **kwds):
         raise RuntimeError("fail")
 
 
@@ -58,15 +58,15 @@
         self.assertRegex(
             str(a),
             r"ConstructionTimer object for NoneType \(unknown\); "
             r"[0-9\.]+ elapsed seconds",
         )
         v = Var()
         v.construct()
-        a = ConstructionTimer(_VarData(v))
+        a = ConstructionTimer(VarData(v))
         self.assertRegex(
             str(a),
             r"ConstructionTimer object for Var ScalarVar\[NOTSET\]; "
             r"[0-9\.]+ elapsed seconds",
         )
 
     def test_raw_transformation_timer(self):
@@ -103,43 +103,40 @@
                 report_timing()
                 m = ConcreteModel()
                 m.r = RangeSet(2)
                 m.x = Var(m.r)
                 m.y = Var(Any, dense=False)
                 xfrm.apply_to(m)
             result = out.getvalue().strip()
-            self.maxDiff = None
             for l, r in zip(result.splitlines(), ref.splitlines()):
                 self.assertRegex(str(l.strip()), str(r.strip()))
         finally:
             report_timing(False)
 
         os = StringIO()
         try:
             report_timing(os)
             m = ConcreteModel()
             m.r = RangeSet(2)
             m.x = Var(m.r)
             m.y = Var(Any, dense=False)
             xfrm.apply_to(m)
             result = os.getvalue().strip()
-            self.maxDiff = None
             for l, r in zip(result.splitlines(), ref.splitlines()):
                 self.assertRegex(str(l.strip()), str(r.strip()))
         finally:
             report_timing(False)
         buf = StringIO()
         with LoggingIntercept(buf, 'pyomo'):
             m = ConcreteModel()
             m.r = RangeSet(2)
             m.x = Var(m.r)
             m.y = Var(Any, dense=False)
             xfrm.apply_to(m)
             result = os.getvalue().strip()
-            self.maxDiff = None
             for l, r in zip(result.splitlines(), ref.splitlines()):
                 self.assertRegex(str(l.strip()), str(r.strip()))
             self.assertEqual(buf.getvalue().strip(), "")
 
     def test_report_timing_context_manager(self):
         ref = r"""
            (0(\.\d+)?) seconds to construct Var x; 2 indices total
@@ -168,15 +165,14 @@
                     self.assertEqual(OS.getvalue(), "")
                 # Active reporting: we should log the timing
                 with capture_output() as OUT:
                     m = model.create_instance()
                     xfrm.apply_to(m)
                 self.assertEqual(OUT.getvalue(), "")
                 result = OS.getvalue().strip()
-                self.maxDiff = None
                 for l, r in zip_longest(result.splitlines(), ref.splitlines()):
                     self.assertRegex(str(l.strip()), str(r.strip()))
             # Active reporting is False: the previous log should not have changed
             with capture_output() as OUT:
                 m = model.create_instance()
                 xfrm.apply_to(m)
             self.assertEqual(OUT.getvalue(), "")
```

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_typing.py` & `Pyomo-6.7.2/pyomo/common/tests/test_typing.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/tests/test_unittest.py` & `Pyomo-6.7.2/pyomo/common/tests/test_unittest.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/timing.py` & `Pyomo-6.7.2/pyomo/common/timing.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/common/unittest.py` & `Pyomo-6.7.2/pyomo/common/unittest.py`

 * *Files 1% similar despite different names*

```diff
@@ -494,14 +494,18 @@
 
     unittest.TestCase documentation
     -------------------------------
     """
 
     __doc__ += _unittest.TestCase.__doc__
 
+    # By default, we always want to spend the time to create the full
+    # diff of the test reault and the baseline
+    maxDiff = None
+
     def assertStructuredAlmostEqual(
         self,
         first,
         second,
         places=None,
         msg=None,
         delta=None,
@@ -627,15 +631,15 @@
             solver_: (solver_ in available_solvers) for solver_ in solvers_used
         }
 
         cls.package_available = {}
         cls.package_modules = {}
         packages_used = set(sum(list(cls.package_dependencies.values()), []))
         for package_ in packages_used:
-            pack, pack_avail = attempt_import(package_, defer_check=False)
+            pack, pack_avail = attempt_import(package_, defer_import=False)
             cls.package_available[package_] = pack_avail
             cls.package_modules[package_] = pack
 
     @classmethod
     def _find_tests(cls, test_dirs, pattern):
         test_tuples = []
         for testdir in test_dirs:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/build.py` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/build.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/CMakeLists.txt` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/FindASL.cmake` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/FindASL.cmake`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/src/functions.c` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/src/functions.c`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/ampl_function_demo/tests/test_ampl_function_demo.py` & `Pyomo-6.7.2/pyomo/contrib/ampl_function_demo/tests/test_ampl_function_demo.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/base.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/base.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,20 +17,20 @@
     Optional,
     Mapping,
     NoReturn,
     List,
     Tuple,
     MutableMapping,
 )
-from pyomo.core.base.constraint import _GeneralConstraintData, Constraint
-from pyomo.core.base.sos import _SOSConstraintData, SOSConstraint
-from pyomo.core.base.var import _GeneralVarData, Var
-from pyomo.core.base.param import _ParamData, Param
-from pyomo.core.base.block import _BlockData, Block
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.constraint import ConstraintData, Constraint
+from pyomo.core.base.sos import SOSConstraintData, SOSConstraint
+from pyomo.core.base.var import VarData, Var
+from pyomo.core.base.param import ParamData, Param
+from pyomo.core.base.block import BlockData, Block
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.common.collections import ComponentMap
 from .utils.get_objective import get_objective
 from .utils.collect_vars_and_named_exprs import collect_vars_and_named_exprs
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.config import ConfigDict, ConfigValue, NonNegativeFloat
 from pyomo.common.errors import ApplicationError
 from pyomo.opt.base import SolverFactory as LegacySolverFactory
@@ -175,17 +175,15 @@
         self.declare('relax_integrality', ConfigValue(domain=bool))
 
         self.mip_gap: Optional[float] = None
         self.relax_integrality: bool = False
 
 
 class SolutionLoaderBase(abc.ABC):
-    def load_vars(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> NoReturn:
+    def load_vars(self, vars_to_load: Optional[Sequence[VarData]] = None) -> NoReturn:
         """
         Load the solution of the primal variables into the value attribute of the variables.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose solution should be loaded. If vars_to_load is None, then the solution
@@ -193,16 +191,16 @@
         """
         for v, val in self.get_primals(vars_to_load=vars_to_load).items():
             v.set_value(val, skip_validation=True)
         StaleFlagManager.mark_all_as_stale(delayed=True)
 
     @abc.abstractmethod
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Returns a ComponentMap mapping variable to var value.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose solution value should be retrieved. If vars_to_load is None,
@@ -212,16 +210,16 @@
         -------
         primals: ComponentMap
             Maps variables to solution values
         """
         pass
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Returns a dictionary mapping constraint to dual value.
 
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose duals should be retrieved. If cons_to_load is None, then the duals for all
@@ -231,16 +229,16 @@
         -------
         duals: dict
             Maps constraints to dual values
         """
         raise NotImplementedError(f'{type(self)} does not support the get_duals method')
 
     def get_slacks(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Returns a dictionary mapping constraint to slack.
 
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose duals should be loaded. If cons_to_load is None, then the duals for all
@@ -252,16 +250,16 @@
             Maps constraints to slacks
         """
         raise NotImplementedError(
             f'{type(self)} does not support the get_slacks method'
         )
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Returns a ComponentMap mapping variable to reduced cost.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose reduced cost should be retrieved. If vars_to_load is None, then the
@@ -299,32 +297,32 @@
         """
         self._primals = primals
         self._duals = duals
         self._slacks = slacks
         self._reduced_costs = reduced_costs
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._primals is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check the termination condition.'
             )
         if vars_to_load is None:
             return ComponentMap(self._primals.values())
         else:
             primals = ComponentMap()
             for v in vars_to_load:
                 primals[v] = self._primals[id(v)][1]
             return primals
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         if self._duals is None:
             raise RuntimeError(
                 'Solution loader does not currently have valid duals. Please '
                 'check the termination condition and ensure the solver returns duals '
                 'for the given problem type.'
             )
         if cons_to_load is None:
@@ -332,16 +330,16 @@
         else:
             duals = dict()
             for c in cons_to_load:
                 duals[c] = self._duals[c]
         return duals
 
     def get_slacks(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         if self._slacks is None:
             raise RuntimeError(
                 'Solution loader does not currently have valid slacks. Please '
                 'check the termination condition and ensure the solver returns slacks '
                 'for the given problem type.'
             )
         if cons_to_load is None:
@@ -349,16 +347,16 @@
         else:
             slacks = dict()
             for c in cons_to_load:
                 slacks[c] = self._slacks[c]
         return slacks
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._reduced_costs is None:
             raise RuntimeError(
                 'Solution loader does not currently have valid reduced costs. Please '
                 'check the termination condition and ensure the solver returns reduced '
                 'costs for the given problem type.'
             )
         if vars_to_load is None:
@@ -617,21 +615,21 @@
             # Note: Python 3.11 changed the core enums so that the
             # "mixin" type for standard enums overrides the behavior
             # specified in __format__.  We will override str() here to
             # preserve the previous behavior
             return self.name
 
     @abc.abstractmethod
-    def solve(self, model: _BlockData, timer: HierarchicalTimer = None) -> Results:
+    def solve(self, model: BlockData, timer: HierarchicalTimer = None) -> Results:
         """
         Solve a Pyomo model.
 
         Parameters
         ----------
-        model: _BlockData
+        model: BlockData
             The Pyomo model to be solved
         timer: HierarchicalTimer
             An option timer for reporting timing
 
         Returns
         -------
         results: Results
@@ -704,17 +702,15 @@
         return False
 
 
 class PersistentSolver(Solver):
     def is_persistent(self):
         return True
 
-    def load_vars(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> NoReturn:
+    def load_vars(self, vars_to_load: Optional[Sequence[VarData]] = None) -> NoReturn:
         """
         Load the solution of the primal variables into the value attribute of the variables.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose solution should be loaded. If vars_to_load is None, then the solution
@@ -722,21 +718,21 @@
         """
         for v, val in self.get_primals(vars_to_load=vars_to_load).items():
             v.set_value(val, skip_validation=True)
         StaleFlagManager.mark_all_as_stale(delayed=True)
 
     @abc.abstractmethod
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         pass
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Declare sign convention in docstring here.
 
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose duals should be loaded. If cons_to_load is None, then the duals for all
@@ -748,16 +744,16 @@
             Maps constraints to dual values
         """
         raise NotImplementedError(
             '{0} does not support the get_duals method'.format(type(self))
         )
 
     def get_slacks(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose slacks should be loaded. If cons_to_load is None, then the slacks for all
             constraints will be loaded.
 
@@ -767,16 +763,16 @@
             Maps constraints to slack values
         """
         raise NotImplementedError(
             '{0} does not support the get_slacks method'.format(type(self))
         )
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose reduced cost should be loaded. If vars_to_load is None, then all reduced costs
             will be loaded.
 
@@ -795,51 +791,51 @@
         pass
 
     @abc.abstractmethod
     def set_instance(self, model):
         pass
 
     @abc.abstractmethod
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         pass
 
     @abc.abstractmethod
-    def add_params(self, params: List[_ParamData]):
+    def add_params(self, params: List[ParamData]):
         pass
 
     @abc.abstractmethod
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         pass
 
     @abc.abstractmethod
-    def add_block(self, block: _BlockData):
+    def add_block(self, block: BlockData):
         pass
 
     @abc.abstractmethod
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         pass
 
     @abc.abstractmethod
-    def remove_params(self, params: List[_ParamData]):
+    def remove_params(self, params: List[ParamData]):
         pass
 
     @abc.abstractmethod
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         pass
 
     @abc.abstractmethod
-    def remove_block(self, block: _BlockData):
+    def remove_block(self, block: BlockData):
         pass
 
     @abc.abstractmethod
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         pass
 
     @abc.abstractmethod
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         pass
 
     @abc.abstractmethod
     def update_params(self):
         pass
 
 
@@ -853,28 +849,28 @@
             raise RuntimeError('The results in the solver are no longer valid.')
 
     def get_primals(self, vars_to_load=None):
         self._assert_solution_still_valid()
         return self._solver.get_primals(vars_to_load=vars_to_load)
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         self._assert_solution_still_valid()
         return self._solver.get_duals(cons_to_load=cons_to_load)
 
     def get_slacks(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         self._assert_solution_still_valid()
         return self._solver.get_slacks(cons_to_load=cons_to_load)
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         self._assert_solution_still_valid()
         return self._solver.get_reduced_costs(vars_to_load=vars_to_load)
 
     def invalidate(self):
         self._valid = False
 
 
@@ -950,18 +946,18 @@
         if self.use_extensions and cmodel_available:
             self._expr_types = cmodel.PyomoExprTypes()
         self.add_block(model)
         if self._objective is None:
             self.set_objective(None)
 
     @abc.abstractmethod
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         pass
 
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         for v in variables:
             if id(v) in self._referenced_variables:
                 raise ValueError(
                     'variable {name} has already been added'.format(name=v.name)
                 )
             self._referenced_variables[id(v)] = [dict(), dict(), None]
             self._vars[id(v)] = (
@@ -971,44 +967,44 @@
                 v.fixed,
                 v.domain.get_interval(),
                 v.value,
             )
         self._add_variables(variables)
 
     @abc.abstractmethod
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         pass
 
-    def add_params(self, params: List[_ParamData]):
+    def add_params(self, params: List[ParamData]):
         for p in params:
             self._params[id(p)] = p
         self._add_params(params)
 
     @abc.abstractmethod
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         pass
 
-    def _check_for_new_vars(self, variables: List[_GeneralVarData]):
+    def _check_for_new_vars(self, variables: List[VarData]):
         new_vars = dict()
         for v in variables:
             v_id = id(v)
             if v_id not in self._referenced_variables:
                 new_vars[v_id] = v
         self.add_variables(list(new_vars.values()))
 
-    def _check_to_remove_vars(self, variables: List[_GeneralVarData]):
+    def _check_to_remove_vars(self, variables: List[VarData]):
         vars_to_remove = dict()
         for v in variables:
             v_id = id(v)
             ref_cons, ref_sos, ref_obj = self._referenced_variables[v_id]
             if len(ref_cons) == 0 and len(ref_sos) == 0 and ref_obj is None:
                 vars_to_remove[v_id] = v
         self.remove_variables(list(vars_to_remove.values()))
 
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         all_fixed_vars = dict()
         for con in cons:
             if con in self._named_expressions:
                 raise ValueError(
                     'constraint {name} has already been added'.format(name=con.name)
                 )
             self._active_constraints[con] = (con.lower, con.body, con.upper)
@@ -1030,18 +1026,18 @@
                     v.unfix()
                     all_fixed_vars[id(v)] = v
         self._add_constraints(cons)
         for v in all_fixed_vars.values():
             v.fix()
 
     @abc.abstractmethod
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         pass
 
-    def add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def add_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             if con in self._vars_referenced_by_con:
                 raise ValueError(
                     'constraint {name} has already been added'.format(name=con.name)
                 )
             self._active_constraints[con] = tuple()
             variables = con.get_variables()
@@ -1050,18 +1046,18 @@
             self._named_expressions[con] = list()
             self._vars_referenced_by_con[con] = variables
             for v in variables:
                 self._referenced_variables[id(v)][1][con] = None
         self._add_sos_constraints(cons)
 
     @abc.abstractmethod
-    def _set_objective(self, obj: _GeneralObjectiveData):
+    def _set_objective(self, obj: ObjectiveData):
         pass
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         if self._objective is not None:
             for v in self._vars_referenced_by_obj:
                 self._referenced_variables[id(v)][2] = None
             if not self._only_child_vars:
                 self._check_to_remove_vars(self._vars_referenced_by_obj)
             self._external_functions.pop(self._objective, None)
         if obj is not None:
@@ -1128,18 +1124,18 @@
             ]
         )
         obj = get_objective(block)
         if obj is not None:
             self.set_objective(obj)
 
     @abc.abstractmethod
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         pass
 
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         self._remove_constraints(cons)
         for con in cons:
             if con not in self._named_expressions:
                 raise ValueError(
                     'cannot remove constraint {name} - it was not added'.format(
                         name=con.name
                     )
@@ -1150,18 +1146,18 @@
                 self._check_to_remove_vars(self._vars_referenced_by_con[con])
             del self._active_constraints[con]
             del self._named_expressions[con]
             self._external_functions.pop(con, None)
             del self._vars_referenced_by_con[con]
 
     @abc.abstractmethod
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         pass
 
-    def remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def remove_sos_constraints(self, cons: List[SOSConstraintData]):
         self._remove_sos_constraints(cons)
         for con in cons:
             if con not in self._vars_referenced_by_con:
                 raise ValueError(
                     'cannot remove constraint {name} - it was not added'.format(
                         name=con.name
                     )
@@ -1170,18 +1166,18 @@
                 self._referenced_variables[id(v)][1].pop(con)
             self._check_to_remove_vars(self._vars_referenced_by_con[con])
             del self._active_constraints[con]
             del self._named_expressions[con]
             del self._vars_referenced_by_con[con]
 
     @abc.abstractmethod
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         pass
 
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         self._remove_variables(variables)
         for v in variables:
             v_id = id(v)
             if v_id not in self._referenced_variables:
                 raise ValueError(
                     'cannot remove variable {name} - it has not been added'.format(
                         name=v.name
@@ -1194,18 +1190,18 @@
                         name=v.name
                     )
                 )
             del self._referenced_variables[v_id]
             del self._vars[v_id]
 
     @abc.abstractmethod
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         pass
 
-    def remove_params(self, params: List[_ParamData]):
+    def remove_params(self, params: List[ParamData]):
         self._remove_params(params)
         for p in params:
             del self._params[id(p)]
 
     def remove_block(self, block):
         self.remove_constraints(
             [
@@ -1242,18 +1238,18 @@
                         ctype=Param, descend_into=True
                     )
                 ).values()
             )
         )
 
     @abc.abstractmethod
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         pass
 
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         for v in variables:
             self._vars[id(v)] = (
                 v,
                 v._lb,
                 v._ub,
                 v.fixed,
                 v.domain.get_interval(),
@@ -1330,20 +1326,20 @@
                     new_cons.append(c)
             for c in current_sos_dict.keys():
                 if c not in self._vars_referenced_by_con:
                     new_sos.append(c)
             for c in self._vars_referenced_by_con.keys():
                 if c not in current_cons_dict and c not in current_sos_dict:
                     if (c.ctype is Constraint) or (
-                        c.ctype is None and isinstance(c, _GeneralConstraintData)
+                        c.ctype is None and isinstance(c, ConstraintData)
                     ):
                         old_cons.append(c)
                     else:
                         assert (c.ctype is SOSConstraint) or (
-                            c.ctype is None and isinstance(c, _SOSConstraintData)
+                            c.ctype is None and isinstance(c, SOSConstraintData)
                         )
                         old_sos.append(c)
         self.remove_constraints(old_cons)
         self.remove_sos_constraints(old_sos)
         timer.stop('cons')
         timer.start('params')
         self.remove_params(old_params)
@@ -1525,15 +1521,15 @@
     TerminationCondition.licensingProblems: LegacySolutionStatus.error,
 }
 
 
 class LegacySolverInterface(object):
     def solve(
         self,
-        model: _BlockData,
+        model: BlockData,
         tee: bool = False,
         load_solutions: bool = True,
         logfile: Optional[str] = None,
         solnfile: Optional[str] = None,
         timelimit: Optional[float] = None,
         report_timing: bool = False,
         solver_io: Optional[str] = None,
@@ -1661,23 +1657,23 @@
             True if the solver license is valid. Otherwise, False.
 
         """
         return bool(self.available())
 
     @property
     def options(self):
-        for solver_name in ['gurobi', 'ipopt', 'cplex', 'cbc', 'highs']:
+        for solver_name in ['gurobi', 'ipopt', 'cplex', 'cbc', 'highs', 'maingo']:
             if hasattr(self, solver_name + '_options'):
                 return getattr(self, solver_name + '_options')
         raise NotImplementedError('Could not find the correct options')
 
     @options.setter
     def options(self, val):
         found = False
-        for solver_name in ['gurobi', 'ipopt', 'cplex', 'cbc', 'highs']:
+        for solver_name in ['gurobi', 'ipopt', 'cplex', 'cbc', 'highs', 'maingo']:
             if hasattr(self, solver_name + '_options'):
                 setattr(self, solver_name + '_options', val)
                 found = True
         if not found:
             raise NotImplementedError('Could not find the correct options')
 
     def __enter__(self):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/build.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/build.py`

 * *Files 12% similar despite different names*

```diff
@@ -12,23 +12,14 @@
 import shutil
 import glob
 import os
 import sys
 import tempfile
 
 
-def handleReadonly(function, path, excinfo):
-    excvalue = excinfo[1]
-    if excvalue.errno == errno.EACCES:
-        os.chmod(path, stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)  # 0777
-        function(path)
-    else:
-        raise
-
-
 def get_appsi_extension(in_setup=False, appsi_root=None):
     from pybind11.setup_helpers import Pybind11Extension
 
     if appsi_root is None:
         from pyomo.common.fileutils import this_file_dir
 
         appsi_root = this_file_dir()
@@ -62,14 +53,15 @@
 
 
 def build_appsi(args=[]):
     print('\n\n**** Building APPSI ****')
     from setuptools import Distribution
     from pybind11.setup_helpers import build_ext
     import pybind11.setup_helpers
+    from pyomo.common.cmake_builder import handleReadonly
     from pyomo.common.envvar import PYOMO_CONFIG_DIR
     from pyomo.common.fileutils import this_file_dir
 
     class appsi_build_ext(build_ext):
         def run(self):
             basedir = os.path.abspath(os.path.curdir)
             if self.inplace:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/cmodel_bindings.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/cmodel_bindings.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -59,15 +59,16 @@
   m.def("process_pyomo_vars", &process_pyomo_vars);
   m.def("create_vars", &create_vars);
   m.def("create_params", &create_params);
   m.def("create_constants", &create_constants);
   m.def("appsi_exprs_from_pyomo_exprs", &appsi_exprs_from_pyomo_exprs);
   m.def("appsi_expr_from_pyomo_expr", &appsi_expr_from_pyomo_expr);
   m.def("prep_for_repn", &prep_for_repn);
-  py::class_<PyomoExprTypes>(m, "PyomoExprTypes").def(py::init<>());
+  py::class_<PyomoExprTypes>(m, "PyomoExprTypes", py::module_local())
+      .def(py::init<>());
   py::class_<Node, std::shared_ptr<Node>>(m, "Node")
       .def("is_variable_type", &Node::is_variable_type)
       .def("is_param_type", &Node::is_param_type)
       .def("is_expression_type", &Node::is_expression_type)
       .def("is_operator_type", &Node::is_operator_type)
       .def("is_constant_type", &Node::is_constant_type)
       .def("is_leaf", &Node::is_leaf);
@@ -161,15 +162,15 @@
   py::class_<LPObjective, LPBase, Objective, std::shared_ptr<LPObjective>>(
       m, "LPObjective")
       .def(py::init<>());
   py::class_<LPWriter, Model>(m, "LPWriter")
       .def(py::init<>())
       .def("write", &LPWriter::write)
       .def("get_solve_cons", &LPWriter::get_solve_cons);
-  py::enum_<ExprType>(m, "ExprType")
+  py::enum_<ExprType>(m, "ExprType", py::module_local())
       .value("py_float", ExprType::py_float)
       .value("var", ExprType::var)
       .value("param", ExprType::param)
       .value("product", ExprType::product)
       .value("sum", ExprType::sum)
       .value("negation", ExprType::negation)
       .value("external_func", ExprType::external_func)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/common.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/common.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/common.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/common.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/expression.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/expression.cpp`

 * *Files 1% similar despite different names*

```diff
@@ -1544,15 +1544,18 @@
     break;
   }
   case var: {
     res = var_map[expr_types.id(expr)].cast<std::shared_ptr<Node>>();
     break;
   }
   case param: {
-    res = param_map[expr_types.id(expr)].cast<std::shared_ptr<Node>>();
+    if (expr.attr("parent_component")().attr("mutable").cast<bool>())
+        res = param_map[expr_types.id(expr)].cast<std::shared_ptr<Node>>();
+    else
+        res = std::make_shared<Constant>(expr.attr("value").cast<double>());
     break;
   }
   case product: {
     res = std::make_shared<MultiplyOperator>();
     break;
   }
   case sum: {
@@ -1785,15 +1788,16 @@
 int build_expression_tree(py::handle pyomo_expr,
                           std::shared_ptr<Node> appsi_expr, py::handle var_map,
                           py::handle param_map, PyomoExprTypes &expr_types) {
   int num_nodes = 0;
 
   if (expr_types.expr_type_map[py::type::of(pyomo_expr)].cast<ExprType>() ==
       named_expr)
-    pyomo_expr = pyomo_expr.attr("expr");
+    return build_expression_tree(pyomo_expr.attr("expr"), appsi_expr, var_map,
+                                 param_map, expr_types);
 
   if (appsi_expr->is_leaf()) {
     ;
   } else if (appsi_expr->is_binary_operator()) {
     num_nodes += 1;
     std::shared_ptr<BinaryOperator> oper =
         std::dynamic_pointer_cast<BinaryOperator>(appsi_expr);
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/expression.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/expression.hpp`

 * *Files 2% similar despite different names*

```diff
@@ -676,18 +676,18 @@
     expr_type_map[np_uint32] = py_float;
     expr_type_map[np_uint64] = py_float;
     expr_type_map[np_ulonglong] = py_float;
     expr_type_map[np_float16] = py_float;
     expr_type_map[np_float32] = py_float;
     expr_type_map[np_float64] = py_float;
     expr_type_map[ScalarVar] = var;
-    expr_type_map[_GeneralVarData] = var;
+    expr_type_map[VarData] = var;
     expr_type_map[AutoLinkedBinaryVar] = var;
     expr_type_map[ScalarParam] = param;
-    expr_type_map[_ParamData] = param;
+    expr_type_map[ParamData] = param;
     expr_type_map[MonomialTermExpression] = product;
     expr_type_map[ProductExpression] = product;
     expr_type_map[NPV_ProductExpression] = product;
     expr_type_map[SumExpression] = sum;
     expr_type_map[NPV_SumExpression] = sum;
     expr_type_map[NegationExpression] = negation;
     expr_type_map[NPV_NegationExpression] = negation;
@@ -696,15 +696,15 @@
     expr_type_map[PowExpression] = power;
     expr_type_map[NPV_PowExpression] = power;
     expr_type_map[DivisionExpression] = division;
     expr_type_map[NPV_DivisionExpression] = division;
     expr_type_map[UnaryFunctionExpression] = unary_func;
     expr_type_map[NPV_UnaryFunctionExpression] = unary_func;
     expr_type_map[LinearExpression] = linear;
-    expr_type_map[_GeneralExpressionData] = named_expr;
+    expr_type_map[ExpressionData] = named_expr;
     expr_type_map[ScalarExpression] = named_expr;
     expr_type_map[Integral] = named_expr;
     expr_type_map[ScalarIntegral] = named_expr;
     expr_type_map[NumericConstant] = numeric_constant;
     expr_type_map[_PyomoUnit] = pyomo_unit;
     expr_type_map[AbsExpression] = unary_abs;
     expr_type_map[NPV_AbsExpression] = unary_abs;
@@ -724,20 +724,20 @@
   py::type np_uint64 = np.attr("uint64");
   py::type np_ulonglong = np.attr("ulonglong");
   py::type np_float16 = np.attr("float16");
   py::type np_float32 = np.attr("float32");
   py::type np_float64 = np.attr("float64");
   py::object ScalarParam =
       py::module_::import("pyomo.core.base.param").attr("ScalarParam");
-  py::object _ParamData =
-      py::module_::import("pyomo.core.base.param").attr("_ParamData");
+  py::object ParamData =
+      py::module_::import("pyomo.core.base.param").attr("ParamData");
   py::object ScalarVar =
       py::module_::import("pyomo.core.base.var").attr("ScalarVar");
-  py::object _GeneralVarData =
-      py::module_::import("pyomo.core.base.var").attr("_GeneralVarData");
+  py::object VarData =
+      py::module_::import("pyomo.core.base.var").attr("VarData");
   py::object AutoLinkedBinaryVar =
       py::module_::import("pyomo.gdp.disjunct").attr("AutoLinkedBinaryVar");
   py::object numeric_expr = py::module_::import("pyomo.core.expr.numeric_expr");
   py::object NegationExpression = numeric_expr.attr("NegationExpression");
   py::object NPV_NegationExpression =
       numeric_expr.attr("NPV_NegationExpression");
   py::object ExternalFunctionExpression =
@@ -761,16 +761,16 @@
   py::object NPV_AbsExpression = numeric_expr.attr("NPV_AbsExpression");
   py::object NPV_UnaryFunctionExpression =
       numeric_expr.attr("NPV_UnaryFunctionExpression");
   py::object LinearExpression = numeric_expr.attr("LinearExpression");
   py::object NumericConstant =
       py::module_::import("pyomo.core.expr.numvalue").attr("NumericConstant");
   py::object expr_module = py::module_::import("pyomo.core.base.expression");
-  py::object _GeneralExpressionData =
-      expr_module.attr("_GeneralExpressionData");
+  py::object ExpressionData =
+      expr_module.attr("ExpressionData");
   py::object ScalarExpression = expr_module.attr("ScalarExpression");
   py::object ScalarIntegral =
       py::module_::import("pyomo.dae.integral").attr("ScalarIntegral");
   py::object Integral =
       py::module_::import("pyomo.dae.integral").attr("Integral");
   py::object _PyomoUnit =
       py::module_::import("pyomo.core.base.units_container").attr("_PyomoUnit");
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/fbbt_model.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/fbbt_model.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/fbbt_model.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/fbbt_model.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/interval.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/interval.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/interval.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/interval.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/lp_writer.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/lp_writer.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/lp_writer.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/lp_writer.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/model_base.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/model_base.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/model_base.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/model_base.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/nl_writer.cpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/nl_writer.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/src/nl_writer.hpp` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/src/nl_writer.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/cmodel/tests/test_import.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/cmodel/tests/test_import.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/examples/getting_started.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/examples/getting_started.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/examples/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/examples/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/examples/tests/test_examples.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/examples/tests/test_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/fbbt.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/fbbt.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,20 +14,20 @@
     ConfigDict,
     ConfigValue,
     NonNegativeFloat,
     NonNegativeInt,
 )
 from .cmodel import cmodel, cmodel_available
 from typing import List, Optional
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.objective import _GeneralObjectiveData, minimize, maximize
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.objective import ObjectiveData, minimize, maximize
+from pyomo.core.base.block import BlockData
 from pyomo.core.base import SymbolMap, TextLabeler
 from pyomo.common.errors import InfeasibleConstraintException
 
 
 class IntervalConfig(ConfigDict):
     """
     Attributes
@@ -117,15 +117,15 @@
 
         self._model = model
         self._cmodel = cmodel.FBBTModel()
         self.add_block(model)
         if self._objective is None:
             self.set_objective(None)
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         if self._symbolic_solver_labels:
             set_name = True
             symbol_map = self._symbol_map
             labeler = self._var_labeler
         else:
             set_name = False
             symbol_map = None
@@ -139,77 +139,77 @@
             self._rvar_map,
             set_name,
             symbol_map,
             labeler,
             False,
         )
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         cparams = cmodel.create_params(len(params))
         for ndx, p in enumerate(params):
             cp = cparams[ndx]
             cp.value = p.value
             self._param_map[id(p)] = cp
         if self._symbolic_solver_labels:
             for ndx, p in enumerate(params):
                 cp = cparams[ndx]
                 cp.name = self._symbol_map.getSymbol(p, self._param_labeler)
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         cmodel.process_fbbt_constraints(
             self._cmodel,
             self._pyomo_expr_types,
             cons,
             self._var_map,
             self._param_map,
             self._active_constraints,
             self._con_map,
             self._rcon_map,
         )
         if self._symbolic_solver_labels:
             for c, cc in self._con_map.items():
                 cc.name = self._symbol_map.getSymbol(c, self._con_labeler)
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError(
                 'IntervalTightener does not support SOS constraints'
             )
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         if self._symbolic_solver_labels:
             for c in cons:
                 self._symbol_map.removeSymbol(c)
         for c in cons:
             cc = self._con_map.pop(c)
             self._cmodel.remove_constraint(cc)
             del self._rcon_map[cc]
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError(
                 'IntervalTightener does not support SOS constraints'
             )
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         if self._symbolic_solver_labels:
             for v in variables:
                 self._symbol_map.removeSymbol(v)
         for v in variables:
             cvar = self._var_map.pop(id(v))
             del self._rvar_map[cvar]
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         if self._symbolic_solver_labels:
             for p in params:
                 self._symbol_map.removeSymbol(p)
         for p in params:
             del self._param_map[id(p)]
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         cmodel.process_pyomo_vars(
             self._pyomo_expr_types,
             variables,
             self._var_map,
             self._param_map,
             self._vars,
             self._rvar_map,
@@ -220,21 +220,21 @@
         )
 
     def update_params(self):
         for p_id, p in self._params.items():
             cp = self._param_map[p_id]
             cp.value = p.value
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         if self._symbolic_solver_labels:
             if self._objective is not None:
                 self._symbol_map.removeSymbol(self._objective)
         super().set_objective(obj)
 
-    def _set_objective(self, obj: _GeneralObjectiveData):
+    def _set_objective(self, obj: ObjectiveData):
         if obj is None:
             ce = cmodel.Constant(0)
             sense = 0
         else:
             ce = cmodel.appsi_expr_from_pyomo_expr(
                 obj.expr, self._var_map, self._param_map, self._pyomo_expr_types
             )
@@ -271,15 +271,15 @@
                 if not cc.active:
                     cons_to_deactivate.append(c)
         self.remove_constraints(cons_to_deactivate)
         for c in cons_to_deactivate:
             c.deactivate()
 
     def perform_fbbt(
-        self, model: _BlockData, symbolic_solver_labels: Optional[bool] = None
+        self, model: BlockData, symbolic_solver_labels: Optional[bool] = None
     ):
         if model is not self._model:
             self.set_instance(model, symbolic_solver_labels=symbolic_solver_labels)
         else:
             if (
                 symbolic_solver_labels is not None
                 and symbolic_solver_labels != self._symbolic_solver_labels
@@ -300,15 +300,15 @@
         finally:
             # we want to make sure the pyomo model and cmodel stay in sync
             # even if an exception is raised and caught
             self._update_pyomo_var_bounds()
             self._deactivate_satisfied_cons()
         return n_iter
 
-    def perform_fbbt_with_seed(self, model: _BlockData, seed_var: _GeneralVarData):
+    def perform_fbbt_with_seed(self, model: BlockData, seed_var: VarData):
         if model is not self._model:
             self.set_instance(model)
         else:
             self.update()
         try:
             n_iter = self._cmodel.perform_fbbt_with_seed(
                 self._var_map[id(seed_var)],
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/plugins.py`

 * *Files 24% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.extensions import ExtensionBuilderFactory
 from .base import SolverFactory
-from .solvers import Gurobi, Ipopt, Cbc, Cplex, Highs
+from .solvers import Gurobi, Ipopt, Cbc, Cplex, Highs, MAiNGO
 from .build import AppsiBuilder
 
 
 def load():
     ExtensionBuilderFactory.register('appsi')(AppsiBuilder)
     SolverFactory.register(
         name='gurobi', doc='Automated persistent interface to Gurobi'
@@ -26,7 +26,10 @@
     SolverFactory.register(name='ipopt', doc='Automated persistent interface to Ipopt')(
         Ipopt
     )
     SolverFactory.register(name='cbc', doc='Automated persistent interface to Cbc')(Cbc)
     SolverFactory.register(name='highs', doc='Automated persistent interface to Highs')(
         Highs
     )
+    SolverFactory.register(
+        name='maingo', doc='Automated persistent interface to MAiNGO'
+    )(MAiNGO)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/__init__.py` & `Pyomo-6.7.2/pyomo/duality/__init__.py`

 * *Files 16% similar despite different names*

```diff
@@ -5,13 +5,8 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from .gurobi import Gurobi, GurobiResults
-from .ipopt import Ipopt
-from .cbc import Cbc
-from .cplex import Cplex
-from .highs import Highs
-from .wntr import Wntr, WntrResults
+import pyomo.duality.collect
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/cbc.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/cbc.py`

 * *Files 6% similar despite different names*

```diff
@@ -22,19 +22,19 @@
 from pyomo.common.log import LogStream
 import logging
 import subprocess
 from pyomo.core.kernel.objective import minimize, maximize
 import math
 from pyomo.common.collections import ComponentMap
 from typing import Optional, Sequence, NoReturn, List, Mapping
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.block import _BlockData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.block import BlockData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.tee import TeeStream
 import sys
 from typing import Dict
 from pyomo.common.config import ConfigValue, NonNegativeInt
 from pyomo.common.errors import PyomoException
 from pyomo.contrib.appsi.cmodel import cmodel_available
@@ -160,42 +160,42 @@
     @property
     def symbol_map(self):
         return self._writer.symbol_map
 
     def set_instance(self, model):
         self._writer.set_instance(model)
 
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         self._writer.add_variables(variables)
 
-    def add_params(self, params: List[_ParamData]):
+    def add_params(self, params: List[ParamData]):
         self._writer.add_params(params)
 
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         self._writer.add_constraints(cons)
 
-    def add_block(self, block: _BlockData):
+    def add_block(self, block: BlockData):
         self._writer.add_block(block)
 
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         self._writer.remove_variables(variables)
 
-    def remove_params(self, params: List[_ParamData]):
+    def remove_params(self, params: List[ParamData]):
         self._writer.remove_params(params)
 
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         self._writer.remove_constraints(cons)
 
-    def remove_block(self, block: _BlockData):
+    def remove_block(self, block: BlockData):
         self._writer.remove_block(block)
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         self._writer.set_objective(obj)
 
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         self._writer.update_variables(variables)
 
     def update_params(self):
         self._writer.update_params()
 
     def solve(self, model, timer: HierarchicalTimer = None):
         StaleFlagManager.mark_all_as_stale()
@@ -436,16 +436,16 @@
                 results.best_objective_bound = math.inf
 
         results.solution_loader = PersistentSolutionLoader(solver=self)
 
         return results
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._last_results_object is None
             or self._last_results_object.best_feasible_objective is None
         ):
             raise RuntimeError(
                 'Solver does not currently have a valid solution. Please '
                 'check the termination condition.'
@@ -473,16 +473,16 @@
 
         if cons_to_load is None:
             return {k: v for k, v in self._dual_sol.items()}
         else:
             return {c: self._dual_sol[c] for c in cons_to_load}
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._last_results_object is None
             or self._last_results_object.termination_condition
             != TerminationCondition.optimal
         ):
             raise RuntimeError(
                 'Solver does not currently have valid reduced costs. Please '
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/cplex.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/cplex.py`

 * *Files 2% similar despite different names*

```diff
@@ -18,19 +18,19 @@
     PersistentSolutionLoader,
 )
 from pyomo.contrib.appsi.writers import LPWriter
 import logging
 import math
 from pyomo.common.collections import ComponentMap
 from typing import Optional, Sequence, NoReturn, List, Mapping, Dict
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.block import _BlockData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.block import BlockData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.common.timing import HierarchicalTimer
 import sys
 import time
 from pyomo.common.log import LogStream
 from pyomo.common.config import ConfigValue, NonNegativeInt
 from pyomo.common.errors import PyomoException
 from pyomo.contrib.appsi.cmodel import cmodel_available
@@ -175,42 +175,42 @@
     @property
     def update_config(self):
         return self._writer.update_config
 
     def set_instance(self, model):
         self._writer.set_instance(model)
 
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         self._writer.add_variables(variables)
 
-    def add_params(self, params: List[_ParamData]):
+    def add_params(self, params: List[ParamData]):
         self._writer.add_params(params)
 
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         self._writer.add_constraints(cons)
 
-    def add_block(self, block: _BlockData):
+    def add_block(self, block: BlockData):
         self._writer.add_block(block)
 
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         self._writer.remove_variables(variables)
 
-    def remove_params(self, params: List[_ParamData]):
+    def remove_params(self, params: List[ParamData]):
         self._writer.remove_params(params)
 
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         self._writer.remove_constraints(cons)
 
-    def remove_block(self, block: _BlockData):
+    def remove_block(self, block: BlockData):
         self._writer.remove_block(block)
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         self._writer.set_objective(obj)
 
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         self._writer.update_variables(variables)
 
     def update_params(self):
         self._writer.update_params()
 
     def solve(self, model, timer: HierarchicalTimer = None):
         StaleFlagManager.mark_all_as_stale()
@@ -358,16 +358,16 @@
                 timer.start('load solution')
                 self.load_vars()
                 timer.stop('load solution')
 
         return results
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._cplex_model.solution.get_solution_type()
             == self._cplex_model.solution.type.none
         ):
             raise RuntimeError(
                 'Solver does not currently have a valid solution. Please '
                 'check the termination condition.'
@@ -385,16 +385,16 @@
                 continue
             v = symbol_map.bySymbol[name]
             if self._writer._referenced_variables[id(v)]:
                 res[v] = val
         return res
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         if (
             self._cplex_model.solution.get_solution_type()
             == self._cplex_model.solution.type.none
         ):
             raise RuntimeError(
                 'Solver does not currently have valid duals. Please '
                 'check the termination condition.'
@@ -436,16 +436,16 @@
                     res[_con] = val
             else:
                 res[_con] = val
 
         return res
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._cplex_model.solution.get_solution_type()
             == self._cplex_model.solution.type.none
         ):
             raise RuntimeError(
                 'Solver does not currently have valid reduced costs. Please '
                 'check the termination condition.'
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/gurobi.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/gurobi.py`

 * *Files 2% similar despite different names*

```diff
@@ -19,18 +19,18 @@
 from pyomo.common.errors import PyomoException
 from pyomo.common.tee import capture_output, TeeStream
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.shutdown import python_is_shutting_down
 from pyomo.common.config import ConfigValue, NonNegativeInt
 from pyomo.core.kernel.objective import minimize, maximize
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
-from pyomo.core.base.var import Var, _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.param import _ParamData
+from pyomo.core.base.var import Var, VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.param import ParamData
 from pyomo.core.expr.numvalue import value, is_constant, is_fixed, native_numeric_types
 from pyomo.repn import generate_standard_repn
 from pyomo.core.expr.numeric_expr import NPV_MaxExpression, NPV_MinExpression
 from pyomo.contrib.appsi.base import (
     PersistentSolver,
     Results,
     TerminationCondition,
@@ -454,15 +454,15 @@
                     else:
                         mutable_bound.var = gurobipy_var
                     self._mutable_bounds[var_id, 'ub'] = (var, mutable_bound)
                 ub = min(value(_ub), ub)
 
         return lb, ub, vtype
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         var_names = list()
         vtypes = list()
         lbs = list()
         ubs = list()
         mutable_lbs = dict()
         mutable_ubs = dict()
         for ndx, var in enumerate(variables):
@@ -485,15 +485,15 @@
         for ndx, mutable_bound in mutable_lbs.items():
             mutable_bound.var = gurobi_vars[ndx]
         for ndx, mutable_bound in mutable_ubs.items():
             mutable_bound.var = gurobi_vars[ndx]
         self._vars_added_since_update.update(variables)
         self._needs_updated = True
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         pass
 
     def _reinit(self):
         saved_config = self.config
         saved_options = self.gurobi_options
         saved_update_config = self.update_config
         self.__init__(only_child_vars=self._only_child_vars)
@@ -575,15 +575,15 @@
         return (
             new_expr,
             repn.constant,
             mutable_linear_coefficients,
             mutable_quadratic_coefficients,
         )
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         for con in cons:
             conname = self._symbol_map.getSymbol(con, self._labeler)
             (
                 gurobi_expr,
                 repn_constant,
                 mutable_linear_coefficients,
                 mutable_quadratic_coefficients,
@@ -705,15 +705,15 @@
                 )
 
             self._pyomo_con_to_solver_con_map[con] = gurobipy_con
             self._solver_con_to_pyomo_con_map[id(gurobipy_con)] = con
         self._constraints_added_since_update.update(cons)
         self._needs_updated = True
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             conname = self._symbol_map.getSymbol(con, self._labeler)
             level = con.level
             if level == 1:
                 sos_type = gurobipy.GRB.SOS_TYPE1
             elif level == 2:
                 sos_type = gurobipy.GRB.SOS_TYPE2
@@ -731,54 +731,54 @@
                 weights.append(w)
 
             gurobipy_con = self._solver_model.addSOS(sos_type, gurobi_vars, weights)
             self._pyomo_sos_to_solver_sos_map[con] = gurobipy_con
         self._constraints_added_since_update.update(cons)
         self._needs_updated = True
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         for con in cons:
             if con in self._constraints_added_since_update:
                 self._update_gurobi_model()
             solver_con = self._pyomo_con_to_solver_con_map[con]
             self._solver_model.remove(solver_con)
             self._symbol_map.removeSymbol(con)
             del self._pyomo_con_to_solver_con_map[con]
             del self._solver_con_to_pyomo_con_map[id(solver_con)]
             self._range_constraints.discard(con)
             self._mutable_helpers.pop(con, None)
             self._mutable_quadratic_helpers.pop(con, None)
         self._needs_updated = True
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             if con in self._constraints_added_since_update:
                 self._update_gurobi_model()
             solver_sos_con = self._pyomo_sos_to_solver_sos_map[con]
             self._solver_model.remove(solver_sos_con)
             self._symbol_map.removeSymbol(con)
             del self._pyomo_sos_to_solver_sos_map[con]
         self._needs_updated = True
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         for var in variables:
             v_id = id(var)
             if var in self._vars_added_since_update:
                 self._update_gurobi_model()
             solver_var = self._pyomo_var_to_solver_var_map[v_id]
             self._solver_model.remove(solver_var)
             self._symbol_map.removeSymbol(var)
             del self._pyomo_var_to_solver_var_map[v_id]
             self._mutable_bounds.pop(v_id, None)
         self._needs_updated = True
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         pass
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         for var in variables:
             var_id = id(var)
             if var_id not in self._pyomo_var_to_solver_var_map:
                 raise ValueError(
                     'The Var provided to update_var needs to be added first: {0}'.format(
                         var
                     )
@@ -1191,15 +1191,15 @@
 
     def set_linear_constraint_attr(self, con, attr, val):
         """
         Set the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
                 CBasis
                 DStart
                 Lazy
@@ -1217,15 +1217,15 @@
 
     def set_var_attr(self, var, attr, val):
         """
         Set the value of an attribute on a gurobi variable.
 
         Parameters
         ----------
-        var: pyomo.core.base.var._GeneralVarData
+        var: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
                 Start
                 VarHintVal
                 VarHintPri
@@ -1252,15 +1252,15 @@
 
     def get_var_attr(self, var, attr):
         """
         Get the value of an attribute on a gurobi var.
 
         Parameters
         ----------
-        var: pyomo.core.base.var._GeneralVarData
+        var: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be retrieved.
         attr: str
             The attribute to get. See gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1268,15 +1268,15 @@
 
     def get_linear_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1284,15 +1284,15 @@
 
     def get_sos_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi sos constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.sos._SOSConstraintData
+        con: pyomo.core.base.sos.SOSConstraintData
             The pyomo SOS constraint for which the corresponding gurobi SOS constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1300,15 +1300,15 @@
 
     def get_quadratic_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi quadratic constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1421,15 +1421,15 @@
 
     def cbCut(self, con):
         """
         Add a cut within a callback.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The cut to add
         """
         if not con.active:
             raise ValueError('cbCut expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbCut expected a non-trivial constraint')
@@ -1506,15 +1506,15 @@
         for i, v in enumerate(vars):
             v.set_value(var_values[i], skip_validation=True)
 
     def cbLazy(self, con):
         """
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The lazy constraint to add
         """
         if not con.active:
             raise ValueError('cbLazy expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbLazy expected a non-trivial constraint')
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/highs.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/highs.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,18 +16,18 @@
 from pyomo.common.errors import PyomoException
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.config import ConfigValue, NonNegativeInt
 from pyomo.common.tee import TeeStream, capture_output
 from pyomo.common.log import LogStream
 from pyomo.core.kernel.objective import minimize, maximize
 from pyomo.core.base import SymbolMap
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.param import _ParamData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.param import ParamData
 from pyomo.core.expr.numvalue import value, is_constant
 from pyomo.repn import generate_standard_repn
 from pyomo.core.expr.numeric_expr import NPV_MaxExpression, NPV_MinExpression
 from pyomo.contrib.appsi.base import (
     PersistentSolver,
     Results,
     TerminationCondition,
@@ -172,19 +172,27 @@
     def available(self):
         if highspy_available:
             return self.Availability.FullLicense
         else:
             return self.Availability.NotFound
 
     def version(self):
-        version = (
-            highspy.HIGHS_VERSION_MAJOR,
-            highspy.HIGHS_VERSION_MINOR,
-            highspy.HIGHS_VERSION_PATCH,
-        )
+        try:
+            version = (
+                highspy.HIGHS_VERSION_MAJOR,
+                highspy.HIGHS_VERSION_MINOR,
+                highspy.HIGHS_VERSION_PATCH,
+            )
+        except AttributeError:
+            # Older versions of Highs do not have the above attributes
+            # and the solver version can only be obtained by making
+            # an instance of the solver class.
+            tmp = highspy.Highs()
+            version = (tmp.versionMajor(), tmp.versionMinor(), tmp.versionPatch())
+
         return version
 
     @property
     def config(self) -> HighsConfig:
         return self._config
 
     @config.setter
@@ -304,15 +312,15 @@
             if _lb is not None:
                 lb = max(value(_lb), lb)
             if _ub is not None:
                 ub = min(value(_ub), ub)
 
         return lb, ub, vtype
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         self._sol = None
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         lbs = list()
         ubs = list()
         indices = list()
         vtypes = list()
@@ -331,15 +339,15 @@
         self._solver_model.addVars(
             len(lbs), np.array(lbs, dtype=np.double), np.array(ubs, dtype=np.double)
         )
         self._solver_model.changeColsIntegrality(
             len(vtypes), np.array(indices), np.array(vtypes)
         )
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         pass
 
     def _reinit(self):
         saved_config = self.config
         saved_options = self.highs_options
         saved_update_config = self.update_config
         self.__init__(only_child_vars=self._only_child_vars)
@@ -372,15 +380,15 @@
                     self._expr_types = cmodel.PyomoExprTypes()
 
                 self._solver_model = highspy.Highs()
                 self.add_block(model)
                 if self._objective is None:
                     self.set_objective(None)
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         self._sol = None
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         current_num_cons = len(self._pyomo_con_to_solver_con_map)
         lbs = list()
         ubs = list()
         starts = list()
@@ -452,21 +460,21 @@
             np.array(ubs, dtype=np.double),
             len(coef_values),
             np.array(starts),
             np.array(var_indices),
             np.array(coef_values, dtype=np.double),
         )
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         if cons:
             raise NotImplementedError(
                 'Highs interface does not support SOS constraints'
             )
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         self._sol = None
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         indices_to_remove = list()
         for con in cons:
             con_ndx = self._pyomo_con_to_solver_con_map.pop(con)
             del self._solver_con_to_pyomo_con_map[con_ndx]
@@ -483,21 +491,21 @@
         self._pyomo_con_to_solver_con_map.clear()
         self._pyomo_con_to_solver_con_map.update(new_con_map)
         self._solver_con_to_pyomo_con_map.clear()
         self._solver_con_to_pyomo_con_map.update(
             {v: k for k, v in self._pyomo_con_to_solver_con_map.items()}
         )
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         if cons:
             raise NotImplementedError(
                 'Highs interface does not support SOS constraints'
             )
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         self._sol = None
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         indices_to_remove = list()
         for v in variables:
             v_id = id(v)
             v_ndx = self._pyomo_var_to_solver_var_map.pop(v_id)
@@ -511,18 +519,18 @@
         new_var_map = dict()
         for v_id in self._pyomo_var_to_solver_var_map.keys():
             new_var_map[v_id] = v_ndx
             v_ndx += 1
         self._pyomo_var_to_solver_var_map.clear()
         self._pyomo_var_to_solver_var_map.update(new_var_map)
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         pass
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         self._sol = None
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         indices = list()
         lbs = list()
         ubs = list()
         vtypes = list()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/ipopt.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/ipopt.py`

 * *Files 3% similar despite different names*

```diff
@@ -24,19 +24,19 @@
 import subprocess
 from pyomo.core.kernel.objective import minimize
 import math
 from pyomo.common.collections import ComponentMap
 from pyomo.core.expr.numvalue import value
 from pyomo.core.expr.visitor import replace_expressions
 from typing import Optional, Sequence, NoReturn, List, Mapping
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.block import _BlockData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.block import BlockData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.tee import TeeStream
 import sys
 from typing import Dict
 from pyomo.common.config import ConfigValue, NonNegativeInt
 from pyomo.common.errors import PyomoException
 import os
@@ -143,26 +143,27 @@
         self._solver_options = dict()
         self._writer = NLWriter(only_child_vars=only_child_vars)
         self._filename = None
         self._dual_sol = dict()
         self._primal_sol = ComponentMap()
         self._reduced_costs = ComponentMap()
         self._last_results_object: Optional[Results] = None
+        self._version_timeout = 2
 
     def available(self):
         if self.config.executable.path() is None:
             return self.Availability.NotFound
         elif not cmodel_available:
             return self.Availability.NeedsCompiledExtension
         return self.Availability.FullLicense
 
     def version(self):
         results = subprocess.run(
             [str(self.config.executable), '--version'],
-            timeout=1,
+            timeout=self._version_timeout,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
         )
         version = results.stdout.splitlines()[0]
         version = version.split(' ')[1]
         version = version.strip()
@@ -223,42 +224,42 @@
     def symbol_map(self):
         return self._writer.symbol_map
 
     def set_instance(self, model):
         self._writer.config.symbolic_solver_labels = self.config.symbolic_solver_labels
         self._writer.set_instance(model)
 
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         self._writer.add_variables(variables)
 
-    def add_params(self, params: List[_ParamData]):
+    def add_params(self, params: List[ParamData]):
         self._writer.add_params(params)
 
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         self._writer.add_constraints(cons)
 
-    def add_block(self, block: _BlockData):
+    def add_block(self, block: BlockData):
         self._writer.add_block(block)
 
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         self._writer.remove_variables(variables)
 
-    def remove_params(self, params: List[_ParamData]):
+    def remove_params(self, params: List[ParamData]):
         self._writer.remove_params(params)
 
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         self._writer.remove_constraints(cons)
 
-    def remove_block(self, block: _BlockData):
+    def remove_block(self, block: BlockData):
         self._writer.remove_block(block)
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         self._writer.set_objective(obj)
 
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         self._writer.update_variables(variables)
 
     def update_params(self):
         self._writer.update_params()
 
     def _write_options_file(self):
         f = open(self._filename + '.opt', 'w')
@@ -509,16 +510,16 @@
                 results.best_objective_bound = math.inf
 
         results.solution_loader = PersistentSolutionLoader(solver=self)
 
         return results
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._last_results_object is None
             or self._last_results_object.best_feasible_objective is None
         ):
             raise RuntimeError(
                 'Solver does not currently have a valid solution. Please '
                 'check the termination condition.'
@@ -529,17 +530,15 @@
             for v, val in self._primal_sol.items():
                 res[v] = val
         else:
             for v in vars_to_load:
                 res[v] = self._primal_sol[v]
         return res
 
-    def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ):
+    def get_duals(self, cons_to_load: Optional[Sequence[ConstraintData]] = None):
         if (
             self._last_results_object is None
             or self._last_results_object.termination_condition
             != TerminationCondition.optimal
         ):
             raise RuntimeError(
                 'Solver does not currently have valid duals. Please '
@@ -548,16 +547,16 @@
 
         if cons_to_load is None:
             return {k: v for k, v in self._dual_sol.items()}
         else:
             return {c: self._dual_sol[c] for c in cons_to_load}
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if (
             self._last_results_object is None
             or self._last_results_object.termination_condition
             != TerminationCondition.optimal
         ):
             raise RuntimeError(
                 'Solver does not currently have valid reduced costs. Please '
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_gurobi_persistent.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_gurobi_persistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_highs_persistent.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_highs_persistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_ipopt_persistent.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_ipopt_persistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_persistent_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_persistent_solvers.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 from pyomo.common.dependencies import attempt_import
 import pyomo.common.unittest as unittest
 
 parameterized, param_available = attempt_import('parameterized')
 parameterized = parameterized.parameterized
 from pyomo.contrib.appsi.base import TerminationCondition, Results, PersistentSolver
 from pyomo.contrib.appsi.cmodel import cmodel_available
-from pyomo.contrib.appsi.solvers import Gurobi, Ipopt, Cplex, Cbc, Highs
+from pyomo.contrib.appsi.solvers import Gurobi, Ipopt, Cplex, Cbc, Highs, MAiNGO
 from typing import Type
 from pyomo.core.expr.numeric_expr import LinearExpression
 import os
 
 numpy, numpy_available = attempt_import('numpy')
 import random
 from pyomo import gdp
@@ -32,19 +32,31 @@
 
 all_solvers = [
     ('gurobi', Gurobi),
     ('ipopt', Ipopt),
     ('cplex', Cplex),
     ('cbc', Cbc),
     ('highs', Highs),
+    ('maingo', MAiNGO),
 ]
-mip_solvers = [('gurobi', Gurobi), ('cplex', Cplex), ('cbc', Cbc), ('highs', Highs)]
-nlp_solvers = [('ipopt', Ipopt)]
-qcp_solvers = [('gurobi', Gurobi), ('ipopt', Ipopt), ('cplex', Cplex)]
-miqcqp_solvers = [('gurobi', Gurobi), ('cplex', Cplex)]
+mip_solvers = [
+    ('gurobi', Gurobi),
+    ('cplex', Cplex),
+    ('cbc', Cbc),
+    ('highs', Highs),
+    ('maingo', MAiNGO),
+]
+nlp_solvers = [('ipopt', Ipopt), ('maingo', MAiNGO)]
+qcp_solvers = [
+    ('gurobi', Gurobi),
+    ('ipopt', Ipopt),
+    ('cplex', Cplex),
+    ('maingo', MAiNGO),
+]
+miqcqp_solvers = [('gurobi', Gurobi), ('cplex', Cplex), ('maingo', MAiNGO)]
 only_child_vars_options = [True, False]
 
 
 """
 The tests in this file are used to ensure basic functionality/API works with all solvers
 
 Feature                                    Tested
@@ -168,22 +180,24 @@
         m = pe.ConcreteModel()
         m.x = pe.Var()
         m.obj = pe.Objective(expr=m.x)
         m.c = pe.Constraint(expr=(-1, m.x, 1))
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, -1)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c], 1)
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c], 1)
         m.obj.sense = pe.maximize
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, 1)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c], 1)
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c], 1)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_reduced_costs(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -192,39 +206,42 @@
         m.x = pe.Var(bounds=(-1, 1))
         m.y = pe.Var(bounds=(-2, 2))
         m.obj = pe.Objective(expr=3 * m.x + 4 * m.y)
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, -1)
         self.assertAlmostEqual(m.y.value, -2)
-        rc = opt.get_reduced_costs()
-        self.assertAlmostEqual(rc[m.x], 3)
-        self.assertAlmostEqual(rc[m.y], 4)
+        if opt_class != MAiNGO:
+            rc = opt.get_reduced_costs()
+            self.assertAlmostEqual(rc[m.x], 3)
+            self.assertAlmostEqual(rc[m.y], 4)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_reduced_costs2(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
             raise unittest.SkipTest
         m = pe.ConcreteModel()
         m.x = pe.Var(bounds=(-1, 1))
         m.obj = pe.Objective(expr=m.x)
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, -1)
-        rc = opt.get_reduced_costs()
-        self.assertAlmostEqual(rc[m.x], 1)
+        if opt_class != MAiNGO:
+            rc = opt.get_reduced_costs()
+            self.assertAlmostEqual(rc[m.x], 1)
         m.obj.sense = pe.maximize
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, 1)
-        rc = opt.get_reduced_costs()
-        self.assertAlmostEqual(rc[m.x], 1)
+        if opt_class != MAiNGO:
+            rc = opt.get_reduced_costs()
+            self.assertAlmostEqual(rc[m.x], 1)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_param_changes(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -248,17 +265,18 @@
             m.b2.value = b2
             res: Results = opt.solve(m)
             self.assertEqual(res.termination_condition, TerminationCondition.optimal)
             self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
             self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
             self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
             self.assertTrue(res.best_objective_bound <= m.y.value)
-            duals = opt.get_duals()
-            self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
-            self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
+            if opt_class != MAiNGO:
+                duals = opt.get_duals()
+                self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
+                self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_immutable_param(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         """
         This test is important because component_data_objects returns immutable params as floats.
@@ -286,17 +304,18 @@
             m.b2.value = b2
             res: Results = opt.solve(m)
             self.assertEqual(res.termination_condition, TerminationCondition.optimal)
             self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
             self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
             self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
             self.assertTrue(res.best_objective_bound <= m.y.value)
-            duals = opt.get_duals()
-            self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
-            self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
+            if opt_class != MAiNGO:
+                duals = opt.get_duals()
+                self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
+                self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_equality(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -320,17 +339,18 @@
             m.b2.value = b2
             res: Results = opt.solve(m)
             self.assertEqual(res.termination_condition, TerminationCondition.optimal)
             self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
             self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
             self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
             self.assertTrue(res.best_objective_bound <= m.y.value)
-            duals = opt.get_duals()
-            self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
-            self.assertAlmostEqual(duals[m.c2], -a1 / (a2 - a1))
+            if opt_class != MAiNGO:
+                duals = opt.get_duals()
+                self.assertAlmostEqual(duals[m.c1], (1 + a1 / (a2 - a1)))
+                self.assertAlmostEqual(duals[m.c2], -a1 / (a2 - a1))
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_linear_expression(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -390,17 +410,18 @@
             m.b2.value = b2
             res: Results = opt.solve(m)
             self.assertEqual(res.termination_condition, TerminationCondition.optimal)
             self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
             self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
             self.assertEqual(res.best_feasible_objective, None)
             self.assertEqual(res.best_objective_bound, None)
-            duals = opt.get_duals()
-            self.assertAlmostEqual(duals[m.c1], 0)
-            self.assertAlmostEqual(duals[m.c2], 0)
+            if opt_class != MAiNGO:
+                duals = opt.get_duals()
+                self.assertAlmostEqual(duals[m.c1], 0)
+                self.assertAlmostEqual(duals[m.c2], 0)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_add_remove_cons(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -419,40 +440,43 @@
         m.c2 = pe.Constraint(expr=m.y >= a2 * m.x + b2)
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
         self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
         self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
         self.assertTrue(res.best_objective_bound <= m.y.value)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a2 - a1)))
-        self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a2 - a1)))
+            self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
 
         m.c3 = pe.Constraint(expr=m.y >= a3 * m.x + b3)
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, (b3 - b1) / (a1 - a3))
         self.assertAlmostEqual(m.y.value, a1 * (b3 - b1) / (a1 - a3) + b1)
         self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
         self.assertTrue(res.best_objective_bound <= m.y.value)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a3 - a1)))
-        self.assertAlmostEqual(duals[m.c2], 0)
-        self.assertAlmostEqual(duals[m.c3], a1 / (a3 - a1))
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a3 - a1)))
+            self.assertAlmostEqual(duals[m.c2], 0)
+            self.assertAlmostEqual(duals[m.c3], a1 / (a3 - a1))
 
         del m.c3
         res = opt.solve(m)
         self.assertEqual(res.termination_condition, TerminationCondition.optimal)
         self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
         self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
         self.assertAlmostEqual(res.best_feasible_objective, m.y.value)
         self.assertTrue(res.best_objective_bound <= m.y.value)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a2 - a1)))
-        self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c1], -(1 + a1 / (a2 - a1)))
+            self.assertAlmostEqual(duals[m.c2], a1 / (a2 - a1))
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_results_infeasible(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -483,22 +507,23 @@
         self.assertAlmostEqual(m.y.value, None)
         self.assertTrue(res.best_feasible_objective is None)
 
         with self.assertRaisesRegex(
             RuntimeError, '.*does not currently have a valid solution.*'
         ):
             res.solution_loader.load_vars()
-        with self.assertRaisesRegex(
-            RuntimeError, '.*does not currently have valid duals.*'
-        ):
-            res.solution_loader.get_duals()
-        with self.assertRaisesRegex(
-            RuntimeError, '.*does not currently have valid reduced costs.*'
-        ):
-            res.solution_loader.get_reduced_costs()
+        if opt_class != MAiNGO:
+            with self.assertRaisesRegex(
+                RuntimeError, '.*does not currently have valid duals.*'
+            ):
+                res.solution_loader.get_duals()
+            with self.assertRaisesRegex(
+                RuntimeError, '.*does not currently have valid reduced costs.*'
+            ):
+                res.solution_loader.get_reduced_costs()
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_duals(self, name: str, opt_class: Type[PersistentSolver], only_child_vars):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
             raise unittest.SkipTest
         m = pe.ConcreteModel()
@@ -507,21 +532,22 @@
         m.obj = pe.Objective(expr=m.y)
         m.c1 = pe.Constraint(expr=m.y - m.x >= 0)
         m.c2 = pe.Constraint(expr=m.y + m.x - 2 >= 0)
 
         res = opt.solve(m)
         self.assertAlmostEqual(m.x.value, 1)
         self.assertAlmostEqual(m.y.value, 1)
-        duals = opt.get_duals()
-        self.assertAlmostEqual(duals[m.c1], 0.5)
-        self.assertAlmostEqual(duals[m.c2], 0.5)
-
-        duals = opt.get_duals(cons_to_load=[m.c1])
-        self.assertAlmostEqual(duals[m.c1], 0.5)
-        self.assertNotIn(m.c2, duals)
+        if opt_class != MAiNGO:
+            duals = opt.get_duals()
+            self.assertAlmostEqual(duals[m.c1], 0.5)
+            self.assertAlmostEqual(duals[m.c2], 0.5)
+
+            duals = opt.get_duals(cons_to_load=[m.c1])
+            self.assertAlmostEqual(duals[m.c1], 0.5)
+            self.assertNotIn(m.c2, duals)
 
     @parameterized.expand(input=_load_tests(qcp_solvers, only_child_vars_options))
     def test_mutable_quadratic_coefficient(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -668,15 +694,15 @@
 
     @parameterized.expand(input=_load_tests(nlp_solvers, only_child_vars_options))
     def test_fixed_vars_4(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         opt.update_config.treat_fixed_vars_as_params = True
-        if not opt.available():
+        if not opt.available() or opt_class == MAiNGO:
             raise unittest.SkipTest
         m = pe.ConcreteModel()
         m.x = pe.Var()
         m.y = pe.Var()
         m.obj = pe.Objective(expr=m.x**2 + m.y**2)
         m.c1 = pe.Constraint(expr=m.x == 2 / m.y)
         m.y.fix(1)
@@ -761,25 +787,27 @@
             res: Results = opt.solve(m)
             self.assertEqual(res.termination_condition, TerminationCondition.optimal)
             if sense is pe.minimize:
                 self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2), 6)
                 self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1, 6)
                 self.assertAlmostEqual(res.best_feasible_objective, m.y.value, 6)
                 self.assertTrue(res.best_objective_bound <= m.y.value + 1e-12)
-                duals = opt.get_duals()
-                self.assertAlmostEqual(duals[m.con1], (1 + a1 / (a2 - a1)), 6)
-                self.assertAlmostEqual(duals[m.con2], -a1 / (a2 - a1), 6)
+                if opt_class != MAiNGO:
+                    duals = opt.get_duals()
+                    self.assertAlmostEqual(duals[m.con1], (1 + a1 / (a2 - a1)), 6)
+                    self.assertAlmostEqual(duals[m.con2], -a1 / (a2 - a1), 6)
             else:
                 self.assertAlmostEqual(m.x.value, (c2 - c1) / (a1 - a2), 6)
                 self.assertAlmostEqual(m.y.value, a1 * (c2 - c1) / (a1 - a2) + c1, 6)
                 self.assertAlmostEqual(res.best_feasible_objective, m.y.value, 6)
                 self.assertTrue(res.best_objective_bound >= m.y.value - 1e-12)
-                duals = opt.get_duals()
-                self.assertAlmostEqual(duals[m.con1], (1 + a1 / (a2 - a1)), 6)
-                self.assertAlmostEqual(duals[m.con2], -a1 / (a2 - a1), 6)
+                if opt_class != MAiNGO:
+                    duals = opt.get_duals()
+                    self.assertAlmostEqual(duals[m.con1], (1 + a1 / (a2 - a1)), 6)
+                    self.assertAlmostEqual(duals[m.con2], -a1 / (a2 - a1), 6)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_add_and_remove_vars(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -833,21 +861,21 @@
             raise unittest.SkipTest
         m = pe.ConcreteModel()
         m.x = pe.Var()
         m.y = pe.Var()
         m.obj = pe.Objective(expr=m.x**2 + m.y**2)
         m.c1 = pe.Constraint(expr=m.y >= pe.exp(m.x))
         res = opt.solve(m)
-        self.assertAlmostEqual(m.x.value, -0.42630274815985264)
-        self.assertAlmostEqual(m.y.value, 0.6529186341994245)
+        self.assertAlmostEqual(m.x.value, -0.42630274815985264, 6)
+        self.assertAlmostEqual(m.y.value, 0.6529186341994245, 6)
 
     @parameterized.expand(input=_load_tests(nlp_solvers, only_child_vars_options))
     def test_log(self, name: str, opt_class: Type[PersistentSolver], only_child_vars):
         opt = opt_class(only_child_vars=only_child_vars)
-        if not opt.available():
+        if not opt.available() or opt_class == MAiNGO:
             raise unittest.SkipTest
         m = pe.ConcreteModel()
         m.x = pe.Var(initialize=1)
         m.y = pe.Var()
         m.obj = pe.Objective(expr=m.x**2 + m.y**2)
         m.c1 = pe.Constraint(expr=m.y <= pe.log(m.x))
         res = opt.solve(m)
@@ -915,14 +943,35 @@
         m.y.setlb(m.p)
         m.obj.sense = pe.minimize
         m.p.value = 3
         res = opt.solve(m)
         self.assertAlmostEqual(m.y.value, 3)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
+    def test_bounds_with_immutable_params(
+        self, name: str, opt_class: Type[PersistentSolver], only_child_vars
+    ):
+        # this test is for issue #2574
+        opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
+        if not opt.available():
+            raise unittest.SkipTest
+        m = pe.ConcreteModel()
+        m.p = pe.Param(mutable=False, initialize=1)
+        m.q = pe.Param([1, 2], mutable=False, initialize=10)
+        m.y = pe.Var()
+        m.y.setlb(m.p)
+        m.y.setub(m.q[1])
+        m.obj = pe.Objective(expr=m.y)
+        res = opt.solve(m)
+        self.assertAlmostEqual(m.y.value, 1)
+        m.y.setlb(m.q[2])
+        res = opt.solve(m)
+        self.assertAlmostEqual(m.y.value, 10)
+
+    @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_solution_loader(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
             raise unittest.SkipTest
         m = pe.ConcreteModel()
@@ -948,39 +997,40 @@
         self.assertIn(m.y, primals)
         self.assertAlmostEqual(primals[m.x], 1)
         self.assertAlmostEqual(primals[m.y], 1)
         primals = res.solution_loader.get_primals([m.y])
         self.assertNotIn(m.x, primals)
         self.assertIn(m.y, primals)
         self.assertAlmostEqual(primals[m.y], 1)
-        reduced_costs = res.solution_loader.get_reduced_costs()
-        self.assertIn(m.x, reduced_costs)
-        self.assertIn(m.y, reduced_costs)
-        self.assertAlmostEqual(reduced_costs[m.x], 1)
-        self.assertAlmostEqual(reduced_costs[m.y], 0)
-        reduced_costs = res.solution_loader.get_reduced_costs([m.y])
-        self.assertNotIn(m.x, reduced_costs)
-        self.assertIn(m.y, reduced_costs)
-        self.assertAlmostEqual(reduced_costs[m.y], 0)
-        duals = res.solution_loader.get_duals()
-        self.assertIn(m.c1, duals)
-        self.assertIn(m.c2, duals)
-        self.assertAlmostEqual(duals[m.c1], 1)
-        self.assertAlmostEqual(duals[m.c2], 0)
-        duals = res.solution_loader.get_duals([m.c1])
-        self.assertNotIn(m.c2, duals)
-        self.assertIn(m.c1, duals)
-        self.assertAlmostEqual(duals[m.c1], 1)
+        if opt_class != MAiNGO:
+            reduced_costs = res.solution_loader.get_reduced_costs()
+            self.assertIn(m.x, reduced_costs)
+            self.assertIn(m.y, reduced_costs)
+            self.assertAlmostEqual(reduced_costs[m.x], 1)
+            self.assertAlmostEqual(reduced_costs[m.y], 0)
+            reduced_costs = res.solution_loader.get_reduced_costs([m.y])
+            self.assertNotIn(m.x, reduced_costs)
+            self.assertIn(m.y, reduced_costs)
+            self.assertAlmostEqual(reduced_costs[m.y], 0)
+            duals = res.solution_loader.get_duals()
+            self.assertIn(m.c1, duals)
+            self.assertIn(m.c2, duals)
+            self.assertAlmostEqual(duals[m.c1], 1)
+            self.assertAlmostEqual(duals[m.c2], 0)
+            duals = res.solution_loader.get_duals([m.c1])
+            self.assertNotIn(m.c2, duals)
+            self.assertIn(m.c1, duals)
+            self.assertAlmostEqual(duals[m.c1], 1)
 
     @parameterized.expand(input=_load_tests(all_solvers, only_child_vars_options))
     def test_time_limit(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
-        if not opt.available():
+        if not opt.available() or opt_class == MAiNGO:
             raise unittest.SkipTest
         from sys import platform
 
         if platform == 'win32':
             raise unittest.SkipTest
 
         N = 30
@@ -1053,21 +1103,22 @@
         self.assertAlmostEqual(res.best_feasible_objective, 2)
         m.obj.expr = 3 * m.y
         res = opt.solve(m)
         self.assertAlmostEqual(res.best_feasible_objective, 3)
         m.obj.sense = pe.maximize
         opt.config.load_solution = False
         res = opt.solve(m)
-        self.assertIn(
-            res.termination_condition,
-            {
-                TerminationCondition.unbounded,
-                TerminationCondition.infeasibleOrUnbounded,
-            },
-        )
+        if opt_class != MAiNGO:
+            self.assertIn(
+                res.termination_condition,
+                {
+                    TerminationCondition.unbounded,
+                    TerminationCondition.infeasibleOrUnbounded,
+                },
+            )
         m.obj.sense = pe.minimize
         opt.config.load_solution = True
         m.obj = pe.Objective(expr=m.x * m.y)
         m.x.fix(2)
         res = opt.solve(m)
         self.assertAlmostEqual(res.best_feasible_objective, 6, 6)
         m.x.fix(3)
@@ -1156,27 +1207,27 @@
         m = pe.ConcreteModel()
         m.x = pe.Var(domain=pe.Binary)
         m.y = pe.Var()
         m.obj = pe.Objective(expr=m.y)
         m.c = pe.Constraint(expr=m.y >= m.x)
         m.x.fix(0)
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 0)
+        self.assertAlmostEqual(res.best_feasible_objective, 0, 5)
         m.x.fix(1)
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 1)
+        self.assertAlmostEqual(res.best_feasible_objective, 1, 5)
 
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         opt.update_config.treat_fixed_vars_as_params = False
         m.x.fix(0)
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 0)
+        self.assertAlmostEqual(res.best_feasible_objective, 0, 5)
         m.x.fix(1)
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 1)
+        self.assertAlmostEqual(res.best_feasible_objective, 1, 5)
 
     @parameterized.expand(input=_load_tests(mip_solvers, only_child_vars_options))
     def test_with_gdp(
         self, name: str, opt_class: Type[PersistentSolver], only_child_vars
     ):
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         if not opt.available():
@@ -1192,24 +1243,24 @@
         m.d2 = gdp.Disjunct()
         m.d2.c1 = pe.Constraint(expr=m.y >= m.x + 1)
         m.d2.c2 = pe.Constraint(expr=m.y >= -m.x + 1)
         m.disjunction = gdp.Disjunction(expr=[m.d2, m.d1])
         pe.TransformationFactory("gdp.bigm").apply_to(m)
 
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 1)
-        self.assertAlmostEqual(m.x.value, 0)
-        self.assertAlmostEqual(m.y.value, 1)
+        self.assertAlmostEqual(res.best_feasible_objective, 1, 6)
+        self.assertAlmostEqual(m.x.value, 0, 6)
+        self.assertAlmostEqual(m.y.value, 1, 6)
 
         opt: PersistentSolver = opt_class(only_child_vars=only_child_vars)
         opt.use_extensions = True
         res = opt.solve(m)
-        self.assertAlmostEqual(res.best_feasible_objective, 1)
-        self.assertAlmostEqual(m.x.value, 0)
-        self.assertAlmostEqual(m.y.value, 1)
+        self.assertAlmostEqual(res.best_feasible_objective, 1, 6)
+        self.assertAlmostEqual(m.x.value, 0, 6)
+        self.assertAlmostEqual(m.y.value, 1, 6)
 
     @parameterized.expand(input=all_solvers)
     def test_variables_elsewhere(self, name: str, opt_class: Type[PersistentSolver]):
         opt: PersistentSolver = opt_class(only_child_vars=False)
         if not opt.available():
             raise unittest.SkipTest
 
@@ -1334,39 +1385,44 @@
         m.a1 = pe.Param(mutable=True)
         m.a2 = pe.Param(mutable=True)
         m.b1 = pe.Param(mutable=True)
         m.b2 = pe.Param(mutable=True)
         m.obj = pe.Objective(expr=m.y)
         m.c1 = pe.Constraint(expr=(0, m.y - m.a1 * m.x - m.b1, None))
         m.c2 = pe.Constraint(expr=(None, -m.y + m.a2 * m.x + m.b2, 0))
-        m.dual = pe.Suffix(direction=pe.Suffix.IMPORT)
+        if opt_class != MAiNGO:
+            m.dual = pe.Suffix(direction=pe.Suffix.IMPORT)
 
         params_to_test = [(1, -1, 2, 1), (1, -2, 2, 1), (1, -1, 3, 1)]
         for a1, a2, b1, b2 in params_to_test:
             m.a1.value = a1
             m.a2.value = a2
             m.b1.value = b1
             m.b2.value = b2
             res = opt.solve(m)
             pe.assert_optimal_termination(res)
             self.assertAlmostEqual(m.x.value, (b2 - b1) / (a1 - a2))
             self.assertAlmostEqual(m.y.value, a1 * (b2 - b1) / (a1 - a2) + b1)
-            self.assertAlmostEqual(m.dual[m.c1], (1 + a1 / (a2 - a1)))
-            self.assertAlmostEqual(m.dual[m.c2], a1 / (a2 - a1))
+            if opt_class != MAiNGO:
+                self.assertAlmostEqual(m.dual[m.c1], (1 + a1 / (a2 - a1)))
+                self.assertAlmostEqual(m.dual[m.c2], a1 / (a2 - a1))
 
     @parameterized.expand(input=all_solvers)
     def test_load_solutions(self, name: str, opt_class: Type[PersistentSolver]):
         opt = pe.SolverFactory('appsi_' + name)
         if not opt.available(exception_flag=False):
             raise unittest.SkipTest
         m = pe.ConcreteModel()
         m.x = pe.Var()
         m.obj = pe.Objective(expr=m.x)
         m.c = pe.Constraint(expr=(-1, m.x, 1))
-        m.dual = pe.Suffix(direction=pe.Suffix.IMPORT)
+        if opt_class != MAiNGO:
+            m.dual = pe.Suffix(direction=pe.Suffix.IMPORT)
         res = opt.solve(m, load_solutions=False)
         pe.assert_optimal_termination(res)
         self.assertIsNone(m.x.value)
-        self.assertNotIn(m.c, m.dual)
+        if opt_class != MAiNGO:
+            self.assertNotIn(m.c, m.dual)
         m.solutions.load_from(res)
         self.assertAlmostEqual(m.x.value, -1)
-        self.assertAlmostEqual(m.dual[m.c], 1)
+        if opt_class != MAiNGO:
+            self.assertAlmostEqual(m.dual[m.c], 1)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/tests/test_wntr_persistent.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/tests/test_wntr_persistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/solvers/wntr.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/solvers/wntr.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,18 +35,18 @@
     NPV_UnaryFunctionExpression,
     NPV_AbsExpression,
 )
 from pyomo.common.errors import PyomoException
 from pyomo.common.collections import ComponentMap
 from pyomo.core.expr.numvalue import native_numeric_types
 from typing import Dict, Optional, List
-from pyomo.core.base.block import _BlockData
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.constraint import _GeneralConstraintData
+from pyomo.core.base.block import BlockData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.constraint import ConstraintData
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
 from pyomo.common.dependencies import attempt_import
 from pyomo.core.staleflag import StaleFlagManager
 from pyomo.contrib.appsi.cmodel import cmodel, cmodel_available
 
 wntr, wntr_available = attempt_import('wntr')
@@ -174,15 +174,15 @@
                     'set opt.config.load_solution=False. If using the environ.SolverFactory '
                     'interface, you can set opt.solve(model, load_solutions = False). '
                     'Then you can check results.termination_condition and '
                     'results.best_feasible_objective before loading a solution.'
                 )
         return results
 
-    def solve(self, model: _BlockData, timer: HierarchicalTimer = None) -> Results:
+    def solve(self, model: BlockData, timer: HierarchicalTimer = None) -> Results:
         StaleFlagManager.mark_all_as_stale()
         if self._last_results_object is not None:
             self._last_results_object.solution_loader.invalidate()
         if timer is None:
             timer = HierarchicalTimer()
         if model is not self._model:
             timer.start('set_instance')
@@ -235,15 +235,15 @@
 
         self._solver_model = wntr.sim.aml.aml.Model()
         self._solver_model._wntr_fixed_var_params = wntr.sim.aml.aml.ParamDict()
         self._solver_model._wntr_fixed_var_cons = wntr.sim.aml.aml.ConstraintDict()
 
         self.add_block(model)
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         aml = wntr.sim.aml.aml
         for var in variables:
             varname = self._symbol_map.getSymbol(var, self._labeler)
             _v, _lb, _ub, _fixed, _domain_interval, _value = self._vars[id(var)]
             lb, ub, step = _domain_interval
             if (
                 _lb is not None
@@ -266,23 +266,23 @@
                 )
                 wntr_expr = wntr_var - param
                 self._solver_model._wntr_fixed_var_cons[id(var)] = aml.Constraint(
                     wntr_expr
                 )
             self._needs_updated = True
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         aml = wntr.sim.aml.aml
         for p in params:
             pname = self._symbol_map.getSymbol(p, self._labeler)
             wntr_p = aml.Param(p.value)
             setattr(self._solver_model, pname, wntr_p)
             self._pyomo_param_to_solver_param_map[id(p)] = wntr_p
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         aml = wntr.sim.aml.aml
         for con in cons:
             if not con.equality:
                 raise ValueError(
                     f"WNTR's newtwon solver only supports equality constraints: {con.name}"
                 )
             conname = self._symbol_map.getSymbol(con, self._labeler)
@@ -290,43 +290,43 @@
                 con.body - con.upper
             )
             wntr_con = aml.Constraint(wntr_expr)
             setattr(self._solver_model, conname, wntr_con)
             self._pyomo_con_to_solver_con_map[con] = wntr_con
             self._needs_updated = True
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         for con in cons:
             solver_con = self._pyomo_con_to_solver_con_map[con]
             delattr(self._solver_model, solver_con.name)
             self._symbol_map.removeSymbol(con)
             del self._pyomo_con_to_solver_con_map[con]
             self._needs_updated = True
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         for var in variables:
             v_id = id(var)
             solver_var = self._pyomo_var_to_solver_var_map[v_id]
             delattr(self._solver_model, solver_var.name)
             self._symbol_map.removeSymbol(var)
             del self._pyomo_var_to_solver_var_map[v_id]
             if v_id in self._solver_model._wntr_fixed_var_params:
                 del self._solver_model._wntr_fixed_var_params[v_id]
                 del self._solver_model._wntr_fixed_var_cons[v_id]
             self._needs_updated = True
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         for p in params:
             p_id = id(p)
             solver_param = self._pyomo_param_to_solver_param_map[p_id]
             delattr(self._solver_model, solver_param.name)
             self._symbol_map.removeSymbol(p)
             del self._pyomo_param_to_solver_param_map[p_id]
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         aml = wntr.sim.aml.aml
         for var in variables:
             v_id = id(var)
             solver_var = self._pyomo_var_to_solver_var_map[v_id]
             _v, _lb, _ub, _fixed, _domain_interval, _value = self._vars[v_id]
             lb, ub, step = _domain_interval
             if (
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_base.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_fbbt.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_fbbt.py`

 * *Files 3% similar despite different names*

```diff
@@ -147,7 +147,20 @@
             m.e[i].expr = i * m.x[i]
         m.c = pe.Constraint(expr=sum(m.e.values()) == 0)
         it = appsi.fbbt.IntervalTightener()
         it.perform_fbbt(m)
         for x in m.x.values():
             self.assertAlmostEqual(x.lb, 0)
             self.assertAlmostEqual(x.ub, 0)
+
+    def test_named_exprs_nest(self):
+        # test for issue #3184
+        m = pe.ConcreteModel()
+        m.x = pe.Var()
+        m.e = pe.Expression(expr=m.x + 1)
+        m.f = pe.Expression(expr=m.e)
+        m.c = pe.Constraint(expr=(0, m.f, 0))
+        it = appsi.fbbt.IntervalTightener()
+        it.perform_fbbt(m)
+        for x in m.x.values():
+            self.assertAlmostEqual(x.lb, -1)
+            self.assertAlmostEqual(x.ub, -1)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/tests/test_interval.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/tests/test_interval.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/utils/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/utils/collect_vars_and_named_exprs.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/utils/collect_vars_and_named_exprs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/utils/get_objective.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/utils/get_objective.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/utils/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/utils/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/utils/tests/test_collect_vars_and_named_exprs.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/utils/tests/test_collect_vars_and_named_exprs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/config.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/lp_writer.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/lp_writer.py`

 * *Files 5% similar despite different names*

```diff
@@ -6,20 +6,20 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from typing import List
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.objective import _GeneralObjectiveData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.objective import ObjectiveData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.block import BlockData
 from pyomo.repn.standard_repn import generate_standard_repn
 from pyomo.core.expr.numvalue import value
 from pyomo.contrib.appsi.base import PersistentBase
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.core.kernel.objective import minimize, maximize
 from .config import WriterConfig
@@ -73,66 +73,66 @@
 
         self._writer = cmodel.LPWriter()
 
         self.add_block(model)
         if self._objective is None:
             self.set_objective(None)
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         cmodel.process_pyomo_vars(
             self._expr_types,
             variables,
             self._pyomo_var_to_solver_var_map,
             self._pyomo_param_to_solver_param_map,
             self._vars,
             self._solver_var_to_pyomo_var_map,
             True,
             self._symbol_map,
             self._var_labeler,
             False,
         )
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         cparams = cmodel.create_params(len(params))
         for ndx, p in enumerate(params):
             cp = cparams[ndx]
             cp.name = self._symbol_map.getSymbol(p, self._param_labeler)
             cp.value = p.value
             self._pyomo_param_to_solver_param_map[id(p)] = cp
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         cmodel.process_lp_constraints(cons, self)
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError('LP writer does not yet support SOS constraints')
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         for c in cons:
             cc = self._pyomo_con_to_solver_con_map.pop(c)
             self._writer.remove_constraint(cc)
             self._symbol_map.removeSymbol(c)
             del self._solver_con_to_pyomo_con_map[cc]
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError('LP writer does not yet support SOS constraints')
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         for v in variables:
             cvar = self._pyomo_var_to_solver_var_map.pop(id(v))
             del self._solver_var_to_pyomo_var_map[cvar]
             self._symbol_map.removeSymbol(v)
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         for p in params:
             del self._pyomo_param_to_solver_param_map[id(p)]
             self._symbol_map.removeSymbol(p)
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         cmodel.process_pyomo_vars(
             self._expr_types,
             variables,
             self._pyomo_var_to_solver_var_map,
             self._pyomo_param_to_solver_param_map,
             self._vars,
             self._solver_var_to_pyomo_var_map,
@@ -143,15 +143,15 @@
         )
 
     def update_params(self):
         for p_id, p in self._params.items():
             cp = self._pyomo_param_to_solver_param_map[p_id]
             cp.value = p.value
 
-    def _set_objective(self, obj: _GeneralObjectiveData):
+    def _set_objective(self, obj: ObjectiveData):
         cobj = cmodel.process_lp_objective(
             self._expr_types,
             obj,
             self._pyomo_var_to_solver_var_map,
             self._pyomo_param_to_solver_param_map,
         )
         if obj is None:
@@ -163,15 +163,15 @@
                 sense = 0
             else:
                 sense = 1
         cobj.sense = sense
         cobj.name = cname
         self._writer.objective = cobj
 
-    def write(self, model: _BlockData, filename: str, timer: HierarchicalTimer = None):
+    def write(self, model: BlockData, filename: str, timer: HierarchicalTimer = None):
         if timer is None:
             timer = HierarchicalTimer()
         if model is not self._model:
             timer.start('set_instance')
             self.set_instance(model)
             timer.stop('set_instance')
         else:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/nl_writer.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/nl_writer.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,20 +6,20 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from typing import List
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.objective import _GeneralObjectiveData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.objective import ObjectiveData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.block import BlockData
 from pyomo.repn.standard_repn import generate_standard_repn
 from pyomo.core.expr.numvalue import value
 from pyomo.contrib.appsi.base import PersistentBase
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.core.kernel.objective import minimize
 from .config import WriterConfig
@@ -74,15 +74,15 @@
         self._writer = cmodel.NLWriter()
 
         self.add_block(model)
         if self._objective is None:
             self.set_objective(None)
         self._set_pyomo_amplfunc_env()
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         if self.config.symbolic_solver_labels:
             set_name = True
             symbol_map = self._symbol_map
             labeler = self._var_labeler
         else:
             set_name = False
             symbol_map = None
@@ -96,76 +96,76 @@
             self._solver_var_to_pyomo_var_map,
             set_name,
             symbol_map,
             labeler,
             False,
         )
 
-    def _add_params(self, params: List[_ParamData]):
+    def _add_params(self, params: List[ParamData]):
         cparams = cmodel.create_params(len(params))
         for ndx, p in enumerate(params):
             cp = cparams[ndx]
             cp.value = p.value
             self._pyomo_param_to_solver_param_map[id(p)] = cp
         if self.config.symbolic_solver_labels:
             for ndx, p in enumerate(params):
                 cp = cparams[ndx]
                 cp.name = self._symbol_map.getSymbol(p, self._param_labeler)
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         cmodel.process_nl_constraints(
             self._writer,
             self._expr_types,
             cons,
             self._pyomo_var_to_solver_var_map,
             self._pyomo_param_to_solver_param_map,
             self._active_constraints,
             self._pyomo_con_to_solver_con_map,
             self._solver_con_to_pyomo_con_map,
         )
         if self.config.symbolic_solver_labels:
             for c, cc in self._pyomo_con_to_solver_con_map.items():
                 cc.name = self._symbol_map.getSymbol(c, self._con_labeler)
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError('NL writer does not support SOS constraints')
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         if self.config.symbolic_solver_labels:
             for c in cons:
                 self._symbol_map.removeSymbol(c)
                 self._con_labeler.remove_obj(c)
         for c in cons:
             cc = self._pyomo_con_to_solver_con_map.pop(c)
             self._writer.remove_constraint(cc)
             del self._solver_con_to_pyomo_con_map[cc]
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         if len(cons) != 0:
             raise NotImplementedError('NL writer does not support SOS constraints')
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         if self.config.symbolic_solver_labels:
             for v in variables:
                 self._symbol_map.removeSymbol(v)
                 self._var_labeler.remove_obj(v)
         for v in variables:
             cvar = self._pyomo_var_to_solver_var_map.pop(id(v))
             del self._solver_var_to_pyomo_var_map[cvar]
 
-    def _remove_params(self, params: List[_ParamData]):
+    def _remove_params(self, params: List[ParamData]):
         if self.config.symbolic_solver_labels:
             for p in params:
                 self._symbol_map.removeSymbol(p)
                 self._param_labeler.remove_obj(p)
         for p in params:
             del self._pyomo_param_to_solver_param_map[id(p)]
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         cmodel.process_pyomo_vars(
             self._expr_types,
             variables,
             self._pyomo_var_to_solver_var_map,
             self._pyomo_param_to_solver_param_map,
             self._vars,
             self._solver_var_to_pyomo_var_map,
@@ -176,15 +176,15 @@
         )
 
     def update_params(self):
         for p_id, p in self._params.items():
             cp = self._pyomo_param_to_solver_param_map[p_id]
             cp.value = p.value
 
-    def _set_objective(self, obj: _GeneralObjectiveData):
+    def _set_objective(self, obj: ObjectiveData):
         if obj is None:
             const = cmodel.Constant(0)
             lin_vars = list()
             lin_coef = list()
             nonlin = cmodel.Constant(0)
             sense = 0
         else:
@@ -228,15 +228,15 @@
                 sense = 0
             else:
                 sense = 1
         cobj = cmodel.NLObjective(const, lin_coef, lin_vars, nonlin)
         cobj.sense = sense
         self._writer.objective = cobj
 
-    def write(self, model: _BlockData, filename: str, timer: HierarchicalTimer = None):
+    def write(self, model: BlockData, filename: str, timer: HierarchicalTimer = None):
         if timer is None:
             timer = HierarchicalTimer()
         if model is not self._model:
             timer.start('set_instance')
             self.set_instance(model)
             timer.stop('set_instance')
         else:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/appsi/writers/tests/test_nl_writer.py` & `Pyomo-6.7.2/pyomo/contrib/appsi/writers/tests/test_nl_writer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/benders/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/benders_cuts.py` & `Pyomo-6.7.2/pyomo/contrib/benders/benders_cuts.py`

 * *Files 0% similar despite different names*

```diff
@@ -5,15 +5,15 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.core.base.block import _BlockData, declare_custom_block
+from pyomo.core.base.block import BlockData, declare_custom_block
 import pyomo.environ as pyo
 from pyomo.solvers.plugins.solvers.persistent_solver import PersistentSolver
 from pyomo.core.expr.visitor import identify_variables
 from pyomo.common.collections import ComponentSet
 
 try:
     from mpi4py import MPI
@@ -162,21 +162,21 @@
                 b.aux_cons.add(body_lower <= 0)
             _del_con(c)
 
     b.obj_con = pyo.Constraint(expr=orig_obj_expr - b._eta - b._z <= 0)
 
 
 @declare_custom_block(name='BendersCutGenerator')
-class BendersCutGeneratorData(_BlockData):
+class BendersCutGeneratorData(BlockData):
     def __init__(self, component):
         if not mpi4py_available:
             raise ImportError('BendersCutGenerator requires mpi4py.')
         if not numpy_available:
             raise ImportError('BendersCutGenerator requires numpy.')
-        _BlockData.__init__(self, component)
+        BlockData.__init__(self, component)
 
         self.num_subproblems_by_rank = 0  # np.zeros(self.comm.Get_size())
         self.subproblems = list()
         self.complicating_vars_maps = list()
         self.root_vars = list()
         self.root_vars_indices = pyo.ComponentMap()
         self.root_etas = list()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/benders/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/examples/farmer.py` & `Pyomo-6.7.2/pyomo/contrib/benders/examples/farmer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/examples/grothey_ex.py` & `Pyomo-6.7.2/pyomo/contrib/benders/examples/grothey_ex.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/benders/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/benders/tests/test_benders.py` & `Pyomo-6.7.2/pyomo/contrib/benders/tests/test_benders.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/community_graph.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/community_graph.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/detection.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/detection.py`

 * *Files 0% similar despite different names*

```diff
@@ -27,15 +27,15 @@
     ComponentMap,
     Block,
     Var,
     Constraint,
     Objective,
     ConstraintList,
 )
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.core.expr.visitor import replace_expressions, identify_variables
 from pyomo.contrib.community_detection.community_graph import generate_model_graph
 from pyomo.common.dependencies import networkx as nx
 from pyomo.common.dependencies.matplotlib import pyplot as plt
 from itertools import combinations
 
 import copy
@@ -746,15 +746,15 @@
                             id(variable_in_stored_constraint)
                         ] = variable_in_new_model
 
                 # TODO - Is there a better way to check whether something is actually an objective? (as done below)
                 # Check to see whether 'stored_constraint' is actually an objective (since constraints and objectives
                 # grouped together)
                 if self.with_objective and isinstance(
-                    stored_constraint, (_GeneralObjectiveData, Objective)
+                    stored_constraint, (ObjectiveData, Objective)
                 ):
                     # If the constraint is actually an objective, we add it to the block as an objective
                     new_objective = Objective(
                         expr=replace_expressions(
                             stored_constraint.expr, replace_variables_in_expression_map
                         )
                     )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/event_log.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/event_log.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/community_detection/tests/test_detection.py` & `Pyomo-6.7.2/pyomo/contrib/community_detection/tests/test_detection.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/cp/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -13,14 +13,27 @@
     IntervalVar,
     IntervalVarStartTime,
     IntervalVarEndTime,
     IntervalVarLength,
     IntervalVarPresence,
 )
 from pyomo.contrib.cp.repn.docplex_writer import DocplexWriter, CPOptimizerSolver
+from pyomo.contrib.cp.sequence_var import SequenceVar
+from pyomo.contrib.cp.scheduling_expr.sequence_expressions import (
+    no_overlap,
+    first_in_sequence,
+    last_in_sequence,
+    before_in_sequence,
+    predecessor_to,
+)
+from pyomo.contrib.cp.scheduling_expr.scheduling_logic import (
+    alternative,
+    spans,
+    synchronize,
+)
 from pyomo.contrib.cp.scheduling_expr.step_function_expressions import (
     AlwaysIn,
     Step,
     Pulse,
 )
 
 # register logical_to_disjunctive transformation
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/interval_var.py` & `Pyomo-6.7.2/pyomo/contrib/cp/interval_var.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,27 +7,29 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.collections import ComponentSet
 from pyomo.common.pyomo_typing import overload
+from pyomo.contrib.cp.scheduling_expr.scheduling_logic import SpanExpression
 from pyomo.contrib.cp.scheduling_expr.precedence_expressions import (
     BeforeExpression,
     AtExpression,
 )
 
 from pyomo.core import Integers, value
 from pyomo.core.base import Any, ScalarVar, ScalarBooleanVar
-from pyomo.core.base.block import _BlockData, Block
+from pyomo.core.base.block import BlockData, Block
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.indexed_component import IndexedComponent, UnindexedComponent_set
 from pyomo.core.base.initializer import BoundInitializer, Initializer
 from pyomo.core.expr import GetItemExpression
+from pyomo.core.expr.logical_expr import _flattened
 
 
 class IntervalVarTimePoint(ScalarVar):
     """This class defines the abstract interface for a single variable
     denoting a start or end time point of an IntervalVar"""
 
     __slots__ = ()
@@ -45,60 +47,62 @@
         return AtExpression((self, time, delay))
 
 
 class IntervalVarStartTime(IntervalVarTimePoint):
     """This class defines a single variable denoting a start time point
     of an IntervalVar"""
 
-    def __init__(self):
+    def __init__(self, *args, **kwd):
         super().__init__(domain=Integers, ctype=IntervalVarStartTime)
 
 
 class IntervalVarEndTime(IntervalVarTimePoint):
     """This class defines a single variable denoting an end time point
     of an IntervalVar"""
 
-    def __init__(self):
+    def __init__(self, *args, **kwd):
         super().__init__(domain=Integers, ctype=IntervalVarEndTime)
 
 
 class IntervalVarLength(ScalarVar):
     """This class defines the abstract interface for a single variable
     denoting the length of an IntervalVar"""
 
     __slots__ = ()
 
-    def __init__(self):
+    def __init__(self, *args, **kwd):
         super().__init__(domain=Integers, ctype=IntervalVarLength)
 
     def get_associated_interval_var(self):
         return self.parent_block()
 
 
 class IntervalVarPresence(ScalarBooleanVar):
     """This class defines the abstract interface for a single Boolean variable
     denoting whether or not an IntervalVar is scheduled"""
 
     __slots__ = ()
 
-    def __init__(self):
+    def __init__(self, *args, **kwd):
+        # TODO: adding args and kwd above made Reference work, but we
+        # probably shouldn't just swallow them, right?
         super().__init__(ctype=IntervalVarPresence)
 
     def get_associated_interval_var(self):
         return self.parent_block()
 
 
-class IntervalVarData(_BlockData):
+class IntervalVarData(BlockData):
     """This class defines the abstract interface for a single interval variable."""
 
     # We will put our four variables on this, and everything else is off limits.
     _Block_reserved_words = Any
 
     def __init__(self, component=None):
-        _BlockData.__init__(self, component)
+        BlockData.__init__(self, component)
 
         with self._declare_reserved_components():
             self.is_present = IntervalVarPresence()
             self.start_time = IntervalVarStartTime()
             self.end_time = IntervalVarEndTime()
             self.length = IntervalVarLength()
 
@@ -118,14 +122,17 @@
                 "Cannot set 'optional' to %s: Must be True or False." % val
             )
         if val:
             self.is_present.unfix()
         else:
             self.is_present.fix(True)
 
+    def spans(self, *args):
+        return SpanExpression([self] + list(_flattened(args)))
+
 
 @ModelComponentFactory.register("Interval variables for scheduling.")
 class IntervalVar(Block):
     """An interval variable, which may be defined over an index.
 
     Args:
         start (tuple of two integers): Feasible range for the
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/cp/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/repn/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/cp/repn/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/repn/docplex_writer.py` & `Pyomo-6.7.2/pyomo/contrib/cp/repn/docplex_writer.py`

 * *Files 5% similar despite different names*

```diff
@@ -26,18 +26,35 @@
     IntervalVarEndTime,
     IntervalVarPresence,
     IntervalVarLength,
     ScalarIntervalVar,
     IntervalVarData,
     IndexedIntervalVar,
 )
+from pyomo.contrib.cp.sequence_var import (
+    SequenceVar,
+    ScalarSequenceVar,
+    SequenceVarData,
+)
+from pyomo.contrib.cp.scheduling_expr.scheduling_logic import (
+    AlternativeExpression,
+    SpanExpression,
+    SynchronizeExpression,
+)
 from pyomo.contrib.cp.scheduling_expr.precedence_expressions import (
     BeforeExpression,
     AtExpression,
 )
+from pyomo.contrib.cp.scheduling_expr.sequence_expressions import (
+    NoOverlapExpression,
+    FirstInSequenceExpression,
+    LastInSequenceExpression,
+    BeforeInSequenceExpression,
+    PredecessorToExpression,
+)
 from pyomo.contrib.cp.scheduling_expr.step_function_expressions import (
     AlwaysIn,
     StepAt,
     StepAtStart,
     StepAtEnd,
     Pulse,
     CumulativeFunction,
@@ -56,24 +73,25 @@
     BooleanVar,
     LogicalConstraint,
     Suffix,
     value,
 )
 from pyomo.core.base.boolean_var import (
     ScalarBooleanVar,
-    _GeneralBooleanVarData,
+    BooleanVarData,
     IndexedBooleanVar,
 )
-from pyomo.core.base.expression import ScalarExpression, _GeneralExpressionData
-from pyomo.core.base.param import IndexedParam, ScalarParam, _ParamData
-from pyomo.core.base.var import ScalarVar, _GeneralVarData, IndexedVar
+from pyomo.core.base.expression import ScalarExpression, ExpressionData
+from pyomo.core.base.param import IndexedParam, ScalarParam, ParamData
+from pyomo.core.base.var import ScalarVar, VarData, IndexedVar
 import pyomo.core.expr as EXPR
 from pyomo.core.expr.visitor import StreamBasedExpressionVisitor, identify_variables
 from pyomo.core.base import Set, RangeSet
 from pyomo.core.base.set import SetProduct
+from pyomo.repn.util import ExitNodeDispatcher
 from pyomo.opt import WriterFactory, SolverFactory, TerminationCondition, SolverResults
 
 ### FIXME: Remove the following as soon as non-active components no
 ### longer report active==True
 from pyomo.network import Port
 
 ###
@@ -445,14 +463,15 @@
 
 def _create_docplex_interval_var(visitor, interval_var):
     # Create a new docplex interval var and then figure out all the info that
     # gets stored on it
     nm = interval_var.name if visitor.symbolic_solver_labels else None
     cpx_interval_var = cp.interval_var(name=nm)
     visitor.var_map[id(interval_var)] = cpx_interval_var
+    visitor.pyomo_to_docplex[interval_var] = cpx_interval_var
 
     # Figure out if it exists
     if interval_var.is_present.fixed and not interval_var.is_present.value:
         # Someone has fixed that this will not get scheduled.
         cpx_interval_var.set_absent()
     elif interval_var.optional:
         cpx_interval_var.set_optional()
@@ -487,24 +506,56 @@
             cpx_interval_var.set_end_min(end_time.lb)
         if end_time.ub is not None:
             cpx_interval_var.set_end_max(end_time.ub)
 
     return cpx_interval_var
 
 
+def _create_docplex_sequence_var(visitor, sequence_var):
+    nm = sequence_var.name if visitor.symbolic_solver_labels else None
+
+    cpx_seq_var = cp.sequence_var(
+        name=nm,
+        vars=[
+            _get_docplex_interval_var(visitor, v) for v in sequence_var.interval_vars
+        ],
+    )
+    visitor.var_map[id(sequence_var)] = cpx_seq_var
+    return cpx_seq_var
+
+
 def _get_docplex_interval_var(visitor, interval_var):
     # We might already have the interval_var and just need to retrieve it
     if id(interval_var) in visitor.var_map:
         cpx_interval_var = visitor.var_map[id(interval_var)]
     else:
         cpx_interval_var = _create_docplex_interval_var(visitor, interval_var)
         visitor.cpx.add(cpx_interval_var)
     return cpx_interval_var
 
 
+def _get_docplex_sequence_var(visitor, sequence_var):
+    if id(sequence_var) in visitor.var_map:
+        cpx_seq_var = visitor.var_map[id(sequence_var)]
+    else:
+        cpx_seq_var = _create_docplex_sequence_var(visitor, sequence_var)
+        visitor.cpx.add(cpx_seq_var)
+    return cpx_seq_var
+
+
+def _before_sequence_var(visitor, child):
+    _id = id(child)
+    if _id not in visitor.var_map:
+        cpx_seq_var = _get_docplex_sequence_var(visitor, child)
+        visitor.var_map[_id] = cpx_seq_var
+        visitor.pyomo_to_docplex[child] = cpx_seq_var
+
+    return False, (_GENERAL, visitor.var_map[_id])
+
+
 def _before_interval_var(visitor, child):
     _id = id(child)
     if _id not in visitor.var_map:
         cpx_interval_var = _get_docplex_interval_var(visitor, child)
         visitor.var_map[_id] = cpx_interval_var
         visitor.pyomo_to_docplex[child] = cpx_interval_var
 
@@ -560,43 +611,43 @@
         visitor.var_map[_id] = cp.presence_of(cpx_interval_var)
     # There aren't any special types of constraints involving the presence, so
     # we just treat this expression as if it's a normal variable.
     return False, (_GENERAL, visitor.var_map[_id])
 
 
 def _handle_step_at_node(visitor, node):
-    return cp.step_at(node._time, node._height)
+    return False, (_GENERAL, cp.step_at(node._time, node._height))
 
 
 def _handle_step_at_start_node(visitor, node):
     cpx_var = _get_docplex_interval_var(visitor, node._time)
-    return cp.step_at_start(cpx_var, node._height)
+    return False, (_GENERAL, cp.step_at_start(cpx_var, node._height))
 
 
 def _handle_step_at_end_node(visitor, node):
     cpx_var = _get_docplex_interval_var(visitor, node._time)
-    return cp.step_at_end(cpx_var, node._height)
+    return False, (_GENERAL, cp.step_at_end(cpx_var, node._height))
 
 
 def _handle_pulse_node(visitor, node):
     cpx_var = _get_docplex_interval_var(visitor, node._interval_var)
-    return cp.pulse(cpx_var, node._height)
+    return False, (_GENERAL, cp.pulse(cpx_var, node._height))
 
 
 def _handle_negated_step_function_node(visitor, node):
     return _step_function_handles[node.args[0].__class__](visitor, node.args[0])
 
 
 def _handle_cumulative_function(visitor, node):
     expr = 0
     for arg in node.args:
         if arg.__class__ is NegatedStepFunction:
-            expr -= _handle_negated_step_function_node(visitor, arg)
+            expr -= _handle_negated_step_function_node(visitor, arg)[1][1]
         else:
-            expr += _step_function_handles[arg.__class__](visitor, arg)
+            expr += _step_function_handles[arg.__class__](visitor, arg)[1][1]
 
     return False, (_GENERAL, expr)
 
 
 _step_function_handles = {
     StepAt: _handle_step_at_node,
     StepAtStart: _handle_step_at_start_node,
@@ -654,15 +705,15 @@
 
 
 def _handle_monomial_expr(visitor, node, arg1, arg2):
     # Monomial terms show up a lot.  This handles some common
     # simplifications (necessary in part for the unit tests)
     if arg2[1].__class__ in EXPR.native_types:
         return _GENERAL, arg1[1] * arg2[1]
-    elif arg1[1] == 1:
+    elif arg1[1].__class__ in EXPR.native_types and arg1[1] == 1:
         return arg2
     return (_GENERAL, cp.times(_get_int_valued_expr(arg1), _get_int_valued_expr(arg2)))
 
 
 def _handle_sum_node(visitor, node, *args):
     return (
         _GENERAL,
@@ -906,75 +957,120 @@
 def _handle_always_in_node(visitor, node, cumul_func, lb, ub, start, end):
     return (
         _GENERAL,
         cp.always_in(cumul_func[1], interval=(start[1], end[1]), min=lb[1], max=ub[1]),
     )
 
 
+def _handle_no_overlap_expression_node(visitor, node, seq_var):
+    return _GENERAL, cp.no_overlap(seq_var[1])
+
+
+def _handle_first_in_sequence_expression_node(visitor, node, interval_var, seq_var):
+    return _GENERAL, cp.first(seq_var[1], interval_var[1])
+
+
+def _handle_last_in_sequence_expression_node(visitor, node, interval_var, seq_var):
+    return _GENERAL, cp.last(seq_var[1], interval_var[1])
+
+
+def _handle_before_in_sequence_expression_node(
+    visitor, node, before_var, after_var, seq_var
+):
+    return _GENERAL, cp.before(seq_var[1], before_var[1], after_var[1])
+
+
+def _handle_predecessor_to_expression_node(
+    visitor, node, before_var, after_var, seq_var
+):
+    return _GENERAL, cp.previous(seq_var[1], before_var[1], after_var[1])
+
+
+def _handle_span_expression_node(visitor, node, *args):
+    return _GENERAL, cp.span(args[0][1], [arg[1] for arg in args[1:]])
+
+
+def _handle_alternative_expression_node(visitor, node, *args):
+    return _GENERAL, cp.alternative(args[0][1], [arg[1] for arg in args[1:]])
+
+
+def _handle_synchronize_expression_node(visitor, node, *args):
+    return _GENERAL, cp.synchronize(args[0][1], [arg[1] for arg in args[1:]])
+
+
+_operator_handles = {
+    EXPR.GetItemExpression: _handle_getitem,
+    EXPR.GetAttrExpression: _handle_getattr,
+    EXPR.CallExpression: _handle_call,
+    EXPR.NegationExpression: _handle_negation_node,
+    EXPR.ProductExpression: _handle_product_node,
+    EXPR.DivisionExpression: _handle_division_node,
+    EXPR.PowExpression: _handle_pow_node,
+    EXPR.AbsExpression: _handle_abs_node,
+    EXPR.MonomialTermExpression: _handle_monomial_expr,
+    EXPR.SumExpression: _handle_sum_node,
+    EXPR.MinExpression: _handle_min_node,
+    EXPR.MaxExpression: _handle_max_node,
+    EXPR.NotExpression: _handle_not_node,
+    EXPR.EquivalenceExpression: _handle_equivalence_node,
+    EXPR.ImplicationExpression: _handle_implication_node,
+    EXPR.AndExpression: _handle_and_node,
+    EXPR.OrExpression: _handle_or_node,
+    EXPR.XorExpression: _handle_xor_node,
+    EXPR.ExactlyExpression: _handle_exactly_node,
+    EXPR.AtMostExpression: _handle_at_most_node,
+    EXPR.AtLeastExpression: _handle_at_least_node,
+    EXPR.AllDifferentExpression: _handle_all_diff_node,
+    EXPR.CountIfExpression: _handle_count_if_node,
+    EXPR.EqualityExpression: _handle_equality_node,
+    EXPR.NotEqualExpression: _handle_not_equal_node,
+    EXPR.InequalityExpression: _handle_inequality_node,
+    EXPR.RangedExpression: _handle_ranged_inequality_node,
+    BeforeExpression: _handle_before_expression_node,
+    AtExpression: _handle_at_expression_node,
+    AlwaysIn: _handle_always_in_node,
+    ExpressionData: _handle_named_expression_node,
+    ScalarExpression: _handle_named_expression_node,
+    NoOverlapExpression: _handle_no_overlap_expression_node,
+    FirstInSequenceExpression: _handle_first_in_sequence_expression_node,
+    LastInSequenceExpression: _handle_last_in_sequence_expression_node,
+    BeforeInSequenceExpression: _handle_before_in_sequence_expression_node,
+    PredecessorToExpression: _handle_predecessor_to_expression_node,
+    SpanExpression: _handle_span_expression_node,
+    AlternativeExpression: _handle_alternative_expression_node,
+    SynchronizeExpression: _handle_synchronize_expression_node,
+}
+
+
 class LogicalToDoCplex(StreamBasedExpressionVisitor):
-    _operator_handles = {
-        EXPR.GetItemExpression: _handle_getitem,
-        EXPR.Structural_GetItemExpression: _handle_getitem,
-        EXPR.Numeric_GetItemExpression: _handle_getitem,
-        EXPR.Boolean_GetItemExpression: _handle_getitem,
-        EXPR.GetAttrExpression: _handle_getattr,
-        EXPR.Structural_GetAttrExpression: _handle_getattr,
-        EXPR.Numeric_GetAttrExpression: _handle_getattr,
-        EXPR.Boolean_GetAttrExpression: _handle_getattr,
-        EXPR.CallExpression: _handle_call,
-        EXPR.NegationExpression: _handle_negation_node,
-        EXPR.ProductExpression: _handle_product_node,
-        EXPR.DivisionExpression: _handle_division_node,
-        EXPR.PowExpression: _handle_pow_node,
-        EXPR.AbsExpression: _handle_abs_node,
-        EXPR.MonomialTermExpression: _handle_monomial_expr,
-        EXPR.SumExpression: _handle_sum_node,
-        EXPR.LinearExpression: _handle_sum_node,
-        EXPR.MinExpression: _handle_min_node,
-        EXPR.MaxExpression: _handle_max_node,
-        EXPR.NotExpression: _handle_not_node,
-        EXPR.EquivalenceExpression: _handle_equivalence_node,
-        EXPR.ImplicationExpression: _handle_implication_node,
-        EXPR.AndExpression: _handle_and_node,
-        EXPR.OrExpression: _handle_or_node,
-        EXPR.XorExpression: _handle_xor_node,
-        EXPR.ExactlyExpression: _handle_exactly_node,
-        EXPR.AtMostExpression: _handle_at_most_node,
-        EXPR.AtLeastExpression: _handle_at_least_node,
-        EXPR.AllDifferentExpression: _handle_all_diff_node,
-        EXPR.CountIfExpression: _handle_count_if_node,
-        EXPR.EqualityExpression: _handle_equality_node,
-        EXPR.NotEqualExpression: _handle_not_equal_node,
-        EXPR.InequalityExpression: _handle_inequality_node,
-        EXPR.RangedExpression: _handle_ranged_inequality_node,
-        BeforeExpression: _handle_before_expression_node,
-        AtExpression: _handle_at_expression_node,
-        AlwaysIn: _handle_always_in_node,
-        _GeneralExpressionData: _handle_named_expression_node,
-        ScalarExpression: _handle_named_expression_node,
-    }
+    exit_node_dispatcher = ExitNodeDispatcher(_operator_handles)
+    # NOTE: Because of indirection, we can encounter indexed Params and Vars in
+    # expressions
+
     _var_handles = {
         IntervalVarStartTime: _before_interval_var_start_time,
         IntervalVarEndTime: _before_interval_var_end_time,
         IntervalVarLength: _before_interval_var_length,
         IntervalVarPresence: _before_interval_var_presence,
         ScalarIntervalVar: _before_interval_var,
         IntervalVarData: _before_interval_var,
         IndexedIntervalVar: _before_indexed_interval_var,
+        ScalarSequenceVar: _before_sequence_var,
+        SequenceVarData: _before_sequence_var,
         ScalarVar: _before_var,
-        _GeneralVarData: _before_var,
+        VarData: _before_var,
         IndexedVar: _before_indexed_var,
         ScalarBooleanVar: _before_boolean_var,
-        _GeneralBooleanVarData: _before_boolean_var,
+        BooleanVarData: _before_boolean_var,
         IndexedBooleanVar: _before_indexed_boolean_var,
-        _GeneralExpressionData: _before_named_expression,
+        ExpressionData: _before_named_expression,
         ScalarExpression: _before_named_expression,
-        IndexedParam: _before_indexed_param,  # Because of indirection
+        IndexedParam: _before_indexed_param,
         ScalarParam: _before_param,
-        _ParamData: _before_param,
+        ParamData: _before_param,
     }
 
     def __init__(self, cpx_model, symbolic_solver_labels=False):
         self.cpx = cpx_model
         self.symbolic_solver_labels = symbolic_solver_labels
         self._process_node = self._process_node_bx
 
@@ -1000,26 +1096,29 @@
         # Convert Vars Logical vars to docplex equivalents
         if not child.is_expression_type() or child.is_named_expression_type():
             return self._var_handles[child.__class__](self, child)
 
         return True, None
 
     def exitNode(self, node, data):
-        return self._operator_handles[node.__class__](self, node, *data)
+        return self.exit_node_dispatcher[node.__class__](self, node, *data)
 
     finalizeResult = None
 
 
 # [ESJ 11/7/22]: TODO: We should revisit this method in the future, as it is not
 # very efficient.
 def collect_valid_components(model, active=True, sort=None, valid=set(), targets=set()):
     assert active in (True, None)
     unrecognized = {}
     components = {k: [] for k in targets}
     for obj in model.component_data_objects(active=True, descend_into=True, sort=sort):
+        # HACK around #3045
+        if not hasattr(obj, 'ctype'):
+            continue
         ctype = obj.ctype
         if ctype in components:
             components[ctype].append(obj)
         elif ctype not in valid:
             if ctype not in unrecognized:
                 unrecognized[ctype] = [obj]
             else:
@@ -1062,15 +1161,21 @@
                 LogicalConstraint,
                 Suffix,
                 # FIXME: Non-active components should not report as Active
                 Set,
                 RangeSet,
                 Port,
             },
-            targets={Objective, Constraint, LogicalConstraint, IntervalVar},
+            targets={
+                Objective,
+                Constraint,
+                LogicalConstraint,
+                IntervalVar,
+                SequenceVar,
+            },
         )
         if unknown:
             raise ValueError(
                 "The model ('%s') contains the following active components "
                 "that the docplex writer does not know how to process:\n\t%s"
                 % (
                     model.name,
@@ -1291,14 +1396,18 @@
                 if sol is None:
                     logger.warning(
                         "CP optimizer did not return a value "
                         "for variable '%s'" % py_var.name
                     )
                 else:
                     sol = sol.get_value()
+                if py_var.ctype is SequenceVar:
+                    # They don't actually have values--the IntervalVars will get
+                    # set.
+                    continue
                 if py_var.ctype is IntervalVar:
                     if len(sol) == 0:
                         # The interval_var is absent
                         py_var.is_present.set_value(False)
                     else:
                         (start, end, size) = sol
                         py_var.is_present.set_value(True)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/precedence_expressions.py` & `Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/precedence_expressions.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,21 +17,21 @@
         return 3
 
     @property
     def delay(self):
         return self._args_[2]
 
     def _to_string_impl(self, values, relation):
-        delay = int(values[2])
-        if delay == 0:
+        delay = values[2]
+        if delay == '0':
             first = values[0]
-        elif delay > 0:
-            first = "%s + %s" % (values[0], delay)
+        elif delay[0] in '-+':
+            first = "%s %s %s" % (values[0], delay[0], delay[1:])
         else:
-            first = "%s - %s" % (values[0], abs(delay))
+            first = "%s + %s" % (values[0], delay)
         return "%s %s %s" % (first, relation, values[1])
 
 
 class BeforeExpression(PrecedenceExpression):
     """
     Base class for all precedence expressions.
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/scheduling_expr/step_function_expressions.py` & `Pyomo-6.7.2/pyomo/contrib/cp/scheduling_expr/step_function_expressions.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,14 @@
 
 from pyomo.contrib.cp.interval_var import (
     IntervalVar,
     IntervalVarData,
     IntervalVarStartTime,
     IntervalVarEndTime,
 )
-from pyomo.core.base.component import Component
 from pyomo.core.expr.base import ExpressionBase
 from pyomo.core.expr.logical_expr import BooleanExpression
 
 
 def _sum_two_units(_self, _other):
     return CumulativeFunction([_self, _other])
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_docplex_walker.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_docplex_walker.py`

 * *Files 17% similar despite different names*

```diff
@@ -7,20 +7,24 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.common.unittest as unittest
 
-from pyomo.contrib.cp import IntervalVar
-from pyomo.contrib.cp.scheduling_expr.step_function_expressions import (
-    AlwaysIn,
-    Step,
-    Pulse,
+from pyomo.contrib.cp import (
+    IntervalVar,
+    SequenceVar,
+    no_overlap,
+    first_in_sequence,
+    last_in_sequence,
+    alternative,
+    synchronize,
 )
+from pyomo.contrib.cp.scheduling_expr.step_function_expressions import Step, Pulse
 from pyomo.contrib.cp.repn.docplex_writer import docplex_available, LogicalToDoCplex
 
 from pyomo.core.base.range import NumericRange
 from pyomo.core.expr.numeric_expr import MinExpression, MaxExpression
 from pyomo.core.expr.logical_expr import (
     equivalent,
     exactly,
@@ -42,16 +46,14 @@
     Binary,
     NonNegativeIntegers,
     NegativeIntegers,
     NonPositiveIntegers,
     Integers,
     inequality,
     Expression,
-    Reals,
-    Set,
     Param,
 )
 
 try:
     import docplex.cp.model as cp
 
     docplex_available = True
@@ -94,14 +96,18 @@
         cpx_x = visitor.var_map[id(m.x)]
         cpx_i = visitor.var_map[id(m.i)]
         cpx_i2 = visitor.var_map[id(m.i2[2])]
         self.assertTrue(
             expr[1].equals(cpx_x + cp.start_of(cpx_i) + cp.length_of(cpx_i2))
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], cpx_x)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], cpx_i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], cpx_i2)
+
     def test_write_subtraction(self):
         m = self.get_model()
         m.a.domain = Binary
         m.c = Constraint(expr=m.x - m.a[1] <= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
@@ -109,14 +115,17 @@
         self.assertIn(id(m.a[1]), visitor.var_map)
 
         x = visitor.var_map[id(m.x)]
         a1 = visitor.var_map[id(m.a[1])]
 
         self.assertTrue(expr[1].equals(x + (-1 * a1)))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+
     def test_write_product(self):
         m = self.get_model()
         m.a.domain = PositiveIntegers
         m.c = Constraint(expr=m.x * (m.a[1] + 1) <= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
@@ -124,14 +133,17 @@
         self.assertIn(id(m.a[1]), visitor.var_map)
 
         x = visitor.var_map[id(m.x)]
         a1 = visitor.var_map[id(m.a[1])]
 
         self.assertTrue(expr[1].equals(x * (a1 + 1)))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+
     def test_write_floating_point_division(self):
         m = self.get_model()
         m.a.domain = NonNegativeIntegers
         m.c = Constraint(expr=m.x / (m.a[1] + 1) <= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
@@ -139,63 +151,72 @@
         self.assertIn(id(m.a[1]), visitor.var_map)
 
         x = visitor.var_map[id(m.x)]
         a1 = visitor.var_map[id(m.a[1])]
 
         self.assertTrue(expr[1].equals(x / (a1 + 1)))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+
     def test_write_power_expression(self):
         m = self.get_model()
         m.c = Constraint(expr=m.x**2 <= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         cpx_x = visitor.var_map[id(m.x)]
         # .equals checks the equality of two expressions in docplex.
         self.assertTrue(expr[1].equals(cpx_x**2))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], cpx_x)
+
     def test_write_absolute_value_expression(self):
         m = self.get_model()
         m.a.domain = NegativeIntegers
         m.c = Constraint(expr=abs(m.a[1]) + 1 <= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.a[1]), visitor.var_map)
 
         a1 = visitor.var_map[id(m.a[1])]
 
         self.assertTrue(expr[1].equals(cp.abs(a1) + 1))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+
     def test_write_min_expression(self):
         m = self.get_model()
         m.a.domain = NonPositiveIntegers
         m.c = Constraint(expr=MinExpression([m.a[i] for i in m.I]) >= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(expr[1].equals(cp.min(a[i] for i in m.I)))
 
     def test_write_max_expression(self):
         m = self.get_model()
         m.a.domain = NonPositiveIntegers
         m.c = Constraint(expr=MaxExpression([m.a[i] for i in m.I]) >= 3)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(expr[1].equals(cp.max(a[i] for i in m.I)))
 
     def test_expression_with_mutable_param(self):
         m = ConcreteModel()
         m.x = Var(domain=Integers, bounds=(2, 3))
         m.p = Param(initialize=4, mutable=True)
@@ -205,14 +226,43 @@
         expr = visitor.walk_expression((e, e, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
 
         self.assertTrue(expr[1].equals(4 * x))
 
+    def test_monomial_expressions(self):
+        m = ConcreteModel()
+        m.x = Var(domain=Integers, bounds=(1, 4))
+        m.p = Param(initialize=4, mutable=True)
+
+        visitor = self.get_visitor()
+
+        const_expr = 3 * m.x
+        nested_expr = (1 / m.p) * m.x
+        pow_expr = (m.p ** (0.5)) * m.x
+
+        e = m.x * 4
+        expr = visitor.walk_expression((e, e, 0))
+        self.assertIn(id(m.x), visitor.var_map)
+        x = visitor.var_map[id(m.x)]
+        self.assertTrue(expr[1].equals(4 * x))
+
+        e = 1.0 * m.x
+        expr = visitor.walk_expression((e, e, 0))
+        self.assertTrue(expr[1].equals(x))
+
+        e = (1 / m.p) * m.x
+        expr = visitor.walk_expression((e, e, 0))
+        self.assertTrue(expr[1].equals(cp.float_div(1, 4) * x))
+
+        e = (m.p ** (0.5)) * m.x
+        expr = visitor.walk_expression((e, e, 0))
+        self.assertTrue(expr[1].equals(cp.power(4, 0.5) * x))
+
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_LogicalExpressions(CommonTest):
     def test_write_logical_and(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.b.land(m.b2['b']))
         visitor = self.get_visitor()
@@ -222,27 +272,38 @@
         self.assertIn(id(m.b2['b']), visitor.var_map)
 
         b = visitor.var_map[id(m.b)]
         b2b = visitor.var_map[id(m.b2['b'])]
 
         self.assertTrue(expr[1].equals(cp.logical_and(b, b2b)))
 
+        # ESJ: This is ludicrous, but I don't know how to get the args of a CP
+        # expression, so testing that we were correct in the pyomo to docplex
+        # map by checking that we can build an expression that is the same as b
+        # (because b is actually "b == 1" since docplex doesn't believe in
+        # Booleans)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertTrue(b2b.equals(visitor.pyomo_to_docplex[m.b2['b']] == 1))
+
     def test_write_logical_or(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.b.lor(m.i.is_present))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         self.assertIn(id(m.b), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
         b = visitor.var_map[id(m.b)]
         i = visitor.var_map[id(m.i)]
 
         self.assertTrue(expr[1].equals(cp.logical_or(b, cp.presence_of(i))))
 
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+
     def test_write_xor(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.b.xor(m.i2[2].start_time >= 5))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         self.assertIn(id(m.b), visitor.var_map)
@@ -252,50 +313,45 @@
 
         # [ESJ 9/22/22]: This isn't the greatest test because there's no direct
         # translation so how we choose to represent this could change.
         self.assertTrue(
             expr[1].equals(cp.count([b, cp.less_or_equal(5, cp.start_of(i22))], 1) == 1)
         )
 
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+
     def test_write_logical_not(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=~m.b2['a'])
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         self.assertIn(id(m.b2['a']), visitor.var_map)
         b2a = visitor.var_map[id(m.b2['a'])]
 
         self.assertTrue(expr[1].equals(cp.logical_not(b2a)))
 
+        self.assertTrue(b2a.equals(visitor.pyomo_to_docplex[m.b2['a']] == 1))
+
     def test_equivalence(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=equivalent(~m.b2['a'], m.b))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         self.assertIn(id(m.b), visitor.var_map)
         self.assertIn(id(m.b2['a']), visitor.var_map)
         b = visitor.var_map[id(m.b)]
         b2a = visitor.var_map[id(m.b2['a'])]
 
         self.assertTrue(expr[1].equals(cp.equal(cp.logical_not(b2a), b)))
 
-    def test_implication(self):
-        m = self.get_model()
-        m.c = LogicalConstraint(expr=m.b2['a'].implies(~m.b))
-        visitor = self.get_visitor()
-        expr = visitor.walk_expression((m.c.expr, m.c, 0))
-
-        self.assertIn(id(m.b), visitor.var_map)
-        self.assertIn(id(m.b2['a']), visitor.var_map)
-        b = visitor.var_map[id(m.b)]
-        b2a = visitor.var_map[id(m.b2['a'])]
-
-        self.assertTrue(expr[1].equals(cp.if_then(b2a, cp.logical_not(b))))
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertTrue(b2a.equals(visitor.pyomo_to_docplex[m.b2['a']] == 1))
 
     def test_equality(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = LogicalConstraint(expr=m.b.implies(m.a[3] == 4))
 
         visitor = self.get_visitor()
@@ -304,14 +360,17 @@
         self.assertIn(id(m.b), visitor.var_map)
         self.assertIn(id(m.a[3]), visitor.var_map)
         b = visitor.var_map[id(m.b)]
         a3 = visitor.var_map[id(m.a[3])]
 
         self.assertTrue(expr[1].equals(cp.if_then(b, cp.equal(a3, 4))))
 
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertIs(visitor.pyomo_to_docplex[m.a[3]], a3)
+
     def test_inequality(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = LogicalConstraint(expr=m.b.implies(m.a[3] >= m.a[4]))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
@@ -321,14 +380,18 @@
         self.assertIn(id(m.a[4]), visitor.var_map)
         b = visitor.var_map[id(m.b)]
         a3 = visitor.var_map[id(m.a[3])]
         a4 = visitor.var_map[id(m.a[4])]
 
         self.assertTrue(expr[1].equals(cp.if_then(b, cp.less_or_equal(a4, a3))))
 
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertIs(visitor.pyomo_to_docplex[m.a[3]], a3)
+        self.assertIs(visitor.pyomo_to_docplex[m.a[4]], a4)
+
     def test_ranged_inequality(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = Constraint(expr=inequality(3, m.a[2], 5))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
@@ -351,26 +414,31 @@
         self.assertIn(id(m.a[4]), visitor.var_map)
         b = visitor.var_map[id(m.b)]
         a3 = visitor.var_map[id(m.a[3])]
         a4 = visitor.var_map[id(m.a[4])]
 
         self.assertTrue(expr[1].equals(cp.if_then(b, a3 != a4)))
 
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+        self.assertIs(visitor.pyomo_to_docplex[m.a[3]], a3)
+        self.assertIs(visitor.pyomo_to_docplex[m.a[4]], a4)
+
     def test_exactly_expression(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = LogicalConstraint(expr=exactly(3, [m.a[i] == 4 for i in m.I]))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(
             expr[1].equals(cp.equal(cp.count([a[i] == 4 for i in m.I], 1), 3))
         )
 
     def test_atleast_expression(self):
         m = self.get_model()
@@ -380,14 +448,15 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(
             expr[1].equals(
                 cp.greater_or_equal(cp.count([a[i] == 4 for i in m.I], 1), 3)
             )
         )
 
@@ -399,14 +468,15 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(
             expr[1].equals(cp.less_or_equal(cp.count([a[i] == 4 for i in m.I], 1), 3))
         )
 
     def test_all_diff_expression(self):
         m = self.get_model()
@@ -417,14 +487,15 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(expr[1].equals(cp.all_diff(a[i] for i in m.I)))
 
     def test_count_if_expression(self):
         m = self.get_model()
         m.a.domain = Integers
         m.a.bounds = (11, 20)
@@ -433,14 +504,15 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         a = {}
         for i in m.I:
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
 
         self.assertTrue(expr[1].equals(cp.count((a[i] == i for i in m.I), 1) == 5))
 
     def test_interval_var_is_present(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = LogicalConstraint(expr=m.i.is_present.implies(m.a[1] == 5))
@@ -451,14 +523,17 @@
         self.assertIn(id(m.a[1]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
         a1 = visitor.var_map[id(m.a[1])]
         i = visitor.var_map[id(m.i)]
 
         self.assertTrue(expr[1].equals(cp.if_then(cp.presence_of(i), a1 == 5)))
 
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+
     def test_interval_var_is_present_indirection(self):
         m = self.get_model()
         m.a.domain = Integers
         m.y = Var(domain=Integers, bounds=[1, 2])
 
         m.c = LogicalConstraint(expr=m.i2[m.y].is_present.implies(m.a[1] >= 7))
 
@@ -484,14 +559,19 @@
                     )
                     == True,
                     cp.less_or_equal(7, a1),
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.a[1]], a1)
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+
     def test_is_present_indirection_and_length(self):
         m = self.get_model()
         m.y = Var(domain=Integers, bounds=[1, 2])
 
         m.c = LogicalConstraint(expr=m.i2[m.y].is_present.land(m.i2[m.y].length >= 7))
 
         visitor = self.get_visitor()
@@ -518,14 +598,18 @@
                             [cp.length_of(i21), cp.length_of(i22)], 0 + 1 * (y - 1) // 1
                         ),
                     ),
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+
     def test_handle_getattr_lor(self):
         m = self.get_model()
         m.y = Var(domain=Integers, bounds=(1, 2))
 
         e = m.i2[m.y].is_present.lor(~m.b)
 
         visitor = self.get_visitor()
@@ -549,14 +633,19 @@
                     )
                     == True,
                     cp.logical_not(b),
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
     def test_handle_getattr_xor(self):
         m = self.get_model()
         m.y = Var(domain=Integers, bounds=(1, 2))
 
         e = m.i2[m.y].is_present.xor(m.b)
 
         visitor = self.get_visitor()
@@ -587,14 +676,19 @@
                         1,
                     ),
                     1,
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
     def test_handle_getattr_equivalent_to(self):
         m = self.get_model()
         m.y = Var(domain=Integers, bounds=(1, 2))
 
         e = m.i2[m.y].is_present.equivalent_to(~m.b)
 
         visitor = self.get_visitor()
@@ -618,14 +712,19 @@
                     )
                     == True,
                     cp.logical_not(b),
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
     def test_logical_or_on_indirection(self):
         m = ConcreteModel()
         m.b = BooleanVar([2, 3, 4, 5])
         m.x = Var(domain=Integers, bounds=(3, 5))
 
         e = m.b[m.x].lor(m.x == 5)
 
@@ -647,14 +746,19 @@
                 cp.logical_or(
                     cp.element([b3, b4, b5], 0 + 1 * (x - 3) // 1) == True,
                     cp.equal(x, 5),
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertTrue(b3.equals(visitor.pyomo_to_docplex[m.b[3]] == 1))
+        self.assertTrue(b4.equals(visitor.pyomo_to_docplex[m.b[4]] == 1))
+        self.assertTrue(b5.equals(visitor.pyomo_to_docplex[m.b[5]] == 1))
+
     def test_logical_xor_on_indirection(self):
         m = ConcreteModel()
         m.b = BooleanVar([2, 3, 4, 5])
         m.b[4].fix(False)
         m.x = Var(domain=Integers, bounds=(3, 5))
 
         e = m.b[m.x].xor(m.x == 5)
@@ -681,14 +785,18 @@
                         1,
                     ),
                     1,
                 )
             )
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertTrue(b3.equals(visitor.pyomo_to_docplex[m.b[3]] == 1))
+        self.assertTrue(b5.equals(visitor.pyomo_to_docplex[m.b[5]] == 1))
+
     def test_using_precedence_expr_as_boolean_expr(self):
         m = self.get_model()
         e = m.b.implies(m.i2[2].start_time.before(m.i2[1].start_time))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
@@ -700,14 +808,18 @@
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
 
         self.assertTrue(
             expr[1].equals(cp.if_then(b, cp.start_of(i22) + 0 <= cp.start_of(i21)))
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
     def test_using_precedence_expr_as_boolean_expr_positive_delay(self):
         m = self.get_model()
         e = m.b.implies(m.i2[2].start_time.before(m.i2[1].start_time, delay=4))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
@@ -719,14 +831,18 @@
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
 
         self.assertTrue(
             expr[1].equals(cp.if_then(b, cp.start_of(i22) + 4 <= cp.start_of(i21)))
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
     def test_using_precedence_expr_as_boolean_expr_negative_delay(self):
         m = self.get_model()
         e = m.b.implies(m.i2[2].start_time.at(m.i2[1].start_time, delay=-3))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
@@ -738,39 +854,46 @@
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
 
         self.assertTrue(
             expr[1].equals(cp.if_then(b, cp.start_of(i22) + (-3) == cp.start_of(i21)))
         )
 
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertTrue(b.equals(visitor.pyomo_to_docplex[m.b] == 1))
+
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_IntervalVars(CommonTest):
     def test_interval_var_fixed_presences_correct(self):
         m = self.get_model()
 
         m.silly = LogicalConstraint(expr=m.i.is_present)
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.silly.expr, m.silly, 0))
         self.assertIn(id(m.i), visitor.var_map)
         i = visitor.var_map[id(m.i)]
         # Check that docplex knows it's optional
         self.assertTrue(i.is_optional())
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         # Now fix it to absent
         m.i.is_present.fix(False)
         m.c = LogicalConstraint(expr=m.i.is_present.lor(m.i2[1].start_time == 2))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i2[1]), visitor.var_map)
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
         self.assertIn(id(m.i), visitor.var_map)
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         # Check that we passed on the presence info to docplex
         self.assertTrue(i.is_absent())
         self.assertTrue(i21.is_present())
         # Not testing the expression here because sometime we might optimize out
         # the presence_of call for fixed absent vars, but for now I haven't.
 
@@ -781,14 +904,15 @@
         m.silly = LogicalConstraint(expr=m.i.is_present)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.silly.expr, m.silly, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(i.is_optional())
         self.assertEqual(i.get_length(), (4, 4))
         self.assertEqual(i.get_start(), (2, 7))
         self.assertEqual(i.get_end(), (6, 11))
 
     def test_interval_var_fixed_start_and_end(self):
@@ -798,131 +922,220 @@
         m.i.end_time.fix(6)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.i, m.i, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertFalse(i.is_optional())
         self.assertEqual(i.get_start(), (3, 3))
         self.assertEqual(i.get_end(), (6, 6))
 
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
+class TestCPExpressionWalker_SequenceVars(CommonTest):
+    def get_model(self):
+        m = super().get_model()
+        m.seq = SequenceVar(expr=[m.i, m.i2[1], m.i2[2]])
+
+        return m
+
+    def check_scalar_sequence_var(self, m, visitor):
+        self.assertIn(id(m.seq), visitor.var_map)
+        seq = visitor.var_map[id(m.seq)]
+        self.assertIs(visitor.pyomo_to_docplex[m.seq], seq)
+
+        i = visitor.var_map[id(m.i)]
+        i21 = visitor.var_map[id(m.i2[1])]
+        i22 = visitor.var_map[id(m.i2[2])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+
+        ivs = seq.get_interval_variables()
+        self.assertEqual(len(ivs), 3)
+        self.assertIs(ivs[0], i)
+        self.assertIs(ivs[1], i21)
+        self.assertIs(ivs[2], i22)
+
+        return seq, i, i21, i22
+
+    def test_scalar_sequence_var(self):
+        m = self.get_model()
+
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((m.seq, m.seq, 0))
+        self.check_scalar_sequence_var(m, visitor)
+
+    def test_no_overlap(self):
+        m = self.get_model()
+        e = no_overlap(m.seq)
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        seq, i, i21, i22 = self.check_scalar_sequence_var(m, visitor)
+        self.assertTrue(expr[1].equals(cp.no_overlap(seq)))
+
+    def test_first_in_sequence(self):
+        m = self.get_model()
+        e = first_in_sequence(m.i2[1], m.seq)
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        seq, i, i21, i22 = self.check_scalar_sequence_var(m, visitor)
+        self.assertTrue(expr[1].equals(cp.first(seq, i21)))
+
+    def test_before_in_sequence(self):
+        m = self.get_model()
+        e = last_in_sequence(m.i, m.seq)
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        seq, i, i21, i22 = self.check_scalar_sequence_var(m, visitor)
+        self.assertTrue(expr[1].equals(cp.last(seq, i)))
+
+    def test_last_in_sequence(self):
+        m = self.get_model()
+        e = last_in_sequence(m.i2[1], m.seq)
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        seq, i, i21, i22 = self.check_scalar_sequence_var(m, visitor)
+        self.assertTrue(expr[1].equals(cp.last(seq, i21)))
+
+
+@unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_PrecedenceExpressions(CommonTest):
     def test_start_before_start(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.start_time.before(m.i2[1].start_time))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.start_before_start(i, i21, 0)))
 
     def test_start_before_end(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.start_time.before(m.i2[1].end_time, delay=3))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.start_before_end(i, i21, 3)))
 
     def test_end_before_start(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.end_time.before(m.i2[1].start_time, delay=-2))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.end_before_start(i, i21, -2)))
 
     def test_end_before_end(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.end_time.before(m.i2[1].end_time, delay=6))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.end_before_end(i, i21, 6)))
 
     def test_start_at_start(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.start_time.at(m.i2[1].start_time))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.start_at_start(i, i21, 0)))
 
     def test_start_at_end(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.start_time.at(m.i2[1].end_time, delay=3))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.start_at_end(i, i21, 3)))
 
     def test_end_at_start(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.end_time.at(m.i2[1].start_time, delay=-2))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.end_at_start(i, i21, -2)))
 
     def test_end_at_end(self):
         m = self.get_model()
         m.c = LogicalConstraint(expr=m.i.end_time.at(m.i2[1].end_time, delay=6))
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
 
         self.assertTrue(expr[1].equals(cp.end_at_end(i, i21, 6)))
 
     ##
     # Tests for precedence constraints with indirection
     ##
 
@@ -939,14 +1152,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([cp.start_of(i21), cp.start_of(i22)], 0 + 1 * (y - 1) // 1)
                 + 3
                 <= cp.end_of(i)
             )
@@ -965,14 +1182,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.end_of(i) + (-2)
                 <= cp.element(
                     [cp.start_of(i21), cp.start_of(i22)], 0 + 1 * (y - 1) // 1
                 )
@@ -992,14 +1213,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([cp.start_of(i21), cp.start_of(i22)], 0 + 1 * (y - 1) // 1)
                 == cp.end_of(i) + 4
             )
         )
@@ -1019,14 +1244,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.start_of(i) + (-4)
                 <= cp.element([cp.end_of(i21), cp.end_of(i22)], 0 + 1 * (y - 1) // 1)
             )
         )
@@ -1044,14 +1273,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([cp.end_of(i21), cp.end_of(i22)], 0 + 1 * (y - 1) // 1) + 0
                 <= cp.start_of(i)
             )
         )
@@ -1069,14 +1302,18 @@
         self.assertIn(id(m.i2[2]), visitor.var_map)
         self.assertIn(id(m.i), visitor.var_map)
 
         y = visitor.var_map[id(m.y)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
 
         self.assertTrue(
             expr[1].equals(
                 cp.start_of(i) + (-6)
                 == cp.element([cp.end_of(i21), cp.end_of(i22)], 0 + 1 * (y - 1) // 1)
             )
         )
@@ -1103,14 +1340,21 @@
         y = visitor.var_map[id(m.y)]
         x = visitor.var_map[id(m.x)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i33 = visitor.var_map[id(m.i3[1, 3])]
         i34 = visitor.var_map[id(m.i3[1, 4])]
         i35 = visitor.var_map[id(m.i3[1, 5])]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 3]], i33)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 4]], i34)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 5]], i35)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element(
                     [cp.start_of(i33), cp.start_of(i34), cp.start_of(i35)],
                     0 + 1 * (x + (-3) - 3) // 1,
                 )
@@ -1140,14 +1384,21 @@
         y = visitor.var_map[id(m.y)]
         x = visitor.var_map[id(m.x)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i33 = visitor.var_map[id(m.i3[1, 3])]
         i34 = visitor.var_map[id(m.i3[1, 4])]
         i35 = visitor.var_map[id(m.i3[1, 5])]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 3]], i33)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 4]], i34)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 5]], i35)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([cp.end_of(i21), cp.end_of(i22)], 0 + 1 * (y - 1) // 1)
                 <= cp.element(
                     [cp.start_of(i33), cp.start_of(i34), cp.start_of(i35)],
                     0 + 1 * (x + (-3) - 3) // 1,
@@ -1175,14 +1426,21 @@
         y = visitor.var_map[id(m.y)]
         x = visitor.var_map[id(m.x)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
         i33 = visitor.var_map[id(m.i3[1, 3])]
         i34 = visitor.var_map[id(m.i3[1, 4])]
         i35 = visitor.var_map[id(m.i3[1, 5])]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 3]], i33)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 4]], i34)
+        self.assertIs(visitor.pyomo_to_docplex[m.i3[1, 5]], i35)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element(
                     [cp.start_of(i33), cp.start_of(i34), cp.start_of(i35)],
                     0 + 1 * (x + (-3) - 3) // 1,
                 )
@@ -1222,19 +1480,100 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         self.assertIn(id(m.a), visitor.var_map)
         x = visitor.var_map[id(m.x)]
         a = visitor.var_map[id(m.a)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+        self.assertIs(visitor.pyomo_to_docplex[m.a], a)
 
         self.assertTrue(expr[1].equals(cp.element([2, 4, 6], 0 + 1 * (x - 1) // 2) / a))
 
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
+class TestCPExpressionWalker_HierarchicalScheduling(CommonTest):
+    def get_model(self):
+        m = ConcreteModel()
+
+        def start_rule(m, i):
+            return 2 * i
+
+        def length_rule(m, i):
+            return i
+
+        m.iv = IntervalVar(
+            [1, 2, 3], start=start_rule, length=length_rule, optional=True
+        )
+        m.whole_enchilada = IntervalVar()
+
+        return m
+
+    def test_spans(self):
+        m = self.get_model()
+        e = m.whole_enchilada.spans(m.iv[i] for i in [1, 2, 3])
+
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        self.assertIn(id(m.whole_enchilada), visitor.var_map)
+        whole_enchilada = visitor.var_map[id(m.whole_enchilada)]
+        self.assertIs(visitor.pyomo_to_docplex[m.whole_enchilada], whole_enchilada)
+
+        iv = {}
+        for i in [1, 2, 3]:
+            self.assertIn(id(m.iv[i]), visitor.var_map)
+            iv[i] = visitor.var_map[id(m.iv[i])]
+
+        self.assertTrue(
+            expr[1].equals(cp.span(whole_enchilada, [iv[i] for i in [1, 2, 3]]))
+        )
+
+    def test_alternative(self):
+        m = self.get_model()
+        e = alternative(m.whole_enchilada, [m.iv[i] for i in [1, 2, 3]])
+
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        self.assertIn(id(m.whole_enchilada), visitor.var_map)
+        whole_enchilada = visitor.var_map[id(m.whole_enchilada)]
+        self.assertIs(visitor.pyomo_to_docplex[m.whole_enchilada], whole_enchilada)
+
+        iv = {}
+        for i in [1, 2, 3]:
+            self.assertIn(id(m.iv[i]), visitor.var_map)
+            iv[i] = visitor.var_map[id(m.iv[i])]
+
+        self.assertTrue(
+            expr[1].equals(cp.alternative(whole_enchilada, [iv[i] for i in [1, 2, 3]]))
+        )
+
+    def test_synchronize(self):
+        m = self.get_model()
+        e = synchronize(m.whole_enchilada, [m.iv[i] for i in [1, 2, 3]])
+
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((e, e, 0))
+
+        self.assertIn(id(m.whole_enchilada), visitor.var_map)
+        whole_enchilada = visitor.var_map[id(m.whole_enchilada)]
+        self.assertIs(visitor.pyomo_to_docplex[m.whole_enchilada], whole_enchilada)
+
+        iv = {}
+        for i in [1, 2, 3]:
+            self.assertIn(id(m.iv[i]), visitor.var_map)
+            iv[i] = visitor.var_map[id(m.iv[i])]
+
+        self.assertTrue(
+            expr[1].equals(cp.synchronize(whole_enchilada, [iv[i] for i in [1, 2, 3]]))
+        )
+
+
+@unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_CumulFuncExpressions(CommonTest):
     def test_always_in(self):
         m = self.get_model()
         f = (
             Pulse((m.i, 3))
             + Step(m.i2[1].start_time, height=2)
             - Step(m.i2[2].end_time, height=-1)
@@ -1247,14 +1586,17 @@
         self.assertIn(id(m.i), visitor.var_map)
         self.assertIn(id(m.i2[1]), visitor.var_map)
         self.assertIn(id(m.i2[2]), visitor.var_map)
 
         i = visitor.var_map[id(m.i)]
         i21 = visitor.var_map[id(m.i2[1])]
         i22 = visitor.var_map[id(m.i2[2])]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[1]], i21)
+        self.assertIs(visitor.pyomo_to_docplex[m.i2[2]], i22)
 
         self.assertTrue(
             expr[1].equals(
                 cp.always_in(
                     cp.pulse(i, 3)
                     + cp.step_at_start(i21, 2)
                     - cp.step_at_end(i22, -1)
@@ -1262,40 +1604,60 @@
                     interval=(0, 10),
                     min=0,
                     max=3,
                 )
             )
         )
 
+    def test_always_in_single_pulse(self):
+        # This is a bit silly as you can tell whether or not it is feasible
+        # structurally, but there's no reason it couldn't happen.
+        m = self.get_model()
+        f = Pulse((m.i, 3))
+        m.c = LogicalConstraint(expr=f.within((0, 3), (0, 10)))
+        visitor = self.get_visitor()
+        expr = visitor.walk_expression((m.c.expr, m.c, 0))
+
+        self.assertIn(id(m.i), visitor.var_map)
+
+        i = visitor.var_map[id(m.i)]
+        self.assertIs(visitor.pyomo_to_docplex[m.i], i)
+
+        self.assertTrue(
+            expr[1].equals(cp.always_in(cp.pulse(i, 3), interval=(0, 10), min=0, max=3))
+        )
+
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_NamedExpressions(CommonTest):
     def test_named_expression(self):
         m = self.get_model()
         m.e = Expression(expr=m.x**2 + 7)
         m.c = Constraint(expr=m.e <= 32)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
 
         self.assertTrue(expr[1].equals(x**2 + 7))
 
     def test_repeated_named_expression(self):
         m = self.get_model()
         m.e = Expression(expr=m.x**2 + 7)
         m.c = Constraint(expr=m.e - 8 * m.e <= 32)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
 
         self.assertTrue(expr[1].equals(x**2 + 7 + (-1) * (8 * (x**2 + 7))))
 
 
 @unittest.skipIf(not docplex_available, "docplex is not available")
 class TestCPExpressionWalker_Vars(CommonTest):
     def test_complain_about_non_integer_vars(self):
@@ -1318,48 +1680,53 @@
         m.c = Constraint(expr=m.a[1] + m.a[2] >= 4)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.a[2]), visitor.var_map)
         a2 = visitor.var_map[id(m.a[2])]
+        self.assertIs(visitor.pyomo_to_docplex[m.a[2]], a2)
 
         self.assertTrue(expr[1].equals(3 + a2))
 
     def test_fixed_boolean_var(self):
         m = self.get_model()
         m.b.fix(False)
         m.b2['a'].fix(True)
         m.c = LogicalConstraint(expr=m.b.lor(m.b2['a'].land(m.b2['b'])))
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.expr, m.c, 0))
 
         self.assertIn(id(m.b2['b']), visitor.var_map)
         b2b = visitor.var_map[id(m.b2['b'])]
+        self.assertTrue(b2b.equals(visitor.pyomo_to_docplex[m.b2['b']] == 1))
 
         self.assertTrue(expr[1].equals(cp.logical_or(False, cp.logical_and(True, b2b))))
 
     def test_indirection_single_index(self):
         m = self.get_model()
         m.a.domain = Integers
         m.c = Constraint(expr=m.a[m.x] >= 3.5)
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((m.c.body, m.c, 0))
 
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
         a = []
         # only need indices 6, 7, and 8 from a, since that's what x is capable
         # of selecting.
         for idx in [6, 7, 8]:
             v = m.a[idx]
             self.assertIn(id(v), visitor.var_map)
-            a.append(visitor.var_map[id(v)])
+            cpx_v = visitor.var_map[id(v)]
+            self.assertIs(visitor.pyomo_to_docplex[v], cpx_v)
+            a.append(cpx_v)
         # since x is between 6 and 8, we subtract 6 from it for it to be the
         # right index
         self.assertTrue(expr[1].equals(cp.element(a, 0 + 1 * (x - 6) // 1)))
 
     def test_indirection_multi_index_second_constant(self):
         m = self.get_model()
         m.z = Var(m.I, m.I, domain=Integers)
@@ -1369,16 +1736,18 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
         z = {}
         for i in [6, 7, 8]:
             self.assertIn(id(m.z[i, 3]), visitor.var_map)
             z[i, 3] = visitor.var_map[id(m.z[i, 3])]
+            self.assertIs(visitor.pyomo_to_docplex[m.z[i, 3]], z[i, 3])
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([z[i, 3] for i in [6, 7, 8]], 0 + 1 * (x - 6) // 1)
             )
         )
 
@@ -1391,16 +1760,19 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
         z = {}
         for i in [6, 7, 8]:
             self.assertIn(id(m.z[3, i]), visitor.var_map)
             z[3, i] = visitor.var_map[id(m.z[3, i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.z[3, i]], z[3, i])
+
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([z[3, i] for i in [6, 7, 8]], 0 + 1 * (x - 6) // 1)
             )
         )
 
@@ -1414,16 +1786,19 @@
         expr = visitor.walk_expression((e, e, 0))
 
         z = {}
         for i in [6, 7, 8]:
             for j in [6, 7, 8]:
                 self.assertIn(id(m.z[i, j]), visitor.var_map)
                 z[i, j] = visitor.var_map[id(m.z[i, j])]
+                self.assertIs(visitor.pyomo_to_docplex[m.z[i, j]], z[i, j])
+
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element(
                     [z[i, j] for i in [6, 7, 8] for j in [6, 7, 8]],
                     0 + 1 * (x - 6) // 1 + 3 * (x - 6) // 1,
                 )
@@ -1439,20 +1814,25 @@
 
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
         z = {}
         for i in [6, 7, 8]:
             for j in [1, 3, 5]:
-                self.assertIn(id(m.z[i, 3]), visitor.var_map)
+                self.assertIn(id(m.z[i, j]), visitor.var_map)
                 z[i, j] = visitor.var_map[id(m.z[i, j])]
+                self.assertIs(visitor.pyomo_to_docplex[m.z[i, j]], z[i, j])
+
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
+
         self.assertIn(id(m.y), visitor.var_map)
         y = visitor.var_map[id(m.y)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element(
                     [z[i, j] for i in [6, 7, 8] for j in [1, 3, 5]],
                     0 + 1 * (x - 6) // 1 + 3 * (y - 1) // 2,
                 )
@@ -1469,18 +1849,22 @@
         visitor = self.get_visitor()
         expr = visitor.walk_expression((e, e, 0))
 
         a = {}
         for i in range(1, 8):
             self.assertIn(id(m.a[i]), visitor.var_map)
             a[i] = visitor.var_map[id(m.a[i])]
+            self.assertIs(visitor.pyomo_to_docplex[m.a[i]], a[i])
+
         self.assertIn(id(m.x), visitor.var_map)
         x = visitor.var_map[id(m.x)]
+        self.assertIs(visitor.pyomo_to_docplex[m.x], x)
         self.assertIn(id(m.y), visitor.var_map)
         y = visitor.var_map[id(m.y)]
+        self.assertIs(visitor.pyomo_to_docplex[m.y], y)
 
         self.assertTrue(
             expr[1].equals(
                 cp.element([a[i] for i in range(1, 8)], 0 + 1 * (x + -1 * y - 1) // 1)
             )
         )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_docplex_writer.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_docplex_writer.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,15 +8,24 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.common.unittest as unittest
 from pyomo.common.fileutils import Executable
 
-from pyomo.contrib.cp import IntervalVar, Pulse, Step, AlwaysIn
+from pyomo.contrib.cp import (
+    IntervalVar,
+    SequenceVar,
+    Pulse,
+    Step,
+    AlwaysIn,
+    first_in_sequence,
+    predecessor_to,
+    no_overlap,
+)
 from pyomo.contrib.cp.repn.docplex_writer import LogicalToDoCplex
 from pyomo.environ import (
     all_different,
     count_if,
     ConcreteModel,
     Set,
     Var,
@@ -356,15 +365,14 @@
         perfect = 7 * 7 * 4
         self.assertEqual(results.problem.lower_bound, perfect)
         self.assertEqual(results.problem.upper_bound, perfect)
         self.assertEqual(
             results.solver.termination_condition, TerminationCondition.optimal
         )
         self.assertEqual(value(m.obj), perfect)
-        m.person_name.pprint()
         self.assertEqual(value(m.person_name['P1']), 0)
         self.assertEqual(value(m.person_name['P2']), 1)
         self.assertEqual(value(m.person_name['P3']), 2)
         self.assertEqual(value(m.person_name['P4']), 3)
         self.assertEqual(value(m.person_name['P5']), 4)
         # We can't distinguish P6 and P7, so they could each have either of
         # names 5 and 6
@@ -388,7 +396,29 @@
         m.person_name['P7'].fix(5)
 
         results = SolverFactory('cp_optimizer').solve(m)
         self.assertEqual(
             results.solver.termination_condition, TerminationCondition.optimal
         )
         self.assertEqual(value(m.obj), perfect)
+
+    def test_scheduling_with_sequence_vars(self):
+        m = ConcreteModel()
+        m.Steps = Set(initialize=[1, 2, 3])
+
+        def length_rule(m, j):
+            return 2 * j
+
+        m.i = IntervalVar(m.Steps, start=(0, 12), end=(0, 12), length=length_rule)
+        m.seq = SequenceVar(expr=[m.i[j] for j in m.Steps])
+        m.first = LogicalConstraint(expr=first_in_sequence(m.i[1], m.seq))
+        m.seq_order1 = LogicalConstraint(expr=predecessor_to(m.i[1], m.i[2], m.seq))
+        m.seq_order2 = LogicalConstraint(expr=predecessor_to(m.i[2], m.i[3], m.seq))
+        m.no_ovlerpa = LogicalConstraint(expr=no_overlap(m.seq))
+
+        results = SolverFactory('cp_optimizer').solve(m)
+        self.assertEqual(
+            results.solver.termination_condition, TerminationCondition.feasible
+        )
+        self.assertEqual(value(m.i[1].start_time), 0)
+        self.assertEqual(value(m.i[2].start_time), 2)
+        self.assertEqual(value(m.i[3].start_time), 6)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_interval_var.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_interval_var.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 from pyomo.contrib.cp.interval_var import (
     IntervalVar,
     IntervalVarTimePoint,
     IntervalVarLength,
     IntervalVarPresence,
 )
 from pyomo.core.expr import GetItemExpression, GetAttrExpression
-from pyomo.environ import ConcreteModel, Integers, Set, value, Var
+from pyomo.environ import ConcreteModel, Integers, Reference, Set, value, Var
 
 
 class TestScalarIntervalVar(unittest.TestCase):
     def test_initialize_with_no_data(self):
         m = ConcreteModel()
         m.i = IntervalVar()
 
@@ -213,9 +213,28 @@
 
         thing2 = thing1.start_time
         self.assertIsInstance(thing2, GetAttrExpression)
         self.assertEqual(len(thing2.args), 2)
         self.assertIs(thing2.args[0], thing1)
         self.assertEqual(thing2.args[1], 'start_time')
 
-        # TODO: But this is where it dies.
         expr1 = m.act[m.i, 2].start_time.before(m.act[m.i**2, 1].end_time)
+
+    def test_reference(self):
+        m = ConcreteModel()
+        m.act = IntervalVar([1, 2], end=[0, 10], optional=True)
+
+        thing = Reference(m.act[:].is_present)
+        self.assertIs(thing[1], m.act[1].is_present)
+        self.assertIs(thing[2], m.act[2].is_present)
+
+        thing = Reference(m.act[:].start_time)
+        self.assertIs(thing[1], m.act[1].start_time)
+        self.assertIs(thing[2], m.act[2].start_time)
+
+        thing = Reference(m.act[:].end_time)
+        self.assertIs(thing[1], m.act[1].end_time)
+        self.assertIs(thing[2], m.act[2].end_time)
+
+        thing = Reference(m.act[:].length)
+        self.assertIs(thing[1], m.act[1].length)
+        self.assertIs(thing[2], m.act[2].length)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_logical_to_disjunctive.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_logical_to_disjunctive.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_precedence_constraints.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_precedence_constraints.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 
 import pyomo.common.unittest as unittest
 from pyomo.contrib.cp import IntervalVar
 from pyomo.contrib.cp.scheduling_expr.precedence_expressions import (
     BeforeExpression,
     AtExpression,
 )
-from pyomo.environ import ConcreteModel, LogicalConstraint
+from pyomo.environ import ConcreteModel, LogicalConstraint, Param
 
 
 class TestPrecedenceRelationships(unittest.TestCase):
     def get_model(self):
         m = ConcreteModel()
         m.a = IntervalVar()
         m.b = IntervalVar()
@@ -169,7 +169,21 @@
         self.assertIsInstance(m.c.expr, BeforeExpression)
         self.assertEqual(len(m.c.expr.args), 3)
         self.assertIs(m.c.expr.args[0], m.b.end_time)
         self.assertIs(m.c.expr.args[1], m.a.end_time)
         self.assertEqual(m.c.expr.delay, 0)
 
         self.assertEqual(str(m.c.expr), "b.end_time <= a.end_time")
+
+    def test_end_before_start_param_delay(self):
+        m = self.get_model()
+        m.PrepTime = Param(initialize=5)
+        m.c = LogicalConstraint(
+            expr=m.a.end_time.before(m.b.start_time, delay=m.PrepTime)
+        )
+        self.assertIsInstance(m.c.expr, BeforeExpression)
+        self.assertEqual(len(m.c.expr.args), 3)
+        self.assertIs(m.c.expr.args[0], m.a.end_time)
+        self.assertIs(m.c.expr.args[1], m.b.start_time)
+        self.assertIs(m.c.expr.delay, m.PrepTime)
+
+        self.assertEqual(str(m.c.expr), "a.end_time + PrepTime <= b.start_time")
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/tests/test_step_function_expressions.py` & `Pyomo-6.7.2/pyomo/contrib/cp/tests/test_step_function_expressions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/transform/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/cp/transform/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/transform/logical_to_disjunctive_program.py` & `Pyomo-6.7.2/pyomo/contrib/cp/transform/logical_to_disjunctive_program.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,29 +8,28 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.contrib.cp.transform.logical_to_disjunctive_walker import (
     LogicalToDisjunctiveVisitor,
 )
-from pyomo.common.collections import ComponentMap
 from pyomo.common.modeling import unique_component_name
 from pyomo.common.config import ConfigDict, ConfigValue
 
 from pyomo.core import (
     TransformationFactory,
     VarList,
     Binary,
     LogicalConstraint,
     Block,
     ConstraintList,
     Transformation,
     NonNegativeIntegers,
 )
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base import SortComponents
 from pyomo.core.util import target_list
 from pyomo.gdp import Disjunct, Disjunction
 
 
 @TransformationFactory.register(
     "contrib.logical_to_disjunctive",
@@ -69,15 +68,15 @@
         targets = config.targets
         if targets is None:
             targets = (model,)
 
         transBlocks = {}
         visitor = LogicalToDisjunctiveVisitor()
         for t in targets:
-            if t.ctype is Block or isinstance(t, _BlockData):
+            if t.ctype is Block or isinstance(t, BlockData):
                 self._transform_block(t, model, visitor, transBlocks)
             elif t.ctype is LogicalConstraint:
                 if t.is_indexed():
                     self._transform_constraint(t, visitor, transBlocks)
                 else:
                     self._transform_constraintData(t, visitor, transBlocks)
             else:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/cp/transform/logical_to_disjunctive_walker.py` & `Pyomo-6.7.2/pyomo/contrib/cp/transform/logical_to_disjunctive_walker.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,35 +5,31 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-import collections
-
 from pyomo.common.collections import ComponentMap
 from pyomo.common.errors import MouseTrap
 from pyomo.core.expr.expr_common import ExpressionType
 from pyomo.core.expr.visitor import StreamBasedExpressionVisitor
-from pyomo.core.expr.numeric_expr import NumericExpression
-from pyomo.core.expr.relational_expr import RelationalExpression
 import pyomo.core.expr as EXPR
 from pyomo.core.base import (
     Binary,
     Constraint,
     ConstraintList,
     NonNegativeIntegers,
     VarList,
     value,
 )
 import pyomo.core.base.boolean_var as BV
-from pyomo.core.base.expression import ScalarExpression, _GeneralExpressionData
-from pyomo.core.base.param import ScalarParam, _ParamData
-from pyomo.core.base.var import ScalarVar, _GeneralVarData
+from pyomo.core.base.expression import ScalarExpression, ExpressionData
+from pyomo.core.base.param import ScalarParam, ParamData
+from pyomo.core.base.var import ScalarVar, VarData
 from pyomo.gdp.disjunct import AutoLinkedBooleanVar, Disjunct, Disjunction
 
 
 def _dispatch_boolean_var(visitor, node):
     if node not in visitor.boolean_to_binary_map:
         binary = node.get_associated_binary()
         if binary is not None:
@@ -205,23 +201,23 @@
 _operator_dispatcher[EXPR.XorExpression] = _dispatch_xor
 _operator_dispatcher[EXPR.ExactlyExpression] = _dispatch_exactly
 _operator_dispatcher[EXPR.AtLeastExpression] = _dispatch_atleast
 _operator_dispatcher[EXPR.AtMostExpression] = _dispatch_atmost
 
 _before_child_dispatcher = {}
 _before_child_dispatcher[BV.ScalarBooleanVar] = _dispatch_boolean_var
-_before_child_dispatcher[BV._GeneralBooleanVarData] = _dispatch_boolean_var
+_before_child_dispatcher[BV.BooleanVarData] = _dispatch_boolean_var
 _before_child_dispatcher[AutoLinkedBooleanVar] = _dispatch_boolean_var
-_before_child_dispatcher[_ParamData] = _dispatch_param
+_before_child_dispatcher[ParamData] = _dispatch_param
 _before_child_dispatcher[ScalarParam] = _dispatch_param
 # for the moment, these are all just so we can get good error messages when we
 # don't handle them:
 _before_child_dispatcher[ScalarVar] = _dispatch_var
-_before_child_dispatcher[_GeneralVarData] = _dispatch_var
-_before_child_dispatcher[_GeneralExpressionData] = _dispatch_expression
+_before_child_dispatcher[VarData] = _dispatch_var
+_before_child_dispatcher[ExpressionData] = _dispatch_expression
 _before_child_dispatcher[ScalarExpression] = _dispatch_expression
 
 
 class LogicalToDisjunctiveVisitor(StreamBasedExpressionVisitor):
     """Converts BooleanExpressions to Linear (MIP) representation
 
     This converter eschews conjunctive normal form, and instead follows
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/doe/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/doe.py` & `Pyomo-6.7.2/pyomo/contrib/doe/doe.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,17 @@
 from itertools import permutations, product
 import logging
 from enum import Enum
 from pyomo.common.timing import TicTocTimer
 from pyomo.contrib.sensitivity_toolbox.sens import get_dsdp
 from pyomo.contrib.doe.scenario import ScenarioGenerator, FiniteDifferenceStep
 from pyomo.contrib.doe.result import FisherResults, GridSearchResult
+import collections.abc
+
+import inspect
 
 
 class CalculationMode(Enum):
     sequential_finite = "sequential_finite"
     direct_kaug = "direct_kaug"
 
 
@@ -97,14 +100,16 @@
         discretize_model:
             A user-specified ``function`` that discretizes the model. Only use with Pyomo.DAE, default=None
         args:
             Additional arguments for the create_model function.
         """
 
         # parameters
+        if not isinstance(param_init, collections.abc.Mapping):
+            raise ValueError("param_init should be a dictionary.")
         self.param = param_init
         # design variable name
         self.design_name = design_vars.variable_names
         self.design_vars = design_vars
         self.create_model = create_model
         self.args = args
 
@@ -222,32 +227,36 @@
         self.step = step
         self.tee_opt = tee_opt
 
         # calculate how much the FIM element is scaled by a constant number
         # FIM = Jacobian.T@Jacobian, the FIM is scaled by squared value the Jacobian is scaled
         self.fim_scale_constant_value = self.scale_constant_value**2
 
+        # Start timer
         sp_timer = TicTocTimer()
         sp_timer.tic(msg=None)
 
         # build the large DOE pyomo model
         m = self._create_doe_model(no_obj=True)
 
         # solve model, achieve results for square problem, and results for optimization problem
         m, analysis_square = self._compute_stochastic_program(m, optimize_opt)
 
         if self.optimize:
+            # If set to optimize, solve the optimization problem (with degrees of freedom)
             analysis_optimize = self._optimize_stochastic_program(m)
             dT = sp_timer.toc(msg=None)
-            self.logger.info("elapsed time: %0.1f" % dT)
+            self.logger.info("elapsed time: %0.1f seconds" % dT)
+            # Return both square problem and optimization problem results
             return analysis_square, analysis_optimize
 
         else:
             dT = sp_timer.toc(msg=None)
-            self.logger.info("elapsed time: %0.1f" % dT)
+            self.logger.info("elapsed time: %0.1f seconds" % dT)
+            # Return only square problem results
             return analysis_square
 
     def _compute_stochastic_program(self, m, optimize_option):
         """
         Solve the stochastic program problem as a square problem.
         """
 
@@ -383,15 +392,15 @@
                 read_output, extract_single_model, store_output
             )
 
         elif self.mode == CalculationMode.direct_kaug:
             FIM_analysis = self._direct_kaug()
 
         dT = square_timer.toc(msg=None)
-        self.logger.info("elapsed time: %0.1f" % dT)
+        self.logger.info("elapsed time: %0.1f seconds" % dT)
 
         return FIM_analysis
 
     def _sequential_finite(self, read_output, extract_single_model, store_output):
         """Sequential_finite mode uses Pyomo Block to evaluate the sensitivity information."""
 
         # if measurements are provided
@@ -583,31 +592,56 @@
 
         # Create a global model
         mod = pyo.ConcreteModel()
 
         # Set for block/scenarios
         mod.scenario = pyo.Set(initialize=self.scenario_data.scenario_indices)
 
+        # Determine if create_model takes theta as an optional input
+        pass_theta_to_initialize = (
+            'theta' in inspect.getfullargspec(self.create_model).args
+        )
+
         # Allow user to self-define complex design variables
         self.create_model(mod=mod, model_option=ModelOptionLib.stage1)
 
+        # Fix parameter values in the copy of the stage1 model (if they exist)
+        for par in self.param:
+            cuid = pyo.ComponentUID(par)
+            var = cuid.find_component_on(mod)
+            if var is not None:
+                # Fix the parameter value
+                # Otherwise, the parameter does not exist on the stage 1 model
+                var.fix(self.param[par])
+
         def block_build(b, s):
             # create block scenarios
-            self.create_model(mod=b, model_option=ModelOptionLib.stage2)
+            # idea: check if create_model takes theta as an optional input, if so, pass parameter values to create_model
+
+            if pass_theta_to_initialize:
+                # Grab the values of theta for this scenario/block
+                theta_initialize = self.scenario_data.scenario[s]
+                # Add model on block with theta values
+                self.create_model(
+                    mod=b, model_option=ModelOptionLib.stage2, theta=theta_initialize
+                )
+            else:
+                # Otherwise add model on block without theta values
+                self.create_model(mod=b, model_option=ModelOptionLib.stage2)
 
             # fix parameter values to perturbed values
             for par in self.param:
                 cuid = pyo.ComponentUID(par)
                 var = cuid.find_component_on(b)
                 var.fix(self.scenario_data.scenario[s][par])
 
         mod.block = pyo.Block(mod.scenario, rule=block_build)
 
         # discretize the model
-        if self.discretize_model:
+        if self.discretize_model is not None:
             mod = self.discretize_model(mod)
 
         # force design variables in blocks to be equal to global design values
         for name in self.design_name:
 
             def fix1(mod, s):
                 cuid = pyo.ComponentUID(name)
@@ -771,15 +805,15 @@
         for design_set_iter in search_design_set:
             # generate the design variable dictionary needed for running compute_FIM
             # first copy value from design_values
             design_iter = self.design_vars.variable_names_value.copy()
             # update the controlled value of certain time points for certain design variables
             for i, names in enumerate(design_dimension_names):
                 # if the element is a list, all design variables in this list share the same values
-                if type(names) is list or type(names) is tuple:
+                if isinstance(names, collections.abc.Sequence):
                     for n in names:
                         design_iter[n] = list(design_set_iter)[i]
                 else:
                     design_iter[names] = list(design_set_iter)[i]
 
             self.design_vars.variable_names_value = design_iter
             iter_timer = TicTocTimer()
@@ -875,28 +909,53 @@
 
         def identity_matrix(m, i, j):
             if i == j:
                 return 1
             else:
                 return 0
 
+        ### Initialize the Jacobian if provided by the user
+
+        # If the user provides an initial Jacobian, convert it to a dictionary
+        if self.jac_initial is not None:
+            dict_jac_initialize = {}
+            for i, bu in enumerate(model.regression_parameters):
+                for j, un in enumerate(model.measured_variables):
+                    if isinstance(self.jac_initial, dict):
+                        # Jacobian is a dictionary of arrays or lists where the key is the regression parameter name
+                        dict_jac_initialize[(bu, un)] = self.jac_initial[bu][j]
+                    elif isinstance(self.jac_initial, np.ndarray):
+                        # Jacobian is a numpy array, rows are regression parameters, columns are measured variables
+                        dict_jac_initialize[(bu, un)] = self.jac_initial[i][j]
+
+        # Initialize the Jacobian matrix
+        def initialize_jac(m, i, j):
+            # If provided by the user, use the values now stored in the dictionary
+            if self.jac_initial is not None:
+                return dict_jac_initialize[(i, j)]
+            # Otherwise initialize to 0.1 (which is an arbitrary non-zero value)
+            else:
+                return 0.1
+
         model.sensitivity_jacobian = pyo.Var(
-            model.regression_parameters, model.measured_variables, initialize=0.1
+            model.regression_parameters,
+            model.measured_variables,
+            initialize=initialize_jac,
         )
 
-        if self.fim_initial:
+        if self.fim_initial is not None:
             dict_fim_initialize = {}
             for i, bu in enumerate(model.regression_parameters):
                 for j, un in enumerate(model.regression_parameters):
                     dict_fim_initialize[(bu, un)] = self.fim_initial[i][j]
 
         def initialize_fim(m, j, d):
             return dict_fim_initialize[(j, d)]
 
-        if self.fim_initial:
+        if self.fim_initial is not None:
             model.fim = pyo.Var(
                 model.regression_parameters,
                 model.regression_parameters,
                 initialize=initialize_fim,
             )
         else:
             model.fim = pyo.Var(
@@ -1007,14 +1066,40 @@
         model.fim_constraint = pyo.Constraint(
             model.regression_parameters, model.regression_parameters, rule=fim_rule
         )
 
         return model
 
     def _add_objective(self, m):
+
+        ### Initialize the Cholesky decomposition matrix
+        if self.Cholesky_option:
+
+            # Assemble the FIM matrix
+            fim = np.zeros((len(self.param), len(self.param)))
+            for i, bu in enumerate(m.regression_parameters):
+                for j, un in enumerate(m.regression_parameters):
+                    fim[i][j] = m.fim[bu, un].value
+
+            # Calculate the eigenvalues of the FIM matrix
+            eig = np.linalg.eigvals(fim)
+
+            # If the smallest eigenvalue is (practically) negative, add a diagonal matrix to make it positive definite
+            small_number = 1e-10
+            if min(eig) < small_number:
+                fim = fim + np.eye(len(self.param)) * (small_number - min(eig))
+
+            # Compute the Cholesky decomposition of the FIM matrix
+            L = np.linalg.cholesky(fim)
+
+        # Initialize the Cholesky matrix
+        for i, c in enumerate(m.regression_parameters):
+            for j, d in enumerate(m.regression_parameters):
+                m.L_ele[c, d].value = L[i, j]
+
         def cholesky_imp(m, c, d):
             """
             Calculate Cholesky L matrix using algebraic constraints
             """
             # If it is the left bottom half of L
             if list(self.param.keys()).index(c) >= list(self.param.keys()).index(d):
                 return m.fim[c, d] == sum(
@@ -1097,22 +1182,28 @@
         optimize: a dictionary, keys are design variable name, values are True or False, deciding if this design variable is optimized as DOF this time
 
         Returns
         -------
         m: model
         """
         for name in self.design_name:
+            # Loop over design variables
+            # Get Pyomo variable object
             cuid = pyo.ComponentUID(name)
             var = cuid.find_component_on(m)
             if fix_opt:
+                # If fix_opt is True, fix the design variable
                 var.fix(design_val[name])
             else:
+                # Otherwise check optimize_option
                 if optimize_option is None:
+                    # If optimize_option is None, unfix all design variables
                     var.unfix()
                 else:
+                    # Otherwise, unfix only the design variables listed in optimize_option with value True
                     if optimize_option[name]:
                         var.unfix()
         return m
 
     def _get_default_ipopt_solver(self):
         """Default solver"""
         solver = SolverFactory('ipopt')
@@ -1120,29 +1211,32 @@
         solver.options['halt_on_ampl_error'] = 'yes'
         solver.options['max_iter'] = 3000
         return solver
 
     def _solve_doe(self, m, fix=False, opt_option=None):
         """Solve DOE model.
         If it's a square problem, fix design variable and solve.
-        Else, fix design variable and solve square problem firstly, then unfix them and solve the optimization problem
+        Else, fix design variable and solve square problem first, then unfix them and solve the optimization problem
 
         Parameters
         ----------
         m:model
         fix: if true, solve two times (square first). Else, just solve the square problem
         opt_option: a dictionary, keys are design variable name, values are True or False,
             deciding if this design variable is optimized as DOF this time.
             If None, all design variables are optimized as DOF this time.
 
         Returns
         -------
         solver_results: solver results
         """
-        ### Solve square problem
+        # if fix = False, solve the optimization problem
+        # if fix = True, solve the square problem
+
+        # either fix or unfix the design variables
         mod = self._fix_design(
             m, self.design_values, fix_opt=fix, optimize_option=opt_option
         )
 
         # if user gives solver, use this solver. if not, use default IPOPT solver
         solver_result = self.solver.solve(mod, tee=self.tee_opt)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/doe/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_compute_FIM.py` & `Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_compute_FIM.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_grid_search.py` & `Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_grid_search.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_kinetics.py` & `Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_kinetics.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/examples/reactor_optimize_doe.py` & `Pyomo-6.7.2/pyomo/contrib/doe/examples/reactor_optimize_doe.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/measurements.py` & `Pyomo-6.7.2/pyomo/contrib/doe/measurements.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,14 +22,16 @@
 #  and others acting on its behalf a paid-up, nonexclusive, irrevocable,
 #  worldwide license in the Software to reproduce, distribute copies to the
 #  public, prepare derivative works, and perform publicly and display
 #  publicly, and to permit other to do so.
 #  ___________________________________________________________________________
 
 import itertools
+import collections.abc
+from pyomo.common.numeric_types import native_numeric_types
 
 
 class VariablesWithIndices:
     def __init__(self):
         """This class provides utility methods for DesignVariables and MeasurementVariables to create
         lists of Pyomo variable names with an arbitrary number of indices.
         """
@@ -89,26 +91,26 @@
             indices,
             time_index_position,
             values,
             lower_bounds,
             upper_bounds,
         )
 
-        if values:
+        if values is not None:
             # this dictionary keys are special set, values are its value
             self.variable_names_value.update(zip(added_names, values))
 
         # if a scalar (int or float) is given, set it as the lower bound for all variables
-        if lower_bounds:
-            if type(lower_bounds) in [int, float]:
+        if lower_bounds is not None:
+            if type(lower_bounds) in native_numeric_types:
                 lower_bounds = [lower_bounds] * len(added_names)
             self.lower_bounds.update(zip(added_names, lower_bounds))
 
-        if upper_bounds:
-            if type(upper_bounds) in [int, float]:
+        if upper_bounds is not None:
+            if type(upper_bounds) in native_numeric_types:
                 upper_bounds = [upper_bounds] * len(added_names)
             self.upper_bounds.update(zip(added_names, upper_bounds))
 
         return added_names
 
     def _generate_variable_names_with_indices(
         self, var_name, indices=None, time_index_position=None
@@ -167,34 +169,34 @@
         values,
         lower_bounds,
         upper_bounds,
     ):
         """
         Check if the measurement information provided are valid to use.
         """
-        assert type(var_name) is str, "var_name should be a string."
+        assert isinstance(var_name, str), "var_name should be a string."
 
         if time_index_position not in indices:
             raise ValueError("time index cannot be found in indices.")
 
         # if given a list, check if bounds have the same length with flattened variable
-        if values and len(values) != len_indices:
+        if values is not None and len(values) != len_indices:
             raise ValueError("Values is of different length with indices.")
 
         if (
-            lower_bounds
-            and type(lower_bounds) == list
-            and len(lower_bounds) != len_indices
+            lower_bounds is not None  # ensure not None
+            and isinstance(lower_bounds, collections.abc.Sequence)  # ensure list-like
+            and len(lower_bounds) != len_indices  # ensure same length
         ):
             raise ValueError("Lowerbounds is of different length with indices.")
 
         if (
-            upper_bounds
-            and type(upper_bounds) == list
-            and len(upper_bounds) != len_indices
+            upper_bounds is not None  # ensure None
+            and isinstance(upper_bounds, collections.abc.Sequence)  # ensure list-like
+            and len(upper_bounds) != len_indices  # ensure same length
         ):
             raise ValueError("Upperbounds is of different length with indices.")
 
 
 class MeasurementVariables(VariablesWithIndices):
     def __init__(self):
         """
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/result.py` & `Pyomo-6.7.2/pyomo/contrib/doe/result.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/scenario.py` & `Pyomo-6.7.2/pyomo/contrib/doe/scenario.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/doe/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/tests/test_example.py` & `Pyomo-6.7.2/pyomo/contrib/doe/tests/test_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/tests/test_fim_doe.py` & `Pyomo-6.7.2/pyomo/contrib/doe/tests/test_fim_doe.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/doe/tests/test_reactor_example.py` & `Pyomo-6.7.2/pyomo/contrib/doe/tests/test_reactor_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/example/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/bar.py` & `Pyomo-6.7.2/pyomo/contrib/example/bar.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/foo.py` & `Pyomo-6.7.2/pyomo/contrib/example/foo.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/example/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/plugins/ex_plugin.py` & `Pyomo-6.7.2/pyomo/contrib/example/plugins/ex_plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/example/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/example/tests/test_example.py` & `Pyomo-6.7.2/pyomo/contrib/example/tests/test_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/expression_bounds_walker.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/expression_bounds_walker.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/fbbt.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/fbbt.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,17 +20,18 @@
 )
 from pyomo.core.expr.numvalue import nonpyomo_leaf_types, value
 from pyomo.core.expr.numvalue import is_fixed
 import pyomo.contrib.fbbt.interval as interval
 import math
 from pyomo.core.base.block import Block
 from pyomo.core.base.constraint import Constraint
+from pyomo.core.base.expression import ExpressionData, ScalarExpression
+from pyomo.core.base.objective import ObjectiveData, ScalarObjective
 from pyomo.core.base.var import Var
 from pyomo.gdp import Disjunct
-from pyomo.core.base.expression import _GeneralExpressionData, ScalarExpression
 import logging
 from pyomo.common.errors import InfeasibleConstraintException, PyomoException
 from pyomo.common.config import (
     ConfigDict,
     ConfigValue,
     In,
     NonNegativeFloat,
@@ -329,23 +330,23 @@
     visitor: _FBBTVisitorLeafToRoot
     node: pyomo.core.expr.numeric_expr.UnaryFunctionExpression
     arg: UnaryFunctionExpression arg
     """
     _unary_leaf_to_root_map[node.getname()](visitor, node, arg)
 
 
-def _prop_bnds_leaf_to_root_GeneralExpression(visitor, node, expr):
+def _prop_bnds_leaf_to_root_NamedExpression(visitor, node, expr):
     """
     Propagate bounds from children to parent
 
     Parameters
     ----------
     visitor: _FBBTVisitorLeafToRoot
-    node: pyomo.core.base.expression._GeneralExpressionData
-    expr: GeneralExpression arg
+    node: pyomo.core.base.expression.NamedExpressionData
+    expr: NamedExpressionData arg
     """
     bnds_dict = visitor.bnds_dict
     if node in bnds_dict:
         return
 
     if expr.__class__ in native_types:
         expr_lb = expr_ub = expr
@@ -362,16 +363,18 @@
         numeric_expr.PowExpression: _prop_bnds_leaf_to_root_PowExpression,
         numeric_expr.SumExpression: _prop_bnds_leaf_to_root_SumExpression,
         numeric_expr.MonomialTermExpression: _prop_bnds_leaf_to_root_ProductExpression,
         numeric_expr.NegationExpression: _prop_bnds_leaf_to_root_NegationExpression,
         numeric_expr.UnaryFunctionExpression: _prop_bnds_leaf_to_root_UnaryFunctionExpression,
         numeric_expr.LinearExpression: _prop_bnds_leaf_to_root_SumExpression,
         numeric_expr.AbsExpression: _prop_bnds_leaf_to_root_abs,
-        _GeneralExpressionData: _prop_bnds_leaf_to_root_GeneralExpression,
-        ScalarExpression: _prop_bnds_leaf_to_root_GeneralExpression,
+        ExpressionData: _prop_bnds_leaf_to_root_NamedExpression,
+        ScalarExpression: _prop_bnds_leaf_to_root_NamedExpression,
+        ObjectiveData: _prop_bnds_leaf_to_root_NamedExpression,
+        ScalarObjective: _prop_bnds_leaf_to_root_NamedExpression,
     },
 )
 
 
 def _prop_bnds_root_to_leaf_ProductExpression(node, bnds_dict, feasibility_tol):
     """
 
@@ -894,21 +897,21 @@
         logger.warning(
             'Unsupported expression type for FBBT: {0}. Bounds will not be improved in this part of '
             'the tree.'
             ''.format(node.getname())
         )
 
 
-def _prop_bnds_root_to_leaf_GeneralExpression(node, bnds_dict, feasibility_tol):
+def _prop_bnds_root_to_leaf_NamedExpression(node, bnds_dict, feasibility_tol):
     """
     Propagate bounds from parent to children.
 
     Parameters
     ----------
-    node: pyomo.core.base.expression._GeneralExpressionData
+    node: pyomo.core.base.expression.NamedExpressionData
     bnds_dict: ComponentMap
     feasibility_tol: float
         If the bounds computed on the body of a constraint violate the bounds of the constraint by more than
         feasibility_tol, then the constraint is considered infeasible and an exception is raised. This tolerance
         is also used when performing certain interval arithmetic operations to ensure that none of the feasible
         region is removed due to floating point arithmetic and to prevent math domain errors (a larger value
         is more conservative).
@@ -941,20 +944,18 @@
     _prop_bnds_root_to_leaf_UnaryFunctionExpression
 )
 _prop_bnds_root_to_leaf_map[numeric_expr.LinearExpression] = (
     _prop_bnds_root_to_leaf_SumExpression
 )
 _prop_bnds_root_to_leaf_map[numeric_expr.AbsExpression] = _prop_bnds_root_to_leaf_abs
 
-_prop_bnds_root_to_leaf_map[_GeneralExpressionData] = (
-    _prop_bnds_root_to_leaf_GeneralExpression
-)
-_prop_bnds_root_to_leaf_map[ScalarExpression] = (
-    _prop_bnds_root_to_leaf_GeneralExpression
-)
+_prop_bnds_root_to_leaf_map[ExpressionData] = _prop_bnds_root_to_leaf_NamedExpression
+_prop_bnds_root_to_leaf_map[ScalarExpression] = _prop_bnds_root_to_leaf_NamedExpression
+_prop_bnds_root_to_leaf_map[ObjectiveData] = _prop_bnds_root_to_leaf_NamedExpression
+_prop_bnds_root_to_leaf_map[ScalarObjective] = _prop_bnds_root_to_leaf_NamedExpression
 
 
 def _check_and_reset_bounds(var, lb, ub):
     """
     This function ensures that lb is not less than var.lb and that ub is not greater than var.ub.
     """
     orig_lb = var.lb
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/interval.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/interval.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_expression_bounds_walker.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_expression_bounds_walker.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_fbbt.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_fbbt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fbbt/tests/test_interval.py` & `Pyomo-6.7.2/pyomo/contrib/fbbt/tests/test_interval.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fme/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/fme/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fme/fourier_motzkin_elimination.py` & `Pyomo-6.7.2/pyomo/contrib/fme/fourier_motzkin_elimination.py`

 * *Files 0% similar despite different names*

```diff
@@ -19,15 +19,15 @@
     Suffix,
     Expression,
     Objective,
     SortComponents,
     value,
     ConstraintList,
 )
-from pyomo.core.base import TransformationFactory, _VarData
+from pyomo.core.base import TransformationFactory, VarData
 from pyomo.core.plugins.transform.hierarchy import Transformation
 from pyomo.common.config import ConfigBlock, ConfigValue, NonNegativeFloat
 from pyomo.common.modeling import unique_component_name
 from pyomo.repn.standard_repn import generate_standard_repn
 from pyomo.common.collections import ComponentMap, ComponentSet
 from pyomo.opt import TerminationCondition
 
@@ -54,15 +54,15 @@
     # we do need value here since we didn't control v.lb and v.ub above.
     if value(min_lhs) >= constraint['lower']:
         return False  # constraint implied by var bounds
     return True
 
 
 def vars_to_eliminate_list(x):
-    if isinstance(x, (Var, _VarData)):
+    if isinstance(x, (Var, VarData)):
         if not x.is_indexed():
             return ComponentSet([x])
         ans = ComponentSet()
         for j in x.index_set():
             ans.add(x[j])
         return ans
     elif hasattr(x, '__iter__'):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/fme/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/fme/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fme/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/fme/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/fme/tests/test_fourier_motzkin_elimination.py` & `Pyomo-6.7.2/pyomo/contrib/fme/tests/test_fourier_motzkin_elimination.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/compute_bounds.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/compute_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/info.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/info.py`

 * *Files 4% similar despite different names*

```diff
@@ -31,18 +31,18 @@
     return ComponentMap()
 
 
 def disjunctive_bound(var, scope):
     """Compute the disjunctive bounds for a variable in a given scope.
 
     Args:
-        var (_VarData): Variable for which to compute bound
+        var (VarData): Variable for which to compute bound
         scope (Component): The scope in which to compute the bound. If not a
-            _DisjunctData, it will walk up the tree and use the scope of the
-            most immediate enclosing _DisjunctData.
+            DisjunctData, it will walk up the tree and use the scope of the
+            most immediate enclosing DisjunctData.
 
     Returns:
         numeric: the tighter of either the disjunctive lower bound, the
             variable lower bound, or (-inf, inf) if neither exist.
 
     """
     # Initialize to the global variable bound
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdp_bounds/tests/test_gdp_bounds.py` & `Pyomo-6.7.2/pyomo/contrib/gdp_bounds/tests/test_gdp_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/GDPopt.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/GDPopt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/algorithm_base_class.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/algorithm_base_class.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/branch_and_bound.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/branch_and_bound.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/config_options.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/config_options.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/create_oa_subproblems.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/create_oa_subproblems.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/cut_generation.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/cut_generation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/discrete_problem_initialize.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/discrete_problem_initialize.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/enumerate.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/enumerate.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/gloa.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/gloa.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/loa.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/loa.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/nlp_initialization.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/nlp_initialization.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/oa_algorithm_utils.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/oa_algorithm_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/ric.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/ric.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/solve_discrete_problem.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/solve_discrete_problem.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/solve_subproblem.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/solve_subproblem.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/common_tests.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/common_tests.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_LBB.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_LBB.py`

 * *Files 2% similar despite different names*

```diff
@@ -55,14 +55,15 @@
         self.assertEqual(
             result.solver.termination_condition, TerminationCondition.infeasible
         )
         self.assertIsNone(m.x.value)
         self.assertIsNone(m.d.disjuncts[0].indicator_var.value)
         self.assertIsNone(m.d.disjuncts[1].indicator_var.value)
 
+    @unittest.skipUnless(z3_available, "Z3 SAT solver is not available")
     def test_infeasible_GDP_check_sat(self):
         """Test for infeasible GDP with check_sat option True."""
         m = ConcreteModel()
         m.x = Var(bounds=(0, 2))
         m.d = Disjunction(expr=[[m.x**2 >= 3, m.x >= 3], [m.x**2 <= -1, m.x <= -1]])
         m.o = Objective(expr=m.x)
         output = StringIO()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_enumerate.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_enumerate.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/tests/test_gdpopt.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/tests/test_gdpopt.py`

 * *Files 0% similar despite different names*

```diff
@@ -18,15 +18,14 @@
 from os.path import join, normpath
 
 import pyomo.common.unittest as unittest
 from pyomo.common.log import LoggingIntercept
 from pyomo.common.collections import Bunch
 from pyomo.common.config import ConfigDict, ConfigValue
 from pyomo.common.fileutils import import_file, PYOMO_ROOT_DIR
-from pyomo.contrib.appsi.solvers.gurobi import Gurobi
 from pyomo.contrib.gdpopt.create_oa_subproblems import (
     add_util_block,
     add_disjunct_list,
     add_constraints_by_disjunct,
     add_global_constraint_list,
 )
 import pyomo.contrib.gdpopt.tests.common_tests as ct
@@ -763,14 +762,17 @@
                 "time limit of 1 seconds.",
                 output.getvalue().strip(),
             )
         self.assertEqual(
             results.solver.termination_condition, TerminationCondition.maxTimeLimit
         )
 
+    @unittest.skipUnless(
+        license_available, "No BARON license--8PP logical problem exceeds demo size"
+    )
     def test_LOA_8PP_logical_default_init(self):
         """Test logic-based outer approximation with 8PP."""
         exfile = import_file(join(exdir, 'eight_process', 'eight_proc_logical.py'))
         eight_process = exfile.build_eight_process_flowsheet()
         results = SolverFactory('gdpopt.loa').solve(
             eight_process, mip_solver=mip_solver, nlp_solver=nlp_solver, tee=False
         )
@@ -866,14 +868,17 @@
             eight_process,
             init_algorithm='max_binary',
             mip_solver=mip_solver,
             nlp_solver=nlp_solver,
         )
         ct.check_8PP_solution(self, eight_process, results)
 
+    @unittest.skipUnless(
+        license_available, "No BARON license--8PP logical problem exceeds demo size"
+    )
     def test_LOA_8PP_logical_maxBinary(self):
         """Test logic-based OA with max_binary initialization."""
         exfile = import_file(join(exdir, 'eight_process', 'eight_proc_logical.py'))
         eight_process = exfile.build_eight_process_flowsheet()
         results = SolverFactory('gdpopt.loa').solve(
             eight_process,
             init_algorithm='max_binary',
@@ -1046,15 +1051,19 @@
             mip_solver=mip_solver,
             nlp_solver=nlp_solver,
             subproblem_initialization_method=assert_correct_disjuncts_active,
         )
 
         self.assertTrue(fabs(value(eight_process.profit.expr) - 68) <= 1e-2)
 
-    @unittest.skipUnless(Gurobi().available(), "APPSI Gurobi solver is not available")
+    @unittest.skipUnless(
+        SolverFactory('appsi_gurobi').available(exception_flag=False)
+        and SolverFactory('appsi_gurobi').license_is_valid(),
+        "Legacy APPSI Gurobi solver is not available",
+    )
     def test_auto_persistent_solver(self):
         exfile = import_file(join(exdir, 'eight_process', 'eight_proc_model.py'))
         m = exfile.build_eight_process_flowsheet()
         results = SolverFactory('gdpopt.loa').solve(m, mip_solver='appsi_gurobi')
 
         self.assertTrue(fabs(value(m.profit.expr) - 68) <= 1e-2)
         ct.check_8PP_solution(self, m, results)
@@ -1122,14 +1131,17 @@
         exfile = import_file(join(exdir, 'eight_process', 'eight_proc_model.py'))
         eight_process = exfile.build_eight_process_flowsheet()
         results = SolverFactory('gdpopt.ric').solve(
             eight_process, mip_solver=mip_solver, nlp_solver=nlp_solver, tee=False
         )
         ct.check_8PP_solution(self, eight_process, results)
 
+    @unittest.skipUnless(
+        license_available, "No BARON license--8PP logical problem exceeds demo size"
+    )
     def test_RIC_8PP_logical_default_init(self):
         """Test logic-based outer approximation with 8PP."""
         exfile = import_file(join(exdir, 'eight_process', 'eight_proc_logical.py'))
         eight_process = exfile.build_eight_process_flowsheet()
         results = SolverFactory('gdpopt.ric').solve(
             eight_process, mip_solver=mip_solver, nlp_solver=nlp_solver, tee=False
         )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/gdpopt/util.py` & `Pyomo-6.7.2/pyomo/contrib/gdpopt/util.py`

 * *Files 1% similar despite different names*

```diff
@@ -549,10 +549,17 @@
     # need to set it.
     bigm._config = bigm.CONFIG()
     # ESJ: This function doesn't handle ConstraintDatas, and bigm is not
     # sufficiently modular to have a function that does at the moment, so I'm
     # making a Reference to the ComponentData so that it will look like an
     # indexed component for now. If I redesign bigm at some point, then this
     # could be prettier.
-    bigm._transform_constraint(Reference(constraint), parent_disjunct, None, [], [])
+    bigm._transform_constraint(
+        Reference(constraint),
+        parent_disjunct,
+        None,
+        [],
+        [],
+        1 - parent_disjunct.binary_indicator_var,
+    )
     # Now get rid of it because this is a class attribute!
     del bigm._config
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/gjh/GJH.py` & `Pyomo-6.7.2/pyomo/contrib/gjh/GJH.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gjh/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/gjh/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gjh/getGJH.py` & `Pyomo-6.7.2/pyomo/contrib/gjh/getGJH.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/gjh/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/gjh/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/iis/__init__.py` & `Pyomo-6.7.2/pyomo/repn/beta/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,8 +5,8 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.contrib.iis.iis import write_iis
+import pyomo.repn.beta.matrix
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/iis/iis.py` & `Pyomo-6.7.2/pyomo/contrib/iis/iis.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/iis/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/iis/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/iis/tests/test_iis.py` & `Pyomo-6.7.2/pyomo/contrib/iis/tests/test_iis.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/dulmage_mendelsohn.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/dulmage_mendelsohn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/common/tests/test_dulmage_mendelsohn.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/common/tests/test_dulmage_mendelsohn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/config.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/config.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,14 +32,21 @@
     ``compute_values=True``
     """
 
     ampl_repn = 3
     """Use ``pyomo.repn.plugins.nl_writer.AMPLRepnVisitor``"""
 
 
+class IncidenceOrder(enum.Enum):
+
+    dulmage_mendelsohn_upper = 0
+
+    dulmage_mendelsohn_lower = 1
+
+
 _include_fixed = ConfigValue(
     default=False,
     domain=bool,
     description="Include fixed variables",
     doc=(
         "Flag indicating whether fixed variables should be included in the"
         " incidence graph"
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/connected.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/connected.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/dulmage_mendelsohn.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/dulmage_mendelsohn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/incidence.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/incidence.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/interface.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/interface.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,28 +11,28 @@
 """Utility functions and a utility class for interfacing Pyomo components with
 useful graph algorithms.
 
 """
 
 import enum
 import textwrap
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base.var import Var
 from pyomo.core.base.constraint import Constraint
 from pyomo.core.base.objective import Objective
 from pyomo.core.expr import EqualityExpression
 from pyomo.util.subsystems import create_subsystem_block
 from pyomo.common.collections import ComponentSet, ComponentMap
 from pyomo.common.dependencies import (
     attempt_import,
     networkx as nx,
     scipy as sp,
     plotly,
 )
-from pyomo.common.deprecation import deprecated
+from pyomo.common.deprecation import deprecated, deprecation_warning
 from pyomo.contrib.incidence_analysis.config import get_config_from_kwds
 from pyomo.contrib.incidence_analysis.matching import maximum_matching
 from pyomo.contrib.incidence_analysis.connected import get_independent_submatrices
 from pyomo.contrib.incidence_analysis.triangularize import (
     get_scc_of_projection,
     block_triangularize,
     get_diagonal_blocks,
@@ -275,15 +275,15 @@
         # WARNING: This cache will become invalid if the user alters their
         # model.
         self._config = get_config_from_kwds(**kwds)
         if model is None:
             self._incidence_graph = None
             self._variables = None
             self._constraints = None
-        elif isinstance(model, _BlockData):
+        elif isinstance(model, BlockData):
             self._constraints = [
                 con
                 for con in model.component_data_objects(Constraint, active=active)
                 if include_inequality or isinstance(con.expr, EqualityExpression)
             ]
             self._variables = list(
                 _generate_variables_in_constraints(self._constraints, **self._config)
@@ -344,15 +344,15 @@
             )
             # For now, don't check any properties of this graph. We could check
             # for a bipartition that matches the variable and constraint lists.
             self._incidence_graph = nx_graph
         else:
             raise TypeError(
                 "Unsupported type for incidence graph. Expected PyomoNLP"
-                " or _BlockData but got %s." % type(model)
+                " or BlockData but got %s." % type(model)
             )
 
     @property
     def variables(self):
         """The variables participating in the incidence graph"""
         if self._incidence_graph is None:
             raise RuntimeError("Cannot get variables when nothing is cached")
@@ -449,19 +449,37 @@
 
     def _validate_input(self, variables, constraints):
         if variables is None:
             if self._incidence_graph is None:
                 raise ValueError("Neither variables nor a model have been provided.")
             else:
                 variables = self.variables
+        elif self._incidence_graph is not None:
+            # If variables were provided and an incidence graph is cached,
+            # make sure the provided variables exist in the graph.
+            for var in variables:
+                if var not in self._var_index_map:
+                    raise KeyError(
+                        f"Variable {var} does not exist in the cached"
+                        " incidence graph."
+                    )
         if constraints is None:
             if self._incidence_graph is None:
                 raise ValueError("Neither constraints nor a model have been provided.")
             else:
                 constraints = self.constraints
+        elif self._incidence_graph is not None:
+            # If constraints were provided and an incidence graph is cached,
+            # make sure the provided constraints exist in the graph.
+            for con in constraints:
+                if con not in self._con_index_map:
+                    raise KeyError(
+                        f"Constraint {con} does not exist in the cached"
+                        " incidence graph."
+                    )
 
         _check_unindexed(variables + constraints)
         return variables, constraints
 
     def _extract_subgraph(self, variables, constraints):
         if self._incidence_graph is None:
             # Note that we pass along self._config here, so any kwds used
@@ -850,55 +868,96 @@
         var_partition = ColPartition(
             *[[variables[i - M] for i in subset] for subset in col_partition]
         )
         # Switch the order of the maps here to match the method call.
         # Hopefully this does not get too confusing...
         return var_partition, con_partition
 
-    def remove_nodes(self, nodes, constraints=None):
+    def remove_nodes(self, variables=None, constraints=None):
         """Removes the specified variables and constraints (columns and
         rows) from the cached incidence matrix.
 
         This is a "projection" of the variable and constraint vectors, rather
         than something like a vertex elimination. For the puropse of this
         method, there is no need to distinguish between variables and
         constraints. However, we provide the "constraints" argument so a call
         signature similar to other methods in this class is still valid.
 
         Parameters
         ----------
-        nodes: list
-            VarData or ConData objects whose columns or rows will be
-            removed from the incidence matrix.
+        variables: list
+            VarData objects whose nodes will be removed from the incidence graph
         constraints: list
-            VarData or ConData objects whose columns or rows will be
-            removed from the incidence matrix.
+            ConData objects whose nodes will be removed from the incidence graph
+
+        .. note::
+
+           **Deprecation in Pyomo v6.7.2**
+
+           The pre-6.7.2 implementation of ``remove_nodes`` allowed variables and
+           constraints to remove to be specified in a single list. This made
+           error checking difficult, and indeed, if invalid components were
+           provided, we carried on silently instead of throwing an error or
+           warning. As part of a fix to raise an error if an invalid component
+           (one that is not part of the incidence graph) is provided, we now require
+           variables and constraints to be specified separately.
 
         """
         if constraints is None:
             constraints = []
+        if variables is None:
+            variables = []
         if self._incidence_graph is None:
             raise RuntimeError(
                 "Attempting to remove variables and constraints from cached "
                 "incidence matrix,\nbut no incidence matrix has been cached."
             )
-        to_exclude = ComponentSet(nodes)
-        to_exclude.update(constraints)
-        vars_to_include = [v for v in self.variables if v not in to_exclude]
-        cons_to_include = [c for c in self.constraints if c not in to_exclude]
+
+        vars_to_validate = []
+        cons_to_validate = []
+        depr_msg = (
+            "In IncidenceGraphInterface.remove_nodes, passing variables and"
+            " constraints in the same list is deprecated. Please separate your"
+            " variables and constraints and pass them in the order variables,"
+            " constraints."
+        )
+        if any(var in self._con_index_map for var in variables) or any(
+            con in self._var_index_map for con in constraints
+        ):
+            deprecation_warning(depr_msg, version="6.7.2")
+        # If we received variables/constraints in the same list, sort them.
+        # Any unrecognized objects will be caught by _validate_input.
+        for var in variables:
+            if var in self._con_index_map:
+                cons_to_validate.append(var)
+            else:
+                vars_to_validate.append(var)
+        for con in constraints:
+            if con in self._var_index_map:
+                vars_to_validate.append(con)
+            else:
+                cons_to_validate.append(con)
+
+        variables, constraints = self._validate_input(
+            vars_to_validate, cons_to_validate
+        )
+        v_exclude = ComponentSet(variables)
+        c_exclude = ComponentSet(constraints)
+        vars_to_include = [v for v in self.variables if v not in v_exclude]
+        cons_to_include = [c for c in self.constraints if c not in c_exclude]
         incidence_graph = self._extract_subgraph(vars_to_include, cons_to_include)
         # update attributes
         self._variables = vars_to_include
         self._constraints = cons_to_include
         self._incidence_graph = incidence_graph
         self._var_index_map = ComponentMap(
-            (var, i) for i, var in enumerate(self.variables)
+            (var, i) for i, var in enumerate(vars_to_include)
         )
         self._con_index_map = ComponentMap(
-            (con, i) for i, con in enumerate(self._constraints)
+            (con, i) for i, con in enumerate(cons_to_include)
         )
 
     def plot(self, variables=None, constraints=None, title=None, show=True):
         """Plot the bipartite incidence graph of variables and constraints"""
         variables, constraints = self._validate_input(variables, constraints)
         graph = self._extract_subgraph(variables, constraints)
         M = len(constraints)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/matching.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/matching.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/scc_solver.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/scc_solver.py`

 * *Files 13% similar despite different names*

```diff
@@ -14,70 +14,80 @@
 from pyomo.core.base.constraint import Constraint
 from pyomo.util.calc_var_value import calculate_variable_from_constraint
 from pyomo.util.subsystems import TemporarySubsystemManager, generate_subsystem_blocks
 from pyomo.contrib.incidence_analysis.interface import (
     IncidenceGraphInterface,
     _generate_variables_in_constraints,
 )
+from pyomo.contrib.incidence_analysis.config import IncidenceMethod
 
 
 _log = logging.getLogger(__name__)
 
 
 def generate_strongly_connected_components(
-    constraints, variables=None, include_fixed=False
+    constraints, variables=None, include_fixed=False, igraph=None
 ):
-    """Yield in order ``_BlockData`` that each contain the variables and
+    """Yield in order ``BlockData`` that each contain the variables and
     constraints of a single diagonal block in a block lower triangularization
     of the incidence matrix of constraints and variables
 
     These diagonal blocks correspond to strongly connected components of the
     bipartite incidence graph, projected with respect to a perfect matching
     into a directed graph.
 
     Parameters
     ----------
     constraints: List of Pyomo constraint data objects
         Constraints used to generate strongly connected components.
     variables: List of Pyomo variable data objects
         Variables that may participate in strongly connected components.
         If not provided, all variables in the constraints will be used.
-    include_fixed: Bool
+    include_fixed: Bool, optional
         Indicates whether fixed variables will be included when
         identifying variables in constraints.
+    igraph: IncidenceGraphInterface, optional
+        Incidence graph containing (at least) the provided constraints
+        and variables.
 
     Yields
     ------
-    Tuple of ``_BlockData``, list-of-variables
+    Tuple of ``BlockData``, list-of-variables
         Blocks containing the variables and constraints of every strongly
         connected component, in a topological order. The variables are the
         "input variables" for that block.
 
     """
     if variables is None:
         variables = list(
-            _generate_variables_in_constraints(constraints, include_fixed=include_fixed)
+            _generate_variables_in_constraints(
+                constraints,
+                include_fixed=include_fixed,
+                method=IncidenceMethod.ampl_repn,
+            )
         )
 
     assert len(variables) == len(constraints)
-    igraph = IncidenceGraphInterface()
+    if igraph is None:
+        igraph = IncidenceGraphInterface()
+
     var_blocks, con_blocks = igraph.block_triangularize(
         variables=variables, constraints=constraints
     )
     subsets = [(cblock, vblock) for vblock, cblock in zip(var_blocks, con_blocks)]
     for block, inputs in generate_subsystem_blocks(
         subsets, include_fixed=include_fixed
     ):
         # TODO: How does len scale for reference-to-list?
         assert len(block.vars) == len(block.cons)
         yield (block, inputs)
 
 
 def solve_strongly_connected_components(
-    block, solver=None, solve_kwds=None, calc_var_kwds=None
+    block, *, solver=None, solve_kwds=None, use_calc_var=True, calc_var_kwds=None
 ):
     """Solve a square system of variables and equality constraints by
     solving strongly connected components individually.
 
     Strongly connected components (of the directed graph of constraints
     obtained from a perfect matching of variables and constraints) are
     the diagonal blocks in a block triangularization of the incidence
@@ -94,53 +104,61 @@
         The Pyomo block whose variables and constraints will be solved
     solver: Pyomo solver object
         The solver object that will be used to solve strongly connected
         components of size greater than one constraint. Must implement
         a solve method.
     solve_kwds: Dictionary
         Keyword arguments for the solver's solve method
+    use_calc_var: Bool
+        Whether to use ``calculate_variable_from_constraint`` for one-by-one
+        square system solves
     calc_var_kwds: Dictionary
         Keyword arguments for calculate_variable_from_constraint
 
     Returns
     -------
     List of results objects returned by each call to solve
 
     """
     if solve_kwds is None:
         solve_kwds = {}
     if calc_var_kwds is None:
         calc_var_kwds = {}
 
     igraph = IncidenceGraphInterface(
-        block, active=True, include_fixed=False, include_inequality=False
+        block,
+        active=True,
+        include_fixed=False,
+        include_inequality=False,
+        method=IncidenceMethod.ampl_repn,
     )
     constraints = igraph.constraints
     variables = igraph.variables
 
     res_list = []
     log_blocks = _log.isEnabledFor(logging.DEBUG)
-    for scc, inputs in generate_strongly_connected_components(constraints, variables):
-        with TemporarySubsystemManager(to_fix=inputs):
+    for scc, inputs in generate_strongly_connected_components(
+        constraints, variables, igraph=igraph
+    ):
+        with TemporarySubsystemManager(to_fix=inputs, remove_bounds_on_fix=True):
             N = len(scc.vars)
-            if N == 1:
+            if N == 1 and use_calc_var:
                 if log_blocks:
                     _log.debug(f"Solving 1x1 block: {scc.cons[0].name}.")
                 results = calculate_variable_from_constraint(
                     scc.vars[0], scc.cons[0], **calc_var_kwds
                 )
-                res_list.append(results)
             else:
                 if solver is None:
                     var_names = [var.name for var in scc.vars.values()][:10]
                     con_names = [con.name for con in scc.cons.values()][:10]
                     raise RuntimeError(
                         "An external solver is required if block has strongly\n"
                         "connected components of size greater than one (is not"
                         " a DAG).\nGot an SCC of size %sx%s including"
                         " components:\n%s\n%s" % (N, N, var_names, con_names)
                     )
                 if log_blocks:
                     _log.debug(f"Solving {N}x{N} block.")
                 results = solver.solve(scc, **solve_kwds)
-                res_list.append(results)
+            res_list.append(results)
     return res_list
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/models_for_testing.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/models_for_testing.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_connected.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_connected.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_dulmage_mendelsohn.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_dulmage_mendelsohn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_incidence.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_incidence.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_interface.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_interface.py`

 * *Files 5% similar despite different names*

```diff
@@ -630,25 +630,23 @@
 
     def test_exception(self):
         model = make_gas_expansion_model()
         model.obj = pyo.Objective(expr=0)
         nlp = PyomoNLP(model)
         igraph = IncidenceGraphInterface(nlp)
 
-        with self.assertRaises(RuntimeError) as exc:
+        with self.assertRaisesRegex(KeyError, "does not exist"):
             variables = [model.P]
             constraints = [model.ideal_gas]
             igraph.maximum_matching(variables, constraints)
-        self.assertIn("must be unindexed", str(exc.exception))
 
-        with self.assertRaises(RuntimeError) as exc:
+        with self.assertRaisesRegex(KeyError, "does not exist"):
             variables = [model.P]
             constraints = [model.ideal_gas]
             igraph.block_triangularize(variables, constraints)
-        self.assertIn("must be unindexed", str(exc.exception))
 
 
 @unittest.skipUnless(networkx_available, "networkx is not available.")
 class TestGasExpansionModelInterfaceClassStructural(unittest.TestCase):
     # In these tests we pass a model to the interface and are caching a
     # structural incidence matrix.
     def test_imperfect_matching(self):
@@ -881,25 +879,23 @@
                 self.assertEqual(con_block_map[model.mbal[i]], idx)
                 self.assertEqual(con_block_map[model.ebal[i]], idx)
 
     def test_exception(self):
         model = make_gas_expansion_model()
         igraph = IncidenceGraphInterface(model)
 
-        with self.assertRaises(RuntimeError) as exc:
+        with self.assertRaisesRegex(KeyError, "does not exist"):
             variables = [model.P]
             constraints = [model.ideal_gas]
             igraph.maximum_matching(variables, constraints)
-        self.assertIn("must be unindexed", str(exc.exception))
 
-        with self.assertRaises(RuntimeError) as exc:
+        with self.assertRaisesRegex(KeyError, "does not exist"):
             variables = [model.P]
             constraints = [model.ideal_gas]
             igraph.block_triangularize(variables, constraints)
-        self.assertIn("must be unindexed", str(exc.exception))
 
     @unittest.skipUnless(scipy_available, "scipy is not available.")
     def test_remove(self):
         model = make_gas_expansion_model()
         igraph = IncidenceGraphInterface(model)
 
         n_eqn = len(list(model.component_data_objects(pyo.Constraint)))
@@ -919,15 +915,15 @@
         self.assertIn(model.F[2], underconstrained_set)
 
         N, M = igraph.incidence_matrix.shape
 
         # Say we know that these variables and constraints should
         # be matched...
         vars_to_remove = [model.F[0], model.F[2]]
-        cons_to_remove = (model.mbal[1], model.mbal[2])
+        cons_to_remove = [model.mbal[1], model.mbal[2]]
         igraph.remove_nodes(vars_to_remove, cons_to_remove)
         variable_set = ComponentSet(igraph.variables)
         self.assertNotIn(model.F[0], variable_set)
         self.assertNotIn(model.F[2], variable_set)
         var_dmp, con_dmp = igraph.dulmage_mendelsohn()
         underconstrained_set = ComponentSet(
             var_dmp.unmatched + var_dmp.underconstrained
@@ -1305,15 +1301,15 @@
         N, M = igraph.incidence_matrix.shape
 
         # flow_comp[1] is underconstrained, but we think it should be
         # specified by flow_eqn[1], so we remove these from the incidence
         # matrix.
         vars_to_remove = [m.flow_comp[1]]
         cons_to_remove = [m.flow_eqn[1]]
-        igraph.remove_nodes(vars_to_remove + cons_to_remove)
+        igraph.remove_nodes(vars_to_remove, cons_to_remove)
         var_dmp, con_dmp = igraph.dulmage_mendelsohn()
         var_con_set = ComponentSet(igraph.variables + igraph.constraints)
         underconstrained_set = ComponentSet(
             var_dmp.unmatched + var_dmp.underconstrained
         )
         self.assertNotIn(m.flow_comp[1], var_con_set)
         self.assertNotIn(m.flow_eqn[1], var_con_set)
@@ -1456,14 +1452,50 @@
     def test_remove_no_matrix(self):
         m = pyo.ConcreteModel()
         m.v1 = pyo.Var()
         igraph = IncidenceGraphInterface()
         with self.assertRaisesRegex(RuntimeError, "no incidence matrix"):
             igraph.remove_nodes([m.v1])
 
+    def test_remove_bad_node(self):
+        m = pyo.ConcreteModel()
+        m.x = pyo.Var([1, 2, 3])
+        m.eq = pyo.Constraint(pyo.PositiveIntegers)
+        m.eq[1] = m.x[1] * m.x[2] == m.x[3]
+        m.eq[2] = m.x[1] + 2 * m.x[2] == 3 * m.x[3]
+        igraph = IncidenceGraphInterface(m)
+        with self.assertRaisesRegex(KeyError, "does not exist"):
+            # Suppose we think something like this should work. We should get
+            # an error, and not silently do nothing.
+            igraph.remove_nodes([m.x], [m.eq[1]])
+
+        with self.assertRaisesRegex(KeyError, "does not exist"):
+            igraph.remove_nodes(None, [m.eq])
+
+        with self.assertRaisesRegex(KeyError, "does not exist"):
+            igraph.remove_nodes([[m.x[1], m.x[2]], [m.eq[1]]])
+
+    def test_remove_varcon_samelist_deprecated(self):
+        m = pyo.ConcreteModel()
+        m.x = pyo.Var([1, 2, 3])
+        m.eq = pyo.Constraint(pyo.PositiveIntegers)
+        m.eq[1] = m.x[1] * m.x[2] == m.x[3]
+        m.eq[2] = m.x[1] + 2 * m.x[2] == 3 * m.x[3]
+
+        igraph = IncidenceGraphInterface(m)
+        # This raises a deprecation warning. When the deprecated functionality
+        # is removed, this will fail, and this test should be updated accordingly.
+        igraph.remove_nodes([m.eq[1], m.x[1]])
+        self.assertEqual(len(igraph.variables), 2)
+        self.assertEqual(len(igraph.constraints), 1)
+
+        igraph.remove_nodes([], [m.eq[2], m.x[2]])
+        self.assertEqual(len(igraph.variables), 1)
+        self.assertEqual(len(igraph.constraints), 0)
+
 
 @unittest.skipUnless(networkx_available, "networkx is not available.")
 @unittest.skipUnless(scipy_available, "scipy is not available.")
 class TestIncludeInequality(unittest.TestCase):
     def make_model_with_inequalities(self):
         m = make_degenerate_solid_phase_model()
 
@@ -1836,15 +1868,15 @@
         m.eq4 = pyo.Constraint(expr=m.x[1] == 5 * m.x[2])
 
         igraph = IncidenceGraphInterface(m)
         # Eliminate x[1] using eq4
         for adj_con in igraph.get_adjacent_to(m.x[1]):
             for adj_var in igraph.get_adjacent_to(m.eq4):
                 igraph.add_edge(adj_var, adj_con)
-        igraph.remove_nodes([m.x[1], m.eq4])
+        igraph.remove_nodes([m.x[1]], [m.eq4])
 
         assert ComponentSet(igraph.variables) == ComponentSet([m.x[2], m.x[3], m.x[4]])
         assert ComponentSet(igraph.constraints) == ComponentSet([m.eq1, m.eq2, m.eq3])
         self.assertEqual(7, igraph.n_edges)
 
         assert m.x[2] in ComponentSet(igraph.get_adjacent_to(m.eq1))
         assert m.x[2] in ComponentSet(igraph.get_adjacent_to(m.eq2))
@@ -1884,14 +1916,14 @@
         m.block = pyo.Block([1, 2, 3])
         m.block[1].subblock = make_degenerate_solid_phase_model()
         igraph = IncidenceGraphInterface(m.block[1])
         var_dmp, con_dmp = igraph.dulmage_mendelsohn()
         self.assertEqual(len(var_dmp.unmatched), 1)
         self.assertEqual(len(con_dmp.unmatched), 1)
 
-        msg = "Unsupported type.*_BlockData"
+        msg = "Unsupported type.*BlockData"
         with self.assertRaisesRegex(TypeError, msg):
             igraph = IncidenceGraphInterface(m.block)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_matching.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_matching.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_scc_solver.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_scc_solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/tests/test_triangularize.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_triangularize.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/triangularize.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/triangularize.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/incidence_analysis/util.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/examples/ex1.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/examples/ex1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/interface.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/interior_point.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/interior_point.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/inverse_reduced_hessian.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/inverse_reduced_hessian.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/base_linear_solver_interface.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/base_linear_solver_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/ma27_interface.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/ma27_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/mumps_interface.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/mumps_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/scipy_interface.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/scipy_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/test_linear_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/test_linear_solvers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/linalg/tests/test_realloc.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/linalg/tests/test_realloc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_interior_point.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_interior_point.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_inverse_reduced_hessian.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_inverse_reduced_hessian.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_realloc.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_realloc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/interior_point/tests/test_reg.py` & `Pyomo-6.7.2/pyomo/contrib/interior_point/tests/test_reg.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/latex_printer/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,29 +5,21 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-#  ___________________________________________________________________________
+# ___________________________________________________________________________
 #
-#  Pyomo: Python Optimization Modeling Objects
-#  Copyright (c) 2008-2023
+# Pyomo: Python Optimization Modeling Objects
+# Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
-#  Under the terms of Contract DE-NA0003525 with National Technology and
-#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
-#  rights in this software.
-#  This software is distributed under the 3-clause BSD License.
-#  ___________________________________________________________________________
-
-# Recommended just to build all of the appropriate things
-import pyomo.environ
+# Under the terms of Contract DE-NA0003525 with National Technology and
+# Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
+# rights in this software.
+# This software is distributed under the 3-clause BSD License.
+# ___________________________________________________________________________
 
-# Remove one layer of .latex_printer
-# import statemnt is now:
-#   from pyomo.contrib.latex_printer import latex_printer
-try:
-    from pyomo.contrib.latex_printer.latex_printer import latex_printer
-except:
-    pass
-    # in this case, the dependencies are not installed, nothing will work
+"""
+pyomo.contrib.sensitivity_toolbox tests
+"""
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/latex_printer/latex_printer.py` & `Pyomo-6.7.2/pyomo/contrib/latex_printer/latex_printer.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,25 +5,14 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-#  ___________________________________________________________________________
-#
-#  Pyomo: Python Optimization Modeling Objects
-#  Copyright (c) 2008-2023
-#  National Technology and Engineering Solutions of Sandia, LLC
-#  Under the terms of Contract DE-NA0003525 with National Technology and
-#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
-#  rights in this software.
-#  This software is distributed under the 3-clause BSD License.
-#  ___________________________________________________________________________
-
 import math
 import copy
 import re
 import io
 import pyomo.environ as pyo
 from pyomo.core.expr.visitor import StreamBasedExpressionVisitor
 from pyomo.core.expr import (
@@ -41,59 +30,93 @@
     RangedExpression,
     Expr_ifExpression,
     ExternalFunctionExpression,
 )
 
 from pyomo.core.expr.visitor import identify_components
 from pyomo.core.expr.base import ExpressionBase
-from pyomo.core.base.expression import ScalarExpression, _GeneralExpressionData
-from pyomo.core.base.objective import ScalarObjective, _GeneralObjectiveData
+from pyomo.core.base.expression import ScalarExpression, ExpressionData
+from pyomo.core.base.objective import ScalarObjective, ObjectiveData
 import pyomo.core.kernel as kernel
 from pyomo.core.expr.template_expr import (
     GetItemExpression,
     GetAttrExpression,
     TemplateSumExpression,
     IndexTemplate,
     Numeric_GetItemExpression,
     templatize_constraint,
     resolve_template,
     templatize_rule,
 )
-from pyomo.core.base.var import ScalarVar, _GeneralVarData, IndexedVar
-from pyomo.core.base.param import _ParamData, ScalarParam, IndexedParam
-from pyomo.core.base.set import _SetData
+from pyomo.core.base.var import ScalarVar, VarData, IndexedVar
+from pyomo.core.base.param import ParamData, ScalarParam, IndexedParam
+from pyomo.core.base.set import SetData, SetOperator
 from pyomo.core.base.constraint import ScalarConstraint, IndexedConstraint
 from pyomo.common.collections.component_map import ComponentMap
 from pyomo.common.collections.component_set import ComponentSet
 from pyomo.core.expr.template_expr import (
     NPV_Numeric_GetItemExpression,
     NPV_Structural_GetItemExpression,
     Numeric_GetAttrExpression,
 )
 from pyomo.core.expr.numeric_expr import NPV_SumExpression, NPV_DivisionExpression
 from pyomo.core.base.block import IndexedBlock
 
 from pyomo.core.base.external import _PythonCallbackFunctionID
 from pyomo.core.base.enums import SortComponents
 
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 
 from pyomo.repn.util import ExprType
 
 from pyomo.common import DeveloperError
 
 _CONSTANT = ExprType.CONSTANT
 _MONOMIAL = ExprType.MONOMIAL
 _GENERAL = ExprType.GENERAL
 
 from pyomo.common.errors import InfeasibleConstraintException
 
 from pyomo.common.dependencies import numpy as np, numpy_available
 
 
+set_operator_map = {
+    '|': r' \cup ',
+    '&': r' \cap ',
+    '*': r' \times ',
+    '-': r' \setminus ',
+    '^': r' \triangle ',
+}
+
+latex_reals = r'\mathds{R}'
+latex_integers = r'\mathds{Z}'
+
+domainMap = {
+    'Reals': latex_reals,
+    'PositiveReals': latex_reals + '_{> 0}',
+    'NonPositiveReals': latex_reals + '_{\\leq 0}',
+    'NegativeReals': latex_reals + '_{< 0}',
+    'NonNegativeReals': latex_reals + '_{\\geq 0}',
+    'Integers': latex_integers,
+    'PositiveIntegers': latex_integers + '_{> 0}',
+    'NonPositiveIntegers': latex_integers + '_{\\leq 0}',
+    'NegativeIntegers': latex_integers + '_{< 0}',
+    'NonNegativeIntegers': latex_integers + '_{\\geq 0}',
+    'Boolean': '\\left\\{ \\text{True} , \\text{False} \\right \\}',
+    'Binary': '\\left\\{ 0 , 1 \\right \\}',
+    # 'Any': None,
+    # 'AnyWithNone': None,
+    'EmptySet': '\\varnothing',
+    'UnitInterval': latex_reals,
+    'PercentFraction': latex_reals,
+    # 'RealInterval' :        None    ,
+    # 'IntegerInterval' :     None    ,
+}
+
+
 def decoder(num, base):
     if int(num) != abs(num):
         # Requiring an integer is nice, but not strictly necessary;
         # the algorithm works for floating point
         raise ValueError("num should be a nonnegative integer")
     if int(base) != abs(base) or not base:
         raise ValueError("base should be a positive integer")
@@ -282,22 +305,23 @@
 
 def handle_functionID_node(visitor, node, *args):
     # seems to just be a placeholder empty wrapper object
     return ''
 
 
 def handle_indexTemplate_node(visitor, node, *args):
-    if node._set in ComponentSet(visitor.setMap.keys()):
+    if node._set in visitor.setMap:
         # already detected set, do nothing
         pass
     else:
-        visitor.setMap[node._set] = 'SET%d' % (len(visitor.setMap.keys()) + 1)
+        visitor.setMap[node._set] = 'SET%d' % (len(visitor.setMap) + 1)
 
-    return '__I_PLACEHOLDER_8675309_GROUP_%s_%s__' % (
+    return '__I_PLACEHOLDER_8675309_GROUP_%s_%s_%s__' % (
         node._group,
+        node._id,
         visitor.setMap[node._set],
     )
 
 
 def handle_numericGetItemExpression_node(visitor, node, *args):
     joinedName = args[0]
 
@@ -311,16 +335,17 @@
             pstr += '}'
     return pstr
 
 
 def handle_templateSumExpression_node(visitor, node, *args):
     pstr = ''
     for i in range(0, len(node._iters)):
-        pstr += '\\sum_{__S_PLACEHOLDER_8675309_GROUP_%s_%s__} ' % (
+        pstr += '\\sum_{__S_PLACEHOLDER_8675309_GROUP_%s_%s_%s__} ' % (
             node._iters[i][0]._group,
+            ','.join(str(it._id) for it in node._iters[i]),
             visitor.setMap[node._iters[i][0]._set],
         )
 
     pstr += args[0]
 
     return pstr
 
@@ -370,33 +395,33 @@
             PowExpression: handle_pow_node,
             AbsExpression: handle_abs_node,
             UnaryFunctionExpression: handle_unary_node,
             Expr_ifExpression: handle_exprif_node,
             EqualityExpression: handle_equality_node,
             InequalityExpression: handle_inequality_node,
             RangedExpression: handle_ranged_inequality_node,
-            _GeneralExpressionData: handle_named_expression_node,
+            ExpressionData: handle_named_expression_node,
             ScalarExpression: handle_named_expression_node,
             kernel.expression.expression: handle_named_expression_node,
             kernel.expression.noclone: handle_named_expression_node,
-            _GeneralObjectiveData: handle_named_expression_node,
-            _GeneralVarData: handle_var_node,
+            ObjectiveData: handle_named_expression_node,
+            VarData: handle_var_node,
             ScalarObjective: handle_named_expression_node,
             kernel.objective.objective: handle_named_expression_node,
             ExternalFunctionExpression: handle_external_function_node,
             _PythonCallbackFunctionID: handle_functionID_node,
             LinearExpression: handle_sumExpression_node,
             SumExpression: handle_sumExpression_node,
             MonomialTermExpression: handle_monomialTermExpression_node,
             IndexedVar: handle_var_node,
             IndexTemplate: handle_indexTemplate_node,
             Numeric_GetItemExpression: handle_numericGetItemExpression_node,
             TemplateSumExpression: handle_templateSumExpression_node,
             ScalarParam: handle_param_node,
-            _ParamData: handle_param_node,
+            ParamData: handle_param_node,
             IndexedParam: handle_param_node,
             NPV_Numeric_GetItemExpression: handle_numericGetItemExpression_node,
             IndexedBlock: handle_indexedBlock_node,
             NPV_Structural_GetItemExpression: handle_npv_structuralGetItemExpression_node,
             str: handle_str_node,
             Numeric_GetAttrExpression: handle_numericGetAttrExpression_node,
             NPV_SumExpression: handle_sumExpression_node,
@@ -412,36 +437,14 @@
             raise DeveloperError(
                 'Latex printer encountered an error when processing type %s, contact the developers'
                 % (node.__class__)
             )
 
 
 def analyze_variable(vr):
-    domainMap = {
-        'Reals': '\\mathds{R}',
-        'PositiveReals': '\\mathds{R}_{> 0}',
-        'NonPositiveReals': '\\mathds{R}_{\\leq 0}',
-        'NegativeReals': '\\mathds{R}_{< 0}',
-        'NonNegativeReals': '\\mathds{R}_{\\geq 0}',
-        'Integers': '\\mathds{Z}',
-        'PositiveIntegers': '\\mathds{Z}_{> 0}',
-        'NonPositiveIntegers': '\\mathds{Z}_{\\leq 0}',
-        'NegativeIntegers': '\\mathds{Z}_{< 0}',
-        'NonNegativeIntegers': '\\mathds{Z}_{\\geq 0}',
-        'Boolean': '\\left\\{ \\text{True} , \\text{False} \\right \\}',
-        'Binary': '\\left\\{ 0 , 1 \\right \\}',
-        # 'Any': None,
-        # 'AnyWithNone': None,
-        'EmptySet': '\\varnothing',
-        'UnitInterval': '\\mathds{R}',
-        'PercentFraction': '\\mathds{R}',
-        # 'RealInterval' :        None    ,
-        # 'IntegerInterval' :     None    ,
-    }
-
     domainName = vr.domain.name
     varBounds = vr.bounds
     lowerBoundValue = varBounds[0]
     upperBoundValue = varBounds[1]
 
     if domainName in ['Reals', 'Integers']:
         if lowerBoundValue is not None:
@@ -580,15 +583,15 @@
 ):
     """This function produces a string that can be rendered as LaTeX
 
     Prints a Pyomo component (Block, Model, Objective, Constraint, or Expression) to a LaTeX compatible string
 
     Parameters
     ----------
-    pyomo_component: _BlockData or Model or Objective or Constraint or Expression
+    pyomo_component: BlockData or Model or Objective or Constraint or Expression
         The Pyomo component to be printed
 
     latex_component_map: pyomo.common.collections.component_map.ComponentMap
         A map keyed by Pyomo component, values become the LaTeX representation in
         the printer
 
     ostream: io.TextIOWrapper or io.StringIO or str
@@ -623,23 +626,23 @@
     # these objects require a slight modification of behavior
     # isSingle==False means a model or block
 
     use_short_descriptors = True
 
     # Cody's backdoor because he got outvoted
     if latex_component_map is not None:
-        if 'use_short_descriptors' in list(latex_component_map.keys()):
+        if 'use_short_descriptors' in latex_component_map:
             if latex_component_map['use_short_descriptors'] == False:
                 use_short_descriptors = False
 
     if latex_component_map is None:
         latex_component_map = ComponentMap()
-        existing_components = ComponentSet([])
+        existing_components = ComponentSet()
     else:
-        existing_components = ComponentSet(list(latex_component_map.keys()))
+        existing_components = ComponentSet(latex_component_map)
 
     isSingle = False
 
     if isinstance(pyomo_component, pyo.Objective):
         objectives = [pyomo_component]
         constraints = []
         expressions = []
@@ -667,15 +670,15 @@
         objectives = []
         constraints = []
         expressions = [pyomo_component]
         templatize_fcn = templatize_passthrough
         use_equation_environment = True
         isSingle = True
 
-    elif isinstance(pyomo_component, _BlockData):
+    elif isinstance(pyomo_component, BlockData):
         objectives = [
             obj
             for obj in pyomo_component.component_data_objects(
                 pyo.Objective,
                 descend_into=True,
                 active=True,
                 sort=SortComponents.deterministic,
@@ -698,30 +701,26 @@
             "Invalid type %s passed into the latex printer"
             % (str(type(pyomo_component)))
         )
 
     if isSingle:
         temp_comp, temp_indexes = templatize_fcn(pyomo_component)
         variableList = []
-        for v in identify_components(
-            temp_comp, [ScalarVar, _GeneralVarData, IndexedVar]
-        ):
-            if isinstance(v, _GeneralVarData):
+        for v in identify_components(temp_comp, [ScalarVar, VarData, IndexedVar]):
+            if isinstance(v, VarData):
                 v_write = v.parent_component()
                 if v_write not in ComponentSet(variableList):
                     variableList.append(v_write)
             else:
                 if v not in ComponentSet(variableList):
                     variableList.append(v)
 
         parameterList = []
-        for p in identify_components(
-            temp_comp, [ScalarParam, _ParamData, IndexedParam]
-        ):
-            if isinstance(p, _ParamData):
+        for p in identify_components(temp_comp, [ScalarParam, ParamData, IndexedParam]):
+            if isinstance(p, ParamData):
                 p_write = p.parent_component()
                 if p_write not in ComponentSet(parameterList):
                     parameterList.append(p_write)
             else:
                 if p not in ComponentSet(parameterList):
                     parameterList.append(p)
 
@@ -778,37 +777,37 @@
     visitor = _LatexVisitor()
 
     variableMap = ComponentMap()
     vrIdx = 0
     for vr in variableList:
         vrIdx += 1
         if isinstance(vr, ScalarVar):
-            variableMap[vr] = 'x_' + str(vrIdx)
+            variableMap[vr] = 'x_' + str(vrIdx) + '_'
         elif isinstance(vr, IndexedVar):
-            variableMap[vr] = 'x_' + str(vrIdx)
+            variableMap[vr] = 'x_' + str(vrIdx) + '_'
             for sd in vr.index_set().data():
                 vrIdx += 1
-                variableMap[vr[sd]] = 'x_' + str(vrIdx)
+                variableMap[vr[sd]] = 'x_' + str(vrIdx) + '_'
         else:
             raise DeveloperError(
                 'Variable is not a variable.  Should not happen.  Contact developers'
             )
     visitor.variableMap = variableMap
 
     parameterMap = ComponentMap()
     pmIdx = 0
     for vr in parameterList:
         pmIdx += 1
         if isinstance(vr, ScalarParam):
-            parameterMap[vr] = 'p_' + str(pmIdx)
+            parameterMap[vr] = 'p_' + str(pmIdx) + '_'
         elif isinstance(vr, IndexedParam):
-            parameterMap[vr] = 'p_' + str(pmIdx)
+            parameterMap[vr] = 'p_' + str(pmIdx) + '_'
             for sd in vr.index_set().data():
                 pmIdx += 1
-                parameterMap[vr[sd]] = 'p_' + str(pmIdx)
+                parameterMap[vr[sd]] = 'p_' + str(pmIdx) + '_'
         else:
             raise DeveloperError(
                 'Parameter is not a parameter.  Should not happen.  Contact developers'
             )
     visitor.parameterMap = parameterMap
 
     setMap = ComponentMap()
@@ -911,32 +910,41 @@
                     + ' %s %s'
                     % (visitor.walk_expression(con_template), trailingAligner)
                 )
 
                 # setMap = visitor.setMap
                 # Multiple constraints are generated using a set
                 if len(indices) > 0:
-                    if indices[0]._set in ComponentSet(visitor.setMap.keys()):
-                        # already detected set, do nothing
-                        pass
-                    else:
-                        visitor.setMap[indices[0]._set] = 'SET%d' % (
-                            len(visitor.setMap.keys()) + 1
+                    conLine += ' \\qquad \\forall'
+
+                    _bygroups = {}
+                    for idx in indices:
+                        _bygroups.setdefault(idx._group, []).append(idx)
+                    for _group, idxs in _bygroups.items():
+                        if idxs[0]._set in visitor.setMap:
+                            # already detected set, do nothing
+                            pass
+                        else:
+                            visitor.setMap[idxs[0]._set] = 'SET%d' % (
+                                len(visitor.setMap) + 1
+                            )
+
+                        idxTag = ','.join(
+                            '__I_PLACEHOLDER_8675309_GROUP_%s_%s_%s__'
+                            % (idx._group, idx._id, visitor.setMap[idx._set])
+                            for idx in idxs
                         )
 
-                    idxTag = '__I_PLACEHOLDER_8675309_GROUP_%s_%s__' % (
-                        indices[0]._group,
-                        visitor.setMap[indices[0]._set],
-                    )
-                    setTag = '__S_PLACEHOLDER_8675309_GROUP_%s_%s__' % (
-                        indices[0]._group,
-                        visitor.setMap[indices[0]._set],
-                    )
+                        setTag = '__S_PLACEHOLDER_8675309_GROUP_%s_%s_%s__' % (
+                            indices[0]._group,
+                            ','.join(str(it._id) for it in idxs),
+                            visitor.setMap[indices[0]._set],
+                        )
 
-                    conLine += ' \\qquad \\forall %s \\in %s ' % (idxTag, setTag)
+                        conLine += ' %s \\in %s ' % (idxTag, setTag)
                 pstr += conLine
 
                 # Add labels as needed
                 if not use_equation_environment:
                     pstr += (
                         '\\label{con:' + pyomo_component.name + '_' + con.name + '} '
                     )
@@ -1055,38 +1063,45 @@
             pstr += '    \\end{aligned} \n'
             pstr += '    \\label{%s} \n' % (pyomo_component.name)
         pstr += '\\end{equation} \n'
 
     setMap = visitor.setMap
     setMap_inverse = {vl: ky for ky, vl in setMap.items()}
 
+    def generate_set_name(st, lcm):
+        if st in lcm:
+            return lcm[st][0]
+        if st.parent_block().component(st.name) is st:
+            return st.name.replace('_', r'\_')
+        if isinstance(st, SetOperator):
+            return set_operator_map[st._operator.strip()].join(
+                generate_set_name(s, lcm) for s in st.subsets(False)
+            )
+        else:
+            return str(st).replace('_', r'\_').replace('{', r'\{').replace('}', r'\}')
+
     # Handling the iterator indices
     defaultSetLatexNames = ComponentMap()
-    for ky, vl in setMap.items():
-        st = ky
-        defaultSetLatexNames[st] = st.name.replace('_', '\\_')
-        if st in ComponentSet(latex_component_map.keys()):
-            defaultSetLatexNames[st] = latex_component_map[st][
-                0
-            ]  # .replace('_', '\\_')
+    for ky in setMap:
+        defaultSetLatexNames[ky] = generate_set_name(ky, latex_component_map)
 
     latexLines = pstr.split('\n')
     for jj in range(0, len(latexLines)):
         groupMap = {}
         uniqueSets = []
         ln = latexLines[jj]
         # only modify if there is a placeholder in the line
         if "PLACEHOLDER_8675309_GROUP_" in ln:
             splitLatex = ln.split('__')
             # Find the unique combinations of group numbers and set names
             for word in splitLatex:
                 if "PLACEHOLDER_8675309_GROUP_" in word:
                     ifo = word.split("PLACEHOLDER_8675309_GROUP_")[1]
-                    gpNum, stName = ifo.split('_')
-                    if gpNum not in groupMap.keys():
+                    gpNum, idNum, stName = ifo.split('_')
+                    if gpNum not in groupMap:
                         groupMap[gpNum] = [stName]
                     if stName not in ComponentSet(uniqueSets):
                         uniqueSets.append(stName)
 
             # Determine if the set is continuous
             setInfo = dict(
                 zip(
@@ -1095,18 +1110,15 @@
                 )
             )
 
             for ky, vl in setInfo.items():
                 ix = int(ky[3:]) - 1
                 setInfo[ky]['setObject'] = setMap_inverse[ky]  # setList[ix]
                 setInfo[ky]['setRegEx'] = (
-                    r'__S_PLACEHOLDER_8675309_GROUP_([0-9*])_%s__' % (ky)
-                )
-                setInfo[ky]['sumSetRegEx'] = (
-                    r'sum_{__S_PLACEHOLDER_8675309_GROUP_([0-9*])_%s__}' % (ky)
+                    r'__S_PLACEHOLDER_8675309_GROUP_([0-9]+)_([0-9,]+)_%s__' % (ky,)
                 )
                 # setInfo[ky]['idxRegEx'] = r'__I_PLACEHOLDER_8675309_GROUP_[0-9*]_%s__'%(ky)
 
             if explicit_set_summation:
                 for ky, vl in setInfo.items():
                     st = vl['setObject']
                     stData = st.data()
@@ -1123,81 +1135,96 @@
                 if explicit_set_summation and setInfo[ky]['continuous']:
                     st = setInfo[ky]['setObject']
                     stData = st.data()
                     bgn = stData[0]
                     ed = stData[-1]
 
                     replacement = (
-                        r'sum_{ __I_PLACEHOLDER_8675309_GROUP_\1_%s__ = %d }^{%d}'
+                        r'sum_{ __I_PLACEHOLDER_8675309_GROUP_\1_\2_%s__ = %d }^{%d}'
                         % (ky, bgn, ed)
                     )
-                    ln = re.sub(setInfo[ky]['sumSetRegEx'], replacement, ln)
+                    ln = re.sub(
+                        'sum_{' + setInfo[ky]['setRegEx'] + '}', replacement, ln
+                    )
                 else:
                     # if the set is not continuous or the flag has not been set
-                    replacement = (
-                        r'sum_{ __I_PLACEHOLDER_8675309_GROUP_\1_%s__ \\in __S_PLACEHOLDER_8675309_GROUP_\1_%s__  }'
-                        % (ky, ky)
-                    )
-                    ln = re.sub(setInfo[ky]['sumSetRegEx'], replacement, ln)
+                    for _grp, _id in re.findall(
+                        'sum_{' + setInfo[ky]['setRegEx'] + '}', ln
+                    ):
+                        set_placeholder = '__S_PLACEHOLDER_8675309_GROUP_%s_%s_%s__' % (
+                            _grp,
+                            _id,
+                            ky,
+                        )
+                        i_placeholder = ','.join(
+                            '__I_PLACEHOLDER_8675309_GROUP_%s_%s_%s__' % (_grp, _, ky)
+                            for _ in _id.split(',')
+                        )
+                        replacement = r'sum_{ %s \in %s  }' % (
+                            i_placeholder,
+                            set_placeholder,
+                        )
+                        ln = ln.replace('sum_{' + set_placeholder + '}', replacement)
 
                 replacement = repr(defaultSetLatexNames[setInfo[ky]['setObject']])[1:-1]
                 ln = re.sub(setInfo[ky]['setRegEx'], replacement, ln)
 
             # groupNumbers = re.findall(r'__I_PLACEHOLDER_8675309_GROUP_([0-9*])_SET[0-9]*__',ln)
             setNumbers = re.findall(
-                r'__I_PLACEHOLDER_8675309_GROUP_[0-9*]_SET([0-9]*)__', ln
+                r'__I_PLACEHOLDER_8675309_GROUP_[0-9]+_[0-9]+_SET([0-9]+)__', ln
             )
-            groupSetPairs = re.findall(
-                r'__I_PLACEHOLDER_8675309_GROUP_([0-9*])_SET([0-9]*)__', ln
+            groupIdSetTuples = re.findall(
+                r'__I_PLACEHOLDER_8675309_GROUP_([0-9]+)_([0-9]+)_SET([0-9]+)__', ln
             )
 
             groupInfo = {}
             for vl in setNumbers:
                 groupInfo['SET' + vl] = {
                     'setObject': setInfo['SET' + vl]['setObject'],
                     'indices': [],
                 }
 
-            for gp in groupSetPairs:
-                if gp[0] not in groupInfo['SET' + gp[1]]['indices']:
-                    groupInfo['SET' + gp[1]]['indices'].append(gp[0])
+            for _gp, _id, _set in groupIdSetTuples:
+                if (_gp, _id) not in groupInfo['SET' + _set]['indices']:
+                    groupInfo['SET' + _set]['indices'].append((_gp, _id))
+
+            def get_index_names(st, lcm):
+                if st in lcm:
+                    return lcm[st][1]
+                elif isinstance(st, SetOperator):
+                    return sum(
+                        (get_index_names(s, lcm) for s in st.subsets(False)), start=[]
+                    )
+                elif st.dimen is not None:
+                    return [None] * st.dimen
+                else:
+                    return [Ellipsis]
 
             indexCounter = 0
             for ky, vl in groupInfo.items():
-                if vl['setObject'] in ComponentSet(latex_component_map.keys()):
-                    indexNames = latex_component_map[vl['setObject']][1]
-                    if len(indexNames) != 0:
-                        if len(indexNames) < len(vl['indices']):
-                            raise ValueError(
-                                'Insufficient number of indices provided to the overwrite dictionary for set %s'
-                                % (vl['setObject'].name)
-                            )
-                        for i in range(0, len(vl['indices'])):
-                            ln = ln.replace(
-                                '__I_PLACEHOLDER_8675309_GROUP_%s_%s__'
-                                % (vl['indices'][i], ky),
-                                indexNames[i],
-                            )
-                    else:
-                        for i in range(0, len(vl['indices'])):
-                            ln = ln.replace(
-                                '__I_PLACEHOLDER_8675309_GROUP_%s_%s__'
-                                % (vl['indices'][i], ky),
-                                alphabetStringGenerator(indexCounter),
-                            )
-                            indexCounter += 1
-                else:
-                    for i in range(0, len(vl['indices'])):
-                        ln = ln.replace(
-                            '__I_PLACEHOLDER_8675309_GROUP_%s_%s__'
-                            % (vl['indices'][i], ky),
-                            alphabetStringGenerator(indexCounter),
+                indexNames = get_index_names(vl['setObject'], latex_component_map)
+                nonNone = list(filter(None, indexNames))
+                if nonNone:
+                    if len(nonNone) < len(vl['indices']):
+                        raise ValueError(
+                            'Insufficient number of indices provided to the '
+                            'overwrite dictionary for set %s (expected %s, but got %s)'
+                            % (vl['setObject'].name, len(vl['indices']), indexNames)
                         )
+                else:
+                    indexNames = []
+                    for i in vl['indices']:
+                        indexNames.append(alphabetStringGenerator(indexCounter))
                         indexCounter += 1
-
+                for i in range(0, len(vl['indices'])):
+                    ln = ln.replace(
+                        '__I_PLACEHOLDER_8675309_GROUP_%s_%s_%s__'
+                        % (*vl['indices'][i], ky),
+                        indexNames[i],
+                    )
         latexLines[jj] = ln
 
     pstr = '\n'.join(latexLines)
 
     new_variableMap = ComponentMap()
     for i, vr in enumerate(variableList):
         if isinstance(vr, ScalarVar):
@@ -1232,33 +1259,33 @@
                 new_parameterMap[pm[sd]] = str(pm[sd])  # .name
         else:
             raise DeveloperError(
                 'Parameter is not a parameter.  Should not happen.  Contact developers'
             )
 
     for ky, vl in new_variableMap.items():
-        if ky not in ComponentSet(latex_component_map.keys()):
+        if ky not in latex_component_map:
             latex_component_map[ky] = vl
     for ky, vl in new_parameterMap.items():
-        if ky not in ComponentSet(latex_component_map.keys()):
+        if ky not in latex_component_map:
             latex_component_map[ky] = vl
 
     rep_dict = {}
-    for ky in ComponentSet(list(reversed(list(latex_component_map.keys())))):
-        if isinstance(ky, (pyo.Var, _GeneralVarData)):
+    for ky in reversed(list(latex_component_map)):
+        if isinstance(ky, (pyo.Var, VarData)):
             overwrite_value = latex_component_map[ky]
             if ky not in existing_components:
                 overwrite_value = overwrite_value.replace('_', '\\_')
             rep_dict[variableMap[ky]] = overwrite_value
-        elif isinstance(ky, (pyo.Param, _ParamData)):
+        elif isinstance(ky, (pyo.Param, ParamData)):
             overwrite_value = latex_component_map[ky]
             if ky not in existing_components:
                 overwrite_value = overwrite_value.replace('_', '\\_')
             rep_dict[parameterMap[ky]] = overwrite_value
-        elif isinstance(ky, _SetData):
+        elif isinstance(ky, SetData):
             # already handled
             pass
         elif isinstance(ky, (float, int)):
             # happens when immutable parameters are used, do nothing
             pass
         else:
             raise ValueError(
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/test_latex_printer.py` & `Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/test_latex_printer.py`

 * *Files 9% similar despite different names*

```diff
@@ -5,33 +5,24 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-#  ___________________________________________________________________________
-#
-#  Pyomo: Python Optimization Modeling Objects
-#  Copyright (c) 2008-2023
-#  National Technology and Engineering Solutions of Sandia, LLC
-#  Under the terms of Contract DE-NA0003525 with National Technology and
-#  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
-#  rights in this software.
-#  This software is distributed under the 3-clause BSD License.
-#  ___________________________________________________________________________
-
 import io
+from textwrap import dedent
+
 import pyomo.common.unittest as unittest
-from pyomo.contrib.latex_printer import latex_printer
+import pyomo.core.tests.examples.pmedian_concrete as pmedian_concrete
 import pyomo.environ as pyo
-from textwrap import dedent
+
+from pyomo.contrib.latex_printer import latex_printer
 from pyomo.common.tempfiles import TempfileManager
 from pyomo.common.collections.component_map import ComponentMap
-
 from pyomo.environ import (
     Reals,
     PositiveReals,
     NonPositiveReals,
     NegativeReals,
     NonNegativeReals,
     Integers,
@@ -793,10 +784,54 @@
             & & -10 \leq x \leq 10 & \qquad \in \mathds{R} \label{con:basicFormulation_x_bound} 
         \end{align} 
         """
         )
 
         self.assertEqual('\n' + pstr + '\n', bstr)
 
+    def test_latexPrinter_pmedian_verbose(self):
+        m = pmedian_concrete.create_model()
+        self.assertEqual(
+            latex_printer(m).strip(),
+            r"""
+\begin{align} 
+    & \min 
+    & & \sum_{ i \in Locations  } \sum_{ j \in Customers  } cost_{i,j} serve\_customer\_from\_location_{i,j} & \label{obj:M1_obj} \\ 
+    & \text{s.t.} 
+    & & \sum_{ i \in Locations  } serve\_customer\_from\_location_{i,j} = 1 &  \qquad \forall j \in Customers \label{con:M1_single_x} \\ 
+    &&& serve\_customer\_from\_location_{i,j} \leq select\_location_{i} &  \qquad \forall i,j \in Locations \times Customers \label{con:M1_bound_y} \\ 
+    &&& \sum_{ i \in Locations  } select\_location_{i} = P & \label{con:M1_num_facilities} \\ 
+    & \text{w.b.} 
+    & & 0.0 \leq serve\_customer\_from\_location \leq 1.0 & \qquad \in \mathds{R} \label{con:M1_serve_customer_from_location_bound} \\ 
+    &&& select\_location & \qquad \in \left\{ 0 , 1 \right \} \label{con:M1_select_location_bound} 
+\end{align}
+            """.strip(),
+        )
+
+    def test_latexPrinter_pmedian_concise(self):
+        m = pmedian_concrete.create_model()
+        lcm = ComponentMap()
+        lcm[m.Locations] = ['L', ['n']]
+        lcm[m.Customers] = ['C', ['m']]
+        lcm[m.cost] = 'd'
+        lcm[m.serve_customer_from_location] = 'x'
+        lcm[m.select_location] = 'y'
+        self.assertEqual(
+            latex_printer(m, latex_component_map=lcm).strip(),
+            r"""
+\begin{align} 
+    & \min 
+    & & \sum_{ n \in L  } \sum_{ m \in C  } d_{n,m} x_{n,m} & \label{obj:M1_obj} \\ 
+    & \text{s.t.} 
+    & & \sum_{ n \in L  } x_{n,m} = 1 &  \qquad \forall m \in C \label{con:M1_single_x} \\ 
+    &&& x_{n,m} \leq y_{n} &  \qquad \forall n,m \in L \times C \label{con:M1_bound_y} \\ 
+    &&& \sum_{ n \in L  } y_{n} = P & \label{con:M1_num_facilities} \\ 
+    & \text{w.b.} 
+    & & 0.0 \leq x \leq 1.0 & \qquad \in \mathds{R} \label{con:M1_x_bound} \\ 
+    &&& y & \qquad \in \left\{ 0 , 1 \right \} \label{con:M1_y_bound} 
+\end{align}
+            """.strip(),
+        )
+
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/latex_printer/tests/test_latex_printer_vartypes.py` & `Pyomo-6.7.2/pyomo/contrib/latex_printer/tests/test_latex_printer_vartypes.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/build.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/build.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/getMCPP.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/getMCPP.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/mcppInterface.cpp` & `Pyomo-6.7.2/pyomo/contrib/mcpp/mcppInterface.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/pyomo_mcpp.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/pyomo_mcpp.py`

 * *Files 1% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 import ctypes
 import logging
 import os
 
 from pyomo.common.fileutils import Library
 from pyomo.core import value, Expression
 from pyomo.core.base.block import SubclassOf
-from pyomo.core.base.expression import _ExpressionData
+from pyomo.core.base.expression import NamedExpressionData
 from pyomo.core.expr.numvalue import nonpyomo_leaf_types
 from pyomo.core.expr.numeric_expr import (
     AbsExpression,
     LinearExpression,
     NegationExpression,
     NPV_AbsExpression,
     NPV_ExternalFunctionExpression,
@@ -303,15 +303,17 @@
                 raise NotImplementedError("Unknown unary function: %s" % (node.name,))
         elif isinstance(node, NPV_expressions):
             ans = self.mcpp.newConstant(value(data[0]))
         elif type(node) in nonpyomo_leaf_types:
             ans = self.mcpp.newConstant(node)
         elif not node.is_expression_type():
             ans = self.register_num(node)
-        elif type(node) in SubclassOf(Expression) or isinstance(node, _ExpressionData):
+        elif type(node) in SubclassOf(Expression) or isinstance(
+            node, NamedExpressionData
+        ):
             ans = data[0]
         else:
             raise RuntimeError("Unhandled expression type: %s" % (type(node)))
 
         if ans is None:
             msg = self.mcpp.get_last_exception_message()
             msg = msg.decode("utf-8")
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mcpp/test_mcpp.py` & `Pyomo-6.7.2/pyomo/contrib/mcpp/test_mcpp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/MindtPy.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/MindtPy.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/algorithm_base_class.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/algorithm_base_class.py`

 * *Files 1% similar despite different names*

```diff
@@ -81,8641 +81,8730 @@
 00000500: 2e63 6f6d 6d6f 6e2e 6572 726f 7273 2069  .common.errors i
 00000510: 6d70 6f72 7420 4465 7665 6c6f 7065 7245  mport DeveloperE
 00000520: 7272 6f72 0a66 726f 6d20 7079 6f6d 6f2e  rror.from pyomo.
 00000530: 736f 6c76 6572 732e 706c 7567 696e 732e  solvers.plugins.
 00000540: 736f 6c76 6572 732e 6775 726f 6269 5f64  solvers.gurobi_d
 00000550: 6972 6563 7420 696d 706f 7274 2067 7572  irect import gur
 00000560: 6f62 6970 790a 6672 6f6d 2070 796f 6d6f  obipy.from pyomo
-00000570: 2e6f 7074 2069 6d70 6f72 7420 280a 2020  .opt import (.  
-00000580: 2020 536f 6c76 6572 4661 6374 6f72 792c    SolverFactory,
-00000590: 0a20 2020 2053 6f6c 7665 7252 6573 756c  .    SolverResul
-000005a0: 7473 2c0a 2020 2020 5072 6f62 6c65 6d53  ts,.    ProblemS
-000005b0: 656e 7365 2c0a 2020 2020 536f 6c75 7469  ense,.    Soluti
-000005c0: 6f6e 5374 6174 7573 2c0a 2020 2020 536f  onStatus,.    So
-000005d0: 6c76 6572 5374 6174 7573 2c0a 290a 6672  lverStatus,.).fr
-000005e0: 6f6d 2070 796f 6d6f 2e63 6f72 6520 696d  om pyomo.core im
-000005f0: 706f 7274 2028 0a20 2020 206d 696e 696d  port (.    minim
-00000600: 697a 652c 0a20 2020 206d 6178 696d 697a  ize,.    maximiz
-00000610: 652c 0a20 2020 204f 626a 6563 7469 7665  e,.    Objective
-00000620: 2c0a 2020 2020 5661 724c 6973 742c 0a20  ,.    VarList,. 
-00000630: 2020 2052 6561 6c73 2c0a 2020 2020 436f     Reals,.    Co
-00000640: 6e73 7472 6169 6e74 4c69 7374 2c0a 2020  nstraintList,.  
-00000650: 2020 436f 6e73 7472 6169 6e74 2c0a 2020    Constraint,.  
-00000660: 2020 426c 6f63 6b2c 0a20 2020 2054 7261    Block,.    Tra
-00000670: 6e73 666f 726d 6174 696f 6e46 6163 746f  nsformationFacto
-00000680: 7279 2c0a 2020 2020 4e6f 6e4e 6567 6174  ry,.    NonNegat
-00000690: 6976 6552 6561 6c73 2c0a 2020 2020 5375  iveReals,.    Su
-000006a0: 6666 6978 2c0a 2020 2020 5661 722c 0a20  ffix,.    Var,. 
-000006b0: 2020 2052 616e 6765 5365 742c 0a20 2020     RangeSet,.   
-000006c0: 2076 616c 7565 2c0a 2020 2020 4578 7072   value,.    Expr
-000006d0: 6573 7369 6f6e 2c0a 290a 6672 6f6d 2070  ession,.).from p
-000006e0: 796f 6d6f 2e63 6f6e 7472 6962 2e67 6470  yomo.contrib.gdp
-000006f0: 6f70 742e 7574 696c 2069 6d70 6f72 7420  opt.util import 
-00000700: 280a 2020 2020 5375 7070 7265 7373 496e  (.    SuppressIn
-00000710: 6665 6173 6962 6c65 5761 726e 696e 672c  feasibleWarning,
-00000720: 0a20 2020 205f 446f 4e6f 7468 696e 672c  .    _DoNothing,
-00000730: 0a20 2020 206c 6f77 6572 5f6c 6f67 6765  .    lower_logge
-00000740: 725f 6c65 7665 6c5f 746f 2c0a 2020 2020  r_level_to,.    
-00000750: 6765 745f 6d61 696e 5f65 6c61 7073 6564  get_main_elapsed
-00000760: 5f74 696d 652c 0a20 2020 2074 696d 655f  _time,.    time_
-00000770: 636f 6465 2c0a 290a 6672 6f6d 2070 796f  code,.).from pyo
-00000780: 6d6f 2e63 6f6e 7472 6962 2e67 6470 6f70  mo.contrib.gdpop
-00000790: 742e 736f 6c76 655f 6469 7363 7265 7465  t.solve_discrete
-000007a0: 5f70 726f 626c 656d 2069 6d70 6f72 7420  _problem import 
-000007b0: 280a 2020 2020 6469 7374 696e 6775 6973  (.    distinguis
-000007c0: 685f 6d69 705f 696e 6665 6173 6962 6c65  h_mip_infeasible
-000007d0: 5f6f 725f 756e 626f 756e 6465 642c 0a29  _or_unbounded,.)
-000007e0: 0a66 726f 6d20 7079 6f6d 6f2e 636f 6e74  .from pyomo.cont
-000007f0: 7269 622e 6d69 6e64 7470 792e 7574 696c  rib.mindtpy.util
-00000800: 2069 6d70 6f72 7420 280a 2020 2020 6765   import (.    ge
-00000810: 6e65 7261 7465 5f6e 6f72 6d31 5f6f 626a  nerate_norm1_obj
-00000820: 6563 7469 7665 5f66 756e 6374 696f 6e2c  ective_function,
-00000830: 0a20 2020 2067 656e 6572 6174 655f 6e6f  .    generate_no
-00000840: 726d 3273 715f 6f62 6a65 6374 6976 655f  rm2sq_objective_
-00000850: 6675 6e63 7469 6f6e 2c0a 2020 2020 6765  function,.    ge
-00000860: 6e65 7261 7465 5f6e 6f72 6d5f 696e 665f  nerate_norm_inf_
-00000870: 6f62 6a65 6374 6976 655f 6675 6e63 7469  objective_functi
-00000880: 6f6e 2c0a 2020 2020 6765 6e65 7261 7465  on,.    generate
-00000890: 5f6c 6167 5f6f 626a 6563 7469 7665 5f66  _lag_objective_f
-000008a0: 756e 6374 696f 6e2c 0a20 2020 2047 7572  unction,.    Gur
-000008b0: 6f62 6950 6572 7369 7374 656e 7434 4d69  obiPersistent4Mi
-000008c0: 6e64 7450 792c 0a20 2020 2073 6574 7570  ndtPy,.    setup
-000008d0: 5f72 6573 756c 7473 5f6f 626a 6563 742c  _results_object,
-000008e0: 0a20 2020 2067 6574 5f69 6e74 6567 6572  .    get_integer
-000008f0: 5f73 6f6c 7574 696f 6e2c 0a20 2020 2069  _solution,.    i
-00000900: 6e69 7469 616c 697a 655f 6665 6173 5f73  nitialize_feas_s
-00000910: 7562 7072 6f62 6c65 6d2c 0a20 2020 2065  ubproblem,.    e
-00000920: 7069 6772 6170 685f 7265 666f 726d 756c  pigraph_reformul
-00000930: 6174 696f 6e2c 0a20 2020 2061 6464 5f76  ation,.    add_v
-00000940: 6172 5f62 6f75 6e64 2c0a 2020 2020 636f  ar_bound,.    co
-00000950: 7079 5f76 6172 5f6c 6973 745f 7661 6c75  py_var_list_valu
-00000960: 6573 5f66 726f 6d5f 736f 6c75 7469 6f6e  es_from_solution
-00000970: 5f70 6f6f 6c2c 0a20 2020 2067 656e 6572  _pool,.    gener
-00000980: 6174 655f 6e6f 726d 5f63 6f6e 7374 7261  ate_norm_constra
-00000990: 696e 742c 0a20 2020 2066 705f 636f 6e76  int,.    fp_conv
-000009a0: 6572 6765 642c 0a20 2020 2061 6464 5f6f  erged,.    add_o
-000009b0: 7274 686f 676f 6e61 6c69 7479 5f63 7574  rthogonality_cut
-000009c0: 732c 0a20 2020 2073 6574 5f73 6f6c 7665  s,.    set_solve
-000009d0: 725f 6d69 7067 6170 2c0a 2020 2020 7365  r_mipgap,.    se
-000009e0: 745f 736f 6c76 6572 5f63 6f6e 7374 7261  t_solver_constra
-000009f0: 696e 745f 7669 6f6c 6174 696f 6e5f 746f  int_violation_to
-00000a00: 6c65 7261 6e63 652c 0a20 2020 2075 7064  lerance,.    upd
-00000a10: 6174 655f 736f 6c76 6572 5f74 696d 656c  ate_solver_timel
-00000a20: 696d 6974 2c0a 2020 2020 636f 7079 5f76  imit,.    copy_v
-00000a30: 6172 5f6c 6973 745f 7661 6c75 6573 2c0a  ar_list_values,.
-00000a40: 290a 0a73 696e 676c 655f 7472 6565 2c20  )..single_tree, 
-00000a50: 7369 6e67 6c65 5f74 7265 655f 6176 6169  single_tree_avai
-00000a60: 6c61 626c 6520 3d20 6174 7465 6d70 745f  lable = attempt_
-00000a70: 696d 706f 7274 2827 7079 6f6d 6f2e 636f  import('pyomo.co
-00000a80: 6e74 7269 622e 6d69 6e64 7470 792e 7369  ntrib.mindtpy.si
-00000a90: 6e67 6c65 5f74 7265 6527 290a 7461 6275  ngle_tree').tabu
-00000aa0: 5f6c 6973 742c 2074 6162 755f 6c69 7374  _list, tabu_list
-00000ab0: 5f61 7661 696c 6162 6c65 203d 2061 7474  _available = att
-00000ac0: 656d 7074 5f69 6d70 6f72 7428 2770 796f  empt_import('pyo
-00000ad0: 6d6f 2e63 6f6e 7472 6962 2e6d 696e 6474  mo.contrib.mindt
-00000ae0: 7079 2e74 6162 755f 6c69 7374 2729 0a65  py.tabu_list').e
-00000af0: 6762 2c20 6567 625f 6176 6169 6c61 626c  gb, egb_availabl
-00000b00: 6520 3d20 6174 7465 6d70 745f 696d 706f  e = attempt_impo
-00000b10: 7274 280a 2020 2020 2770 796f 6d6f 2e63  rt(.    'pyomo.c
-00000b20: 6f6e 7472 6962 2e70 796e 756d 6572 6f2e  ontrib.pynumero.
-00000b30: 696e 7465 7266 6163 6573 2e65 7874 6572  interfaces.exter
-00000b40: 6e61 6c5f 6772 6579 5f62 6f78 270a 290a  nal_grey_box'.).
-00000b50: 0a0a 636c 6173 7320 5f4d 696e 6474 5079  ..class _MindtPy
-00000b60: 416c 676f 7269 7468 6d28 6f62 6a65 6374  Algorithm(object
-00000b70: 293a 0a20 2020 2064 6566 205f 5f69 6e69  ):.    def __ini
-00000b80: 745f 5f28 7365 6c66 2c20 2a2a 6b77 6473  t__(self, **kwds
-00000b90: 293a 0a20 2020 2020 2020 2022 2222 0a20  ):.        """. 
-00000ba0: 2020 2020 2020 2054 6869 7320 6973 2061         This is a
-00000bb0: 2063 6f6d 6d6f 6e20 696e 6974 206d 6574   common init met
-00000bc0: 686f 6420 666f 7220 616c 6c20 7468 6520  hod for all the 
-00000bd0: 4d69 6e64 7450 7920 616c 676f 7269 7468  MindtPy algorith
-00000be0: 6d73 2c20 736f 2074 6861 7420 7765 0a20  ms, so that we. 
-00000bf0: 2020 2020 2020 2063 6f72 7265 6374 6c79         correctly
-00000c00: 2073 6574 2075 7020 7468 6520 636f 6e66   set up the conf
-00000c10: 6967 2061 7267 756d 656e 7473 2061 6e64  ig arguments and
-00000c20: 2069 6e69 7469 616c 697a 6520 7468 6520   initialize the 
-00000c30: 6765 6e65 7269 6320 7061 7274 730a 2020  generic parts.  
-00000c40: 2020 2020 2020 6f66 2074 6865 2061 6c67        of the alg
-00000c50: 6f72 6974 686d 2073 7461 7465 2e0a 0a20  orithm state... 
-00000c60: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00000c70: 2020 2073 656c 662e 776f 726b 696e 675f     self.working_
-00000c80: 6d6f 6465 6c20 3d20 4e6f 6e65 0a20 2020  model = None.   
-00000c90: 2020 2020 2073 656c 662e 6d69 7020 3d20       self.mip = 
-00000ca0: 4e6f 6e65 0a20 2020 2020 2020 2073 656c  None.        sel
-00000cb0: 662e 6669 7865 645f 6e6c 7020 3d20 4e6f  f.fixed_nlp = No
-00000cc0: 6e65 0a0a 2020 2020 2020 2020 2320 5765  ne..        # We
-00000cd0: 2073 746f 7265 2062 6f75 6e64 732c 2074   store bounds, t
-00000ce0: 696d 696e 6720 696e 666f 2c20 6974 6572  iming info, iter
-00000cf0: 6174 696f 6e20 636f 756e 742c 2069 6e63  ation count, inc
-00000d00: 756d 6265 6e74 2c20 616e 6420 7468 650a  umbent, and the.
-00000d10: 2020 2020 2020 2020 2320 4578 7072 6573          # Expres
-00000d20: 7369 6f6e 206f 6620 7468 6520 6f72 6967  sion of the orig
-00000d30: 696e 616c 2028 706f 7373 6962 6c79 206e  inal (possibly n
-00000d40: 6f6e 6c69 6e65 6172 2920 6f62 6a65 6374  onlinear) object
-00000d50: 6976 6520 6675 6e63 7469 6f6e 2e0a 2020  ive function..  
-00000d60: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
-00000d70: 7473 203d 2053 6f6c 7665 7252 6573 756c  ts = SolverResul
-00000d80: 7473 2829 0a20 2020 2020 2020 2073 656c  ts().        sel
-00000d90: 662e 7469 6d69 6e67 203d 2042 756e 6368  f.timing = Bunch
-00000da0: 2829 0a20 2020 2020 2020 2073 656c 662e  ().        self.
-00000db0: 6375 7272 5f69 6e74 5f73 6f6c 203d 205b  curr_int_sol = [
-00000dc0: 5d0a 2020 2020 2020 2020 7365 6c66 2e73  ].        self.s
-00000dd0: 686f 756c 645f 7465 726d 696e 6174 6520  hould_terminate 
-00000de0: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-00000df0: 7365 6c66 2e69 6e74 6567 6572 5f6c 6973  self.integer_lis
-00000e00: 7420 3d20 5b5d 0a20 2020 2020 2020 2023  t = [].        #
-00000e10: 2044 6963 7469 6f6e 6172 7920 7b69 6e74   Dictionary {int
-00000e20: 6567 6572 2073 6f6c 7574 696f 6e20 2874  eger solution (t
-00000e30: 7570 6c65 293a 205b 6375 7473 2062 6567  uple): [cuts beg
-00000e40: 696e 2069 6e64 6578 2c20 6375 7473 2065  in index, cuts e
-00000e50: 6e64 2069 6e64 6578 5d20 286c 6973 7429  nd index] (list)
-00000e60: 7d0a 2020 2020 2020 2020 7365 6c66 2e69  }.        self.i
-00000e70: 6e74 6567 6572 5f73 6f6c 7574 696f 6e5f  nteger_solution_
-00000e80: 746f 5f63 7574 735f 696e 6465 7820 3d20  to_cuts_index = 
-00000e90: 6469 6374 2829 0a0a 2020 2020 2020 2020  dict()..        
-00000ea0: 2320 5365 7420 7570 2069 7465 7261 7469  # Set up iterati
-00000eb0: 6f6e 2063 6f75 6e74 6572 730a 2020 2020  on counters.    
-00000ec0: 2020 2020 7365 6c66 2e6e 6c70 5f69 7465      self.nlp_ite
-00000ed0: 7220 3d20 300a 2020 2020 2020 2020 7365  r = 0.        se
-00000ee0: 6c66 2e6d 6970 5f69 7465 7220 3d20 300a  lf.mip_iter = 0.
-00000ef0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-00000f00: 5f73 7562 6974 6572 203d 2030 0a20 2020  _subiter = 0.   
-00000f10: 2020 2020 2073 656c 662e 6e6c 705f 696e       self.nlp_in
-00000f20: 6665 6173 6962 6c65 5f63 6f75 6e74 6572  feasible_counter
-00000f30: 203d 2030 0a20 2020 2020 2020 2073 656c   = 0.        sel
-00000f40: 662e 6670 5f69 7465 7220 3d20 310a 0a20  f.fp_iter = 1.. 
-00000f50: 2020 2020 2020 2073 656c 662e 7072 696d         self.prim
-00000f60: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
-00000f70: 735f 7469 6d65 203d 205b 305d 0a20 2020  s_time = [0].   
-00000f80: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
-00000f90: 6f75 6e64 5f70 726f 6772 6573 735f 7469  ound_progress_ti
-00000fa0: 6d65 203d 205b 305d 0a20 2020 2020 2020  me = [0].       
-00000fb0: 2073 656c 662e 6162 735f 6761 7020 3d20   self.abs_gap = 
-00000fc0: 666c 6f61 7428 2769 6e66 2729 0a20 2020  float('inf').   
-00000fd0: 2020 2020 2073 656c 662e 7265 6c5f 6761       self.rel_ga
-00000fe0: 7020 3d20 666c 6f61 7428 2769 6e66 2729  p = float('inf')
-00000ff0: 0a20 2020 2020 2020 2073 656c 662e 6c6f  .        self.lo
-00001000: 675f 666f 726d 6174 7465 7220 3d20 280a  g_formatter = (.
-00001010: 2020 2020 2020 2020 2020 2020 2720 7b3a              ' {:
-00001020: 3e39 7d20 2020 7b3a 3e31 357d 2020 207b  >9}   {:>15}   {
-00001030: 3a3e 3135 677d 2020 207b 3a3e 3132 677d  :>15g}   {:>12g}
-00001040: 2020 207b 3a3e 3132 677d 2020 207b 3a3e     {:>12g}   {:>
-00001050: 372e 3225 7d20 2020 7b3a 3e37 2e32 667d  7.2%}   {:>7.2f}
-00001060: 270a 2020 2020 2020 2020 290a 2020 2020  '.        ).    
-00001070: 2020 2020 7365 6c66 2e74 6572 6d69 6e61      self.termina
-00001080: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 5f6c  tion_condition_l
-00001090: 6f67 5f66 6f72 6d61 7474 6572 203d 2028  og_formatter = (
-000010a0: 0a20 2020 2020 2020 2020 2020 2027 207b  .            ' {
-000010b0: 3a3e 397d 2020 207b 3a3e 3135 7d20 2020  :>9}   {:>15}   
-000010c0: 7b3a 3e31 357d 2020 207b 3a3e 3132 677d  {:>15}   {:>12g}
-000010d0: 2020 207b 3a3e 3132 677d 2020 207b 3a3e     {:>12g}   {:>
-000010e0: 372e 3225 7d20 2020 7b3a 3e37 2e32 667d  7.2%}   {:>7.2f}
-000010f0: 270a 2020 2020 2020 2020 290a 2020 2020  '.        ).    
-00001100: 2020 2020 7365 6c66 2e66 6978 6564 5f6e      self.fixed_n
-00001110: 6c70 5f6c 6f67 5f66 6f72 6d61 7474 6572  lp_log_formatter
-00001120: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-00001130: 2027 7b3a 317d 7b3a 3e39 7d20 2020 7b3a   '{:1}{:>9}   {:
-00001140: 3e31 357d 2020 207b 3a3e 3135 677d 2020  >15}   {:>15g}  
-00001150: 207b 3a3e 3132 677d 2020 207b 3a3e 3132   {:>12g}   {:>12
-00001160: 677d 2020 207b 3a3e 372e 3225 7d20 2020  g}   {:>7.2%}   
-00001170: 7b3a 3e37 2e32 667d 270a 2020 2020 2020  {:>7.2f}'.      
-00001180: 2020 290a 2020 2020 2020 2020 7365 6c66    ).        self
-00001190: 2e69 6e66 6561 7369 626c 655f 6669 7865  .infeasible_fixe
-000011a0: 645f 6e6c 705f 6c6f 675f 666f 726d 6174  d_nlp_log_format
-000011b0: 7465 7220 3d20 280a 2020 2020 2020 2020  ter = (.        
-000011c0: 2020 2020 277b 3a31 7d7b 3a3e 397d 2020      '{:1}{:>9}  
-000011d0: 207b 3a3e 3135 7d20 2020 7b3a 3e31 357d   {:>15}   {:>15}
-000011e0: 2020 207b 3a3e 3132 677d 2020 207b 3a3e     {:>12g}   {:>
-000011f0: 3132 677d 2020 207b 3a3e 372e 3225 7d20  12g}   {:>7.2%} 
-00001200: 2020 7b3a 3e37 2e32 667d 270a 2020 2020    {:>7.2f}'.    
-00001210: 2020 2020 290a 2020 2020 2020 2020 7365      ).        se
-00001220: 6c66 2e6c 6f67 5f6e 6f74 655f 666f 726d  lf.log_note_form
-00001230: 6174 7465 7220 3d20 2720 7b3a 3e39 7d20  atter = ' {:>9} 
-00001240: 2020 7b3a 3e31 357d 2020 207b 3a3e 3135    {:>15}   {:>15
-00001250: 7d27 0a0a 2020 2020 2020 2020 2320 466c  }'..        # Fl
-00001260: 6167 2069 6e64 6963 6174 696e 6720 7768  ag indicating wh
-00001270: 6574 6865 7220 7468 6520 736f 6c75 7469  ether the soluti
-00001280: 6f6e 2069 6d70 726f 7665 6420 696e 2074  on improved in t
-00001290: 6865 2070 6173 740a 2020 2020 2020 2020  he past.        
-000012a0: 2320 6974 6572 6174 696f 6e20 6f72 206e  # iteration or n
-000012b0: 6f74 0a20 2020 2020 2020 2073 656c 662e  ot.        self.
-000012c0: 7072 696d 616c 5f62 6f75 6e64 5f69 6d70  primal_bound_imp
-000012d0: 726f 7665 6420 3d20 4661 6c73 650a 2020  roved = False.  
-000012e0: 2020 2020 2020 7365 6c66 2e64 7561 6c5f        self.dual_
-000012f0: 626f 756e 645f 696d 7072 6f76 6564 203d  bound_improved =
-00001300: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
-00001310: 2320 5374 6f72 6520 7468 6520 696e 6974  # Store the init
-00001320: 6961 6c20 6d6f 6465 6c20 7374 6174 6520  ial model state 
-00001330: 6173 2074 6865 2062 6573 7420 736f 6c75  as the best solu
-00001340: 7469 6f6e 2066 6f75 6e64 2e20 4966 2077  tion found. If w
-00001350: 650a 2020 2020 2020 2020 2320 6669 6e64  e.        # find
-00001360: 206e 6f20 6265 7474 6572 2073 6f6c 7574   no better solut
-00001370: 696f 6e2c 2074 6865 6e20 7765 2077 696c  ion, then we wil
-00001380: 6c20 7265 7374 6f72 6520 6672 6f6d 2074  l restore from t
-00001390: 6869 7320 636f 7079 2e0a 2020 2020 2020  his copy..      
-000013a0: 2020 7365 6c66 2e62 6573 745f 736f 6c75    self.best_solu
-000013b0: 7469 6f6e 5f66 6f75 6e64 203d 204e 6f6e  tion_found = Non
-000013c0: 650a 2020 2020 2020 2020 7365 6c66 2e62  e.        self.b
-000013d0: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
-000013e0: 6e64 5f74 696d 6520 3d20 4e6f 6e65 0a0a  nd_time = None..
-000013f0: 2020 2020 2020 2020 7365 6c66 2e73 746f          self.sto
-00001400: 7265 645f 626f 756e 6420 3d20 7b7d 0a20  red_bound = {}. 
-00001410: 2020 2020 2020 2073 656c 662e 6e75 6d5f         self.num_
-00001420: 6e6f 5f67 6f6f 645f 6375 7473 5f61 6464  no_good_cuts_add
-00001430: 6564 203d 207b 7d0a 2020 2020 2020 2020  ed = {}.        
-00001440: 7365 6c66 2e6c 6173 745f 6974 6572 5f63  self.last_iter_c
-00001450: 7574 7320 3d20 4661 6c73 650a 2020 2020  uts = False.    
-00001460: 2020 2020 2320 5374 6f72 6520 7468 6520      # Store the 
-00001470: 4f41 2063 7574 7320 6765 6e65 7261 7465  OA cuts generate
-00001480: 6420 696e 2074 6865 206d 6970 5f73 7461  d in the mip_sta
-00001490: 7274 5f70 726f 6365 7373 2e0a 2020 2020  rt_process..    
-000014a0: 2020 2020 7365 6c66 2e6d 6970 5f73 7461      self.mip_sta
-000014b0: 7274 5f6c 617a 795f 6f61 5f63 7574 7320  rt_lazy_oa_cuts 
-000014c0: 3d20 5b5d 0a20 2020 2020 2020 2023 2057  = [].        # W
-000014d0: 6865 7468 6572 2074 6f20 6c6f 6164 2073  hether to load s
-000014e0: 6f6c 7574 696f 6e73 2069 6e20 736f 6c76  olutions in solv
-000014f0: 6528 2920 6675 6e63 7469 6f6e 0a20 2020  e() function.   
-00001500: 2020 2020 2073 656c 662e 6c6f 6164 5f73       self.load_s
-00001510: 6f6c 7574 696f 6e73 203d 2054 7275 650a  olutions = True.
-00001520: 0a20 2020 2023 2053 7570 706f 7274 2075  .    # Support u
-00001530: 7365 2061 7320 6120 636f 6e74 6578 7420  se as a context 
-00001540: 6d61 6e61 6765 7220 756e 6465 7220 6375  manager under cu
-00001550: 7272 656e 7420 736f 6c76 6572 2041 5049  rrent solver API
-00001560: 0a20 2020 2064 6566 205f 5f65 6e74 6572  .    def __enter
-00001570: 5f5f 2873 656c 6629 3a0a 2020 2020 2020  __(self):.      
-00001580: 2020 7265 7475 726e 2073 656c 660a 0a20    return self.. 
-00001590: 2020 2064 6566 205f 5f65 7869 745f 5f28     def __exit__(
-000015a0: 7365 6c66 2c20 742c 2076 2c20 7472 6163  self, t, v, trac
-000015b0: 6562 6163 6b29 3a0a 2020 2020 2020 2020  eback):.        
-000015c0: 7061 7373 0a0a 2020 2020 6465 6620 6176  pass..    def av
-000015d0: 6169 6c61 626c 6528 7365 6c66 2c20 6578  ailable(self, ex
-000015e0: 6365 7074 696f 6e5f 666c 6167 3d54 7275  ception_flag=Tru
-000015f0: 6529 3a0a 2020 2020 2020 2020 2222 2253  e):.        """S
-00001600: 6f6c 7665 7220 6973 2061 6c77 6179 7320  olver is always 
-00001610: 6176 6169 6c61 626c 652e 2054 686f 7567  available. Thoug
-00001620: 6820 7375 6273 6f6c 7665 7273 206d 6179  h subsolvers may
-00001630: 206e 6f74 2062 652c 2074 6865 7920 7769   not be, they wi
-00001640: 6c6c 0a20 2020 2020 2020 2072 6169 7365  ll.        raise
-00001650: 2061 6e20 6572 726f 7220 7768 656e 2074   an error when t
-00001660: 6865 2074 696d 6520 636f 6d65 732e 0a20  he time comes.. 
-00001670: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00001680: 2020 2072 6574 7572 6e20 5472 7565 0a0a     return True..
-00001690: 2020 2020 6465 6620 6c69 6365 6e73 655f      def license_
-000016a0: 6973 5f76 616c 6964 2873 656c 6629 3a0a  is_valid(self):.
-000016b0: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-000016c0: 7275 650a 0a20 2020 2064 6566 2076 6572  rue..    def ver
-000016d0: 7369 6f6e 2873 656c 6629 3a0a 2020 2020  sion(self):.    
-000016e0: 2020 2020 2222 2252 6574 7572 6e20 6120      """Return a 
-000016f0: 332d 7475 706c 6520 6465 7363 7269 6269  3-tuple describi
-00001700: 6e67 2074 6865 2073 6f6c 7665 7220 7665  ng the solver ve
-00001710: 7273 696f 6e2e 2222 220a 2020 2020 2020  rsion.""".      
-00001720: 2020 7265 7475 726e 205f 5f76 6572 7369    return __versi
-00001730: 6f6e 5f5f 0a0a 2020 2020 5f6d 6574 6173  on__..    _metas
-00001740: 6f6c 7665 7220 3d20 4661 6c73 650a 0a20  olver = False.. 
-00001750: 2020 2064 6566 205f 6c6f 675f 736f 6c76     def _log_solv
-00001760: 6572 5f69 6e74 726f 5f6d 6573 7361 6765  er_intro_message
-00001770: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-00001780: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
-00001790: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
-000017a0: 2020 2020 2022 5374 6172 7469 6e67 204d       "Starting M
-000017b0: 696e 6474 5079 2076 6572 7369 6f6e 2025  indtPy version %
-000017c0: 7320 7573 696e 6720 2573 2061 6c67 6f72  s using %s algor
-000017d0: 6974 686d 220a 2020 2020 2020 2020 2020  ithm".          
-000017e0: 2020 2520 2822 2e22 2e6a 6f69 6e28 6d61    % (".".join(ma
-000017f0: 7028 7374 722c 2073 656c 662e 7665 7273  p(str, self.vers
-00001800: 696f 6e28 2929 292c 2073 656c 662e 636f  ion())), self.co
-00001810: 6e66 6967 2e73 7472 6174 6567 7929 0a20  nfig.strategy). 
-00001820: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00001830: 206f 7320 3d20 5374 7269 6e67 494f 2829   os = StringIO()
-00001840: 0a20 2020 2020 2020 2073 656c 662e 636f  .        self.co
-00001850: 6e66 6967 2e64 6973 706c 6179 286f 7374  nfig.display(ost
-00001860: 7265 616d 3d6f 7329 0a20 2020 2020 2020  ream=os).       
-00001870: 2073 656c 662e 636f 6e66 6967 2e6c 6f67   self.config.log
-00001880: 6765 722e 696e 666f 286f 732e 6765 7476  ger.info(os.getv
-00001890: 616c 7565 2829 290a 2020 2020 2020 2020  alue()).        
-000018a0: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
-000018b0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
-000018c0: 2020 2020 2027 2d2d 2d2d 2d2d 2d2d 2d2d       '----------
-000018d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000018e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000018f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00000570: 2e6f 7074 2069 6d70 6f72 7420 536f 6c76  .opt import Solv
+00000580: 6572 4661 6374 6f72 792c 2053 6f6c 7665  erFactory, Solve
+00000590: 7252 6573 756c 7473 2c20 536f 6c75 7469  rResults, Soluti
+000005a0: 6f6e 5374 6174 7573 2c20 536f 6c76 6572  onStatus, Solver
+000005b0: 5374 6174 7573 0a66 726f 6d20 7079 6f6d  Status.from pyom
+000005c0: 6f2e 636f 7265 2069 6d70 6f72 7420 280a  o.core import (.
+000005d0: 2020 2020 6d69 6e69 6d69 7a65 2c0a 2020      minimize,.  
+000005e0: 2020 6d61 7869 6d69 7a65 2c0a 2020 2020    maximize,.    
+000005f0: 4f62 6a65 6374 6976 652c 0a20 2020 2056  Objective,.    V
+00000600: 6172 4c69 7374 2c0a 2020 2020 5265 616c  arList,.    Real
+00000610: 732c 0a20 2020 2043 6f6e 7374 7261 696e  s,.    Constrain
+00000620: 744c 6973 742c 0a20 2020 2043 6f6e 7374  tList,.    Const
+00000630: 7261 696e 742c 0a20 2020 2042 6c6f 636b  raint,.    Block
+00000640: 2c0a 2020 2020 5472 616e 7366 6f72 6d61  ,.    Transforma
+00000650: 7469 6f6e 4661 6374 6f72 792c 0a20 2020  tionFactory,.   
+00000660: 204e 6f6e 4e65 6761 7469 7665 5265 616c   NonNegativeReal
+00000670: 732c 0a20 2020 2053 7566 6669 782c 0a20  s,.    Suffix,. 
+00000680: 2020 2056 6172 2c0a 2020 2020 5261 6e67     Var,.    Rang
+00000690: 6553 6574 2c0a 2020 2020 7661 6c75 652c  eSet,.    value,
+000006a0: 0a20 2020 2045 7870 7265 7373 696f 6e2c  .    Expression,
+000006b0: 0a29 0a66 726f 6d20 7079 6f6d 6f2e 636f  .).from pyomo.co
+000006c0: 6e74 7269 622e 6764 706f 7074 2e75 7469  ntrib.gdpopt.uti
+000006d0: 6c20 696d 706f 7274 2028 0a20 2020 2053  l import (.    S
+000006e0: 7570 7072 6573 7349 6e66 6561 7369 626c  uppressInfeasibl
+000006f0: 6557 6172 6e69 6e67 2c0a 2020 2020 5f44  eWarning,.    _D
+00000700: 6f4e 6f74 6869 6e67 2c0a 2020 2020 6c6f  oNothing,.    lo
+00000710: 7765 725f 6c6f 6767 6572 5f6c 6576 656c  wer_logger_level
+00000720: 5f74 6f2c 0a20 2020 2067 6574 5f6d 6169  _to,.    get_mai
+00000730: 6e5f 656c 6170 7365 645f 7469 6d65 2c0a  n_elapsed_time,.
+00000740: 2020 2020 7469 6d65 5f63 6f64 652c 0a29      time_code,.)
+00000750: 0a66 726f 6d20 7079 6f6d 6f2e 636f 6e74  .from pyomo.cont
+00000760: 7269 622e 6764 706f 7074 2e73 6f6c 7665  rib.gdpopt.solve
+00000770: 5f64 6973 6372 6574 655f 7072 6f62 6c65  _discrete_proble
+00000780: 6d20 696d 706f 7274 2028 0a20 2020 2064  m import (.    d
+00000790: 6973 7469 6e67 7569 7368 5f6d 6970 5f69  istinguish_mip_i
+000007a0: 6e66 6561 7369 626c 655f 6f72 5f75 6e62  nfeasible_or_unb
+000007b0: 6f75 6e64 6564 2c0a 290a 6672 6f6d 2070  ounded,.).from p
+000007c0: 796f 6d6f 2e63 6f6e 7472 6962 2e6d 696e  yomo.contrib.min
+000007d0: 6474 7079 2e75 7469 6c20 696d 706f 7274  dtpy.util import
+000007e0: 2028 0a20 2020 2067 656e 6572 6174 655f   (.    generate_
+000007f0: 6e6f 726d 315f 6f62 6a65 6374 6976 655f  norm1_objective_
+00000800: 6675 6e63 7469 6f6e 2c0a 2020 2020 6765  function,.    ge
+00000810: 6e65 7261 7465 5f6e 6f72 6d32 7371 5f6f  nerate_norm2sq_o
+00000820: 626a 6563 7469 7665 5f66 756e 6374 696f  bjective_functio
+00000830: 6e2c 0a20 2020 2067 656e 6572 6174 655f  n,.    generate_
+00000840: 6e6f 726d 5f69 6e66 5f6f 626a 6563 7469  norm_inf_objecti
+00000850: 7665 5f66 756e 6374 696f 6e2c 0a20 2020  ve_function,.   
+00000860: 2067 656e 6572 6174 655f 6c61 675f 6f62   generate_lag_ob
+00000870: 6a65 6374 6976 655f 6675 6e63 7469 6f6e  jective_function
+00000880: 2c0a 2020 2020 4775 726f 6269 5065 7273  ,.    GurobiPers
+00000890: 6973 7465 6e74 344d 696e 6474 5079 2c0a  istent4MindtPy,.
+000008a0: 2020 2020 7365 7475 705f 7265 7375 6c74      setup_result
+000008b0: 735f 6f62 6a65 6374 2c0a 2020 2020 6765  s_object,.    ge
+000008c0: 745f 696e 7465 6765 725f 736f 6c75 7469  t_integer_soluti
+000008d0: 6f6e 2c0a 2020 2020 696e 6974 6961 6c69  on,.    initiali
+000008e0: 7a65 5f66 6561 735f 7375 6270 726f 626c  ze_feas_subprobl
+000008f0: 656d 2c0a 2020 2020 6570 6967 7261 7068  em,.    epigraph
+00000900: 5f72 6566 6f72 6d75 6c61 7469 6f6e 2c0a  _reformulation,.
+00000910: 2020 2020 6164 645f 7661 725f 626f 756e      add_var_boun
+00000920: 642c 0a20 2020 2063 6f70 795f 7661 725f  d,.    copy_var_
+00000930: 6c69 7374 5f76 616c 7565 735f 6672 6f6d  list_values_from
+00000940: 5f73 6f6c 7574 696f 6e5f 706f 6f6c 2c0a  _solution_pool,.
+00000950: 2020 2020 6765 6e65 7261 7465 5f6e 6f72      generate_nor
+00000960: 6d5f 636f 6e73 7472 6169 6e74 2c0a 2020  m_constraint,.  
+00000970: 2020 6670 5f63 6f6e 7665 7267 6564 2c0a    fp_converged,.
+00000980: 2020 2020 6164 645f 6f72 7468 6f67 6f6e      add_orthogon
+00000990: 616c 6974 795f 6375 7473 2c0a 2020 2020  ality_cuts,.    
+000009a0: 7365 745f 736f 6c76 6572 5f6d 6970 6761  set_solver_mipga
+000009b0: 702c 0a20 2020 2073 6574 5f73 6f6c 7665  p,.    set_solve
+000009c0: 725f 636f 6e73 7472 6169 6e74 5f76 696f  r_constraint_vio
+000009d0: 6c61 7469 6f6e 5f74 6f6c 6572 616e 6365  lation_tolerance
+000009e0: 2c0a 2020 2020 7570 6461 7465 5f73 6f6c  ,.    update_sol
+000009f0: 7665 725f 7469 6d65 6c69 6d69 742c 0a20  ver_timelimit,. 
+00000a00: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
+00000a10: 5f76 616c 7565 732c 0a29 0a0a 7369 6e67  _values,.)..sing
+00000a20: 6c65 5f74 7265 652c 2073 696e 676c 655f  le_tree, single_
+00000a30: 7472 6565 5f61 7661 696c 6162 6c65 203d  tree_available =
+00000a40: 2061 7474 656d 7074 5f69 6d70 6f72 7428   attempt_import(
+00000a50: 2770 796f 6d6f 2e63 6f6e 7472 6962 2e6d  'pyomo.contrib.m
+00000a60: 696e 6474 7079 2e73 696e 676c 655f 7472  indtpy.single_tr
+00000a70: 6565 2729 0a74 6162 755f 6c69 7374 2c20  ee').tabu_list, 
+00000a80: 7461 6275 5f6c 6973 745f 6176 6169 6c61  tabu_list_availa
+00000a90: 626c 6520 3d20 6174 7465 6d70 745f 696d  ble = attempt_im
+00000aa0: 706f 7274 2827 7079 6f6d 6f2e 636f 6e74  port('pyomo.cont
+00000ab0: 7269 622e 6d69 6e64 7470 792e 7461 6275  rib.mindtpy.tabu
+00000ac0: 5f6c 6973 7427 290a 6567 622c 2065 6762  _list').egb, egb
+00000ad0: 5f61 7661 696c 6162 6c65 203d 2061 7474  _available = att
+00000ae0: 656d 7074 5f69 6d70 6f72 7428 0a20 2020  empt_import(.   
+00000af0: 2027 7079 6f6d 6f2e 636f 6e74 7269 622e   'pyomo.contrib.
+00000b00: 7079 6e75 6d65 726f 2e69 6e74 6572 6661  pynumero.interfa
+00000b10: 6365 732e 6578 7465 726e 616c 5f67 7265  ces.external_gre
+00000b20: 795f 626f 7827 0a29 0a0a 0a63 6c61 7373  y_box'.)...class
+00000b30: 205f 4d69 6e64 7450 7941 6c67 6f72 6974   _MindtPyAlgorit
+00000b40: 686d 286f 626a 6563 7429 3a0a 2020 2020  hm(object):.    
+00000b50: 6465 6620 5f5f 696e 6974 5f5f 2873 656c  def __init__(sel
+00000b60: 662c 202a 2a6b 7764 7329 3a0a 2020 2020  f, **kwds):.    
+00000b70: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00000b80: 5468 6973 2069 7320 6120 636f 6d6d 6f6e  This is a common
+00000b90: 2069 6e69 7420 6d65 7468 6f64 2066 6f72   init method for
+00000ba0: 2061 6c6c 2074 6865 204d 696e 6474 5079   all the MindtPy
+00000bb0: 2061 6c67 6f72 6974 686d 732c 2073 6f20   algorithms, so 
+00000bc0: 7468 6174 2077 650a 2020 2020 2020 2020  that we.        
+00000bd0: 636f 7272 6563 746c 7920 7365 7420 7570  correctly set up
+00000be0: 2074 6865 2063 6f6e 6669 6720 6172 6775   the config argu
+00000bf0: 6d65 6e74 7320 616e 6420 696e 6974 6961  ments and initia
+00000c00: 6c69 7a65 2074 6865 2067 656e 6572 6963  lize the generic
+00000c10: 2070 6172 7473 0a20 2020 2020 2020 206f   parts.        o
+00000c20: 6620 7468 6520 616c 676f 7269 7468 6d20  f the algorithm 
+00000c30: 7374 6174 652e 0a0a 2020 2020 2020 2020  state...        
+00000c40: 2222 220a 2020 2020 2020 2020 7365 6c66  """.        self
+00000c50: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 203d  .working_model =
+00000c60: 204e 6f6e 650a 2020 2020 2020 2020 7365   None.        se
+00000c70: 6c66 2e6d 6970 203d 204e 6f6e 650a 2020  lf.mip = None.  
+00000c80: 2020 2020 2020 7365 6c66 2e66 6978 6564        self.fixed
+00000c90: 5f6e 6c70 203d 204e 6f6e 650a 0a20 2020  _nlp = None..   
+00000ca0: 2020 2020 2023 2057 6520 7374 6f72 6520       # We store 
+00000cb0: 626f 756e 6473 2c20 7469 6d69 6e67 2069  bounds, timing i
+00000cc0: 6e66 6f2c 2069 7465 7261 7469 6f6e 2063  nfo, iteration c
+00000cd0: 6f75 6e74 2c20 696e 6375 6d62 656e 742c  ount, incumbent,
+00000ce0: 2061 6e64 2074 6865 0a20 2020 2020 2020   and the.       
+00000cf0: 2023 2045 7870 7265 7373 696f 6e20 6f66   # Expression of
+00000d00: 2074 6865 206f 7269 6769 6e61 6c20 2870   the original (p
+00000d10: 6f73 7369 626c 7920 6e6f 6e6c 696e 6561  ossibly nonlinea
+00000d20: 7229 206f 626a 6563 7469 7665 2066 756e  r) objective fun
+00000d30: 6374 696f 6e2e 0a20 2020 2020 2020 2073  ction..        s
+00000d40: 656c 662e 7265 7375 6c74 7320 3d20 536f  elf.results = So
+00000d50: 6c76 6572 5265 7375 6c74 7328 290a 2020  lverResults().  
+00000d60: 2020 2020 2020 7365 6c66 2e74 696d 696e        self.timin
+00000d70: 6720 3d20 4275 6e63 6828 290a 2020 2020  g = Bunch().    
+00000d80: 2020 2020 7365 6c66 2e63 7572 725f 696e      self.curr_in
+00000d90: 745f 736f 6c20 3d20 5b5d 0a20 2020 2020  t_sol = [].     
+00000da0: 2020 2073 656c 662e 7368 6f75 6c64 5f74     self.should_t
+00000db0: 6572 6d69 6e61 7465 203d 2046 616c 7365  erminate = False
+00000dc0: 0a20 2020 2020 2020 2073 656c 662e 696e  .        self.in
+00000dd0: 7465 6765 725f 6c69 7374 203d 205b 5d0a  teger_list = [].
+00000de0: 2020 2020 2020 2020 2320 4469 6374 696f          # Dictio
+00000df0: 6e61 7279 207b 696e 7465 6765 7220 736f  nary {integer so
+00000e00: 6c75 7469 6f6e 2028 7475 706c 6529 3a20  lution (tuple): 
+00000e10: 5b63 7574 7320 6265 6769 6e20 696e 6465  [cuts begin inde
+00000e20: 782c 2063 7574 7320 656e 6420 696e 6465  x, cuts end inde
+00000e30: 785d 2028 6c69 7374 297d 0a20 2020 2020  x] (list)}.     
+00000e40: 2020 2073 656c 662e 696e 7465 6765 725f     self.integer_
+00000e50: 736f 6c75 7469 6f6e 5f74 6f5f 6375 7473  solution_to_cuts
+00000e60: 5f69 6e64 6578 203d 2064 6963 7428 290a  _index = dict().
+00000e70: 0a20 2020 2020 2020 2023 2053 6574 2075  .        # Set u
+00000e80: 7020 6974 6572 6174 696f 6e20 636f 756e  p iteration coun
+00000e90: 7465 7273 0a20 2020 2020 2020 2073 656c  ters.        sel
+00000ea0: 662e 6e6c 705f 6974 6572 203d 2030 0a20  f.nlp_iter = 0. 
+00000eb0: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
+00000ec0: 6974 6572 203d 2030 0a20 2020 2020 2020  iter = 0.       
+00000ed0: 2073 656c 662e 6d69 705f 7375 6269 7465   self.mip_subite
+00000ee0: 7220 3d20 300a 2020 2020 2020 2020 7365  r = 0.        se
+00000ef0: 6c66 2e6e 6c70 5f69 6e66 6561 7369 626c  lf.nlp_infeasibl
+00000f00: 655f 636f 756e 7465 7220 3d20 300a 2020  e_counter = 0.  
+00000f10: 2020 2020 2020 7365 6c66 2e66 705f 6974        self.fp_it
+00000f20: 6572 203d 2031 0a0a 2020 2020 2020 2020  er = 1..        
+00000f30: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
+00000f40: 645f 7072 6f67 7265 7373 5f74 696d 6520  d_progress_time 
+00000f50: 3d20 5b30 5d0a 2020 2020 2020 2020 7365  = [0].        se
+00000f60: 6c66 2e64 7561 6c5f 626f 756e 645f 7072  lf.dual_bound_pr
+00000f70: 6f67 7265 7373 5f74 696d 6520 3d20 5b30  ogress_time = [0
+00000f80: 5d0a 2020 2020 2020 2020 7365 6c66 2e61  ].        self.a
+00000f90: 6273 5f67 6170 203d 2066 6c6f 6174 2827  bs_gap = float('
+00000fa0: 696e 6627 290a 2020 2020 2020 2020 7365  inf').        se
+00000fb0: 6c66 2e72 656c 5f67 6170 203d 2066 6c6f  lf.rel_gap = flo
+00000fc0: 6174 2827 696e 6627 290a 2020 2020 2020  at('inf').      
+00000fd0: 2020 7365 6c66 2e6c 6f67 5f66 6f72 6d61    self.log_forma
+00000fe0: 7474 6572 203d 2028 0a20 2020 2020 2020  tter = (.       
+00000ff0: 2020 2020 2027 207b 3a3e 397d 2020 207b       ' {:>9}   {
+00001000: 3a3e 3135 7d20 2020 7b3a 3e31 3567 7d20  :>15}   {:>15g} 
+00001010: 2020 7b3a 3e31 3267 7d20 2020 7b3a 3e31    {:>12g}   {:>1
+00001020: 3267 7d20 2020 7b3a 3e37 2e32 257d 2020  2g}   {:>7.2%}  
+00001030: 207b 3a3e 372e 3266 7d27 0a20 2020 2020   {:>7.2f}'.     
+00001040: 2020 2029 0a20 2020 2020 2020 2073 656c     ).        sel
+00001050: 662e 7465 726d 696e 6174 696f 6e5f 636f  f.termination_co
+00001060: 6e64 6974 696f 6e5f 6c6f 675f 666f 726d  ndition_log_form
+00001070: 6174 7465 7220 3d20 280a 2020 2020 2020  atter = (.      
+00001080: 2020 2020 2020 2720 7b3a 3e39 7d20 2020        ' {:>9}   
+00001090: 7b3a 3e31 357d 2020 207b 3a3e 3135 7d20  {:>15}   {:>15} 
+000010a0: 2020 7b3a 3e31 3267 7d20 2020 7b3a 3e31    {:>12g}   {:>1
+000010b0: 3267 7d20 2020 7b3a 3e37 2e32 257d 2020  2g}   {:>7.2%}  
+000010c0: 207b 3a3e 372e 3266 7d27 0a20 2020 2020   {:>7.2f}'.     
+000010d0: 2020 2029 0a20 2020 2020 2020 2073 656c     ).        sel
+000010e0: 662e 6669 7865 645f 6e6c 705f 6c6f 675f  f.fixed_nlp_log_
+000010f0: 666f 726d 6174 7465 7220 3d20 280a 2020  formatter = (.  
+00001100: 2020 2020 2020 2020 2020 277b 3a31 7d7b            '{:1}{
+00001110: 3a3e 397d 2020 207b 3a3e 3135 7d20 2020  :>9}   {:>15}   
+00001120: 7b3a 3e31 3567 7d20 2020 7b3a 3e31 3267  {:>15g}   {:>12g
+00001130: 7d20 2020 7b3a 3e31 3267 7d20 2020 7b3a  }   {:>12g}   {:
+00001140: 3e37 2e32 257d 2020 207b 3a3e 372e 3266  >7.2%}   {:>7.2f
+00001150: 7d27 0a20 2020 2020 2020 2029 0a20 2020  }'.        ).   
+00001160: 2020 2020 2073 656c 662e 696e 6665 6173       self.infeas
+00001170: 6962 6c65 5f66 6978 6564 5f6e 6c70 5f6c  ible_fixed_nlp_l
+00001180: 6f67 5f66 6f72 6d61 7474 6572 203d 2028  og_formatter = (
+00001190: 0a20 2020 2020 2020 2020 2020 2027 7b3a  .            '{:
+000011a0: 317d 7b3a 3e39 7d20 2020 7b3a 3e31 357d  1}{:>9}   {:>15}
+000011b0: 2020 207b 3a3e 3135 7d20 2020 7b3a 3e31     {:>15}   {:>1
+000011c0: 3267 7d20 2020 7b3a 3e31 3267 7d20 2020  2g}   {:>12g}   
+000011d0: 7b3a 3e37 2e32 257d 2020 207b 3a3e 372e  {:>7.2%}   {:>7.
+000011e0: 3266 7d27 0a20 2020 2020 2020 2029 0a20  2f}'.        ). 
+000011f0: 2020 2020 2020 2073 656c 662e 6c6f 675f         self.log_
+00001200: 6e6f 7465 5f66 6f72 6d61 7474 6572 203d  note_formatter =
+00001210: 2027 207b 3a3e 397d 2020 207b 3a3e 3135   ' {:>9}   {:>15
+00001220: 7d20 2020 7b3a 3e31 357d 270a 0a20 2020  }   {:>15}'..   
+00001230: 2020 2020 2023 2046 6c61 6720 696e 6469       # Flag indi
+00001240: 6361 7469 6e67 2077 6865 7468 6572 2074  cating whether t
+00001250: 6865 2073 6f6c 7574 696f 6e20 696d 7072  he solution impr
+00001260: 6f76 6564 2069 6e20 7468 6520 7061 7374  oved in the past
+00001270: 0a20 2020 2020 2020 2023 2069 7465 7261  .        # itera
+00001280: 7469 6f6e 206f 7220 6e6f 740a 2020 2020  tion or not.    
+00001290: 2020 2020 7365 6c66 2e70 7269 6d61 6c5f      self.primal_
+000012a0: 626f 756e 645f 696d 7072 6f76 6564 203d  bound_improved =
+000012b0: 2046 616c 7365 0a20 2020 2020 2020 2073   False.        s
+000012c0: 656c 662e 6475 616c 5f62 6f75 6e64 5f69  elf.dual_bound_i
+000012d0: 6d70 726f 7665 6420 3d20 4661 6c73 650a  mproved = False.
+000012e0: 0a20 2020 2020 2020 2023 2053 746f 7265  .        # Store
+000012f0: 2074 6865 2069 6e69 7469 616c 206d 6f64   the initial mod
+00001300: 656c 2073 7461 7465 2061 7320 7468 6520  el state as the 
+00001310: 6265 7374 2073 6f6c 7574 696f 6e20 666f  best solution fo
+00001320: 756e 642e 2049 6620 7765 0a20 2020 2020  und. If we.     
+00001330: 2020 2023 2066 696e 6420 6e6f 2062 6574     # find no bet
+00001340: 7465 7220 736f 6c75 7469 6f6e 2c20 7468  ter solution, th
+00001350: 656e 2077 6520 7769 6c6c 2072 6573 746f  en we will resto
+00001360: 7265 2066 726f 6d20 7468 6973 2063 6f70  re from this cop
+00001370: 792e 0a20 2020 2020 2020 2073 656c 662e  y..        self.
+00001380: 6265 7374 5f73 6f6c 7574 696f 6e5f 666f  best_solution_fo
+00001390: 756e 6420 3d20 4e6f 6e65 0a20 2020 2020  und = None.     
+000013a0: 2020 2073 656c 662e 6265 7374 5f73 6f6c     self.best_sol
+000013b0: 7574 696f 6e5f 666f 756e 645f 7469 6d65  ution_found_time
+000013c0: 203d 204e 6f6e 650a 0a20 2020 2020 2020   = None..       
+000013d0: 2073 656c 662e 7374 6f72 6564 5f62 6f75   self.stored_bou
+000013e0: 6e64 203d 207b 7d0a 2020 2020 2020 2020  nd = {}.        
+000013f0: 7365 6c66 2e6e 756d 5f6e 6f5f 676f 6f64  self.num_no_good
+00001400: 5f63 7574 735f 6164 6465 6420 3d20 7b7d  _cuts_added = {}
+00001410: 0a20 2020 2020 2020 2073 656c 662e 6c61  .        self.la
+00001420: 7374 5f69 7465 725f 6375 7473 203d 2046  st_iter_cuts = F
+00001430: 616c 7365 0a20 2020 2020 2020 2023 2053  alse.        # S
+00001440: 746f 7265 2074 6865 204f 4120 6375 7473  tore the OA cuts
+00001450: 2067 656e 6572 6174 6564 2069 6e20 7468   generated in th
+00001460: 6520 6d69 705f 7374 6172 745f 7072 6f63  e mip_start_proc
+00001470: 6573 732e 0a20 2020 2020 2020 2073 656c  ess..        sel
+00001480: 662e 6d69 705f 7374 6172 745f 6c61 7a79  f.mip_start_lazy
+00001490: 5f6f 615f 6375 7473 203d 205b 5d0a 2020  _oa_cuts = [].  
+000014a0: 2020 2020 2020 2320 5768 6574 6865 7220        # Whether 
+000014b0: 746f 206c 6f61 6420 736f 6c75 7469 6f6e  to load solution
+000014c0: 7320 696e 2073 6f6c 7665 2829 2066 756e  s in solve() fun
+000014d0: 6374 696f 6e0a 2020 2020 2020 2020 7365  ction.        se
+000014e0: 6c66 2e6d 6970 5f6c 6f61 645f 736f 6c75  lf.mip_load_solu
+000014f0: 7469 6f6e 7320 3d20 5472 7565 0a20 2020  tions = True.   
+00001500: 2020 2020 2073 656c 662e 6e6c 705f 6c6f       self.nlp_lo
+00001510: 6164 5f73 6f6c 7574 696f 6e73 203d 2054  ad_solutions = T
+00001520: 7275 650a 2020 2020 2020 2020 7365 6c66  rue.        self
+00001530: 2e72 6567 756c 6172 697a 6174 696f 6e5f  .regularization_
+00001540: 6d69 705f 6c6f 6164 5f73 6f6c 7574 696f  mip_load_solutio
+00001550: 6e73 203d 2054 7275 650a 0a20 2020 2023  ns = True..    #
+00001560: 2053 7570 706f 7274 2075 7365 2061 7320   Support use as 
+00001570: 6120 636f 6e74 6578 7420 6d61 6e61 6765  a context manage
+00001580: 7220 756e 6465 7220 6375 7272 656e 7420  r under current 
+00001590: 736f 6c76 6572 2041 5049 0a20 2020 2064  solver API.    d
+000015a0: 6566 205f 5f65 6e74 6572 5f5f 2873 656c  ef __enter__(sel
+000015b0: 6629 3a0a 2020 2020 2020 2020 7265 7475  f):.        retu
+000015c0: 726e 2073 656c 660a 0a20 2020 2064 6566  rn self..    def
+000015d0: 205f 5f65 7869 745f 5f28 7365 6c66 2c20   __exit__(self, 
+000015e0: 742c 2076 2c20 7472 6163 6562 6163 6b29  t, v, traceback)
+000015f0: 3a0a 2020 2020 2020 2020 7061 7373 0a0a  :.        pass..
+00001600: 2020 2020 6465 6620 6176 6169 6c61 626c      def availabl
+00001610: 6528 7365 6c66 2c20 6578 6365 7074 696f  e(self, exceptio
+00001620: 6e5f 666c 6167 3d54 7275 6529 3a0a 2020  n_flag=True):.  
+00001630: 2020 2020 2020 2222 2253 6f6c 7665 7220        """Solver 
+00001640: 6973 2061 6c77 6179 7320 6176 6169 6c61  is always availa
+00001650: 626c 652e 2054 686f 7567 6820 7375 6273  ble. Though subs
+00001660: 6f6c 7665 7273 206d 6179 206e 6f74 2062  olvers may not b
+00001670: 652c 2074 6865 7920 7769 6c6c 0a20 2020  e, they will.   
+00001680: 2020 2020 2072 6169 7365 2061 6e20 6572       raise an er
+00001690: 726f 7220 7768 656e 2074 6865 2074 696d  ror when the tim
+000016a0: 6520 636f 6d65 732e 0a20 2020 2020 2020  e comes..       
+000016b0: 2022 2222 0a20 2020 2020 2020 2072 6574   """.        ret
+000016c0: 7572 6e20 5472 7565 0a0a 2020 2020 6465  urn True..    de
+000016d0: 6620 6c69 6365 6e73 655f 6973 5f76 616c  f license_is_val
+000016e0: 6964 2873 656c 6629 3a0a 2020 2020 2020  id(self):.      
+000016f0: 2020 7265 7475 726e 2054 7275 650a 0a20    return True.. 
+00001700: 2020 2064 6566 2076 6572 7369 6f6e 2873     def version(s
+00001710: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
+00001720: 2252 6574 7572 6e20 6120 332d 7475 706c  "Return a 3-tupl
+00001730: 6520 6465 7363 7269 6269 6e67 2074 6865  e describing the
+00001740: 2073 6f6c 7665 7220 7665 7273 696f 6e2e   solver version.
+00001750: 2222 220a 2020 2020 2020 2020 7265 7475  """.        retu
+00001760: 726e 205f 5f76 6572 7369 6f6e 5f5f 0a0a  rn __version__..
+00001770: 2020 2020 5f6d 6574 6173 6f6c 7665 7220      _metasolver 
+00001780: 3d20 4661 6c73 650a 0a20 2020 2064 6566  = False..    def
+00001790: 205f 6c6f 675f 736f 6c76 6572 5f69 6e74   _log_solver_int
+000017a0: 726f 5f6d 6573 7361 6765 2873 656c 6629  ro_message(self)
+000017b0: 3a0a 2020 2020 2020 2020 7365 6c66 2e63  :.        self.c
+000017c0: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
+000017d0: 6f28 0a20 2020 2020 2020 2020 2020 2022  o(.            "
+000017e0: 5374 6172 7469 6e67 204d 696e 6474 5079  Starting MindtPy
+000017f0: 2076 6572 7369 6f6e 2025 7320 7573 696e   version %s usin
+00001800: 6720 2573 2061 6c67 6f72 6974 686d 220a  g %s algorithm".
+00001810: 2020 2020 2020 2020 2020 2020 2520 2822              % ("
+00001820: 2e22 2e6a 6f69 6e28 6d61 7028 7374 722c  .".join(map(str,
+00001830: 2073 656c 662e 7665 7273 696f 6e28 2929   self.version())
+00001840: 292c 2073 656c 662e 636f 6e66 6967 2e73  ), self.config.s
+00001850: 7472 6174 6567 7929 0a20 2020 2020 2020  trategy).       
+00001860: 2029 0a20 2020 2020 2020 206f 7320 3d20   ).        os = 
+00001870: 5374 7269 6e67 494f 2829 0a20 2020 2020  StringIO().     
+00001880: 2020 2073 656c 662e 636f 6e66 6967 2e64     self.config.d
+00001890: 6973 706c 6179 286f 7374 7265 616d 3d6f  isplay(ostream=o
+000018a0: 7329 0a20 2020 2020 2020 2073 656c 662e  s).        self.
+000018b0: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
+000018c0: 666f 286f 732e 6765 7476 616c 7565 2829  fo(os.getvalue()
+000018d0: 290a 2020 2020 2020 2020 7365 6c66 2e63  ).        self.c
+000018e0: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
+000018f0: 6f28 0a20 2020 2020 2020 2020 2020 2027  o(.            '
 00001900: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00001910: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00001920: 2d2d 2d2d 2d5c 6e27 0a20 2020 2020 2020  -----\n'.       
-00001930: 2020 2020 2027 2020 2020 2020 2020 2020       '          
-00001940: 2020 2020 204d 6978 6564 2d49 6e74 6567       Mixed-Integ
-00001950: 6572 204e 6f6e 6c69 6e65 6172 2044 6563  er Nonlinear Dec
-00001960: 6f6d 706f 7369 7469 6f6e 2054 6f6f 6c62  omposition Toolb
-00001970: 6f78 2069 6e20 5079 6f6d 6f20 284d 696e  ox in Pyomo (Min
-00001980: 6474 5079 2920 2020 2020 2020 2020 2020  dtPy)           
-00001990: 2020 2020 205c 6e27 0a20 2020 2020 2020       \n'.       
-000019a0: 2020 2020 2027 2d2d 2d2d 2d2d 2d2d 2d2d       '----------
-000019b0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000019c0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000019d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001920: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001930: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001940: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001950: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d5c  ---------------\
+00001960: 6e27 0a20 2020 2020 2020 2020 2020 2027  n'.            '
+00001970: 2020 2020 2020 2020 2020 2020 2020 204d                 M
+00001980: 6978 6564 2d49 6e74 6567 6572 204e 6f6e  ixed-Integer Non
+00001990: 6c69 6e65 6172 2044 6563 6f6d 706f 7369  linear Decomposi
+000019a0: 7469 6f6e 2054 6f6f 6c62 6f78 2069 6e20  tion Toolbox in 
+000019b0: 5079 6f6d 6f20 284d 696e 6474 5079 2920  Pyomo (MindtPy) 
+000019c0: 2020 2020 2020 2020 2020 2020 2020 205c                 \
+000019d0: 6e27 0a20 2020 2020 2020 2020 2020 2027  n'.            '
 000019e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 000019f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00001a00: 2d2d 2d2d 2d5c 6e27 0a20 2020 2020 2020  -----\n'.       
-00001a10: 2020 2020 2027 466f 7220 6d6f 7265 2069       'For more i
-00001a20: 6e66 6f72 6d61 7469 6f6e 2c20 706c 6561  nformation, plea
-00001a30: 7365 2076 6973 6974 205c 6e27 0a20 2020  se visit \n'.   
-00001a40: 2020 2020 2020 2020 2027 6874 7470 733a           'https:
-00001a50: 2f2f 7079 6f6d 6f2e 7265 6164 7468 6564  //pyomo.readthed
-00001a60: 6f63 732e 696f 2f65 6e2f 7374 6162 6c65  ocs.io/en/stable
-00001a70: 2f63 6f6e 7472 6962 7574 6564 5f70 6163  /contributed_pac
-00001a80: 6b61 6765 732f 6d69 6e64 7470 792e 6874  kages/mindtpy.ht
-00001a90: 6d6c 270a 2020 2020 2020 2020 290a 2020  ml'.        ).  
-00001aa0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
-00001ab0: 672e 6c6f 6767 6572 2e69 6e66 6f28 0a20  g.logger.info(. 
-00001ac0: 2020 2020 2020 2020 2020 2027 4966 2079             'If y
-00001ad0: 6f75 2075 7365 2074 6869 7320 736f 6674  ou use this soft
-00001ae0: 7761 7265 2c20 706c 6561 7365 2063 6974  ware, please cit
-00001af0: 6520 7468 6520 666f 6c6c 6f77 696e 673a  e the following:
-00001b00: 5c6e 270a 2020 2020 2020 2020 2020 2020  \n'.            
-00001b10: 2742 6572 6e61 6c2c 2044 6176 6964 2045  'Bernal, David E
-00001b20: 2e2c 2065 7420 616c 2e20 4d69 7865 642d  ., et al. Mixed-
-00001b30: 696e 7465 6765 7220 6e6f 6e6c 696e 6561  integer nonlinea
-00001b40: 7220 6465 636f 6d70 6f73 6974 696f 6e20  r decomposition 
-00001b50: 746f 6f6c 626f 7820 666f 7220 5079 6f6d  toolbox for Pyom
-00001b60: 6f20 284d 696e 6474 5079 292e 5c6e 270a  o (MindtPy).\n'.
-00001b70: 2020 2020 2020 2020 2020 2020 2743 6f6d              'Com
-00001b80: 7075 7465 7220 4169 6465 6420 4368 656d  puter Aided Chem
-00001b90: 6963 616c 2045 6e67 696e 6565 7269 6e67  ical Engineering
-00001ba0: 2e20 566f 6c2e 2034 342e 2045 6c73 6576  . Vol. 44. Elsev
-00001bb0: 6965 722c 2032 3031 382e 2038 3935 2d39  ier, 2018. 895-9
-00001bc0: 3030 2e5c 6e27 0a20 2020 2020 2020 2029  00.\n'.        )
-00001bd0: 0a0a 2020 2020 6465 6620 7365 745f 7570  ..    def set_up
-00001be0: 5f6c 6f67 6765 7228 7365 6c66 293a 0a20  _logger(self):. 
-00001bf0: 2020 2020 2020 2022 2222 5365 7420 7570         """Set up
-00001c00: 2074 6865 2066 6f72 6d61 7474 6572 2061   the formatter a
-00001c10: 6e64 2068 616e 646c 6572 2066 6f72 206c  nd handler for l
-00001c20: 6f67 6765 722e 2222 220a 2020 2020 2020  ogger.""".      
-00001c30: 2020 7365 6c66 2e63 6f6e 6669 672e 6c6f    self.config.lo
-00001c40: 6767 6572 2e68 616e 646c 6572 732e 636c  gger.handlers.cl
-00001c50: 6561 7228 290a 2020 2020 2020 2020 7365  ear().        se
-00001c60: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
-00001c70: 2e70 726f 7061 6761 7465 203d 2046 616c  .propagate = Fal
-00001c80: 7365 0a20 2020 2020 2020 2063 6820 3d20  se.        ch = 
-00001c90: 6c6f 6767 696e 672e 5374 7265 616d 4861  logging.StreamHa
-00001ca0: 6e64 6c65 7228 290a 2020 2020 2020 2020  ndler().        
-00001cb0: 6368 2e73 6574 4c65 7665 6c28 7365 6c66  ch.setLevel(self
-00001cc0: 2e63 6f6e 6669 672e 6c6f 6767 696e 675f  .config.logging_
-00001cd0: 6c65 7665 6c29 0a20 2020 2020 2020 2023  level).        #
-00001ce0: 2063 7265 6174 6520 666f 726d 6174 7465   create formatte
-00001cf0: 7220 616e 6420 6164 6420 6974 2074 6f20  r and add it to 
-00001d00: 7468 6520 6861 6e64 6c65 7273 0a20 2020  the handlers.   
-00001d10: 2020 2020 2066 6f72 6d61 7474 6572 203d       formatter =
-00001d20: 206c 6f67 6769 6e67 2e46 6f72 6d61 7474   logging.Formatt
-00001d30: 6572 2827 2528 6d65 7373 6167 6529 7327  er('%(message)s'
-00001d40: 290a 2020 2020 2020 2020 6368 2e73 6574  ).        ch.set
-00001d50: 466f 726d 6174 7465 7228 666f 726d 6174  Formatter(format
-00001d60: 7465 7229 0a20 2020 2020 2020 2023 2061  ter).        # a
-00001d70: 6464 2074 6865 2068 616e 646c 6572 7320  dd the handlers 
-00001d80: 746f 206c 6f67 6765 720a 2020 2020 2020  to logger.      
-00001d90: 2020 7365 6c66 2e63 6f6e 6669 672e 6c6f    self.config.lo
-00001da0: 6767 6572 2e61 6464 4861 6e64 6c65 7228  gger.addHandler(
-00001db0: 6368 290a 0a20 2020 2064 6566 205f 6c6f  ch)..    def _lo
-00001dc0: 675f 6865 6164 6572 2873 656c 662c 206c  g_header(self, l
-00001dd0: 6f67 6765 7229 3a0a 2020 2020 2020 2020  ogger):.        
-00001de0: 2320 544f 444f 3a20 7265 7772 6974 650a  # TODO: rewrite.
-00001df0: 2020 2020 2020 2020 6c6f 6767 6572 2e69          logger.i
-00001e00: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
-00001e10: 2027 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   '==============
-00001e20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e50: 3d3d 3d27 0a20 2020 2020 2020 2020 2020  ==='.           
-00001e60: 2027 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   '==============
-00001e70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 270a  =============='.
-00001e80: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00001e90: 2020 6c6f 6767 6572 2e69 6e66 6f28 0a20    logger.info(. 
-00001ea0: 2020 2020 2020 2020 2020 2027 7b3a 5e39             '{:^9
-00001eb0: 7d20 7c20 7b3a 5e31 357d 207c 207b 3a5e  } | {:^15} | {:^
-00001ec0: 3131 7d20 7c20 7b3a 5e31 317d 207c 207b  11} | {:^11} | {
-00001ed0: 3a5e 387d 207c 207b 3a5e 377d 5c6e 272e  :^8} | {:^7}\n'.
-00001ee0: 666f 726d 6174 280a 2020 2020 2020 2020  format(.        
-00001ef0: 2020 2020 2020 2020 2749 7465 7261 7469          'Iterati
-00001f00: 6f6e 272c 0a20 2020 2020 2020 2020 2020  on',.           
-00001f10: 2020 2020 2027 5375 6270 726f 626c 656d       'Subproblem
-00001f20: 2054 7970 6527 2c0a 2020 2020 2020 2020   Type',.        
-00001f30: 2020 2020 2020 2020 274c 6f77 6572 2042          'Lower B
-00001f40: 6f75 6e64 272c 0a20 2020 2020 2020 2020  ound',.         
-00001f50: 2020 2020 2020 2027 5570 7065 7220 426f         'Upper Bo
-00001f60: 756e 6427 2c0a 2020 2020 2020 2020 2020  und',.          
-00001f70: 2020 2020 2020 2720 4761 7020 272c 0a20        ' Gap ',. 
-00001f80: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00001f90: 5469 6d65 2873 2927 2c0a 2020 2020 2020  Time(s)',.      
-00001fa0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00001fb0: 290a 0a20 2020 2064 6566 2063 7265 6174  )..    def creat
-00001fc0: 655f 7574 696c 6974 795f 626c 6f63 6b28  e_utility_block(
-00001fd0: 7365 6c66 2c20 6d6f 6465 6c2c 206e 616d  self, model, nam
-00001fe0: 6529 3a0a 2020 2020 2020 2020 6372 6561  e):.        crea
-00001ff0: 7465 645f 7574 696c 5f62 6c6f 636b 203d  ted_util_block =
-00002000: 2046 616c 7365 0a20 2020 2020 2020 2023   False.        #
-00002010: 2043 7265 6174 6520 6120 6d6f 6465 6c20   Create a model 
-00002020: 626c 6f63 6b20 6f6e 2077 6869 6368 2074  block on which t
-00002030: 6f20 7374 6f72 6520 4d69 6e64 7450 792d  o store MindtPy-
-00002040: 7370 6563 6966 6963 2075 7469 6c69 7479  specific utility
-00002050: 0a20 2020 2020 2020 2023 206d 6f64 656c  .        # model
-00002060: 696e 6720 6f62 6a65 6374 732e 0a20 2020  ing objects..   
-00002070: 2020 2020 2069 6620 6861 7361 7474 7228       if hasattr(
-00002080: 6d6f 6465 6c2c 206e 616d 6529 3a0a 2020  model, name):.  
-00002090: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
-000020a0: 5275 6e74 696d 6545 7272 6f72 280a 2020  RuntimeError(.  
-000020b0: 2020 2020 2020 2020 2020 2020 2020 224d                "M
-000020c0: 696e 6474 5079 206e 6565 6473 2074 6f20  indtPy needs to 
-000020d0: 6372 6561 7465 2061 2042 6c6f 636b 206e  create a Block n
-000020e0: 616d 6564 2025 7320 220a 2020 2020 2020  amed %s ".      
-000020f0: 2020 2020 2020 2020 2020 226f 6e20 7468            "on th
-00002100: 6520 6d6f 6465 6c20 6f62 6a65 6374 2c20  e model object, 
-00002110: 6275 7420 616e 2061 7474 7269 6275 7465  but an attribute
-00002120: 2077 6974 6820 7468 6174 206e 616d 6520   with that name 
-00002130: 220a 2020 2020 2020 2020 2020 2020 2020  ".              
-00002140: 2020 2261 6c72 6561 6479 2065 7869 7374    "already exist
-00002150: 732e 2220 2520 6e61 6d65 0a20 2020 2020  s." % name.     
-00002160: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00002170: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00002180: 2020 2063 7265 6174 6564 5f75 7469 6c5f     created_util_
-00002190: 626c 6f63 6b20 3d20 5472 7565 0a20 2020  block = True.   
-000021a0: 2020 2020 2020 2020 2073 6574 6174 7472           setattr
-000021b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000021c0: 2020 6d6f 6465 6c2c 0a20 2020 2020 2020    model,.       
-000021d0: 2020 2020 2020 2020 206e 616d 652c 0a20           name,. 
-000021e0: 2020 2020 2020 2020 2020 2020 2020 2042                 B
-000021f0: 6c6f 636b 2864 6f63 3d22 436f 6e74 6169  lock(doc="Contai
-00002200: 6e65 7220 666f 7220 4d69 6e64 7450 7920  ner for MindtPy 
-00002210: 736f 6c76 6572 2075 7469 6c69 7479 206d  solver utility m
-00002220: 6f64 656c 696e 6720 6f62 6a65 6374 7322  odeling objects"
-00002230: 292c 0a20 2020 2020 2020 2020 2020 2029  ),.            )
-00002240: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00002250: 662e 7574 696c 5f62 6c6f 636b 5f6e 616d  f.util_block_nam
-00002260: 6520 3d20 6e61 6d65 0a0a 2020 2020 2020  e = name..      
-00002270: 2020 2020 2020 2320 5361 7665 206f 7264        # Save ord
-00002280: 6572 6564 206c 6973 7473 206f 6620 6d61  ered lists of ma
-00002290: 696e 206d 6f64 656c 696e 6720 636f 6d70  in modeling comp
-000022a0: 6f6e 656e 7473 2c20 736f 2074 6861 7420  onents, so that 
-000022b0: 6461 7461 2063 616e 0a20 2020 2020 2020  data can.       
-000022c0: 2020 2020 2023 2062 6520 6561 7369 6c79       # be easily
-000022d0: 2074 7261 6e73 6665 7272 6564 2062 6574   transferred bet
-000022e0: 7765 656e 2066 7574 7572 6520 6d6f 6465  ween future mode
-000022f0: 6c20 636c 6f6e 6573 2e0a 2020 2020 2020  l clones..      
-00002300: 2020 2020 2020 7365 6c66 2e62 7569 6c64        self.build
-00002310: 5f6f 7264 6572 6564 5f63 6f6d 706f 6e65  _ordered_compone
-00002320: 6e74 5f6c 6973 7473 286d 6f64 656c 290a  nt_lists(model).
-00002330: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00002340: 2e61 6464 5f63 7574 735f 636f 6d70 6f6e  .add_cuts_compon
-00002350: 656e 7473 286d 6f64 656c 290a 0a20 2020  ents(model)..   
-00002360: 2064 6566 206d 6f64 656c 5f69 735f 7661   def model_is_va
-00002370: 6c69 6428 7365 6c66 293a 0a20 2020 2020  lid(self):.     
-00002380: 2020 2022 2222 4465 7465 726d 696e 6573     """Determines
-00002390: 2077 6865 7468 6572 2074 6865 206d 6f64   whether the mod
-000023a0: 656c 2069 7320 736f 6c76 6162 6c65 2062  el is solvable b
-000023b0: 7920 4d69 6e64 7450 792e 0a0a 2020 2020  y MindtPy...    
-000023c0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-000023d0: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-000023e0: 2020 2020 626f 6f6c 0a20 2020 2020 2020      bool.       
-000023f0: 2020 2020 2054 7275 6520 6966 206d 6f64       True if mod
-00002400: 656c 2069 7320 736f 6c76 6162 6c65 2069  el is solvable i
-00002410: 6e20 4d69 6e64 7450 792c 2046 616c 7365  n MindtPy, False
-00002420: 206f 7468 6572 7769 7365 2e0a 2020 2020   otherwise..    
-00002430: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00002440: 6d20 3d20 7365 6c66 2e77 6f72 6b69 6e67  m = self.working
-00002450: 5f6d 6f64 656c 0a20 2020 2020 2020 204d  _model.        M
-00002460: 696e 6474 5079 203d 206d 2e4d 696e 6474  indtPy = m.Mindt
-00002470: 5079 5f75 7469 6c73 0a20 2020 2020 2020  Py_utils.       
-00002480: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
-00002490: 6f6e 6669 670a 0a20 2020 2020 2020 2023  onfig..        #
-000024a0: 2048 616e 646c 6520 4c50 2f4e 4c50 2062   Handle LP/NLP b
-000024b0: 6569 6e67 2070 6173 7365 6420 746f 2074  eing passed to t
-000024c0: 6865 2073 6f6c 7665 720a 2020 2020 2020  he solver.      
-000024d0: 2020 7072 6f62 203d 2073 656c 662e 7265    prob = self.re
-000024e0: 7375 6c74 732e 7072 6f62 6c65 6d0a 2020  sults.problem.  
-000024f0: 2020 2020 2020 6966 206c 656e 284d 696e        if len(Min
-00002500: 6474 5079 2e64 6973 6372 6574 655f 7661  dtPy.discrete_va
-00002510: 7269 6162 6c65 5f6c 6973 7429 203d 3d20  riable_list) == 
-00002520: 303a 0a20 2020 2020 2020 2020 2020 2063  0:.            c
-00002530: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
-00002540: 6f28 2750 726f 626c 656d 2068 6173 206e  o('Problem has n
-00002550: 6f20 6469 7363 7265 7465 2064 6563 6973  o discrete decis
-00002560: 696f 6e73 2e27 290a 2020 2020 2020 2020  ions.').        
-00002570: 2020 2020 6f62 6a20 3d20 6e65 7874 286d      obj = next(m
-00002580: 2e63 6f6d 706f 6e65 6e74 5f64 6174 615f  .component_data_
-00002590: 6f62 6a65 6374 7328 6374 7970 653d 4f62  objects(ctype=Ob
-000025a0: 6a65 6374 6976 652c 2061 6374 6976 653d  jective, active=
-000025b0: 5472 7565 2929 0a20 2020 2020 2020 2020  True)).         
-000025c0: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
-000025d0: 2020 2020 2020 2020 616e 7928 0a20 2020          any(.   
-000025e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000025f0: 2063 2e62 6f64 792e 706f 6c79 6e6f 6d69   c.body.polynomi
-00002600: 616c 5f64 6567 7265 6528 290a 2020 2020  al_degree().    
-00002610: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002620: 6e6f 7420 696e 2073 656c 662e 6d69 705f  not in self.mip_
-00002630: 636f 6e73 7472 6169 6e74 5f70 6f6c 796e  constraint_polyn
-00002640: 6f6d 6961 6c5f 6465 6772 6565 0a20 2020  omial_degree.   
-00002650: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002660: 2066 6f72 2063 2069 6e20 4d69 6e64 7450   for c in MindtP
-00002670: 792e 636f 6e73 7472 6169 6e74 5f6c 6973  y.constraint_lis
-00002680: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00002690: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-000026a0: 2020 2020 6f72 206f 626a 2e65 7870 722e      or obj.expr.
-000026b0: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
-000026c0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-000026d0: 2020 2020 6e6f 7420 696e 2073 656c 662e      not in self.
-000026e0: 6d69 705f 6f62 6a65 6374 6976 655f 706f  mip_objective_po
-000026f0: 6c79 6e6f 6d69 616c 5f64 6567 7265 650a  lynomial_degree.
-00002700: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
-00002710: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00002720: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
-00002730: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
-00002740: 2020 2020 2020 2027 596f 7572 206d 6f64         'Your mod
-00002750: 656c 2069 7320 6120 4e4c 5020 286e 6f6e  el is a NLP (non
-00002760: 6c69 6e65 6172 2070 726f 6772 616d 292e  linear program).
-00002770: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
-00002780: 2020 2020 2020 2027 5573 696e 6720 4e4c         'Using NL
-00002790: 5020 736f 6c76 6572 2025 7320 746f 2073  P solver %s to s
-000027a0: 6f6c 7665 2e27 2025 2063 6f6e 6669 672e  olve.' % config.
-000027b0: 6e6c 705f 736f 6c76 6572 0a20 2020 2020  nlp_solver.     
-000027c0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-000027d0: 2020 2020 2020 2020 2020 2020 2075 7064               upd
-000027e0: 6174 655f 736f 6c76 6572 5f74 696d 656c  ate_solver_timel
-000027f0: 696d 6974 280a 2020 2020 2020 2020 2020  imit(.          
-00002800: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
-00002810: 6c70 5f6f 7074 2c20 636f 6e66 6967 2e6e  lp_opt, config.n
-00002820: 6c70 5f73 6f6c 7665 722c 2073 656c 662e  lp_solver, self.
-00002830: 7469 6d69 6e67 2c20 636f 6e66 6967 0a20  timing, config. 
-00002840: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00002850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002860: 2073 656c 662e 6e6c 705f 6f70 742e 736f   self.nlp_opt.so
-00002870: 6c76 6528 0a20 2020 2020 2020 2020 2020  lve(.           
-00002880: 2020 2020 2020 2020 2073 656c 662e 6f72           self.or
-00002890: 6967 696e 616c 5f6d 6f64 656c 2c0a 2020  iginal_model,.  
-000028a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028b0: 2020 7465 653d 636f 6e66 6967 2e6e 6c70    tee=config.nlp
-000028c0: 5f73 6f6c 7665 725f 7465 652c 0a20 2020  _solver_tee,.   
-000028d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000028e0: 202a 2a63 6f6e 6669 672e 6e6c 705f 736f   **config.nlp_so
-000028f0: 6c76 6572 5f61 7267 732c 0a20 2020 2020  lver_args,.     
-00002900: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00002910: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00002920: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
-00002930: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00002940: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-00002950: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-00002960: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002970: 2020 2020 2759 6f75 7220 6d6f 6465 6c20      'Your model 
-00002980: 6973 2061 6e20 4c50 2028 6c69 6e65 6172  is an LP (linear
-00002990: 2070 726f 6772 616d 292e 2027 0a20 2020   program). '.   
-000029a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000029b0: 2027 5573 696e 6720 4c50 2073 6f6c 7665   'Using LP solve
-000029c0: 7220 2573 2074 6f20 736f 6c76 652e 2720  r %s to solve.' 
-000029d0: 2520 636f 6e66 6967 2e6d 6970 5f73 6f6c  % config.mip_sol
-000029e0: 7665 720a 2020 2020 2020 2020 2020 2020  ver.            
-000029f0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-00002a00: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
-00002a10: 6e63 6528 7365 6c66 2e6d 6970 5f6f 7074  nce(self.mip_opt
-00002a20: 2c20 5065 7273 6973 7465 6e74 536f 6c76  , PersistentSolv
-00002a30: 6572 293a 0a20 2020 2020 2020 2020 2020  er):.           
-00002a40: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-00002a50: 705f 6f70 742e 7365 745f 696e 7374 616e  p_opt.set_instan
-00002a60: 6365 2873 656c 662e 6f72 6967 696e 616c  ce(self.original
-00002a70: 5f6d 6f64 656c 290a 2020 2020 2020 2020  _model).        
-00002a80: 2020 2020 2020 2020 7570 6461 7465 5f73          update_s
-00002a90: 6f6c 7665 725f 7469 6d65 6c69 6d69 7428  olver_timelimit(
-00002aa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00002ab0: 2020 2020 2073 656c 662e 6d69 705f 6f70       self.mip_op
-00002ac0: 742c 2063 6f6e 6669 672e 6d69 705f 736f  t, config.mip_so
-00002ad0: 6c76 6572 2c20 7365 6c66 2e74 696d 696e  lver, self.timin
-00002ae0: 672c 2063 6f6e 6669 670a 2020 2020 2020  g, config.      
-00002af0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00002b00: 2020 2020 2020 2020 2020 2020 7265 7375              resu
-00002b10: 6c74 7320 3d20 7365 6c66 2e6d 6970 5f6f  lts = self.mip_o
-00002b20: 7074 2e73 6f6c 7665 280a 2020 2020 2020  pt.solve(.      
-00002b30: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00002b40: 6c66 2e6f 7269 6769 6e61 6c5f 6d6f 6465  lf.original_mode
-00002b50: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
-00002b60: 2020 2020 2020 2074 6565 3d63 6f6e 6669         tee=confi
-00002b70: 672e 6d69 705f 736f 6c76 6572 5f74 6565  g.mip_solver_tee
-00002b80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00002b90: 2020 2020 2020 6c6f 6164 5f73 6f6c 7574        load_solut
-00002ba0: 696f 6e73 3d73 656c 662e 6c6f 6164 5f73  ions=self.load_s
-00002bb0: 6f6c 7574 696f 6e73 2c0a 2020 2020 2020  olutions,.      
-00002bc0: 2020 2020 2020 2020 2020 2020 2020 2a2a                **
-00002bd0: 636f 6e66 6967 2e6d 6970 5f73 6f6c 7665  config.mip_solve
-00002be0: 725f 6172 6773 2c0a 2020 2020 2020 2020  r_args,.        
-00002bf0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00002c00: 2020 2020 2020 2020 2020 6966 206c 656e            if len
-00002c10: 2872 6573 756c 7473 2e73 6f6c 7574 696f  (results.solutio
-00002c20: 6e29 203e 2030 3a0a 2020 2020 2020 2020  n) > 0:.        
-00002c30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00002c40: 2e6f 7269 6769 6e61 6c5f 6d6f 6465 6c2e  .original_model.
-00002c50: 736f 6c75 7469 6f6e 732e 6c6f 6164 5f66  solutions.load_f
-00002c60: 726f 6d28 7265 7375 6c74 7329 0a20 2020  rom(results).   
-00002c70: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00002c80: 7572 6e20 4661 6c73 650a 0a20 2020 2020  urn False..     
-00002c90: 2020 2023 2053 6574 2075 7020 6475 616c     # Set up dual
-00002ca0: 2076 616c 7565 2072 6570 6f72 7469 6e67   value reporting
-00002cb0: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
-00002cc0: 6967 2e63 616c 6375 6c61 7465 5f64 7561  ig.calculate_dua
-00002cd0: 6c5f 6174 5f73 6f6c 7574 696f 6e3a 0a20  l_at_solution:. 
-00002ce0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-00002cf0: 7420 6861 7361 7474 7228 6d2c 2027 6475  t hasattr(m, 'du
-00002d00: 616c 2729 3a0a 2020 2020 2020 2020 2020  al'):.          
-00002d10: 2020 2020 2020 6d2e 6475 616c 203d 2053        m.dual = S
-00002d20: 7566 6669 7828 6469 7265 6374 696f 6e3d  uffix(direction=
-00002d30: 5375 6666 6978 2e49 4d50 4f52 5429 0a20  Suffix.IMPORT). 
-00002d40: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
-00002d50: 6e6f 7420 6973 696e 7374 616e 6365 286d  not isinstance(m
-00002d60: 2e64 7561 6c2c 2053 7566 6669 7829 3a0a  .dual, Suffix):.
-00002d70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00002d80: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-00002d90: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00002da0: 2020 2020 2020 2264 7561 6c20 6973 206e        "dual is n
-00002db0: 6f74 2064 6566 696e 6564 2061 7320 6120  ot defined as a 
-00002dc0: 5375 6666 6978 2069 6e20 7468 6520 6f72  Suffix in the or
-00002dd0: 6967 696e 616c 206d 6f64 656c 2e22 0a20  iginal model.". 
-00002de0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00002df0: 0a0a 2020 2020 2020 2020 2320 544f 444f  ..        # TODO
-00002e00: 2069 6620 616e 7920 636f 6e74 696e 756f   if any continuo
-00002e10: 7573 2076 6172 6961 626c 6573 2061 7265  us variables are
-00002e20: 206d 756c 7469 706c 6965 6420 7769 7468   multiplied with
-00002e30: 2062 696e 6172 7920 6f6e 6573 2c0a 2020   binary ones,.  
-00002e40: 2020 2020 2020 2320 206e 6565 6420 746f        #  need to
-00002e50: 2064 6f20 736f 6d65 206b 696e 6420 6f66   do some kind of
-00002e60: 2074 7261 6e73 666f 726d 6174 696f 6e20   transformation 
-00002e70: 2847 6c6f 7665 723f 2920 6f72 2074 6872  (Glover?) or thr
-00002e80: 6f77 2061 6e20 6572 726f 7220 6d65 7373  ow an error mess
-00002e90: 6167 650a 2020 2020 2020 2020 7265 7475  age.        retu
-00002ea0: 726e 2054 7275 650a 0a20 2020 2064 6566  rn True..    def
-00002eb0: 2062 7569 6c64 5f6f 7264 6572 6564 5f63   build_ordered_c
-00002ec0: 6f6d 706f 6e65 6e74 5f6c 6973 7473 2873  omponent_lists(s
-00002ed0: 656c 662c 206d 6f64 656c 293a 0a20 2020  elf, model):.   
-00002ee0: 2020 2020 2022 2222 4465 6669 6e65 206c       """Define l
-00002ef0: 6973 7473 2075 7365 6420 666f 7220 6675  ists used for fu
-00002f00: 7475 7265 2064 6174 6120 7472 616e 7366  ture data transf
-00002f10: 6572 2e0a 0a20 2020 2020 2020 2041 6c73  er...        Als
-00002f20: 6f20 6174 7461 6368 6573 206f 7264 6572  o attaches order
-00002f30: 6564 206c 6973 7473 206f 6620 7468 6520  ed lists of the 
-00002f40: 7661 7269 6162 6c65 732c 2063 6f6e 7374  variables, const
-00002f50: 7261 696e 7473 2074 6f20 7468 6520 6d6f  raints to the mo
-00002f60: 6465 6c20 736f 2074 6861 7420 7468 6579  del so that they
-00002f70: 2063 616e 2062 6520 7573 6564 2066 6f72   can be used for
-00002f80: 206d 6170 7069 6e67 2062 6163 6b20 616e   mapping back an
-00002f90: 640a 2020 2020 2020 2020 666f 7274 682e  d.        forth.
-00002fa0: 0a0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00002fb0: 2020 2020 2020 7574 696c 5f62 6c6f 636b        util_block
-00002fc0: 203d 2067 6574 6174 7472 286d 6f64 656c   = getattr(model
-00002fd0: 2c20 7365 6c66 2e75 7469 6c5f 626c 6f63  , self.util_bloc
-00002fe0: 6b5f 6e61 6d65 290a 2020 2020 2020 2020  k_name).        
-00002ff0: 7661 725f 7365 7420 3d20 436f 6d70 6f6e  var_set = Compon
-00003000: 656e 7453 6574 2829 0a20 2020 2020 2020  entSet().       
-00003010: 2075 7469 6c5f 626c 6f63 6b2e 636f 6e73   util_block.cons
-00003020: 7472 6169 6e74 5f6c 6973 7420 3d20 6c69  traint_list = li
-00003030: 7374 280a 2020 2020 2020 2020 2020 2020  st(.            
-00003040: 6d6f 6465 6c2e 636f 6d70 6f6e 656e 745f  model.component_
-00003050: 6461 7461 5f6f 626a 6563 7473 280a 2020  data_objects(.  
-00003060: 2020 2020 2020 2020 2020 2020 2020 6374                ct
-00003070: 7970 653d 436f 6e73 7472 6169 6e74 2c20  ype=Constraint, 
-00003080: 6163 7469 7665 3d54 7275 652c 2064 6573  active=True, des
-00003090: 6365 6e64 5f69 6e74 6f3d 2842 6c6f 636b  cend_into=(Block
-000030a0: 290a 2020 2020 2020 2020 2020 2020 290a  ).            ).
-000030b0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000030c0: 2020 6966 2065 6762 5f61 7661 696c 6162    if egb_availab
-000030d0: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
-000030e0: 7574 696c 5f62 6c6f 636b 2e67 7265 795f  util_block.grey_
-000030f0: 626f 785f 6c69 7374 203d 206c 6973 7428  box_list = list(
-00003100: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003110: 206d 6f64 656c 2e63 6f6d 706f 6e65 6e74   model.component
-00003120: 5f64 6174 615f 6f62 6a65 6374 7328 0a20  _data_objects(. 
-00003130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00003140: 2020 2063 7479 7065 3d65 6762 2e45 7874     ctype=egb.Ext
-00003150: 6572 6e61 6c47 7265 7942 6f78 426c 6f63  ernalGreyBoxBloc
-00003160: 6b2c 2061 6374 6976 653d 5472 7565 2c20  k, active=True, 
-00003170: 6465 7363 656e 645f 696e 746f 3d28 426c  descend_into=(Bl
-00003180: 6f63 6b29 0a20 2020 2020 2020 2020 2020  ock).           
-00003190: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-000031a0: 2020 2029 0a20 2020 2020 2020 2065 6c73     ).        els
-000031b0: 653a 0a20 2020 2020 2020 2020 2020 2075  e:.            u
-000031c0: 7469 6c5f 626c 6f63 6b2e 6772 6579 5f62  til_block.grey_b
-000031d0: 6f78 5f6c 6973 7420 3d20 5b5d 0a20 2020  ox_list = [].   
-000031e0: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
-000031f0: 6c69 6e65 6172 5f63 6f6e 7374 7261 696e  linear_constrain
-00003200: 745f 6c69 7374 203d 206c 6973 7428 0a20  t_list = list(. 
-00003210: 2020 2020 2020 2020 2020 2063 0a20 2020             c.   
-00003220: 2020 2020 2020 2020 2066 6f72 2063 2069           for c i
-00003230: 6e20 7574 696c 5f62 6c6f 636b 2e63 6f6e  n util_block.con
-00003240: 7374 7261 696e 745f 6c69 7374 0a20 2020  straint_list.   
-00003250: 2020 2020 2020 2020 2069 6620 632e 626f           if c.bo
-00003260: 6479 2e70 6f6c 796e 6f6d 6961 6c5f 6465  dy.polynomial_de
-00003270: 6772 6565 2829 2069 6e20 7365 6c66 2e6d  gree() in self.m
-00003280: 6970 5f63 6f6e 7374 7261 696e 745f 706f  ip_constraint_po
-00003290: 6c79 6e6f 6d69 616c 5f64 6567 7265 650a  lynomial_degree.
-000032a0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000032b0: 2020 7574 696c 5f62 6c6f 636b 2e6e 6f6e    util_block.non
-000032c0: 6c69 6e65 6172 5f63 6f6e 7374 7261 696e  linear_constrain
-000032d0: 745f 6c69 7374 203d 206c 6973 7428 0a20  t_list = list(. 
-000032e0: 2020 2020 2020 2020 2020 2063 0a20 2020             c.   
-000032f0: 2020 2020 2020 2020 2066 6f72 2063 2069           for c i
-00003300: 6e20 7574 696c 5f62 6c6f 636b 2e63 6f6e  n util_block.con
-00003310: 7374 7261 696e 745f 6c69 7374 0a20 2020  straint_list.   
-00003320: 2020 2020 2020 2020 2069 6620 632e 626f           if c.bo
-00003330: 6479 2e70 6f6c 796e 6f6d 6961 6c5f 6465  dy.polynomial_de
-00003340: 6772 6565 2829 206e 6f74 2069 6e20 7365  gree() not in se
-00003350: 6c66 2e6d 6970 5f63 6f6e 7374 7261 696e  lf.mip_constrain
-00003360: 745f 706f 6c79 6e6f 6d69 616c 5f64 6567  t_polynomial_deg
-00003370: 7265 650a 2020 2020 2020 2020 290a 2020  ree.        ).  
-00003380: 2020 2020 2020 7574 696c 5f62 6c6f 636b        util_block
-00003390: 2e6f 626a 6563 7469 7665 5f6c 6973 7420  .objective_list 
-000033a0: 3d20 6c69 7374 280a 2020 2020 2020 2020  = list(.        
-000033b0: 2020 2020 6d6f 6465 6c2e 636f 6d70 6f6e      model.compon
-000033c0: 656e 745f 6461 7461 5f6f 626a 6563 7473  ent_data_objects
-000033d0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000033e0: 2020 6374 7970 653d 4f62 6a65 6374 6976    ctype=Objectiv
-000033f0: 652c 2061 6374 6976 653d 5472 7565 2c20  e, active=True, 
-00003400: 6465 7363 656e 645f 696e 746f 3d28 426c  descend_into=(Bl
-00003410: 6f63 6b29 0a20 2020 2020 2020 2020 2020  ock).           
-00003420: 2029 0a20 2020 2020 2020 2029 0a0a 2020   ).        )..  
-00003430: 2020 2020 2020 2320 4964 656e 7469 6679        # Identify
-00003440: 2074 6865 206e 6f6e 2d66 6978 6564 2076   the non-fixed v
-00003450: 6172 6961 626c 6573 2069 6e20 2870 6f74  ariables in (pot
-00003460: 656e 7469 616c 6c79 2920 6163 7469 7665  entially) active
-00003470: 2063 6f6e 7374 7261 696e 7473 2061 6e64   constraints and
-00003480: 0a20 2020 2020 2020 2023 206f 626a 6563  .        # objec
-00003490: 7469 7665 2066 756e 6374 696f 6e73 0a20  tive functions. 
-000034a0: 2020 2020 2020 2066 6f72 2063 6f6e 7374         for const
-000034b0: 7220 696e 2067 6574 6174 7472 2875 7469  r in getattr(uti
-000034c0: 6c5f 626c 6f63 6b2c 2027 636f 6e73 7472  l_block, 'constr
-000034d0: 6169 6e74 5f6c 6973 7427 293a 0a20 2020  aint_list'):.   
-000034e0: 2020 2020 2020 2020 2066 6f72 2076 2069           for v i
-000034f0: 6e20 4558 5052 2e69 6465 6e74 6966 795f  n EXPR.identify_
-00003500: 7661 7269 6162 6c65 7328 636f 6e73 7472  variables(constr
-00003510: 2e62 6f64 792c 2069 6e63 6c75 6465 5f66  .body, include_f
-00003520: 6978 6564 3d46 616c 7365 293a 0a20 2020  ixed=False):.   
-00003530: 2020 2020 2020 2020 2020 2020 2076 6172               var
-00003540: 5f73 6574 2e61 6464 2876 290a 2020 2020  _set.add(v).    
-00003550: 2020 2020 666f 7220 6f62 6a20 696e 206d      for obj in m
-00003560: 6f64 656c 2e63 6f6d 706f 6e65 6e74 5f64  odel.component_d
-00003570: 6174 615f 6f62 6a65 6374 7328 6374 7970  ata_objects(ctyp
-00003580: 653d 4f62 6a65 6374 6976 652c 2061 6374  e=Objective, act
-00003590: 6976 653d 5472 7565 293a 0a20 2020 2020  ive=True):.     
-000035a0: 2020 2020 2020 2066 6f72 2076 2069 6e20         for v in 
-000035b0: 4558 5052 2e69 6465 6e74 6966 795f 7661  EXPR.identify_va
-000035c0: 7269 6162 6c65 7328 6f62 6a2e 6578 7072  riables(obj.expr
-000035d0: 2c20 696e 636c 7564 655f 6669 7865 643d  , include_fixed=
-000035e0: 4661 6c73 6529 3a0a 2020 2020 2020 2020  False):.        
-000035f0: 2020 2020 2020 2020 7661 725f 7365 742e          var_set.
-00003600: 6164 6428 7629 0a0a 2020 2020 2020 2020  add(v)..        
-00003610: 2320 5765 2075 7365 2063 6f6d 706f 6e65  # We use compone
-00003620: 6e74 5f64 6174 615f 6f62 6a65 6374 7320  nt_data_objects 
-00003630: 7261 7468 6572 2074 6861 6e20 6c69 7374  rather than list
-00003640: 2876 6172 5f73 6574 2920 696e 206f 7264  (var_set) in ord
-00003650: 6572 2074 6f0a 2020 2020 2020 2020 2320  er to.        # 
-00003660: 7072 6573 6572 7665 2061 2064 6574 6572  preserve a deter
-00003670: 6d69 6e69 7374 6963 206f 7264 6572 696e  ministic orderin
-00003680: 672e 0a20 2020 2020 2020 2069 6620 6567  g..        if eg
-00003690: 625f 6176 6169 6c61 626c 653a 0a20 2020  b_available:.   
-000036a0: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
-000036b0: 6f63 6b2e 7661 7269 6162 6c65 5f6c 6973  ock.variable_lis
-000036c0: 7420 3d20 6c69 7374 280a 2020 2020 2020  t = list(.      
-000036d0: 2020 2020 2020 2020 2020 760a 2020 2020            v.    
-000036e0: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-000036f0: 7620 696e 206d 6f64 656c 2e63 6f6d 706f  v in model.compo
-00003700: 6e65 6e74 5f64 6174 615f 6f62 6a65 6374  nent_data_object
-00003710: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
-00003720: 2020 2020 2020 2063 7479 7065 3d56 6172         ctype=Var
-00003730: 2c20 6465 7363 656e 645f 696e 746f 3d28  , descend_into=(
-00003740: 426c 6f63 6b2c 2065 6762 2e45 7874 6572  Block, egb.Exter
-00003750: 6e61 6c47 7265 7942 6f78 426c 6f63 6b29  nalGreyBoxBlock)
-00003760: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00003770: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
-00003780: 2020 2069 6620 7620 696e 2076 6172 5f73     if v in var_s
-00003790: 6574 0a20 2020 2020 2020 2020 2020 2029  et.            )
-000037a0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-000037b0: 2020 2020 2020 2020 2020 2075 7469 6c5f             util_
-000037c0: 626c 6f63 6b2e 7661 7269 6162 6c65 5f6c  block.variable_l
-000037d0: 6973 7420 3d20 6c69 7374 280a 2020 2020  ist = list(.    
-000037e0: 2020 2020 2020 2020 2020 2020 760a 2020              v.  
-000037f0: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00003800: 7220 7620 696e 206d 6f64 656c 2e63 6f6d  r v in model.com
-00003810: 706f 6e65 6e74 5f64 6174 615f 6f62 6a65  ponent_data_obje
-00003820: 6374 7328 6374 7970 653d 5661 722c 2064  cts(ctype=Var, d
-00003830: 6573 6365 6e64 5f69 6e74 6f3d 2842 6c6f  escend_into=(Blo
-00003840: 636b 2929 0a20 2020 2020 2020 2020 2020  ck)).           
-00003850: 2020 2020 2069 6620 7620 696e 2076 6172       if v in var
-00003860: 5f73 6574 0a20 2020 2020 2020 2020 2020  _set.           
-00003870: 2029 0a20 2020 2020 2020 2075 7469 6c5f   ).        util_
-00003880: 626c 6f63 6b2e 6469 7363 7265 7465 5f76  block.discrete_v
-00003890: 6172 6961 626c 655f 6c69 7374 203d 206c  ariable_list = l
-000038a0: 6973 7428 0a20 2020 2020 2020 2020 2020  ist(.           
-000038b0: 2076 2066 6f72 2076 2069 6e20 7574 696c   v for v in util
-000038c0: 5f62 6c6f 636b 2e76 6172 6961 626c 655f  _block.variable_
-000038d0: 6c69 7374 2069 6620 7620 696e 2076 6172  list if v in var
-000038e0: 5f73 6574 2061 6e64 2076 2e69 735f 696e  _set and v.is_in
-000038f0: 7465 6765 7228 290a 2020 2020 2020 2020  teger().        
-00003900: 290a 2020 2020 2020 2020 7574 696c 5f62  ).        util_b
-00003910: 6c6f 636b 2e63 6f6e 7469 6e75 6f75 735f  lock.continuous_
-00003920: 7661 7269 6162 6c65 5f6c 6973 7420 3d20  variable_list = 
-00003930: 6c69 7374 280a 2020 2020 2020 2020 2020  list(.          
-00003940: 2020 7620 666f 7220 7620 696e 2075 7469    v for v in uti
-00003950: 6c5f 626c 6f63 6b2e 7661 7269 6162 6c65  l_block.variable
-00003960: 5f6c 6973 7420 6966 2076 2069 6e20 7661  _list if v in va
-00003970: 725f 7365 7420 616e 6420 762e 6973 5f63  r_set and v.is_c
-00003980: 6f6e 7469 6e75 6f75 7328 290a 2020 2020  ontinuous().    
-00003990: 2020 2020 290a 0a20 2020 2064 6566 2061      )..    def a
-000039a0: 6464 5f63 7574 735f 636f 6d70 6f6e 656e  dd_cuts_componen
-000039b0: 7473 2873 656c 662c 206d 6f64 656c 293a  ts(self, model):
-000039c0: 0a20 2020 2020 2020 2063 6f6e 6669 6720  .        config 
-000039d0: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-000039e0: 2020 2020 2020 4d69 6e64 7450 7920 3d20        MindtPy = 
-000039f0: 6d6f 6465 6c2e 4d69 6e64 7450 795f 7574  model.MindtPy_ut
-00003a00: 696c 730a 0a20 2020 2020 2020 2023 2043  ils..        # C
-00003a10: 7265 6174 6520 6120 6d6f 6465 6c20 626c  reate a model bl
-00003a20: 6f63 6b20 696e 2077 6869 6368 2074 6f20  ock in which to 
-00003a30: 7374 6f72 6520 7468 6520 6765 6e65 7261  store the genera
-00003a40: 7465 6420 6665 6173 6962 696c 6974 790a  ted feasibility.
-00003a50: 2020 2020 2020 2020 2320 736c 6163 6b20          # slack 
-00003a60: 636f 6e73 7472 6169 6e74 732e 2044 6f20  constraints. Do 
-00003a70: 6e6f 7420 6c65 6176 6520 7468 6520 636f  not leave the co
-00003a80: 6e73 7472 6169 6e74 7320 6f6e 2062 7920  nstraints on by 
-00003a90: 6465 6661 756c 742e 0a20 2020 2020 2020  default..       
-00003aa0: 2066 6561 7320 3d20 4d69 6e64 7450 792e   feas = MindtPy.
-00003ab0: 6665 6173 5f6f 7074 203d 2042 6c6f 636b  feas_opt = Block
-00003ac0: 2829 0a20 2020 2020 2020 2066 6561 732e  ().        feas.
-00003ad0: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
-00003ae0: 2020 2020 2066 6561 732e 6665 6173 5f63       feas.feas_c
-00003af0: 6f6e 7374 7261 696e 7473 203d 2043 6f6e  onstraints = Con
-00003b00: 7374 7261 696e 744c 6973 7428 646f 633d  straintList(doc=
-00003b10: 2746 6561 7369 6269 6c69 7479 2050 726f  'Feasibility Pro
-00003b20: 626c 656d 2043 6f6e 7374 7261 696e 7473  blem Constraints
-00003b30: 2729 0a0a 2020 2020 2020 2020 2320 4372  ')..        # Cr
-00003b40: 6561 7465 2061 206d 6f64 656c 2062 6c6f  eate a model blo
-00003b50: 636b 2069 6e20 7768 6963 6820 746f 2073  ck in which to s
-00003b60: 746f 7265 2074 6865 2067 656e 6572 6174  tore the generat
-00003b70: 6564 206c 696e 6561 720a 2020 2020 2020  ed linear.      
-00003b80: 2020 2320 636f 6e73 7472 6169 6e74 732e    # constraints.
-00003b90: 2044 6f20 6e6f 7420 6c65 6176 6520 7468   Do not leave th
-00003ba0: 6520 636f 6e73 7472 6169 6e74 7320 6f6e  e constraints on
-00003bb0: 2062 7920 6465 6661 756c 742e 0a20 2020   by default..   
-00003bc0: 2020 2020 206c 696e 203d 204d 696e 6474       lin = Mindt
-00003bd0: 5079 2e63 7574 7320 3d20 426c 6f63 6b28  Py.cuts = Block(
-00003be0: 290a 2020 2020 2020 2020 6c69 6e2e 6465  ).        lin.de
-00003bf0: 6163 7469 7661 7465 2829 0a0a 2020 2020  activate()..    
-00003c00: 2020 2020 2320 6e6f 2d67 6f6f 6420 6375      # no-good cu
-00003c10: 7473 2065 7863 6c75 6465 2070 6172 7469  ts exclude parti
-00003c20: 6375 6c61 7220 6469 7363 7265 7465 2064  cular discrete d
-00003c30: 6563 6973 696f 6e73 0a20 2020 2020 2020  ecisions.       
-00003c40: 206c 696e 2e6e 6f5f 676f 6f64 5f63 7574   lin.no_good_cut
-00003c50: 7320 3d20 436f 6e73 7472 6169 6e74 4c69  s = ConstraintLi
-00003c60: 7374 2864 6f63 3d27 6e6f 2d67 6f6f 6420  st(doc='no-good 
-00003c70: 6375 7473 2729 0a20 2020 2020 2020 2023  cuts').        #
-00003c80: 2046 6561 7369 626c 6520 6e6f 2d67 6f6f   Feasible no-goo
-00003c90: 6420 6375 7473 2065 7863 6c75 6465 2064  d cuts exclude d
-00003ca0: 6973 6372 6574 6520 7265 616c 697a 6174  iscrete realizat
-00003cb0: 696f 6e73 2074 6861 7420 6861 7665 0a20  ions that have. 
-00003cc0: 2020 2020 2020 2023 2062 6565 6e20 6578         # been ex
-00003cd0: 706c 6f72 6564 2076 6961 2061 6e20 4e4c  plored via an NL
-00003ce0: 5020 7375 6270 726f 626c 656d 2e20 4465  P subproblem. De
-00003cf0: 7065 6e64 696e 6720 6f6e 206d 6f64 656c  pending on model
-00003d00: 0a20 2020 2020 2020 2023 2063 6861 7261  .        # chara
-00003d10: 6374 6572 6973 7469 6373 2c20 7468 6520  cteristics, the 
-00003d20: 7573 6572 206d 6179 2077 6973 6820 746f  user may wish to
-00003d30: 2072 6576 6973 6974 204e 4c50 2073 7562   revisit NLP sub
-00003d40: 7072 6f62 6c65 6d73 0a20 2020 2020 2020  problems.       
-00003d50: 2023 2028 7769 7468 2061 2064 6966 6665   # (with a diffe
-00003d60: 7265 6e74 2069 6e69 7469 616c 697a 6174  rent initializat
-00003d70: 696f 6e2c 2066 6f72 2065 7861 6d70 6c65  ion, for example
-00003d80: 292e 2054 6865 7265 666f 7265 2c20 7468  ). Therefore, th
-00003d90: 6573 650a 2020 2020 2020 2020 2320 6375  ese.        # cu
-00003da0: 7473 2061 7265 206e 6f74 2065 6e61 626c  ts are not enabl
-00003db0: 6564 2062 7920 6465 6661 756c 742e 0a0a  ed by default...
-00003dc0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-00003dd0: 672e 6665 6173 6962 696c 6974 795f 6e6f  g.feasibility_no
-00003de0: 726d 203d 3d20 274c 3127 206f 7220 636f  rm == 'L1' or co
-00003df0: 6e66 6967 2e66 6561 7369 6269 6c69 7479  nfig.feasibility
-00003e00: 5f6e 6f72 6d20 3d3d 2027 4c32 273a 0a20  _norm == 'L2':. 
-00003e10: 2020 2020 2020 2020 2020 2066 6561 732e             feas.
-00003e20: 6e6c 5f63 6f6e 7374 7261 696e 745f 7365  nl_constraint_se
-00003e30: 7420 3d20 5261 6e67 6553 6574 280a 2020  t = RangeSet(.  
-00003e40: 2020 2020 2020 2020 2020 2020 2020 6c65                le
-00003e50: 6e28 4d69 6e64 7450 792e 6e6f 6e6c 696e  n(MindtPy.nonlin
-00003e60: 6561 725f 636f 6e73 7472 6169 6e74 5f6c  ear_constraint_l
-00003e70: 6973 7429 2c0a 2020 2020 2020 2020 2020  ist),.          
-00003e80: 2020 2020 2020 646f 633d 2749 6e74 6567        doc='Integ
-00003e90: 6572 2069 6e64 6578 2073 6574 206f 7665  er index set ove
-00003ea0: 7220 7468 6520 6e6f 6e6c 696e 6561 7220  r the nonlinear 
-00003eb0: 636f 6e73 7472 6169 6e74 732e 272c 0a20  constraints.',. 
-00003ec0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00003ed0: 2020 2020 2020 2020 2023 2043 7265 6174           # Creat
-00003ee0: 6520 736c 6163 6b20 7661 7269 6162 6c65  e slack variable
-00003ef0: 7320 666f 7220 6665 6173 6962 696c 6974  s for feasibilit
-00003f00: 7920 7072 6f62 6c65 6d0a 2020 2020 2020  y problem.      
-00003f10: 2020 2020 2020 6665 6173 2e73 6c61 636b        feas.slack
-00003f20: 5f76 6172 203d 2056 6172 280a 2020 2020  _var = Var(.    
-00003f30: 2020 2020 2020 2020 2020 2020 6665 6173              feas
-00003f40: 2e6e 6c5f 636f 6e73 7472 6169 6e74 5f73  .nl_constraint_s
-00003f50: 6574 2c20 646f 6d61 696e 3d4e 6f6e 4e65  et, domain=NonNe
-00003f60: 6761 7469 7665 5265 616c 732c 2069 6e69  gativeReals, ini
-00003f70: 7469 616c 697a 653d 310a 2020 2020 2020  tialize=1.      
-00003f80: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00003f90: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00003fa0: 2020 6665 6173 2e73 6c61 636b 5f76 6172    feas.slack_var
-00003fb0: 203d 2056 6172 2864 6f6d 6169 6e3d 4e6f   = Var(domain=No
-00003fc0: 6e4e 6567 6174 6976 6552 6561 6c73 2c20  nNegativeReals, 
-00003fd0: 696e 6974 6961 6c69 7a65 3d31 290a 0a20  initialize=1).. 
-00003fe0: 2020 2020 2020 2023 2043 7265 6174 6520         # Create 
-00003ff0: 736c 6163 6b20 7661 7269 6162 6c65 7320  slack variables 
-00004000: 666f 7220 4f41 2063 7574 730a 2020 2020  for OA cuts.    
-00004010: 2020 2020 6966 2063 6f6e 6669 672e 6164      if config.ad
-00004020: 645f 736c 6163 6b3a 0a20 2020 2020 2020  d_slack:.       
-00004030: 2020 2020 206c 696e 2e73 6c61 636b 5f76       lin.slack_v
-00004040: 6172 7320 3d20 5661 724c 6973 7428 0a20  ars = VarList(. 
-00004050: 2020 2020 2020 2020 2020 2020 2020 2062                 b
-00004060: 6f75 6e64 733d 2830 2c20 636f 6e66 6967  ounds=(0, config
-00004070: 2e6d 6178 5f73 6c61 636b 292c 2069 6e69  .max_slack), ini
-00004080: 7469 616c 697a 653d 302c 2064 6f6d 6169  tialize=0, domai
-00004090: 6e3d 4e6f 6e4e 6567 6174 6976 6552 6561  n=NonNegativeRea
-000040a0: 6c73 0a20 2020 2020 2020 2020 2020 2029  ls.            )
-000040b0: 0a0a 2020 2020 6465 6620 6765 745f 6475  ..    def get_du
-000040c0: 616c 5f69 6e74 6567 7261 6c28 7365 6c66  al_integral(self
-000040d0: 293a 0a20 2020 2020 2020 2022 2222 4361  ):.        """Ca
-000040e0: 6c63 756c 6174 6520 7468 6520 6475 616c  lculate the dual
-000040f0: 2069 6e74 6567 7261 6c2e 0a20 2020 2020   integral..     
-00004100: 2020 2052 6566 3a20 5468 6520 636f 6e66     Ref: The conf
-00004110: 696e 6564 2070 7269 6d61 6c20 696e 7465  ined primal inte
-00004120: 6772 616c 2e20 5b68 7474 703a 2f2f 7777  gral. [http://ww
-00004130: 772e 6f70 7469 6d69 7a61 7469 6f6e 2d6f  w.optimization-o
-00004140: 6e6c 696e 652e 6f72 672f 4442 5f46 494c  nline.org/DB_FIL
-00004150: 452f 3230 3230 2f30 372f 3739 3130 2e70  E/2020/07/7910.p
-00004160: 6466 5d0a 0a20 2020 2020 2020 2052 6574  df]..        Ret
-00004170: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
-00004180: 2d2d 2d2d 0a20 2020 2020 2020 2066 6c6f  ----.        flo
-00004190: 6174 0a20 2020 2020 2020 2020 2020 2054  at.            T
-000041a0: 6865 2064 7561 6c20 696e 7465 6772 616c  he dual integral
-000041b0: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-000041c0: 2020 2020 2020 6475 616c 5f69 6e74 6567        dual_integ
-000041d0: 7261 6c20 3d20 300a 2020 2020 2020 2020  ral = 0.        
-000041e0: 6475 616c 5f62 6f75 6e64 5f70 726f 6772  dual_bound_progr
-000041f0: 6573 7320 3d20 7365 6c66 2e64 7561 6c5f  ess = self.dual_
-00004200: 626f 756e 645f 7072 6f67 7265 7373 2e63  bound_progress.c
-00004210: 6f70 7928 290a 2020 2020 2020 2020 2320  opy().        # 
-00004220: 496e 6974 6961 6c20 6475 616c 2062 6f75  Initial dual bou
-00004230: 6e64 2069 7320 7365 7420 746f 2069 6e66  nd is set to inf
-00004240: 206f 7220 2d69 6e66 2e20 546f 2063 616c   or -inf. To cal
-00004250: 6375 6c61 7465 2064 7561 6c20 696e 7465  culate dual inte
-00004260: 6772 616c 2c20 7765 2073 6574 0a20 2020  gral, we set.   
-00004270: 2020 2020 2023 2069 6e69 7469 616c 5f64       # initial_d
-00004280: 7561 6c5f 626f 756e 6420 746f 2031 3025  ual_bound to 10%
-00004290: 2067 7265 6174 6572 206f 7220 736d 616c   greater or smal
-000042a0: 6c65 7220 7468 616e 2074 6865 2066 6972  ler than the fir
-000042b0: 7374 5f66 6f75 6e64 5f64 7561 6c5f 626f  st_found_dual_bo
-000042c0: 756e 642e 0a20 2020 2020 2020 2023 2054  und..        # T
-000042d0: 4f44 4f3a 2063 6865 636b 2069 6620 7468  ODO: check if th
-000042e0: 6520 6361 6c63 756c 6174 696f 6e20 6f66  e calculation of
-000042f0: 2069 6e69 7469 616c 5f64 7561 6c5f 626f   initial_dual_bo
-00004300: 756e 6420 6e65 6564 7320 746f 2062 6520  und needs to be 
-00004310: 6d6f 6469 6669 6564 2e0a 2020 2020 2020  modified..      
-00004320: 2020 666f 7220 6475 616c 5f62 6f75 6e64    for dual_bound
-00004330: 2069 6e20 6475 616c 5f62 6f75 6e64 5f70   in dual_bound_p
-00004340: 726f 6772 6573 733a 0a20 2020 2020 2020  rogress:.       
-00004350: 2020 2020 2069 6620 6475 616c 5f62 6f75       if dual_bou
-00004360: 6e64 2021 3d20 6475 616c 5f62 6f75 6e64  nd != dual_bound
-00004370: 5f70 726f 6772 6573 735b 305d 3a0a 2020  _progress[0]:.  
-00004380: 2020 2020 2020 2020 2020 2020 2020 6272                br
-00004390: 6561 6b0a 2020 2020 2020 2020 666f 7220  eak.        for 
-000043a0: 6920 696e 2072 616e 6765 286c 656e 2864  i in range(len(d
-000043b0: 7561 6c5f 626f 756e 645f 7072 6f67 7265  ual_bound_progre
-000043c0: 7373 2929 3a0a 2020 2020 2020 2020 2020  ss)):.          
-000043d0: 2020 6966 2064 7561 6c5f 626f 756e 645f    if dual_bound_
-000043e0: 7072 6f67 7265 7373 5b69 5d20 3d3d 2073  progress[i] == s
-000043f0: 656c 662e 6475 616c 5f62 6f75 6e64 5f70  elf.dual_bound_p
-00004400: 726f 6772 6573 735b 305d 3a0a 2020 2020  rogress[0]:.    
-00004410: 2020 2020 2020 2020 2020 2020 6475 616c              dual
-00004420: 5f62 6f75 6e64 5f70 726f 6772 6573 735b  _bound_progress[
-00004430: 695d 203d 2064 7561 6c5f 626f 756e 6420  i] = dual_bound 
-00004440: 2a20 280a 2020 2020 2020 2020 2020 2020  * (.            
-00004450: 2020 2020 2020 2020 310a 2020 2020 2020          1.      
-00004460: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
-00004470: 7365 6c66 2e63 6f6e 6669 672e 696e 6974  self.config.init
-00004480: 6961 6c5f 626f 756e 645f 636f 6566 0a20  ial_bound_coef. 
-00004490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000044a0: 2020 202a 2073 656c 662e 6f62 6a65 6374     * self.object
-000044b0: 6976 655f 7365 6e73 650a 2020 2020 2020  ive_sense.      
-000044c0: 2020 2020 2020 2020 2020 2020 2020 2a20                * 
-000044d0: 6d61 7468 2e63 6f70 7973 6967 6e28 312c  math.copysign(1,
-000044e0: 2064 7561 6c5f 626f 756e 6429 0a20 2020   dual_bound).   
-000044f0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-00004500: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00004510: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00004520: 2062 7265 616b 0a20 2020 2020 2020 2066   break.        f
-00004530: 6f72 2069 2069 6e20 7261 6e67 6528 6c65  or i in range(le
-00004540: 6e28 6475 616c 5f62 6f75 6e64 5f70 726f  n(dual_bound_pro
-00004550: 6772 6573 7329 293a 0a20 2020 2020 2020  gress)):.       
-00004560: 2020 2020 2069 6620 6920 3d3d 2030 3a0a       if i == 0:.
-00004570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004580: 6475 616c 5f69 6e74 6567 7261 6c20 2b3d  dual_integral +=
-00004590: 2061 6273 2864 7561 6c5f 626f 756e 645f   abs(dual_bound_
-000045a0: 7072 6f67 7265 7373 5b69 5d20 2d20 7365  progress[i] - se
-000045b0: 6c66 2e64 7561 6c5f 626f 756e 6429 202a  lf.dual_bound) *
-000045c0: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-000045d0: 2020 2020 2020 2073 656c 662e 6475 616c         self.dual
-000045e0: 5f62 6f75 6e64 5f70 726f 6772 6573 735f  _bound_progress_
-000045f0: 7469 6d65 5b69 5d0a 2020 2020 2020 2020  time[i].        
-00004600: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00004610: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00004620: 2020 2020 2020 2020 2020 2020 6475 616c              dual
-00004630: 5f69 6e74 6567 7261 6c20 2b3d 2061 6273  _integral += abs
-00004640: 2864 7561 6c5f 626f 756e 645f 7072 6f67  (dual_bound_prog
-00004650: 7265 7373 5b69 5d20 2d20 7365 6c66 2e64  ress[i] - self.d
-00004660: 7561 6c5f 626f 756e 6429 202a 2028 0a20  ual_bound) * (. 
-00004670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004680: 2020 2073 656c 662e 6475 616c 5f62 6f75     self.dual_bou
-00004690: 6e64 5f70 726f 6772 6573 735f 7469 6d65  nd_progress_time
-000046a0: 5b69 5d0a 2020 2020 2020 2020 2020 2020  [i].            
-000046b0: 2020 2020 2020 2020 2d20 7365 6c66 2e64          - self.d
-000046c0: 7561 6c5f 626f 756e 645f 7072 6f67 7265  ual_bound_progre
-000046d0: 7373 5f74 696d 655b 6920 2d20 315d 0a20  ss_time[i - 1]. 
-000046e0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-000046f0: 0a20 2020 2020 2020 2073 656c 662e 636f  .        self.co
-00004700: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-00004710: 280a 2020 2020 2020 2020 2020 2020 2720  (.            ' 
-00004720: 7b3a 3c32 357d 3a20 2020 7b3a 3e37 2e34  {:<25}:   {:>7.4
-00004730: 667d 2027 2e66 6f72 6d61 7428 2744 7561  f} '.format('Dua
-00004740: 6c20 696e 7465 6772 616c 272c 2064 7561  l integral', dua
-00004750: 6c5f 696e 7465 6772 616c 290a 2020 2020  l_integral).    
-00004760: 2020 2020 290a 2020 2020 2020 2020 7265      ).        re
-00004770: 7475 726e 2064 7561 6c5f 696e 7465 6772  turn dual_integr
-00004780: 616c 0a0a 2020 2020 6465 6620 6765 745f  al..    def get_
-00004790: 7072 696d 616c 5f69 6e74 6567 7261 6c28  primal_integral(
-000047a0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-000047b0: 2222 4361 6c63 756c 6174 6520 7468 6520  ""Calculate the 
-000047c0: 7072 696d 616c 2069 6e74 6567 7261 6c2e  primal integral.
-000047d0: 0a20 2020 2020 2020 2052 6566 3a20 5468  .        Ref: Th
-000047e0: 6520 636f 6e66 696e 6564 2070 7269 6d61  e confined prima
-000047f0: 6c20 696e 7465 6772 616c 2e20 5b68 7474  l integral. [htt
-00004800: 703a 2f2f 7777 772e 6f70 7469 6d69 7a61  p://www.optimiza
-00004810: 7469 6f6e 2d6f 6e6c 696e 652e 6f72 672f  tion-online.org/
-00004820: 4442 5f46 494c 452f 3230 3230 2f30 372f  DB_FILE/2020/07/
-00004830: 3739 3130 2e70 6466 5d0a 0a20 2020 2020  7910.pdf]..     
-00004840: 2020 2052 6574 7572 6e73 0a20 2020 2020     Returns.     
-00004850: 2020 202d 2d2d 2d2d 2d2d 0a20 2020 2020     -------.     
-00004860: 2020 2066 6c6f 6174 0a20 2020 2020 2020     float.       
-00004870: 2020 2020 2054 6865 2070 7269 6d61 6c20       The primal 
-00004880: 696e 7465 6772 616c 2e0a 2020 2020 2020  integral..      
-00004890: 2020 2222 220a 2020 2020 2020 2020 7072    """.        pr
-000048a0: 696d 616c 5f69 6e74 6567 7261 6c20 3d20  imal_integral = 
-000048b0: 300a 2020 2020 2020 2020 7072 696d 616c  0.        primal
-000048c0: 5f62 6f75 6e64 5f70 726f 6772 6573 7320  _bound_progress 
-000048d0: 3d20 7365 6c66 2e70 7269 6d61 6c5f 626f  = self.primal_bo
-000048e0: 756e 645f 7072 6f67 7265 7373 2e63 6f70  und_progress.cop
-000048f0: 7928 290a 2020 2020 2020 2020 2320 496e  y().        # In
-00004900: 6974 6961 6c20 7072 696d 616c 2062 6f75  itial primal bou
-00004910: 6e64 2069 7320 7365 7420 746f 2069 6e66  nd is set to inf
-00004920: 206f 7220 2d69 6e66 2e20 546f 2063 616c   or -inf. To cal
-00004930: 6375 6c61 7465 2070 7269 6d61 6c20 696e  culate primal in
-00004940: 7465 6772 616c 2c20 7765 2073 6574 0a20  tegral, we set. 
-00004950: 2020 2020 2020 2023 2069 6e69 7469 616c         # initial
-00004960: 5f70 7269 6d61 6c5f 626f 756e 6420 746f  _primal_bound to
-00004970: 2031 3025 2067 7265 6174 6572 206f 7220   10% greater or 
-00004980: 736d 616c 6c65 7220 7468 616e 2074 6865  smaller than the
-00004990: 2066 6972 7374 5f66 6f75 6e64 5f70 7269   first_found_pri
-000049a0: 6d61 6c5f 626f 756e 642e 0a20 2020 2020  mal_bound..     
-000049b0: 2020 2023 2054 4f44 4f3a 2063 6865 636b     # TODO: check
-000049c0: 2069 6620 7468 6520 6361 6c63 756c 6174   if the calculat
-000049d0: 696f 6e20 6f66 2069 6e69 7469 616c 5f70  ion of initial_p
-000049e0: 7269 6d61 6c5f 626f 756e 6420 6e65 6564  rimal_bound need
-000049f0: 7320 746f 2062 6520 6d6f 6469 6669 6564  s to be modified
-00004a00: 2e0a 2020 2020 2020 2020 666f 7220 7072  ..        for pr
-00004a10: 696d 616c 5f62 6f75 6e64 2069 6e20 7072  imal_bound in pr
-00004a20: 696d 616c 5f62 6f75 6e64 5f70 726f 6772  imal_bound_progr
-00004a30: 6573 733a 0a20 2020 2020 2020 2020 2020  ess:.           
-00004a40: 2069 6620 7072 696d 616c 5f62 6f75 6e64   if primal_bound
-00004a50: 2021 3d20 7072 696d 616c 5f62 6f75 6e64   != primal_bound
-00004a60: 5f70 726f 6772 6573 735b 305d 3a0a 2020  _progress[0]:.  
-00004a70: 2020 2020 2020 2020 2020 2020 2020 6272                br
-00004a80: 6561 6b0a 2020 2020 2020 2020 666f 7220  eak.        for 
-00004a90: 6920 696e 2072 616e 6765 286c 656e 2870  i in range(len(p
-00004aa0: 7269 6d61 6c5f 626f 756e 645f 7072 6f67  rimal_bound_prog
-00004ab0: 7265 7373 2929 3a0a 2020 2020 2020 2020  ress)):.        
-00004ac0: 2020 2020 6966 2070 7269 6d61 6c5f 626f      if primal_bo
-00004ad0: 756e 645f 7072 6f67 7265 7373 5b69 5d20  und_progress[i] 
-00004ae0: 3d3d 2073 656c 662e 7072 696d 616c 5f62  == self.primal_b
-00004af0: 6f75 6e64 5f70 726f 6772 6573 735b 305d  ound_progress[0]
-00004b00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00004b10: 2020 7072 696d 616c 5f62 6f75 6e64 5f70    primal_bound_p
-00004b20: 726f 6772 6573 735b 695d 203d 2070 7269  rogress[i] = pri
-00004b30: 6d61 6c5f 626f 756e 6420 2a20 280a 2020  mal_bound * (.  
+00001a00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001a10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001a20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00001a30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d5c  ---------------\
+00001a40: 6e27 0a20 2020 2020 2020 2020 2020 2027  n'.            '
+00001a50: 466f 7220 6d6f 7265 2069 6e66 6f72 6d61  For more informa
+00001a60: 7469 6f6e 2c20 706c 6561 7365 2076 6973  tion, please vis
+00001a70: 6974 205c 6e27 0a20 2020 2020 2020 2020  it \n'.         
+00001a80: 2020 2027 6874 7470 733a 2f2f 7079 6f6d     'https://pyom
+00001a90: 6f2e 7265 6164 7468 6564 6f63 732e 696f  o.readthedocs.io
+00001aa0: 2f65 6e2f 7374 6162 6c65 2f63 6f6e 7472  /en/stable/contr
+00001ab0: 6962 7574 6564 5f70 6163 6b61 6765 732f  ibuted_packages/
+00001ac0: 6d69 6e64 7470 792e 6874 6d6c 270a 2020  mindtpy.html'.  
+00001ad0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00001ae0: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
+00001af0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
+00001b00: 2020 2020 2027 4966 2079 6f75 2075 7365       'If you use
+00001b10: 2074 6869 7320 736f 6674 7761 7265 2c20   this software, 
+00001b20: 706c 6561 7365 2063 6974 6520 7468 6520  please cite the 
+00001b30: 666f 6c6c 6f77 696e 673a 5c6e 270a 2020  following:\n'.  
+00001b40: 2020 2020 2020 2020 2020 2742 6572 6e61            'Berna
+00001b50: 6c2c 2044 6176 6964 2045 2e2c 2065 7420  l, David E., et 
+00001b60: 616c 2e20 4d69 7865 642d 696e 7465 6765  al. Mixed-intege
+00001b70: 7220 6e6f 6e6c 696e 6561 7220 6465 636f  r nonlinear deco
+00001b80: 6d70 6f73 6974 696f 6e20 746f 6f6c 626f  mposition toolbo
+00001b90: 7820 666f 7220 5079 6f6d 6f20 284d 696e  x for Pyomo (Min
+00001ba0: 6474 5079 292e 5c6e 270a 2020 2020 2020  dtPy).\n'.      
+00001bb0: 2020 2020 2020 2743 6f6d 7075 7465 7220        'Computer 
+00001bc0: 4169 6465 6420 4368 656d 6963 616c 2045  Aided Chemical E
+00001bd0: 6e67 696e 6565 7269 6e67 2e20 566f 6c2e  ngineering. Vol.
+00001be0: 2034 342e 2045 6c73 6576 6965 722c 2032   44. Elsevier, 2
+00001bf0: 3031 382e 2038 3935 2d39 3030 2e5c 6e27  018. 895-900.\n'
+00001c00: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+00001c10: 6465 6620 7365 745f 7570 5f6c 6f67 6765  def set_up_logge
+00001c20: 7228 7365 6c66 293a 0a20 2020 2020 2020  r(self):.       
+00001c30: 2022 2222 5365 7420 7570 2074 6865 2066   """Set up the f
+00001c40: 6f72 6d61 7474 6572 2061 6e64 2068 616e  ormatter and han
+00001c50: 646c 6572 2066 6f72 206c 6f67 6765 722e  dler for logger.
+00001c60: 2222 220a 2020 2020 2020 2020 7365 6c66  """.        self
+00001c70: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e68  .config.logger.h
+00001c80: 616e 646c 6572 732e 636c 6561 7228 290a  andlers.clear().
+00001c90: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
+00001ca0: 6669 672e 6c6f 6767 6572 2e70 726f 7061  fig.logger.propa
+00001cb0: 6761 7465 203d 2046 616c 7365 0a20 2020  gate = False.   
+00001cc0: 2020 2020 2063 6820 3d20 6c6f 6767 696e       ch = loggin
+00001cd0: 672e 5374 7265 616d 4861 6e64 6c65 7228  g.StreamHandler(
+00001ce0: 290a 2020 2020 2020 2020 6368 2e73 6574  ).        ch.set
+00001cf0: 4c65 7665 6c28 7365 6c66 2e63 6f6e 6669  Level(self.confi
+00001d00: 672e 6c6f 6767 696e 675f 6c65 7665 6c29  g.logging_level)
+00001d10: 0a20 2020 2020 2020 2023 2063 7265 6174  .        # creat
+00001d20: 6520 666f 726d 6174 7465 7220 616e 6420  e formatter and 
+00001d30: 6164 6420 6974 2074 6f20 7468 6520 6861  add it to the ha
+00001d40: 6e64 6c65 7273 0a20 2020 2020 2020 2066  ndlers.        f
+00001d50: 6f72 6d61 7474 6572 203d 206c 6f67 6769  ormatter = loggi
+00001d60: 6e67 2e46 6f72 6d61 7474 6572 2827 2528  ng.Formatter('%(
+00001d70: 6d65 7373 6167 6529 7327 290a 2020 2020  message)s').    
+00001d80: 2020 2020 6368 2e73 6574 466f 726d 6174      ch.setFormat
+00001d90: 7465 7228 666f 726d 6174 7465 7229 0a20  ter(formatter). 
+00001da0: 2020 2020 2020 2023 2061 6464 2074 6865         # add the
+00001db0: 2068 616e 646c 6572 7320 746f 206c 6f67   handlers to log
+00001dc0: 6765 720a 2020 2020 2020 2020 7365 6c66  ger.        self
+00001dd0: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e61  .config.logger.a
+00001de0: 6464 4861 6e64 6c65 7228 6368 290a 0a20  ddHandler(ch).. 
+00001df0: 2020 2064 6566 205f 6c6f 675f 6865 6164     def _log_head
+00001e00: 6572 2873 656c 662c 206c 6f67 6765 7229  er(self, logger)
+00001e10: 3a0a 2020 2020 2020 2020 2320 544f 444f  :.        # TODO
+00001e20: 3a20 7265 7772 6974 650a 2020 2020 2020  : rewrite.      
+00001e30: 2020 6c6f 6767 6572 2e69 6e66 6f28 0a20    logger.info(. 
+00001e40: 2020 2020 2020 2020 2020 2027 3d3d 3d3d             '====
+00001e50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001e60: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001e70: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001e80: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d27 0a20  ============='. 
+00001e90: 2020 2020 2020 2020 2020 2027 3d3d 3d3d             '====
+00001ea0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001eb0: 3d3d 3d3d 3d3d 3d3d 270a 2020 2020 2020  ========'.      
+00001ec0: 2020 290a 2020 2020 2020 2020 6c6f 6767    ).        logg
+00001ed0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
+00001ee0: 2020 2020 2027 7b3a 5e39 7d20 7c20 7b3a       '{:^9} | {:
+00001ef0: 5e31 357d 207c 207b 3a5e 3131 7d20 7c20  ^15} | {:^11} | 
+00001f00: 7b3a 5e31 317d 207c 207b 3a5e 387d 207c  {:^11} | {:^8} |
+00001f10: 207b 3a5e 377d 5c6e 272e 666f 726d 6174   {:^7}\n'.format
+00001f20: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00001f30: 2020 2749 7465 7261 7469 6f6e 272c 0a20    'Iteration',. 
+00001f40: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00001f50: 5375 6270 726f 626c 656d 2054 7970 6527  Subproblem Type'
+00001f60: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00001f70: 2020 274c 6f77 6572 2042 6f75 6e64 272c    'Lower Bound',
+00001f80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00001f90: 2027 5570 7065 7220 426f 756e 6427 2c0a   'Upper Bound',.
+00001fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00001fb0: 2720 4761 7020 272c 0a20 2020 2020 2020  ' Gap ',.       
+00001fc0: 2020 2020 2020 2020 2027 5469 6d65 2873           'Time(s
+00001fd0: 2927 2c0a 2020 2020 2020 2020 2020 2020  )',.            
+00001fe0: 290a 2020 2020 2020 2020 290a 0a20 2020  ).        )..   
+00001ff0: 2064 6566 2063 7265 6174 655f 7574 696c   def create_util
+00002000: 6974 795f 626c 6f63 6b28 7365 6c66 2c20  ity_block(self, 
+00002010: 6d6f 6465 6c2c 206e 616d 6529 3a0a 2020  model, name):.  
+00002020: 2020 2020 2020 6372 6561 7465 645f 7574        created_ut
+00002030: 696c 5f62 6c6f 636b 203d 2046 616c 7365  il_block = False
+00002040: 0a20 2020 2020 2020 2023 2043 7265 6174  .        # Creat
+00002050: 6520 6120 6d6f 6465 6c20 626c 6f63 6b20  e a model block 
+00002060: 6f6e 2077 6869 6368 2074 6f20 7374 6f72  on which to stor
+00002070: 6520 4d69 6e64 7450 792d 7370 6563 6966  e MindtPy-specif
+00002080: 6963 2075 7469 6c69 7479 0a20 2020 2020  ic utility.     
+00002090: 2020 2023 206d 6f64 656c 696e 6720 6f62     # modeling ob
+000020a0: 6a65 6374 732e 0a20 2020 2020 2020 2069  jects..        i
+000020b0: 6620 6861 7361 7474 7228 6d6f 6465 6c2c  f hasattr(model,
+000020c0: 206e 616d 6529 3a0a 2020 2020 2020 2020   name):.        
+000020d0: 2020 2020 7261 6973 6520 5275 6e74 696d      raise Runtim
+000020e0: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
+000020f0: 2020 2020 2020 2020 224d 696e 6474 5079          "MindtPy
+00002100: 206e 6565 6473 2074 6f20 6372 6561 7465   needs to create
+00002110: 2061 2042 6c6f 636b 206e 616d 6564 2025   a Block named %
+00002120: 7320 220a 2020 2020 2020 2020 2020 2020  s ".            
+00002130: 2020 2020 226f 6e20 7468 6520 6d6f 6465      "on the mode
+00002140: 6c20 6f62 6a65 6374 2c20 6275 7420 616e  l object, but an
+00002150: 2061 7474 7269 6275 7465 2077 6974 6820   attribute with 
+00002160: 7468 6174 206e 616d 6520 220a 2020 2020  that name ".    
+00002170: 2020 2020 2020 2020 2020 2020 2261 6c72              "alr
+00002180: 6561 6479 2065 7869 7374 732e 2220 2520  eady exists." % 
+00002190: 6e61 6d65 0a20 2020 2020 2020 2020 2020  name.           
+000021a0: 2029 0a20 2020 2020 2020 2065 6c73 653a   ).        else:
+000021b0: 0a20 2020 2020 2020 2020 2020 2063 7265  .            cre
+000021c0: 6174 6564 5f75 7469 6c5f 626c 6f63 6b20  ated_util_block 
+000021d0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+000021e0: 2020 2073 6574 6174 7472 280a 2020 2020     setattr(.    
+000021f0: 2020 2020 2020 2020 2020 2020 6d6f 6465              mode
+00002200: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
+00002210: 2020 206e 616d 652c 0a20 2020 2020 2020     name,.       
+00002220: 2020 2020 2020 2020 2042 6c6f 636b 2864           Block(d
+00002230: 6f63 3d22 436f 6e74 6169 6e65 7220 666f  oc="Container fo
+00002240: 7220 4d69 6e64 7450 7920 736f 6c76 6572  r MindtPy solver
+00002250: 2075 7469 6c69 7479 206d 6f64 656c 696e   utility modelin
+00002260: 6720 6f62 6a65 6374 7322 292c 0a20 2020  g objects"),.   
+00002270: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00002280: 2020 2020 2020 2073 656c 662e 7574 696c         self.util
+00002290: 5f62 6c6f 636b 5f6e 616d 6520 3d20 6e61  _block_name = na
+000022a0: 6d65 0a0a 2020 2020 2020 2020 2020 2020  me..            
+000022b0: 2320 5361 7665 206f 7264 6572 6564 206c  # Save ordered l
+000022c0: 6973 7473 206f 6620 6d61 696e 206d 6f64  ists of main mod
+000022d0: 656c 696e 6720 636f 6d70 6f6e 656e 7473  eling components
+000022e0: 2c20 736f 2074 6861 7420 6461 7461 2063  , so that data c
+000022f0: 616e 0a20 2020 2020 2020 2020 2020 2023  an.            #
+00002300: 2062 6520 6561 7369 6c79 2074 7261 6e73   be easily trans
+00002310: 6665 7272 6564 2062 6574 7765 656e 2066  ferred between f
+00002320: 7574 7572 6520 6d6f 6465 6c20 636c 6f6e  uture model clon
+00002330: 6573 2e0a 2020 2020 2020 2020 2020 2020  es..            
+00002340: 7365 6c66 2e62 7569 6c64 5f6f 7264 6572  self.build_order
+00002350: 6564 5f63 6f6d 706f 6e65 6e74 5f6c 6973  ed_component_lis
+00002360: 7473 286d 6f64 656c 290a 2020 2020 2020  ts(model).      
+00002370: 2020 2020 2020 7365 6c66 2e61 6464 5f63        self.add_c
+00002380: 7574 735f 636f 6d70 6f6e 656e 7473 286d  uts_components(m
+00002390: 6f64 656c 290a 0a20 2020 2064 6566 206d  odel)..    def m
+000023a0: 6f64 656c 5f69 735f 7661 6c69 6428 7365  odel_is_valid(se
+000023b0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
+000023c0: 4465 7465 726d 696e 6573 2077 6865 7468  Determines wheth
+000023d0: 6572 2074 6865 206d 6f64 656c 2069 7320  er the model is 
+000023e0: 736f 6c76 6162 6c65 2062 7920 4d69 6e64  solvable by Mind
+000023f0: 7450 792e 0a0a 2020 2020 2020 2020 5265  tPy...        Re
+00002400: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
+00002410: 2d2d 2d2d 2d0a 2020 2020 2020 2020 626f  -----.        bo
+00002420: 6f6c 0a20 2020 2020 2020 2020 2020 2054  ol.            T
+00002430: 7275 6520 6966 206d 6f64 656c 2069 7320  rue if model is 
+00002440: 736f 6c76 6162 6c65 2069 6e20 4d69 6e64  solvable in Mind
+00002450: 7450 792c 2046 616c 7365 206f 7468 6572  tPy, False other
+00002460: 7769 7365 2e0a 2020 2020 2020 2020 2222  wise..        ""
+00002470: 220a 2020 2020 2020 2020 6d20 3d20 7365  ".        m = se
+00002480: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
+00002490: 0a20 2020 2020 2020 204d 696e 6474 5079  .        MindtPy
+000024a0: 203d 206d 2e4d 696e 6474 5079 5f75 7469   = m.MindtPy_uti
+000024b0: 6c73 0a20 2020 2020 2020 2063 6f6e 6669  ls.        confi
+000024c0: 6720 3d20 7365 6c66 2e63 6f6e 6669 670a  g = self.config.
+000024d0: 0a20 2020 2020 2020 2023 2048 616e 646c  .        # Handl
+000024e0: 6520 4c50 2f4e 4c50 2062 6569 6e67 2070  e LP/NLP being p
+000024f0: 6173 7365 6420 746f 2074 6865 2073 6f6c  assed to the sol
+00002500: 7665 720a 2020 2020 2020 2020 7072 6f62  ver.        prob
+00002510: 203d 2073 656c 662e 7265 7375 6c74 732e   = self.results.
+00002520: 7072 6f62 6c65 6d0a 2020 2020 2020 2020  problem.        
+00002530: 6966 206c 656e 284d 696e 6474 5079 2e64  if len(MindtPy.d
+00002540: 6973 6372 6574 655f 7661 7269 6162 6c65  iscrete_variable
+00002550: 5f6c 6973 7429 203d 3d20 303a 0a20 2020  _list) == 0:.   
+00002560: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00002570: 6c6f 6767 6572 2e69 6e66 6f28 2750 726f  logger.info('Pro
+00002580: 626c 656d 2068 6173 206e 6f20 6469 7363  blem has no disc
+00002590: 7265 7465 2064 6563 6973 696f 6e73 2e27  rete decisions.'
+000025a0: 290a 2020 2020 2020 2020 2020 2020 6f62  ).            ob
+000025b0: 6a20 3d20 6e65 7874 286d 2e63 6f6d 706f  j = next(m.compo
+000025c0: 6e65 6e74 5f64 6174 615f 6f62 6a65 6374  nent_data_object
+000025d0: 7328 6374 7970 653d 4f62 6a65 6374 6976  s(ctype=Objectiv
+000025e0: 652c 2061 6374 6976 653d 5472 7565 2929  e, active=True))
+000025f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00002600: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00002610: 2020 616e 7928 0a20 2020 2020 2020 2020    any(.         
+00002620: 2020 2020 2020 2020 2020 2063 2e62 6f64             c.bod
+00002630: 792e 706f 6c79 6e6f 6d69 616c 5f64 6567  y.polynomial_deg
+00002640: 7265 6528 290a 2020 2020 2020 2020 2020  ree().          
+00002650: 2020 2020 2020 2020 2020 6e6f 7420 696e            not in
+00002660: 2073 656c 662e 6d69 705f 636f 6e73 7472   self.mip_constr
+00002670: 6169 6e74 5f70 6f6c 796e 6f6d 6961 6c5f  aint_polynomial_
+00002680: 6465 6772 6565 0a20 2020 2020 2020 2020  degree.         
+00002690: 2020 2020 2020 2020 2020 2066 6f72 2063             for c
+000026a0: 2069 6e20 4d69 6e64 7450 792e 636f 6e73   in MindtPy.cons
+000026b0: 7472 6169 6e74 5f6c 6973 740a 2020 2020  traint_list.    
+000026c0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000026d0: 2020 2020 2020 2020 2020 2020 2020 6f72                or
+000026e0: 206f 626a 2e65 7870 722e 706f 6c79 6e6f   obj.expr.polyno
+000026f0: 6d69 616c 5f64 6567 7265 6528 290a 2020  mial_degree().  
+00002700: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
+00002710: 7420 696e 2073 656c 662e 6d69 705f 6f62  t in self.mip_ob
+00002720: 6a65 6374 6976 655f 706f 6c79 6e6f 6d69  jective_polynomi
+00002730: 616c 5f64 6567 7265 650a 2020 2020 2020  al_degree.      
+00002740: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+00002750: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00002760: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+00002770: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002780: 2027 596f 7572 206d 6f64 656c 2069 7320   'Your model is 
+00002790: 6120 4e4c 5020 286e 6f6e 6c69 6e65 6172  a NLP (nonlinear
+000027a0: 2070 726f 6772 616d 292e 2027 0a20 2020   program). '.   
+000027b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000027c0: 2027 5573 696e 6720 4e4c 5020 736f 6c76   'Using NLP solv
+000027d0: 6572 2025 7320 746f 2073 6f6c 7665 2e27  er %s to solve.'
+000027e0: 2025 2063 6f6e 6669 672e 6e6c 705f 736f   % config.nlp_so
+000027f0: 6c76 6572 0a20 2020 2020 2020 2020 2020  lver.           
+00002800: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00002810: 2020 2020 2020 2075 7064 6174 655f 736f         update_so
+00002820: 6c76 6572 5f74 696d 656c 696d 6974 280a  lver_timelimit(.
+00002830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002840: 2020 2020 7365 6c66 2e6e 6c70 5f6f 7074      self.nlp_opt
+00002850: 2c20 636f 6e66 6967 2e6e 6c70 5f73 6f6c  , config.nlp_sol
+00002860: 7665 722c 2073 656c 662e 7469 6d69 6e67  ver, self.timing
+00002870: 2c20 636f 6e66 6967 0a20 2020 2020 2020  , config.       
+00002880: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00002890: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000028a0: 6e6c 705f 6f70 742e 736f 6c76 6528 0a20  nlp_opt.solve(. 
+000028b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000028c0: 2020 2073 656c 662e 6f72 6967 696e 616c     self.original
+000028d0: 5f6d 6f64 656c 2c0a 2020 2020 2020 2020  _model,.        
+000028e0: 2020 2020 2020 2020 2020 2020 7465 653d              tee=
+000028f0: 636f 6e66 6967 2e6e 6c70 5f73 6f6c 7665  config.nlp_solve
+00002900: 725f 7465 652c 0a20 2020 2020 2020 2020  r_tee,.         
+00002910: 2020 2020 2020 2020 2020 202a 2a63 6f6e             **con
+00002920: 6669 672e 6e6c 705f 736f 6c76 6572 5f61  fig.nlp_solver_a
+00002930: 7267 732c 0a20 2020 2020 2020 2020 2020  rgs,.           
+00002940: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00002950: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
+00002960: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
+00002970: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00002980: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
+00002990: 6765 722e 696e 666f 280a 2020 2020 2020  ger.info(.      
+000029a0: 2020 2020 2020 2020 2020 2020 2020 2759                'Y
+000029b0: 6f75 7220 6d6f 6465 6c20 6973 2061 6e20  our model is an 
+000029c0: 4c50 2028 6c69 6e65 6172 2070 726f 6772  LP (linear progr
+000029d0: 616d 292e 2027 0a20 2020 2020 2020 2020  am). '.         
+000029e0: 2020 2020 2020 2020 2020 2027 5573 696e             'Usin
+000029f0: 6720 4c50 2073 6f6c 7665 7220 2573 2074  g LP solver %s t
+00002a00: 6f20 736f 6c76 652e 2720 2520 636f 6e66  o solve.' % conf
+00002a10: 6967 2e6d 6970 5f73 6f6c 7665 720a 2020  ig.mip_solver.  
+00002a20: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00002a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a40: 6966 2069 7369 6e73 7461 6e63 6528 7365  if isinstance(se
+00002a50: 6c66 2e6d 6970 5f6f 7074 2c20 5065 7273  lf.mip_opt, Pers
+00002a60: 6973 7465 6e74 536f 6c76 6572 293a 0a20  istentSolver):. 
+00002a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002a80: 2020 2073 656c 662e 6d69 705f 6f70 742e     self.mip_opt.
+00002a90: 7365 745f 696e 7374 616e 6365 2873 656c  set_instance(sel
+00002aa0: 662e 6f72 6967 696e 616c 5f6d 6f64 656c  f.original_model
+00002ab0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00002ac0: 2020 7570 6461 7465 5f73 6f6c 7665 725f    update_solver_
+00002ad0: 7469 6d65 6c69 6d69 7428 0a20 2020 2020  timelimit(.     
+00002ae0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00002af0: 656c 662e 6d69 705f 6f70 742c 2063 6f6e  elf.mip_opt, con
+00002b00: 6669 672e 6d69 705f 736f 6c76 6572 2c20  fig.mip_solver, 
+00002b10: 7365 6c66 2e74 696d 696e 672c 2063 6f6e  self.timing, con
+00002b20: 6669 670a 2020 2020 2020 2020 2020 2020  fig.            
+00002b30: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00002b40: 2020 2020 2020 7265 7375 6c74 7320 3d20        results = 
+00002b50: 7365 6c66 2e6d 6970 5f6f 7074 2e73 6f6c  self.mip_opt.sol
+00002b60: 7665 280a 2020 2020 2020 2020 2020 2020  ve(.            
+00002b70: 2020 2020 2020 2020 7365 6c66 2e6f 7269          self.ori
+00002b80: 6769 6e61 6c5f 6d6f 6465 6c2c 0a20 2020  ginal_model,.   
+00002b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002ba0: 2074 6565 3d63 6f6e 6669 672e 6d69 705f   tee=config.mip_
+00002bb0: 736f 6c76 6572 5f74 6565 2c0a 2020 2020  solver_tee,.    
+00002bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002bd0: 6c6f 6164 5f73 6f6c 7574 696f 6e73 3d73  load_solutions=s
+00002be0: 656c 662e 6d69 705f 6c6f 6164 5f73 6f6c  elf.mip_load_sol
+00002bf0: 7574 696f 6e73 2c0a 2020 2020 2020 2020  utions,.        
+00002c00: 2020 2020 2020 2020 2020 2020 2a2a 636f              **co
+00002c10: 6e66 6967 2e6d 6970 5f73 6f6c 7665 725f  nfig.mip_solver_
+00002c20: 6172 6773 2c0a 2020 2020 2020 2020 2020  args,.          
+00002c30: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00002c40: 2020 2020 2020 2020 6966 206c 656e 2872          if len(r
+00002c50: 6573 756c 7473 2e73 6f6c 7574 696f 6e29  esults.solution)
+00002c60: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
+00002c70: 2020 2020 2020 2020 2020 7365 6c66 2e6f            self.o
+00002c80: 7269 6769 6e61 6c5f 6d6f 6465 6c2e 736f  riginal_model.so
+00002c90: 6c75 7469 6f6e 732e 6c6f 6164 5f66 726f  lutions.load_fro
+00002ca0: 6d28 7265 7375 6c74 7329 0a20 2020 2020  m(results).     
+00002cb0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00002cc0: 6e20 4661 6c73 650a 0a20 2020 2020 2020  n False..       
+00002cd0: 2023 2053 6574 2075 7020 6475 616c 2076   # Set up dual v
+00002ce0: 616c 7565 2072 6570 6f72 7469 6e67 0a20  alue reporting. 
+00002cf0: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
+00002d00: 2e63 616c 6375 6c61 7465 5f64 7561 6c5f  .calculate_dual_
+00002d10: 6174 5f73 6f6c 7574 696f 6e3a 0a20 2020  at_solution:.   
+00002d20: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
+00002d30: 6861 7361 7474 7228 6d2c 2027 6475 616c  hasattr(m, 'dual
+00002d40: 2729 3a0a 2020 2020 2020 2020 2020 2020  '):.            
+00002d50: 2020 2020 6d2e 6475 616c 203d 2053 7566      m.dual = Suf
+00002d60: 6669 7828 6469 7265 6374 696f 6e3d 5375  fix(direction=Su
+00002d70: 6666 6978 2e49 4d50 4f52 5429 0a20 2020  ffix.IMPORT).   
+00002d80: 2020 2020 2020 2020 2065 6c69 6620 6e6f           elif no
+00002d90: 7420 6973 696e 7374 616e 6365 286d 2e64  t isinstance(m.d
+00002da0: 7561 6c2c 2053 7566 6669 7829 3a0a 2020  ual, Suffix):.  
+00002db0: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+00002dc0: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+00002dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00002de0: 2020 2020 2264 7561 6c20 6973 206e 6f74      "dual is not
+00002df0: 2064 6566 696e 6564 2061 7320 6120 5375   defined as a Su
+00002e00: 6666 6978 2069 6e20 7468 6520 6f72 6967  ffix in the orig
+00002e10: 696e 616c 206d 6f64 656c 2e22 0a20 2020  inal model.".   
+00002e20: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+00002e30: 2020 2020 2020 2020 2320 544f 444f 2069          # TODO i
+00002e40: 6620 616e 7920 636f 6e74 696e 756f 7573  f any continuous
+00002e50: 2076 6172 6961 626c 6573 2061 7265 206d   variables are m
+00002e60: 756c 7469 706c 6965 6420 7769 7468 2062  ultiplied with b
+00002e70: 696e 6172 7920 6f6e 6573 2c0a 2020 2020  inary ones,.    
+00002e80: 2020 2020 2320 206e 6565 6420 746f 2064      #  need to d
+00002e90: 6f20 736f 6d65 206b 696e 6420 6f66 2074  o some kind of t
+00002ea0: 7261 6e73 666f 726d 6174 696f 6e20 2847  ransformation (G
+00002eb0: 6c6f 7665 723f 2920 6f72 2074 6872 6f77  lover?) or throw
+00002ec0: 2061 6e20 6572 726f 7220 6d65 7373 6167   an error messag
+00002ed0: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
+00002ee0: 2054 7275 650a 0a20 2020 2064 6566 2062   True..    def b
+00002ef0: 7569 6c64 5f6f 7264 6572 6564 5f63 6f6d  uild_ordered_com
+00002f00: 706f 6e65 6e74 5f6c 6973 7473 2873 656c  ponent_lists(sel
+00002f10: 662c 206d 6f64 656c 293a 0a20 2020 2020  f, model):.     
+00002f20: 2020 2022 2222 4465 6669 6e65 206c 6973     """Define lis
+00002f30: 7473 2075 7365 6420 666f 7220 6675 7475  ts used for futu
+00002f40: 7265 2064 6174 6120 7472 616e 7366 6572  re data transfer
+00002f50: 2e0a 0a20 2020 2020 2020 2041 6c73 6f20  ...        Also 
+00002f60: 6174 7461 6368 6573 206f 7264 6572 6564  attaches ordered
+00002f70: 206c 6973 7473 206f 6620 7468 6520 7661   lists of the va
+00002f80: 7269 6162 6c65 732c 2063 6f6e 7374 7261  riables, constra
+00002f90: 696e 7473 2074 6f20 7468 6520 6d6f 6465  ints to the mode
+00002fa0: 6c20 736f 2074 6861 7420 7468 6579 2063  l so that they c
+00002fb0: 616e 2062 6520 7573 6564 2066 6f72 206d  an be used for m
+00002fc0: 6170 7069 6e67 2062 6163 6b20 616e 640a  apping back and.
+00002fd0: 2020 2020 2020 2020 666f 7274 682e 0a0a          forth...
+00002fe0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00002ff0: 2020 2020 7574 696c 5f62 6c6f 636b 203d      util_block =
+00003000: 2067 6574 6174 7472 286d 6f64 656c 2c20   getattr(model, 
+00003010: 7365 6c66 2e75 7469 6c5f 626c 6f63 6b5f  self.util_block_
+00003020: 6e61 6d65 290a 2020 2020 2020 2020 7661  name).        va
+00003030: 725f 7365 7420 3d20 436f 6d70 6f6e 656e  r_set = Componen
+00003040: 7453 6574 2829 0a20 2020 2020 2020 2075  tSet().        u
+00003050: 7469 6c5f 626c 6f63 6b2e 636f 6e73 7472  til_block.constr
+00003060: 6169 6e74 5f6c 6973 7420 3d20 6c69 7374  aint_list = list
+00003070: 280a 2020 2020 2020 2020 2020 2020 6d6f  (.            mo
+00003080: 6465 6c2e 636f 6d70 6f6e 656e 745f 6461  del.component_da
+00003090: 7461 5f6f 626a 6563 7473 280a 2020 2020  ta_objects(.    
+000030a0: 2020 2020 2020 2020 2020 2020 6374 7970              ctyp
+000030b0: 653d 436f 6e73 7472 6169 6e74 2c20 6163  e=Constraint, ac
+000030c0: 7469 7665 3d54 7275 652c 2064 6573 6365  tive=True, desce
+000030d0: 6e64 5f69 6e74 6f3d 2842 6c6f 636b 290a  nd_into=(Block).
+000030e0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+000030f0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00003100: 6966 2065 6762 5f61 7661 696c 6162 6c65  if egb_available
+00003110: 3a0a 2020 2020 2020 2020 2020 2020 7574  :.            ut
+00003120: 696c 5f62 6c6f 636b 2e67 7265 795f 626f  il_block.grey_bo
+00003130: 785f 6c69 7374 203d 206c 6973 7428 0a20  x_list = list(. 
+00003140: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00003150: 6f64 656c 2e63 6f6d 706f 6e65 6e74 5f64  odel.component_d
+00003160: 6174 615f 6f62 6a65 6374 7328 0a20 2020  ata_objects(.   
+00003170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003180: 2063 7479 7065 3d65 6762 2e45 7874 6572   ctype=egb.Exter
+00003190: 6e61 6c47 7265 7942 6f78 426c 6f63 6b2c  nalGreyBoxBlock,
+000031a0: 2061 6374 6976 653d 5472 7565 2c20 6465   active=True, de
+000031b0: 7363 656e 645f 696e 746f 3d28 426c 6f63  scend_into=(Bloc
+000031c0: 6b29 0a20 2020 2020 2020 2020 2020 2020  k).             
+000031d0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+000031e0: 2029 0a20 2020 2020 2020 2065 6c73 653a   ).        else:
+000031f0: 0a20 2020 2020 2020 2020 2020 2075 7469  .            uti
+00003200: 6c5f 626c 6f63 6b2e 6772 6579 5f62 6f78  l_block.grey_box
+00003210: 5f6c 6973 7420 3d20 5b5d 0a20 2020 2020  _list = [].     
+00003220: 2020 2075 7469 6c5f 626c 6f63 6b2e 6c69     util_block.li
+00003230: 6e65 6172 5f63 6f6e 7374 7261 696e 745f  near_constraint_
+00003240: 6c69 7374 203d 206c 6973 7428 0a20 2020  list = list(.   
+00003250: 2020 2020 2020 2020 2063 0a20 2020 2020           c.     
+00003260: 2020 2020 2020 2066 6f72 2063 2069 6e20         for c in 
+00003270: 7574 696c 5f62 6c6f 636b 2e63 6f6e 7374  util_block.const
+00003280: 7261 696e 745f 6c69 7374 0a20 2020 2020  raint_list.     
+00003290: 2020 2020 2020 2069 6620 632e 626f 6479         if c.body
+000032a0: 2e70 6f6c 796e 6f6d 6961 6c5f 6465 6772  .polynomial_degr
+000032b0: 6565 2829 2069 6e20 7365 6c66 2e6d 6970  ee() in self.mip
+000032c0: 5f63 6f6e 7374 7261 696e 745f 706f 6c79  _constraint_poly
+000032d0: 6e6f 6d69 616c 5f64 6567 7265 650a 2020  nomial_degree.  
+000032e0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+000032f0: 7574 696c 5f62 6c6f 636b 2e6e 6f6e 6c69  util_block.nonli
+00003300: 6e65 6172 5f63 6f6e 7374 7261 696e 745f  near_constraint_
+00003310: 6c69 7374 203d 206c 6973 7428 0a20 2020  list = list(.   
+00003320: 2020 2020 2020 2020 2063 0a20 2020 2020           c.     
+00003330: 2020 2020 2020 2066 6f72 2063 2069 6e20         for c in 
+00003340: 7574 696c 5f62 6c6f 636b 2e63 6f6e 7374  util_block.const
+00003350: 7261 696e 745f 6c69 7374 0a20 2020 2020  raint_list.     
+00003360: 2020 2020 2020 2069 6620 632e 626f 6479         if c.body
+00003370: 2e70 6f6c 796e 6f6d 6961 6c5f 6465 6772  .polynomial_degr
+00003380: 6565 2829 206e 6f74 2069 6e20 7365 6c66  ee() not in self
+00003390: 2e6d 6970 5f63 6f6e 7374 7261 696e 745f  .mip_constraint_
+000033a0: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+000033b0: 650a 2020 2020 2020 2020 290a 2020 2020  e.        ).    
+000033c0: 2020 2020 7574 696c 5f62 6c6f 636b 2e6f      util_block.o
+000033d0: 626a 6563 7469 7665 5f6c 6973 7420 3d20  bjective_list = 
+000033e0: 6c69 7374 280a 2020 2020 2020 2020 2020  list(.          
+000033f0: 2020 6d6f 6465 6c2e 636f 6d70 6f6e 656e    model.componen
+00003400: 745f 6461 7461 5f6f 626a 6563 7473 280a  t_data_objects(.
+00003410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00003420: 6374 7970 653d 4f62 6a65 6374 6976 652c  ctype=Objective,
+00003430: 2061 6374 6976 653d 5472 7565 2c20 6465   active=True, de
+00003440: 7363 656e 645f 696e 746f 3d28 426c 6f63  scend_into=(Bloc
+00003450: 6b29 0a20 2020 2020 2020 2020 2020 2029  k).            )
+00003460: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+00003470: 2020 2020 2320 4964 656e 7469 6679 2074      # Identify t
+00003480: 6865 206e 6f6e 2d66 6978 6564 2076 6172  he non-fixed var
+00003490: 6961 626c 6573 2069 6e20 2870 6f74 656e  iables in (poten
+000034a0: 7469 616c 6c79 2920 6163 7469 7665 2063  tially) active c
+000034b0: 6f6e 7374 7261 696e 7473 2061 6e64 0a20  onstraints and. 
+000034c0: 2020 2020 2020 2023 206f 626a 6563 7469         # objecti
+000034d0: 7665 2066 756e 6374 696f 6e73 0a20 2020  ve functions.   
+000034e0: 2020 2020 2066 6f72 2063 6f6e 7374 7220       for constr 
+000034f0: 696e 2067 6574 6174 7472 2875 7469 6c5f  in getattr(util_
+00003500: 626c 6f63 6b2c 2027 636f 6e73 7472 6169  block, 'constrai
+00003510: 6e74 5f6c 6973 7427 293a 0a20 2020 2020  nt_list'):.     
+00003520: 2020 2020 2020 2066 6f72 2076 2069 6e20         for v in 
+00003530: 4558 5052 2e69 6465 6e74 6966 795f 7661  EXPR.identify_va
+00003540: 7269 6162 6c65 7328 636f 6e73 7472 2e62  riables(constr.b
+00003550: 6f64 792c 2069 6e63 6c75 6465 5f66 6978  ody, include_fix
+00003560: 6564 3d46 616c 7365 293a 0a20 2020 2020  ed=False):.     
+00003570: 2020 2020 2020 2020 2020 2076 6172 5f73             var_s
+00003580: 6574 2e61 6464 2876 290a 2020 2020 2020  et.add(v).      
+00003590: 2020 666f 7220 6f62 6a20 696e 206d 6f64    for obj in mod
+000035a0: 656c 2e63 6f6d 706f 6e65 6e74 5f64 6174  el.component_dat
+000035b0: 615f 6f62 6a65 6374 7328 6374 7970 653d  a_objects(ctype=
+000035c0: 4f62 6a65 6374 6976 652c 2061 6374 6976  Objective, activ
+000035d0: 653d 5472 7565 293a 0a20 2020 2020 2020  e=True):.       
+000035e0: 2020 2020 2066 6f72 2076 2069 6e20 4558       for v in EX
+000035f0: 5052 2e69 6465 6e74 6966 795f 7661 7269  PR.identify_vari
+00003600: 6162 6c65 7328 6f62 6a2e 6578 7072 2c20  ables(obj.expr, 
+00003610: 696e 636c 7564 655f 6669 7865 643d 4661  include_fixed=Fa
+00003620: 6c73 6529 3a0a 2020 2020 2020 2020 2020  lse):.          
+00003630: 2020 2020 2020 7661 725f 7365 742e 6164        var_set.ad
+00003640: 6428 7629 0a0a 2020 2020 2020 2020 2320  d(v)..        # 
+00003650: 5765 2075 7365 2063 6f6d 706f 6e65 6e74  We use component
+00003660: 5f64 6174 615f 6f62 6a65 6374 7320 7261  _data_objects ra
+00003670: 7468 6572 2074 6861 6e20 6c69 7374 2876  ther than list(v
+00003680: 6172 5f73 6574 2920 696e 206f 7264 6572  ar_set) in order
+00003690: 2074 6f0a 2020 2020 2020 2020 2320 7072   to.        # pr
+000036a0: 6573 6572 7665 2061 2064 6574 6572 6d69  eserve a determi
+000036b0: 6e69 7374 6963 206f 7264 6572 696e 672e  nistic ordering.
+000036c0: 0a20 2020 2020 2020 2069 6620 6567 625f  .        if egb_
+000036d0: 6176 6169 6c61 626c 653a 0a20 2020 2020  available:.     
+000036e0: 2020 2020 2020 2075 7469 6c5f 626c 6f63         util_bloc
+000036f0: 6b2e 7661 7269 6162 6c65 5f6c 6973 7420  k.variable_list 
+00003700: 3d20 6c69 7374 280a 2020 2020 2020 2020  = list(.        
+00003710: 2020 2020 2020 2020 760a 2020 2020 2020          v.      
+00003720: 2020 2020 2020 2020 2020 666f 7220 7620            for v 
+00003730: 696e 206d 6f64 656c 2e63 6f6d 706f 6e65  in model.compone
+00003740: 6e74 5f64 6174 615f 6f62 6a65 6374 7328  nt_data_objects(
+00003750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00003760: 2020 2020 2063 7479 7065 3d56 6172 2c20       ctype=Var, 
+00003770: 6465 7363 656e 645f 696e 746f 3d28 426c  descend_into=(Bl
+00003780: 6f63 6b2c 2065 6762 2e45 7874 6572 6e61  ock, egb.Externa
+00003790: 6c47 7265 7942 6f78 426c 6f63 6b29 0a20  lGreyBoxBlock). 
+000037a0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+000037b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000037c0: 2069 6620 7620 696e 2076 6172 5f73 6574   if v in var_set
+000037d0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+000037e0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000037f0: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
+00003800: 6f63 6b2e 7661 7269 6162 6c65 5f6c 6973  ock.variable_lis
+00003810: 7420 3d20 6c69 7374 280a 2020 2020 2020  t = list(.      
+00003820: 2020 2020 2020 2020 2020 760a 2020 2020            v.    
+00003830: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00003840: 7620 696e 206d 6f64 656c 2e63 6f6d 706f  v in model.compo
+00003850: 6e65 6e74 5f64 6174 615f 6f62 6a65 6374  nent_data_object
+00003860: 7328 6374 7970 653d 5661 722c 2064 6573  s(ctype=Var, des
+00003870: 6365 6e64 5f69 6e74 6f3d 2842 6c6f 636b  cend_into=(Block
+00003880: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00003890: 2020 2069 6620 7620 696e 2076 6172 5f73     if v in var_s
+000038a0: 6574 0a20 2020 2020 2020 2020 2020 2029  et.            )
+000038b0: 0a20 2020 2020 2020 2075 7469 6c5f 626c  .        util_bl
+000038c0: 6f63 6b2e 6469 7363 7265 7465 5f76 6172  ock.discrete_var
+000038d0: 6961 626c 655f 6c69 7374 203d 206c 6973  iable_list = lis
+000038e0: 7428 0a20 2020 2020 2020 2020 2020 2076  t(.            v
+000038f0: 2066 6f72 2076 2069 6e20 7574 696c 5f62   for v in util_b
+00003900: 6c6f 636b 2e76 6172 6961 626c 655f 6c69  lock.variable_li
+00003910: 7374 2069 6620 7620 696e 2076 6172 5f73  st if v in var_s
+00003920: 6574 2061 6e64 2076 2e69 735f 696e 7465  et and v.is_inte
+00003930: 6765 7228 290a 2020 2020 2020 2020 290a  ger().        ).
+00003940: 2020 2020 2020 2020 7574 696c 5f62 6c6f          util_blo
+00003950: 636b 2e63 6f6e 7469 6e75 6f75 735f 7661  ck.continuous_va
+00003960: 7269 6162 6c65 5f6c 6973 7420 3d20 6c69  riable_list = li
+00003970: 7374 280a 2020 2020 2020 2020 2020 2020  st(.            
+00003980: 7620 666f 7220 7620 696e 2075 7469 6c5f  v for v in util_
+00003990: 626c 6f63 6b2e 7661 7269 6162 6c65 5f6c  block.variable_l
+000039a0: 6973 7420 6966 2076 2069 6e20 7661 725f  ist if v in var_
+000039b0: 7365 7420 616e 6420 762e 6973 5f63 6f6e  set and v.is_con
+000039c0: 7469 6e75 6f75 7328 290a 2020 2020 2020  tinuous().      
+000039d0: 2020 290a 0a20 2020 2064 6566 2061 6464    )..    def add
+000039e0: 5f63 7574 735f 636f 6d70 6f6e 656e 7473  _cuts_components
+000039f0: 2873 656c 662c 206d 6f64 656c 293a 0a20  (self, model):. 
+00003a00: 2020 2020 2020 2063 6f6e 6669 6720 3d20         config = 
+00003a10: 7365 6c66 2e63 6f6e 6669 670a 2020 2020  self.config.    
+00003a20: 2020 2020 4d69 6e64 7450 7920 3d20 6d6f      MindtPy = mo
+00003a30: 6465 6c2e 4d69 6e64 7450 795f 7574 696c  del.MindtPy_util
+00003a40: 730a 0a20 2020 2020 2020 2023 2043 7265  s..        # Cre
+00003a50: 6174 6520 6120 6d6f 6465 6c20 626c 6f63  ate a model bloc
+00003a60: 6b20 696e 2077 6869 6368 2074 6f20 7374  k in which to st
+00003a70: 6f72 6520 7468 6520 6765 6e65 7261 7465  ore the generate
+00003a80: 6420 6665 6173 6962 696c 6974 790a 2020  d feasibility.  
+00003a90: 2020 2020 2020 2320 736c 6163 6b20 636f        # slack co
+00003aa0: 6e73 7472 6169 6e74 732e 2044 6f20 6e6f  nstraints. Do no
+00003ab0: 7420 6c65 6176 6520 7468 6520 636f 6e73  t leave the cons
+00003ac0: 7472 6169 6e74 7320 6f6e 2062 7920 6465  traints on by de
+00003ad0: 6661 756c 742e 0a20 2020 2020 2020 2066  fault..        f
+00003ae0: 6561 7320 3d20 4d69 6e64 7450 792e 6665  eas = MindtPy.fe
+00003af0: 6173 5f6f 7074 203d 2042 6c6f 636b 2829  as_opt = Block()
+00003b00: 0a20 2020 2020 2020 2066 6561 732e 6465  .        feas.de
+00003b10: 6163 7469 7661 7465 2829 0a20 2020 2020  activate().     
+00003b20: 2020 2066 6561 732e 6665 6173 5f63 6f6e     feas.feas_con
+00003b30: 7374 7261 696e 7473 203d 2043 6f6e 7374  straints = Const
+00003b40: 7261 696e 744c 6973 7428 646f 633d 2746  raintList(doc='F
+00003b50: 6561 7369 6269 6c69 7479 2050 726f 626c  easibility Probl
+00003b60: 656d 2043 6f6e 7374 7261 696e 7473 2729  em Constraints')
+00003b70: 0a0a 2020 2020 2020 2020 2320 4372 6561  ..        # Crea
+00003b80: 7465 2061 206d 6f64 656c 2062 6c6f 636b  te a model block
+00003b90: 2069 6e20 7768 6963 6820 746f 2073 746f   in which to sto
+00003ba0: 7265 2074 6865 2067 656e 6572 6174 6564  re the generated
+00003bb0: 206c 696e 6561 720a 2020 2020 2020 2020   linear.        
+00003bc0: 2320 636f 6e73 7472 6169 6e74 732e 2044  # constraints. D
+00003bd0: 6f20 6e6f 7420 6c65 6176 6520 7468 6520  o not leave the 
+00003be0: 636f 6e73 7472 6169 6e74 7320 6f6e 2062  constraints on b
+00003bf0: 7920 6465 6661 756c 742e 0a20 2020 2020  y default..     
+00003c00: 2020 206c 696e 203d 204d 696e 6474 5079     lin = MindtPy
+00003c10: 2e63 7574 7320 3d20 426c 6f63 6b28 290a  .cuts = Block().
+00003c20: 2020 2020 2020 2020 6c69 6e2e 6465 6163          lin.deac
+00003c30: 7469 7661 7465 2829 0a0a 2020 2020 2020  tivate()..      
+00003c40: 2020 2320 6e6f 2d67 6f6f 6420 6375 7473    # no-good cuts
+00003c50: 2065 7863 6c75 6465 2070 6172 7469 6375   exclude particu
+00003c60: 6c61 7220 6469 7363 7265 7465 2064 6563  lar discrete dec
+00003c70: 6973 696f 6e73 0a20 2020 2020 2020 206c  isions.        l
+00003c80: 696e 2e6e 6f5f 676f 6f64 5f63 7574 7320  in.no_good_cuts 
+00003c90: 3d20 436f 6e73 7472 6169 6e74 4c69 7374  = ConstraintList
+00003ca0: 2864 6f63 3d27 6e6f 2d67 6f6f 6420 6375  (doc='no-good cu
+00003cb0: 7473 2729 0a20 2020 2020 2020 2023 2046  ts').        # F
+00003cc0: 6561 7369 626c 6520 6e6f 2d67 6f6f 6420  easible no-good 
+00003cd0: 6375 7473 2065 7863 6c75 6465 2064 6973  cuts exclude dis
+00003ce0: 6372 6574 6520 7265 616c 697a 6174 696f  crete realizatio
+00003cf0: 6e73 2074 6861 7420 6861 7665 0a20 2020  ns that have.   
+00003d00: 2020 2020 2023 2062 6565 6e20 6578 706c       # been expl
+00003d10: 6f72 6564 2076 6961 2061 6e20 4e4c 5020  ored via an NLP 
+00003d20: 7375 6270 726f 626c 656d 2e20 4465 7065  subproblem. Depe
+00003d30: 6e64 696e 6720 6f6e 206d 6f64 656c 0a20  nding on model. 
+00003d40: 2020 2020 2020 2023 2063 6861 7261 6374         # charact
+00003d50: 6572 6973 7469 6373 2c20 7468 6520 7573  eristics, the us
+00003d60: 6572 206d 6179 2077 6973 6820 746f 2072  er may wish to r
+00003d70: 6576 6973 6974 204e 4c50 2073 7562 7072  evisit NLP subpr
+00003d80: 6f62 6c65 6d73 0a20 2020 2020 2020 2023  oblems.        #
+00003d90: 2028 7769 7468 2061 2064 6966 6665 7265   (with a differe
+00003da0: 6e74 2069 6e69 7469 616c 697a 6174 696f  nt initializatio
+00003db0: 6e2c 2066 6f72 2065 7861 6d70 6c65 292e  n, for example).
+00003dc0: 2054 6865 7265 666f 7265 2c20 7468 6573   Therefore, thes
+00003dd0: 650a 2020 2020 2020 2020 2320 6375 7473  e.        # cuts
+00003de0: 2061 7265 206e 6f74 2065 6e61 626c 6564   are not enabled
+00003df0: 2062 7920 6465 6661 756c 742e 0a0a 2020   by default...  
+00003e00: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+00003e10: 6665 6173 6962 696c 6974 795f 6e6f 726d  feasibility_norm
+00003e20: 203d 3d20 274c 3127 206f 7220 636f 6e66   == 'L1' or conf
+00003e30: 6967 2e66 6561 7369 6269 6c69 7479 5f6e  ig.feasibility_n
+00003e40: 6f72 6d20 3d3d 2027 4c32 273a 0a20 2020  orm == 'L2':.   
+00003e50: 2020 2020 2020 2020 2066 6561 732e 6e6c           feas.nl
+00003e60: 5f63 6f6e 7374 7261 696e 745f 7365 7420  _constraint_set 
+00003e70: 3d20 5261 6e67 6553 6574 280a 2020 2020  = RangeSet(.    
+00003e80: 2020 2020 2020 2020 2020 2020 6c65 6e28              len(
+00003e90: 4d69 6e64 7450 792e 6e6f 6e6c 696e 6561  MindtPy.nonlinea
+00003ea0: 725f 636f 6e73 7472 6169 6e74 5f6c 6973  r_constraint_lis
+00003eb0: 7429 2c0a 2020 2020 2020 2020 2020 2020  t),.            
+00003ec0: 2020 2020 646f 633d 2749 6e74 6567 6572      doc='Integer
+00003ed0: 2069 6e64 6578 2073 6574 206f 7665 7220   index set over 
+00003ee0: 7468 6520 6e6f 6e6c 696e 6561 7220 636f  the nonlinear co
+00003ef0: 6e73 7472 6169 6e74 732e 272c 0a20 2020  nstraints.',.   
+00003f00: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00003f10: 2020 2020 2020 2023 2043 7265 6174 6520         # Create 
+00003f20: 736c 6163 6b20 7661 7269 6162 6c65 7320  slack variables 
+00003f30: 666f 7220 6665 6173 6962 696c 6974 7920  for feasibility 
+00003f40: 7072 6f62 6c65 6d0a 2020 2020 2020 2020  problem.        
+00003f50: 2020 2020 6665 6173 2e73 6c61 636b 5f76      feas.slack_v
+00003f60: 6172 203d 2056 6172 280a 2020 2020 2020  ar = Var(.      
+00003f70: 2020 2020 2020 2020 2020 6665 6173 2e6e            feas.n
+00003f80: 6c5f 636f 6e73 7472 6169 6e74 5f73 6574  l_constraint_set
+00003f90: 2c20 646f 6d61 696e 3d4e 6f6e 4e65 6761  , domain=NonNega
+00003fa0: 7469 7665 5265 616c 732c 2069 6e69 7469  tiveReals, initi
+00003fb0: 616c 697a 653d 310a 2020 2020 2020 2020  alize=1.        
+00003fc0: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+00003fd0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00003fe0: 6665 6173 2e73 6c61 636b 5f76 6172 203d  feas.slack_var =
+00003ff0: 2056 6172 2864 6f6d 6169 6e3d 4e6f 6e4e   Var(domain=NonN
+00004000: 6567 6174 6976 6552 6561 6c73 2c20 696e  egativeReals, in
+00004010: 6974 6961 6c69 7a65 3d31 290a 0a20 2020  itialize=1)..   
+00004020: 2020 2020 2023 2043 7265 6174 6520 736c       # Create sl
+00004030: 6163 6b20 7661 7269 6162 6c65 7320 666f  ack variables fo
+00004040: 7220 4f41 2063 7574 730a 2020 2020 2020  r OA cuts.      
+00004050: 2020 6966 2063 6f6e 6669 672e 6164 645f    if config.add_
+00004060: 736c 6163 6b3a 0a20 2020 2020 2020 2020  slack:.         
+00004070: 2020 206c 696e 2e73 6c61 636b 5f76 6172     lin.slack_var
+00004080: 7320 3d20 5661 724c 6973 7428 0a20 2020  s = VarList(.   
+00004090: 2020 2020 2020 2020 2020 2020 2062 6f75               bou
+000040a0: 6e64 733d 2830 2c20 636f 6e66 6967 2e6d  nds=(0, config.m
+000040b0: 6178 5f73 6c61 636b 292c 2069 6e69 7469  ax_slack), initi
+000040c0: 616c 697a 653d 302c 2064 6f6d 6169 6e3d  alize=0, domain=
+000040d0: 4e6f 6e4e 6567 6174 6976 6552 6561 6c73  NonNegativeReals
+000040e0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+000040f0: 2020 2020 6465 6620 6765 745f 6475 616c      def get_dual
+00004100: 5f69 6e74 6567 7261 6c28 7365 6c66 293a  _integral(self):
+00004110: 0a20 2020 2020 2020 2022 2222 4361 6c63  .        """Calc
+00004120: 756c 6174 6520 7468 6520 6475 616c 2069  ulate the dual i
+00004130: 6e74 6567 7261 6c2e 0a20 2020 2020 2020  ntegral..       
+00004140: 2052 6566 3a20 5468 6520 636f 6e66 696e   Ref: The confin
+00004150: 6564 2070 7269 6d61 6c20 696e 7465 6772  ed primal integr
+00004160: 616c 2e20 5b68 7474 703a 2f2f 7777 772e  al. [http://www.
+00004170: 6f70 7469 6d69 7a61 7469 6f6e 2d6f 6e6c  optimization-onl
+00004180: 696e 652e 6f72 672f 4442 5f46 494c 452f  ine.org/DB_FILE/
+00004190: 3230 3230 2f30 372f 3739 3130 2e70 6466  2020/07/7910.pdf
+000041a0: 5d0a 0a20 2020 2020 2020 2052 6574 7572  ]..        Retur
+000041b0: 6e73 0a20 2020 2020 2020 202d 2d2d 2d2d  ns.        -----
+000041c0: 2d2d 0a20 2020 2020 2020 2066 6c6f 6174  --.        float
+000041d0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+000041e0: 2064 7561 6c20 696e 7465 6772 616c 2e0a   dual integral..
+000041f0: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
+00004200: 2020 2020 6475 616c 5f69 6e74 6567 7261      dual_integra
+00004210: 6c20 3d20 300a 2020 2020 2020 2020 6475  l = 0.        du
+00004220: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
+00004230: 7320 3d20 7365 6c66 2e64 7561 6c5f 626f  s = self.dual_bo
+00004240: 756e 645f 7072 6f67 7265 7373 2e63 6f70  und_progress.cop
+00004250: 7928 290a 2020 2020 2020 2020 2320 496e  y().        # In
+00004260: 6974 6961 6c20 6475 616c 2062 6f75 6e64  itial dual bound
+00004270: 2069 7320 7365 7420 746f 2069 6e66 206f   is set to inf o
+00004280: 7220 2d69 6e66 2e20 546f 2063 616c 6375  r -inf. To calcu
+00004290: 6c61 7465 2064 7561 6c20 696e 7465 6772  late dual integr
+000042a0: 616c 2c20 7765 2073 6574 0a20 2020 2020  al, we set.     
+000042b0: 2020 2023 2069 6e69 7469 616c 5f64 7561     # initial_dua
+000042c0: 6c5f 626f 756e 6420 746f 2031 3025 2067  l_bound to 10% g
+000042d0: 7265 6174 6572 206f 7220 736d 616c 6c65  reater or smalle
+000042e0: 7220 7468 616e 2074 6865 2066 6972 7374  r than the first
+000042f0: 5f66 6f75 6e64 5f64 7561 6c5f 626f 756e  _found_dual_boun
+00004300: 642e 0a20 2020 2020 2020 2023 2054 4f44  d..        # TOD
+00004310: 4f3a 2063 6865 636b 2069 6620 7468 6520  O: check if the 
+00004320: 6361 6c63 756c 6174 696f 6e20 6f66 2069  calculation of i
+00004330: 6e69 7469 616c 5f64 7561 6c5f 626f 756e  nitial_dual_boun
+00004340: 6420 6e65 6564 7320 746f 2062 6520 6d6f  d needs to be mo
+00004350: 6469 6669 6564 2e0a 2020 2020 2020 2020  dified..        
+00004360: 666f 7220 6475 616c 5f62 6f75 6e64 2069  for dual_bound i
+00004370: 6e20 6475 616c 5f62 6f75 6e64 5f70 726f  n dual_bound_pro
+00004380: 6772 6573 733a 0a20 2020 2020 2020 2020  gress:.         
+00004390: 2020 2069 6620 6475 616c 5f62 6f75 6e64     if dual_bound
+000043a0: 2021 3d20 6475 616c 5f62 6f75 6e64 5f70   != dual_bound_p
+000043b0: 726f 6772 6573 735b 305d 3a0a 2020 2020  rogress[0]:.    
+000043c0: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+000043d0: 6b0a 2020 2020 2020 2020 666f 7220 6920  k.        for i 
+000043e0: 696e 2072 616e 6765 286c 656e 2864 7561  in range(len(dua
+000043f0: 6c5f 626f 756e 645f 7072 6f67 7265 7373  l_bound_progress
+00004400: 2929 3a0a 2020 2020 2020 2020 2020 2020  )):.            
+00004410: 6966 2064 7561 6c5f 626f 756e 645f 7072  if dual_bound_pr
+00004420: 6f67 7265 7373 5b69 5d20 3d3d 2073 656c  ogress[i] == sel
+00004430: 662e 6475 616c 5f62 6f75 6e64 5f70 726f  f.dual_bound_pro
+00004440: 6772 6573 735b 305d 3a0a 2020 2020 2020  gress[0]:.      
+00004450: 2020 2020 2020 2020 2020 6475 616c 5f62            dual_b
+00004460: 6f75 6e64 5f70 726f 6772 6573 735b 695d  ound_progress[i]
+00004470: 203d 2064 7561 6c5f 626f 756e 6420 2a20   = dual_bound * 
+00004480: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00004490: 2020 2020 2020 310a 2020 2020 2020 2020        1.        
+000044a0: 2020 2020 2020 2020 2020 2020 2d20 7365              - se
+000044b0: 6c66 2e63 6f6e 6669 672e 696e 6974 6961  lf.config.initia
+000044c0: 6c5f 626f 756e 645f 636f 6566 0a20 2020  l_bound_coef.   
+000044d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000044e0: 202a 2073 656c 662e 6f62 6a65 6374 6976   * self.objectiv
+000044f0: 655f 7365 6e73 650a 2020 2020 2020 2020  e_sense.        
+00004500: 2020 2020 2020 2020 2020 2020 2a20 6d61              * ma
+00004510: 7468 2e63 6f70 7973 6967 6e28 312c 2064  th.copysign(1, d
+00004520: 7561 6c5f 626f 756e 6429 0a20 2020 2020  ual_bound).     
+00004530: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00004540: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+00004550: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00004560: 7265 616b 0a20 2020 2020 2020 2066 6f72  reak.        for
+00004570: 2069 2069 6e20 7261 6e67 6528 6c65 6e28   i in range(len(
+00004580: 6475 616c 5f62 6f75 6e64 5f70 726f 6772  dual_bound_progr
+00004590: 6573 7329 293a 0a20 2020 2020 2020 2020  ess)):.         
+000045a0: 2020 2069 6620 6920 3d3d 2030 3a0a 2020     if i == 0:.  
+000045b0: 2020 2020 2020 2020 2020 2020 2020 6475                du
+000045c0: 616c 5f69 6e74 6567 7261 6c20 2b3d 2061  al_integral += a
+000045d0: 6273 2864 7561 6c5f 626f 756e 645f 7072  bs(dual_bound_pr
+000045e0: 6f67 7265 7373 5b69 5d20 2d20 7365 6c66  ogress[i] - self
+000045f0: 2e64 7561 6c5f 626f 756e 6429 202a 2028  .dual_bound) * (
+00004600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00004610: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
+00004620: 6f75 6e64 5f70 726f 6772 6573 735f 7469  ound_progress_ti
+00004630: 6d65 5b69 5d0a 2020 2020 2020 2020 2020  me[i].          
+00004640: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00004650: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00004660: 2020 2020 2020 2020 2020 6475 616c 5f69            dual_i
+00004670: 6e74 6567 7261 6c20 2b3d 2061 6273 2864  ntegral += abs(d
+00004680: 7561 6c5f 626f 756e 645f 7072 6f67 7265  ual_bound_progre
+00004690: 7373 5b69 5d20 2d20 7365 6c66 2e64 7561  ss[i] - self.dua
+000046a0: 6c5f 626f 756e 6429 202a 2028 0a20 2020  l_bound) * (.   
+000046b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000046c0: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+000046d0: 5f70 726f 6772 6573 735f 7469 6d65 5b69  _progress_time[i
+000046e0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000046f0: 2020 2020 2020 2d20 7365 6c66 2e64 7561        - self.dua
+00004700: 6c5f 626f 756e 645f 7072 6f67 7265 7373  l_bound_progress
+00004710: 5f74 696d 655b 6920 2d20 315d 0a20 2020  _time[i - 1].   
+00004720: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00004730: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
+00004740: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
+00004750: 2020 2020 2020 2020 2020 2020 2720 7b3a              ' {:
+00004760: 3c32 357d 3a20 2020 7b3a 3e37 2e34 667d  <25}:   {:>7.4f}
+00004770: 2027 2e66 6f72 6d61 7428 2744 7561 6c20   '.format('Dual 
+00004780: 696e 7465 6772 616c 272c 2064 7561 6c5f  integral', dual_
+00004790: 696e 7465 6772 616c 290a 2020 2020 2020  integral).      
+000047a0: 2020 290a 2020 2020 2020 2020 7265 7475    ).        retu
+000047b0: 726e 2064 7561 6c5f 696e 7465 6772 616c  rn dual_integral
+000047c0: 0a0a 2020 2020 6465 6620 6765 745f 7072  ..    def get_pr
+000047d0: 696d 616c 5f69 6e74 6567 7261 6c28 7365  imal_integral(se
+000047e0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
+000047f0: 4361 6c63 756c 6174 6520 7468 6520 7072  Calculate the pr
+00004800: 696d 616c 2069 6e74 6567 7261 6c2e 0a20  imal integral.. 
+00004810: 2020 2020 2020 2052 6566 3a20 5468 6520         Ref: The 
+00004820: 636f 6e66 696e 6564 2070 7269 6d61 6c20  confined primal 
+00004830: 696e 7465 6772 616c 2e20 5b68 7474 703a  integral. [http:
+00004840: 2f2f 7777 772e 6f70 7469 6d69 7a61 7469  //www.optimizati
+00004850: 6f6e 2d6f 6e6c 696e 652e 6f72 672f 4442  on-online.org/DB
+00004860: 5f46 494c 452f 3230 3230 2f30 372f 3739  _FILE/2020/07/79
+00004870: 3130 2e70 6466 5d0a 0a20 2020 2020 2020  10.pdf]..       
+00004880: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+00004890: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
+000048a0: 2066 6c6f 6174 0a20 2020 2020 2020 2020   float.         
+000048b0: 2020 2054 6865 2070 7269 6d61 6c20 696e     The primal in
+000048c0: 7465 6772 616c 2e0a 2020 2020 2020 2020  tegral..        
+000048d0: 2222 220a 2020 2020 2020 2020 7072 696d  """.        prim
+000048e0: 616c 5f69 6e74 6567 7261 6c20 3d20 300a  al_integral = 0.
+000048f0: 2020 2020 2020 2020 7072 696d 616c 5f62          primal_b
+00004900: 6f75 6e64 5f70 726f 6772 6573 7320 3d20  ound_progress = 
+00004910: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
+00004920: 645f 7072 6f67 7265 7373 2e63 6f70 7928  d_progress.copy(
+00004930: 290a 2020 2020 2020 2020 2320 496e 6974  ).        # Init
+00004940: 6961 6c20 7072 696d 616c 2062 6f75 6e64  ial primal bound
+00004950: 2069 7320 7365 7420 746f 2069 6e66 206f   is set to inf o
+00004960: 7220 2d69 6e66 2e20 546f 2063 616c 6375  r -inf. To calcu
+00004970: 6c61 7465 2070 7269 6d61 6c20 696e 7465  late primal inte
+00004980: 6772 616c 2c20 7765 2073 6574 0a20 2020  gral, we set.   
+00004990: 2020 2020 2023 2069 6e69 7469 616c 5f70       # initial_p
+000049a0: 7269 6d61 6c5f 626f 756e 6420 746f 2031  rimal_bound to 1
+000049b0: 3025 2067 7265 6174 6572 206f 7220 736d  0% greater or sm
+000049c0: 616c 6c65 7220 7468 616e 2074 6865 2066  aller than the f
+000049d0: 6972 7374 5f66 6f75 6e64 5f70 7269 6d61  irst_found_prima
+000049e0: 6c5f 626f 756e 642e 0a20 2020 2020 2020  l_bound..       
+000049f0: 2023 2054 4f44 4f3a 2063 6865 636b 2069   # TODO: check i
+00004a00: 6620 7468 6520 6361 6c63 756c 6174 696f  f the calculatio
+00004a10: 6e20 6f66 2069 6e69 7469 616c 5f70 7269  n of initial_pri
+00004a20: 6d61 6c5f 626f 756e 6420 6e65 6564 7320  mal_bound needs 
+00004a30: 746f 2062 6520 6d6f 6469 6669 6564 2e0a  to be modified..
+00004a40: 2020 2020 2020 2020 666f 7220 7072 696d          for prim
+00004a50: 616c 5f62 6f75 6e64 2069 6e20 7072 696d  al_bound in prim
+00004a60: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
+00004a70: 733a 0a20 2020 2020 2020 2020 2020 2069  s:.            i
+00004a80: 6620 7072 696d 616c 5f62 6f75 6e64 2021  f primal_bound !
+00004a90: 3d20 7072 696d 616c 5f62 6f75 6e64 5f70  = primal_bound_p
+00004aa0: 726f 6772 6573 735b 305d 3a0a 2020 2020  rogress[0]:.    
+00004ab0: 2020 2020 2020 2020 2020 2020 6272 6561              brea
+00004ac0: 6b0a 2020 2020 2020 2020 666f 7220 6920  k.        for i 
+00004ad0: 696e 2072 616e 6765 286c 656e 2870 7269  in range(len(pri
+00004ae0: 6d61 6c5f 626f 756e 645f 7072 6f67 7265  mal_bound_progre
+00004af0: 7373 2929 3a0a 2020 2020 2020 2020 2020  ss)):.          
+00004b00: 2020 6966 2070 7269 6d61 6c5f 626f 756e    if primal_boun
+00004b10: 645f 7072 6f67 7265 7373 5b69 5d20 3d3d  d_progress[i] ==
+00004b20: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
+00004b30: 6e64 5f70 726f 6772 6573 735b 305d 3a0a  nd_progress[0]:.
 00004b40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00004b50: 2020 310a 2020 2020 2020 2020 2020 2020    1.            
-00004b60: 2020 2020 2020 2020 2b20 7365 6c66 2e63          + self.c
-00004b70: 6f6e 6669 672e 696e 6974 6961 6c5f 626f  onfig.initial_bo
-00004b80: 756e 645f 636f 6566 0a20 2020 2020 2020  und_coef.       
-00004b90: 2020 2020 2020 2020 2020 2020 202a 2073               * s
-00004ba0: 656c 662e 6f62 6a65 6374 6976 655f 7365  elf.objective_se
-00004bb0: 6e73 650a 2020 2020 2020 2020 2020 2020  nse.            
-00004bc0: 2020 2020 2020 2020 2a20 6d61 7468 2e63          * math.c
-00004bd0: 6f70 7973 6967 6e28 312c 2070 7269 6d61  opysign(1, prima
-00004be0: 6c5f 626f 756e 6429 0a20 2020 2020 2020  l_bound).       
-00004bf0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00004c00: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00004c10: 2020 2020 2020 2020 2020 2020 2062 7265               bre
-00004c20: 616b 0a20 2020 2020 2020 2066 6f72 2069  ak.        for i
-00004c30: 2069 6e20 7261 6e67 6528 6c65 6e28 7072   in range(len(pr
-00004c40: 696d 616c 5f62 6f75 6e64 5f70 726f 6772  imal_bound_progr
-00004c50: 6573 7329 293a 0a20 2020 2020 2020 2020  ess)):.         
-00004c60: 2020 2069 6620 6920 3d3d 2030 3a0a 2020     if i == 0:.  
-00004c70: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00004c80: 696d 616c 5f69 6e74 6567 7261 6c20 2b3d  imal_integral +=
-00004c90: 2061 6273 2870 7269 6d61 6c5f 626f 756e   abs(primal_boun
-00004ca0: 645f 7072 6f67 7265 7373 5b69 5d20 2d20  d_progress[i] - 
-00004cb0: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
-00004cc0: 6429 202a 2028 0a20 2020 2020 2020 2020  d) * (.         
-00004cd0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00004ce0: 7072 696d 616c 5f62 6f75 6e64 5f70 726f  primal_bound_pro
-00004cf0: 6772 6573 735f 7469 6d65 5b69 5d0a 2020  gress_time[i].  
-00004d00: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00004d10: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00004d20: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00004d30: 2020 7072 696d 616c 5f69 6e74 6567 7261    primal_integra
-00004d40: 6c20 2b3d 2061 6273 2870 7269 6d61 6c5f  l += abs(primal_
-00004d50: 626f 756e 645f 7072 6f67 7265 7373 5b69  bound_progress[i
-00004d60: 5d20 2d20 7365 6c66 2e70 7269 6d61 6c5f  ] - self.primal_
-00004d70: 626f 756e 6429 202a 2028 0a20 2020 2020  bound) * (.     
-00004d80: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00004d90: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
-00004da0: 5f70 726f 6772 6573 735f 7469 6d65 5b69  _progress_time[i
-00004db0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
-00004dc0: 2020 2020 2020 2d20 7365 6c66 2e70 7269        - self.pri
-00004dd0: 6d61 6c5f 626f 756e 645f 7072 6f67 7265  mal_bound_progre
-00004de0: 7373 5f74 696d 655b 6920 2d20 315d 0a20  ss_time[i - 1]. 
-00004df0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00004e00: 0a0a 2020 2020 2020 2020 7365 6c66 2e63  ..        self.c
-00004e10: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
-00004e20: 6f28 0a20 2020 2020 2020 2020 2020 2027  o(.            '
-00004e30: 207b 3a3c 3235 7d3a 2020 207b 3a3e 372e   {:<25}:   {:>7.
-00004e40: 3466 7d20 272e 666f 726d 6174 2827 5072  4f} '.format('Pr
-00004e50: 696d 616c 2069 6e74 6567 7261 6c27 2c20  imal integral', 
-00004e60: 7072 696d 616c 5f69 6e74 6567 7261 6c29  primal_integral)
-00004e70: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-00004e80: 2020 2072 6574 7572 6e20 7072 696d 616c     return primal
-00004e90: 5f69 6e74 6567 7261 6c0a 0a20 2020 2064  _integral..    d
-00004ea0: 6566 2067 6574 5f69 6e74 6567 7261 6c5f  ef get_integral_
-00004eb0: 696e 666f 2873 656c 6629 3a0a 2020 2020  info(self):.    
-00004ec0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-00004ed0: 4f62 7461 696e 2070 7269 6d61 6c20 696e  Obtain primal in
-00004ee0: 7465 6772 616c 2c20 6475 616c 2069 6e74  tegral, dual int
-00004ef0: 6567 7261 6c20 616e 6420 7072 696d 616c  egral and primal
-00004f00: 2064 7561 6c20 6761 7020 696e 7465 6772   dual gap integr
-00004f10: 616c 2e0a 2020 2020 2020 2020 2222 220a  al..        """.
-00004f20: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
-00004f30: 6d61 6c5f 696e 7465 6772 616c 203d 2073  mal_integral = s
-00004f40: 656c 662e 6765 745f 7072 696d 616c 5f69  elf.get_primal_i
-00004f50: 6e74 6567 7261 6c28 290a 2020 2020 2020  ntegral().      
-00004f60: 2020 7365 6c66 2e64 7561 6c5f 696e 7465    self.dual_inte
-00004f70: 6772 616c 203d 2073 656c 662e 6765 745f  gral = self.get_
-00004f80: 6475 616c 5f69 6e74 6567 7261 6c28 290a  dual_integral().
-00004f90: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
-00004fa0: 6d61 6c5f 6475 616c 5f67 6170 5f69 6e74  mal_dual_gap_int
-00004fb0: 6567 7261 6c20 3d20 7365 6c66 2e70 7269  egral = self.pri
-00004fc0: 6d61 6c5f 696e 7465 6772 616c 202b 2073  mal_integral + s
-00004fd0: 656c 662e 6475 616c 5f69 6e74 6567 7261  elf.dual_integra
-00004fe0: 6c0a 0a20 2020 2064 6566 2075 7064 6174  l..    def updat
-00004ff0: 655f 6761 7028 7365 6c66 293a 0a20 2020  e_gap(self):.   
-00005000: 2020 2020 2022 2222 5570 6461 7465 2074       """Update t
-00005010: 6865 2072 656c 6174 6976 6520 6761 7020  he relative gap 
-00005020: 616e 6420 7468 6520 6162 736f 6c75 7465  and the absolute
-00005030: 2067 6170 2e22 2222 0a20 2020 2020 2020   gap.""".       
-00005040: 2069 6620 7365 6c66 2e6f 626a 6563 7469   if self.objecti
-00005050: 7665 5f73 656e 7365 203d 3d20 6d69 6e69  ve_sense == mini
-00005060: 6d69 7a65 3a0a 2020 2020 2020 2020 2020  mize:.          
-00005070: 2020 7365 6c66 2e61 6273 5f67 6170 203d    self.abs_gap =
-00005080: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
-00005090: 6e64 202d 2073 656c 662e 6475 616c 5f62  nd - self.dual_b
-000050a0: 6f75 6e64 0a20 2020 2020 2020 2065 6c73  ound.        els
-000050b0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-000050c0: 656c 662e 6162 735f 6761 7020 3d20 7365  elf.abs_gap = se
-000050d0: 6c66 2e64 7561 6c5f 626f 756e 6420 2d20  lf.dual_bound - 
-000050e0: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
-000050f0: 640a 2020 2020 2020 2020 7365 6c66 2e72  d.        self.r
-00005100: 656c 5f67 6170 203d 2073 656c 662e 6162  el_gap = self.ab
-00005110: 735f 6761 7020 2f20 2861 6273 2873 656c  s_gap / (abs(sel
-00005120: 662e 7072 696d 616c 5f62 6f75 6e64 2920  f.primal_bound) 
-00005130: 2b20 3165 2d31 3029 0a0a 2020 2020 6465  + 1e-10)..    de
-00005140: 6620 7570 6461 7465 5f64 7561 6c5f 626f  f update_dual_bo
-00005150: 756e 6428 7365 6c66 2c20 626f 756e 645f  und(self, bound_
-00005160: 7661 6c75 6529 3a0a 2020 2020 2020 2020  value):.        
-00005170: 2222 2255 7064 6174 6520 7468 6520 6475  """Update the du
-00005180: 616c 2062 6f75 6e64 2e0a 0a20 2020 2020  al bound...     
-00005190: 2020 2043 616c 6c20 6166 7465 7220 736f     Call after so
-000051a0: 6c76 696e 6720 7265 6c61 7865 6420 7072  lving relaxed pr
-000051b0: 6f62 6c65 6d2c 2069 6e63 6c75 6469 6e67  oblem, including
-000051c0: 2072 656c 6178 6564 204e 4c50 2061 6e64   relaxed NLP and
-000051d0: 204d 4950 206d 6169 6e20 7072 6f62 6c65   MIP main proble
-000051e0: 6d2e 0a20 2020 2020 2020 2055 7365 2074  m..        Use t
-000051f0: 6865 206f 7074 696d 616c 2070 7269 6d61  he optimal prima
-00005200: 6c20 626f 756e 6420 6f66 2074 6865 2072  l bound of the r
-00005210: 656c 6178 6564 2070 726f 626c 656d 2074  elaxed problem t
-00005220: 6f20 7570 6461 7465 2074 6865 2064 7561  o update the dua
-00005230: 6c20 626f 756e 642e 0a0a 2020 2020 2020  l bound...      
-00005240: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
-00005250: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
-00005260: 2020 2020 2020 2020 626f 756e 645f 7661          bound_va
-00005270: 6c75 6520 3a20 666c 6f61 740a 2020 2020  lue : float.    
-00005280: 2020 2020 2020 2020 5468 6520 696e 7075          The inpu
-00005290: 7420 7661 6c75 6520 7573 6564 2074 6f20  t value used to 
-000052a0: 7570 6461 7465 2074 6865 2064 7561 6c20  update the dual 
-000052b0: 626f 756e 642e 0a20 2020 2020 2020 2022  bound..        "
-000052c0: 2222 0a20 2020 2020 2020 2069 6620 6d61  "".        if ma
-000052d0: 7468 2e69 736e 616e 2862 6f75 6e64 5f76  th.isnan(bound_v
-000052e0: 616c 7565 293a 0a20 2020 2020 2020 2020  alue):.         
-000052f0: 2020 2072 6574 7572 6e0a 2020 2020 2020     return.      
-00005300: 2020 6966 2073 656c 662e 6f62 6a65 6374    if self.object
-00005310: 6976 655f 7365 6e73 6520 3d3d 206d 696e  ive_sense == min
-00005320: 696d 697a 653a 0a20 2020 2020 2020 2020  imize:.         
-00005330: 2020 2073 656c 662e 6475 616c 5f62 6f75     self.dual_bou
-00005340: 6e64 203d 206d 6178 2862 6f75 6e64 5f76  nd = max(bound_v
-00005350: 616c 7565 2c20 7365 6c66 2e64 7561 6c5f  alue, self.dual_
-00005360: 626f 756e 6429 0a20 2020 2020 2020 2020  bound).         
-00005370: 2020 2073 656c 662e 6475 616c 5f62 6f75     self.dual_bou
-00005380: 6e64 5f69 6d70 726f 7665 6420 3d20 7365  nd_improved = se
-00005390: 6c66 2e64 7561 6c5f 626f 756e 6420 3e20  lf.dual_bound > 
-000053a0: 7365 6c66 2e64 7561 6c5f 626f 756e 645f  self.dual_bound_
-000053b0: 7072 6f67 7265 7373 5b2d 315d 0a20 2020  progress[-1].   
-000053c0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-000053d0: 2020 2020 2020 2073 656c 662e 6475 616c         self.dual
-000053e0: 5f62 6f75 6e64 203d 206d 696e 2862 6f75  _bound = min(bou
-000053f0: 6e64 5f76 616c 7565 2c20 7365 6c66 2e64  nd_value, self.d
-00005400: 7561 6c5f 626f 756e 6429 0a20 2020 2020  ual_bound).     
-00005410: 2020 2020 2020 2073 656c 662e 6475 616c         self.dual
-00005420: 5f62 6f75 6e64 5f69 6d70 726f 7665 6420  _bound_improved 
-00005430: 3d20 7365 6c66 2e64 7561 6c5f 626f 756e  = self.dual_boun
-00005440: 6420 3c20 7365 6c66 2e64 7561 6c5f 626f  d < self.dual_bo
-00005450: 756e 645f 7072 6f67 7265 7373 5b2d 315d  und_progress[-1]
-00005460: 0a20 2020 2020 2020 2073 656c 662e 6475  .        self.du
-00005470: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
-00005480: 732e 6170 7065 6e64 2873 656c 662e 6475  s.append(self.du
-00005490: 616c 5f62 6f75 6e64 290a 2020 2020 2020  al_bound).      
-000054a0: 2020 7365 6c66 2e64 7561 6c5f 626f 756e    self.dual_boun
-000054b0: 645f 7072 6f67 7265 7373 5f74 696d 652e  d_progress_time.
-000054c0: 6170 7065 6e64 2867 6574 5f6d 6169 6e5f  append(get_main_
-000054d0: 656c 6170 7365 645f 7469 6d65 2873 656c  elapsed_time(sel
-000054e0: 662e 7469 6d69 6e67 2929 0a20 2020 2020  f.timing)).     
-000054f0: 2020 2069 6620 7365 6c66 2e64 7561 6c5f     if self.dual_
-00005500: 626f 756e 645f 696d 7072 6f76 6564 3a0a  bound_improved:.
-00005510: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00005520: 2e75 7064 6174 655f 6761 7028 290a 0a20  .update_gap().. 
-00005530: 2020 2064 6566 2075 7064 6174 655f 7375     def update_su
-00005540: 626f 7074 696d 616c 5f64 7561 6c5f 626f  boptimal_dual_bo
-00005550: 756e 6428 7365 6c66 2c20 7265 7375 6c74  und(self, result
-00005560: 7329 3a0a 2020 2020 2020 2020 2222 2249  s):.        """I
-00005570: 6620 7468 6520 7265 6c61 7865 6420 7072  f the relaxed pr
-00005580: 6f62 6c65 6d20 6973 206e 6f74 2073 6f6c  oblem is not sol
-00005590: 7665 6420 746f 206f 7074 696d 616c 6974  ved to optimalit
-000055a0: 792c 2074 6865 2064 7561 6c20 626f 756e  y, the dual boun
-000055b0: 6420 6973 2075 7064 6174 6564 0a20 2020  d is updated.   
-000055c0: 2020 2020 2061 6363 6f72 6469 6e67 2074       according t
-000055d0: 6f20 7468 6520 6475 616c 2062 6f75 6e64  o the dual bound
-000055e0: 206f 6620 7265 6c61 7865 6420 7072 6f62   of relaxed prob
-000055f0: 6c65 6d2e 0a0a 2020 2020 2020 2020 5061  lem...        Pa
-00005600: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
-00005610: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00005620: 2020 2020 7265 7375 6c74 7320 3a20 536f      results : So
-00005630: 6c76 6572 5265 7375 6c74 730a 2020 2020  lverResults.    
-00005640: 2020 2020 2020 2020 5265 7375 6c74 7320          Results 
-00005650: 6672 6f6d 2073 6f6c 7669 6e67 2074 6865  from solving the
-00005660: 2072 656c 6178 6564 2070 726f 626c 656d   relaxed problem
-00005670: 2e0a 2020 2020 2020 2020 2020 2020 5468  ..            Th
-00005680: 6520 6475 616c 2062 6f75 6e64 206f 6620  e dual bound of 
-00005690: 7468 6520 7265 6c61 7865 6420 7072 6f62  the relaxed prob
-000056a0: 6c65 6d20 6361 6e20 6f6e 6c79 2062 6520  lem can only be 
-000056b0: 6f62 7461 696e 6564 2066 726f 6d20 7468  obtained from th
-000056c0: 6520 7265 7375 6c74 206f 626a 6563 742e  e result object.
-000056d0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-000056e0: 2020 2020 2069 6620 7365 6c66 2e6f 626a       if self.obj
-000056f0: 6563 7469 7665 5f73 656e 7365 203d 3d20  ective_sense == 
-00005700: 6d69 6e69 6d69 7a65 3a0a 2020 2020 2020  minimize:.      
-00005710: 2020 2020 2020 626f 756e 645f 7661 6c75        bound_valu
-00005720: 6520 3d20 7265 7375 6c74 732e 7072 6f62  e = results.prob
-00005730: 6c65 6d2e 6c6f 7765 725f 626f 756e 640a  lem.lower_bound.
-00005740: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00005750: 2020 2020 2020 2020 2020 626f 756e 645f            bound_
-00005760: 7661 6c75 6520 3d20 7265 7375 6c74 732e  value = results.
-00005770: 7072 6f62 6c65 6d2e 7570 7065 725f 626f  problem.upper_bo
-00005780: 756e 640a 2020 2020 2020 2020 7365 6c66  und.        self
-00005790: 2e75 7064 6174 655f 6475 616c 5f62 6f75  .update_dual_bou
-000057a0: 6e64 2862 6f75 6e64 5f76 616c 7565 290a  nd(bound_value).
-000057b0: 0a20 2020 2064 6566 2075 7064 6174 655f  .    def update_
-000057c0: 7072 696d 616c 5f62 6f75 6e64 2873 656c  primal_bound(sel
-000057d0: 662c 2062 6f75 6e64 5f76 616c 7565 293a  f, bound_value):
-000057e0: 0a20 2020 2020 2020 2022 2222 5570 6461  .        """Upda
-000057f0: 7465 2074 6865 2070 7269 6d61 6c20 626f  te the primal bo
-00005800: 756e 642e 0a0a 2020 2020 2020 2020 4361  und...        Ca
-00005810: 6c6c 2061 6674 6572 2073 6f6c 7665 2066  ll after solve f
-00005820: 6978 6564 204e 4c50 2073 7562 7072 6f62  ixed NLP subprob
-00005830: 6c65 6d2e 0a20 2020 2020 2020 2055 7365  lem..        Use
-00005840: 2074 6865 206f 7074 696d 616c 2070 7269   the optimal pri
-00005850: 6d61 6c20 626f 756e 6420 6f66 2074 6865  mal bound of the
-00005860: 2072 656c 6178 6564 2070 726f 626c 656d   relaxed problem
-00005870: 2074 6f20 7570 6461 7465 2074 6865 2064   to update the d
-00005880: 7561 6c20 626f 756e 642e 0a0a 2020 2020  ual bound...    
-00005890: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-000058a0: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
-000058b0: 2d0a 2020 2020 2020 2020 626f 756e 645f  -.        bound_
-000058c0: 7661 6c75 6520 3a20 666c 6f61 740a 2020  value : float.  
-000058d0: 2020 2020 2020 2020 2020 5468 6520 696e            The in
-000058e0: 7075 7420 7661 6c75 6520 7573 6564 2074  put value used t
-000058f0: 6f20 7570 6461 7465 2074 6865 2070 7269  o update the pri
-00005900: 6d61 6c20 626f 756e 642e 0a20 2020 2020  mal bound..     
-00005910: 2020 2022 2222 0a20 2020 2020 2020 2069     """.        i
-00005920: 6620 6d61 7468 2e69 736e 616e 2862 6f75  f math.isnan(bou
-00005930: 6e64 5f76 616c 7565 293a 0a20 2020 2020  nd_value):.     
-00005940: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
-00005950: 2020 2020 2020 6966 2073 656c 662e 6f62        if self.ob
-00005960: 6a65 6374 6976 655f 7365 6e73 6520 3d3d  jective_sense ==
-00005970: 206d 696e 696d 697a 653a 0a20 2020 2020   minimize:.     
-00005980: 2020 2020 2020 2073 656c 662e 7072 696d         self.prim
-00005990: 616c 5f62 6f75 6e64 203d 206d 696e 2862  al_bound = min(b
-000059a0: 6f75 6e64 5f76 616c 7565 2c20 7365 6c66  ound_value, self
-000059b0: 2e70 7269 6d61 6c5f 626f 756e 6429 0a20  .primal_bound). 
-000059c0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000059d0: 7072 696d 616c 5f62 6f75 6e64 5f69 6d70  primal_bound_imp
-000059e0: 726f 7665 6420 3d20 280a 2020 2020 2020  roved = (.      
-000059f0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-00005a00: 7269 6d61 6c5f 626f 756e 6420 3c20 7365  rimal_bound < se
-00005a10: 6c66 2e70 7269 6d61 6c5f 626f 756e 645f  lf.primal_bound_
-00005a20: 7072 6f67 7265 7373 5b2d 315d 0a20 2020  progress[-1].   
-00005a30: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00005a40: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00005a50: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
-00005a60: 5f62 6f75 6e64 203d 206d 6178 2862 6f75  _bound = max(bou
-00005a70: 6e64 5f76 616c 7565 2c20 7365 6c66 2e70  nd_value, self.p
-00005a80: 7269 6d61 6c5f 626f 756e 6429 0a20 2020  rimal_bound).   
-00005a90: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-00005aa0: 696d 616c 5f62 6f75 6e64 5f69 6d70 726f  imal_bound_impro
-00005ab0: 7665 6420 3d20 280a 2020 2020 2020 2020  ved = (.        
-00005ac0: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
-00005ad0: 6d61 6c5f 626f 756e 6420 3e20 7365 6c66  mal_bound > self
-00005ae0: 2e70 7269 6d61 6c5f 626f 756e 645f 7072  .primal_bound_pr
-00005af0: 6f67 7265 7373 5b2d 315d 0a20 2020 2020  ogress[-1].     
-00005b00: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00005b10: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
-00005b20: 6e64 5f70 726f 6772 6573 732e 6170 7065  nd_progress.appe
-00005b30: 6e64 2873 656c 662e 7072 696d 616c 5f62  nd(self.primal_b
-00005b40: 6f75 6e64 290a 2020 2020 2020 2020 7365  ound).        se
-00005b50: 6c66 2e70 7269 6d61 6c5f 626f 756e 645f  lf.primal_bound_
-00005b60: 7072 6f67 7265 7373 5f74 696d 652e 6170  progress_time.ap
-00005b70: 7065 6e64 2867 6574 5f6d 6169 6e5f 656c  pend(get_main_el
-00005b80: 6170 7365 645f 7469 6d65 2873 656c 662e  apsed_time(self.
-00005b90: 7469 6d69 6e67 2929 0a20 2020 2020 2020  timing)).       
-00005ba0: 2069 6620 7365 6c66 2e70 7269 6d61 6c5f   if self.primal_
-00005bb0: 626f 756e 645f 696d 7072 6f76 6564 3a0a  bound_improved:.
-00005bc0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00005bd0: 2e75 7064 6174 655f 6761 7028 290a 0a20  .update_gap().. 
-00005be0: 2020 2064 6566 2070 726f 6365 7373 5f6f     def process_o
-00005bf0: 626a 6563 7469 7665 2873 656c 662c 2075  bjective(self, u
-00005c00: 7064 6174 655f 7661 725f 636f 6e5f 6c69  pdate_var_con_li
-00005c10: 7374 3d54 7275 6529 3a0a 2020 2020 2020  st=True):.      
-00005c20: 2020 2222 2250 726f 6365 7373 206d 6f64    """Process mod
-00005c30: 656c 206f 626a 6563 7469 7665 2066 756e  el objective fun
-00005c40: 6374 696f 6e2e 0a0a 2020 2020 2020 2020  ction...        
-00005c50: 4368 6563 6b20 7468 6174 2074 6865 206d  Check that the m
-00005c60: 6f64 656c 2068 6173 206f 6e6c 7920 3120  odel has only 1 
-00005c70: 7661 6c69 6420 6f62 6a65 6374 6976 652e  valid objective.
-00005c80: 0a20 2020 2020 2020 2049 6620 7468 6520  .        If the 
-00005c90: 6f62 6a65 6374 6976 6520 6973 206e 6f6e  objective is non
-00005ca0: 6c69 6e65 6172 2c20 6d6f 7665 2069 7420  linear, move it 
-00005cb0: 696e 746f 2074 6865 2063 6f6e 7374 7261  into the constra
-00005cc0: 696e 7473 2e0a 2020 2020 2020 2020 4966  ints..        If
-00005cd0: 206e 6f20 6f62 6a65 6374 6976 6520 6675   no objective fu
-00005ce0: 6e63 7469 6f6e 2065 7869 7374 732c 2065  nction exists, e
-00005cf0: 6d69 7420 6120 7761 726e 696e 6720 616e  mit a warning an
-00005d00: 6420 6372 6561 7465 2061 2064 756d 6d79  d create a dummy
-00005d10: 206f 626a 6563 7469 7665 2e0a 0a20 2020   objective...   
-00005d20: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
-00005d30: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
-00005d40: 2d2d 0a20 2020 2020 2020 2075 7064 6174  --.        updat
-00005d50: 655f 7661 725f 636f 6e5f 6c69 7374 203a  e_var_con_list :
-00005d60: 2062 6f6f 6c2c 206f 7074 696f 6e61 6c0a   bool, optional.
-00005d70: 2020 2020 2020 2020 2020 2020 5768 6574              Whet
-00005d80: 6865 7220 746f 2075 7064 6174 6520 7468  her to update th
-00005d90: 6520 7661 7269 6162 6c65 2f63 6f6e 7374  e variable/const
-00005da0: 7261 696e 742f 6f62 6a65 6374 6976 6520  raint/objective 
-00005db0: 6c69 7374 732c 2062 7920 6465 6661 756c  lists, by defaul
-00005dc0: 7420 5472 7565 2e0a 2020 2020 2020 2020  t True..        
-00005dd0: 2020 2020 4375 7272 656e 746c 792c 2075      Currently, u
-00005de0: 7064 6174 655f 7661 725f 636f 6e5f 6c69  pdate_var_con_li
-00005df0: 7374 2077 696c 6c20 6265 2073 6574 2074  st will be set t
-00005e00: 6f20 4661 6c73 6520 6f6e 6c79 2077 6865  o False only whe
-00005e10: 6e20 6164 645f 7265 6775 6c61 7269 7a61  n add_regulariza
-00005e20: 7469 6f6e 2069 7320 6e6f 7420 4e6f 6e65  tion is not None
-00005e30: 2069 6e20 4d69 6e64 7450 792e 0a20 2020   in MindtPy..   
-00005e40: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00005e50: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
-00005e60: 6f6e 6669 670a 2020 2020 2020 2020 6d20  onfig.        m 
-00005e70: 3d20 7365 6c66 2e77 6f72 6b69 6e67 5f6d  = self.working_m
-00005e80: 6f64 656c 0a20 2020 2020 2020 2075 7469  odel.        uti
-00005e90: 6c5f 626c 6f63 6b20 3d20 6765 7461 7474  l_block = getatt
-00005ea0: 7228 6d2c 2073 656c 662e 7574 696c 5f62  r(m, self.util_b
-00005eb0: 6c6f 636b 5f6e 616d 6529 0a20 2020 2020  lock_name).     
-00005ec0: 2020 2023 2048 616e 646c 6520 6d69 7373     # Handle miss
-00005ed0: 696e 6720 6f72 206d 756c 7469 706c 6520  ing or multiple 
-00005ee0: 6f62 6a65 6374 6976 6573 0a20 2020 2020  objectives.     
-00005ef0: 2020 2061 6374 6976 655f 6f62 6a65 6374     active_object
-00005f00: 6976 6573 203d 206c 6973 7428 0a20 2020  ives = list(.   
-00005f10: 2020 2020 2020 2020 206d 2e63 6f6d 706f           m.compo
-00005f20: 6e65 6e74 5f64 6174 615f 6f62 6a65 6374  nent_data_object
-00005f30: 7328 6374 7970 653d 4f62 6a65 6374 6976  s(ctype=Objectiv
-00005f40: 652c 2061 6374 6976 653d 5472 7565 2c20  e, active=True, 
-00005f50: 6465 7363 656e 645f 696e 746f 3d54 7275  descend_into=Tru
-00005f60: 6529 0a20 2020 2020 2020 2029 0a20 2020  e).        ).   
-00005f70: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
-00005f80: 732e 7072 6f62 6c65 6d2e 6e75 6d62 6572  s.problem.number
-00005f90: 5f6f 665f 6f62 6a65 6374 6976 6573 203d  _of_objectives =
-00005fa0: 206c 656e 2861 6374 6976 655f 6f62 6a65   len(active_obje
-00005fb0: 6374 6976 6573 290a 2020 2020 2020 2020  ctives).        
-00005fc0: 6966 206c 656e 2861 6374 6976 655f 6f62  if len(active_ob
-00005fd0: 6a65 6374 6976 6573 2920 3d3d 2030 3a0a  jectives) == 0:.
-00005fe0: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-00005ff0: 6967 2e6c 6f67 6765 722e 7761 726e 696e  ig.logger.warnin
-00006000: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
-00006010: 2020 2027 4d6f 6465 6c20 6861 7320 6e6f     'Model has no
-00006020: 2061 6374 6976 6520 6f62 6a65 6374 6976   active objectiv
-00006030: 6573 2e20 4164 6469 6e67 2064 756d 6d79  es. Adding dummy
-00006040: 206f 626a 6563 7469 7665 2e27 0a20 2020   objective.'.   
-00006050: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00006060: 2020 2020 2020 2075 7469 6c5f 626c 6f63         util_bloc
-00006070: 6b2e 6475 6d6d 795f 6f62 6a65 6374 6976  k.dummy_objectiv
-00006080: 6520 3d20 4f62 6a65 6374 6976 6528 6578  e = Objective(ex
-00006090: 7072 3d31 290a 2020 2020 2020 2020 2020  pr=1).          
-000060a0: 2020 6d61 696e 5f6f 626a 203d 2075 7469    main_obj = uti
-000060b0: 6c5f 626c 6f63 6b2e 6475 6d6d 795f 6f62  l_block.dummy_ob
-000060c0: 6a65 6374 6976 650a 2020 2020 2020 2020  jective.        
-000060d0: 656c 6966 206c 656e 2861 6374 6976 655f  elif len(active_
-000060e0: 6f62 6a65 6374 6976 6573 2920 3e20 313a  objectives) > 1:
-000060f0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
-00006100: 7365 2056 616c 7565 4572 726f 7228 274d  se ValueError('M
-00006110: 6f64 656c 2068 6173 206d 756c 7469 706c  odel has multipl
-00006120: 6520 6163 7469 7665 206f 626a 6563 7469  e active objecti
-00006130: 7665 732e 2729 0a20 2020 2020 2020 2065  ves.').        e
-00006140: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00006150: 206d 6169 6e5f 6f62 6a20 3d20 6163 7469   main_obj = acti
-00006160: 7665 5f6f 626a 6563 7469 7665 735b 305d  ve_objectives[0]
-00006170: 0a20 2020 2020 2020 2073 656c 662e 7265  .        self.re
-00006180: 7375 6c74 732e 7072 6f62 6c65 6d2e 7365  sults.problem.se
-00006190: 6e73 6520 3d20 280a 2020 2020 2020 2020  nse = (.        
-000061a0: 2020 2020 5072 6f62 6c65 6d53 656e 7365      ProblemSense
-000061b0: 2e6d 696e 696d 697a 6520 6966 206d 6169  .minimize if mai
-000061c0: 6e5f 6f62 6a2e 7365 6e73 6520 3d3d 2031  n_obj.sense == 1
-000061d0: 2065 6c73 6520 5072 6f62 6c65 6d53 656e   else ProblemSen
-000061e0: 7365 2e6d 6178 696d 697a 650a 2020 2020  se.maximize.    
-000061f0: 2020 2020 290a 2020 2020 2020 2020 7365      ).        se
-00006200: 6c66 2e6f 626a 6563 7469 7665 5f73 656e  lf.objective_sen
-00006210: 7365 203d 206d 6169 6e5f 6f62 6a2e 7365  se = main_obj.se
-00006220: 6e73 650a 0a20 2020 2020 2020 2023 204d  nse..        # M
-00006230: 6f76 6520 7468 6520 6f62 6a65 6374 6976  ove the objectiv
-00006240: 6520 746f 2074 6865 2063 6f6e 7374 7261  e to the constra
-00006250: 696e 7473 2069 6620 6974 2069 7320 6e6f  ints if it is no
-00006260: 6e6c 696e 6561 7220 6f72 206d 6f76 655f  nlinear or move_
-00006270: 6f62 6a65 6374 6976 6520 6973 2054 7275  objective is Tru
-00006280: 652e 0a20 2020 2020 2020 2069 6620 280a  e..        if (.
-00006290: 2020 2020 2020 2020 2020 2020 6d61 696e              main
-000062a0: 5f6f 626a 2e65 7870 722e 706f 6c79 6e6f  _obj.expr.polyno
-000062b0: 6d69 616c 5f64 6567 7265 6528 290a 2020  mial_degree().  
-000062c0: 2020 2020 2020 2020 2020 6e6f 7420 696e            not in
-000062d0: 2073 656c 662e 6d69 705f 6f62 6a65 6374   self.mip_object
-000062e0: 6976 655f 706f 6c79 6e6f 6d69 616c 5f64  ive_polynomial_d
-000062f0: 6567 7265 650a 2020 2020 2020 2020 2020  egree.          
-00006300: 2020 6f72 2063 6f6e 6669 672e 6d6f 7665    or config.move
-00006310: 5f6f 626a 6563 7469 7665 0a20 2020 2020  _objective.     
-00006320: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-00006330: 2020 6966 2063 6f6e 6669 672e 6d6f 7665    if config.move
-00006340: 5f6f 626a 6563 7469 7665 3a0a 2020 2020  _objective:.    
-00006350: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-00006360: 6967 2e6c 6f67 6765 722e 696e 666f 2822  ig.logger.info("
-00006370: 4d6f 7669 6e67 206f 626a 6563 7469 7665  Moving objective
-00006380: 2074 6f20 636f 6e73 7472 6169 6e74 2073   to constraint s
-00006390: 6574 2e22 290a 2020 2020 2020 2020 2020  et.").          
-000063a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000063b0: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
-000063c0: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
-000063d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000063e0: 224f 626a 6563 7469 7665 2069 7320 6e6f  "Objective is no
-000063f0: 6e6c 696e 6561 722e 204d 6f76 696e 6720  nlinear. Moving 
-00006400: 6974 2074 6f20 636f 6e73 7472 6169 6e74  it to constraint
-00006410: 2073 6574 2e22 0a20 2020 2020 2020 2020   set.".         
-00006420: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00006430: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
-00006440: 6f62 6a65 6374 6976 655f 7661 6c75 6520  objective_value 
-00006450: 3d20 5661 724c 6973 7428 646f 6d61 696e  = VarList(domain
-00006460: 3d52 6561 6c73 2c20 696e 6974 6961 6c69  =Reals, initiali
-00006470: 7a65 3d30 290a 2020 2020 2020 2020 2020  ze=0).          
-00006480: 2020 7574 696c 5f62 6c6f 636b 2e6f 626a    util_block.obj
-00006490: 6563 7469 7665 5f63 6f6e 7374 7220 3d20  ective_constr = 
-000064a0: 436f 6e73 7472 6169 6e74 4c69 7374 2829  ConstraintList()
-000064b0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-000064c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000064d0: 2020 6d61 696e 5f6f 626a 2e65 7870 722e    main_obj.expr.
-000064e0: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
-000064f0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-00006500: 2020 2020 6e6f 7420 696e 2073 656c 662e      not in self.
-00006510: 6d69 705f 6f62 6a65 6374 6976 655f 706f  mip_objective_po
-00006520: 6c79 6e6f 6d69 616c 5f64 6567 7265 650a  lynomial_degree.
-00006530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006540: 616e 6420 636f 6e66 6967 2e70 6172 7469  and config.parti
-00006550: 7469 6f6e 5f6f 626a 5f6e 6f6e 6c69 6e65  tion_obj_nonline
-00006560: 6172 5f74 6572 6d73 0a20 2020 2020 2020  ar_terms.       
-00006570: 2020 2020 2020 2020 2061 6e64 206d 6169           and mai
-00006580: 6e5f 6f62 6a2e 6578 7072 2e5f 5f63 6c61  n_obj.expr.__cla
-00006590: 7373 5f5f 2069 7320 4558 5052 2e53 756d  ss__ is EXPR.Sum
-000065a0: 4578 7072 6573 7369 6f6e 0a20 2020 2020  Expression.     
-000065b0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
-000065c0: 2020 2020 2020 2020 2020 7265 706e 203d            repn =
-000065d0: 2067 656e 6572 6174 655f 7374 616e 6461   generate_standa
-000065e0: 7264 5f72 6570 6e28 0a20 2020 2020 2020  rd_repn(.       
-000065f0: 2020 2020 2020 2020 2020 2020 206d 6169               mai
-00006600: 6e5f 6f62 6a2e 6578 7072 2c20 7175 6164  n_obj.expr, quad
-00006610: 7261 7469 633d 3220 696e 2073 656c 662e  ratic=2 in self.
-00006620: 6d69 705f 6f62 6a65 6374 6976 655f 706f  mip_objective_po
-00006630: 6c79 6e6f 6d69 616c 5f64 6567 7265 650a  lynomial_degree.
-00006640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006650: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00006660: 2020 2320 7468 6520 666f 6c6c 6f77 696e    # the followin
-00006670: 6720 636f 6465 2077 696c 6c20 616c 736f  g code will also
-00006680: 2077 6f72 6b20 6966 206c 696e 6561 725f   work if linear_
-00006690: 7375 6265 7870 7220 6973 2061 2063 6f6e  subexpr is a con
-000066a0: 7374 616e 742e 0a20 2020 2020 2020 2020  stant..         
-000066b0: 2020 2020 2020 206c 696e 6561 725f 7375         linear_su
-000066c0: 6265 7870 7220 3d20 280a 2020 2020 2020  bexpr = (.      
-000066d0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000066e0: 706e 2e63 6f6e 7374 616e 740a 2020 2020  pn.constant.    
-000066f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006700: 2b20 7375 6d28 0a20 2020 2020 2020 2020  + sum(.         
-00006710: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00006720: 6f65 6620 2a20 7661 720a 2020 2020 2020  oef * var.      
-00006730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006740: 2020 666f 7220 636f 6566 2c20 7661 7220    for coef, var 
-00006750: 696e 207a 6970 2872 6570 6e2e 6c69 6e65  in zip(repn.line
-00006760: 6172 5f63 6f65 6673 2c20 7265 706e 2e6c  ar_coefs, repn.l
-00006770: 696e 6561 725f 7661 7273 290a 2020 2020  inear_vars).    
+00004b50: 7072 696d 616c 5f62 6f75 6e64 5f70 726f  primal_bound_pro
+00004b60: 6772 6573 735b 695d 203d 2070 7269 6d61  gress[i] = prima
+00004b70: 6c5f 626f 756e 6420 2a20 280a 2020 2020  l_bound * (.    
+00004b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004b90: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
+00004ba0: 2020 2020 2020 2b20 7365 6c66 2e63 6f6e        + self.con
+00004bb0: 6669 672e 696e 6974 6961 6c5f 626f 756e  fig.initial_boun
+00004bc0: 645f 636f 6566 0a20 2020 2020 2020 2020  d_coef.         
+00004bd0: 2020 2020 2020 2020 2020 202a 2073 656c             * sel
+00004be0: 662e 6f62 6a65 6374 6976 655f 7365 6e73  f.objective_sens
+00004bf0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00004c00: 2020 2020 2020 2a20 6d61 7468 2e63 6f70        * math.cop
+00004c10: 7973 6967 6e28 312c 2070 7269 6d61 6c5f  ysign(1, primal_
+00004c20: 626f 756e 6429 0a20 2020 2020 2020 2020  bound).         
+00004c30: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00004c40: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00004c50: 2020 2020 2020 2020 2020 2062 7265 616b             break
+00004c60: 0a20 2020 2020 2020 2066 6f72 2069 2069  .        for i i
+00004c70: 6e20 7261 6e67 6528 6c65 6e28 7072 696d  n range(len(prim
+00004c80: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
+00004c90: 7329 293a 0a20 2020 2020 2020 2020 2020  s)):.           
+00004ca0: 2069 6620 6920 3d3d 2030 3a0a 2020 2020   if i == 0:.    
+00004cb0: 2020 2020 2020 2020 2020 2020 7072 696d              prim
+00004cc0: 616c 5f69 6e74 6567 7261 6c20 2b3d 2061  al_integral += a
+00004cd0: 6273 2870 7269 6d61 6c5f 626f 756e 645f  bs(primal_bound_
+00004ce0: 7072 6f67 7265 7373 5b69 5d20 2d20 7365  progress[i] - se
+00004cf0: 6c66 2e70 7269 6d61 6c5f 626f 756e 6429  lf.primal_bound)
+00004d00: 202a 2028 0a20 2020 2020 2020 2020 2020   * (.           
+00004d10: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
+00004d20: 696d 616c 5f62 6f75 6e64 5f70 726f 6772  imal_bound_progr
+00004d30: 6573 735f 7469 6d65 5b69 5d0a 2020 2020  ess_time[i].    
+00004d40: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00004d50: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00004d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004d70: 7072 696d 616c 5f69 6e74 6567 7261 6c20  primal_integral 
+00004d80: 2b3d 2061 6273 2870 7269 6d61 6c5f 626f  += abs(primal_bo
+00004d90: 756e 645f 7072 6f67 7265 7373 5b69 5d20  und_progress[i] 
+00004da0: 2d20 7365 6c66 2e70 7269 6d61 6c5f 626f  - self.primal_bo
+00004db0: 756e 6429 202a 2028 0a20 2020 2020 2020  und) * (.       
+00004dc0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00004dd0: 662e 7072 696d 616c 5f62 6f75 6e64 5f70  f.primal_bound_p
+00004de0: 726f 6772 6573 735f 7469 6d65 5b69 5d0a  rogress_time[i].
+00004df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00004e00: 2020 2020 2d20 7365 6c66 2e70 7269 6d61      - self.prima
+00004e10: 6c5f 626f 756e 645f 7072 6f67 7265 7373  l_bound_progress
+00004e20: 5f74 696d 655b 6920 2d20 315d 0a20 2020  _time[i - 1].   
+00004e30: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
+00004e40: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
+00004e50: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+00004e60: 0a20 2020 2020 2020 2020 2020 2027 207b  .            ' {
+00004e70: 3a3c 3235 7d3a 2020 207b 3a3e 372e 3466  :<25}:   {:>7.4f
+00004e80: 7d20 272e 666f 726d 6174 2827 5072 696d  } '.format('Prim
+00004e90: 616c 2069 6e74 6567 7261 6c27 2c20 7072  al integral', pr
+00004ea0: 696d 616c 5f69 6e74 6567 7261 6c29 0a20  imal_integral). 
+00004eb0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00004ec0: 2072 6574 7572 6e20 7072 696d 616c 5f69   return primal_i
+00004ed0: 6e74 6567 7261 6c0a 0a20 2020 2064 6566  ntegral..    def
+00004ee0: 2067 6574 5f69 6e74 6567 7261 6c5f 696e   get_integral_in
+00004ef0: 666f 2873 656c 6629 3a0a 2020 2020 2020  fo(self):.      
+00004f00: 2020 2222 220a 2020 2020 2020 2020 4f62    """.        Ob
+00004f10: 7461 696e 2070 7269 6d61 6c20 696e 7465  tain primal inte
+00004f20: 6772 616c 2c20 6475 616c 2069 6e74 6567  gral, dual integ
+00004f30: 7261 6c20 616e 6420 7072 696d 616c 2064  ral and primal d
+00004f40: 7561 6c20 6761 7020 696e 7465 6772 616c  ual gap integral
+00004f50: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00004f60: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
+00004f70: 6c5f 696e 7465 6772 616c 203d 2073 656c  l_integral = sel
+00004f80: 662e 6765 745f 7072 696d 616c 5f69 6e74  f.get_primal_int
+00004f90: 6567 7261 6c28 290a 2020 2020 2020 2020  egral().        
+00004fa0: 7365 6c66 2e64 7561 6c5f 696e 7465 6772  self.dual_integr
+00004fb0: 616c 203d 2073 656c 662e 6765 745f 6475  al = self.get_du
+00004fc0: 616c 5f69 6e74 6567 7261 6c28 290a 2020  al_integral().  
+00004fd0: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
+00004fe0: 6c5f 6475 616c 5f67 6170 5f69 6e74 6567  l_dual_gap_integ
+00004ff0: 7261 6c20 3d20 7365 6c66 2e70 7269 6d61  ral = self.prima
+00005000: 6c5f 696e 7465 6772 616c 202b 2073 656c  l_integral + sel
+00005010: 662e 6475 616c 5f69 6e74 6567 7261 6c0a  f.dual_integral.
+00005020: 0a20 2020 2064 6566 2075 7064 6174 655f  .    def update_
+00005030: 6761 7028 7365 6c66 293a 0a20 2020 2020  gap(self):.     
+00005040: 2020 2022 2222 5570 6461 7465 2074 6865     """Update the
+00005050: 2072 656c 6174 6976 6520 6761 7020 616e   relative gap an
+00005060: 6420 7468 6520 6162 736f 6c75 7465 2067  d the absolute g
+00005070: 6170 2e22 2222 0a20 2020 2020 2020 2069  ap.""".        i
+00005080: 6620 7365 6c66 2e6f 626a 6563 7469 7665  f self.objective
+00005090: 5f73 656e 7365 203d 3d20 6d69 6e69 6d69  _sense == minimi
+000050a0: 7a65 3a0a 2020 2020 2020 2020 2020 2020  ze:.            
+000050b0: 7365 6c66 2e61 6273 5f67 6170 203d 2073  self.abs_gap = s
+000050c0: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+000050d0: 202d 2073 656c 662e 6475 616c 5f62 6f75   - self.dual_bou
+000050e0: 6e64 0a20 2020 2020 2020 2065 6c73 653a  nd.        else:
+000050f0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00005100: 662e 6162 735f 6761 7020 3d20 7365 6c66  f.abs_gap = self
+00005110: 2e64 7561 6c5f 626f 756e 6420 2d20 7365  .dual_bound - se
+00005120: 6c66 2e70 7269 6d61 6c5f 626f 756e 640a  lf.primal_bound.
+00005130: 2020 2020 2020 2020 7365 6c66 2e72 656c          self.rel
+00005140: 5f67 6170 203d 2073 656c 662e 6162 735f  _gap = self.abs_
+00005150: 6761 7020 2f20 2861 6273 2873 656c 662e  gap / (abs(self.
+00005160: 7072 696d 616c 5f62 6f75 6e64 2920 2b20  primal_bound) + 
+00005170: 3165 2d31 3029 0a0a 2020 2020 6465 6620  1e-10)..    def 
+00005180: 7570 6461 7465 5f64 7561 6c5f 626f 756e  update_dual_boun
+00005190: 6428 7365 6c66 2c20 626f 756e 645f 7661  d(self, bound_va
+000051a0: 6c75 6529 3a0a 2020 2020 2020 2020 2222  lue):.        ""
+000051b0: 2255 7064 6174 6520 7468 6520 6475 616c  "Update the dual
+000051c0: 2062 6f75 6e64 2e0a 0a20 2020 2020 2020   bound...       
+000051d0: 2043 616c 6c20 6166 7465 7220 736f 6c76   Call after solv
+000051e0: 696e 6720 7265 6c61 7865 6420 7072 6f62  ing relaxed prob
+000051f0: 6c65 6d2c 2069 6e63 6c75 6469 6e67 2072  lem, including r
+00005200: 656c 6178 6564 204e 4c50 2061 6e64 204d  elaxed NLP and M
+00005210: 4950 206d 6169 6e20 7072 6f62 6c65 6d2e  IP main problem.
+00005220: 0a20 2020 2020 2020 2055 7365 2074 6865  .        Use the
+00005230: 206f 7074 696d 616c 2070 7269 6d61 6c20   optimal primal 
+00005240: 626f 756e 6420 6f66 2074 6865 2072 656c  bound of the rel
+00005250: 6178 6564 2070 726f 626c 656d 2074 6f20  axed problem to 
+00005260: 7570 6461 7465 2074 6865 2064 7561 6c20  update the dual 
+00005270: 626f 756e 642e 0a0a 2020 2020 2020 2020  bound...        
+00005280: 5061 7261 6d65 7465 7273 0a20 2020 2020  Parameters.     
+00005290: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
+000052a0: 2020 2020 2020 626f 756e 645f 7661 6c75        bound_valu
+000052b0: 6520 3a20 666c 6f61 740a 2020 2020 2020  e : float.      
+000052c0: 2020 2020 2020 5468 6520 696e 7075 7420        The input 
+000052d0: 7661 6c75 6520 7573 6564 2074 6f20 7570  value used to up
+000052e0: 6461 7465 2074 6865 2064 7561 6c20 626f  date the dual bo
+000052f0: 756e 642e 0a20 2020 2020 2020 2022 2222  und..        """
+00005300: 0a20 2020 2020 2020 2069 6620 6d61 7468  .        if math
+00005310: 2e69 736e 616e 2862 6f75 6e64 5f76 616c  .isnan(bound_val
+00005320: 7565 293a 0a20 2020 2020 2020 2020 2020  ue):.           
+00005330: 2072 6574 7572 6e0a 2020 2020 2020 2020   return.        
+00005340: 6966 2073 656c 662e 6f62 6a65 6374 6976  if self.objectiv
+00005350: 655f 7365 6e73 6520 3d3d 206d 696e 696d  e_sense == minim
+00005360: 697a 653a 0a20 2020 2020 2020 2020 2020  ize:.           
+00005370: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+00005380: 203d 206d 6178 2862 6f75 6e64 5f76 616c   = max(bound_val
+00005390: 7565 2c20 7365 6c66 2e64 7561 6c5f 626f  ue, self.dual_bo
+000053a0: 756e 6429 0a20 2020 2020 2020 2020 2020  und).           
+000053b0: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+000053c0: 5f69 6d70 726f 7665 6420 3d20 7365 6c66  _improved = self
+000053d0: 2e64 7561 6c5f 626f 756e 6420 3e20 7365  .dual_bound > se
+000053e0: 6c66 2e64 7561 6c5f 626f 756e 645f 7072  lf.dual_bound_pr
+000053f0: 6f67 7265 7373 5b2d 315d 0a20 2020 2020  ogress[-1].     
+00005400: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00005410: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
+00005420: 6f75 6e64 203d 206d 696e 2862 6f75 6e64  ound = min(bound
+00005430: 5f76 616c 7565 2c20 7365 6c66 2e64 7561  _value, self.dua
+00005440: 6c5f 626f 756e 6429 0a20 2020 2020 2020  l_bound).       
+00005450: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
+00005460: 6f75 6e64 5f69 6d70 726f 7665 6420 3d20  ound_improved = 
+00005470: 7365 6c66 2e64 7561 6c5f 626f 756e 6420  self.dual_bound 
+00005480: 3c20 7365 6c66 2e64 7561 6c5f 626f 756e  < self.dual_boun
+00005490: 645f 7072 6f67 7265 7373 5b2d 315d 0a20  d_progress[-1]. 
+000054a0: 2020 2020 2020 2073 656c 662e 6475 616c         self.dual
+000054b0: 5f62 6f75 6e64 5f70 726f 6772 6573 732e  _bound_progress.
+000054c0: 6170 7065 6e64 2873 656c 662e 6475 616c  append(self.dual
+000054d0: 5f62 6f75 6e64 290a 2020 2020 2020 2020  _bound).        
+000054e0: 7365 6c66 2e64 7561 6c5f 626f 756e 645f  self.dual_bound_
+000054f0: 7072 6f67 7265 7373 5f74 696d 652e 6170  progress_time.ap
+00005500: 7065 6e64 2867 6574 5f6d 6169 6e5f 656c  pend(get_main_el
+00005510: 6170 7365 645f 7469 6d65 2873 656c 662e  apsed_time(self.
+00005520: 7469 6d69 6e67 2929 0a20 2020 2020 2020  timing)).       
+00005530: 2069 6620 7365 6c66 2e64 7561 6c5f 626f   if self.dual_bo
+00005540: 756e 645f 696d 7072 6f76 6564 3a0a 2020  und_improved:.  
+00005550: 2020 2020 2020 2020 2020 7365 6c66 2e75            self.u
+00005560: 7064 6174 655f 6761 7028 290a 0a20 2020  pdate_gap()..   
+00005570: 2064 6566 2075 7064 6174 655f 7375 626f   def update_subo
+00005580: 7074 696d 616c 5f64 7561 6c5f 626f 756e  ptimal_dual_boun
+00005590: 6428 7365 6c66 2c20 7265 7375 6c74 7329  d(self, results)
+000055a0: 3a0a 2020 2020 2020 2020 2222 2249 6620  :.        """If 
+000055b0: 7468 6520 7265 6c61 7865 6420 7072 6f62  the relaxed prob
+000055c0: 6c65 6d20 6973 206e 6f74 2073 6f6c 7665  lem is not solve
+000055d0: 6420 746f 206f 7074 696d 616c 6974 792c  d to optimality,
+000055e0: 2074 6865 2064 7561 6c20 626f 756e 6420   the dual bound 
+000055f0: 6973 2075 7064 6174 6564 0a20 2020 2020  is updated.     
+00005600: 2020 2061 6363 6f72 6469 6e67 2074 6f20     according to 
+00005610: 7468 6520 6475 616c 2062 6f75 6e64 206f  the dual bound o
+00005620: 6620 7265 6c61 7865 6420 7072 6f62 6c65  f relaxed proble
+00005630: 6d2e 0a0a 2020 2020 2020 2020 5061 7261  m...        Para
+00005640: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
+00005650: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+00005660: 2020 7265 7375 6c74 7320 3a20 536f 6c76    results : Solv
+00005670: 6572 5265 7375 6c74 730a 2020 2020 2020  erResults.      
+00005680: 2020 2020 2020 5265 7375 6c74 7320 6672        Results fr
+00005690: 6f6d 2073 6f6c 7669 6e67 2074 6865 2072  om solving the r
+000056a0: 656c 6178 6564 2070 726f 626c 656d 2e0a  elaxed problem..
+000056b0: 2020 2020 2020 2020 2020 2020 5468 6520              The 
+000056c0: 6475 616c 2062 6f75 6e64 206f 6620 7468  dual bound of th
+000056d0: 6520 7265 6c61 7865 6420 7072 6f62 6c65  e relaxed proble
+000056e0: 6d20 6361 6e20 6f6e 6c79 2062 6520 6f62  m can only be ob
+000056f0: 7461 696e 6564 2066 726f 6d20 7468 6520  tained from the 
+00005700: 7265 7375 6c74 206f 626a 6563 742e 0a20  result object.. 
+00005710: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00005720: 2020 2069 6620 7365 6c66 2e6f 626a 6563     if self.objec
+00005730: 7469 7665 5f73 656e 7365 203d 3d20 6d69  tive_sense == mi
+00005740: 6e69 6d69 7a65 3a0a 2020 2020 2020 2020  nimize:.        
+00005750: 2020 2020 626f 756e 645f 7661 6c75 6520      bound_value 
+00005760: 3d20 7265 7375 6c74 732e 7072 6f62 6c65  = results.proble
+00005770: 6d2e 6c6f 7765 725f 626f 756e 640a 2020  m.lower_bound.  
+00005780: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00005790: 2020 2020 2020 2020 626f 756e 645f 7661          bound_va
+000057a0: 6c75 6520 3d20 7265 7375 6c74 732e 7072  lue = results.pr
+000057b0: 6f62 6c65 6d2e 7570 7065 725f 626f 756e  oblem.upper_boun
+000057c0: 640a 2020 2020 2020 2020 7365 6c66 2e75  d.        self.u
+000057d0: 7064 6174 655f 6475 616c 5f62 6f75 6e64  pdate_dual_bound
+000057e0: 2862 6f75 6e64 5f76 616c 7565 290a 0a20  (bound_value).. 
+000057f0: 2020 2064 6566 2075 7064 6174 655f 7072     def update_pr
+00005800: 696d 616c 5f62 6f75 6e64 2873 656c 662c  imal_bound(self,
+00005810: 2062 6f75 6e64 5f76 616c 7565 293a 0a20   bound_value):. 
+00005820: 2020 2020 2020 2022 2222 5570 6461 7465         """Update
+00005830: 2074 6865 2070 7269 6d61 6c20 626f 756e   the primal boun
+00005840: 642e 0a0a 2020 2020 2020 2020 4361 6c6c  d...        Call
+00005850: 2061 6674 6572 2073 6f6c 7665 2066 6978   after solve fix
+00005860: 6564 204e 4c50 2073 7562 7072 6f62 6c65  ed NLP subproble
+00005870: 6d2e 0a20 2020 2020 2020 2055 7365 2074  m..        Use t
+00005880: 6865 206f 7074 696d 616c 2070 7269 6d61  he optimal prima
+00005890: 6c20 626f 756e 6420 6f66 2074 6865 2072  l bound of the r
+000058a0: 656c 6178 6564 2070 726f 626c 656d 2074  elaxed problem t
+000058b0: 6f20 7570 6461 7465 2074 6865 2064 7561  o update the dua
+000058c0: 6c20 626f 756e 642e 0a0a 2020 2020 2020  l bound...      
+000058d0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+000058e0: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+000058f0: 2020 2020 2020 2020 626f 756e 645f 7661          bound_va
+00005900: 6c75 6520 3a20 666c 6f61 740a 2020 2020  lue : float.    
+00005910: 2020 2020 2020 2020 5468 6520 696e 7075          The inpu
+00005920: 7420 7661 6c75 6520 7573 6564 2074 6f20  t value used to 
+00005930: 7570 6461 7465 2074 6865 2070 7269 6d61  update the prima
+00005940: 6c20 626f 756e 642e 0a20 2020 2020 2020  l bound..       
+00005950: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+00005960: 6d61 7468 2e69 736e 616e 2862 6f75 6e64  math.isnan(bound
+00005970: 5f76 616c 7565 293a 0a20 2020 2020 2020  _value):.       
+00005980: 2020 2020 2072 6574 7572 6e0a 2020 2020       return.    
+00005990: 2020 2020 6966 2073 656c 662e 6f62 6a65      if self.obje
+000059a0: 6374 6976 655f 7365 6e73 6520 3d3d 206d  ctive_sense == m
+000059b0: 696e 696d 697a 653a 0a20 2020 2020 2020  inimize:.       
+000059c0: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
+000059d0: 5f62 6f75 6e64 203d 206d 696e 2862 6f75  _bound = min(bou
+000059e0: 6e64 5f76 616c 7565 2c20 7365 6c66 2e70  nd_value, self.p
+000059f0: 7269 6d61 6c5f 626f 756e 6429 0a20 2020  rimal_bound).   
+00005a00: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
+00005a10: 696d 616c 5f62 6f75 6e64 5f69 6d70 726f  imal_bound_impro
+00005a20: 7665 6420 3d20 280a 2020 2020 2020 2020  ved = (.        
+00005a30: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
+00005a40: 6d61 6c5f 626f 756e 6420 3c20 7365 6c66  mal_bound < self
+00005a50: 2e70 7269 6d61 6c5f 626f 756e 645f 7072  .primal_bound_pr
+00005a60: 6f67 7265 7373 5b2d 315d 0a20 2020 2020  ogress[-1].     
+00005a70: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00005a80: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00005a90: 2020 2073 656c 662e 7072 696d 616c 5f62     self.primal_b
+00005aa0: 6f75 6e64 203d 206d 6178 2862 6f75 6e64  ound = max(bound
+00005ab0: 5f76 616c 7565 2c20 7365 6c66 2e70 7269  _value, self.pri
+00005ac0: 6d61 6c5f 626f 756e 6429 0a20 2020 2020  mal_bound).     
+00005ad0: 2020 2020 2020 2073 656c 662e 7072 696d         self.prim
+00005ae0: 616c 5f62 6f75 6e64 5f69 6d70 726f 7665  al_bound_improve
+00005af0: 6420 3d20 280a 2020 2020 2020 2020 2020  d = (.          
+00005b00: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
+00005b10: 6c5f 626f 756e 6420 3e20 7365 6c66 2e70  l_bound > self.p
+00005b20: 7269 6d61 6c5f 626f 756e 645f 7072 6f67  rimal_bound_prog
+00005b30: 7265 7373 5b2d 315d 0a20 2020 2020 2020  ress[-1].       
+00005b40: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
+00005b50: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+00005b60: 5f70 726f 6772 6573 732e 6170 7065 6e64  _progress.append
+00005b70: 2873 656c 662e 7072 696d 616c 5f62 6f75  (self.primal_bou
+00005b80: 6e64 290a 2020 2020 2020 2020 7365 6c66  nd).        self
+00005b90: 2e70 7269 6d61 6c5f 626f 756e 645f 7072  .primal_bound_pr
+00005ba0: 6f67 7265 7373 5f74 696d 652e 6170 7065  ogress_time.appe
+00005bb0: 6e64 2867 6574 5f6d 6169 6e5f 656c 6170  nd(get_main_elap
+00005bc0: 7365 645f 7469 6d65 2873 656c 662e 7469  sed_time(self.ti
+00005bd0: 6d69 6e67 2929 0a20 2020 2020 2020 2069  ming)).        i
+00005be0: 6620 7365 6c66 2e70 7269 6d61 6c5f 626f  f self.primal_bo
+00005bf0: 756e 645f 696d 7072 6f76 6564 3a0a 2020  und_improved:.  
+00005c00: 2020 2020 2020 2020 2020 7365 6c66 2e75            self.u
+00005c10: 7064 6174 655f 6761 7028 290a 0a20 2020  pdate_gap()..   
+00005c20: 2064 6566 2070 726f 6365 7373 5f6f 626a   def process_obj
+00005c30: 6563 7469 7665 2873 656c 662c 2075 7064  ective(self, upd
+00005c40: 6174 655f 7661 725f 636f 6e5f 6c69 7374  ate_var_con_list
+00005c50: 3d54 7275 6529 3a0a 2020 2020 2020 2020  =True):.        
+00005c60: 2222 2250 726f 6365 7373 206d 6f64 656c  """Process model
+00005c70: 206f 626a 6563 7469 7665 2066 756e 6374   objective funct
+00005c80: 696f 6e2e 0a0a 2020 2020 2020 2020 4368  ion...        Ch
+00005c90: 6563 6b20 7468 6174 2074 6865 206d 6f64  eck that the mod
+00005ca0: 656c 2068 6173 206f 6e6c 7920 3120 7661  el has only 1 va
+00005cb0: 6c69 6420 6f62 6a65 6374 6976 652e 0a20  lid objective.. 
+00005cc0: 2020 2020 2020 2049 6620 7468 6520 6f62         If the ob
+00005cd0: 6a65 6374 6976 6520 6973 206e 6f6e 6c69  jective is nonli
+00005ce0: 6e65 6172 2c20 6d6f 7665 2069 7420 696e  near, move it in
+00005cf0: 746f 2074 6865 2063 6f6e 7374 7261 696e  to the constrain
+00005d00: 7473 2e0a 2020 2020 2020 2020 4966 206e  ts..        If n
+00005d10: 6f20 6f62 6a65 6374 6976 6520 6675 6e63  o objective func
+00005d20: 7469 6f6e 2065 7869 7374 732c 2065 6d69  tion exists, emi
+00005d30: 7420 6120 7761 726e 696e 6720 616e 6420  t a warning and 
+00005d40: 6372 6561 7465 2061 2064 756d 6d79 206f  create a dummy o
+00005d50: 626a 6563 7469 7665 2e0a 0a20 2020 2020  bjective...     
+00005d60: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
+00005d70: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
+00005d80: 0a20 2020 2020 2020 2075 7064 6174 655f  .        update_
+00005d90: 7661 725f 636f 6e5f 6c69 7374 203a 2062  var_con_list : b
+00005da0: 6f6f 6c2c 206f 7074 696f 6e61 6c0a 2020  ool, optional.  
+00005db0: 2020 2020 2020 2020 2020 5768 6574 6865            Whethe
+00005dc0: 7220 746f 2075 7064 6174 6520 7468 6520  r to update the 
+00005dd0: 7661 7269 6162 6c65 2f63 6f6e 7374 7261  variable/constra
+00005de0: 696e 742f 6f62 6a65 6374 6976 6520 6c69  int/objective li
+00005df0: 7374 732c 2062 7920 6465 6661 756c 7420  sts, by default 
+00005e00: 5472 7565 2e0a 2020 2020 2020 2020 2020  True..          
+00005e10: 2020 4375 7272 656e 746c 792c 2075 7064    Currently, upd
+00005e20: 6174 655f 7661 725f 636f 6e5f 6c69 7374  ate_var_con_list
+00005e30: 2077 696c 6c20 6265 2073 6574 2074 6f20   will be set to 
+00005e40: 4661 6c73 6520 6f6e 6c79 2077 6865 6e20  False only when 
+00005e50: 6164 645f 7265 6775 6c61 7269 7a61 7469  add_regularizati
+00005e60: 6f6e 2069 7320 6e6f 7420 4e6f 6e65 2069  on is not None i
+00005e70: 6e20 4d69 6e64 7450 792e 0a20 2020 2020  n MindtPy..     
+00005e80: 2020 2022 2222 0a20 2020 2020 2020 2063     """.        c
+00005e90: 6f6e 6669 6720 3d20 7365 6c66 2e63 6f6e  onfig = self.con
+00005ea0: 6669 670a 2020 2020 2020 2020 6d20 3d20  fig.        m = 
+00005eb0: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
+00005ec0: 656c 0a20 2020 2020 2020 2075 7469 6c5f  el.        util_
+00005ed0: 626c 6f63 6b20 3d20 6765 7461 7474 7228  block = getattr(
+00005ee0: 6d2c 2073 656c 662e 7574 696c 5f62 6c6f  m, self.util_blo
+00005ef0: 636b 5f6e 616d 6529 0a20 2020 2020 2020  ck_name).       
+00005f00: 2023 2048 616e 646c 6520 6d69 7373 696e   # Handle missin
+00005f10: 6720 6f72 206d 756c 7469 706c 6520 6f62  g or multiple ob
+00005f20: 6a65 6374 6976 6573 0a20 2020 2020 2020  jectives.       
+00005f30: 2061 6374 6976 655f 6f62 6a65 6374 6976   active_objectiv
+00005f40: 6573 203d 206c 6973 7428 0a20 2020 2020  es = list(.     
+00005f50: 2020 2020 2020 206d 2e63 6f6d 706f 6e65         m.compone
+00005f60: 6e74 5f64 6174 615f 6f62 6a65 6374 7328  nt_data_objects(
+00005f70: 6374 7970 653d 4f62 6a65 6374 6976 652c  ctype=Objective,
+00005f80: 2061 6374 6976 653d 5472 7565 2c20 6465   active=True, de
+00005f90: 7363 656e 645f 696e 746f 3d54 7275 6529  scend_into=True)
+00005fa0: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
+00005fb0: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
+00005fc0: 7072 6f62 6c65 6d2e 6e75 6d62 6572 5f6f  problem.number_o
+00005fd0: 665f 6f62 6a65 6374 6976 6573 203d 206c  f_objectives = l
+00005fe0: 656e 2861 6374 6976 655f 6f62 6a65 6374  en(active_object
+00005ff0: 6976 6573 290a 2020 2020 2020 2020 6966  ives).        if
+00006000: 206c 656e 2861 6374 6976 655f 6f62 6a65   len(active_obje
+00006010: 6374 6976 6573 2920 3d3d 2030 3a0a 2020  ctives) == 0:.  
+00006020: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+00006030: 2e6c 6f67 6765 722e 7761 726e 696e 6728  .logger.warning(
+00006040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006050: 2027 4d6f 6465 6c20 6861 7320 6e6f 2061   'Model has no a
+00006060: 6374 6976 6520 6f62 6a65 6374 6976 6573  ctive objectives
+00006070: 2e20 4164 6469 6e67 2064 756d 6d79 206f  . Adding dummy o
+00006080: 626a 6563 7469 7665 2e27 0a20 2020 2020  bjective.'.     
+00006090: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000060a0: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
+000060b0: 6475 6d6d 795f 6f62 6a65 6374 6976 6520  dummy_objective 
+000060c0: 3d20 4f62 6a65 6374 6976 6528 6578 7072  = Objective(expr
+000060d0: 3d31 290a 2020 2020 2020 2020 2020 2020  =1).            
+000060e0: 6d61 696e 5f6f 626a 203d 2075 7469 6c5f  main_obj = util_
+000060f0: 626c 6f63 6b2e 6475 6d6d 795f 6f62 6a65  block.dummy_obje
+00006100: 6374 6976 650a 2020 2020 2020 2020 656c  ctive.        el
+00006110: 6966 206c 656e 2861 6374 6976 655f 6f62  if len(active_ob
+00006120: 6a65 6374 6976 6573 2920 3e20 313a 0a20  jectives) > 1:. 
+00006130: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00006140: 2056 616c 7565 4572 726f 7228 274d 6f64   ValueError('Mod
+00006150: 656c 2068 6173 206d 756c 7469 706c 6520  el has multiple 
+00006160: 6163 7469 7665 206f 626a 6563 7469 7665  active objective
+00006170: 732e 2729 0a20 2020 2020 2020 2065 6c73  s.').        els
+00006180: 653a 0a20 2020 2020 2020 2020 2020 206d  e:.            m
+00006190: 6169 6e5f 6f62 6a20 3d20 6163 7469 7665  ain_obj = active
+000061a0: 5f6f 626a 6563 7469 7665 735b 305d 0a20  _objectives[0]. 
+000061b0: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+000061c0: 6c74 732e 7072 6f62 6c65 6d2e 7365 6e73  lts.problem.sens
+000061d0: 6520 3d20 6d61 696e 5f6f 626a 2e73 656e  e = main_obj.sen
+000061e0: 7365 0a20 2020 2020 2020 2073 656c 662e  se.        self.
+000061f0: 6f62 6a65 6374 6976 655f 7365 6e73 6520  objective_sense 
+00006200: 3d20 6d61 696e 5f6f 626a 2e73 656e 7365  = main_obj.sense
+00006210: 0a0a 2020 2020 2020 2020 2320 4d6f 7665  ..        # Move
+00006220: 2074 6865 206f 626a 6563 7469 7665 2074   the objective t
+00006230: 6f20 7468 6520 636f 6e73 7472 6169 6e74  o the constraint
+00006240: 7320 6966 2069 7420 6973 206e 6f6e 6c69  s if it is nonli
+00006250: 6e65 6172 206f 7220 6d6f 7665 5f6f 626a  near or move_obj
+00006260: 6563 7469 7665 2069 7320 5472 7565 2e0a  ective is True..
+00006270: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
+00006280: 2020 2020 2020 2020 206d 6169 6e5f 6f62           main_ob
+00006290: 6a2e 6578 7072 2e70 6f6c 796e 6f6d 6961  j.expr.polynomia
+000062a0: 6c5f 6465 6772 6565 2829 0a20 2020 2020  l_degree().     
+000062b0: 2020 2020 2020 206e 6f74 2069 6e20 7365         not in se
+000062c0: 6c66 2e6d 6970 5f6f 626a 6563 7469 7665  lf.mip_objective
+000062d0: 5f70 6f6c 796e 6f6d 6961 6c5f 6465 6772  _polynomial_degr
+000062e0: 6565 0a20 2020 2020 2020 2020 2020 206f  ee.            o
+000062f0: 7220 636f 6e66 6967 2e6d 6f76 655f 6f62  r config.move_ob
+00006300: 6a65 6374 6976 650a 2020 2020 2020 2020  jective.        
+00006310: 293a 0a20 2020 2020 2020 2020 2020 2069  ):.            i
+00006320: 6620 636f 6e66 6967 2e6d 6f76 655f 6f62  f config.move_ob
+00006330: 6a65 6374 6976 653a 0a20 2020 2020 2020  jective:.       
+00006340: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00006350: 6c6f 6767 6572 2e69 6e66 6f28 224d 6f76  logger.info("Mov
+00006360: 696e 6720 6f62 6a65 6374 6976 6520 746f  ing objective to
+00006370: 2063 6f6e 7374 7261 696e 7420 7365 742e   constraint set.
+00006380: 2229 0a20 2020 2020 2020 2020 2020 2065  ").            e
+00006390: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000063a0: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
+000063b0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
+000063c0: 2020 2020 2020 2020 2020 2020 2022 4f62               "Ob
+000063d0: 6a65 6374 6976 6520 6973 206e 6f6e 6c69  jective is nonli
+000063e0: 6e65 6172 2e20 4d6f 7669 6e67 2069 7420  near. Moving it 
+000063f0: 746f 2063 6f6e 7374 7261 696e 7420 7365  to constraint se
+00006400: 742e 220a 2020 2020 2020 2020 2020 2020  t.".            
+00006410: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00006420: 2020 7574 696c 5f62 6c6f 636b 2e6f 626a    util_block.obj
+00006430: 6563 7469 7665 5f76 616c 7565 203d 2056  ective_value = V
+00006440: 6172 4c69 7374 2864 6f6d 6169 6e3d 5265  arList(domain=Re
+00006450: 616c 732c 2069 6e69 7469 616c 697a 653d  als, initialize=
+00006460: 3029 0a20 2020 2020 2020 2020 2020 2075  0).            u
+00006470: 7469 6c5f 626c 6f63 6b2e 6f62 6a65 6374  til_block.object
+00006480: 6976 655f 636f 6e73 7472 203d 2043 6f6e  ive_constr = Con
+00006490: 7374 7261 696e 744c 6973 7428 290a 2020  straintList().  
+000064a0: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+000064b0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+000064c0: 6169 6e5f 6f62 6a2e 6578 7072 2e70 6f6c  ain_obj.expr.pol
+000064d0: 796e 6f6d 6961 6c5f 6465 6772 6565 2829  ynomial_degree()
+000064e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000064f0: 206e 6f74 2069 6e20 7365 6c66 2e6d 6970   not in self.mip
+00006500: 5f6f 626a 6563 7469 7665 5f70 6f6c 796e  _objective_polyn
+00006510: 6f6d 6961 6c5f 6465 6772 6565 0a20 2020  omial_degree.   
+00006520: 2020 2020 2020 2020 2020 2020 2061 6e64               and
+00006530: 2063 6f6e 6669 672e 7061 7274 6974 696f   config.partitio
+00006540: 6e5f 6f62 6a5f 6e6f 6e6c 696e 6561 725f  n_obj_nonlinear_
+00006550: 7465 726d 730a 2020 2020 2020 2020 2020  terms.          
+00006560: 2020 2020 2020 616e 6420 6d61 696e 5f6f        and main_o
+00006570: 626a 2e65 7870 722e 5f5f 636c 6173 735f  bj.expr.__class_
+00006580: 5f20 6973 2045 5850 522e 5375 6d45 7870  _ is EXPR.SumExp
+00006590: 7265 7373 696f 6e0a 2020 2020 2020 2020  ression.        
+000065a0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+000065b0: 2020 2020 2020 2072 6570 6e20 3d20 6765         repn = ge
+000065c0: 6e65 7261 7465 5f73 7461 6e64 6172 645f  nerate_standard_
+000065d0: 7265 706e 280a 2020 2020 2020 2020 2020  repn(.          
+000065e0: 2020 2020 2020 2020 2020 6d61 696e 5f6f            main_o
+000065f0: 626a 2e65 7870 722c 2071 7561 6472 6174  bj.expr, quadrat
+00006600: 6963 3d32 2069 6e20 7365 6c66 2e6d 6970  ic=2 in self.mip
+00006610: 5f6f 626a 6563 7469 7665 5f70 6f6c 796e  _objective_polyn
+00006620: 6f6d 6961 6c5f 6465 6772 6565 0a20 2020  omial_degree.   
+00006630: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00006640: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+00006650: 2074 6865 2066 6f6c 6c6f 7769 6e67 2063   the following c
+00006660: 6f64 6520 7769 6c6c 2061 6c73 6f20 776f  ode will also wo
+00006670: 726b 2069 6620 6c69 6e65 6172 5f73 7562  rk if linear_sub
+00006680: 6578 7072 2069 7320 6120 636f 6e73 7461  expr is a consta
+00006690: 6e74 2e0a 2020 2020 2020 2020 2020 2020  nt..            
+000066a0: 2020 2020 6c69 6e65 6172 5f73 7562 6578      linear_subex
+000066b0: 7072 203d 2028 0a20 2020 2020 2020 2020  pr = (.         
+000066c0: 2020 2020 2020 2020 2020 2072 6570 6e2e             repn.
+000066d0: 636f 6e73 7461 6e74 0a20 2020 2020 2020  constant.       
+000066e0: 2020 2020 2020 2020 2020 2020 202b 2073               + s
+000066f0: 756d 280a 2020 2020 2020 2020 2020 2020  um(.            
+00006700: 2020 2020 2020 2020 2020 2020 636f 6566              coef
+00006710: 202a 2076 6172 0a20 2020 2020 2020 2020   * var.         
+00006720: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00006730: 6f72 2063 6f65 662c 2076 6172 2069 6e20  or coef, var in 
+00006740: 7a69 7028 7265 706e 2e6c 696e 6561 725f  zip(repn.linear_
+00006750: 636f 6566 732c 2072 6570 6e2e 6c69 6e65  coefs, repn.line
+00006760: 6172 5f76 6172 7329 0a20 2020 2020 2020  ar_vars).       
+00006770: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
 00006780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006790: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000067a0: 2020 2020 2020 2b20 7375 6d28 0a20 2020        + sum(.   
-000067b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067c0: 2020 2020 2063 6f65 6620 2a20 7661 7231       coef * var1
-000067d0: 202a 2076 6172 320a 2020 2020 2020 2020   * var2.        
-000067e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067f0: 666f 7220 636f 6566 2c20 2876 6172 312c  for coef, (var1,
-00006800: 2076 6172 3229 2069 6e20 7a69 7028 0a20   var2) in zip(. 
-00006810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006820: 2020 2020 2020 2020 2020 2072 6570 6e2e             repn.
-00006830: 7175 6164 7261 7469 635f 636f 6566 732c  quadratic_coefs,
-00006840: 2072 6570 6e2e 7175 6164 7261 7469 635f   repn.quadratic_
-00006850: 7661 7273 0a20 2020 2020 2020 2020 2020  vars.           
-00006860: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
-00006870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006880: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00006890: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-000068a0: 2020 2020 2020 2023 206f 6e6c 7920 6e65         # only ne
-000068b0: 6564 2074 6f20 6765 6e65 7261 7465 206f  ed to generate o
-000068c0: 6e65 2065 7069 6772 6170 6820 636f 6e73  ne epigraph cons
-000068d0: 7472 6169 6e74 2066 6f72 2074 6865 2073  traint for the s
-000068e0: 756d 206f 6620 616c 6c20 6c69 6e65 6172  um of all linear
-000068f0: 2074 6572 6d73 2061 6e64 2063 6f6e 7374   terms and const
-00006900: 616e 740a 2020 2020 2020 2020 2020 2020  ant.            
-00006910: 2020 2020 6570 6967 7261 7068 5f72 6566      epigraph_ref
-00006920: 6f72 6d75 6c61 7469 6f6e 280a 2020 2020  ormulation(.    
-00006930: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006940: 6c69 6e65 6172 5f73 7562 6578 7072 2c0a  linear_subexpr,.
-00006950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006960: 2020 2020 7574 696c 5f62 6c6f 636b 2e6f      util_block.o
-00006970: 626a 6563 7469 7665 5f76 616c 7565 2c0a  bjective_value,.
-00006980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006990: 2020 2020 7574 696c 5f62 6c6f 636b 2e6f      util_block.o
-000069a0: 626a 6563 7469 7665 5f63 6f6e 7374 722c  bjective_constr,
-000069b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000069c0: 2020 2020 2063 6f6e 6669 672e 7573 655f       config.use_
-000069d0: 6d63 7070 2c0a 2020 2020 2020 2020 2020  mcpp,.          
-000069e0: 2020 2020 2020 2020 2020 6d61 696e 5f6f            main_o
-000069f0: 626a 2e73 656e 7365 2c0a 2020 2020 2020  bj.sense,.      
-00006a00: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00006a10: 2020 2020 2020 2020 2020 2020 6e6f 6e6c              nonl
-00006a20: 696e 6561 725f 7375 6265 7870 7220 3d20  inear_subexpr = 
-00006a30: 7265 706e 2e6e 6f6e 6c69 6e65 6172 5f65  repn.nonlinear_e
-00006a40: 7870 720a 2020 2020 2020 2020 2020 2020  xpr.            
-00006a50: 2020 2020 6966 206e 6f6e 6c69 6e65 6172      if nonlinear
-00006a60: 5f73 7562 6578 7072 2e5f 5f63 6c61 7373  _subexpr.__class
-00006a70: 5f5f 2069 7320 4558 5052 2e53 756d 4578  __ is EXPR.SumEx
-00006a80: 7072 6573 7369 6f6e 3a0a 2020 2020 2020  pression:.      
-00006a90: 2020 2020 2020 2020 2020 2020 2020 666f                fo
-00006aa0: 7220 7375 6273 7562 6578 7072 2069 6e20  r subsubexpr in 
-00006ab0: 6e6f 6e6c 696e 6561 725f 7375 6265 7870  nonlinear_subexp
-00006ac0: 722e 6172 6773 3a0a 2020 2020 2020 2020  r.args:.        
-00006ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006ae0: 6570 6967 7261 7068 5f72 6566 6f72 6d75  epigraph_reformu
-00006af0: 6c61 7469 6f6e 280a 2020 2020 2020 2020  lation(.        
-00006b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b10: 2020 2020 7375 6273 7562 6578 7072 2c0a      subsubexpr,.
-00006b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b30: 2020 2020 2020 2020 2020 2020 7574 696c              util
-00006b40: 5f62 6c6f 636b 2e6f 626a 6563 7469 7665  _block.objective
-00006b50: 5f76 616c 7565 2c0a 2020 2020 2020 2020  _value,.        
-00006b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006b70: 2020 2020 7574 696c 5f62 6c6f 636b 2e6f      util_block.o
-00006b80: 626a 6563 7469 7665 5f63 6f6e 7374 722c  bjective_constr,
-00006b90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006ba0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00006bb0: 6669 672e 7573 655f 6d63 7070 2c0a 2020  fig.use_mcpp,.  
-00006bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006bd0: 2020 2020 2020 2020 2020 6d61 696e 5f6f            main_o
-00006be0: 626a 2e73 656e 7365 2c0a 2020 2020 2020  bj.sense,.      
-00006bf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006c00: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00006c10: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00006c20: 2020 2020 2020 2020 2020 2020 2020 6570                ep
-00006c30: 6967 7261 7068 5f72 6566 6f72 6d75 6c61  igraph_reformula
-00006c40: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
-00006c50: 2020 2020 2020 2020 2020 2020 2020 6e6f                no
-00006c60: 6e6c 696e 6561 725f 7375 6265 7870 722c  nlinear_subexpr,
-00006c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00006c80: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
-00006c90: 6f63 6b2e 6f62 6a65 6374 6976 655f 7661  ock.objective_va
-00006ca0: 6c75 652c 0a20 2020 2020 2020 2020 2020  lue,.           
-00006cb0: 2020 2020 2020 2020 2020 2020 2075 7469               uti
-00006cc0: 6c5f 626c 6f63 6b2e 6f62 6a65 6374 6976  l_block.objectiv
-00006cd0: 655f 636f 6e73 7472 2c0a 2020 2020 2020  e_constr,.      
-00006ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006cf0: 2020 636f 6e66 6967 2e75 7365 5f6d 6370    config.use_mcp
-00006d00: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-00006d10: 2020 2020 2020 2020 2020 206d 6169 6e5f             main_
-00006d20: 6f62 6a2e 7365 6e73 652c 0a20 2020 2020  obj.sense,.     
-00006d30: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-00006d40: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00006d50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00006d60: 2020 2065 7069 6772 6170 685f 7265 666f     epigraph_refo
-00006d70: 726d 756c 6174 696f 6e28 0a20 2020 2020  rmulation(.     
-00006d80: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00006d90: 6169 6e5f 6f62 6a2e 6578 7072 2c0a 2020  ain_obj.expr,.  
-00006da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006db0: 2020 7574 696c 5f62 6c6f 636b 2e6f 626a    util_block.obj
-00006dc0: 6563 7469 7665 5f76 616c 7565 2c0a 2020  ective_value,.  
-00006dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006de0: 2020 7574 696c 5f62 6c6f 636b 2e6f 626a    util_block.obj
-00006df0: 6563 7469 7665 5f63 6f6e 7374 722c 0a20  ective_constr,. 
-00006e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006e10: 2020 2063 6f6e 6669 672e 7573 655f 6d63     config.use_mc
-00006e20: 7070 2c0a 2020 2020 2020 2020 2020 2020  pp,.            
-00006e30: 2020 2020 2020 2020 6d61 696e 5f6f 626a          main_obj
-00006e40: 2e73 656e 7365 2c0a 2020 2020 2020 2020  .sense,.        
-00006e50: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-00006e60: 2020 2020 2020 206d 6169 6e5f 6f62 6a2e         main_obj.
-00006e70: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
-00006e80: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
-00006e90: 6f63 6b2e 6f62 6a65 6374 6976 6520 3d20  ock.objective = 
-00006ea0: 4f62 6a65 6374 6976 6528 0a20 2020 2020  Objective(.     
-00006eb0: 2020 2020 2020 2020 2020 2065 7870 723d             expr=
-00006ec0: 7375 6d28 7574 696c 5f62 6c6f 636b 2e6f  sum(util_block.o
-00006ed0: 626a 6563 7469 7665 5f76 616c 7565 5b3a  bjective_value[:
-00006ee0: 5d29 2c20 7365 6e73 653d 6d61 696e 5f6f  ]), sense=main_o
-00006ef0: 626a 2e73 656e 7365 0a20 2020 2020 2020  bj.sense.       
-00006f00: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
-00006f10: 2020 2020 6966 2028 0a20 2020 2020 2020      if (.       
-00006f20: 2020 2020 2020 2020 206d 6169 6e5f 6f62           main_ob
-00006f30: 6a2e 6578 7072 2e70 6f6c 796e 6f6d 6961  j.expr.polynomia
-00006f40: 6c5f 6465 6772 6565 2829 0a20 2020 2020  l_degree().     
-00006f50: 2020 2020 2020 2020 2020 206e 6f74 2069             not i
-00006f60: 6e20 7365 6c66 2e6d 6970 5f6f 626a 6563  n self.mip_objec
-00006f70: 7469 7665 5f70 6f6c 796e 6f6d 6961 6c5f  tive_polynomial_
-00006f80: 6465 6772 6565 0a20 2020 2020 2020 2020  degree.         
-00006f90: 2020 2020 2020 206f 7220 2863 6f6e 6669         or (confi
-00006fa0: 672e 6d6f 7665 5f6f 626a 6563 7469 7665  g.move_objective
-00006fb0: 2061 6e64 2075 7064 6174 655f 7661 725f   and update_var_
-00006fc0: 636f 6e5f 6c69 7374 290a 2020 2020 2020  con_list).      
-00006fd0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
-00006fe0: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
-00006ff0: 6f63 6b2e 7661 7269 6162 6c65 5f6c 6973  ock.variable_lis
-00007000: 742e 6578 7465 6e64 2875 7469 6c5f 626c  t.extend(util_bl
-00007010: 6f63 6b2e 6f62 6a65 6374 6976 655f 7661  ock.objective_va
-00007020: 6c75 655b 3a5d 290a 2020 2020 2020 2020  lue[:]).        
-00007030: 2020 2020 2020 2020 7574 696c 5f62 6c6f          util_blo
-00007040: 636b 2e63 6f6e 7469 6e75 6f75 735f 7661  ck.continuous_va
-00007050: 7269 6162 6c65 5f6c 6973 742e 6578 7465  riable_list.exte
-00007060: 6e64 280a 2020 2020 2020 2020 2020 2020  nd(.            
-00007070: 2020 2020 2020 2020 7574 696c 5f62 6c6f          util_blo
-00007080: 636b 2e6f 626a 6563 7469 7665 5f76 616c  ck.objective_val
-00007090: 7565 5b3a 5d0a 2020 2020 2020 2020 2020  ue[:].          
-000070a0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-000070b0: 2020 2020 2020 2020 7574 696c 5f62 6c6f          util_blo
-000070c0: 636b 2e63 6f6e 7374 7261 696e 745f 6c69  ck.constraint_li
-000070d0: 7374 2e65 7874 656e 6428 7574 696c 5f62  st.extend(util_b
-000070e0: 6c6f 636b 2e6f 626a 6563 7469 7665 5f63  lock.objective_c
-000070f0: 6f6e 7374 725b 3a5d 290a 2020 2020 2020  onstr[:]).      
-00007100: 2020 2020 2020 2020 2020 7574 696c 5f62            util_b
-00007110: 6c6f 636b 2e6f 626a 6563 7469 7665 5f6c  lock.objective_l
-00007120: 6973 742e 6170 7065 6e64 2875 7469 6c5f  ist.append(util_
-00007130: 626c 6f63 6b2e 6f62 6a65 6374 6976 6529  block.objective)
-00007140: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007150: 2066 6f72 2063 6f6e 7374 7220 696e 2075   for constr in u
-00007160: 7469 6c5f 626c 6f63 6b2e 6f62 6a65 6374  til_block.object
-00007170: 6976 655f 636f 6e73 7472 5b3a 5d3a 0a20  ive_constr[:]:. 
-00007180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007190: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
-000071a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071b0: 636f 6e73 7472 2e62 6f64 792e 706f 6c79  constr.body.poly
-000071c0: 6e6f 6d69 616c 5f64 6567 7265 6528 290a  nomial_degree().
-000071d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071e0: 2020 2020 2020 2020 696e 2073 656c 662e          in self.
-000071f0: 6d69 705f 636f 6e73 7472 6169 6e74 5f70  mip_constraint_p
-00007200: 6f6c 796e 6f6d 6961 6c5f 6465 6772 6565  olynomial_degree
-00007210: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007220: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-00007230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007240: 7574 696c 5f62 6c6f 636b 2e6c 696e 6561  util_block.linea
-00007250: 725f 636f 6e73 7472 6169 6e74 5f6c 6973  r_constraint_lis
-00007260: 742e 6170 7065 6e64 2863 6f6e 7374 7229  t.append(constr)
-00007270: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007280: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00007290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000072a0: 2020 2075 7469 6c5f 626c 6f63 6b2e 6e6f     util_block.no
-000072b0: 6e6c 696e 6561 725f 636f 6e73 7472 6169  nlinear_constrai
-000072c0: 6e74 5f6c 6973 742e 6170 7065 6e64 2863  nt_list.append(c
-000072d0: 6f6e 7374 7229 0a0a 2020 2020 6465 6620  onstr)..    def 
-000072e0: 7365 745f 7570 5f73 6f6c 7665 5f64 6174  set_up_solve_dat
-000072f0: 6128 7365 6c66 2c20 6d6f 6465 6c29 3a0a  a(self, model):.
-00007300: 2020 2020 2020 2020 2222 2253 6574 2075          """Set u
-00007310: 7020 7468 6520 736f 6c76 6520 6461 7461  p the solve data
-00007320: 2e0a 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-00007330: 6574 6572 730a 2020 2020 2020 2020 2d2d  eters.        --
-00007340: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020 2020  --------.       
-00007350: 206d 6f64 656c 203a 2050 796f 6d6f 206d   model : Pyomo m
-00007360: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
-00007370: 2054 6865 206f 7269 6769 6e61 6c20 6d6f   The original mo
-00007380: 6465 6c20 746f 2062 6520 736f 6c76 6564  del to be solved
-00007390: 2069 6e20 4d69 6e64 7450 792e 0a20 2020   in MindtPy..   
-000073a0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000073b0: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
-000073c0: 6f6e 6669 670a 2020 2020 2020 2020 2320  onfig.        # 
-000073d0: 6966 2074 6865 206f 626a 6563 7469 7665  if the objective
-000073e0: 2066 756e 6374 696f 6e20 6973 2061 2063   function is a c
-000073f0: 6f6e 7374 616e 742c 2064 7561 6c20 626f  onstant, dual bo
-00007400: 756e 6420 636f 6e73 7472 6169 6e74 2069  und constraint i
-00007410: 7320 6e6f 7420 6164 6465 642e 0a20 2020  s not added..   
-00007420: 2020 2020 206f 626a 203d 206e 6578 7428       obj = next(
-00007430: 6d6f 6465 6c2e 636f 6d70 6f6e 656e 745f  model.component_
-00007440: 6461 7461 5f6f 626a 6563 7473 2863 7479  data_objects(cty
-00007450: 7065 3d4f 626a 6563 7469 7665 2c20 6163  pe=Objective, ac
-00007460: 7469 7665 3d54 7275 6529 290a 2020 2020  tive=True)).    
-00007470: 2020 2020 6966 206f 626a 2e65 7870 722e      if obj.expr.
-00007480: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
-00007490: 6528 2920 3d3d 2030 3a0a 2020 2020 2020  e() == 0:.      
-000074a0: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
-000074b0: 6765 722e 696e 666f 280a 2020 2020 2020  ger.info(.      
-000074c0: 2020 2020 2020 2020 2020 2754 6865 206d            'The m
-000074d0: 6f64 656c 2068 6173 2061 2063 6f6e 7374  odel has a const
-000074e0: 616e 7420 6f62 6a65 6369 7469 7665 2066  ant objecitive f
-000074f0: 756e 6374 696f 6e2e 2075 7365 5f64 7561  unction. use_dua
-00007500: 6c5f 626f 756e 6420 6973 2073 6574 2074  l_bound is set t
-00007510: 6f20 4661 6c73 652e 270a 2020 2020 2020  o False.'.      
-00007520: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00007530: 2020 2020 636f 6e66 6967 2e75 7365 5f64      config.use_d
-00007540: 7561 6c5f 626f 756e 6420 3d20 4661 6c73  ual_bound = Fals
-00007550: 650a 0a20 2020 2020 2020 2069 6620 636f  e..        if co
-00007560: 6e66 6967 2e75 7365 5f66 6262 743a 0a20  nfig.use_fbbt:. 
-00007570: 2020 2020 2020 2020 2020 2066 6262 7428             fbbt(
-00007580: 6d6f 6465 6c29 0a20 2020 2020 2020 2020  model).         
-00007590: 2020 2023 2054 4f44 4f3a 206c 6f67 6769     # TODO: loggi
-000075a0: 6e67 5f6c 6576 656c 2069 7320 6e6f 7420  ng_level is not 
-000075b0: 6c6f 6767 696e 672e 494e 464f 2068 6572  logging.INFO her
-000075c0: 650a 2020 2020 2020 2020 2020 2020 636f  e.            co
-000075d0: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-000075e0: 2827 5573 6520 7468 6520 6662 6274 2074  ('Use the fbbt t
-000075f0: 6f20 7469 6768 7465 6e20 7468 6520 626f  o tighten the bo
-00007600: 756e 6473 206f 6620 7661 7269 6162 6c65  unds of variable
-00007610: 7327 290a 0a20 2020 2020 2020 2073 656c  s')..        sel
-00007620: 662e 6f72 6967 696e 616c 5f6d 6f64 656c  f.original_model
-00007630: 203d 206d 6f64 656c 0a20 2020 2020 2020   = model.       
-00007640: 2073 656c 662e 776f 726b 696e 675f 6d6f   self.working_mo
-00007650: 6465 6c20 3d20 6d6f 6465 6c2e 636c 6f6e  del = model.clon
-00007660: 6528 290a 0a20 2020 2020 2020 2023 2073  e()..        # s
-00007670: 6574 2075 7020 626f 756e 6473 0a20 2020  et up bounds.   
-00007680: 2020 2020 2069 6620 6f62 6a2e 7365 6e73       if obj.sens
-00007690: 6520 3d3d 206d 696e 696d 697a 653a 0a20  e == minimize:. 
-000076a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000076b0: 7072 696d 616c 5f62 6f75 6e64 203d 2066  primal_bound = f
-000076c0: 6c6f 6174 2827 696e 6627 290a 2020 2020  loat('inf').    
-000076d0: 2020 2020 2020 2020 7365 6c66 2e64 7561          self.dua
-000076e0: 6c5f 626f 756e 6420 3d20 666c 6f61 7428  l_bound = float(
-000076f0: 272d 696e 6627 290a 2020 2020 2020 2020  '-inf').        
-00007700: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00007710: 2020 7365 6c66 2e70 7269 6d61 6c5f 626f    self.primal_bo
-00007720: 756e 6420 3d20 666c 6f61 7428 272d 696e  und = float('-in
-00007730: 6627 290a 2020 2020 2020 2020 2020 2020  f').            
-00007740: 7365 6c66 2e64 7561 6c5f 626f 756e 6420  self.dual_bound 
-00007750: 3d20 666c 6f61 7428 2769 6e66 2729 0a20  = float('inf'). 
-00007760: 2020 2020 2020 2073 656c 662e 7072 696d         self.prim
-00007770: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
-00007780: 7320 3d20 5b73 656c 662e 7072 696d 616c  s = [self.primal
-00007790: 5f62 6f75 6e64 5d0a 2020 2020 2020 2020  _bound].        
-000077a0: 7365 6c66 2e64 7561 6c5f 626f 756e 645f  self.dual_bound_
-000077b0: 7072 6f67 7265 7373 203d 205b 7365 6c66  progress = [self
-000077c0: 2e64 7561 6c5f 626f 756e 645d 0a0a 2020  .dual_bound]..  
-000077d0: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
-000077e0: 6e6c 705f 736f 6c76 6572 2069 6e20 7b27  nlp_solver in {'
-000077f0: 6970 6f70 7427 2c20 2763 7969 706f 7074  ipopt', 'cyipopt
-00007800: 277d 3a0a 2020 2020 2020 2020 2020 2020  '}:.            
-00007810: 6966 206e 6f74 2068 6173 6174 7472 2873  if not hasattr(s
-00007820: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
-00007830: 6c2c 2027 6970 6f70 745f 7a4c 5f6f 7574  l, 'ipopt_zL_out
-00007840: 2729 3a0a 2020 2020 2020 2020 2020 2020  '):.            
-00007850: 2020 2020 7365 6c66 2e77 6f72 6b69 6e67      self.working
-00007860: 5f6d 6f64 656c 2e69 706f 7074 5f7a 4c5f  _model.ipopt_zL_
-00007870: 6f75 7420 3d20 5375 6666 6978 2864 6972  out = Suffix(dir
-00007880: 6563 7469 6f6e 3d53 7566 6669 782e 494d  ection=Suffix.IM
-00007890: 504f 5254 290a 2020 2020 2020 2020 2020  PORT).          
-000078a0: 2020 6966 206e 6f74 2068 6173 6174 7472    if not hasattr
-000078b0: 2873 656c 662e 776f 726b 696e 675f 6d6f  (self.working_mo
-000078c0: 6465 6c2c 2027 6970 6f70 745f 7a55 5f6f  del, 'ipopt_zU_o
-000078d0: 7574 2729 3a0a 2020 2020 2020 2020 2020  ut'):.          
-000078e0: 2020 2020 2020 7365 6c66 2e77 6f72 6b69        self.worki
-000078f0: 6e67 5f6d 6f64 656c 2e69 706f 7074 5f7a  ng_model.ipopt_z
-00007900: 555f 6f75 7420 3d20 5375 6666 6978 2864  U_out = Suffix(d
-00007910: 6972 6563 7469 6f6e 3d53 7566 6669 782e  irection=Suffix.
-00007920: 494d 504f 5254 290a 0a20 2020 2020 2020  IMPORT)..       
-00007930: 2069 6620 636f 6e66 6967 2e71 7561 6472   if config.quadr
-00007940: 6174 6963 5f73 7472 6174 6567 7920 3d3d  atic_strategy ==
-00007950: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-00007960: 7365 6c66 2e6d 6970 5f6f 626a 6563 7469  self.mip_objecti
-00007970: 7665 5f70 6f6c 796e 6f6d 6961 6c5f 6465  ve_polynomial_de
-00007980: 6772 6565 203d 207b 302c 2031 7d0a 2020  gree = {0, 1}.  
-00007990: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
-000079a0: 6970 5f63 6f6e 7374 7261 696e 745f 706f  ip_constraint_po
-000079b0: 6c79 6e6f 6d69 616c 5f64 6567 7265 6520  lynomial_degree 
-000079c0: 3d20 7b30 2c20 317d 0a20 2020 2020 2020  = {0, 1}.       
-000079d0: 2065 6c69 6620 636f 6e66 6967 2e71 7561   elif config.qua
-000079e0: 6472 6174 6963 5f73 7472 6174 6567 7920  dratic_strategy 
-000079f0: 3d3d 2031 3a0a 2020 2020 2020 2020 2020  == 1:.          
-00007a00: 2020 7365 6c66 2e6d 6970 5f6f 626a 6563    self.mip_objec
-00007a10: 7469 7665 5f70 6f6c 796e 6f6d 6961 6c5f  tive_polynomial_
-00007a20: 6465 6772 6565 203d 207b 302c 2031 2c20  degree = {0, 1, 
-00007a30: 327d 0a20 2020 2020 2020 2020 2020 2073  2}.            s
-00007a40: 656c 662e 6d69 705f 636f 6e73 7472 6169  elf.mip_constrai
-00007a50: 6e74 5f70 6f6c 796e 6f6d 6961 6c5f 6465  nt_polynomial_de
-00007a60: 6772 6565 203d 207b 302c 2031 7d0a 2020  gree = {0, 1}.  
-00007a70: 2020 2020 2020 656c 6966 2063 6f6e 6669        elif confi
-00007a80: 672e 7175 6164 7261 7469 635f 7374 7261  g.quadratic_stra
-00007a90: 7465 6779 203d 3d20 323a 0a20 2020 2020  tegy == 2:.     
-00007aa0: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-00007ab0: 6f62 6a65 6374 6976 655f 706f 6c79 6e6f  objective_polyno
-00007ac0: 6d69 616c 5f64 6567 7265 6520 3d20 7b30  mial_degree = {0
-00007ad0: 2c20 312c 2032 7d0a 2020 2020 2020 2020  , 1, 2}.        
-00007ae0: 2020 2020 7365 6c66 2e6d 6970 5f63 6f6e      self.mip_con
-00007af0: 7374 7261 696e 745f 706f 6c79 6e6f 6d69  straint_polynomi
-00007b00: 616c 5f64 6567 7265 6520 3d20 7b30 2c20  al_degree = {0, 
-00007b10: 312c 2032 7d0a 0a20 2020 2023 202d 2d2d  1, 2}..    # ---
+00006790: 2020 202b 2073 756d 280a 2020 2020 2020     + sum(.      
+000067a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000067b0: 2020 636f 6566 202a 2076 6172 3120 2a20    coef * var1 * 
+000067c0: 7661 7232 0a20 2020 2020 2020 2020 2020  var2.           
+000067d0: 2020 2020 2020 2020 2020 2020 2066 6f72               for
+000067e0: 2063 6f65 662c 2028 7661 7231 2c20 7661   coef, (var1, va
+000067f0: 7232 2920 696e 207a 6970 280a 2020 2020  r2) in zip(.    
+00006800: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006810: 2020 2020 2020 2020 7265 706e 2e71 7561          repn.qua
+00006820: 6472 6174 6963 5f63 6f65 6673 2c20 7265  dratic_coefs, re
+00006830: 706e 2e71 7561 6472 6174 6963 5f76 6172  pn.quadratic_var
+00006840: 730a 2020 2020 2020 2020 2020 2020 2020  s.              
+00006850: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00006860: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006870: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00006880: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00006890: 2020 2020 2320 6f6e 6c79 206e 6565 6420      # only need 
+000068a0: 746f 2067 656e 6572 6174 6520 6f6e 6520  to generate one 
+000068b0: 6570 6967 7261 7068 2063 6f6e 7374 7261  epigraph constra
+000068c0: 696e 7420 666f 7220 7468 6520 7375 6d20  int for the sum 
+000068d0: 6f66 2061 6c6c 206c 696e 6561 7220 7465  of all linear te
+000068e0: 726d 7320 616e 6420 636f 6e73 7461 6e74  rms and constant
+000068f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006900: 2065 7069 6772 6170 685f 7265 666f 726d   epigraph_reform
+00006910: 756c 6174 696f 6e28 0a20 2020 2020 2020  ulation(.       
+00006920: 2020 2020 2020 2020 2020 2020 206c 696e               lin
+00006930: 6561 725f 7375 6265 7870 722c 0a20 2020  ear_subexpr,.   
+00006940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006950: 2075 7469 6c5f 626c 6f63 6b2e 6f62 6a65   util_block.obje
+00006960: 6374 6976 655f 7661 6c75 652c 0a20 2020  ctive_value,.   
+00006970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006980: 2075 7469 6c5f 626c 6f63 6b2e 6f62 6a65   util_block.obje
+00006990: 6374 6976 655f 636f 6e73 7472 2c0a 2020  ctive_constr,.  
+000069a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000069b0: 2020 636f 6e66 6967 2e75 7365 5f6d 6370    config.use_mcp
+000069c0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
+000069d0: 2020 2020 2020 206d 6169 6e5f 6f62 6a2e         main_obj.
+000069e0: 7365 6e73 652c 0a20 2020 2020 2020 2020  sense,.         
+000069f0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00006a00: 2020 2020 2020 2020 206e 6f6e 6c69 6e65           nonline
+00006a10: 6172 5f73 7562 6578 7072 203d 2072 6570  ar_subexpr = rep
+00006a20: 6e2e 6e6f 6e6c 696e 6561 725f 6578 7072  n.nonlinear_expr
+00006a30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006a40: 2069 6620 6e6f 6e6c 696e 6561 725f 7375   if nonlinear_su
+00006a50: 6265 7870 722e 5f5f 636c 6173 735f 5f20  bexpr.__class__ 
+00006a60: 6973 2045 5850 522e 5375 6d45 7870 7265  is EXPR.SumExpre
+00006a70: 7373 696f 6e3a 0a20 2020 2020 2020 2020  ssion:.         
+00006a80: 2020 2020 2020 2020 2020 2066 6f72 2073             for s
+00006a90: 7562 7375 6265 7870 7220 696e 206e 6f6e  ubsubexpr in non
+00006aa0: 6c69 6e65 6172 5f73 7562 6578 7072 2e61  linear_subexpr.a
+00006ab0: 7267 733a 0a20 2020 2020 2020 2020 2020  rgs:.           
+00006ac0: 2020 2020 2020 2020 2020 2020 2065 7069               epi
+00006ad0: 6772 6170 685f 7265 666f 726d 756c 6174  graph_reformulat
+00006ae0: 696f 6e28 0a20 2020 2020 2020 2020 2020  ion(.           
+00006af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b00: 2073 7562 7375 6265 7870 722c 0a20 2020   subsubexpr,.   
+00006b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b20: 2020 2020 2020 2020 2075 7469 6c5f 626c           util_bl
+00006b30: 6f63 6b2e 6f62 6a65 6374 6976 655f 7661  ock.objective_va
+00006b40: 6c75 652c 0a20 2020 2020 2020 2020 2020  lue,.           
+00006b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b60: 2075 7469 6c5f 626c 6f63 6b2e 6f62 6a65   util_block.obje
+00006b70: 6374 6976 655f 636f 6e73 7472 2c0a 2020  ctive_constr,.  
+00006b80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006b90: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+00006ba0: 2e75 7365 5f6d 6370 702c 0a20 2020 2020  .use_mcpp,.     
+00006bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006bc0: 2020 2020 2020 206d 6169 6e5f 6f62 6a2e         main_obj.
+00006bd0: 7365 6e73 652c 0a20 2020 2020 2020 2020  sense,.         
+00006be0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00006bf0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006c00: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00006c10: 2020 2020 2020 2020 2020 2065 7069 6772             epigr
+00006c20: 6170 685f 7265 666f 726d 756c 6174 696f  aph_reformulatio
+00006c30: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+00006c40: 2020 2020 2020 2020 2020 206e 6f6e 6c69             nonli
+00006c50: 6e65 6172 5f73 7562 6578 7072 2c0a 2020  near_subexpr,.  
+00006c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006c70: 2020 2020 2020 7574 696c 5f62 6c6f 636b        util_block
+00006c80: 2e6f 626a 6563 7469 7665 5f76 616c 7565  .objective_value
+00006c90: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00006ca0: 2020 2020 2020 2020 2020 7574 696c 5f62            util_b
+00006cb0: 6c6f 636b 2e6f 626a 6563 7469 7665 5f63  lock.objective_c
+00006cc0: 6f6e 7374 722c 0a20 2020 2020 2020 2020  onstr,.         
+00006cd0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00006ce0: 6f6e 6669 672e 7573 655f 6d63 7070 2c0a  onfig.use_mcpp,.
+00006cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d00: 2020 2020 2020 2020 6d61 696e 5f6f 626a          main_obj
+00006d10: 2e73 656e 7365 2c0a 2020 2020 2020 2020  .sense,.        
+00006d20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00006d30: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+00006d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006d50: 6570 6967 7261 7068 5f72 6566 6f72 6d75  epigraph_reformu
+00006d60: 6c61 7469 6f6e 280a 2020 2020 2020 2020  lation(.        
+00006d70: 2020 2020 2020 2020 2020 2020 6d61 696e              main
+00006d80: 5f6f 626a 2e65 7870 722c 0a20 2020 2020  _obj.expr,.     
+00006d90: 2020 2020 2020 2020 2020 2020 2020 2075                 u
+00006da0: 7469 6c5f 626c 6f63 6b2e 6f62 6a65 6374  til_block.object
+00006db0: 6976 655f 7661 6c75 652c 0a20 2020 2020  ive_value,.     
+00006dc0: 2020 2020 2020 2020 2020 2020 2020 2075                 u
+00006dd0: 7469 6c5f 626c 6f63 6b2e 6f62 6a65 6374  til_block.object
+00006de0: 6976 655f 636f 6e73 7472 2c0a 2020 2020  ive_constr,.    
+00006df0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006e00: 636f 6e66 6967 2e75 7365 5f6d 6370 702c  config.use_mcpp,
+00006e10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006e20: 2020 2020 206d 6169 6e5f 6f62 6a2e 7365       main_obj.se
+00006e30: 6e73 652c 0a20 2020 2020 2020 2020 2020  nse,.           
+00006e40: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00006e50: 2020 2020 6d61 696e 5f6f 626a 2e64 6561      main_obj.dea
+00006e60: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
+00006e70: 2020 2020 2020 7574 696c 5f62 6c6f 636b        util_block
+00006e80: 2e6f 626a 6563 7469 7665 203d 204f 626a  .objective = Obj
+00006e90: 6563 7469 7665 280a 2020 2020 2020 2020  ective(.        
+00006ea0: 2020 2020 2020 2020 6578 7072 3d73 756d          expr=sum
+00006eb0: 2875 7469 6c5f 626c 6f63 6b2e 6f62 6a65  (util_block.obje
+00006ec0: 6374 6976 655f 7661 6c75 655b 3a5d 292c  ctive_value[:]),
+00006ed0: 2073 656e 7365 3d6d 6169 6e5f 6f62 6a2e   sense=main_obj.
+00006ee0: 7365 6e73 650a 2020 2020 2020 2020 2020  sense.          
+00006ef0: 2020 290a 0a20 2020 2020 2020 2020 2020    )..           
+00006f00: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
+00006f10: 2020 2020 2020 6d61 696e 5f6f 626a 2e65        main_obj.e
+00006f20: 7870 722e 706f 6c79 6e6f 6d69 616c 5f64  xpr.polynomial_d
+00006f30: 6567 7265 6528 290a 2020 2020 2020 2020  egree().        
+00006f40: 2020 2020 2020 2020 6e6f 7420 696e 2073          not in s
+00006f50: 656c 662e 6d69 705f 6f62 6a65 6374 6976  elf.mip_objectiv
+00006f60: 655f 706f 6c79 6e6f 6d69 616c 5f64 6567  e_polynomial_deg
+00006f70: 7265 650a 2020 2020 2020 2020 2020 2020  ree.            
+00006f80: 2020 2020 6f72 2028 636f 6e66 6967 2e6d      or (config.m
+00006f90: 6f76 655f 6f62 6a65 6374 6976 6520 616e  ove_objective an
+00006fa0: 6420 7570 6461 7465 5f76 6172 5f63 6f6e  d update_var_con
+00006fb0: 5f6c 6973 7429 0a20 2020 2020 2020 2020  _list).         
+00006fc0: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
+00006fd0: 2020 2020 2020 7574 696c 5f62 6c6f 636b        util_block
+00006fe0: 2e76 6172 6961 626c 655f 6c69 7374 2e65  .variable_list.e
+00006ff0: 7874 656e 6428 7574 696c 5f62 6c6f 636b  xtend(util_block
+00007000: 2e6f 626a 6563 7469 7665 5f76 616c 7565  .objective_value
+00007010: 5b3a 5d29 0a20 2020 2020 2020 2020 2020  [:]).           
+00007020: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
+00007030: 636f 6e74 696e 756f 7573 5f76 6172 6961  continuous_varia
+00007040: 626c 655f 6c69 7374 2e65 7874 656e 6428  ble_list.extend(
+00007050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007060: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
+00007070: 6f62 6a65 6374 6976 655f 7661 6c75 655b  objective_value[
+00007080: 3a5d 0a20 2020 2020 2020 2020 2020 2020  :].             
+00007090: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+000070a0: 2020 2020 2075 7469 6c5f 626c 6f63 6b2e       util_block.
+000070b0: 636f 6e73 7472 6169 6e74 5f6c 6973 742e  constraint_list.
+000070c0: 6578 7465 6e64 2875 7469 6c5f 626c 6f63  extend(util_bloc
+000070d0: 6b2e 6f62 6a65 6374 6976 655f 636f 6e73  k.objective_cons
+000070e0: 7472 5b3a 5d29 0a20 2020 2020 2020 2020  tr[:]).         
+000070f0: 2020 2020 2020 2075 7469 6c5f 626c 6f63         util_bloc
+00007100: 6b2e 6f62 6a65 6374 6976 655f 6c69 7374  k.objective_list
+00007110: 2e61 7070 656e 6428 7574 696c 5f62 6c6f  .append(util_blo
+00007120: 636b 2e6f 626a 6563 7469 7665 290a 2020  ck.objective).  
+00007130: 2020 2020 2020 2020 2020 2020 2020 666f                fo
+00007140: 7220 636f 6e73 7472 2069 6e20 7574 696c  r constr in util
+00007150: 5f62 6c6f 636b 2e6f 626a 6563 7469 7665  _block.objective
+00007160: 5f63 6f6e 7374 725b 3a5d 3a0a 2020 2020  _constr[:]:.    
+00007170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007180: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
+00007190: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+000071a0: 7374 722e 626f 6479 2e70 6f6c 796e 6f6d  str.body.polynom
+000071b0: 6961 6c5f 6465 6772 6565 2829 0a20 2020  ial_degree().   
+000071c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000071d0: 2020 2020 2069 6e20 7365 6c66 2e6d 6970       in self.mip
+000071e0: 5f63 6f6e 7374 7261 696e 745f 706f 6c79  _constraint_poly
+000071f0: 6e6f 6d69 616c 5f64 6567 7265 650a 2020  nomial_degree.  
+00007200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007210: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+00007220: 2020 2020 2020 2020 2020 2020 2075 7469               uti
+00007230: 6c5f 626c 6f63 6b2e 6c69 6e65 6172 5f63  l_block.linear_c
+00007240: 6f6e 7374 7261 696e 745f 6c69 7374 2e61  onstraint_list.a
+00007250: 7070 656e 6428 636f 6e73 7472 290a 2020  ppend(constr).  
+00007260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007270: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00007280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007290: 7574 696c 5f62 6c6f 636b 2e6e 6f6e 6c69  util_block.nonli
+000072a0: 6e65 6172 5f63 6f6e 7374 7261 696e 745f  near_constraint_
+000072b0: 6c69 7374 2e61 7070 656e 6428 636f 6e73  list.append(cons
+000072c0: 7472 290a 0a20 2020 2064 6566 2073 6574  tr)..    def set
+000072d0: 5f75 705f 736f 6c76 655f 6461 7461 2873  _up_solve_data(s
+000072e0: 656c 662c 206d 6f64 656c 293a 0a20 2020  elf, model):.   
+000072f0: 2020 2020 2022 2222 5365 7420 7570 2074       """Set up t
+00007300: 6865 2073 6f6c 7665 2064 6174 612e 0a0a  he solve data...
+00007310: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
+00007320: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
+00007330: 2d2d 2d2d 2d0a 2020 2020 2020 2020 6d6f  -----.        mo
+00007340: 6465 6c20 3a20 5079 6f6d 6f20 6d6f 6465  del : Pyomo mode
+00007350: 6c0a 2020 2020 2020 2020 2020 2020 5468  l.            Th
+00007360: 6520 6f72 6967 696e 616c 206d 6f64 656c  e original model
+00007370: 2074 6f20 6265 2073 6f6c 7665 6420 696e   to be solved in
+00007380: 204d 696e 6474 5079 2e0a 2020 2020 2020   MindtPy..      
+00007390: 2020 2222 220a 2020 2020 2020 2020 636f    """.        co
+000073a0: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
+000073b0: 6967 0a20 2020 2020 2020 2023 2069 6620  ig.        # if 
+000073c0: 7468 6520 6f62 6a65 6374 6976 6520 6675  the objective fu
+000073d0: 6e63 7469 6f6e 2069 7320 6120 636f 6e73  nction is a cons
+000073e0: 7461 6e74 2c20 6475 616c 2062 6f75 6e64  tant, dual bound
+000073f0: 2063 6f6e 7374 7261 696e 7420 6973 206e   constraint is n
+00007400: 6f74 2061 6464 6564 2e0a 2020 2020 2020  ot added..      
+00007410: 2020 6f62 6a20 3d20 6e65 7874 286d 6f64    obj = next(mod
+00007420: 656c 2e63 6f6d 706f 6e65 6e74 5f64 6174  el.component_dat
+00007430: 615f 6f62 6a65 6374 7328 6374 7970 653d  a_objects(ctype=
+00007440: 4f62 6a65 6374 6976 652c 2061 6374 6976  Objective, activ
+00007450: 653d 5472 7565 2929 0a20 2020 2020 2020  e=True)).       
+00007460: 2069 6620 6f62 6a2e 6578 7072 2e70 6f6c   if obj.expr.pol
+00007470: 796e 6f6d 6961 6c5f 6465 6772 6565 2829  ynomial_degree()
+00007480: 203d 3d20 303a 0a20 2020 2020 2020 2020   == 0:.         
+00007490: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+000074a0: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+000074b0: 2020 2020 2020 2027 5468 6520 6d6f 6465         'The mode
+000074c0: 6c20 6861 7320 6120 636f 6e73 7461 6e74  l has a constant
+000074d0: 206f 626a 6563 6974 6976 6520 6675 6e63   objecitive func
+000074e0: 7469 6f6e 2e20 7573 655f 6475 616c 5f62  tion. use_dual_b
+000074f0: 6f75 6e64 2069 7320 7365 7420 746f 2046  ound is set to F
+00007500: 616c 7365 2e27 0a20 2020 2020 2020 2020  alse.'.         
+00007510: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00007520: 2063 6f6e 6669 672e 7573 655f 6475 616c   config.use_dual
+00007530: 5f62 6f75 6e64 203d 2046 616c 7365 0a0a  _bound = False..
+00007540: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+00007550: 672e 7573 655f 6662 6274 3a0a 2020 2020  g.use_fbbt:.    
+00007560: 2020 2020 2020 2020 6662 6274 286d 6f64          fbbt(mod
+00007570: 656c 290a 2020 2020 2020 2020 2020 2020  el).            
+00007580: 2320 544f 444f 3a20 6c6f 6767 696e 675f  # TODO: logging_
+00007590: 6c65 7665 6c20 6973 206e 6f74 206c 6f67  level is not log
+000075a0: 6769 6e67 2e49 4e46 4f20 6865 7265 0a20  ging.INFO here. 
+000075b0: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+000075c0: 672e 6c6f 6767 6572 2e69 6e66 6f28 2755  g.logger.info('U
+000075d0: 7365 2074 6865 2066 6262 7420 746f 2074  se the fbbt to t
+000075e0: 6967 6874 656e 2074 6865 2062 6f75 6e64  ighten the bound
+000075f0: 7320 6f66 2076 6172 6961 626c 6573 2729  s of variables')
+00007600: 0a0a 2020 2020 2020 2020 7365 6c66 2e6f  ..        self.o
+00007610: 7269 6769 6e61 6c5f 6d6f 6465 6c20 3d20  riginal_model = 
+00007620: 6d6f 6465 6c0a 2020 2020 2020 2020 7365  model.        se
+00007630: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
+00007640: 203d 206d 6f64 656c 2e63 6c6f 6e65 2829   = model.clone()
+00007650: 0a0a 2020 2020 2020 2020 2320 7365 7420  ..        # set 
+00007660: 7570 2062 6f75 6e64 730a 2020 2020 2020  up bounds.      
+00007670: 2020 6966 206f 626a 2e73 656e 7365 203d    if obj.sense =
+00007680: 3d20 6d69 6e69 6d69 7a65 3a0a 2020 2020  = minimize:.    
+00007690: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
+000076a0: 6d61 6c5f 626f 756e 6420 3d20 666c 6f61  mal_bound = floa
+000076b0: 7428 2769 6e66 2729 0a20 2020 2020 2020  t('inf').       
+000076c0: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
+000076d0: 6f75 6e64 203d 2066 6c6f 6174 2827 2d69  ound = float('-i
+000076e0: 6e66 2729 0a20 2020 2020 2020 2065 6c73  nf').        els
+000076f0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+00007700: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+00007710: 203d 2066 6c6f 6174 2827 2d69 6e66 2729   = float('-inf')
+00007720: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00007730: 662e 6475 616c 5f62 6f75 6e64 203d 2066  f.dual_bound = f
+00007740: 6c6f 6174 2827 696e 6627 290a 2020 2020  loat('inf').    
+00007750: 2020 2020 7365 6c66 2e70 7269 6d61 6c5f      self.primal_
+00007760: 626f 756e 645f 7072 6f67 7265 7373 203d  bound_progress =
+00007770: 205b 7365 6c66 2e70 7269 6d61 6c5f 626f   [self.primal_bo
+00007780: 756e 645d 0a20 2020 2020 2020 2073 656c  und].        sel
+00007790: 662e 6475 616c 5f62 6f75 6e64 5f70 726f  f.dual_bound_pro
+000077a0: 6772 6573 7320 3d20 5b73 656c 662e 6475  gress = [self.du
+000077b0: 616c 5f62 6f75 6e64 5d0a 0a20 2020 2020  al_bound]..     
+000077c0: 2020 2069 6620 636f 6e66 6967 2e6e 6c70     if config.nlp
+000077d0: 5f73 6f6c 7665 7220 696e 207b 2769 706f  _solver in {'ipo
+000077e0: 7074 272c 2027 6379 6970 6f70 7427 7d3a  pt', 'cyipopt'}:
+000077f0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00007800: 6e6f 7420 6861 7361 7474 7228 7365 6c66  not hasattr(self
+00007810: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2c20  .working_model, 
+00007820: 2769 706f 7074 5f7a 4c5f 6f75 7427 293a  'ipopt_zL_out'):
+00007830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007840: 2073 656c 662e 776f 726b 696e 675f 6d6f   self.working_mo
+00007850: 6465 6c2e 6970 6f70 745f 7a4c 5f6f 7574  del.ipopt_zL_out
+00007860: 203d 2053 7566 6669 7828 6469 7265 6374   = Suffix(direct
+00007870: 696f 6e3d 5375 6666 6978 2e49 4d50 4f52  ion=Suffix.IMPOR
+00007880: 5429 0a20 2020 2020 2020 2020 2020 2069  T).            i
+00007890: 6620 6e6f 7420 6861 7361 7474 7228 7365  f not hasattr(se
+000078a0: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
+000078b0: 2c20 2769 706f 7074 5f7a 555f 6f75 7427  , 'ipopt_zU_out'
+000078c0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+000078d0: 2020 2073 656c 662e 776f 726b 696e 675f     self.working_
+000078e0: 6d6f 6465 6c2e 6970 6f70 745f 7a55 5f6f  model.ipopt_zU_o
+000078f0: 7574 203d 2053 7566 6669 7828 6469 7265  ut = Suffix(dire
+00007900: 6374 696f 6e3d 5375 6666 6978 2e49 4d50  ction=Suffix.IMP
+00007910: 4f52 5429 0a0a 2020 2020 2020 2020 6966  ORT)..        if
+00007920: 2063 6f6e 6669 672e 7175 6164 7261 7469   config.quadrati
+00007930: 635f 7374 7261 7465 6779 203d 3d20 303a  c_strategy == 0:
+00007940: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00007950: 662e 6d69 705f 6f62 6a65 6374 6976 655f  f.mip_objective_
+00007960: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+00007970: 6520 3d20 7b30 2c20 317d 0a20 2020 2020  e = {0, 1}.     
+00007980: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
+00007990: 636f 6e73 7472 6169 6e74 5f70 6f6c 796e  constraint_polyn
+000079a0: 6f6d 6961 6c5f 6465 6772 6565 203d 207b  omial_degree = {
+000079b0: 302c 2031 7d0a 2020 2020 2020 2020 656c  0, 1}.        el
+000079c0: 6966 2063 6f6e 6669 672e 7175 6164 7261  if config.quadra
+000079d0: 7469 635f 7374 7261 7465 6779 203d 3d20  tic_strategy == 
+000079e0: 313a 0a20 2020 2020 2020 2020 2020 2073  1:.            s
+000079f0: 656c 662e 6d69 705f 6f62 6a65 6374 6976  elf.mip_objectiv
+00007a00: 655f 706f 6c79 6e6f 6d69 616c 5f64 6567  e_polynomial_deg
+00007a10: 7265 6520 3d20 7b30 2c20 312c 2032 7d0a  ree = {0, 1, 2}.
+00007a20: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00007a30: 2e6d 6970 5f63 6f6e 7374 7261 696e 745f  .mip_constraint_
+00007a40: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+00007a50: 6520 3d20 7b30 2c20 317d 0a20 2020 2020  e = {0, 1}.     
+00007a60: 2020 2065 6c69 6620 636f 6e66 6967 2e71     elif config.q
+00007a70: 7561 6472 6174 6963 5f73 7472 6174 6567  uadratic_strateg
+00007a80: 7920 3d3d 2032 3a0a 2020 2020 2020 2020  y == 2:.        
+00007a90: 2020 2020 7365 6c66 2e6d 6970 5f6f 626a      self.mip_obj
+00007aa0: 6563 7469 7665 5f70 6f6c 796e 6f6d 6961  ective_polynomia
+00007ab0: 6c5f 6465 6772 6565 203d 207b 302c 2031  l_degree = {0, 1
+00007ac0: 2c20 327d 0a20 2020 2020 2020 2020 2020  , 2}.           
+00007ad0: 2073 656c 662e 6d69 705f 636f 6e73 7472   self.mip_constr
+00007ae0: 6169 6e74 5f70 6f6c 796e 6f6d 6961 6c5f  aint_polynomial_
+00007af0: 6465 6772 6565 203d 207b 302c 2031 2c20  degree = {0, 1, 
+00007b00: 327d 0a0a 2020 2020 2320 2d2d 2d2d 2d2d  2}..    # ------
+00007b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00007b20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00007b30: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00007b40: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00007b50: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007b60: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00007b70: 2d2d 2d2d 2d2d 0a20 2020 2023 2069 6e69  ------.    # ini
-00007b80: 7469 616c 697a 6174 696f 6e0a 0a20 2020  tialization..   
-00007b90: 2064 6566 204d 696e 6474 5079 5f69 6e69   def MindtPy_ini
-00007ba0: 7469 616c 697a 6174 696f 6e28 7365 6c66  tialization(self
-00007bb0: 293a 0a20 2020 2020 2020 2022 2222 496e  ):.        """In
-00007bc0: 6974 6961 6c69 7a65 7320 7468 6520 6465  itializes the de
-00007bd0: 636f 6d70 6f73 6974 696f 6e20 616c 676f  composition algo
-00007be0: 7269 7468 6d2e 0a0a 2020 2020 2020 2020  rithm...        
-00007bf0: 5468 6973 2066 756e 6374 696f 6e20 696e  This function in
-00007c00: 6974 6961 6c69 7a65 7320 7468 6520 6465  itializes the de
-00007c10: 636f 6d70 6f73 6974 696f 6e20 616c 676f  composition algo
-00007c20: 7269 7468 6d2c 2077 6869 6368 2069 6e63  rithm, which inc
-00007c30: 6c75 6465 7320 6765 6e65 7261 7469 6e67  ludes generating
-00007c40: 2074 6865 0a20 2020 2020 2020 2069 6e69   the.        ini
-00007c50: 7469 616c 2063 7574 7320 7265 7175 6972  tial cuts requir
-00007c60: 6564 2074 6f20 6275 696c 6420 7468 6520  ed to build the 
-00007c70: 6d61 696e 204d 4950 2e0a 2020 2020 2020  main MIP..      
-00007c80: 2020 2222 220a 2020 2020 2020 2020 2320    """.        # 
-00007c90: 446f 2074 6865 2069 6e69 7469 616c 697a  Do the initializ
-00007ca0: 6174 696f 6e0a 2020 2020 2020 2020 636f  ation.        co
-00007cb0: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
-00007cc0: 6967 0a20 2020 2020 2020 2069 6620 636f  ig.        if co
-00007cd0: 6e66 6967 2e69 6e69 745f 7374 7261 7465  nfig.init_strate
-00007ce0: 6779 203d 3d20 2772 4e4c 5027 3a0a 2020  gy == 'rNLP':.  
-00007cf0: 2020 2020 2020 2020 2020 7365 6c66 2e69            self.i
-00007d00: 6e69 745f 724e 4c50 2829 0a20 2020 2020  nit_rNLP().     
-00007d10: 2020 2065 6c69 6620 636f 6e66 6967 2e69     elif config.i
-00007d20: 6e69 745f 7374 7261 7465 6779 203d 3d20  nit_strategy == 
-00007d30: 276d 6178 5f62 696e 6172 7927 3a0a 2020  'max_binary':.  
-00007d40: 2020 2020 2020 2020 2020 7365 6c66 2e69            self.i
-00007d50: 6e69 745f 6d61 785f 6269 6e61 7269 6573  nit_max_binaries
-00007d60: 2829 0a20 2020 2020 2020 2065 6c69 6620  ().        elif 
-00007d70: 636f 6e66 6967 2e69 6e69 745f 7374 7261  config.init_stra
-00007d80: 7465 6779 203d 3d20 2769 6e69 7469 616c  tegy == 'initial
-00007d90: 5f62 696e 6172 7927 3a0a 2020 2020 2020  _binary':.      
-00007da0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-00007db0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00007dc0: 6375 7272 5f69 6e74 5f73 6f6c 203d 2067  curr_int_sol = g
-00007dd0: 6574 5f69 6e74 6567 6572 5f73 6f6c 7574  et_integer_solut
-00007de0: 696f 6e28 7365 6c66 2e77 6f72 6b69 6e67  ion(self.working
-00007df0: 5f6d 6f64 656c 290a 2020 2020 2020 2020  _model).        
-00007e00: 2020 2020 6578 6365 7074 2054 7970 6545      except TypeE
-00007e10: 7272 6f72 2061 7320 653a 0a20 2020 2020  rror as e:.     
-00007e20: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
-00007e30: 672e 6c6f 6767 6572 2e65 7272 6f72 2865  g.logger.error(e
-00007e40: 2c20 6578 635f 696e 666f 3d54 7275 6529  , exc_info=True)
-00007e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007e60: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-00007e70: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-00007e80: 2020 2020 2020 2027 5468 6520 696e 6974         'The init
-00007e90: 6961 6c20 696e 7465 6765 7220 636f 6d62  ial integer comb
-00007ea0: 696e 6174 696f 6e20 6973 206e 6f74 2070  ination is not p
-00007eb0: 726f 7669 6465 6420 6f72 206e 6f74 2063  rovided or not c
-00007ec0: 6f6d 706c 6574 652e 2027 0a20 2020 2020  omplete. '.     
-00007ed0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00007ee0: 506c 6561 7365 2070 726f 7669 6465 2074  Please provide t
-00007ef0: 6865 2063 6f6d 706c 6574 6520 696e 7465  he complete inte
-00007f00: 6765 7220 636f 6d62 696e 6174 696f 6e20  ger combination 
-00007f10: 6f72 2075 7365 206f 7468 6572 2069 6e69  or use other ini
-00007f20: 7469 616c 697a 6174 696f 6e20 7374 7261  tialization stra
-00007f30: 7465 6779 2e27 0a20 2020 2020 2020 2020  tegy.'.         
-00007f40: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00007f50: 2020 2020 2073 656c 662e 696e 7465 6765       self.intege
-00007f60: 725f 6c69 7374 2e61 7070 656e 6428 7365  r_list.append(se
-00007f70: 6c66 2e63 7572 725f 696e 745f 736f 6c29  lf.curr_int_sol)
-00007f80: 0a20 2020 2020 2020 2020 2020 2066 6978  .            fix
-00007f90: 6564 5f6e 6c70 2c20 6669 7865 645f 6e6c  ed_nlp, fixed_nl
-00007fa0: 705f 7265 7375 6c74 203d 2073 656c 662e  p_result = self.
-00007fb0: 736f 6c76 655f 7375 6270 726f 626c 656d  solve_subproblem
-00007fc0: 2829 0a20 2020 2020 2020 2020 2020 2073  ().            s
-00007fd0: 656c 662e 6861 6e64 6c65 5f6e 6c70 5f73  elf.handle_nlp_s
-00007fe0: 7562 7072 6f62 6c65 6d5f 7463 2866 6978  ubproblem_tc(fix
-00007ff0: 6564 5f6e 6c70 2c20 6669 7865 645f 6e6c  ed_nlp, fixed_nl
-00008000: 705f 7265 7375 6c74 290a 2020 2020 2020  p_result).      
-00008010: 2020 2020 2020 7365 6c66 2e69 6e74 6567        self.integ
-00008020: 6572 5f73 6f6c 7574 696f 6e5f 746f 5f63  er_solution_to_c
-00008030: 7574 735f 696e 6465 785b 7365 6c66 2e63  uts_index[self.c
-00008040: 7572 725f 696e 745f 736f 6c5d 203d 205b  urr_int_sol] = [
+00007b60: 2d2d 2d0a 2020 2020 2320 696e 6974 6961  ---.    # initia
+00007b70: 6c69 7a61 7469 6f6e 0a0a 2020 2020 6465  lization..    de
+00007b80: 6620 4d69 6e64 7450 795f 696e 6974 6961  f MindtPy_initia
+00007b90: 6c69 7a61 7469 6f6e 2873 656c 6629 3a0a  lization(self):.
+00007ba0: 2020 2020 2020 2020 2222 2249 6e69 7469          """Initi
+00007bb0: 616c 697a 6573 2074 6865 2064 6563 6f6d  alizes the decom
+00007bc0: 706f 7369 7469 6f6e 2061 6c67 6f72 6974  position algorit
+00007bd0: 686d 2e0a 0a20 2020 2020 2020 2054 6869  hm...        Thi
+00007be0: 7320 6675 6e63 7469 6f6e 2069 6e69 7469  s function initi
+00007bf0: 616c 697a 6573 2074 6865 2064 6563 6f6d  alizes the decom
+00007c00: 706f 7369 7469 6f6e 2061 6c67 6f72 6974  position algorit
+00007c10: 686d 2c20 7768 6963 6820 696e 636c 7564  hm, which includ
+00007c20: 6573 2067 656e 6572 6174 696e 6720 7468  es generating th
+00007c30: 650a 2020 2020 2020 2020 696e 6974 6961  e.        initia
+00007c40: 6c20 6375 7473 2072 6571 7569 7265 6420  l cuts required 
+00007c50: 746f 2062 7569 6c64 2074 6865 206d 6169  to build the mai
+00007c60: 6e20 4d49 502e 0a20 2020 2020 2020 2022  n MIP..        "
+00007c70: 2222 0a20 2020 2020 2020 2023 2044 6f20  "".        # Do 
+00007c80: 7468 6520 696e 6974 6961 6c69 7a61 7469  the initializati
+00007c90: 6f6e 0a20 2020 2020 2020 2063 6f6e 6669  on.        confi
+00007ca0: 6720 3d20 7365 6c66 2e63 6f6e 6669 670a  g = self.config.
+00007cb0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+00007cc0: 672e 696e 6974 5f73 7472 6174 6567 7920  g.init_strategy 
+00007cd0: 3d3d 2027 724e 4c50 273a 0a20 2020 2020  == 'rNLP':.     
+00007ce0: 2020 2020 2020 2073 656c 662e 696e 6974         self.init
+00007cf0: 5f72 4e4c 5028 290a 2020 2020 2020 2020  _rNLP().        
+00007d00: 656c 6966 2063 6f6e 6669 672e 696e 6974  elif config.init
+00007d10: 5f73 7472 6174 6567 7920 3d3d 2027 6d61  _strategy == 'ma
+00007d20: 785f 6269 6e61 7279 273a 0a20 2020 2020  x_binary':.     
+00007d30: 2020 2020 2020 2073 656c 662e 696e 6974         self.init
+00007d40: 5f6d 6178 5f62 696e 6172 6965 7328 290a  _max_binaries().
+00007d50: 2020 2020 2020 2020 656c 6966 2063 6f6e          elif con
+00007d60: 6669 672e 696e 6974 5f73 7472 6174 6567  fig.init_strateg
+00007d70: 7920 3d3d 2027 696e 6974 6961 6c5f 6269  y == 'initial_bi
+00007d80: 6e61 7279 273a 0a20 2020 2020 2020 2020  nary':.         
+00007d90: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00007da0: 2020 2020 2020 2020 7365 6c66 2e63 7572          self.cur
+00007db0: 725f 696e 745f 736f 6c20 3d20 6765 745f  r_int_sol = get_
+00007dc0: 696e 7465 6765 725f 736f 6c75 7469 6f6e  integer_solution
+00007dd0: 2873 656c 662e 776f 726b 696e 675f 6d6f  (self.working_mo
+00007de0: 6465 6c29 0a20 2020 2020 2020 2020 2020  del).           
+00007df0: 2065 7863 6570 7420 5479 7065 4572 726f   except TypeErro
+00007e00: 7220 6173 2065 3a0a 2020 2020 2020 2020  r as e:.        
+00007e10: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
+00007e20: 6f67 6765 722e 6572 726f 7228 652c 2065  ogger.error(e, e
+00007e30: 7863 5f69 6e66 6f3d 5472 7565 290a 2020  xc_info=True).  
+00007e40: 2020 2020 2020 2020 2020 2020 2020 7261                ra
+00007e50: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+00007e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007e70: 2020 2020 2754 6865 2069 6e69 7469 616c      'The initial
+00007e80: 2069 6e74 6567 6572 2063 6f6d 6269 6e61   integer combina
+00007e90: 7469 6f6e 2069 7320 6e6f 7420 7072 6f76  tion is not prov
+00007ea0: 6964 6564 206f 7220 6e6f 7420 636f 6d70  ided or not comp
+00007eb0: 6c65 7465 2e20 270a 2020 2020 2020 2020  lete. '.        
+00007ec0: 2020 2020 2020 2020 2020 2020 2750 6c65              'Ple
+00007ed0: 6173 6520 7072 6f76 6964 6520 7468 6520  ase provide the 
+00007ee0: 636f 6d70 6c65 7465 2069 6e74 6567 6572  complete integer
+00007ef0: 2063 6f6d 6269 6e61 7469 6f6e 206f 7220   combination or 
+00007f00: 7573 6520 6f74 6865 7220 696e 6974 6961  use other initia
+00007f10: 6c69 7a61 7469 6f6e 2073 7472 6174 6567  lization strateg
+00007f20: 792e 270a 2020 2020 2020 2020 2020 2020  y.'.            
+00007f30: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00007f40: 2020 7365 6c66 2e69 6e74 6567 6572 5f6c    self.integer_l
+00007f50: 6973 742e 6170 7065 6e64 2873 656c 662e  ist.append(self.
+00007f60: 6375 7272 5f69 6e74 5f73 6f6c 290a 2020  curr_int_sol).  
+00007f70: 2020 2020 2020 2020 2020 6669 7865 645f            fixed_
+00007f80: 6e6c 702c 2066 6978 6564 5f6e 6c70 5f72  nlp, fixed_nlp_r
+00007f90: 6573 756c 7420 3d20 7365 6c66 2e73 6f6c  esult = self.sol
+00007fa0: 7665 5f73 7562 7072 6f62 6c65 6d28 290a  ve_subproblem().
+00007fb0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00007fc0: 2e68 616e 646c 655f 6e6c 705f 7375 6270  .handle_nlp_subp
+00007fd0: 726f 626c 656d 5f74 6328 6669 7865 645f  roblem_tc(fixed_
+00007fe0: 6e6c 702c 2066 6978 6564 5f6e 6c70 5f72  nlp, fixed_nlp_r
+00007ff0: 6573 756c 7429 0a20 2020 2020 2020 2020  esult).         
+00008000: 2020 2073 656c 662e 696e 7465 6765 725f     self.integer_
+00008010: 736f 6c75 7469 6f6e 5f74 6f5f 6375 7473  solution_to_cuts
+00008020: 5f69 6e64 6578 5b73 656c 662e 6375 7272  _index[self.curr
+00008030: 5f69 6e74 5f73 6f6c 5d20 3d20 5b0a 2020  _int_sol] = [.  
+00008040: 2020 2020 2020 2020 2020 2020 2020 312c                1,
 00008050: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008060: 2031 2c0a 2020 2020 2020 2020 2020 2020   1,.            
-00008070: 2020 2020 6c65 6e28 7365 6c66 2e6d 6970      len(self.mip
-00008080: 2e4d 696e 6474 5079 5f75 7469 6c73 2e63  .MindtPy_utils.c
-00008090: 7574 732e 6f61 5f63 7574 7329 2c0a 2020  uts.oa_cuts),.  
-000080a0: 2020 2020 2020 2020 2020 5d0a 2020 2020            ].    
-000080b0: 2020 2020 656c 6966 2063 6f6e 6669 672e      elif config.
-000080c0: 696e 6974 5f73 7472 6174 6567 7920 3d3d  init_strategy ==
-000080d0: 2027 4650 273a 0a20 2020 2020 2020 2020   'FP':.         
-000080e0: 2020 2073 656c 662e 696e 6974 5f72 4e4c     self.init_rNL
-000080f0: 5028 290a 2020 2020 2020 2020 2020 2020  P().            
-00008100: 7365 6c66 2e66 705f 6c6f 6f70 2829 0a0a  self.fp_loop()..
-00008110: 2020 2020 6465 6620 696e 6974 5f72 4e4c      def init_rNL
-00008120: 5028 7365 6c66 2c20 6164 645f 6f61 5f63  P(self, add_oa_c
-00008130: 7574 733d 5472 7565 293a 0a20 2020 2020  uts=True):.     
-00008140: 2020 2022 2222 496e 6974 6961 6c69 7a65     """Initialize
-00008150: 2074 6865 2070 726f 626c 656d 2062 7920   the problem by 
-00008160: 736f 6c76 696e 6720 7468 6520 7265 6c61  solving the rela
-00008170: 7865 6420 4e4c 5020 616e 6420 7468 656e  xed NLP and then
-00008180: 2073 746f 7265 2074 6865 206f 7074 696d   store the optim
-00008190: 616c 2076 6172 6961 626c 650a 2020 2020  al variable.    
-000081a0: 2020 2020 7661 6c75 6573 206f 6274 6169      values obtai
-000081b0: 6e65 6420 6672 6f6d 2073 6f6c 7669 6e67  ned from solving
-000081c0: 2074 6865 2072 4e4c 502e 0a0a 2020 2020   the rNLP...    
-000081d0: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-000081e0: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
-000081f0: 2d0a 2020 2020 2020 2020 6164 645f 6f61  -.        add_oa
-00008200: 5f63 7574 7320 3a20 426f 6f6c 0a20 2020  _cuts : Bool.   
-00008210: 2020 2020 2020 2020 2057 6865 7468 6572           Whether
-00008220: 2061 6464 204f 4120 6375 7473 2061 6674   add OA cuts aft
-00008230: 6572 2073 6f6c 7669 6e67 2074 6865 2072  er solving the r
-00008240: 656c 6178 6564 204e 4c50 2070 726f 626c  elaxed NLP probl
-00008250: 656d 2e0a 0a20 2020 2020 2020 2052 6169  em...        Rai
-00008260: 7365 730a 2020 2020 2020 2020 2d2d 2d2d  ses.        ----
-00008270: 2d2d 0a20 2020 2020 2020 2056 616c 7565  --.        Value
-00008280: 4572 726f 720a 2020 2020 2020 2020 2020  Error.          
-00008290: 2020 4d69 6e64 7450 7920 756e 6162 6c65    MindtPy unable
-000082a0: 2074 6f20 6861 6e64 6c65 2074 6865 2074   to handle the t
-000082b0: 6572 6d69 6e61 7469 6f6e 2063 6f6e 6469  ermination condi
-000082c0: 7469 6f6e 206f 6620 7468 6520 7265 6c61  tion of the rela
-000082d0: 7865 6420 4e4c 502e 0a20 2020 2020 2020  xed NLP..       
-000082e0: 2022 2222 0a20 2020 2020 2020 2063 6f6e   """.        con
-000082f0: 6669 6720 3d20 7365 6c66 2e63 6f6e 6669  fig = self.confi
-00008300: 670a 2020 2020 2020 2020 7365 6c66 2e72  g.        self.r
-00008310: 6e6c 7020 3d20 7365 6c66 2e77 6f72 6b69  nlp = self.worki
-00008320: 6e67 5f6d 6f64 656c 2e63 6c6f 6e65 2829  ng_model.clone()
-00008330: 0a20 2020 2020 2020 2063 6f6e 6669 672e  .        config.
-00008340: 6c6f 6767 6572 2e64 6562 7567 2827 5265  logger.debug('Re
-00008350: 6c61 7865 6420 4e4c 503a 2053 6f6c 7665  laxed NLP: Solve
-00008360: 2072 656c 6178 6564 2069 6e74 6567 7261   relaxed integra
-00008370: 6c69 7479 2729 0a20 2020 2020 2020 204d  lity').        M
-00008380: 696e 6474 5079 203d 2073 656c 662e 726e  indtPy = self.rn
-00008390: 6c70 2e4d 696e 6474 5079 5f75 7469 6c73  lp.MindtPy_utils
-000083a0: 0a20 2020 2020 2020 2054 7261 6e73 666f  .        Transfo
-000083b0: 726d 6174 696f 6e46 6163 746f 7279 2827  rmationFactory('
-000083c0: 636f 7265 2e72 656c 6178 5f69 6e74 6567  core.relax_integ
-000083d0: 6572 5f76 6172 7327 292e 6170 706c 795f  er_vars').apply_
-000083e0: 746f 2873 656c 662e 726e 6c70 290a 2020  to(self.rnlp).  
-000083f0: 2020 2020 2020 6e6c 705f 6172 6773 203d        nlp_args =
-00008400: 2064 6963 7428 636f 6e66 6967 2e6e 6c70   dict(config.nlp
-00008410: 5f73 6f6c 7665 725f 6172 6773 290a 2020  _solver_args).  
-00008420: 2020 2020 2020 7570 6461 7465 5f73 6f6c        update_sol
-00008430: 7665 725f 7469 6d65 6c69 6d69 7428 7365  ver_timelimit(se
-00008440: 6c66 2e6e 6c70 5f6f 7074 2c20 636f 6e66  lf.nlp_opt, conf
-00008450: 6967 2e6e 6c70 5f73 6f6c 7665 722c 2073  ig.nlp_solver, s
-00008460: 656c 662e 7469 6d69 6e67 2c20 636f 6e66  elf.timing, conf
-00008470: 6967 290a 2020 2020 2020 2020 7769 7468  ig).        with
-00008480: 2053 7570 7072 6573 7349 6e66 6561 7369   SuppressInfeasi
-00008490: 626c 6557 6172 6e69 6e67 2829 3a0a 2020  bleWarning():.  
-000084a0: 2020 2020 2020 2020 2020 7265 7375 6c74            result
-000084b0: 7320 3d20 7365 6c66 2e6e 6c70 5f6f 7074  s = self.nlp_opt
-000084c0: 2e73 6f6c 7665 280a 2020 2020 2020 2020  .solve(.        
-000084d0: 2020 2020 2020 2020 7365 6c66 2e72 6e6c          self.rnl
-000084e0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-000084f0: 2020 2074 6565 3d63 6f6e 6669 672e 6e6c     tee=config.nl
-00008500: 705f 736f 6c76 6572 5f74 6565 2c0a 2020  p_solver_tee,.  
-00008510: 2020 2020 2020 2020 2020 2020 2020 6c6f                lo
-00008520: 6164 5f73 6f6c 7574 696f 6e73 3d73 656c  ad_solutions=sel
-00008530: 662e 6c6f 6164 5f73 6f6c 7574 696f 6e73  f.load_solutions
-00008540: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00008550: 2020 2a2a 6e6c 705f 6172 6773 2c0a 2020    **nlp_args,.  
-00008560: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00008570: 2020 2020 2020 2020 6966 206c 656e 2872          if len(r
-00008580: 6573 756c 7473 2e73 6f6c 7574 696f 6e29  esults.solution)
-00008590: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
-000085a0: 2020 2020 2020 7365 6c66 2e72 6e6c 702e        self.rnlp.
-000085b0: 736f 6c75 7469 6f6e 732e 6c6f 6164 5f66  solutions.load_f
-000085c0: 726f 6d28 7265 7375 6c74 7329 0a20 2020  rom(results).   
-000085d0: 2020 2020 2073 7562 7072 6f62 5f74 6572       subprob_ter
-000085e0: 6d69 6e61 7465 5f63 6f6e 6420 3d20 7265  minate_cond = re
-000085f0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
-00008600: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
-00008610: 6f6e 0a0a 2020 2020 2020 2020 2320 536f  on..        # So
-00008620: 6d65 7469 6d65 732c 2074 6865 204e 4c50  metimes, the NLP
-00008630: 2073 6f6c 7665 7220 6d69 6768 7420 6265   solver might be
-00008640: 2074 7261 7070 6564 2069 6e20 6120 696e   trapped in a in
-00008650: 6665 6173 6962 6c65 2073 6f6c 7574 696f  feasible solutio
-00008660: 6e20 6966 2074 6865 206f 626a 6563 7469  n if the objecti
-00008670: 7665 2066 756e 6374 696f 6e20 6973 206e  ve function is n
-00008680: 6f6e 6c69 6e65 6172 2061 6e64 2070 6172  onlinear and par
-00008690: 7469 7469 6f6e 5f6f 626a 5f6e 6f6e 6c69  tition_obj_nonli
-000086a0: 6e65 6172 5f74 6572 6d73 2069 7320 5472  near_terms is Tr
-000086b0: 7565 2e20 4966 2074 6869 7320 6861 7070  ue. If this happ
-000086c0: 656e 732c 2077 6520 7769 6c6c 2075 7365  ens, we will use
-000086d0: 2074 6865 206f 7269 6769 6e61 6c20 6f62   the original ob
-000086e0: 6a65 6374 6976 6520 6675 6e63 7469 6f6e  jective function
-000086f0: 2069 6e73 7465 6164 2e0a 2020 2020 2020   instead..      
-00008700: 2020 6966 2028 0a20 2020 2020 2020 2020    if (.         
-00008710: 2020 2073 7562 7072 6f62 5f74 6572 6d69     subprob_termi
-00008720: 6e61 7465 5f63 6f6e 6420 3d3d 2074 632e  nate_cond == tc.
-00008730: 696e 6665 6173 6962 6c65 0a20 2020 2020  infeasible.     
-00008740: 2020 2020 2020 2061 6e64 2063 6f6e 6669         and confi
-00008750: 672e 7061 7274 6974 696f 6e5f 6f62 6a5f  g.partition_obj_
-00008760: 6e6f 6e6c 696e 6561 725f 7465 726d 730a  nonlinear_terms.
-00008770: 2020 2020 2020 2020 2020 2020 616e 6420              and 
-00008780: 7365 6c66 2e72 6e6c 702e 4d69 6e64 7450  self.rnlp.MindtP
-00008790: 795f 7574 696c 732e 6f62 6a65 6374 6976  y_utils.objectiv
-000087a0: 655f 6c69 7374 5b30 5d2e 6578 7072 2e70  e_list[0].expr.p
-000087b0: 6f6c 796e 6f6d 6961 6c5f 6465 6772 6565  olynomial_degree
-000087c0: 2829 0a20 2020 2020 2020 2020 2020 206e  ().            n
-000087d0: 6f74 2069 6e20 7365 6c66 2e6d 6970 5f6f  ot in self.mip_o
-000087e0: 626a 6563 7469 7665 5f70 6f6c 796e 6f6d  bjective_polynom
-000087f0: 6961 6c5f 6465 6772 6565 0a20 2020 2020  ial_degree.     
-00008800: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-00008810: 2020 636f 6e66 6967 2e6c 6f67 6765 722e    config.logger.
-00008820: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-00008830: 2020 2020 2020 2749 6e69 7469 616c 2072        'Initial r
-00008840: 656c 6178 6564 204e 4c50 2070 726f 626c  elaxed NLP probl
-00008850: 656d 2069 7320 696e 6665 6173 6962 6c65  em is infeasible
-00008860: 2e20 5468 6973 206d 6967 6874 2062 6520  . This might be 
-00008870: 7265 6c61 7465 6420 746f 2070 6172 7469  related to parti
-00008880: 7469 6f6e 5f6f 626a 5f6e 6f6e 6c69 6e65  tion_obj_nonline
-00008890: 6172 5f74 6572 6d73 2e20 5472 7969 6e67  ar_terms. Trying
-000088a0: 2074 6f20 736f 6c76 6520 6974 2061 6761   to solve it aga
-000088b0: 696e 2077 6974 686f 7574 2070 6172 7469  in without parti
-000088c0: 7469 6f6e 696e 6720 6e6f 6e6c 696e 6561  tioning nonlinea
-000088d0: 7220 6f62 6a65 6374 6976 6520 6675 6e63  r objective func
-000088e0: 7469 6f6e 2e27 0a20 2020 2020 2020 2020  tion.'.         
-000088f0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-00008900: 2073 656c 662e 726e 6c70 2e4d 696e 6474   self.rnlp.Mindt
-00008910: 5079 5f75 7469 6c73 2e6f 626a 6563 7469  Py_utils.objecti
-00008920: 7665 2e64 6561 6374 6976 6174 6528 290a  ve.deactivate().
-00008930: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00008940: 2e72 6e6c 702e 4d69 6e64 7450 795f 7574  .rnlp.MindtPy_ut
-00008950: 696c 732e 6f62 6a65 6374 6976 655f 6c69  ils.objective_li
-00008960: 7374 5b30 5d2e 6163 7469 7661 7465 2829  st[0].activate()
-00008970: 0a20 2020 2020 2020 2020 2020 2072 6573  .            res
-00008980: 756c 7473 203d 2073 656c 662e 6e6c 705f  ults = self.nlp_
-00008990: 6f70 742e 736f 6c76 6528 0a20 2020 2020  opt.solve(.     
-000089a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000089b0: 726e 6c70 2c0a 2020 2020 2020 2020 2020  rnlp,.          
-000089c0: 2020 2020 2020 7465 653d 636f 6e66 6967        tee=config
-000089d0: 2e6e 6c70 5f73 6f6c 7665 725f 7465 652c  .nlp_solver_tee,
-000089e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000089f0: 206c 6f61 645f 736f 6c75 7469 6f6e 733d   load_solutions=
-00008a00: 7365 6c66 2e6c 6f61 645f 736f 6c75 7469  self.load_soluti
-00008a10: 6f6e 732c 0a20 2020 2020 2020 2020 2020  ons,.           
-00008a20: 2020 2020 202a 2a6e 6c70 5f61 7267 732c       **nlp_args,
-00008a30: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-00008a40: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
-00008a50: 6e28 7265 7375 6c74 732e 736f 6c75 7469  n(results.soluti
-00008a60: 6f6e 2920 3e20 303a 0a20 2020 2020 2020  on) > 0:.       
-00008a70: 2020 2020 2020 2020 2073 656c 662e 726e           self.rn
-00008a80: 6c70 2e73 6f6c 7574 696f 6e73 2e6c 6f61  lp.solutions.loa
-00008a90: 645f 6672 6f6d 2872 6573 756c 7473 290a  d_from(results).
-00008aa0: 2020 2020 2020 2020 2020 2020 7375 6270              subp
-00008ab0: 726f 625f 7465 726d 696e 6174 655f 636f  rob_terminate_co
-00008ac0: 6e64 203d 2072 6573 756c 7473 2e73 6f6c  nd = results.sol
-00008ad0: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-00008ae0: 636f 6e64 6974 696f 6e0a 0a20 2020 2020  condition..     
-00008af0: 2020 2069 6620 7375 6270 726f 625f 7465     if subprob_te
-00008b00: 726d 696e 6174 655f 636f 6e64 2069 6e20  rminate_cond in 
-00008b10: 7b74 632e 6f70 7469 6d61 6c2c 2074 632e  {tc.optimal, tc.
-00008b20: 6665 6173 6962 6c65 2c20 7463 2e6c 6f63  feasible, tc.loc
-00008b30: 616c 6c79 4f70 7469 6d61 6c7d 3a0a 2020  allyOptimal}:.  
-00008b40: 2020 2020 2020 2020 2020 6d61 696e 5f6f            main_o
-00008b50: 626a 6563 7469 7665 203d 204d 696e 6474  bjective = Mindt
-00008b60: 5079 2e6f 626a 6563 7469 7665 5f6c 6973  Py.objective_lis
-00008b70: 745b 2d31 5d0a 2020 2020 2020 2020 2020  t[-1].          
-00008b80: 2020 6966 2073 7562 7072 6f62 5f74 6572    if subprob_ter
-00008b90: 6d69 6e61 7465 5f63 6f6e 6420 3d3d 2074  minate_cond == t
-00008ba0: 632e 6f70 7469 6d61 6c3a 0a20 2020 2020  c.optimal:.     
-00008bb0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00008bc0: 7570 6461 7465 5f64 7561 6c5f 626f 756e  update_dual_boun
-00008bd0: 6428 7661 6c75 6528 6d61 696e 5f6f 626a  d(value(main_obj
-00008be0: 6563 7469 7665 2e65 7870 7229 290a 2020  ective.expr)).  
-00008bf0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00008c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c10: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
-00008c20: 666f 2827 7265 6c61 7865 6420 4e4c 5020  fo('relaxed NLP 
-00008c30: 6973 206e 6f74 2073 6f6c 7665 6420 746f  is not solved to
-00008c40: 206f 7074 696d 616c 6974 792e 2729 0a20   optimality.'). 
-00008c50: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00008c60: 656c 662e 7570 6461 7465 5f73 7562 6f70  elf.update_subop
-00008c70: 7469 6d61 6c5f 6475 616c 5f62 6f75 6e64  timal_dual_bound
-00008c80: 2872 6573 756c 7473 290a 2020 2020 2020  (results).      
-00008c90: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
-00008ca0: 6765 722e 696e 666f 280a 2020 2020 2020  ger.info(.      
-00008cb0: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
-00008cc0: 6f67 5f66 6f72 6d61 7474 6572 2e66 6f72  og_formatter.for
-00008cd0: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-00008ce0: 2020 2020 2020 2020 2027 2d27 2c0a 2020           '-',.  
-00008cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008d00: 2020 2752 656c 6178 6564 204e 4c50 272c    'Relaxed NLP',
-00008d10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008d20: 2020 2020 2076 616c 7565 286d 6169 6e5f       value(main_
-00008d30: 6f62 6a65 6374 6976 652e 6578 7072 292c  objective.expr),
-00008d40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008d50: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
-00008d60: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
-00008d70: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00008d80: 2e64 7561 6c5f 626f 756e 642c 0a20 2020  .dual_bound,.   
-00008d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008da0: 2073 656c 662e 7265 6c5f 6761 702c 0a20   self.rel_gap,. 
-00008db0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008dc0: 2020 2067 6574 5f6d 6169 6e5f 656c 6170     get_main_elap
-00008dd0: 7365 645f 7469 6d65 2873 656c 662e 7469  sed_time(self.ti
-00008de0: 6d69 6e67 292c 0a20 2020 2020 2020 2020  ming),.         
-00008df0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00008e00: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00008e10: 2020 2023 2041 6464 204f 4120 6375 740a     # Add OA cut.
-00008e20: 2020 2020 2020 2020 2020 2020 6966 2061              if a
-00008e30: 6464 5f6f 615f 6375 7473 3a0a 2020 2020  dd_oa_cuts:.    
-00008e40: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-00008e50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008e60: 2020 2020 2073 656c 662e 636f 6e66 6967       self.config
-00008e70: 2e6e 6c70 5f73 6f6c 7665 7220 3d3d 2027  .nlp_solver == '
-00008e80: 6379 6970 6f70 7427 0a20 2020 2020 2020  cyipopt'.       
-00008e90: 2020 2020 2020 2020 2020 2020 2061 6e64               and
-00008ea0: 2073 656c 662e 6f62 6a65 6374 6976 655f   self.objective_
-00008eb0: 7365 6e73 6520 3d3d 206d 696e 696d 697a  sense == minimiz
-00008ec0: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
-00008ed0: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
-00008ee0: 2020 2020 2020 2020 2023 2054 4f44 4f3a           # TODO:
-00008ef0: 2072 6563 6f76 6572 2074 6865 206f 7070   recover the opp
-00008f00: 6f73 6974 6520 6475 616c 2077 6865 6e20  osite dual when 
-00008f10: 6379 6970 6f70 7420 6973 7375 6520 2332  cyipopt issue #2
-00008f20: 3833 3120 6973 2073 6f6c 7665 642e 0a20  831 is solved.. 
-00008f30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008f40: 2020 2064 7561 6c5f 7661 6c75 6573 203d     dual_values =
-00008f50: 2028 0a20 2020 2020 2020 2020 2020 2020   (.             
-00008f60: 2020 2020 2020 2020 2020 206c 6973 7428             list(
-00008f70: 2d31 202a 2073 656c 662e 726e 6c70 2e64  -1 * self.rnlp.d
-00008f80: 7561 6c5b 635d 2066 6f72 2063 2069 6e20  ual[c] for c in 
-00008f90: 4d69 6e64 7450 792e 636f 6e73 7472 6169  MindtPy.constrai
-00008fa0: 6e74 5f6c 6973 7429 0a20 2020 2020 2020  nt_list).       
-00008fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008fc0: 2069 6620 636f 6e66 6967 2e63 616c 6375   if config.calcu
-00008fd0: 6c61 7465 5f64 7561 6c5f 6174 5f73 6f6c  late_dual_at_sol
-00008fe0: 7574 696f 6e0a 2020 2020 2020 2020 2020  ution.          
-00008ff0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00009000: 7365 204e 6f6e 650a 2020 2020 2020 2020  se None.        
-00009010: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00009020: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00009030: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-00009040: 2020 2020 2020 2020 6475 616c 5f76 616c          dual_val
-00009050: 7565 7320 3d20 280a 2020 2020 2020 2020  ues = (.        
-00009060: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009070: 6c69 7374 2873 656c 662e 726e 6c70 2e64  list(self.rnlp.d
-00009080: 7561 6c5b 635d 2066 6f72 2063 2069 6e20  ual[c] for c in 
-00009090: 4d69 6e64 7450 792e 636f 6e73 7472 6169  MindtPy.constrai
-000090a0: 6e74 5f6c 6973 7429 0a20 2020 2020 2020  nt_list).       
-000090b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000090c0: 2069 6620 636f 6e66 6967 2e63 616c 6375   if config.calcu
-000090d0: 6c61 7465 5f64 7561 6c5f 6174 5f73 6f6c  late_dual_at_sol
-000090e0: 7574 696f 6e0a 2020 2020 2020 2020 2020  ution.          
-000090f0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-00009100: 7365 204e 6f6e 650a 2020 2020 2020 2020  se None.        
-00009110: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00009120: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00009130: 7079 5f76 6172 5f6c 6973 745f 7661 6c75  py_var_list_valu
-00009140: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
-00009150: 2020 2020 2020 2020 7365 6c66 2e72 6e6c          self.rnl
-00009160: 702e 4d69 6e64 7450 795f 7574 696c 732e  p.MindtPy_utils.
-00009170: 7661 7269 6162 6c65 5f6c 6973 742c 0a20  variable_list,. 
-00009180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009190: 2020 2073 656c 662e 6d69 702e 4d69 6e64     self.mip.Mind
-000091a0: 7450 795f 7574 696c 732e 7661 7269 6162  tPy_utils.variab
-000091b0: 6c65 5f6c 6973 742c 0a20 2020 2020 2020  le_list,.       
-000091c0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-000091d0: 6669 672c 0a20 2020 2020 2020 2020 2020  fig,.           
-000091e0: 2020 2020 2020 2020 2069 676e 6f72 655f           ignore_
-000091f0: 696e 7465 6772 616c 6974 793d 5472 7565  integrality=True
-00009200: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009210: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00009220: 2020 2020 6966 2063 6f6e 6669 672e 696e      if config.in
-00009230: 6974 5f73 7472 6174 6567 7920 3d3d 2027  it_strategy == '
-00009240: 4650 273a 0a20 2020 2020 2020 2020 2020  FP':.           
-00009250: 2020 2020 2020 2020 2063 6f70 795f 7661           copy_va
-00009260: 725f 6c69 7374 5f76 616c 7565 7328 0a20  r_list_values(. 
-00009270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009280: 2020 2020 2020 2073 656c 662e 726e 6c70         self.rnlp
-00009290: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-000092a0: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-000092b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000092c0: 2020 2020 2020 7365 6c66 2e77 6f72 6b69        self.worki
-000092d0: 6e67 5f6d 6f64 656c 2e4d 696e 6474 5079  ng_model.MindtPy
-000092e0: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
-000092f0: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
-00009300: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00009310: 6e66 6967 2c0a 2020 2020 2020 2020 2020  nfig,.          
-00009320: 2020 2020 2020 2020 2020 2020 2020 6967                ig
-00009330: 6e6f 7265 5f69 6e74 6567 7261 6c69 7479  nore_integrality
-00009340: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
-00009350: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00009360: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00009370: 662e 6164 645f 6375 7473 280a 2020 2020  f.add_cuts(.    
-00009380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009390: 6475 616c 5f76 616c 7565 733d 6475 616c  dual_values=dual
-000093a0: 5f76 616c 7565 732c 0a20 2020 2020 2020  _values,.       
-000093b0: 2020 2020 2020 2020 2020 2020 206c 696e               lin
-000093c0: 6561 7269 7a65 5f61 6374 6976 653d 5472  earize_active=Tr
-000093d0: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
-000093e0: 2020 2020 2020 2020 6c69 6e65 6172 697a          lineariz
-000093f0: 655f 7669 6f6c 6174 6564 3d54 7275 652c  e_violated=True,
-00009400: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00009410: 2020 2020 2063 625f 6f70 743d 4e6f 6e65       cb_opt=None
-00009420: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00009430: 2020 2020 2020 6e6c 703d 7365 6c66 2e72        nlp=self.r
-00009440: 6e6c 702c 0a20 2020 2020 2020 2020 2020  nlp,.           
-00009450: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00009460: 2020 2020 2020 2066 6f72 2076 6172 2069         for var i
-00009470: 6e20 7365 6c66 2e6d 6970 2e4d 696e 6474  n self.mip.Mindt
-00009480: 5079 5f75 7469 6c73 2e64 6973 6372 6574  Py_utils.discret
-00009490: 655f 7661 7269 6162 6c65 5f6c 6973 743a  e_variable_list:
-000094a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000094b0: 2020 2020 2023 2057 6520 646f 6e27 7420       # We don't 
-000094c0: 7761 6e74 2074 6f20 7472 6967 6765 7220  want to trigger 
-000094d0: 7468 6520 7265 7365 7420 6f66 2074 6865  the reset of the
-000094e0: 2067 6c6f 6261 6c20 7374 616c 650a 2020   global stale.  
-000094f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009500: 2020 2320 696e 6469 6361 746f 722c 2073    # indicator, s
-00009510: 6f20 7765 2077 696c 6c20 7365 7420 7468  o we will set th
-00009520: 6973 2076 6172 6961 626c 6520 746f 2062  is variable to b
-00009530: 6520 2273 7461 6c65 222c 0a20 2020 2020  e "stale",.     
-00009540: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00009550: 206b 6e6f 7769 6e67 2074 6861 7420 7365   knowing that se
-00009560: 745f 7661 6c75 6520 7769 6c6c 2073 7769  t_value will swi
-00009570: 7463 6820 6974 2062 6163 6b20 746f 2022  tch it back to "
-00009580: 6e6f 740a 2020 2020 2020 2020 2020 2020  not.            
-00009590: 2020 2020 2020 2020 2320 7374 616c 6522          # stale"
-000095a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000095b0: 2020 2020 2076 6172 2e73 7461 6c65 203d       var.stale =
-000095c0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
-000095d0: 2020 2020 2020 2020 2020 7661 722e 7365            var.se
-000095e0: 745f 7661 6c75 6528 696e 7428 726f 756e  t_value(int(roun
-000095f0: 6428 7661 722e 7661 6c75 6529 292c 2073  d(var.value)), s
-00009600: 6b69 705f 7661 6c69 6461 7469 6f6e 3d54  kip_validation=T
-00009610: 7275 6529 0a20 2020 2020 2020 2065 6c69  rue).        eli
-00009620: 6620 7375 6270 726f 625f 7465 726d 696e  f subprob_termin
-00009630: 6174 655f 636f 6e64 2069 6e20 7b74 632e  ate_cond in {tc.
-00009640: 696e 6665 6173 6962 6c65 2c20 7463 2e6e  infeasible, tc.n
-00009650: 6f53 6f6c 7574 696f 6e7d 3a0a 2020 2020  oSolution}:.    
-00009660: 2020 2020 2020 2020 2320 544f 444f 2066          # TODO f
-00009670: 6169 6c3f 2074 7279 2073 6f6d 6574 6869  ail? try somethi
-00009680: 6e67 2065 6c73 653f 0a20 2020 2020 2020  ng else?.       
-00009690: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-000096a0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
-000096b0: 2020 2020 2020 2020 2027 496e 6974 6961           'Initia
-000096c0: 6c20 7265 6c61 7865 6420 4e4c 5020 7072  l relaxed NLP pr
-000096d0: 6f62 6c65 6d20 6973 2069 6e66 6561 7369  oblem is infeasi
-000096e0: 626c 652e 2027 0a20 2020 2020 2020 2020  ble. '.         
-000096f0: 2020 2020 2020 2027 5072 6f62 6c65 6d20         'Problem 
-00009700: 6d61 7920 6265 2069 6e66 6561 7369 626c  may be infeasibl
-00009710: 652e 270a 2020 2020 2020 2020 2020 2020  e.'.            
-00009720: 290a 2020 2020 2020 2020 656c 6966 2073  ).        elif s
-00009730: 7562 7072 6f62 5f74 6572 6d69 6e61 7465  ubprob_terminate
-00009740: 5f63 6f6e 6420 6973 2074 632e 6d61 7854  _cond is tc.maxT
-00009750: 696d 654c 696d 6974 3a0a 2020 2020 2020  imeLimit:.      
-00009760: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
-00009770: 6765 722e 696e 666f 2827 4e4c 5020 7375  ger.info('NLP su
-00009780: 6270 726f 626c 656d 2066 6169 6c65 6420  bproblem failed 
-00009790: 746f 2063 6f6e 7665 7267 6520 7769 7468  to converge with
-000097a0: 696e 2074 696d 6520 6c69 6d69 742e 2729  in time limit.')
-000097b0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000097c0: 662e 7265 7375 6c74 732e 736f 6c76 6572  f.results.solver
-000097d0: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-000097e0: 6469 7469 6f6e 203d 2074 632e 6d61 7854  dition = tc.maxT
-000097f0: 696d 654c 696d 6974 0a20 2020 2020 2020  imeLimit.       
-00009800: 2065 6c69 6620 7375 6270 726f 625f 7465   elif subprob_te
-00009810: 726d 696e 6174 655f 636f 6e64 2069 7320  rminate_cond is 
-00009820: 7463 2e6d 6178 4974 6572 6174 696f 6e73  tc.maxIterations
-00009830: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-00009840: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-00009850: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00009860: 2020 274e 4c50 2073 7562 7072 6f62 6c65    'NLP subproble
-00009870: 6d20 6661 696c 6564 2074 6f20 636f 6e76  m failed to conv
-00009880: 6572 6765 2077 6974 6869 6e20 6974 6572  erge within iter
-00009890: 6174 696f 6e20 6c69 6d69 742e 270a 2020  ation limit.'.  
-000098a0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000098b0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000098c0: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-000098d0: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-000098e0: 2020 2020 2020 2020 274d 696e 6474 5079          'MindtPy
-000098f0: 2075 6e61 626c 6520 746f 2068 616e 646c   unable to handl
-00009900: 6520 7265 6c61 7865 6420 4e4c 5020 7465  e relaxed NLP te
-00009910: 726d 696e 6174 696f 6e20 636f 6e64 6974  rmination condit
-00009920: 696f 6e20 270a 2020 2020 2020 2020 2020  ion '.          
-00009930: 2020 2020 2020 276f 6620 2573 2e20 536f        'of %s. So
-00009940: 6c76 6572 206d 6573 7361 6765 3a20 2573  lver message: %s
-00009950: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
-00009960: 2020 2520 2873 7562 7072 6f62 5f74 6572    % (subprob_ter
-00009970: 6d69 6e61 7465 5f63 6f6e 642c 2072 6573  minate_cond, res
-00009980: 756c 7473 2e73 6f6c 7665 722e 6d65 7373  ults.solver.mess
-00009990: 6167 6529 0a20 2020 2020 2020 2020 2020  age).           
-000099a0: 2029 0a0a 2020 2020 6465 6620 696e 6974   )..    def init
-000099b0: 5f6d 6178 5f62 696e 6172 6965 7328 7365  _max_binaries(se
-000099c0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-000099d0: 4d6f 6469 6669 6573 206d 6f64 656c 2062  Modifies model b
-000099e0: 7920 6d61 7869 6d69 7a69 6e67 2074 6865  y maximizing the
-000099f0: 206e 756d 6265 7220 6f66 2061 6374 6976   number of activ
-00009a00: 6174 6564 2062 696e 6172 7920 7661 7269  ated binary vari
-00009a10: 6162 6c65 732e 0a0a 2020 2020 2020 2020  ables...        
-00009a20: 4e6f 7465 202d 2054 6865 2075 7365 7220  Note - The user 
-00009a30: 776f 756c 6420 7573 7561 6c6c 7920 7761  would usually wa
-00009a40: 6e74 2074 6f20 6361 6c6c 2073 6f6c 7665  nt to call solve
-00009a50: 5f73 7562 7072 6f62 6c65 6d20 6166 7465  _subproblem afte
-00009a60: 7220 616e 2069 6e76 6f63 6174 696f 6e0a  r an invocation.
-00009a70: 2020 2020 2020 2020 6f66 2074 6869 7320          of this 
-00009a80: 6675 6e63 7469 6f6e 2e0a 0a20 2020 2020  function...     
-00009a90: 2020 2052 6169 7365 730a 2020 2020 2020     Raises.      
-00009aa0: 2020 2d2d 2d2d 2d2d 0a20 2020 2020 2020    ------.       
-00009ab0: 2056 616c 7565 4572 726f 720a 2020 2020   ValueError.    
-00009ac0: 2020 2020 2020 2020 4d49 4c50 206d 6169          MILP mai
-00009ad0: 6e20 7072 6f62 6c65 6d20 6973 2069 6e66  n problem is inf
-00009ae0: 6561 7369 626c 652e 0a20 2020 2020 2020  easible..       
-00009af0: 2056 616c 7565 4572 726f 720a 2020 2020   ValueError.    
-00009b00: 2020 2020 2020 2020 4d69 6e64 7450 7920          MindtPy 
-00009b10: 756e 6162 6c65 2074 6f20 6861 6e64 6c65  unable to handle
-00009b20: 2074 6865 2074 6572 6d69 6e61 7469 6f6e   the termination
-00009b30: 2063 6f6e 6469 7469 6f6e 206f 6620 7468   condition of th
-00009b40: 6520 4d49 4c50 206d 6169 6e20 7072 6f62  e MILP main prob
-00009b50: 6c65 6d2e 0a20 2020 2020 2020 2022 2222  lem..        """
-00009b60: 0a20 2020 2020 2020 2063 6f6e 6669 6720  .        config 
-00009b70: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-00009b80: 2020 2020 2020 6d20 3d20 7365 6c66 2e77        m = self.w
-00009b90: 6f72 6b69 6e67 5f6d 6f64 656c 2e63 6c6f  orking_model.clo
-00009ba0: 6e65 2829 0a20 2020 2020 2020 2069 6620  ne().        if 
-00009bb0: 6861 7361 7474 7228 6d2c 2027 6475 616c  hasattr(m, 'dual
-00009bc0: 2729 2061 6e64 2069 7369 6e73 7461 6e63  ') and isinstanc
-00009bd0: 6528 6d2e 6475 616c 2c20 5375 6666 6978  e(m.dual, Suffix
-00009be0: 293a 0a20 2020 2020 2020 2020 2020 206d  ):.            m
-00009bf0: 2e64 656c 5f63 6f6d 706f 6e65 6e74 2827  .del_component('
-00009c00: 6475 616c 2729 0a20 2020 2020 2020 204d  dual').        M
-00009c10: 696e 6474 5079 203d 206d 2e4d 696e 6474  indtPy = m.Mindt
-00009c20: 5079 5f75 7469 6c73 0a20 2020 2020 2020  Py_utils.       
-00009c30: 2073 656c 662e 6d69 705f 7375 6269 7465   self.mip_subite
-00009c40: 7220 2b3d 2031 0a20 2020 2020 2020 2063  r += 1.        c
-00009c50: 6f6e 6669 672e 6c6f 6767 6572 2e64 6562  onfig.logger.deb
-00009c60: 7567 2827 496e 6974 6961 6c69 7a61 7469  ug('Initializati
-00009c70: 6f6e 3a20 6d61 7869 6d69 7a65 2076 616c  on: maximize val
-00009c80: 7565 206f 6620 6269 6e61 7269 6573 2729  ue of binaries')
-00009c90: 0a20 2020 2020 2020 2066 6f72 2063 2069  .        for c i
-00009ca0: 6e20 4d69 6e64 7450 792e 6e6f 6e6c 696e  n MindtPy.nonlin
-00009cb0: 6561 725f 636f 6e73 7472 6169 6e74 5f6c  ear_constraint_l
-00009cc0: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
-00009cd0: 2063 2e64 6561 6374 6976 6174 6528 290a   c.deactivate().
-00009ce0: 2020 2020 2020 2020 6f62 6a65 6374 6976          objectiv
-00009cf0: 6520 3d20 6e65 7874 286d 2e63 6f6d 706f  e = next(m.compo
-00009d00: 6e65 6e74 5f64 6174 615f 6f62 6a65 6374  nent_data_object
-00009d10: 7328 4f62 6a65 6374 6976 652c 2061 6374  s(Objective, act
-00009d20: 6976 653d 5472 7565 2929 0a20 2020 2020  ive=True)).     
-00009d30: 2020 206f 626a 6563 7469 7665 2e64 6561     objective.dea
-00009d40: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
-00009d50: 2020 6269 6e61 7279 5f76 6172 7320 3d20    binary_vars = 
-00009d60: 280a 2020 2020 2020 2020 2020 2020 760a  (.            v.
-00009d70: 2020 2020 2020 2020 2020 2020 666f 7220              for 
-00009d80: 7620 696e 206d 2e4d 696e 6474 5079 5f75  v in m.MindtPy_u
-00009d90: 7469 6c73 2e64 6973 6372 6574 655f 7661  tils.discrete_va
-00009da0: 7269 6162 6c65 5f6c 6973 740a 2020 2020  riable_list.    
-00009db0: 2020 2020 2020 2020 6966 2076 2e69 735f          if v.is_
-00009dc0: 6269 6e61 7279 2829 2061 6e64 206e 6f74  binary() and not
-00009dd0: 2076 2e66 6978 6564 0a20 2020 2020 2020   v.fixed.       
-00009de0: 2029 0a20 2020 2020 2020 204d 696e 6474   ).        Mindt
-00009df0: 5079 2e6d 6178 5f62 696e 6172 795f 6f62  Py.max_binary_ob
-00009e00: 6a20 3d20 4f62 6a65 6374 6976 6528 0a20  j = Objective(. 
-00009e10: 2020 2020 2020 2020 2020 2065 7870 723d             expr=
-00009e20: 7375 6d28 7620 666f 7220 7620 696e 2062  sum(v for v in b
-00009e30: 696e 6172 795f 7661 7273 292c 2073 656e  inary_vars), sen
-00009e40: 7365 3d6d 6178 696d 697a 650a 2020 2020  se=maximize.    
-00009e50: 2020 2020 290a 0a20 2020 2020 2020 2067      )..        g
-00009e60: 6574 6174 7472 286d 2c20 2769 706f 7074  etattr(m, 'ipopt
-00009e70: 5f7a 4c5f 6f75 7427 2c20 5f44 6f4e 6f74  _zL_out', _DoNot
-00009e80: 6869 6e67 2829 292e 6465 6163 7469 7661  hing()).deactiva
-00009e90: 7465 2829 0a20 2020 2020 2020 2067 6574  te().        get
-00009ea0: 6174 7472 286d 2c20 2769 706f 7074 5f7a  attr(m, 'ipopt_z
-00009eb0: 555f 6f75 7427 2c20 5f44 6f4e 6f74 6869  U_out', _DoNothi
-00009ec0: 6e67 2829 292e 6465 6163 7469 7661 7465  ng()).deactivate
-00009ed0: 2829 0a0a 2020 2020 2020 2020 6966 2069  ()..        if i
-00009ee0: 7369 6e73 7461 6e63 6528 7365 6c66 2e6d  sinstance(self.m
-00009ef0: 6970 5f6f 7074 2c20 5065 7273 6973 7465  ip_opt, Persiste
-00009f00: 6e74 536f 6c76 6572 293a 0a20 2020 2020  ntSolver):.     
-00009f10: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-00009f20: 6f70 742e 7365 745f 696e 7374 616e 6365  opt.set_instance
-00009f30: 286d 290a 2020 2020 2020 2020 6d69 705f  (m).        mip_
-00009f40: 6172 6773 203d 2064 6963 7428 636f 6e66  args = dict(conf
-00009f50: 6967 2e6d 6970 5f73 6f6c 7665 725f 6172  ig.mip_solver_ar
-00009f60: 6773 290a 2020 2020 2020 2020 7570 6461  gs).        upda
-00009f70: 7465 5f73 6f6c 7665 725f 7469 6d65 6c69  te_solver_timeli
-00009f80: 6d69 7428 7365 6c66 2e6d 6970 5f6f 7074  mit(self.mip_opt
-00009f90: 2c20 636f 6e66 6967 2e6d 6970 5f73 6f6c  , config.mip_sol
-00009fa0: 7665 722c 2073 656c 662e 7469 6d69 6e67  ver, self.timing
-00009fb0: 2c20 636f 6e66 6967 290a 2020 2020 2020  , config).      
-00009fc0: 2020 7265 7375 6c74 7320 3d20 7365 6c66    results = self
-00009fd0: 2e6d 6970 5f6f 7074 2e73 6f6c 7665 280a  .mip_opt.solve(.
-00009fe0: 2020 2020 2020 2020 2020 2020 6d2c 2074              m, t
-00009ff0: 6565 3d63 6f6e 6669 672e 6d69 705f 736f  ee=config.mip_so
-0000a000: 6c76 6572 5f74 6565 2c20 6c6f 6164 5f73  lver_tee, load_s
-0000a010: 6f6c 7574 696f 6e73 3d73 656c 662e 6c6f  olutions=self.lo
-0000a020: 6164 5f73 6f6c 7574 696f 6e73 2c20 2a2a  ad_solutions, **
-0000a030: 6d69 705f 6172 6773 0a20 2020 2020 2020  mip_args.       
-0000a040: 2029 0a20 2020 2020 2020 2069 6620 6c65   ).        if le
-0000a050: 6e28 7265 7375 6c74 732e 736f 6c75 7469  n(results.soluti
-0000a060: 6f6e 2920 3e20 303a 0a20 2020 2020 2020  on) > 0:.       
-0000a070: 2020 2020 206d 2e73 6f6c 7574 696f 6e73       m.solutions
-0000a080: 2e6c 6f61 645f 6672 6f6d 2872 6573 756c  .load_from(resul
-0000a090: 7473 290a 0a20 2020 2020 2020 2073 6f6c  ts)..        sol
-0000a0a0: 7665 5f74 6572 6d69 6e61 7465 5f63 6f6e  ve_terminate_con
-0000a0b0: 6420 3d20 7265 7375 6c74 732e 736f 6c76  d = results.solv
-0000a0c0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
-0000a0d0: 6f6e 6469 7469 6f6e 0a20 2020 2020 2020  ondition.       
-0000a0e0: 2069 6620 736f 6c76 655f 7465 726d 696e   if solve_termin
-0000a0f0: 6174 655f 636f 6e64 2069 7320 7463 2e6f  ate_cond is tc.o
-0000a100: 7074 696d 616c 3a0a 2020 2020 2020 2020  ptimal:.        
-0000a110: 2020 2020 636f 7079 5f76 6172 5f6c 6973      copy_var_lis
-0000a120: 745f 7661 6c75 6573 280a 2020 2020 2020  t_values(.      
-0000a130: 2020 2020 2020 2020 2020 4d69 6e64 7450            MindtP
-0000a140: 792e 7661 7269 6162 6c65 5f6c 6973 742c  y.variable_list,
-0000a150: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a160: 2073 656c 662e 776f 726b 696e 675f 6d6f   self.working_mo
-0000a170: 6465 6c2e 4d69 6e64 7450 795f 7574 696c  del.MindtPy_util
-0000a180: 732e 7661 7269 6162 6c65 5f6c 6973 742c  s.variable_list,
-0000a190: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a1a0: 2063 6f6e 6669 672c 0a20 2020 2020 2020   config,.       
-0000a1b0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0000a1c0: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
-0000a1d0: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
-0000a1e0: 2020 2020 2020 2073 656c 662e 6c6f 675f         self.log_
-0000a1f0: 666f 726d 6174 7465 722e 666f 726d 6174  formatter.format
-0000a200: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000a210: 2020 2020 2020 272d 272c 0a20 2020 2020        '-',.     
-0000a220: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000a230: 4d61 7820 6269 6e61 7279 204d 494c 5027  Max binary MILP'
-0000a240: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000a250: 2020 2020 2020 7661 6c75 6528 4d69 6e64        value(Mind
-0000a260: 7450 792e 6d61 785f 6269 6e61 7279 5f6f  tPy.max_binary_o
-0000a270: 626a 2e65 7870 7229 2c0a 2020 2020 2020  bj.expr),.      
-0000a280: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000a290: 6c66 2e70 7269 6d61 6c5f 626f 756e 642c  lf.primal_bound,
-0000a2a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000a2b0: 2020 2020 2073 656c 662e 6475 616c 5f62       self.dual_b
-0000a2c0: 6f75 6e64 2c0a 2020 2020 2020 2020 2020  ound,.          
-0000a2d0: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
-0000a2e0: 656c 5f67 6170 2c0a 2020 2020 2020 2020  el_gap,.        
-0000a2f0: 2020 2020 2020 2020 2020 2020 6765 745f              get_
-0000a300: 6d61 696e 5f65 6c61 7073 6564 5f74 696d  main_elapsed_tim
-0000a310: 6528 7365 6c66 2e74 696d 696e 6729 2c0a  e(self.timing),.
-0000a320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000a330: 290a 2020 2020 2020 2020 2020 2020 290a  ).            ).
-0000a340: 2020 2020 2020 2020 656c 6966 2073 6f6c          elif sol
-0000a350: 7665 5f74 6572 6d69 6e61 7465 5f63 6f6e  ve_terminate_con
-0000a360: 6420 6973 2074 632e 696e 6665 6173 6962  d is tc.infeasib
-0000a370: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
-0000a380: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
-0000a390: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000a3a0: 2020 274d 4950 206d 6169 6e20 7072 6f62    'MIP main prob
-0000a3b0: 6c65 6d20 6973 2069 6e66 6561 7369 626c  lem is infeasibl
-0000a3c0: 652e 2027 0a20 2020 2020 2020 2020 2020  e. '.           
-0000a3d0: 2020 2020 2027 5072 6f62 6c65 6d20 6d61       'Problem ma
-0000a3e0: 7920 6861 7665 206e 6f20 6d6f 7265 2066  y have no more f
-0000a3f0: 6561 7369 626c 6520 270a 2020 2020 2020  easible '.      
-0000a400: 2020 2020 2020 2020 2020 2762 696e 6172            'binar
-0000a410: 7920 636f 6e66 6967 7572 6174 696f 6e73  y configurations
-0000a420: 2e27 0a20 2020 2020 2020 2020 2020 2029  .'.            )
-0000a430: 0a20 2020 2020 2020 2065 6c69 6620 736f  .        elif so
-0000a440: 6c76 655f 7465 726d 696e 6174 655f 636f  lve_terminate_co
-0000a450: 6e64 2069 7320 7463 2e6d 6178 5469 6d65  nd is tc.maxTime
-0000a460: 4c69 6d69 743a 0a20 2020 2020 2020 2020  Limit:.         
-0000a470: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
-0000a480: 2e69 6e66 6f28 274e 4c50 2073 7562 7072  .info('NLP subpr
-0000a490: 6f62 6c65 6d20 6661 696c 6564 2074 6f20  oblem failed to 
-0000a4a0: 636f 6e76 6572 6765 2077 6974 6869 6e20  converge within 
-0000a4b0: 7469 6d65 206c 696d 6974 2e27 290a 2020  time limit.').  
-0000a4c0: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
-0000a4d0: 6573 756c 7473 2e73 6f6c 7665 722e 7465  esults.solver.te
-0000a4e0: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
-0000a4f0: 696f 6e20 3d20 7463 2e6d 6178 5469 6d65  ion = tc.maxTime
-0000a500: 4c69 6d69 740a 2020 2020 2020 2020 656c  Limit.        el
-0000a510: 6966 2073 6f6c 7665 5f74 6572 6d69 6e61  if solve_termina
-0000a520: 7465 5f63 6f6e 6420 6973 2074 632e 6d61  te_cond is tc.ma
-0000a530: 7849 7465 7261 7469 6f6e 733a 0a20 2020  xIterations:.   
-0000a540: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
-0000a550: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
-0000a560: 2020 2020 2020 2020 2020 2020 2027 4e4c               'NL
-0000a570: 5020 7375 6270 726f 626c 656d 2066 6169  P subproblem fai
-0000a580: 6c65 6420 746f 2063 6f6e 7665 7267 6520  led to converge 
-0000a590: 7769 7468 696e 2069 7465 7261 7469 6f6e  within iteration
-0000a5a0: 206c 696d 6974 2e27 0a20 2020 2020 2020   limit.'.       
-0000a5b0: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
-0000a5c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000a5d0: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000a5e0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-0000a5f0: 2020 2027 4d69 6e64 7450 7920 756e 6162     'MindtPy unab
-0000a600: 6c65 2074 6f20 6861 6e64 6c65 204d 494c  le to handle MIL
-0000a610: 5020 6d61 696e 2074 6572 6d69 6e61 7469  P main terminati
-0000a620: 6f6e 2063 6f6e 6469 7469 6f6e 2027 0a20  on condition '. 
-0000a630: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000a640: 6f66 2025 732e 2053 6f6c 7665 7220 6d65  of %s. Solver me
-0000a650: 7373 6167 653a 2025 7327 0a20 2020 2020  ssage: %s'.     
-0000a660: 2020 2020 2020 2020 2020 2025 2028 736f             % (so
-0000a670: 6c76 655f 7465 726d 696e 6174 655f 636f  lve_terminate_co
-0000a680: 6e64 2c20 7265 7375 6c74 732e 736f 6c76  nd, results.solv
-0000a690: 6572 2e6d 6573 7361 6765 290a 2020 2020  er.message).    
-0000a6a0: 2020 2020 2020 2020 290a 0a20 2020 2023          )..    #
-0000a6b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a6c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008060: 206c 656e 2873 656c 662e 6d69 702e 4d69   len(self.mip.Mi
+00008070: 6e64 7450 795f 7574 696c 732e 6375 7473  ndtPy_utils.cuts
+00008080: 2e6f 615f 6375 7473 292c 0a20 2020 2020  .oa_cuts),.     
+00008090: 2020 2020 2020 205d 0a20 2020 2020 2020         ].       
+000080a0: 2065 6c69 6620 636f 6e66 6967 2e69 6e69   elif config.ini
+000080b0: 745f 7374 7261 7465 6779 203d 3d20 2746  t_strategy == 'F
+000080c0: 5027 3a0a 2020 2020 2020 2020 2020 2020  P':.            
+000080d0: 7365 6c66 2e69 6e69 745f 724e 4c50 2829  self.init_rNLP()
+000080e0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+000080f0: 662e 6670 5f6c 6f6f 7028 290a 0a20 2020  f.fp_loop()..   
+00008100: 2064 6566 2069 6e69 745f 724e 4c50 2873   def init_rNLP(s
+00008110: 656c 662c 2061 6464 5f6f 615f 6375 7473  elf, add_oa_cuts
+00008120: 3d54 7275 6529 3a0a 2020 2020 2020 2020  =True):.        
+00008130: 2222 2249 6e69 7469 616c 697a 6520 7468  """Initialize th
+00008140: 6520 7072 6f62 6c65 6d20 6279 2073 6f6c  e problem by sol
+00008150: 7669 6e67 2074 6865 2072 656c 6178 6564  ving the relaxed
+00008160: 204e 4c50 2061 6e64 2074 6865 6e20 7374   NLP and then st
+00008170: 6f72 6520 7468 6520 6f70 7469 6d61 6c20  ore the optimal 
+00008180: 7661 7269 6162 6c65 0a20 2020 2020 2020  variable.       
+00008190: 2076 616c 7565 7320 6f62 7461 696e 6564   values obtained
+000081a0: 2066 726f 6d20 736f 6c76 696e 6720 7468   from solving th
+000081b0: 6520 724e 4c50 2e0a 0a20 2020 2020 2020  e rNLP...       
+000081c0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
+000081d0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
+000081e0: 2020 2020 2020 2061 6464 5f6f 615f 6375         add_oa_cu
+000081f0: 7473 203a 2042 6f6f 6c0a 2020 2020 2020  ts : Bool.      
+00008200: 2020 2020 2020 5768 6574 6865 7220 6164        Whether ad
+00008210: 6420 4f41 2063 7574 7320 6166 7465 7220  d OA cuts after 
+00008220: 736f 6c76 696e 6720 7468 6520 7265 6c61  solving the rela
+00008230: 7865 6420 4e4c 5020 7072 6f62 6c65 6d2e  xed NLP problem.
+00008240: 0a0a 2020 2020 2020 2020 5261 6973 6573  ..        Raises
+00008250: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d0a  .        ------.
+00008260: 2020 2020 2020 2020 5661 6c75 6545 7272          ValueErr
+00008270: 6f72 0a20 2020 2020 2020 2020 2020 204d  or.            M
+00008280: 696e 6474 5079 2075 6e61 626c 6520 746f  indtPy unable to
+00008290: 2068 616e 646c 6520 7468 6520 7465 726d   handle the term
+000082a0: 696e 6174 696f 6e20 636f 6e64 6974 696f  ination conditio
+000082b0: 6e20 6f66 2074 6865 2072 656c 6178 6564  n of the relaxed
+000082c0: 204e 4c50 2e0a 2020 2020 2020 2020 2222   NLP..        ""
+000082d0: 220a 2020 2020 2020 2020 636f 6e66 6967  ".        config
+000082e0: 203d 2073 656c 662e 636f 6e66 6967 0a20   = self.config. 
+000082f0: 2020 2020 2020 2073 656c 662e 726e 6c70         self.rnlp
+00008300: 203d 2073 656c 662e 776f 726b 696e 675f   = self.working_
+00008310: 6d6f 6465 6c2e 636c 6f6e 6528 290a 2020  model.clone().  
+00008320: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
+00008330: 6765 722e 6465 6275 6728 2752 656c 6178  ger.debug('Relax
+00008340: 6564 204e 4c50 3a20 536f 6c76 6520 7265  ed NLP: Solve re
+00008350: 6c61 7865 6420 696e 7465 6772 616c 6974  laxed integralit
+00008360: 7927 290a 2020 2020 2020 2020 4d69 6e64  y').        Mind
+00008370: 7450 7920 3d20 7365 6c66 2e72 6e6c 702e  tPy = self.rnlp.
+00008380: 4d69 6e64 7450 795f 7574 696c 730a 2020  MindtPy_utils.  
+00008390: 2020 2020 2020 5472 616e 7366 6f72 6d61        Transforma
+000083a0: 7469 6f6e 4661 6374 6f72 7928 2763 6f72  tionFactory('cor
+000083b0: 652e 7265 6c61 785f 696e 7465 6765 725f  e.relax_integer_
+000083c0: 7661 7273 2729 2e61 7070 6c79 5f74 6f28  vars').apply_to(
+000083d0: 7365 6c66 2e72 6e6c 7029 0a20 2020 2020  self.rnlp).     
+000083e0: 2020 206e 6c70 5f61 7267 7320 3d20 6469     nlp_args = di
+000083f0: 6374 2863 6f6e 6669 672e 6e6c 705f 736f  ct(config.nlp_so
+00008400: 6c76 6572 5f61 7267 7329 0a20 2020 2020  lver_args).     
+00008410: 2020 2075 7064 6174 655f 736f 6c76 6572     update_solver
+00008420: 5f74 696d 656c 696d 6974 2873 656c 662e  _timelimit(self.
+00008430: 6e6c 705f 6f70 742c 2063 6f6e 6669 672e  nlp_opt, config.
+00008440: 6e6c 705f 736f 6c76 6572 2c20 7365 6c66  nlp_solver, self
+00008450: 2e74 696d 696e 672c 2063 6f6e 6669 6729  .timing, config)
+00008460: 0a20 2020 2020 2020 2077 6974 6820 5375  .        with Su
+00008470: 7070 7265 7373 496e 6665 6173 6962 6c65  ppressInfeasible
+00008480: 5761 726e 696e 6728 293a 0a20 2020 2020  Warning():.     
+00008490: 2020 2020 2020 2072 6573 756c 7473 203d         results =
+000084a0: 2073 656c 662e 6e6c 705f 6f70 742e 736f   self.nlp_opt.so
+000084b0: 6c76 6528 0a20 2020 2020 2020 2020 2020  lve(.           
+000084c0: 2020 2020 2073 656c 662e 726e 6c70 2c0a       self.rnlp,.
+000084d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000084e0: 7465 653d 636f 6e66 6967 2e6e 6c70 5f73  tee=config.nlp_s
+000084f0: 6f6c 7665 725f 7465 652c 0a20 2020 2020  olver_tee,.     
+00008500: 2020 2020 2020 2020 2020 206c 6f61 645f             load_
+00008510: 736f 6c75 7469 6f6e 733d 7365 6c66 2e6e  solutions=self.n
+00008520: 6c70 5f6c 6f61 645f 736f 6c75 7469 6f6e  lp_load_solution
+00008530: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00008540: 2020 202a 2a6e 6c70 5f61 7267 732c 0a20     **nlp_args,. 
+00008550: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00008560: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
+00008570: 7265 7375 6c74 732e 736f 6c75 7469 6f6e  results.solution
+00008580: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+00008590: 2020 2020 2020 2073 656c 662e 726e 6c70         self.rnlp
+000085a0: 2e73 6f6c 7574 696f 6e73 2e6c 6f61 645f  .solutions.load_
+000085b0: 6672 6f6d 2872 6573 756c 7473 290a 2020  from(results).  
+000085c0: 2020 2020 2020 7375 6270 726f 625f 7465        subprob_te
+000085d0: 726d 696e 6174 655f 636f 6e64 203d 2072  rminate_cond = r
+000085e0: 6573 756c 7473 2e73 6f6c 7665 722e 7465  esults.solver.te
+000085f0: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
+00008600: 696f 6e0a 0a20 2020 2020 2020 2023 2053  ion..        # S
+00008610: 6f6d 6574 696d 6573 2c20 7468 6520 4e4c  ometimes, the NL
+00008620: 5020 736f 6c76 6572 206d 6967 6874 2062  P solver might b
+00008630: 6520 7472 6170 7065 6420 696e 2061 2069  e trapped in a i
+00008640: 6e66 6561 7369 626c 6520 736f 6c75 7469  nfeasible soluti
+00008650: 6f6e 2069 6620 7468 6520 6f62 6a65 6374  on if the object
+00008660: 6976 6520 6675 6e63 7469 6f6e 2069 7320  ive function is 
+00008670: 6e6f 6e6c 696e 6561 7220 616e 6420 7061  nonlinear and pa
+00008680: 7274 6974 696f 6e5f 6f62 6a5f 6e6f 6e6c  rtition_obj_nonl
+00008690: 696e 6561 725f 7465 726d 7320 6973 2054  inear_terms is T
+000086a0: 7275 652e 2049 6620 7468 6973 2068 6170  rue. If this hap
+000086b0: 7065 6e73 2c20 7765 2077 696c 6c20 7573  pens, we will us
+000086c0: 6520 7468 6520 6f72 6967 696e 616c 206f  e the original o
+000086d0: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+000086e0: 6e20 696e 7374 6561 642e 0a20 2020 2020  n instead..     
+000086f0: 2020 2069 6620 280a 2020 2020 2020 2020     if (.        
+00008700: 2020 2020 7375 6270 726f 625f 7465 726d      subprob_term
+00008710: 696e 6174 655f 636f 6e64 203d 3d20 7463  inate_cond == tc
+00008720: 2e69 6e66 6561 7369 626c 650a 2020 2020  .infeasible.    
+00008730: 2020 2020 2020 2020 616e 6420 636f 6e66          and conf
+00008740: 6967 2e70 6172 7469 7469 6f6e 5f6f 626a  ig.partition_obj
+00008750: 5f6e 6f6e 6c69 6e65 6172 5f74 6572 6d73  _nonlinear_terms
+00008760: 0a20 2020 2020 2020 2020 2020 2061 6e64  .            and
+00008770: 2073 656c 662e 726e 6c70 2e4d 696e 6474   self.rnlp.Mindt
+00008780: 5079 5f75 7469 6c73 2e6f 626a 6563 7469  Py_utils.objecti
+00008790: 7665 5f6c 6973 745b 305d 2e65 7870 722e  ve_list[0].expr.
+000087a0: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+000087b0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
+000087c0: 6e6f 7420 696e 2073 656c 662e 6d69 705f  not in self.mip_
+000087d0: 6f62 6a65 6374 6976 655f 706f 6c79 6e6f  objective_polyno
+000087e0: 6d69 616c 5f64 6567 7265 650a 2020 2020  mial_degree.    
+000087f0: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
+00008800: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+00008810: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+00008820: 2020 2020 2020 2027 496e 6974 6961 6c20         'Initial 
+00008830: 7265 6c61 7865 6420 4e4c 5020 7072 6f62  relaxed NLP prob
+00008840: 6c65 6d20 6973 2069 6e66 6561 7369 626c  lem is infeasibl
+00008850: 652e 2054 6869 7320 6d69 6768 7420 6265  e. This might be
+00008860: 2072 656c 6174 6564 2074 6f20 7061 7274   related to part
+00008870: 6974 696f 6e5f 6f62 6a5f 6e6f 6e6c 696e  ition_obj_nonlin
+00008880: 6561 725f 7465 726d 732e 2054 7279 696e  ear_terms. Tryin
+00008890: 6720 746f 2073 6f6c 7665 2069 7420 6167  g to solve it ag
+000088a0: 6169 6e20 7769 7468 6f75 7420 7061 7274  ain without part
+000088b0: 6974 696f 6e69 6e67 206e 6f6e 6c69 6e65  itioning nonline
+000088c0: 6172 206f 626a 6563 7469 7665 2066 756e  ar objective fun
+000088d0: 6374 696f 6e2e 270a 2020 2020 2020 2020  ction.'.        
+000088e0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+000088f0: 2020 7365 6c66 2e72 6e6c 702e 4d69 6e64    self.rnlp.Mind
+00008900: 7450 795f 7574 696c 732e 6f62 6a65 6374  tPy_utils.object
+00008910: 6976 652e 6465 6163 7469 7661 7465 2829  ive.deactivate()
+00008920: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00008930: 662e 726e 6c70 2e4d 696e 6474 5079 5f75  f.rnlp.MindtPy_u
+00008940: 7469 6c73 2e6f 626a 6563 7469 7665 5f6c  tils.objective_l
+00008950: 6973 745b 305d 2e61 6374 6976 6174 6528  ist[0].activate(
+00008960: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00008970: 7375 6c74 7320 3d20 7365 6c66 2e6e 6c70  sults = self.nlp
+00008980: 5f6f 7074 2e73 6f6c 7665 280a 2020 2020  _opt.solve(.    
+00008990: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000089a0: 2e72 6e6c 702c 0a20 2020 2020 2020 2020  .rnlp,.         
+000089b0: 2020 2020 2020 2074 6565 3d63 6f6e 6669         tee=confi
+000089c0: 672e 6e6c 705f 736f 6c76 6572 5f74 6565  g.nlp_solver_tee
+000089d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000089e0: 2020 6c6f 6164 5f73 6f6c 7574 696f 6e73    load_solutions
+000089f0: 3d73 656c 662e 6e6c 705f 6c6f 6164 5f73  =self.nlp_load_s
+00008a00: 6f6c 7574 696f 6e73 2c0a 2020 2020 2020  olutions,.      
+00008a10: 2020 2020 2020 2020 2020 2a2a 6e6c 705f            **nlp_
+00008a20: 6172 6773 2c0a 2020 2020 2020 2020 2020  args,.          
+00008a30: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+00008a40: 6966 206c 656e 2872 6573 756c 7473 2e73  if len(results.s
+00008a50: 6f6c 7574 696f 6e29 203e 2030 3a0a 2020  olution) > 0:.  
+00008a60: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00008a70: 6c66 2e72 6e6c 702e 736f 6c75 7469 6f6e  lf.rnlp.solution
+00008a80: 732e 6c6f 6164 5f66 726f 6d28 7265 7375  s.load_from(resu
+00008a90: 6c74 7329 0a20 2020 2020 2020 2020 2020  lts).           
+00008aa0: 2073 7562 7072 6f62 5f74 6572 6d69 6e61   subprob_termina
+00008ab0: 7465 5f63 6f6e 6420 3d20 7265 7375 6c74  te_cond = result
+00008ac0: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00008ad0: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 0a0a  tion_condition..
+00008ae0: 2020 2020 2020 2020 6966 2073 7562 7072          if subpr
+00008af0: 6f62 5f74 6572 6d69 6e61 7465 5f63 6f6e  ob_terminate_con
+00008b00: 6420 696e 207b 7463 2e6f 7074 696d 616c  d in {tc.optimal
+00008b10: 2c20 7463 2e66 6561 7369 626c 652c 2074  , tc.feasible, t
+00008b20: 632e 6c6f 6361 6c6c 794f 7074 696d 616c  c.locallyOptimal
+00008b30: 7d3a 0a20 2020 2020 2020 2020 2020 206d  }:.            m
+00008b40: 6169 6e5f 6f62 6a65 6374 6976 6520 3d20  ain_objective = 
+00008b50: 4d69 6e64 7450 792e 6f62 6a65 6374 6976  MindtPy.objectiv
+00008b60: 655f 6c69 7374 5b2d 315d 0a20 2020 2020  e_list[-1].     
+00008b70: 2020 2020 2020 2069 6620 7375 6270 726f         if subpro
+00008b80: 625f 7465 726d 696e 6174 655f 636f 6e64  b_terminate_cond
+00008b90: 203d 3d20 7463 2e6f 7074 696d 616c 3a0a   == tc.optimal:.
+00008ba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008bb0: 7365 6c66 2e75 7064 6174 655f 6475 616c  self.update_dual
+00008bc0: 5f62 6f75 6e64 2876 616c 7565 286d 6169  _bound(value(mai
+00008bd0: 6e5f 6f62 6a65 6374 6976 652e 6578 7072  n_objective.expr
+00008be0: 2929 0a20 2020 2020 2020 2020 2020 2065  )).            e
+00008bf0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00008c00: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
+00008c10: 6572 2e69 6e66 6f28 2772 656c 6178 6564  er.info('relaxed
+00008c20: 204e 4c50 2069 7320 6e6f 7420 736f 6c76   NLP is not solv
+00008c30: 6564 2074 6f20 6f70 7469 6d61 6c69 7479  ed to optimality
+00008c40: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
+00008c50: 2020 2020 7365 6c66 2e75 7064 6174 655f      self.update_
+00008c60: 7375 626f 7074 696d 616c 5f64 7561 6c5f  suboptimal_dual_
+00008c70: 626f 756e 6428 7265 7375 6c74 7329 0a20  bound(results). 
+00008c80: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+00008c90: 672e 6c6f 6767 6572 2e69 6e66 6f28 0a20  g.logger.info(. 
+00008ca0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00008cb0: 656c 662e 6c6f 675f 666f 726d 6174 7465  elf.log_formatte
+00008cc0: 722e 666f 726d 6174 280a 2020 2020 2020  r.format(.      
+00008cd0: 2020 2020 2020 2020 2020 2020 2020 272d                '-
+00008ce0: 272c 0a20 2020 2020 2020 2020 2020 2020  ',.             
+00008cf0: 2020 2020 2020 2027 5265 6c61 7865 6420         'Relaxed 
+00008d00: 4e4c 5027 2c0a 2020 2020 2020 2020 2020  NLP',.          
+00008d10: 2020 2020 2020 2020 2020 7661 6c75 6528            value(
+00008d20: 6d61 696e 5f6f 626a 6563 7469 7665 2e65  main_objective.e
+00008d30: 7870 7229 2c0a 2020 2020 2020 2020 2020  xpr),.          
+00008d40: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+00008d50: 7269 6d61 6c5f 626f 756e 642c 0a20 2020  rimal_bound,.   
+00008d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008d70: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+00008d80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00008d90: 2020 2020 2020 7365 6c66 2e72 656c 5f67        self.rel_g
+00008da0: 6170 2c0a 2020 2020 2020 2020 2020 2020  ap,.            
+00008db0: 2020 2020 2020 2020 6765 745f 6d61 696e          get_main
+00008dc0: 5f65 6c61 7073 6564 5f74 696d 6528 7365  _elapsed_time(se
+00008dd0: 6c66 2e74 696d 696e 6729 2c0a 2020 2020  lf.timing),.    
+00008de0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00008df0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00008e00: 2020 2020 2020 2020 2320 4164 6420 4f41          # Add OA
+00008e10: 2063 7574 0a20 2020 2020 2020 2020 2020   cut.           
+00008e20: 2069 6620 6164 645f 6f61 5f63 7574 733a   if add_oa_cuts:
+00008e30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008e40: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
+00008e50: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
+00008e60: 6f6e 6669 672e 6e6c 705f 736f 6c76 6572  onfig.nlp_solver
+00008e70: 203d 3d20 2763 7969 706f 7074 270a 2020   == 'cyipopt'.  
+00008e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008e90: 2020 616e 6420 7365 6c66 2e6f 626a 6563    and self.objec
+00008ea0: 7469 7665 5f73 656e 7365 203d 3d20 6d69  tive_sense == mi
+00008eb0: 6e69 6d69 7a65 0a20 2020 2020 2020 2020  nimize.         
+00008ec0: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+00008ed0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+00008ee0: 544f 444f 3a20 7265 636f 7665 7220 7468  TODO: recover th
+00008ef0: 6520 6f70 706f 7369 7465 2064 7561 6c20  e opposite dual 
+00008f00: 7768 656e 2063 7969 706f 7074 2069 7373  when cyipopt iss
+00008f10: 7565 2023 3238 3331 2069 7320 736f 6c76  ue #2831 is solv
+00008f20: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
+00008f30: 2020 2020 2020 2020 6475 616c 5f76 616c          dual_val
+00008f40: 7565 7320 3d20 280a 2020 2020 2020 2020  ues = (.        
+00008f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008f60: 6c69 7374 282d 3120 2a20 7365 6c66 2e72  list(-1 * self.r
+00008f70: 6e6c 702e 6475 616c 5b63 5d20 666f 7220  nlp.dual[c] for 
+00008f80: 6320 696e 204d 696e 6474 5079 2e63 6f6e  c in MindtPy.con
+00008f90: 7374 7261 696e 745f 6c69 7374 290a 2020  straint_list).  
+00008fa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008fb0: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+00008fc0: 6361 6c63 756c 6174 655f 6475 616c 5f61  calculate_dual_a
+00008fd0: 745f 736f 6c75 7469 6f6e 0a20 2020 2020  t_solution.     
+00008fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008ff0: 2020 2065 6c73 6520 4e6f 6e65 0a20 2020     else None.   
+00009000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009010: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00009020: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00009030: 2020 2020 2020 2020 2020 2020 2064 7561               dua
+00009040: 6c5f 7661 6c75 6573 203d 2028 0a20 2020  l_values = (.   
+00009050: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009060: 2020 2020 206c 6973 7428 7365 6c66 2e72       list(self.r
+00009070: 6e6c 702e 6475 616c 5b63 5d20 666f 7220  nlp.dual[c] for 
+00009080: 6320 696e 204d 696e 6474 5079 2e63 6f6e  c in MindtPy.con
+00009090: 7374 7261 696e 745f 6c69 7374 290a 2020  straint_list).  
+000090a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000090b0: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+000090c0: 6361 6c63 756c 6174 655f 6475 616c 5f61  calculate_dual_a
+000090d0: 745f 736f 6c75 7469 6f6e 0a20 2020 2020  t_solution.     
+000090e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000090f0: 2020 2065 6c73 6520 4e6f 6e65 0a20 2020     else None.   
+00009100: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009110: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00009120: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
+00009130: 5f76 616c 7565 7328 0a20 2020 2020 2020  _values(.       
+00009140: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00009150: 662e 726e 6c70 2e4d 696e 6474 5079 5f75  f.rnlp.MindtPy_u
+00009160: 7469 6c73 2e76 6172 6961 626c 655f 6c69  tils.variable_li
+00009170: 7374 2c0a 2020 2020 2020 2020 2020 2020  st,.            
+00009180: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00009190: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+000091a0: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+000091b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000091c0: 2020 636f 6e66 6967 2c0a 2020 2020 2020    config,.      
+000091d0: 2020 2020 2020 2020 2020 2020 2020 6967                ig
+000091e0: 6e6f 7265 5f69 6e74 6567 7261 6c69 7479  nore_integrality
+000091f0: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
+00009200: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00009210: 2020 2020 2020 2020 2069 6620 636f 6e66           if conf
+00009220: 6967 2e69 6e69 745f 7374 7261 7465 6779  ig.init_strategy
+00009230: 203d 3d20 2746 5027 3a0a 2020 2020 2020   == 'FP':.      
+00009240: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00009250: 7079 5f76 6172 5f6c 6973 745f 7661 6c75  py_var_list_valu
+00009260: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+00009270: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00009280: 2e72 6e6c 702e 4d69 6e64 7450 795f 7574  .rnlp.MindtPy_ut
+00009290: 696c 732e 7661 7269 6162 6c65 5f6c 6973  ils.variable_lis
+000092a0: 742c 0a20 2020 2020 2020 2020 2020 2020  t,.             
+000092b0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000092c0: 776f 726b 696e 675f 6d6f 6465 6c2e 4d69  working_model.Mi
+000092d0: 6e64 7450 795f 7574 696c 732e 7661 7269  ndtPy_utils.vari
+000092e0: 6162 6c65 5f6c 6973 742c 0a20 2020 2020  able_list,.     
+000092f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009300: 2020 2063 6f6e 6669 672c 0a20 2020 2020     config,.     
+00009310: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009320: 2020 2069 676e 6f72 655f 696e 7465 6772     ignore_integr
+00009330: 616c 6974 793d 5472 7565 2c0a 2020 2020  ality=True,.    
+00009340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009350: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00009360: 2020 7365 6c66 2e61 6464 5f63 7574 7328    self.add_cuts(
+00009370: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009380: 2020 2020 2064 7561 6c5f 7661 6c75 6573       dual_values
+00009390: 3d64 7561 6c5f 7661 6c75 6573 2c0a 2020  =dual_values,.  
+000093a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000093b0: 2020 6c69 6e65 6172 697a 655f 6163 7469    linearize_acti
+000093c0: 7665 3d54 7275 652c 0a20 2020 2020 2020  ve=True,.       
+000093d0: 2020 2020 2020 2020 2020 2020 206c 696e               lin
+000093e0: 6561 7269 7a65 5f76 696f 6c61 7465 643d  earize_violated=
+000093f0: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+00009400: 2020 2020 2020 2020 2020 6362 5f6f 7074            cb_opt
+00009410: 3d4e 6f6e 652c 0a20 2020 2020 2020 2020  =None,.         
+00009420: 2020 2020 2020 2020 2020 206e 6c70 3d73             nlp=s
+00009430: 656c 662e 726e 6c70 2c0a 2020 2020 2020  elf.rnlp,.      
+00009440: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00009450: 2020 2020 2020 2020 2020 2020 666f 7220              for 
+00009460: 7661 7220 696e 2073 656c 662e 6d69 702e  var in self.mip.
+00009470: 4d69 6e64 7450 795f 7574 696c 732e 6469  MindtPy_utils.di
+00009480: 7363 7265 7465 5f76 6172 6961 626c 655f  screte_variable_
+00009490: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
+000094a0: 2020 2020 2020 2020 2020 2320 5765 2064            # We d
+000094b0: 6f6e 2774 2077 616e 7420 746f 2074 7269  on't want to tri
+000094c0: 6767 6572 2074 6865 2072 6573 6574 206f  gger the reset o
+000094d0: 6620 7468 6520 676c 6f62 616c 2073 7461  f the global sta
+000094e0: 6c65 0a20 2020 2020 2020 2020 2020 2020  le.             
+000094f0: 2020 2020 2020 2023 2069 6e64 6963 6174         # indicat
+00009500: 6f72 2c20 736f 2077 6520 7769 6c6c 2073  or, so we will s
+00009510: 6574 2074 6869 7320 7661 7269 6162 6c65  et this variable
+00009520: 2074 6f20 6265 2022 7374 616c 6522 2c0a   to be "stale",.
+00009530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009540: 2020 2020 2320 6b6e 6f77 696e 6720 7468      # knowing th
+00009550: 6174 2073 6574 5f76 616c 7565 2077 696c  at set_value wil
+00009560: 6c20 7377 6974 6368 2069 7420 6261 636b  l switch it back
+00009570: 2074 6f20 226e 6f74 0a20 2020 2020 2020   to "not.       
+00009580: 2020 2020 2020 2020 2020 2020 2023 2073               # s
+00009590: 7461 6c65 220a 2020 2020 2020 2020 2020  tale".          
+000095a0: 2020 2020 2020 2020 2020 7661 722e 7374            var.st
+000095b0: 616c 6520 3d20 5472 7565 0a20 2020 2020  ale = True.     
+000095c0: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+000095d0: 6172 2e73 6574 5f76 616c 7565 2869 6e74  ar.set_value(int
+000095e0: 2872 6f75 6e64 2876 6172 2e76 616c 7565  (round(var.value
+000095f0: 2929 2c20 736b 6970 5f76 616c 6964 6174  )), skip_validat
+00009600: 696f 6e3d 5472 7565 290a 2020 2020 2020  ion=True).      
+00009610: 2020 656c 6966 2073 7562 7072 6f62 5f74    elif subprob_t
+00009620: 6572 6d69 6e61 7465 5f63 6f6e 6420 696e  erminate_cond in
+00009630: 207b 7463 2e69 6e66 6561 7369 626c 652c   {tc.infeasible,
+00009640: 2074 632e 6e6f 536f 6c75 7469 6f6e 7d3a   tc.noSolution}:
+00009650: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
+00009660: 4f44 4f20 6661 696c 3f20 7472 7920 736f  ODO fail? try so
+00009670: 6d65 7468 696e 6720 656c 7365 3f0a 2020  mething else?.  
+00009680: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+00009690: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
+000096a0: 2020 2020 2020 2020 2020 2020 2020 2749                'I
+000096b0: 6e69 7469 616c 2072 656c 6178 6564 204e  nitial relaxed N
+000096c0: 4c50 2070 726f 626c 656d 2069 7320 696e  LP problem is in
+000096d0: 6665 6173 6962 6c65 2e20 270a 2020 2020  feasible. '.    
+000096e0: 2020 2020 2020 2020 2020 2020 2750 726f              'Pro
+000096f0: 626c 656d 206d 6179 2062 6520 696e 6665  blem may be infe
+00009700: 6173 6962 6c65 2e27 0a20 2020 2020 2020  asible.'.       
+00009710: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
+00009720: 6c69 6620 7375 6270 726f 625f 7465 726d  lif subprob_term
+00009730: 696e 6174 655f 636f 6e64 2069 7320 7463  inate_cond is tc
+00009740: 2e6d 6178 5469 6d65 4c69 6d69 743a 0a20  .maxTimeLimit:. 
+00009750: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+00009760: 672e 6c6f 6767 6572 2e69 6e66 6f28 274e  g.logger.info('N
+00009770: 4c50 2073 7562 7072 6f62 6c65 6d20 6661  LP subproblem fa
+00009780: 696c 6564 2074 6f20 636f 6e76 6572 6765  iled to converge
+00009790: 2077 6974 6869 6e20 7469 6d65 206c 696d   within time lim
+000097a0: 6974 2e27 290a 2020 2020 2020 2020 2020  it.').          
+000097b0: 2020 7365 6c66 2e72 6573 756c 7473 2e73    self.results.s
+000097c0: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+000097d0: 6e5f 636f 6e64 6974 696f 6e20 3d20 7463  n_condition = tc
+000097e0: 2e6d 6178 5469 6d65 4c69 6d69 740a 2020  .maxTimeLimit.  
+000097f0: 2020 2020 2020 656c 6966 2073 7562 7072        elif subpr
+00009800: 6f62 5f74 6572 6d69 6e61 7465 5f63 6f6e  ob_terminate_con
+00009810: 6420 6973 2074 632e 6d61 7849 7465 7261  d is tc.maxItera
+00009820: 7469 6f6e 733a 0a20 2020 2020 2020 2020  tions:.         
+00009830: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+00009840: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+00009850: 2020 2020 2020 2027 4e4c 5020 7375 6270         'NLP subp
+00009860: 726f 626c 656d 2066 6169 6c65 6420 746f  roblem failed to
+00009870: 2063 6f6e 7665 7267 6520 7769 7468 696e   converge within
+00009880: 2069 7465 7261 7469 6f6e 206c 696d 6974   iteration limit
+00009890: 2e27 0a20 2020 2020 2020 2020 2020 2029  .'.            )
+000098a0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+000098b0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+000098c0: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+000098d0: 2020 2020 2020 2020 2020 2020 2027 4d69               'Mi
+000098e0: 6e64 7450 7920 756e 6162 6c65 2074 6f20  ndtPy unable to 
+000098f0: 6861 6e64 6c65 2072 656c 6178 6564 204e  handle relaxed N
+00009900: 4c50 2074 6572 6d69 6e61 7469 6f6e 2063  LP termination c
+00009910: 6f6e 6469 7469 6f6e 2027 0a20 2020 2020  ondition '.     
+00009920: 2020 2020 2020 2020 2020 2027 6f66 2025             'of %
+00009930: 732e 2053 6f6c 7665 7220 6d65 7373 6167  s. Solver messag
+00009940: 653a 2025 7327 0a20 2020 2020 2020 2020  e: %s'.         
+00009950: 2020 2020 2020 2025 2028 7375 6270 726f         % (subpro
+00009960: 625f 7465 726d 696e 6174 655f 636f 6e64  b_terminate_cond
+00009970: 2c20 7265 7375 6c74 732e 736f 6c76 6572  , results.solver
+00009980: 2e6d 6573 7361 6765 290a 2020 2020 2020  .message).      
+00009990: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
+000099a0: 2069 6e69 745f 6d61 785f 6269 6e61 7269   init_max_binari
+000099b0: 6573 2873 656c 6629 3a0a 2020 2020 2020  es(self):.      
+000099c0: 2020 2222 224d 6f64 6966 6965 7320 6d6f    """Modifies mo
+000099d0: 6465 6c20 6279 206d 6178 696d 697a 696e  del by maximizin
+000099e0: 6720 7468 6520 6e75 6d62 6572 206f 6620  g the number of 
+000099f0: 6163 7469 7661 7465 6420 6269 6e61 7279  activated binary
+00009a00: 2076 6172 6961 626c 6573 2e0a 0a20 2020   variables...   
+00009a10: 2020 2020 204e 6f74 6520 2d20 5468 6520       Note - The 
+00009a20: 7573 6572 2077 6f75 6c64 2075 7375 616c  user would usual
+00009a30: 6c79 2077 616e 7420 746f 2063 616c 6c20  ly want to call 
+00009a40: 736f 6c76 655f 7375 6270 726f 626c 656d  solve_subproblem
+00009a50: 2061 6674 6572 2061 6e20 696e 766f 6361   after an invoca
+00009a60: 7469 6f6e 0a20 2020 2020 2020 206f 6620  tion.        of 
+00009a70: 7468 6973 2066 756e 6374 696f 6e2e 0a0a  this function...
+00009a80: 2020 2020 2020 2020 5261 6973 6573 0a20          Raises. 
+00009a90: 2020 2020 2020 202d 2d2d 2d2d 2d0a 2020         ------.  
+00009aa0: 2020 2020 2020 5661 6c75 6545 7272 6f72        ValueError
+00009ab0: 0a20 2020 2020 2020 2020 2020 204d 494c  .            MIL
+00009ac0: 5020 6d61 696e 2070 726f 626c 656d 2069  P main problem i
+00009ad0: 7320 696e 6665 6173 6962 6c65 2e0a 2020  s infeasible..  
+00009ae0: 2020 2020 2020 5661 6c75 6545 7272 6f72        ValueError
+00009af0: 0a20 2020 2020 2020 2020 2020 204d 696e  .            Min
+00009b00: 6474 5079 2075 6e61 626c 6520 746f 2068  dtPy unable to h
+00009b10: 616e 646c 6520 7468 6520 7465 726d 696e  andle the termin
+00009b20: 6174 696f 6e20 636f 6e64 6974 696f 6e20  ation condition 
+00009b30: 6f66 2074 6865 204d 494c 5020 6d61 696e  of the MILP main
+00009b40: 2070 726f 626c 656d 2e0a 2020 2020 2020   problem..      
+00009b50: 2020 2222 220a 2020 2020 2020 2020 636f    """.        co
+00009b60: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
+00009b70: 6967 0a20 2020 2020 2020 206d 203d 2073  ig.        m = s
+00009b80: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+00009b90: 6c2e 636c 6f6e 6528 290a 2020 2020 2020  l.clone().      
+00009ba0: 2020 6966 2068 6173 6174 7472 286d 2c20    if hasattr(m, 
+00009bb0: 2764 7561 6c27 2920 616e 6420 6973 696e  'dual') and isin
+00009bc0: 7374 616e 6365 286d 2e64 7561 6c2c 2053  stance(m.dual, S
+00009bd0: 7566 6669 7829 3a0a 2020 2020 2020 2020  uffix):.        
+00009be0: 2020 2020 6d2e 6465 6c5f 636f 6d70 6f6e      m.del_compon
+00009bf0: 656e 7428 2764 7561 6c27 290a 2020 2020  ent('dual').    
+00009c00: 2020 2020 4d69 6e64 7450 7920 3d20 6d2e      MindtPy = m.
+00009c10: 4d69 6e64 7450 795f 7574 696c 730a 2020  MindtPy_utils.  
+00009c20: 2020 2020 2020 7365 6c66 2e6d 6970 5f73        self.mip_s
+00009c30: 7562 6974 6572 202b 3d20 310a 2020 2020  ubiter += 1.    
+00009c40: 2020 2020 636f 6e66 6967 2e6c 6f67 6765      config.logge
+00009c50: 722e 6465 6275 6728 2749 6e69 7469 616c  r.debug('Initial
+00009c60: 697a 6174 696f 6e3a 206d 6178 696d 697a  ization: maximiz
+00009c70: 6520 7661 6c75 6520 6f66 2062 696e 6172  e value of binar
+00009c80: 6965 7327 290a 2020 2020 2020 2020 666f  ies').        fo
+00009c90: 7220 6320 696e 204d 696e 6474 5079 2e6e  r c in MindtPy.n
+00009ca0: 6f6e 6c69 6e65 6172 5f63 6f6e 7374 7261  onlinear_constra
+00009cb0: 696e 745f 6c69 7374 3a0a 2020 2020 2020  int_list:.      
+00009cc0: 2020 2020 2020 632e 6465 6163 7469 7661        c.deactiva
+00009cd0: 7465 2829 0a20 2020 2020 2020 206f 626a  te().        obj
+00009ce0: 6563 7469 7665 203d 206e 6578 7428 6d2e  ective = next(m.
+00009cf0: 636f 6d70 6f6e 656e 745f 6461 7461 5f6f  component_data_o
+00009d00: 626a 6563 7473 284f 626a 6563 7469 7665  bjects(Objective
+00009d10: 2c20 6163 7469 7665 3d54 7275 6529 290a  , active=True)).
+00009d20: 2020 2020 2020 2020 6f62 6a65 6374 6976          objectiv
+00009d30: 652e 6465 6163 7469 7661 7465 2829 0a20  e.deactivate(). 
+00009d40: 2020 2020 2020 2062 696e 6172 795f 7661         binary_va
+00009d50: 7273 203d 2028 0a20 2020 2020 2020 2020  rs = (.         
+00009d60: 2020 2076 0a20 2020 2020 2020 2020 2020     v.           
+00009d70: 2066 6f72 2076 2069 6e20 6d2e 4d69 6e64   for v in m.Mind
+00009d80: 7450 795f 7574 696c 732e 6469 7363 7265  tPy_utils.discre
+00009d90: 7465 5f76 6172 6961 626c 655f 6c69 7374  te_variable_list
+00009da0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00009db0: 762e 6973 5f62 696e 6172 7928 2920 616e  v.is_binary() an
+00009dc0: 6420 6e6f 7420 762e 6669 7865 640a 2020  d not v.fixed.  
+00009dd0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00009de0: 4d69 6e64 7450 792e 6d61 785f 6269 6e61  MindtPy.max_bina
+00009df0: 7279 5f6f 626a 203d 204f 626a 6563 7469  ry_obj = Objecti
+00009e00: 7665 280a 2020 2020 2020 2020 2020 2020  ve(.            
+00009e10: 6578 7072 3d73 756d 2876 2066 6f72 2076  expr=sum(v for v
+00009e20: 2069 6e20 6269 6e61 7279 5f76 6172 7329   in binary_vars)
+00009e30: 2c20 7365 6e73 653d 6d61 7869 6d69 7a65  , sense=maximize
+00009e40: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
+00009e50: 2020 2020 6765 7461 7474 7228 6d2c 2027      getattr(m, '
+00009e60: 6970 6f70 745f 7a4c 5f6f 7574 272c 205f  ipopt_zL_out', _
+00009e70: 446f 4e6f 7468 696e 6728 2929 2e64 6561  DoNothing()).dea
+00009e80: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
+00009e90: 2020 6765 7461 7474 7228 6d2c 2027 6970    getattr(m, 'ip
+00009ea0: 6f70 745f 7a55 5f6f 7574 272c 205f 446f  opt_zU_out', _Do
+00009eb0: 4e6f 7468 696e 6728 2929 2e64 6561 6374  Nothing()).deact
+00009ec0: 6976 6174 6528 290a 0a20 2020 2020 2020  ivate()..       
+00009ed0: 2069 6620 6973 696e 7374 616e 6365 2873   if isinstance(s
+00009ee0: 656c 662e 6d69 705f 6f70 742c 2050 6572  elf.mip_opt, Per
+00009ef0: 7369 7374 656e 7453 6f6c 7665 7229 3a0a  sistentSolver):.
+00009f00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00009f10: 2e6d 6970 5f6f 7074 2e73 6574 5f69 6e73  .mip_opt.set_ins
+00009f20: 7461 6e63 6528 6d29 0a20 2020 2020 2020  tance(m).       
+00009f30: 206d 6970 5f61 7267 7320 3d20 6469 6374   mip_args = dict
+00009f40: 2863 6f6e 6669 672e 6d69 705f 736f 6c76  (config.mip_solv
+00009f50: 6572 5f61 7267 7329 0a20 2020 2020 2020  er_args).       
+00009f60: 2075 7064 6174 655f 736f 6c76 6572 5f74   update_solver_t
+00009f70: 696d 656c 696d 6974 2873 656c 662e 6d69  imelimit(self.mi
+00009f80: 705f 6f70 742c 2063 6f6e 6669 672e 6d69  p_opt, config.mi
+00009f90: 705f 736f 6c76 6572 2c20 7365 6c66 2e74  p_solver, self.t
+00009fa0: 696d 696e 672c 2063 6f6e 6669 6729 0a20  iming, config). 
+00009fb0: 2020 2020 2020 2072 6573 756c 7473 203d         results =
+00009fc0: 2073 656c 662e 6d69 705f 6f70 742e 736f   self.mip_opt.so
+00009fd0: 6c76 6528 0a20 2020 2020 2020 2020 2020  lve(.           
+00009fe0: 206d 2c0a 2020 2020 2020 2020 2020 2020   m,.            
+00009ff0: 7465 653d 636f 6e66 6967 2e6d 6970 5f73  tee=config.mip_s
+0000a000: 6f6c 7665 725f 7465 652c 0a20 2020 2020  olver_tee,.     
+0000a010: 2020 2020 2020 206c 6f61 645f 736f 6c75         load_solu
+0000a020: 7469 6f6e 733d 7365 6c66 2e6d 6970 5f6c  tions=self.mip_l
+0000a030: 6f61 645f 736f 6c75 7469 6f6e 732c 0a20  oad_solutions,. 
+0000a040: 2020 2020 2020 2020 2020 202a 2a6d 6970             **mip
+0000a050: 5f61 7267 732c 0a20 2020 2020 2020 2029  _args,.        )
+0000a060: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
+0000a070: 7265 7375 6c74 732e 736f 6c75 7469 6f6e  results.solution
+0000a080: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+0000a090: 2020 206d 2e73 6f6c 7574 696f 6e73 2e6c     m.solutions.l
+0000a0a0: 6f61 645f 6672 6f6d 2872 6573 756c 7473  oad_from(results
+0000a0b0: 290a 0a20 2020 2020 2020 2073 6f6c 7665  )..        solve
+0000a0c0: 5f74 6572 6d69 6e61 7465 5f63 6f6e 6420  _terminate_cond 
+0000a0d0: 3d20 7265 7375 6c74 732e 736f 6c76 6572  = results.solver
+0000a0e0: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
+0000a0f0: 6469 7469 6f6e 0a20 2020 2020 2020 2069  dition.        i
+0000a100: 6620 736f 6c76 655f 7465 726d 696e 6174  f solve_terminat
+0000a110: 655f 636f 6e64 2069 7320 7463 2e6f 7074  e_cond is tc.opt
+0000a120: 696d 616c 3a0a 2020 2020 2020 2020 2020  imal:.          
+0000a130: 2020 636f 7079 5f76 6172 5f6c 6973 745f    copy_var_list_
+0000a140: 7661 6c75 6573 280a 2020 2020 2020 2020  values(.        
+0000a150: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+0000a160: 7661 7269 6162 6c65 5f6c 6973 742c 0a20  variable_list,. 
+0000a170: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000a180: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+0000a190: 6c2e 4d69 6e64 7450 795f 7574 696c 732e  l.MindtPy_utils.
+0000a1a0: 7661 7269 6162 6c65 5f6c 6973 742c 0a20  variable_list,. 
+0000a1b0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000a1c0: 6f6e 6669 672c 0a20 2020 2020 2020 2020  onfig,.         
+0000a1d0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+0000a1e0: 2063 6f6e 6669 672e 6c6f 6767 6572 2e69   config.logger.i
+0000a1f0: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+0000a200: 2020 2020 2073 656c 662e 6c6f 675f 666f       self.log_fo
+0000a210: 726d 6174 7465 722e 666f 726d 6174 280a  rmatter.format(.
+0000a220: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a230: 2020 2020 272d 272c 0a20 2020 2020 2020      '-',.       
+0000a240: 2020 2020 2020 2020 2020 2020 2027 4d61               'Ma
+0000a250: 7820 6269 6e61 7279 204d 494c 5027 2c0a  x binary MILP',.
+0000a260: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a270: 2020 2020 7661 6c75 6528 4d69 6e64 7450      value(MindtP
+0000a280: 792e 6d61 785f 6269 6e61 7279 5f6f 626a  y.max_binary_obj
+0000a290: 2e65 7870 7229 2c0a 2020 2020 2020 2020  .expr),.        
+0000a2a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000a2b0: 2e70 7269 6d61 6c5f 626f 756e 642c 0a20  .primal_bound,. 
+0000a2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a2d0: 2020 2073 656c 662e 6475 616c 5f62 6f75     self.dual_bou
+0000a2e0: 6e64 2c0a 2020 2020 2020 2020 2020 2020  nd,.            
+0000a2f0: 2020 2020 2020 2020 7365 6c66 2e72 656c          self.rel
+0000a300: 5f67 6170 2c0a 2020 2020 2020 2020 2020  _gap,.          
+0000a310: 2020 2020 2020 2020 2020 6765 745f 6d61            get_ma
+0000a320: 696e 5f65 6c61 7073 6564 5f74 696d 6528  in_elapsed_time(
+0000a330: 7365 6c66 2e74 696d 696e 6729 2c0a 2020  self.timing),.  
+0000a340: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+0000a350: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000a360: 2020 2020 2020 656c 6966 2073 6f6c 7665        elif solve
+0000a370: 5f74 6572 6d69 6e61 7465 5f63 6f6e 6420  _terminate_cond 
+0000a380: 6973 2074 632e 696e 6665 6173 6962 6c65  is tc.infeasible
+0000a390: 3a0a 2020 2020 2020 2020 2020 2020 7261  :.            ra
+0000a3a0: 6973 6520 5661 6c75 6545 7272 6f72 280a  ise ValueError(.
+0000a3b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000a3c0: 274d 4950 206d 6169 6e20 7072 6f62 6c65  'MIP main proble
+0000a3d0: 6d20 6973 2069 6e66 6561 7369 626c 652e  m is infeasible.
+0000a3e0: 2027 0a20 2020 2020 2020 2020 2020 2020   '.             
+0000a3f0: 2020 2027 5072 6f62 6c65 6d20 6d61 7920     'Problem may 
+0000a400: 6861 7665 206e 6f20 6d6f 7265 2066 6561  have no more fea
+0000a410: 7369 626c 6520 270a 2020 2020 2020 2020  sible '.        
+0000a420: 2020 2020 2020 2020 2762 696e 6172 7920          'binary 
+0000a430: 636f 6e66 6967 7572 6174 696f 6e73 2e27  configurations.'
+0000a440: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+0000a450: 2020 2020 2020 2065 6c69 6620 736f 6c76         elif solv
+0000a460: 655f 7465 726d 696e 6174 655f 636f 6e64  e_terminate_cond
+0000a470: 2069 7320 7463 2e6d 6178 5469 6d65 4c69   is tc.maxTimeLi
+0000a480: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
+0000a490: 2063 6f6e 6669 672e 6c6f 6767 6572 2e69   config.logger.i
+0000a4a0: 6e66 6f28 274e 4c50 2073 7562 7072 6f62  nfo('NLP subprob
+0000a4b0: 6c65 6d20 6661 696c 6564 2074 6f20 636f  lem failed to co
+0000a4c0: 6e76 6572 6765 2077 6974 6869 6e20 7469  nverge within ti
+0000a4d0: 6d65 206c 696d 6974 2e27 290a 2020 2020  me limit.').    
+0000a4e0: 2020 2020 2020 2020 7365 6c66 2e72 6573          self.res
+0000a4f0: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+0000a500: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+0000a510: 6e20 3d20 7463 2e6d 6178 5469 6d65 4c69  n = tc.maxTimeLi
+0000a520: 6d69 740a 2020 2020 2020 2020 656c 6966  mit.        elif
+0000a530: 2073 6f6c 7665 5f74 6572 6d69 6e61 7465   solve_terminate
+0000a540: 5f63 6f6e 6420 6973 2074 632e 6d61 7849  _cond is tc.maxI
+0000a550: 7465 7261 7469 6f6e 733a 0a20 2020 2020  terations:.     
+0000a560: 2020 2020 2020 2063 6f6e 6669 672e 6c6f         config.lo
+0000a570: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
+0000a580: 2020 2020 2020 2020 2020 2027 4e4c 5020             'NLP 
+0000a590: 7375 6270 726f 626c 656d 2066 6169 6c65  subproblem faile
+0000a5a0: 6420 746f 2063 6f6e 7665 7267 6520 7769  d to converge wi
+0000a5b0: 7468 696e 2069 7465 7261 7469 6f6e 206c  thin iteration l
+0000a5c0: 696d 6974 2e27 0a20 2020 2020 2020 2020  imit.'.         
+0000a5d0: 2020 2029 0a20 2020 2020 2020 2065 6c73     ).        els
+0000a5e0: 653a 0a20 2020 2020 2020 2020 2020 2072  e:.            r
+0000a5f0: 6169 7365 2056 616c 7565 4572 726f 7228  aise ValueError(
+0000a600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000a610: 2027 4d69 6e64 7450 7920 756e 6162 6c65   'MindtPy unable
+0000a620: 2074 6f20 6861 6e64 6c65 204d 494c 5020   to handle MILP 
+0000a630: 6d61 696e 2074 6572 6d69 6e61 7469 6f6e  main termination
+0000a640: 2063 6f6e 6469 7469 6f6e 2027 0a20 2020   condition '.   
+0000a650: 2020 2020 2020 2020 2020 2020 2027 6f66               'of
+0000a660: 2025 732e 2053 6f6c 7665 7220 6d65 7373   %s. Solver mess
+0000a670: 6167 653a 2025 7327 0a20 2020 2020 2020  age: %s'.       
+0000a680: 2020 2020 2020 2020 2025 2028 736f 6c76           % (solv
+0000a690: 655f 7465 726d 696e 6174 655f 636f 6e64  e_terminate_cond
+0000a6a0: 2c20 7265 7375 6c74 732e 736f 6c76 6572  , results.solver
+0000a6b0: 2e6d 6573 7361 6765 290a 2020 2020 2020  .message).      
+0000a6c0: 2020 2020 2020 290a 0a20 2020 2023 2323        )..    ###
 0000a6d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a6e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a6f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a730: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000a770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a780: 230a 2020 2020 2320 6e6c 705f 736f 6c76  #.    # nlp_solv
-0000a790: 652e 7079 0a0a 2020 2020 6465 6620 736f  e.py..    def so
-0000a7a0: 6c76 655f 7375 6270 726f 626c 656d 2873  lve_subproblem(s
-0000a7b0: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-0000a7c0: 2253 6f6c 7665 7320 7468 6520 4669 7865  "Solves the Fixe
-0000a7d0: 642d 4e4c 5020 2877 6974 6820 6669 7865  d-NLP (with fixe
-0000a7e0: 6420 696e 7465 6765 7273 292e 0a0a 2020  d integers)...  
-0000a7f0: 2020 2020 2020 5468 6973 2066 756e 6374        This funct
-0000a800: 696f 6e20 7365 7473 2075 7020 7468 6520  ion sets up the 
-0000a810: 2766 6978 6564 5f6e 6c70 2720 6279 2066  'fixed_nlp' by f
-0000a820: 6978 696e 6720 6269 6e61 7269 6573 2c20  ixing binaries, 
-0000a830: 7365 7473 2063 6f6e 7469 6e75 6f75 7320  sets continuous 
-0000a840: 7661 7269 6162 6c65 7320 746f 2074 6865  variables to the
-0000a850: 6972 2069 6e69 7469 616c 2076 6172 2076  ir initial var v
-0000a860: 616c 7565 732c 0a20 2020 2020 2020 2070  alues,.        p
-0000a870: 7265 636f 6d70 7574 6573 2064 7561 6c20  recomputes dual 
-0000a880: 7661 6c75 6573 2c20 6465 6163 7469 7661  values, deactiva
-0000a890: 7465 7320 7472 6976 6961 6c20 636f 6e73  tes trivial cons
-0000a8a0: 7472 6169 6e74 732c 2061 6e64 2074 6865  traints, and the
-0000a8b0: 6e20 736f 6c76 6573 204e 4c50 206d 6f64  n solves NLP mod
-0000a8c0: 656c 2e0a 0a20 2020 2020 2020 2052 6574  el...        Ret
-0000a8d0: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
-0000a8e0: 2d2d 2d2d 0a20 2020 2020 2020 2066 6978  ----.        fix
-0000a8f0: 6564 5f6e 6c70 203a 2050 796f 6d6f 206d  ed_nlp : Pyomo m
-0000a900: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
-0000a910: 2049 6e74 6567 6572 2d76 6172 6961 626c   Integer-variabl
-0000a920: 652d 6669 7865 6420 4e4c 5020 6d6f 6465  e-fixed NLP mode
-0000a930: 6c2e 0a20 2020 2020 2020 2072 6573 756c  l..        resul
-0000a940: 7473 203a 2053 6f6c 7665 7252 6573 756c  ts : SolverResul
-0000a950: 7473 0a20 2020 2020 2020 2020 2020 2052  ts.            R
-0000a960: 6573 756c 7473 2066 726f 6d20 736f 6c76  esults from solv
-0000a970: 696e 6720 7468 6520 4669 7865 642d 4e4c  ing the Fixed-NL
-0000a980: 502e 0a20 2020 2020 2020 2022 2222 0a20  P..        """. 
-0000a990: 2020 2020 2020 2063 6f6e 6669 6720 3d20         config = 
-0000a9a0: 7365 6c66 2e63 6f6e 6669 670a 2020 2020  self.config.    
-0000a9b0: 2020 2020 4d69 6e64 7450 7920 3d20 7365      MindtPy = se
-0000a9c0: 6c66 2e66 6978 6564 5f6e 6c70 2e4d 696e  lf.fixed_nlp.Min
-0000a9d0: 6474 5079 5f75 7469 6c73 0a20 2020 2020  dtPy_utils.     
-0000a9e0: 2020 2073 656c 662e 6e6c 705f 6974 6572     self.nlp_iter
-0000a9f0: 202b 3d20 310a 0a20 2020 2020 2020 204d   += 1..        M
-0000aa00: 696e 6474 5079 2e63 7574 732e 6465 6163  indtPy.cuts.deac
-0000aa10: 7469 7661 7465 2829 0a20 2020 2020 2020  tivate().       
-0000aa20: 2069 6620 636f 6e66 6967 2e63 616c 6375   if config.calcu
-0000aa30: 6c61 7465 5f64 7561 6c5f 6174 5f73 6f6c  late_dual_at_sol
-0000aa40: 7574 696f 6e3a 0a20 2020 2020 2020 2020  ution:.         
-0000aa50: 2020 2073 656c 662e 6669 7865 645f 6e6c     self.fixed_nl
-0000aa60: 702e 746d 705f 6475 616c 7320 3d20 436f  p.tmp_duals = Co
-0000aa70: 6d70 6f6e 656e 744d 6170 2829 0a20 2020  mponentMap().   
-0000aa80: 2020 2020 2020 2020 2023 2074 6d70 5f64           # tmp_d
-0000aa90: 7561 6c73 2061 7265 2074 6865 2076 616c  uals are the val
-0000aaa0: 7565 206f 6620 7468 6520 6475 616c 2076  ue of the dual v
-0000aab0: 6172 6961 626c 6573 2073 746f 7265 6420  ariables stored 
-0000aac0: 6265 666f 7265 2075 7369 6e67 2064 6561  before using dea
-0000aad0: 6374 6976 6174 6520 7472 6976 6961 6c20  ctivate trivial 
-0000aae0: 636f 6e73 7472 6169 6e74 730a 2020 2020  constraints.    
-0000aaf0: 2020 2020 2020 2020 2320 5468 6520 7661          # The va
-0000ab00: 6c75 6573 206f 6620 7468 6520 6475 616c  lues of the dual
-0000ab10: 7320 6172 6520 636f 6d70 7574 6564 2061  s are computed a
-0000ab20: 7320 666f 6c6c 6f77 733a 2028 436f 6d70  s follows: (Comp
-0000ab30: 6c65 6d65 6e74 6172 7920 536c 6163 6b6e  lementary Slackn
-0000ab40: 6573 7329 0a20 2020 2020 2020 2020 2020  ess).           
-0000ab50: 2023 0a20 2020 2020 2020 2020 2020 2023   #.            #
-0000ab60: 207c 2063 6f6e 7374 7261 696e 7420 7c20   | constraint | 
-0000ab70: 635f 6765 7120 7c20 7374 6174 7573 2061  c_geq | status a
-0000ab80: 7420 7831 207c 2074 6d70 5f64 7561 6c20  t x1 | tmp_dual 
-0000ab90: 2876 696f 6c61 7469 6f6e 2920 7c0a 2020  (violation) |.  
-0000aba0: 2020 2020 2020 2020 2020 2320 7c2d 2d2d            # |---
-0000abb0: 2d2d 2d2d 2d2d 2d2d 2d7c 2d2d 2d2d 2d2d  ---------|------
-0000abc0: 2d7c 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  -|--------------
-0000abd0: 7c2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  |---------------
-0000abe0: 2d2d 2d2d 2d2d 2d7c 0a20 2020 2020 2020  -------|.       
-0000abf0: 2020 2020 2023 207c 2067 2878 2920 3c3d       # | g(x) <=
-0000ac00: 2062 2020 7c20 2d31 2020 2020 7c20 6728   b  | -1    | g(
-0000ac10: 7831 2920 3c3d 2062 2020 207c 2030 2020  x1) <= b   | 0  
-0000ac20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000ac30: 2020 7c0a 2020 2020 2020 2020 2020 2020    |.            
-0000ac40: 2320 7c20 6728 7829 203c 3d20 6220 207c  # | g(x) <= b  |
-0000ac50: 202d 3120 2020 207c 2067 2878 3129 203e   -1    | g(x1) >
-0000ac60: 2062 2020 2020 7c20 6728 7831 2920 2d20   b    | g(x1) - 
-0000ac70: 6220 2020 2020 2020 2020 2020 207c 0a20  b            |. 
-0000ac80: 2020 2020 2020 2020 2020 2023 207c 2067             # | g
-0000ac90: 2878 2920 3e3d 2062 2020 7c20 2b31 2020  (x) >= b  | +1  
-0000aca0: 2020 7c20 6728 7831 2920 3e3d 2062 2020    | g(x1) >= b  
-0000acb0: 207c 2030 2020 2020 2020 2020 2020 2020   | 0            
-0000acc0: 2020 2020 2020 2020 7c0a 2020 2020 2020          |.      
-0000acd0: 2020 2020 2020 2320 7c20 6728 7829 203e        # | g(x) >
-0000ace0: 3d20 6220 207c 202b 3120 2020 207c 2067  = b  | +1    | g
-0000acf0: 2878 3129 203c 2062 2020 2020 7c20 6220  (x1) < b    | b 
-0000ad00: 2d20 6728 7831 2920 2020 2020 2020 2020  - g(x1)         
-0000ad10: 2020 207c 0a20 2020 2020 2020 2020 2020     |.           
-0000ad20: 2065 7661 6c75 6174 696f 6e5f 6572 726f   evaluation_erro
-0000ad30: 7220 3d20 4661 6c73 650a 2020 2020 2020  r = False.      
-0000ad40: 2020 2020 2020 666f 7220 6320 696e 2073        for c in s
-0000ad50: 656c 662e 6669 7865 645f 6e6c 702e 4d69  elf.fixed_nlp.Mi
-0000ad60: 6e64 7450 795f 7574 696c 732e 636f 6e73  ndtPy_utils.cons
-0000ad70: 7472 6169 6e74 5f6c 6973 743a 0a20 2020  traint_list:.   
-0000ad80: 2020 2020 2020 2020 2020 2020 2023 2057               # W
-0000ad90: 6520 7072 6566 6572 2074 6f20 696e 636c  e prefer to incl
-0000ada0: 7564 6520 7468 6520 7570 7065 7220 626f  ude the upper bo
-0000adb0: 756e 6420 6173 2074 6865 2072 6967 6874  und as the right
-0000adc0: 2068 616e 6420 7369 6465 2073 696e 6365   hand side since
-0000add0: 2077 6520 6172 650a 2020 2020 2020 2020   we are.        
-0000ade0: 2020 2020 2020 2020 2320 636f 6e73 6964          # consid
-0000adf0: 6572 696e 6720 6320 6279 2064 6566 6175  ering c by defau
-0000ae00: 6c74 2061 2028 686f 7065 6675 6c6c 7929  lt a (hopefully)
-0000ae10: 2063 6f6e 7665 7820 6675 6e63 7469 6f6e   convex function
-0000ae20: 2c20 7768 6963 6820 776f 756c 6420 6d61  , which would ma
-0000ae30: 6b65 0a20 2020 2020 2020 2020 2020 2020  ke.             
-0000ae40: 2020 2023 2063 203e 3d20 6c62 2061 206e     # c >= lb a n
-0000ae50: 6f6e 636f 6e76 6578 2069 6e65 7175 616c  onconvex inequal
-0000ae60: 6974 7920 7768 6963 6820 7765 2077 6f75  ity which we wou
-0000ae70: 6c64 6e27 7420 6c69 6b65 2074 6f20 6164  ldn't like to ad
-0000ae80: 6420 6c69 6e65 6172 697a 6174 696f 6e73  d linearizations
-0000ae90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000aea0: 2023 2069 6620 7765 2064 6f6e 2774 2068   # if we don't h
-0000aeb0: 6176 6520 746f 0a20 2020 2020 2020 2020  ave to.         
-0000aec0: 2020 2020 2020 2072 6873 203d 2076 616c         rhs = val
-0000aed0: 7565 2863 2e75 7070 6572 2920 6966 2063  ue(c.upper) if c
-0000aee0: 2e68 6173 5f75 6228 2920 656c 7365 2076  .has_ub() else v
-0000aef0: 616c 7565 2863 2e6c 6f77 6572 290a 2020  alue(c.lower).  
-0000af00: 2020 2020 2020 2020 2020 2020 2020 635f                c_
-0000af10: 6765 7120 3d20 2d31 2069 6620 632e 6861  geq = -1 if c.ha
-0000af20: 735f 7562 2829 2065 6c73 6520 310a 2020  s_ub() else 1.  
-0000af30: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-0000af40: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-0000af50: 2020 2020 2020 2073 656c 662e 6669 7865         self.fixe
-0000af60: 645f 6e6c 702e 746d 705f 6475 616c 735b  d_nlp.tmp_duals[
-0000af70: 635d 203d 2063 5f67 6571 202a 206d 6178  c] = c_geq * max
-0000af80: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000af90: 2020 2020 2020 2020 2020 302c 2063 5f67            0, c_g
-0000afa0: 6571 202a 2028 7268 7320 2d20 7661 6c75  eq * (rhs - valu
-0000afb0: 6528 632e 626f 6479 2929 0a20 2020 2020  e(c.body)).     
-0000afc0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0000afd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000afe0: 2065 7863 6570 7420 2856 616c 7565 4572   except (ValueEr
-0000aff0: 726f 722c 204f 7665 7266 6c6f 7745 7272  ror, OverflowErr
-0000b000: 6f72 2920 6173 2065 3a0a 2020 2020 2020  or) as e:.      
-0000b010: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000b020: 6e66 6967 2e6c 6f67 6765 722e 6572 726f  nfig.logger.erro
-0000b030: 7228 652c 2065 7863 5f69 6e66 6f3d 5472  r(e, exc_info=Tr
-0000b040: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
-0000b050: 2020 2020 2020 2020 7365 6c66 2e66 6978          self.fix
-0000b060: 6564 5f6e 6c70 2e74 6d70 5f64 7561 6c73  ed_nlp.tmp_duals
-0000b070: 5b63 5d20 3d20 4e6f 6e65 0a20 2020 2020  [c] = None.     
-0000b080: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0000b090: 7661 6c75 6174 696f 6e5f 6572 726f 7220  valuation_error 
-0000b0a0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
-0000b0b0: 2020 2069 6620 6576 616c 7561 7469 6f6e     if evaluation
-0000b0c0: 5f65 7272 6f72 3a0a 2020 2020 2020 2020  _error:.        
-0000b0d0: 2020 2020 2020 2020 666f 7220 6e6c 705f          for nlp_
-0000b0e0: 7661 722c 206f 7269 675f 7661 6c20 696e  var, orig_val in
-0000b0f0: 207a 6970 280a 2020 2020 2020 2020 2020   zip(.          
-0000b100: 2020 2020 2020 2020 2020 4d69 6e64 7450            MindtP
-0000b110: 792e 7661 7269 6162 6c65 5f6c 6973 742c  y.variable_list,
-0000b120: 2073 656c 662e 696e 6974 6961 6c5f 7661   self.initial_va
-0000b130: 725f 7661 6c75 6573 0a20 2020 2020 2020  r_values.       
-0000b140: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
-0000b150: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b160: 6966 206e 6f74 206e 6c70 5f76 6172 2e66  if not nlp_var.f
-0000b170: 6978 6564 2061 6e64 206e 6f74 206e 6c70  ixed and not nlp
-0000b180: 5f76 6172 2e69 735f 6269 6e61 7279 2829  _var.is_binary()
-0000b190: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000b1a0: 2020 2020 2020 2020 2020 6e6c 705f 7661            nlp_va
-0000b1b0: 722e 7365 745f 7661 6c75 6528 6f72 6967  r.set_value(orig
-0000b1c0: 5f76 616c 2c20 736b 6970 5f76 616c 6964  _val, skip_valid
-0000b1d0: 6174 696f 6e3d 5472 7565 290a 2020 2020  ation=True).    
-0000b1e0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-0000b1f0: 2020 2020 2054 7261 6e73 666f 726d 6174       Transformat
-0000b200: 696f 6e46 6163 746f 7279 2827 636f 6e74  ionFactory('cont
-0000b210: 7269 622e 6465 6163 7469 7661 7465 5f74  rib.deactivate_t
-0000b220: 7269 7669 616c 5f63 6f6e 7374 7261 696e  rivial_constrain
-0000b230: 7473 2729 2e61 7070 6c79 5f74 6f28 0a20  ts').apply_to(. 
-0000b240: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000b250: 656c 662e 6669 7865 645f 6e6c 702c 0a20  elf.fixed_nlp,. 
-0000b260: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000b270: 6d70 3d54 7275 652c 0a20 2020 2020 2020  mp=True,.       
-0000b280: 2020 2020 2020 2020 2069 676e 6f72 655f           ignore_
-0000b290: 696e 6665 6173 6962 6c65 3d46 616c 7365  infeasible=False
-0000b2a0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000b2b0: 2020 746f 6c65 7261 6e63 653d 636f 6e66    tolerance=conf
-0000b2c0: 6967 2e63 6f6e 7374 7261 696e 745f 746f  ig.constraint_to
-0000b2d0: 6c65 7261 6e63 652c 0a20 2020 2020 2020  lerance,.       
-0000b2e0: 2020 2020 2029 0a20 2020 2020 2020 2065       ).        e
-0000b2f0: 7863 6570 7420 496e 6665 6173 6962 6c65  xcept Infeasible
-0000b300: 436f 6e73 7472 6169 6e74 4578 6365 7074  ConstraintExcept
-0000b310: 696f 6e20 6173 2065 3a0a 2020 2020 2020  ion as e:.      
-0000b320: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
-0000b330: 6765 722e 6572 726f 7228 652c 2065 7863  ger.error(e, exc
-0000b340: 5f69 6e66 6f3d 5472 7565 290a 2020 2020  _info=True).    
-0000b350: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
-0000b360: 6f67 6765 722e 6572 726f 7228 0a20 2020  ogger.error(.   
-0000b370: 2020 2020 2020 2020 2020 2020 2027 496e               'In
-0000b380: 6665 6173 6962 696c 6974 7920 6465 7465  feasibility dete
-0000b390: 6374 6564 2069 6e20 6465 6163 7469 7661  cted in deactiva
-0000b3a0: 7465 5f74 7269 7669 616c 5f63 6f6e 7374  te_trivial_const
-0000b3b0: 7261 696e 7473 2e27 0a20 2020 2020 2020  raints.'.       
-0000b3c0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0000b3d0: 2020 2072 6573 756c 7473 203d 2053 6f6c     results = Sol
-0000b3e0: 7665 7252 6573 756c 7473 2829 0a20 2020  verResults().   
-0000b3f0: 2020 2020 2020 2020 2072 6573 756c 7473           results
-0000b400: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-0000b410: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
-0000b420: 7463 2e69 6e66 6561 7369 626c 650a 2020  tc.infeasible.  
-0000b430: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000b440: 2073 656c 662e 6669 7865 645f 6e6c 702c   self.fixed_nlp,
-0000b450: 2072 6573 756c 7473 0a20 2020 2020 2020   results.       
-0000b460: 2023 2053 6f6c 7665 2074 6865 204e 4c50   # Solve the NLP
-0000b470: 0a20 2020 2020 2020 206e 6c70 5f61 7267  .        nlp_arg
-0000b480: 7320 3d20 6469 6374 2863 6f6e 6669 672e  s = dict(config.
-0000b490: 6e6c 705f 736f 6c76 6572 5f61 7267 7329  nlp_solver_args)
-0000b4a0: 0a20 2020 2020 2020 2075 7064 6174 655f  .        update_
-0000b4b0: 736f 6c76 6572 5f74 696d 656c 696d 6974  solver_timelimit
-0000b4c0: 2873 656c 662e 6e6c 705f 6f70 742c 2063  (self.nlp_opt, c
-0000b4d0: 6f6e 6669 672e 6e6c 705f 736f 6c76 6572  onfig.nlp_solver
-0000b4e0: 2c20 7365 6c66 2e74 696d 696e 672c 2063  , self.timing, c
-0000b4f0: 6f6e 6669 6729 0a20 2020 2020 2020 2077  onfig).        w
-0000b500: 6974 6820 5375 7070 7265 7373 496e 6665  ith SuppressInfe
-0000b510: 6173 6962 6c65 5761 726e 696e 6728 293a  asibleWarning():
-0000b520: 0a20 2020 2020 2020 2020 2020 2077 6974  .            wit
-0000b530: 6820 7469 6d65 5f63 6f64 6528 7365 6c66  h time_code(self
-0000b540: 2e74 696d 696e 672c 2027 6669 7865 6420  .timing, 'fixed 
-0000b550: 7375 6270 726f 626c 656d 2729 3a0a 2020  subproblem'):.  
-0000b560: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0000b570: 7375 6c74 7320 3d20 7365 6c66 2e6e 6c70  sults = self.nlp
-0000b580: 5f6f 7074 2e73 6f6c 7665 280a 2020 2020  _opt.solve(.    
-0000b590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5a0: 7365 6c66 2e66 6978 6564 5f6e 6c70 2c0a  self.fixed_nlp,.
-0000b5b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5c0: 2020 2020 7465 653d 636f 6e66 6967 2e6e      tee=config.n
-0000b5d0: 6c70 5f73 6f6c 7665 725f 7465 652c 0a20  lp_solver_tee,. 
-0000b5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b5f0: 2020 206c 6f61 645f 736f 6c75 7469 6f6e     load_solution
-0000b600: 733d 7365 6c66 2e6c 6f61 645f 736f 6c75  s=self.load_solu
-0000b610: 7469 6f6e 732c 0a20 2020 2020 2020 2020  tions,.         
-0000b620: 2020 2020 2020 2020 2020 202a 2a6e 6c70             **nlp
-0000b630: 5f61 7267 732c 0a20 2020 2020 2020 2020  _args,.         
-0000b640: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-0000b650: 2020 2020 2020 2020 2069 6620 6c65 6e28           if len(
-0000b660: 7265 7375 6c74 732e 736f 6c75 7469 6f6e  results.solution
-0000b670: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
-0000b680: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000b690: 6669 7865 645f 6e6c 702e 736f 6c75 7469  fixed_nlp.soluti
-0000b6a0: 6f6e 732e 6c6f 6164 5f66 726f 6d28 7265  ons.load_from(re
-0000b6b0: 7375 6c74 7329 0a20 2020 2020 2020 2054  sults).        T
-0000b6c0: 7261 6e73 666f 726d 6174 696f 6e46 6163  ransformationFac
-0000b6d0: 746f 7279 2827 636f 6e74 7269 622e 6465  tory('contrib.de
-0000b6e0: 6163 7469 7661 7465 5f74 7269 7669 616c  activate_trivial
-0000b6f0: 5f63 6f6e 7374 7261 696e 7473 2729 2e72  _constraints').r
-0000b700: 6576 6572 7428 0a20 2020 2020 2020 2020  evert(.         
-0000b710: 2020 2073 656c 662e 6669 7865 645f 6e6c     self.fixed_nl
-0000b720: 700a 2020 2020 2020 2020 290a 2020 2020  p.        ).    
-0000b730: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
-0000b740: 6669 7865 645f 6e6c 702c 2072 6573 756c  fixed_nlp, resul
-0000b750: 7473 0a0a 2020 2020 6465 6620 6861 6e64  ts..    def hand
-0000b760: 6c65 5f6e 6c70 5f73 7562 7072 6f62 6c65  le_nlp_subproble
-0000b770: 6d5f 7463 2873 656c 662c 2066 6978 6564  m_tc(self, fixed
-0000b780: 5f6e 6c70 2c20 7265 7375 6c74 2c20 6362  _nlp, result, cb
-0000b790: 5f6f 7074 3d4e 6f6e 6529 3a0a 2020 2020  _opt=None):.    
-0000b7a0: 2020 2020 2222 2254 6869 7320 6675 6e63      """This func
-0000b7b0: 7469 6f6e 2068 616e 646c 6573 2064 6966  tion handles dif
-0000b7c0: 6665 7265 6e74 2074 6572 6d69 6e61 746f  ferent terminato
-0000b7d0: 6e20 636f 6e64 6974 696f 6e73 206f 6620  n conditions of 
-0000b7e0: 7468 6520 6669 7865 642d 4e4c 5020 7375  the fixed-NLP su
-0000b7f0: 6270 726f 626c 656d 2e0a 0a20 2020 2020  bproblem...     
-0000b800: 2020 2050 6172 616d 6574 6572 730a 2020     Parameters.  
-0000b810: 2020 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d        ----------
-0000b820: 0a20 2020 2020 2020 2066 6978 6564 5f6e  .        fixed_n
-0000b830: 6c70 203a 2050 796f 6d6f 206d 6f64 656c  lp : Pyomo model
-0000b840: 0a20 2020 2020 2020 2020 2020 2049 6e74  .            Int
-0000b850: 6567 6572 2d76 6172 6961 626c 652d 6669  eger-variable-fi
-0000b860: 7865 6420 4e4c 5020 6d6f 6465 6c2e 0a20  xed NLP model.. 
-0000b870: 2020 2020 2020 2072 6573 756c 7420 3a20         result : 
-0000b880: 536f 6c76 6572 5265 7375 6c74 730a 2020  SolverResults.  
-0000b890: 2020 2020 2020 2020 2020 5265 7375 6c74            Result
-0000b8a0: 7320 6672 6f6d 2073 6f6c 7669 6e67 2074  s from solving t
-0000b8b0: 6865 204e 4c50 2073 7562 7072 6f62 6c65  he NLP subproble
-0000b8c0: 6d2e 0a20 2020 2020 2020 2063 625f 6f70  m..        cb_op
-0000b8d0: 7420 3a20 536f 6c76 6572 4661 6374 6f72  t : SolverFactor
-0000b8e0: 792c 206f 7074 696f 6e61 6c0a 2020 2020  y, optional.    
-0000b8f0: 2020 2020 2020 2020 5468 6520 6775 726f          The guro
-0000b900: 6269 5f70 6572 7369 7374 656e 7420 736f  bi_persistent so
-0000b910: 6c76 6572 2c20 6279 2064 6566 6175 6c74  lver, by default
-0000b920: 204e 6f6e 652e 0a20 2020 2020 2020 2022   None..        "
-0000b930: 2222 0a20 2020 2020 2020 2069 6620 7265  "".        if re
-0000b940: 7375 6c74 2e73 6f6c 7665 722e 7465 726d  sult.solver.term
-0000b950: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
-0000b960: 6e20 696e 207b 0a20 2020 2020 2020 2020  n in {.         
-0000b970: 2020 2074 632e 6f70 7469 6d61 6c2c 0a20     tc.optimal,. 
-0000b980: 2020 2020 2020 2020 2020 2074 632e 6c6f             tc.lo
-0000b990: 6361 6c6c 794f 7074 696d 616c 2c0a 2020  callyOptimal,.  
-0000b9a0: 2020 2020 2020 2020 2020 7463 2e66 6561            tc.fea
-0000b9b0: 7369 626c 652c 0a20 2020 2020 2020 207d  sible,.        }
-0000b9c0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
-0000b9d0: 6c66 2e68 616e 646c 655f 7375 6270 726f  lf.handle_subpro
-0000b9e0: 626c 656d 5f6f 7074 696d 616c 2866 6978  blem_optimal(fix
-0000b9f0: 6564 5f6e 6c70 2c20 6362 5f6f 7074 290a  ed_nlp, cb_opt).
-0000ba00: 2020 2020 2020 2020 656c 6966 2072 6573          elif res
-0000ba10: 756c 742e 736f 6c76 6572 2e74 6572 6d69  ult.solver.termi
-0000ba20: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
-0000ba30: 2069 6e20 7b74 632e 696e 6665 6173 6962   in {tc.infeasib
-0000ba40: 6c65 2c20 7463 2e6e 6f53 6f6c 7574 696f  le, tc.noSolutio
-0000ba50: 6e7d 3a0a 2020 2020 2020 2020 2020 2020  n}:.            
-0000ba60: 7365 6c66 2e68 616e 646c 655f 7375 6270  self.handle_subp
-0000ba70: 726f 626c 656d 5f69 6e66 6561 7369 626c  roblem_infeasibl
-0000ba80: 6528 6669 7865 645f 6e6c 702c 2063 625f  e(fixed_nlp, cb_
-0000ba90: 6f70 7429 0a20 2020 2020 2020 2065 6c69  opt).        eli
-0000baa0: 6620 7265 7375 6c74 2e73 6f6c 7665 722e  f result.solver.
-0000bab0: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
-0000bac0: 6974 696f 6e20 6973 2074 632e 6d61 7854  ition is tc.maxT
-0000bad0: 696d 654c 696d 6974 3a0a 2020 2020 2020  imeLimit:.      
-0000bae0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
-0000baf0: 672e 6c6f 6767 6572 2e69 6e66 6f28 0a20  g.logger.info(. 
-0000bb00: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000bb10: 4e4c 5020 7375 6270 726f 626c 656d 2066  NLP subproblem f
-0000bb20: 6169 6c65 6420 746f 2063 6f6e 7665 7267  ailed to converg
-0000bb30: 6520 7769 7468 696e 2074 6865 2074 696d  e within the tim
-0000bb40: 6520 6c69 6d69 742e 270a 2020 2020 2020  e limit.'.      
-0000bb50: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0000bb60: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
-0000bb70: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-0000bb80: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
-0000bb90: 7463 2e6d 6178 5469 6d65 4c69 6d69 740a  tc.maxTimeLimit.
-0000bba0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000bbb0: 2e73 686f 756c 645f 7465 726d 696e 6174  .should_terminat
-0000bbc0: 6520 3d20 5472 7565 0a20 2020 2020 2020  e = True.       
-0000bbd0: 2065 6c69 6620 7265 7375 6c74 2e73 6f6c   elif result.sol
-0000bbe0: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-0000bbf0: 636f 6e64 6974 696f 6e20 6973 2074 632e  condition is tc.
-0000bc00: 6d61 7845 7661 6c75 6174 696f 6e73 3a0a  maxEvaluations:.
-0000bc10: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000bc20: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e69  .config.logger.i
-0000bc30: 6e66 6f28 274e 4c50 2073 7562 7072 6f62  nfo('NLP subprob
-0000bc40: 6c65 6d20 6661 696c 6564 2064 7565 2074  lem failed due t
-0000bc50: 6f20 6d61 7845 7661 6c75 6174 696f 6e73  o maxEvaluations
-0000bc60: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
-0000bc70: 7365 6c66 2e72 6573 756c 7473 2e73 6f6c  self.results.sol
-0000bc80: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-0000bc90: 636f 6e64 6974 696f 6e20 3d20 7463 2e6d  condition = tc.m
-0000bca0: 6178 4576 616c 7561 7469 6f6e 730a 2020  axEvaluations.  
-0000bcb0: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
-0000bcc0: 686f 756c 645f 7465 726d 696e 6174 6520  hould_terminate 
-0000bcd0: 3d20 5472 7565 0a20 2020 2020 2020 2065  = True.        e
-0000bce0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000bcf0: 2073 656c 662e 6861 6e64 6c65 5f73 7562   self.handle_sub
-0000bd00: 7072 6f62 6c65 6d5f 6f74 6865 725f 7465  problem_other_te
-0000bd10: 726d 696e 6174 696f 6e28 0a20 2020 2020  rmination(.     
-0000bd20: 2020 2020 2020 2020 2020 2066 6978 6564             fixed
-0000bd30: 5f6e 6c70 2c20 7265 7375 6c74 2e73 6f6c  _nlp, result.sol
-0000bd40: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-0000bd50: 636f 6e64 6974 696f 6e2c 2063 625f 6f70  condition, cb_op
-0000bd60: 740a 2020 2020 2020 2020 2020 2020 290a  t.            ).
-0000bd70: 0a20 2020 2064 6566 2068 616e 646c 655f  .    def handle_
-0000bd80: 7375 6270 726f 626c 656d 5f6f 7074 696d  subproblem_optim
-0000bd90: 616c 2873 656c 662c 2066 6978 6564 5f6e  al(self, fixed_n
-0000bda0: 6c70 2c20 6362 5f6f 7074 3d4e 6f6e 652c  lp, cb_opt=None,
-0000bdb0: 2066 703d 4661 6c73 6529 3a0a 2020 2020   fp=False):.    
-0000bdc0: 2020 2020 2222 2254 6869 7320 6675 6e63      """This func
-0000bdd0: 7469 6f6e 2063 6f70 6965 7320 7468 6520  tion copies the 
-0000bde0: 7265 7375 6c74 206f 6620 7468 6520 4e4c  result of the NL
-0000bdf0: 5020 736f 6c76 6572 2066 756e 6374 696f  P solver functio
-0000be00: 6e20 2827 736f 6c76 655f 7375 6270 726f  n ('solve_subpro
-0000be10: 626c 656d 2729 2074 6f20 7468 6520 776f  blem') to the wo
-0000be20: 726b 696e 6720 6d6f 6465 6c2c 2075 7064  rking model, upd
-0000be30: 6174 6573 0a20 2020 2020 2020 2074 6865  ates.        the
-0000be40: 2062 6f75 6e64 732c 2061 6464 7320 4f41   bounds, adds OA
-0000be50: 2061 6e64 206e 6f2d 676f 6f64 2063 7574   and no-good cut
-0000be60: 732c 2061 6e64 2074 6865 6e20 7374 6f72  s, and then stor
-0000be70: 6573 2074 6865 206e 6577 2073 6f6c 7574  es the new solut
-0000be80: 696f 6e20 6966 2069 7420 6973 2074 6865  ion if it is the
-0000be90: 206e 6577 2062 6573 7420 736f 6c75 7469   new best soluti
-0000bea0: 6f6e 2e20 5468 6973 0a20 2020 2020 2020  on. This.       
-0000beb0: 2066 756e 6374 696f 6e20 6861 6e64 6c65   function handle
-0000bec0: 7320 7468 6520 7265 7375 6c74 206f 6620  s the result of 
-0000bed0: 7468 6520 6c61 7465 7374 2069 7465 7261  the latest itera
-0000bee0: 7469 6f6e 206f 6620 736f 6c76 696e 6720  tion of solving 
-0000bef0: 7468 6520 4e4c 5020 7375 6270 726f 626c  the NLP subprobl
-0000bf00: 656d 2067 6976 656e 2061 6e20 6f70 7469  em given an opti
-0000bf10: 6d61 6c20 736f 6c75 7469 6f6e 2e0a 0a20  mal solution... 
-0000bf20: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-0000bf30: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
-0000bf40: 2d2d 2d2d 0a20 2020 2020 2020 2066 6978  ----.        fix
-0000bf50: 6564 5f6e 6c70 203a 2050 796f 6d6f 206d  ed_nlp : Pyomo m
-0000bf60: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
-0000bf70: 2049 6e74 6567 6572 2d76 6172 6961 626c   Integer-variabl
-0000bf80: 652d 6669 7865 6420 4e4c 5020 6d6f 6465  e-fixed NLP mode
-0000bf90: 6c2e 0a20 2020 2020 2020 2063 625f 6f70  l..        cb_op
-0000bfa0: 7420 3a20 536f 6c76 6572 4661 6374 6f72  t : SolverFactor
-0000bfb0: 792c 206f 7074 696f 6e61 6c0a 2020 2020  y, optional.    
-0000bfc0: 2020 2020 2020 2020 5468 6520 6775 726f          The guro
-0000bfd0: 6269 5f70 6572 7369 7374 656e 7420 736f  bi_persistent so
-0000bfe0: 6c76 6572 2c20 6279 2064 6566 6175 6c74  lver, by default
-0000bff0: 204e 6f6e 652e 0a20 2020 2020 2020 2066   None..        f
-0000c000: 7020 3a20 626f 6f6c 2c20 6f70 7469 6f6e  p : bool, option
-0000c010: 616c 0a20 2020 2020 2020 2020 2020 2057  al.            W
-0000c020: 6865 7468 6572 2069 7420 6973 2069 6e20  hether it is in 
-0000c030: 7468 6520 6c6f 6f70 206f 6620 6665 6173  the loop of feas
-0000c040: 6962 696c 6974 7920 7075 6d70 2c20 6279  ibility pump, by
-0000c050: 2064 6566 6175 6c74 2046 616c 7365 2e0a   default False..
-0000c060: 2020 2020 2020 2020 2222 220a 2020 2020          """.    
-0000c070: 2020 2020 2320 544f 444f 3a20 6368 6563      # TODO: chec
-0000c080: 6b20 7768 6174 2069 7320 7468 6973 2063  k what is this c
-0000c090: 6f70 795f 7661 6c75 6520 6675 6e63 7469  opy_value functi
-0000c0a0: 6f6e 2075 7365 6420 666f 723f 0a20 2020  on used for?.   
-0000c0b0: 2020 2020 2023 2057 6172 6d73 7461 7274       # Warmstart
-0000c0c0: 3f0a 2020 2020 2020 2020 636f 6e66 6967  ?.        config
-0000c0d0: 203d 2073 656c 662e 636f 6e66 6967 0a20   = self.config. 
-0000c0e0: 2020 2020 2020 2063 6f70 795f 7661 725f         copy_var_
-0000c0f0: 6c69 7374 5f76 616c 7565 7328 0a20 2020  list_values(.   
-0000c100: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
-0000c110: 6c70 2e4d 696e 6474 5079 5f75 7469 6c73  lp.MindtPy_utils
-0000c120: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
-0000c130: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000c140: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2e4d  .working_model.M
-0000c150: 696e 6474 5079 5f75 7469 6c73 2e76 6172  indtPy_utils.var
-0000c160: 6961 626c 655f 6c69 7374 2c0a 2020 2020  iable_list,.    
-0000c170: 2020 2020 2020 2020 636f 6e66 6967 2c0a          config,.
-0000c180: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0000c190: 2020 6966 2063 6f6e 6669 672e 6361 6c63    if config.calc
-0000c1a0: 756c 6174 655f 6475 616c 5f61 745f 736f  ulate_dual_at_so
-0000c1b0: 6c75 7469 6f6e 3a0a 2020 2020 2020 2020  lution:.        
-0000c1c0: 2020 2020 666f 7220 6320 696e 2066 6978      for c in fix
-0000c1d0: 6564 5f6e 6c70 2e74 6d70 5f64 7561 6c73  ed_nlp.tmp_duals
-0000c1e0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000c1f0: 2020 6966 2066 6978 6564 5f6e 6c70 2e64    if fixed_nlp.d
-0000c200: 7561 6c2e 6765 7428 632c 204e 6f6e 6529  ual.get(c, None)
-0000c210: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
-0000c220: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000c230: 7865 645f 6e6c 702e 6475 616c 5b63 5d20  xed_nlp.dual[c] 
-0000c240: 3d20 6669 7865 645f 6e6c 702e 746d 705f  = fixed_nlp.tmp_
-0000c250: 6475 616c 735b 635d 0a20 2020 2020 2020  duals[c].       
-0000c260: 2020 2020 2020 2020 2065 6c69 6620 280a           elif (.
-0000c270: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c280: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
-0000c290: 6e6c 705f 736f 6c76 6572 203d 3d20 2763  nlp_solver == 'c
-0000c2a0: 7969 706f 7074 270a 2020 2020 2020 2020  yipopt'.        
-0000c2b0: 2020 2020 2020 2020 2020 2020 616e 6420              and 
-0000c2c0: 7365 6c66 2e6f 626a 6563 7469 7665 5f73  self.objective_s
-0000c2d0: 656e 7365 203d 3d20 6d69 6e69 6d69 7a65  ense == minimize
-0000c2e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c2f0: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
-0000c300: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
-0000c310: 7265 636f 7665 7220 7468 6520 6f70 706f  recover the oppo
-0000c320: 7369 7465 2064 7561 6c20 7768 656e 2063  site dual when c
-0000c330: 7969 706f 7074 2069 7373 7565 2023 3238  yipopt issue #28
-0000c340: 3331 2069 7320 736f 6c76 6564 2e0a 2020  31 is solved..  
-0000c350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c360: 2020 6669 7865 645f 6e6c 702e 6475 616c    fixed_nlp.dual
-0000c370: 5b63 5d20 3d20 2d66 6978 6564 5f6e 6c70  [c] = -fixed_nlp
-0000c380: 2e64 7561 6c5b 635d 0a20 2020 2020 2020  .dual[c].       
-0000c390: 2020 2020 2064 7561 6c5f 7661 6c75 6573       dual_values
-0000c3a0: 203d 206c 6973 7428 0a20 2020 2020 2020   = list(.       
-0000c3b0: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
-0000c3c0: 6c70 2e64 7561 6c5b 635d 2066 6f72 2063  lp.dual[c] for c
-0000c3d0: 2069 6e20 6669 7865 645f 6e6c 702e 4d69   in fixed_nlp.Mi
-0000c3e0: 6e64 7450 795f 7574 696c 732e 636f 6e73  ndtPy_utils.cons
-0000c3f0: 7472 6169 6e74 5f6c 6973 740a 2020 2020  traint_list.    
-0000c400: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0000c410: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000c420: 2020 2020 6475 616c 5f76 616c 7565 7320      dual_values 
-0000c430: 3d20 4e6f 6e65 0a20 2020 2020 2020 206d  = None.        m
-0000c440: 6169 6e5f 6f62 6a65 6374 6976 6520 3d20  ain_objective = 
-0000c450: 6669 7865 645f 6e6c 702e 4d69 6e64 7450  fixed_nlp.MindtP
-0000c460: 795f 7574 696c 732e 6f62 6a65 6374 6976  y_utils.objectiv
-0000c470: 655f 6c69 7374 5b2d 315d 0a20 2020 2020  e_list[-1].     
-0000c480: 2020 2073 656c 662e 7570 6461 7465 5f70     self.update_p
-0000c490: 7269 6d61 6c5f 626f 756e 6428 7661 6c75  rimal_bound(valu
-0000c4a0: 6528 6d61 696e 5f6f 626a 6563 7469 7665  e(main_objective
-0000c4b0: 2e65 7870 7229 290a 2020 2020 2020 2020  .expr)).        
-0000c4c0: 6966 2073 656c 662e 7072 696d 616c 5f62  if self.primal_b
-0000c4d0: 6f75 6e64 5f69 6d70 726f 7665 643a 0a20  ound_improved:. 
-0000c4e0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000c4f0: 6265 7374 5f73 6f6c 7574 696f 6e5f 666f  best_solution_fo
-0000c500: 756e 6420 3d20 6669 7865 645f 6e6c 702e  und = fixed_nlp.
-0000c510: 636c 6f6e 6528 290a 2020 2020 2020 2020  clone().        
-0000c520: 2020 2020 7365 6c66 2e62 6573 745f 736f      self.best_so
-0000c530: 6c75 7469 6f6e 5f66 6f75 6e64 5f74 696d  lution_found_tim
-0000c540: 6520 3d20 6765 745f 6d61 696e 5f65 6c61  e = get_main_ela
-0000c550: 7073 6564 5f74 696d 6528 7365 6c66 2e74  psed_time(self.t
-0000c560: 696d 696e 6729 0a20 2020 2020 2020 2023  iming).        #
-0000c570: 2041 6464 2074 6865 206c 696e 6561 7220   Add the linear 
-0000c580: 6375 740a 2020 2020 2020 2020 636f 7079  cut.        copy
-0000c590: 5f76 6172 5f6c 6973 745f 7661 6c75 6573  _var_list_values
-0000c5a0: 280a 2020 2020 2020 2020 2020 2020 6669  (.            fi
-0000c5b0: 7865 645f 6e6c 702e 4d69 6e64 7450 795f  xed_nlp.MindtPy_
-0000c5c0: 7574 696c 732e 7661 7269 6162 6c65 5f6c  utils.variable_l
-0000c5d0: 6973 742c 0a20 2020 2020 2020 2020 2020  ist,.           
-0000c5e0: 2073 656c 662e 6d69 702e 4d69 6e64 7450   self.mip.MindtP
-0000c5f0: 795f 7574 696c 732e 7661 7269 6162 6c65  y_utils.variable
-0000c600: 5f6c 6973 742c 0a20 2020 2020 2020 2020  _list,.         
-0000c610: 2020 2063 6f6e 6669 672c 0a20 2020 2020     config,.     
-0000c620: 2020 2029 0a20 2020 2020 2020 2073 656c     ).        sel
-0000c630: 662e 6164 645f 6375 7473 280a 2020 2020  f.add_cuts(.    
-0000c640: 2020 2020 2020 2020 6475 616c 5f76 616c          dual_val
-0000c650: 7565 733d 6475 616c 5f76 616c 7565 732c  ues=dual_values,
-0000c660: 0a20 2020 2020 2020 2020 2020 206c 696e  .            lin
-0000c670: 6561 7269 7a65 5f61 6374 6976 653d 5472  earize_active=Tr
-0000c680: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
-0000c690: 6c69 6e65 6172 697a 655f 7669 6f6c 6174  linearize_violat
-0000c6a0: 6564 3d54 7275 652c 0a20 2020 2020 2020  ed=True,.       
-0000c6b0: 2020 2020 2063 625f 6f70 743d 6362 5f6f       cb_opt=cb_o
-0000c6c0: 7074 2c0a 2020 2020 2020 2020 2020 2020  pt,.            
-0000c6d0: 6e6c 703d 7365 6c66 2e66 6978 6564 5f6e  nlp=self.fixed_n
-0000c6e0: 6c70 2c0a 2020 2020 2020 2020 290a 0a20  lp,.        ).. 
-0000c6f0: 2020 2020 2020 2076 6172 5f76 616c 7565         var_value
-0000c700: 7320 3d20 6c69 7374 2876 2e76 616c 7565  s = list(v.value
-0000c710: 2066 6f72 2076 2069 6e20 6669 7865 645f   for v in fixed_
-0000c720: 6e6c 702e 4d69 6e64 7450 795f 7574 696c  nlp.MindtPy_util
-0000c730: 732e 7661 7269 6162 6c65 5f6c 6973 7429  s.variable_list)
-0000c740: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
-0000c750: 6967 2e61 6464 5f6e 6f5f 676f 6f64 5f63  ig.add_no_good_c
-0000c760: 7574 733a 0a20 2020 2020 2020 2020 2020  uts:.           
-0000c770: 2061 6464 5f6e 6f5f 676f 6f64 5f63 7574   add_no_good_cut
-0000c780: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
-0000c790: 2020 2073 656c 662e 6d69 702c 2076 6172     self.mip, var
-0000c7a0: 5f76 616c 7565 732c 2063 6f6e 6669 672c  _values, config,
-0000c7b0: 2073 656c 662e 7469 6d69 6e67 2c20 7365   self.timing, se
-0000c7c0: 6c66 2e6d 6970 5f69 7465 722c 2063 625f  lf.mip_iter, cb_
-0000c7d0: 6f70 740a 2020 2020 2020 2020 2020 2020  opt.            
-0000c7e0: 290a 0a20 2020 2020 2020 2063 6f6e 6669  )..        confi
-0000c7f0: 672e 6361 6c6c 5f61 6674 6572 5f73 7562  g.call_after_sub
-0000c800: 7072 6f62 6c65 6d5f 6665 6173 6962 6c65  problem_feasible
-0000c810: 2866 6978 6564 5f6e 6c70 290a 0a20 2020  (fixed_nlp)..   
-0000c820: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-0000c830: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
-0000c840: 2020 2020 2073 656c 662e 6669 7865 645f       self.fixed_
-0000c850: 6e6c 705f 6c6f 675f 666f 726d 6174 7465  nlp_log_formatte
-0000c860: 722e 666f 726d 6174 280a 2020 2020 2020  r.format(.      
-0000c870: 2020 2020 2020 2020 2020 272a 2720 6966            '*' if
-0000c880: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
-0000c890: 6e64 5f69 6d70 726f 7665 6420 656c 7365  nd_improved else
-0000c8a0: 2027 2027 2c0a 2020 2020 2020 2020 2020   ' ',.          
-0000c8b0: 2020 2020 2020 7365 6c66 2e6e 6c70 5f69        self.nlp_i
-0000c8c0: 7465 7220 6966 206e 6f74 2066 7020 656c  ter if not fp el
-0000c8d0: 7365 2073 656c 662e 6670 5f69 7465 722c  se self.fp_iter,
-0000c8e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c8f0: 2027 4669 7865 6420 4e4c 5027 2c0a 2020   'Fixed NLP',.  
-0000c900: 2020 2020 2020 2020 2020 2020 2020 7661                va
-0000c910: 6c75 6528 6d61 696e 5f6f 626a 6563 7469  lue(main_objecti
-0000c920: 7665 2e65 7870 7229 2c0a 2020 2020 2020  ve.expr),.      
-0000c930: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
-0000c940: 7269 6d61 6c5f 626f 756e 642c 0a20 2020  rimal_bound,.   
-0000c950: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000c960: 662e 6475 616c 5f62 6f75 6e64 2c0a 2020  f.dual_bound,.  
-0000c970: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000c980: 6c66 2e72 656c 5f67 6170 2c0a 2020 2020  lf.rel_gap,.    
-0000c990: 2020 2020 2020 2020 2020 2020 6765 745f              get_
-0000c9a0: 6d61 696e 5f65 6c61 7073 6564 5f74 696d  main_elapsed_tim
-0000c9b0: 6528 7365 6c66 2e74 696d 696e 6729 2c0a  e(self.timing),.
-0000c9c0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0000c9d0: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
-0000c9e0: 2068 616e 646c 655f 7375 6270 726f 626c   handle_subprobl
-0000c9f0: 656d 5f69 6e66 6561 7369 626c 6528 7365  em_infeasible(se
-0000ca00: 6c66 2c20 6669 7865 645f 6e6c 702c 2063  lf, fixed_nlp, c
-0000ca10: 625f 6f70 743d 4e6f 6e65 293a 0a20 2020  b_opt=None):.   
-0000ca20: 2020 2020 2022 2222 536f 6c76 6573 2066       """Solves f
-0000ca30: 6561 7369 6269 6c69 7479 2070 726f 626c  easibility probl
-0000ca40: 656d 2061 6e64 2061 6464 7320 6375 7420  em and adds cut 
-0000ca50: 6163 636f 7264 696e 6720 746f 2074 6865  according to the
-0000ca60: 2073 7065 6369 6669 6564 2073 7472 6174   specified strat
-0000ca70: 6567 792e 0a0a 2020 2020 2020 2020 5468  egy...        Th
-0000ca80: 6973 2066 756e 6374 696f 6e20 6861 6e64  is function hand
-0000ca90: 6c65 7320 7468 6520 7265 7375 6c74 206f  les the result o
-0000caa0: 6620 7468 6520 6c61 7465 7374 2069 7465  f the latest ite
-0000cab0: 7261 7469 6f6e 206f 6620 736f 6c76 696e  ration of solvin
-0000cac0: 6720 7468 6520 4e4c 5020 7375 6270 726f  g the NLP subpro
-0000cad0: 626c 656d 2067 6976 656e 2061 6e20 696e  blem given an in
-0000cae0: 6665 6173 6962 6c65 0a20 2020 2020 2020  feasible.       
-0000caf0: 2073 6f6c 7574 696f 6e20 616e 6420 636f   solution and co
-0000cb00: 7069 6573 2074 6865 2073 6f6c 7574 696f  pies the solutio
-0000cb10: 6e20 6f66 2074 6865 2066 6561 7369 6269  n of the feasibi
-0000cb20: 6c69 7479 2070 726f 626c 656d 2074 6f20  lity problem to 
-0000cb30: 7468 6520 776f 726b 696e 6720 6d6f 6465  the working mode
-0000cb40: 6c2e 0a0a 2020 2020 2020 2020 5061 7261  l...        Para
-0000cb50: 6d65 7465 7273 0a20 2020 2020 2020 202d  meters.        -
-0000cb60: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
-0000cb70: 2020 6669 7865 645f 6e6c 7020 3a20 5079    fixed_nlp : Py
-0000cb80: 6f6d 6f20 6d6f 6465 6c0a 2020 2020 2020  omo model.      
-0000cb90: 2020 2020 2020 496e 7465 6765 722d 7661        Integer-va
-0000cba0: 7269 6162 6c65 2d66 6978 6564 204e 4c50  riable-fixed NLP
-0000cbb0: 206d 6f64 656c 2e0a 2020 2020 2020 2020   model..        
-0000cbc0: 6362 5f6f 7074 203a 2053 6f6c 7665 7246  cb_opt : SolverF
-0000cbd0: 6163 746f 7279 2c20 6f70 7469 6f6e 616c  actory, optional
-0000cbe0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-0000cbf0: 2067 7572 6f62 695f 7065 7273 6973 7465   gurobi_persiste
-0000cc00: 6e74 2073 6f6c 7665 722c 2062 7920 6465  nt solver, by de
-0000cc10: 6661 756c 7420 4e6f 6e65 2e0a 2020 2020  fault None..    
-0000cc20: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000cc30: 2320 544f 444f 2074 7279 2073 6f6d 6574  # TODO try somet
-0000cc40: 6869 6e67 2065 6c73 653f 2052 6569 6e69  hing else? Reini
-0000cc50: 7469 616c 697a 6520 7769 7468 2064 6966  tialize with dif
-0000cc60: 6665 7265 6e74 2069 6e69 7469 616c 0a20  ferent initial. 
-0000cc70: 2020 2020 2020 2023 2076 616c 7565 3f0a         # value?.
-0000cc80: 2020 2020 2020 2020 636f 6e66 6967 203d          config =
-0000cc90: 2073 656c 662e 636f 6e66 6967 0a20 2020   self.config.   
-0000cca0: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-0000ccb0: 6572 2e69 6e66 6f28 0a20 2020 2020 2020  er.info(.       
-0000ccc0: 2020 2020 2073 656c 662e 696e 6665 6173       self.infeas
-0000ccd0: 6962 6c65 5f66 6978 6564 5f6e 6c70 5f6c  ible_fixed_nlp_l
-0000cce0: 6f67 5f66 6f72 6d61 7474 6572 2e66 6f72  og_formatter.for
-0000ccf0: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-0000cd00: 2020 2020 2027 2027 2c0a 2020 2020 2020       ' ',.      
-0000cd10: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
-0000cd20: 6c70 5f69 7465 722c 0a20 2020 2020 2020  lp_iter,.       
-0000cd30: 2020 2020 2020 2020 2027 4669 7865 6420           'Fixed 
-0000cd40: 4e4c 5027 2c0a 2020 2020 2020 2020 2020  NLP',.          
-0000cd50: 2020 2020 2020 2749 6e66 6561 7369 626c        'Infeasibl
-0000cd60: 6527 2c0a 2020 2020 2020 2020 2020 2020  e',.            
-0000cd70: 2020 2020 7365 6c66 2e70 7269 6d61 6c5f      self.primal_
-0000cd80: 626f 756e 642c 0a20 2020 2020 2020 2020  bound,.         
-0000cd90: 2020 2020 2020 2073 656c 662e 6475 616c         self.dual
-0000cda0: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
-0000cdb0: 2020 2020 2020 2020 7365 6c66 2e72 656c          self.rel
-0000cdc0: 5f67 6170 2c0a 2020 2020 2020 2020 2020  _gap,.          
-0000cdd0: 2020 2020 2020 6765 745f 6d61 696e 5f65        get_main_e
-0000cde0: 6c61 7073 6564 5f74 696d 6528 7365 6c66  lapsed_time(self
-0000cdf0: 2e74 696d 696e 6729 2c0a 2020 2020 2020  .timing),.      
-0000ce00: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0000ce10: 290a 2020 2020 2020 2020 7365 6c66 2e6e  ).        self.n
-0000ce20: 6c70 5f69 6e66 6561 7369 626c 655f 636f  lp_infeasible_co
-0000ce30: 756e 7465 7220 2b3d 2031 0a20 2020 2020  unter += 1.     
-0000ce40: 2020 2069 6620 636f 6e66 6967 2e63 616c     if config.cal
-0000ce50: 6375 6c61 7465 5f64 7561 6c5f 6174 5f73  culate_dual_at_s
-0000ce60: 6f6c 7574 696f 6e3a 0a20 2020 2020 2020  olution:.       
-0000ce70: 2020 2020 2066 6f72 2063 2069 6e20 6669       for c in fi
-0000ce80: 7865 645f 6e6c 702e 4d69 6e64 7450 795f  xed_nlp.MindtPy_
-0000ce90: 7574 696c 732e 636f 6e73 7472 6169 6e74  utils.constraint
-0000cea0: 5f6c 6973 743a 0a20 2020 2020 2020 2020  _list:.         
-0000ceb0: 2020 2020 2020 2072 6873 203d 2076 616c         rhs = val
-0000cec0: 7565 2863 2e75 7070 6572 2920 6966 2063  ue(c.upper) if c
-0000ced0: 2e68 6173 5f75 6228 2920 656c 7365 2076  .has_ub() else v
-0000cee0: 616c 7565 2863 2e6c 6f77 6572 290a 2020  alue(c.lower).  
-0000cef0: 2020 2020 2020 2020 2020 2020 2020 635f                c_
-0000cf00: 6765 7120 3d20 2d31 2069 6620 632e 6861  geq = -1 if c.ha
-0000cf10: 735f 7562 2829 2065 6c73 6520 310a 2020  s_ub() else 1.  
-0000cf20: 2020 2020 2020 2020 2020 2020 2020 6669                fi
-0000cf30: 7865 645f 6e6c 702e 6475 616c 5b63 5d20  xed_nlp.dual[c] 
-0000cf40: 3d20 635f 6765 7120 2a20 6d61 7828 302c  = c_geq * max(0,
-0000cf50: 2063 5f67 6571 202a 2028 7268 7320 2d20   c_geq * (rhs - 
-0000cf60: 7661 6c75 6528 632e 626f 6479 2929 290a  value(c.body))).
-0000cf70: 2020 2020 2020 2020 2020 2020 6475 616c              dual
-0000cf80: 5f76 616c 7565 7320 3d20 6c69 7374 280a  _values = list(.
-0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfa0: 6669 7865 645f 6e6c 702e 6475 616c 5b63  fixed_nlp.dual[c
-0000cfb0: 5d20 666f 7220 6320 696e 2066 6978 6564  ] for c in fixed
-0000cfc0: 5f6e 6c70 2e4d 696e 6474 5079 5f75 7469  _nlp.MindtPy_uti
-0000cfd0: 6c73 2e63 6f6e 7374 7261 696e 745f 6c69  ls.constraint_li
-0000cfe0: 7374 0a20 2020 2020 2020 2020 2020 2029  st.            )
-0000cff0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-0000d000: 2020 2020 2020 2020 2020 2064 7561 6c5f             dual_
-0000d010: 7661 6c75 6573 203d 204e 6f6e 650a 0a20  values = None.. 
-0000d020: 2020 2020 2020 2023 2069 6620 636f 6e66         # if conf
-0000d030: 6967 2e73 7472 6174 6567 7920 3d3d 2027  ig.strategy == '
-0000d040: 5053 4327 206f 7220 636f 6e66 6967 2e73  PSC' or config.s
-0000d050: 7472 6174 6567 7920 3d3d 2027 4742 4427  trategy == 'GBD'
-0000d060: 3a0a 2020 2020 2020 2020 2320 2020 2020  :.        #     
-0000d070: 666f 7220 7661 7220 696e 2066 6978 6564  for var in fixed
-0000d080: 5f6e 6c70 2e63 6f6d 706f 6e65 6e74 5f64  _nlp.component_d
-0000d090: 6174 615f 6f62 6a65 6374 7328 6374 7970  ata_objects(ctyp
-0000d0a0: 653d 5661 722c 2064 6573 6365 6e64 5f69  e=Var, descend_i
-0000d0b0: 6e74 6f3d 5472 7565 293a 0a20 2020 2020  nto=True):.     
-0000d0c0: 2020 2023 2020 2020 2020 2020 2066 6978     #         fix
-0000d0d0: 6564 5f6e 6c70 2e69 706f 7074 5f7a 4c5f  ed_nlp.ipopt_zL_
-0000d0e0: 6f75 745b 7661 725d 203d 2030 0a20 2020  out[var] = 0.   
-0000d0f0: 2020 2020 2023 2020 2020 2020 2020 2066       #         f
-0000d100: 6978 6564 5f6e 6c70 2e69 706f 7074 5f7a  ixed_nlp.ipopt_z
-0000d110: 555f 6f75 745b 7661 725d 203d 2030 0a20  U_out[var] = 0. 
-0000d120: 2020 2020 2020 2023 2020 2020 2020 2020         #        
-0000d130: 2069 6620 7661 722e 6861 735f 7562 2829   if var.has_ub()
-0000d140: 2061 6e64 2061 6273 2876 6172 2e75 6220   and abs(var.ub 
-0000d150: 2d20 7661 6c75 6528 7661 7229 2920 3c20  - value(var)) < 
-0000d160: 636f 6e66 6967 2e61 6273 6f6c 7574 655f  config.absolute_
-0000d170: 626f 756e 645f 746f 6c65 7261 6e63 653a  bound_tolerance:
-0000d180: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
-0000d190: 2020 2020 2020 2066 6978 6564 5f6e 6c70         fixed_nlp
-0000d1a0: 2e69 706f 7074 5f7a 4c5f 6f75 745b 7661  .ipopt_zL_out[va
-0000d1b0: 725d 203d 2031 0a20 2020 2020 2020 2023  r] = 1.        #
-0000d1c0: 2020 2020 2020 2020 2065 6c69 6620 7661           elif va
-0000d1d0: 722e 6861 735f 6c62 2829 2061 6e64 2061  r.has_lb() and a
-0000d1e0: 6273 2876 616c 7565 2876 6172 2920 2d20  bs(value(var) - 
-0000d1f0: 7661 722e 6c62 2920 3c20 636f 6e66 6967  var.lb) < config
-0000d200: 2e61 6273 6f6c 7574 655f 626f 756e 645f  .absolute_bound_
-0000d210: 746f 6c65 7261 6e63 653a 0a20 2020 2020  tolerance:.     
-0000d220: 2020 2023 2020 2020 2020 2020 2020 2020     #            
-0000d230: 2066 6978 6564 5f6e 6c70 2e69 706f 7074   fixed_nlp.ipopt
-0000d240: 5f7a 555f 6f75 745b 7661 725d 203d 202d  _zU_out[var] = -
-0000d250: 310a 0a20 2020 2020 2020 2066 6561 735f  1..        feas_
-0000d260: 7375 6270 726f 626c 656d 2c20 6665 6173  subproblem, feas
-0000d270: 5f73 7562 7072 6f62 6c65 6d5f 7265 7375  _subproblem_resu
-0000d280: 6c74 7320 3d20 7365 6c66 2e73 6f6c 7665  lts = self.solve
-0000d290: 5f66 6561 7369 6269 6c69 7479 5f73 7562  _feasibility_sub
-0000d2a0: 7072 6f62 6c65 6d28 290a 2020 2020 2020  problem().      
-0000d2b0: 2020 2320 544f 444f 3a20 646f 2077 6520    # TODO: do we 
-0000d2c0: 7265 616c 6c79 206e 6565 6420 7468 6973  really need this
-0000d2d0: 3f0a 2020 2020 2020 2020 6966 2073 656c  ?.        if sel
-0000d2e0: 662e 7368 6f75 6c64 5f74 6572 6d69 6e61  f.should_termina
-0000d2f0: 7465 3a0a 2020 2020 2020 2020 2020 2020  te:.            
-0000d300: 7265 7475 726e 0a20 2020 2020 2020 2063  return.        c
-0000d310: 6f70 795f 7661 725f 6c69 7374 5f76 616c  opy_var_list_val
-0000d320: 7565 7328 0a20 2020 2020 2020 2020 2020  ues(.           
-0000d330: 2066 6561 735f 7375 6270 726f 626c 656d   feas_subproblem
-0000d340: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-0000d350: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-0000d360: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
-0000d370: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
-0000d380: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
-0000d390: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-0000d3a0: 6967 2c0a 2020 2020 2020 2020 290a 2020  ig,.        ).  
-0000d3b0: 2020 2020 2020 7365 6c66 2e61 6464 5f63        self.add_c
-0000d3c0: 7574 7328 0a20 2020 2020 2020 2020 2020  uts(.           
-0000d3d0: 2064 7561 6c5f 7661 6c75 6573 3d64 7561   dual_values=dua
-0000d3e0: 6c5f 7661 6c75 6573 2c0a 2020 2020 2020  l_values,.      
-0000d3f0: 2020 2020 2020 6c69 6e65 6172 697a 655f        linearize_
-0000d400: 6163 7469 7665 3d54 7275 652c 0a20 2020  active=True,.   
-0000d410: 2020 2020 2020 2020 206c 696e 6561 7269           lineari
-0000d420: 7a65 5f76 696f 6c61 7465 643d 5472 7565  ze_violated=True
-0000d430: 2c0a 2020 2020 2020 2020 2020 2020 6362  ,.            cb
-0000d440: 5f6f 7074 3d63 625f 6f70 742c 0a20 2020  _opt=cb_opt,.   
-0000d450: 2020 2020 2020 2020 206e 6c70 3d66 6561           nlp=fea
-0000d460: 735f 7375 6270 726f 626c 656d 2c0a 2020  s_subproblem,.  
-0000d470: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0000d480: 2320 4164 6420 6120 6e6f 2d67 6f6f 6420  # Add a no-good 
-0000d490: 6375 7420 746f 2065 7863 6c75 6465 2074  cut to exclude t
-0000d4a0: 6869 7320 6469 7363 7265 7465 206f 7074  his discrete opt
-0000d4b0: 696f 6e0a 2020 2020 2020 2020 7661 725f  ion.        var_
-0000d4c0: 7661 6c75 6573 203d 206c 6973 7428 762e  values = list(v.
-0000d4d0: 7661 6c75 6520 666f 7220 7620 696e 2066  value for v in f
-0000d4e0: 6978 6564 5f6e 6c70 2e4d 696e 6474 5079  ixed_nlp.MindtPy
-0000d4f0: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
-0000d500: 6c69 7374 290a 2020 2020 2020 2020 6966  list).        if
-0000d510: 2063 6f6e 6669 672e 6164 645f 6e6f 5f67   config.add_no_g
-0000d520: 6f6f 645f 6375 7473 3a0a 2020 2020 2020  ood_cuts:.      
-0000d530: 2020 2020 2020 2320 6578 636c 7564 6573        # excludes
-0000d540: 2063 7572 7265 6e74 2064 6973 6372 6574   current discret
-0000d550: 6520 6f70 7469 6f6e 0a20 2020 2020 2020  e option.       
-0000d560: 2020 2020 2061 6464 5f6e 6f5f 676f 6f64       add_no_good
-0000d570: 5f63 7574 7328 0a20 2020 2020 2020 2020  _cuts(.         
-0000d580: 2020 2020 2020 2073 656c 662e 6d69 702c         self.mip,
-0000d590: 2076 6172 5f76 616c 7565 732c 2063 6f6e   var_values, con
-0000d5a0: 6669 672c 2073 656c 662e 7469 6d69 6e67  fig, self.timing
-0000d5b0: 2c20 7365 6c66 2e6d 6970 5f69 7465 722c  , self.mip_iter,
-0000d5c0: 2063 625f 6f70 740a 2020 2020 2020 2020   cb_opt.        
-0000d5d0: 2020 2020 290a 0a20 2020 2064 6566 2068      )..    def h
-0000d5e0: 616e 646c 655f 7375 6270 726f 626c 656d  andle_subproblem
-0000d5f0: 5f6f 7468 6572 5f74 6572 6d69 6e61 7469  _other_terminati
-0000d600: 6f6e 280a 2020 2020 2020 2020 7365 6c66  on(.        self
-0000d610: 2c20 6669 7865 645f 6e6c 702c 2074 6572  , fixed_nlp, ter
-0000d620: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
-0000d630: 6f6e 2c20 6362 5f6f 7074 3d4e 6f6e 650a  on, cb_opt=None.
-0000d640: 2020 2020 293a 0a20 2020 2020 2020 2022      ):.        "
-0000d650: 2222 4861 6e64 6c65 7320 7468 6520 7265  ""Handles the re
-0000d660: 7375 6c74 206f 6620 7468 6520 6c61 7465  sult of the late
-0000d670: 7374 2069 7465 7261 7469 6f6e 206f 6620  st iteration of 
-0000d680: 736f 6c76 696e 6720 7468 6520 6669 7865  solving the fixe
-0000d690: 6420 4e4c 5020 7375 6270 726f 626c 656d  d NLP subproblem
-0000d6a0: 2067 6976 656e 0a20 2020 2020 2020 2061   given.        a
-0000d6b0: 2073 6f6c 7574 696f 6e20 7468 6174 2069   solution that i
-0000d6c0: 7320 6e65 6974 6865 7220 6f70 7469 6d61  s neither optima
-0000d6d0: 6c20 6e6f 7220 696e 6665 6173 6962 6c65  l nor infeasible
-0000d6e0: 2e0a 0a20 2020 2020 2020 2050 6172 616d  ...        Param
-0000d6f0: 6574 6572 730a 2020 2020 2020 2020 2d2d  eters.        --
-0000d700: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020 2020  --------.       
-0000d710: 2066 6978 6564 5f6e 6c70 203a 2050 796f   fixed_nlp : Pyo
-0000d720: 6d6f 206d 6f64 656c 0a20 2020 2020 2020  mo model.       
-0000d730: 2020 2020 2049 6e74 6567 6572 2d76 6172       Integer-var
-0000d740: 6961 626c 652d 6669 7865 6420 4e4c 5020  iable-fixed NLP 
-0000d750: 6d6f 6465 6c2e 0a20 2020 2020 2020 2074  model..        t
-0000d760: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-0000d770: 7469 6f6e 203a 2050 796f 6d6f 2054 6572  tion : Pyomo Ter
-0000d780: 6d69 6e61 7469 6f6e 436f 6e64 6974 696f  minationConditio
-0000d790: 6e0a 2020 2020 2020 2020 2020 2020 5468  n.            Th
-0000d7a0: 6520 7465 726d 696e 6174 696f 6e20 636f  e termination co
-0000d7b0: 6e64 6974 696f 6e20 6f66 2074 6865 2066  ndition of the f
-0000d7c0: 6978 6564 204e 4c50 2073 7562 7072 6f62  ixed NLP subprob
-0000d7d0: 6c65 6d2e 0a20 2020 2020 2020 2063 625f  lem..        cb_
-0000d7e0: 6f70 7420 3a20 536f 6c76 6572 4661 6374  opt : SolverFact
-0000d7f0: 6f72 792c 206f 7074 696f 6e61 6c0a 2020  ory, optional.  
-0000d800: 2020 2020 2020 2020 2020 5468 6520 6775            The gu
-0000d810: 726f 6269 5f70 6572 7369 7374 656e 7420  robi_persistent 
-0000d820: 736f 6c76 6572 2c20 6279 2064 6566 6175  solver, by defau
-0000d830: 6c74 204e 6f6e 652e 0a0a 2020 2020 2020  lt None...      
-0000d840: 2020 5261 6973 6573 0a20 2020 2020 2020    Raises.       
-0000d850: 202d 2d2d 2d2d 2d0a 2020 2020 2020 2020   ------.        
-0000d860: 5661 6c75 6545 7272 6f72 0a20 2020 2020  ValueError.     
-0000d870: 2020 2020 2020 204d 696e 6474 5079 2075         MindtPy u
-0000d880: 6e61 626c 6520 746f 2068 616e 646c 6520  nable to handle 
-0000d890: 7468 6520 4e4c 5020 7375 6270 726f 626c  the NLP subprobl
-0000d8a0: 656d 2074 6572 6d69 6e61 7469 6f6e 2063  em termination c
-0000d8b0: 6f6e 6469 7469 6f6e 2e0a 2020 2020 2020  ondition..      
-0000d8c0: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-0000d8d0: 2074 6572 6d69 6e61 7469 6f6e 5f63 6f6e   termination_con
-0000d8e0: 6469 7469 6f6e 2069 7320 7463 2e6d 6178  dition is tc.max
-0000d8f0: 4974 6572 6174 696f 6e73 3a0a 2020 2020  Iterations:.    
-0000d900: 2020 2020 2020 2020 2320 544f 444f 2074          # TODO t
-0000d910: 7279 2073 6f6d 6574 6869 6e67 2065 6c73  ry something els
-0000d920: 653f 2052 6569 6e69 7469 616c 697a 6520  e? Reinitialize 
-0000d930: 7769 7468 2064 6966 6665 7265 6e74 2069  with different i
-0000d940: 6e69 7469 616c 2076 616c 7565 3f0a 2020  nitial value?.  
-0000d950: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-0000d960: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
-0000d970: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
-0000d980: 2020 2027 4e4c 5020 7375 6270 726f 626c     'NLP subprobl
-0000d990: 656d 2066 6169 6c65 6420 746f 2063 6f6e  em failed to con
-0000d9a0: 7665 7267 6520 7769 7468 696e 2069 7465  verge within ite
-0000d9b0: 7261 7469 6f6e 206c 696d 6974 2e27 0a20  ration limit.'. 
-0000d9c0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-0000d9d0: 2020 2020 2020 2020 2076 6172 5f76 616c           var_val
-0000d9e0: 7565 7320 3d20 6c69 7374 2876 2e76 616c  ues = list(v.val
-0000d9f0: 7565 2066 6f72 2076 2069 6e20 6669 7865  ue for v in fixe
-0000da00: 645f 6e6c 702e 4d69 6e64 7450 795f 7574  d_nlp.MindtPy_ut
-0000da10: 696c 732e 7661 7269 6162 6c65 5f6c 6973  ils.variable_lis
-0000da20: 7429 0a20 2020 2020 2020 2020 2020 2069  t).            i
-0000da30: 6620 7365 6c66 2e63 6f6e 6669 672e 6164  f self.config.ad
-0000da40: 645f 6e6f 5f67 6f6f 645f 6375 7473 3a0a  d_no_good_cuts:.
-0000da50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000da60: 2320 6578 636c 7564 6573 2063 7572 7265  # excludes curre
-0000da70: 6e74 2064 6973 6372 6574 6520 6f70 7469  nt discrete opti
-0000da80: 6f6e 0a20 2020 2020 2020 2020 2020 2020  on.             
-0000da90: 2020 2061 6464 5f6e 6f5f 676f 6f64 5f63     add_no_good_c
-0000daa0: 7574 7328 0a20 2020 2020 2020 2020 2020  uts(.           
-0000dab0: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-0000dac0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-0000dad0: 2020 2020 2020 2076 6172 5f76 616c 7565         var_value
-0000dae0: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
-0000daf0: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
-0000db00: 6967 2c0a 2020 2020 2020 2020 2020 2020  ig,.            
-0000db10: 2020 2020 2020 2020 7365 6c66 2e74 696d          self.tim
-0000db20: 696e 672c 0a20 2020 2020 2020 2020 2020  ing,.           
-0000db30: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-0000db40: 705f 6974 6572 2c0a 2020 2020 2020 2020  p_iter,.        
-0000db50: 2020 2020 2020 2020 2020 2020 6362 5f6f              cb_o
-0000db60: 7074 2c0a 2020 2020 2020 2020 2020 2020  pt,.            
-0000db70: 2020 2020 290a 0a20 2020 2020 2020 2065      )..        e
-0000db80: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000db90: 2072 6169 7365 2056 616c 7565 4572 726f   raise ValueErro
-0000dba0: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
-0000dbb0: 2020 2027 4d69 6e64 7450 7920 756e 6162     'MindtPy unab
-0000dbc0: 6c65 2074 6f20 6861 6e64 6c65 204e 4c50  le to handle NLP
-0000dbd0: 2073 7562 7072 6f62 6c65 6d20 7465 726d   subproblem term
-0000dbe0: 696e 6174 696f 6e20 270a 2020 2020 2020  ination '.      
-0000dbf0: 2020 2020 2020 2020 2020 2763 6f6e 6469            'condi
-0000dc00: 7469 6f6e 206f 6620 7b7d 272e 666f 726d  tion of {}'.form
-0000dc10: 6174 2874 6572 6d69 6e61 7469 6f6e 5f63  at(termination_c
-0000dc20: 6f6e 6469 7469 6f6e 290a 2020 2020 2020  ondition).      
-0000dc30: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
-0000dc40: 2073 6f6c 7665 5f66 6561 7369 6269 6c69   solve_feasibili
-0000dc50: 7479 5f73 7562 7072 6f62 6c65 6d28 7365  ty_subproblem(se
-0000dc60: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-0000dc70: 536f 6c76 6573 2061 2066 6561 7369 6269  Solves a feasibi
-0000dc80: 6c69 7479 204e 4c50 2069 6620 7468 6520  lity NLP if the 
-0000dc90: 6669 7865 645f 6e6c 7020 7072 6f62 6c65  fixed_nlp proble
-0000dca0: 6d20 6973 2069 6e66 6561 7369 626c 652e  m is infeasible.
-0000dcb0: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
-0000dcc0: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
-0000dcd0: 2d0a 2020 2020 2020 2020 6665 6173 5f73  -.        feas_s
-0000dce0: 7562 7072 6f62 6c65 6d20 3a20 5079 6f6d  ubproblem : Pyom
-0000dcf0: 6f20 6d6f 6465 6c0a 2020 2020 2020 2020  o model.        
-0000dd00: 2020 2020 4665 6173 6962 696c 6974 7920      Feasibility 
-0000dd10: 4e4c 5020 6672 6f6d 2074 6865 206d 6f64  NLP from the mod
-0000dd20: 656c 2e0a 2020 2020 2020 2020 6665 6173  el..        feas
-0000dd30: 5f73 6f6c 6e20 3a20 536f 6c76 6572 5265  _soln : SolverRe
-0000dd40: 7375 6c74 730a 2020 2020 2020 2020 2020  sults.          
-0000dd50: 2020 5265 7375 6c74 7320 6672 6f6d 2073    Results from s
-0000dd60: 6f6c 7669 6e67 2074 6865 2066 6561 7369  olving the feasi
-0000dd70: 6269 6c69 7479 204e 4c50 2e0a 2020 2020  bility NLP..    
-0000dd80: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
-0000dd90: 636f 6e66 6967 203d 2073 656c 662e 636f  config = self.co
-0000dda0: 6e66 6967 0a20 2020 2020 2020 2066 6561  nfig.        fea
-0000ddb0: 735f 7375 6270 726f 626c 656d 203d 2073  s_subproblem = s
-0000ddc0: 656c 662e 6669 7865 645f 6e6c 700a 2020  elf.fixed_nlp.  
-0000ddd0: 2020 2020 2020 4d69 6e64 7450 7920 3d20        MindtPy = 
-0000dde0: 6665 6173 5f73 7562 7072 6f62 6c65 6d2e  feas_subproblem.
-0000ddf0: 4d69 6e64 7450 795f 7574 696c 730a 2020  MindtPy_utils.  
-0000de00: 2020 2020 2020 4d69 6e64 7450 792e 6665        MindtPy.fe
-0000de10: 6173 5f6f 7074 2e61 6374 6976 6174 6528  as_opt.activate(
-0000de20: 290a 2020 2020 2020 2020 6966 204d 696e  ).        if Min
-0000de30: 6474 5079 2e63 6f6d 706f 6e65 6e74 2827  dtPy.component('
-0000de40: 6f62 6a65 6374 6976 655f 7661 6c75 6527  objective_value'
-0000de50: 2920 6973 206e 6f74 204e 6f6e 653a 0a20  ) is not None:. 
-0000de60: 2020 2020 2020 2020 2020 204d 696e 6474             Mindt
-0000de70: 5079 2e6f 626a 6563 7469 7665 5f76 616c  Py.objective_val
-0000de80: 7565 5b3a 5d2e 7365 745f 7661 6c75 6528  ue[:].set_value(
-0000de90: 302c 2073 6b69 705f 7661 6c69 6461 7469  0, skip_validati
-0000dea0: 6f6e 3d54 7275 6529 0a0a 2020 2020 2020  on=True)..      
-0000deb0: 2020 6163 7469 7665 5f6f 626a 203d 206e    active_obj = n
-0000dec0: 6578 7428 0a20 2020 2020 2020 2020 2020  ext(.           
-0000ded0: 2066 6561 735f 7375 6270 726f 626c 656d   feas_subproblem
-0000dee0: 2e63 6f6d 706f 6e65 6e74 5f64 6174 615f  .component_data_
-0000def0: 6f62 6a65 6374 7328 4f62 6a65 6374 6976  objects(Objectiv
-0000df00: 652c 2061 6374 6976 653d 5472 7565 290a  e, active=True).
-0000df10: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0000df20: 2020 6163 7469 7665 5f6f 626a 2e64 6561    active_obj.dea
-0000df30: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
-0000df40: 2020 666f 7220 636f 6e73 7472 2069 6e20    for constr in 
-0000df50: 4d69 6e64 7450 792e 6e6f 6e6c 696e 6561  MindtPy.nonlinea
-0000df60: 725f 636f 6e73 7472 6169 6e74 5f6c 6973  r_constraint_lis
-0000df70: 743a 0a20 2020 2020 2020 2020 2020 2063  t:.            c
-0000df80: 6f6e 7374 722e 6465 6163 7469 7661 7465  onstr.deactivate
-0000df90: 2829 0a0a 2020 2020 2020 2020 4d69 6e64  ()..        Mind
-0000dfa0: 7450 792e 6665 6173 5f6f 7074 2e61 6374  tPy.feas_opt.act
-0000dfb0: 6976 6174 6528 290a 2020 2020 2020 2020  ivate().        
-0000dfc0: 4d69 6e64 7450 792e 6665 6173 5f6f 626a  MindtPy.feas_obj
-0000dfd0: 2e61 6374 6976 6174 6528 290a 2020 2020  .activate().    
-0000dfe0: 2020 2020 6e6c 705f 6172 6773 203d 2064      nlp_args = d
-0000dff0: 6963 7428 636f 6e66 6967 2e6e 6c70 5f73  ict(config.nlp_s
-0000e000: 6f6c 7665 725f 6172 6773 290a 2020 2020  olver_args).    
-0000e010: 2020 2020 7570 6461 7465 5f73 6f6c 7665      update_solve
-0000e020: 725f 7469 6d65 6c69 6d69 7428 0a20 2020  r_timelimit(.   
-0000e030: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
-0000e040: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
-0000e050: 742c 2063 6f6e 6669 672e 6e6c 705f 736f  t, config.nlp_so
-0000e060: 6c76 6572 2c20 7365 6c66 2e74 696d 696e  lver, self.timin
-0000e070: 672c 2063 6f6e 6669 670a 2020 2020 2020  g, config.      
-0000e080: 2020 290a 2020 2020 2020 2020 5472 616e    ).        Tran
-0000e090: 7366 6f72 6d61 7469 6f6e 4661 6374 6f72  sformationFactor
-0000e0a0: 7928 2763 6f6e 7472 6962 2e64 6561 6374  y('contrib.deact
-0000e0b0: 6976 6174 655f 7472 6976 6961 6c5f 636f  ivate_trivial_co
-0000e0c0: 6e73 7472 6169 6e74 7327 292e 6170 706c  nstraints').appl
-0000e0d0: 795f 746f 280a 2020 2020 2020 2020 2020  y_to(.          
-0000e0e0: 2020 6665 6173 5f73 7562 7072 6f62 6c65    feas_subproble
-0000e0f0: 6d2c 0a20 2020 2020 2020 2020 2020 2074  m,.            t
-0000e100: 6d70 3d54 7275 652c 0a20 2020 2020 2020  mp=True,.       
-0000e110: 2020 2020 2069 676e 6f72 655f 696e 6665       ignore_infe
-0000e120: 6173 6962 6c65 3d46 616c 7365 2c0a 2020  asible=False,.  
-0000e130: 2020 2020 2020 2020 2020 746f 6c65 7261            tolera
-0000e140: 6e63 653d 636f 6e66 6967 2e63 6f6e 7374  nce=config.const
-0000e150: 7261 696e 745f 746f 6c65 7261 6e63 652c  raint_tolerance,
-0000e160: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-0000e170: 2020 2077 6974 6820 5375 7070 7265 7373     with Suppress
-0000e180: 496e 6665 6173 6962 6c65 5761 726e 696e  InfeasibleWarnin
-0000e190: 6728 293a 0a20 2020 2020 2020 2020 2020  g():.           
-0000e1a0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
-0000e1b0: 2020 2020 2020 7769 7468 2074 696d 655f        with time_
-0000e1c0: 636f 6465 2873 656c 662e 7469 6d69 6e67  code(self.timing
-0000e1d0: 2c20 2766 6561 7369 6269 6c69 7479 2073  , 'feasibility s
-0000e1e0: 7562 7072 6f62 6c65 6d27 293a 0a20 2020  ubproblem'):.   
-0000e1f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e200: 2066 6561 735f 736f 6c6e 203d 2073 656c   feas_soln = sel
-0000e210: 662e 6665 6173 6962 696c 6974 795f 6e6c  f.feasibility_nl
-0000e220: 705f 6f70 742e 736f 6c76 6528 0a20 2020  p_opt.solve(.   
-0000e230: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e240: 2020 2020 2066 6561 735f 7375 6270 726f       feas_subpro
-0000e250: 626c 656d 2c0a 2020 2020 2020 2020 2020  blem,.          
-0000e260: 2020 2020 2020 2020 2020 2020 2020 7465                te
-0000e270: 653d 636f 6e66 6967 2e6e 6c70 5f73 6f6c  e=config.nlp_sol
-0000e280: 7665 725f 7465 652c 0a20 2020 2020 2020  ver_tee,.       
-0000e290: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e2a0: 206c 6f61 645f 736f 6c75 7469 6f6e 733d   load_solutions=
-0000e2b0: 636f 6e66 6967 2e6e 6c70 5f73 6f6c 7665  config.nlp_solve
-0000e2c0: 7220 213d 2027 6170 7073 695f 6970 6f70  r != 'appsi_ipop
-0000e2d0: 7427 2c0a 2020 2020 2020 2020 2020 2020  t',.            
-0000e2e0: 2020 2020 2020 2020 2020 2020 2a2a 6e6c              **nl
-0000e2f0: 705f 6172 6773 2c0a 2020 2020 2020 2020  p_args,.        
-0000e300: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0000e310: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e320: 2020 6966 206c 656e 2866 6561 735f 736f    if len(feas_so
-0000e330: 6c6e 2e73 6f6c 7574 696f 6e29 203e 2030  ln.solution) > 0
-0000e340: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000e350: 2020 2020 2020 2020 2020 6665 6173 5f73            feas_s
-0000e360: 7562 7072 6f62 6c65 6d2e 736f 6c75 7469  ubproblem.soluti
-0000e370: 6f6e 732e 6c6f 6164 5f66 726f 6d28 6665  ons.load_from(fe
-0000e380: 6173 5f73 6f6c 6e29 0a20 2020 2020 2020  as_soln).       
-0000e390: 2020 2020 2065 7863 6570 7420 2856 616c       except (Val
-0000e3a0: 7565 4572 726f 722c 204f 7665 7266 6c6f  ueError, Overflo
-0000e3b0: 7745 7272 6f72 2920 6173 2065 3a0a 2020  wError) as e:.  
-0000e3c0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0000e3d0: 6e66 6967 2e6c 6f67 6765 722e 6572 726f  nfig.logger.erro
-0000e3e0: 7228 652c 2065 7863 5f69 6e66 6f3d 5472  r(e, exc_info=Tr
-0000e3f0: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
-0000e400: 2020 2020 666f 7220 6e6c 705f 7661 722c      for nlp_var,
-0000e410: 206f 7269 675f 7661 6c20 696e 207a 6970   orig_val in zip
-0000e420: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000e430: 2020 2020 2020 4d69 6e64 7450 792e 7661        MindtPy.va
-0000e440: 7269 6162 6c65 5f6c 6973 742c 2073 656c  riable_list, sel
-0000e450: 662e 696e 6974 6961 6c5f 7661 725f 7661  f.initial_var_va
-0000e460: 6c75 6573 0a20 2020 2020 2020 2020 2020  lues.           
-0000e470: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-0000e480: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-0000e490: 6f74 206e 6c70 5f76 6172 2e66 6978 6564  ot nlp_var.fixed
-0000e4a0: 2061 6e64 206e 6f74 206e 6c70 5f76 6172   and not nlp_var
-0000e4b0: 2e69 735f 6269 6e61 7279 2829 3a0a 2020  .is_binary():.  
-0000e4c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e4d0: 2020 2020 2020 6e6c 705f 7661 722e 7365        nlp_var.se
-0000e4e0: 745f 7661 6c75 6528 6f72 6967 5f76 616c  t_value(orig_val
-0000e4f0: 2c20 736b 6970 5f76 616c 6964 6174 696f  , skip_validatio
-0000e500: 6e3d 5472 7565 290a 2020 2020 2020 2020  n=True).        
-0000e510: 2020 2020 2020 2020 7769 7468 2074 696d          with tim
-0000e520: 655f 636f 6465 2873 656c 662e 7469 6d69  e_code(self.timi
-0000e530: 6e67 2c20 2766 6561 7369 6269 6c69 7479  ng, 'feasibility
-0000e540: 2073 7562 7072 6f62 6c65 6d27 293a 0a20   subproblem'):. 
-0000e550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e560: 2020 2066 6561 735f 736f 6c6e 203d 2073     feas_soln = s
-0000e570: 656c 662e 6665 6173 6962 696c 6974 795f  elf.feasibility_
-0000e580: 6e6c 705f 6f70 742e 736f 6c76 6528 0a20  nlp_opt.solve(. 
-0000e590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5a0: 2020 2020 2020 2066 6561 735f 7375 6270         feas_subp
-0000e5b0: 726f 626c 656d 2c0a 2020 2020 2020 2020  roblem,.        
-0000e5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e5d0: 7465 653d 636f 6e66 6967 2e6e 6c70 5f73  tee=config.nlp_s
-0000e5e0: 6f6c 7665 725f 7465 652c 0a20 2020 2020  olver_tee,.     
-0000e5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e600: 2020 206c 6f61 645f 736f 6c75 7469 6f6e     load_solution
-0000e610: 733d 636f 6e66 6967 2e6e 6c70 5f73 6f6c  s=config.nlp_sol
-0000e620: 7665 7220 213d 2027 6170 7073 695f 6970  ver != 'appsi_ip
-0000e630: 6f70 7427 2c0a 2020 2020 2020 2020 2020  opt',.          
-0000e640: 2020 2020 2020 2020 2020 2020 2020 2a2a                **
-0000e650: 6e6c 705f 6172 6773 2c0a 2020 2020 2020  nlp_args,.      
-0000e660: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-0000e670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e680: 2020 2020 6966 206c 656e 2866 6561 735f      if len(feas_
-0000e690: 736f 6c6e 2e73 6f6c 7574 696f 6e29 203e  soln.solution) >
-0000e6a0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-0000e6b0: 2020 2020 2020 2020 2020 2020 6665 6173              feas
-0000e6c0: 5f73 6f6c 6e2e 736f 6c75 7469 6f6e 732e  _soln.solutions.
-0000e6d0: 6c6f 6164 5f66 726f 6d28 6665 6173 5f73  load_from(feas_s
-0000e6e0: 6f6c 6e29 0a20 2020 2020 2020 2073 656c  oln).        sel
-0000e6f0: 662e 6861 6e64 6c65 5f66 6561 7369 6269  f.handle_feasibi
-0000e700: 6c69 7479 5f73 7562 7072 6f62 6c65 6d5f  lity_subproblem_
-0000e710: 7463 280a 2020 2020 2020 2020 2020 2020  tc(.            
-0000e720: 6665 6173 5f73 6f6c 6e2e 736f 6c76 6572  feas_soln.solver
-0000e730: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-0000e740: 6469 7469 6f6e 2c20 4d69 6e64 7450 790a  dition, MindtPy.
-0000e750: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0000e760: 2020 636f 6e66 6967 2e6c 6f67 6765 722e    config.logger.
-0000e770: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-0000e780: 2020 7365 6c66 2e66 6978 6564 5f6e 6c70    self.fixed_nlp
-0000e790: 5f6c 6f67 5f66 6f72 6d61 7474 6572 2e66  _log_formatter.f
-0000e7a0: 6f72 6d61 7428 0a20 2020 2020 2020 2020  ormat(.         
-0000e7b0: 2020 2020 2020 2027 2027 2c0a 2020 2020         ' ',.    
-0000e7c0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0000e7d0: 2e6e 6c70 5f69 7465 722c 0a20 2020 2020  .nlp_iter,.     
-0000e7e0: 2020 2020 2020 2020 2020 2027 4665 6173             'Feas
-0000e7f0: 6962 696c 6974 7920 4e4c 5027 2c0a 2020  ibility NLP',.  
-0000e800: 2020 2020 2020 2020 2020 2020 2020 7661                va
-0000e810: 6c75 6528 6665 6173 5f73 7562 7072 6f62  lue(feas_subprob
-0000e820: 6c65 6d2e 4d69 6e64 7450 795f 7574 696c  lem.MindtPy_util
-0000e830: 732e 6665 6173 5f6f 626a 292c 0a20 2020  s.feas_obj),.   
-0000e840: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-0000e850: 662e 7072 696d 616c 5f62 6f75 6e64 2c0a  f.primal_bound,.
-0000e860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000e870: 7365 6c66 2e64 7561 6c5f 626f 756e 642c  self.dual_bound,
-0000e880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000e890: 2073 656c 662e 7265 6c5f 6761 702c 0a20   self.rel_gap,. 
-0000e8a0: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0000e8b0: 6574 5f6d 6169 6e5f 656c 6170 7365 645f  et_main_elapsed_
-0000e8c0: 7469 6d65 2873 656c 662e 7469 6d69 6e67  time(self.timing
-0000e8d0: 292c 0a20 2020 2020 2020 2020 2020 2029  ),.            )
+0000a780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a790: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0000a7a0: 2020 2020 2320 6e6c 705f 736f 6c76 652e      # nlp_solve.
+0000a7b0: 7079 0a0a 2020 2020 6465 6620 736f 6c76  py..    def solv
+0000a7c0: 655f 7375 6270 726f 626c 656d 2873 656c  e_subproblem(sel
+0000a7d0: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
+0000a7e0: 6f6c 7665 7320 7468 6520 4669 7865 642d  olves the Fixed-
+0000a7f0: 4e4c 5020 2877 6974 6820 6669 7865 6420  NLP (with fixed 
+0000a800: 696e 7465 6765 7273 292e 0a0a 2020 2020  integers)...    
+0000a810: 2020 2020 5468 6973 2066 756e 6374 696f      This functio
+0000a820: 6e20 7365 7473 2075 7020 7468 6520 2766  n sets up the 'f
+0000a830: 6978 6564 5f6e 6c70 2720 6279 2066 6978  ixed_nlp' by fix
+0000a840: 696e 6720 6269 6e61 7269 6573 2c20 7365  ing binaries, se
+0000a850: 7473 2063 6f6e 7469 6e75 6f75 7320 7661  ts continuous va
+0000a860: 7269 6162 6c65 7320 746f 2074 6865 6972  riables to their
+0000a870: 2069 6e69 7469 616c 2076 6172 2076 616c   initial var val
+0000a880: 7565 732c 0a20 2020 2020 2020 2070 7265  ues,.        pre
+0000a890: 636f 6d70 7574 6573 2064 7561 6c20 7661  computes dual va
+0000a8a0: 6c75 6573 2c20 6465 6163 7469 7661 7465  lues, deactivate
+0000a8b0: 7320 7472 6976 6961 6c20 636f 6e73 7472  s trivial constr
+0000a8c0: 6169 6e74 732c 2061 6e64 2074 6865 6e20  aints, and then 
+0000a8d0: 736f 6c76 6573 204e 4c50 206d 6f64 656c  solves NLP model
+0000a8e0: 2e0a 0a20 2020 2020 2020 2052 6574 7572  ...        Retur
+0000a8f0: 6e73 0a20 2020 2020 2020 202d 2d2d 2d2d  ns.        -----
+0000a900: 2d2d 0a20 2020 2020 2020 2066 6978 6564  --.        fixed
+0000a910: 5f6e 6c70 203a 2050 796f 6d6f 206d 6f64  _nlp : Pyomo mod
+0000a920: 656c 0a20 2020 2020 2020 2020 2020 2049  el.            I
+0000a930: 6e74 6567 6572 2d76 6172 6961 626c 652d  nteger-variable-
+0000a940: 6669 7865 6420 4e4c 5020 6d6f 6465 6c2e  fixed NLP model.
+0000a950: 0a20 2020 2020 2020 2072 6573 756c 7473  .        results
+0000a960: 203a 2053 6f6c 7665 7252 6573 756c 7473   : SolverResults
+0000a970: 0a20 2020 2020 2020 2020 2020 2052 6573  .            Res
+0000a980: 756c 7473 2066 726f 6d20 736f 6c76 696e  ults from solvin
+0000a990: 6720 7468 6520 4669 7865 642d 4e4c 502e  g the Fixed-NLP.
+0000a9a0: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0000a9b0: 2020 2020 2063 6f6e 6669 6720 3d20 7365       config = se
+0000a9c0: 6c66 2e63 6f6e 6669 670a 2020 2020 2020  lf.config.      
+0000a9d0: 2020 4d69 6e64 7450 7920 3d20 7365 6c66    MindtPy = self
+0000a9e0: 2e66 6978 6564 5f6e 6c70 2e4d 696e 6474  .fixed_nlp.Mindt
+0000a9f0: 5079 5f75 7469 6c73 0a20 2020 2020 2020  Py_utils.       
+0000aa00: 2073 656c 662e 6e6c 705f 6974 6572 202b   self.nlp_iter +
+0000aa10: 3d20 310a 0a20 2020 2020 2020 204d 696e  = 1..        Min
+0000aa20: 6474 5079 2e63 7574 732e 6465 6163 7469  dtPy.cuts.deacti
+0000aa30: 7661 7465 2829 0a20 2020 2020 2020 2069  vate().        i
+0000aa40: 6620 636f 6e66 6967 2e63 616c 6375 6c61  f config.calcula
+0000aa50: 7465 5f64 7561 6c5f 6174 5f73 6f6c 7574  te_dual_at_solut
+0000aa60: 696f 6e3a 0a20 2020 2020 2020 2020 2020  ion:.           
+0000aa70: 2073 656c 662e 6669 7865 645f 6e6c 702e   self.fixed_nlp.
+0000aa80: 746d 705f 6475 616c 7320 3d20 436f 6d70  tmp_duals = Comp
+0000aa90: 6f6e 656e 744d 6170 2829 0a20 2020 2020  onentMap().     
+0000aaa0: 2020 2020 2020 2023 2074 6d70 5f64 7561         # tmp_dua
+0000aab0: 6c73 2061 7265 2074 6865 2076 616c 7565  ls are the value
+0000aac0: 206f 6620 7468 6520 6475 616c 2076 6172   of the dual var
+0000aad0: 6961 626c 6573 2073 746f 7265 6420 6265  iables stored be
+0000aae0: 666f 7265 2075 7369 6e67 2064 6561 6374  fore using deact
+0000aaf0: 6976 6174 6520 7472 6976 6961 6c20 636f  ivate trivial co
+0000ab00: 6e73 7472 6169 6e74 730a 2020 2020 2020  nstraints.      
+0000ab10: 2020 2020 2020 2320 5468 6520 7661 6c75        # The valu
+0000ab20: 6573 206f 6620 7468 6520 6475 616c 7320  es of the duals 
+0000ab30: 6172 6520 636f 6d70 7574 6564 2061 7320  are computed as 
+0000ab40: 666f 6c6c 6f77 733a 2028 436f 6d70 6c65  follows: (Comple
+0000ab50: 6d65 6e74 6172 7920 536c 6163 6b6e 6573  mentary Slacknes
+0000ab60: 7329 0a20 2020 2020 2020 2020 2020 2023  s).            #
+0000ab70: 0a20 2020 2020 2020 2020 2020 2023 207c  .            # |
+0000ab80: 2063 6f6e 7374 7261 696e 7420 7c20 635f   constraint | c_
+0000ab90: 6765 7120 7c20 7374 6174 7573 2061 7420  geq | status at 
+0000aba0: 7831 207c 2074 6d70 5f64 7561 6c20 2876  x1 | tmp_dual (v
+0000abb0: 696f 6c61 7469 6f6e 2920 7c0a 2020 2020  iolation) |.    
+0000abc0: 2020 2020 2020 2020 2320 7c2d 2d2d 2d2d          # |-----
+0000abd0: 2d2d 2d2d 2d2d 2d7c 2d2d 2d2d 2d2d 2d7c  -------|-------|
+0000abe0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 7c2d  --------------|-
+0000abf0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+0000ac00: 2d2d 2d2d 2d7c 0a20 2020 2020 2020 2020  -----|.         
+0000ac10: 2020 2023 207c 2067 2878 2920 3c3d 2062     # | g(x) <= b
+0000ac20: 2020 7c20 2d31 2020 2020 7c20 6728 7831    | -1    | g(x1
+0000ac30: 2920 3c3d 2062 2020 207c 2030 2020 2020  ) <= b   | 0    
+0000ac40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ac50: 7c0a 2020 2020 2020 2020 2020 2020 2320  |.            # 
+0000ac60: 7c20 6728 7829 203c 3d20 6220 207c 202d  | g(x) <= b  | -
+0000ac70: 3120 2020 207c 2067 2878 3129 203e 2062  1    | g(x1) > b
+0000ac80: 2020 2020 7c20 6728 7831 2920 2d20 6220      | g(x1) - b 
+0000ac90: 2020 2020 2020 2020 2020 207c 0a20 2020             |.   
+0000aca0: 2020 2020 2020 2020 2023 207c 2067 2878           # | g(x
+0000acb0: 2920 3e3d 2062 2020 7c20 2b31 2020 2020  ) >= b  | +1    
+0000acc0: 7c20 6728 7831 2920 3e3d 2062 2020 207c  | g(x1) >= b   |
+0000acd0: 2030 2020 2020 2020 2020 2020 2020 2020   0              
+0000ace0: 2020 2020 2020 7c0a 2020 2020 2020 2020        |.        
+0000acf0: 2020 2020 2320 7c20 6728 7829 203e 3d20      # | g(x) >= 
+0000ad00: 6220 207c 202b 3120 2020 207c 2067 2878  b  | +1    | g(x
+0000ad10: 3129 203c 2062 2020 2020 7c20 6220 2d20  1) < b    | b - 
+0000ad20: 6728 7831 2920 2020 2020 2020 2020 2020  g(x1)           
+0000ad30: 207c 0a20 2020 2020 2020 2020 2020 2065   |.            e
+0000ad40: 7661 6c75 6174 696f 6e5f 6572 726f 7220  valuation_error 
+0000ad50: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+0000ad60: 2020 2020 666f 7220 6320 696e 2073 656c      for c in sel
+0000ad70: 662e 6669 7865 645f 6e6c 702e 4d69 6e64  f.fixed_nlp.Mind
+0000ad80: 7450 795f 7574 696c 732e 636f 6e73 7472  tPy_utils.constr
+0000ad90: 6169 6e74 5f6c 6973 743a 0a20 2020 2020  aint_list:.     
+0000ada0: 2020 2020 2020 2020 2020 2023 2057 6520             # We 
+0000adb0: 7072 6566 6572 2074 6f20 696e 636c 7564  prefer to includ
+0000adc0: 6520 7468 6520 7570 7065 7220 626f 756e  e the upper boun
+0000add0: 6420 6173 2074 6865 2072 6967 6874 2068  d as the right h
+0000ade0: 616e 6420 7369 6465 2073 696e 6365 2077  and side since w
+0000adf0: 6520 6172 650a 2020 2020 2020 2020 2020  e are.          
+0000ae00: 2020 2020 2020 2320 636f 6e73 6964 6572        # consider
+0000ae10: 696e 6720 6320 6279 2064 6566 6175 6c74  ing c by default
+0000ae20: 2061 2028 686f 7065 6675 6c6c 7929 2063   a (hopefully) c
+0000ae30: 6f6e 7665 7820 6675 6e63 7469 6f6e 2c20  onvex function, 
+0000ae40: 7768 6963 6820 776f 756c 6420 6d61 6b65  which would make
+0000ae50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ae60: 2023 2063 203e 3d20 6c62 2061 206e 6f6e   # c >= lb a non
+0000ae70: 636f 6e76 6578 2069 6e65 7175 616c 6974  convex inequalit
+0000ae80: 7920 7768 6963 6820 7765 2077 6f75 6c64  y which we would
+0000ae90: 6e27 7420 6c69 6b65 2074 6f20 6164 6420  n't like to add 
+0000aea0: 6c69 6e65 6172 697a 6174 696f 6e73 0a20  linearizations. 
+0000aeb0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000aec0: 2069 6620 7765 2064 6f6e 2774 2068 6176   if we don't hav
+0000aed0: 6520 746f 0a20 2020 2020 2020 2020 2020  e to.           
+0000aee0: 2020 2020 2072 6873 203d 2076 616c 7565       rhs = value
+0000aef0: 2863 2e75 7070 6572 2920 6966 2063 2e68  (c.upper) if c.h
+0000af00: 6173 5f75 6228 2920 656c 7365 2076 616c  as_ub() else val
+0000af10: 7565 2863 2e6c 6f77 6572 290a 2020 2020  ue(c.lower).    
+0000af20: 2020 2020 2020 2020 2020 2020 635f 6765              c_ge
+0000af30: 7120 3d20 2d31 2069 6620 632e 6861 735f  q = -1 if c.has_
+0000af40: 7562 2829 2065 6c73 6520 310a 2020 2020  ub() else 1.    
+0000af50: 2020 2020 2020 2020 2020 2020 7472 793a              try:
+0000af60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000af70: 2020 2020 2073 656c 662e 6669 7865 645f       self.fixed_
+0000af80: 6e6c 702e 746d 705f 6475 616c 735b 635d  nlp.tmp_duals[c]
+0000af90: 203d 2063 5f67 6571 202a 206d 6178 280a   = c_geq * max(.
+0000afa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000afb0: 2020 2020 2020 2020 302c 2063 5f67 6571          0, c_geq
+0000afc0: 202a 2028 7268 7320 2d20 7661 6c75 6528   * (rhs - value(
+0000afd0: 632e 626f 6479 2929 0a20 2020 2020 2020  c.body)).       
+0000afe0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000aff0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0000b000: 7863 6570 7420 2856 616c 7565 4572 726f  xcept (ValueErro
+0000b010: 722c 204f 7665 7266 6c6f 7745 7272 6f72  r, OverflowError
+0000b020: 2920 6173 2065 3a0a 2020 2020 2020 2020  ) as e:.        
+0000b030: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
+0000b040: 6967 2e6c 6f67 6765 722e 6572 726f 7228  ig.logger.error(
+0000b050: 652c 2065 7863 5f69 6e66 6f3d 5472 7565  e, exc_info=True
+0000b060: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000b070: 2020 2020 2020 7365 6c66 2e66 6978 6564        self.fixed
+0000b080: 5f6e 6c70 2e74 6d70 5f64 7561 6c73 5b63  _nlp.tmp_duals[c
+0000b090: 5d20 3d20 4e6f 6e65 0a20 2020 2020 2020  ] = None.       
+0000b0a0: 2020 2020 2020 2020 2020 2020 2065 7661               eva
+0000b0b0: 6c75 6174 696f 6e5f 6572 726f 7220 3d20  luation_error = 
+0000b0c0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0000b0d0: 2069 6620 6576 616c 7561 7469 6f6e 5f65   if evaluation_e
+0000b0e0: 7272 6f72 3a0a 2020 2020 2020 2020 2020  rror:.          
+0000b0f0: 2020 2020 2020 666f 7220 6e6c 705f 7661        for nlp_va
+0000b100: 722c 206f 7269 675f 7661 6c20 696e 207a  r, orig_val in z
+0000b110: 6970 280a 2020 2020 2020 2020 2020 2020  ip(.            
+0000b120: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+0000b130: 7661 7269 6162 6c65 5f6c 6973 742c 2073  variable_list, s
+0000b140: 656c 662e 696e 6974 6961 6c5f 7661 725f  elf.initial_var_
+0000b150: 7661 6c75 6573 0a20 2020 2020 2020 2020  values.         
+0000b160: 2020 2020 2020 2029 3a0a 2020 2020 2020         ):.      
+0000b170: 2020 2020 2020 2020 2020 2020 2020 6966                if
+0000b180: 206e 6f74 206e 6c70 5f76 6172 2e66 6978   not nlp_var.fix
+0000b190: 6564 2061 6e64 206e 6f74 206e 6c70 5f76  ed and not nlp_v
+0000b1a0: 6172 2e69 735f 6269 6e61 7279 2829 3a0a  ar.is_binary():.
+0000b1b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b1c0: 2020 2020 2020 2020 6e6c 705f 7661 722e          nlp_var.
+0000b1d0: 7365 745f 7661 6c75 6528 6f72 6967 5f76  set_value(orig_v
+0000b1e0: 616c 2c20 736b 6970 5f76 616c 6964 6174  al, skip_validat
+0000b1f0: 696f 6e3d 5472 7565 290a 2020 2020 2020  ion=True).      
+0000b200: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+0000b210: 2020 2054 7261 6e73 666f 726d 6174 696f     Transformatio
+0000b220: 6e46 6163 746f 7279 2827 636f 6e74 7269  nFactory('contri
+0000b230: 622e 6465 6163 7469 7661 7465 5f74 7269  b.deactivate_tri
+0000b240: 7669 616c 5f63 6f6e 7374 7261 696e 7473  vial_constraints
+0000b250: 2729 2e61 7070 6c79 5f74 6f28 0a20 2020  ').apply_to(.   
+0000b260: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000b270: 662e 6669 7865 645f 6e6c 702c 0a20 2020  f.fixed_nlp,.   
+0000b280: 2020 2020 2020 2020 2020 2020 2074 6d70               tmp
+0000b290: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
+0000b2a0: 2020 2020 2020 2069 676e 6f72 655f 696e         ignore_in
+0000b2b0: 6665 6173 6962 6c65 3d46 616c 7365 2c0a  feasible=False,.
+0000b2c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b2d0: 746f 6c65 7261 6e63 653d 636f 6e66 6967  tolerance=config
+0000b2e0: 2e63 6f6e 7374 7261 696e 745f 746f 6c65  .constraint_tole
+0000b2f0: 7261 6e63 652c 0a20 2020 2020 2020 2020  rance,.         
+0000b300: 2020 2029 0a20 2020 2020 2020 2065 7863     ).        exc
+0000b310: 6570 7420 496e 6665 6173 6962 6c65 436f  ept InfeasibleCo
+0000b320: 6e73 7472 6169 6e74 4578 6365 7074 696f  nstraintExceptio
+0000b330: 6e20 6173 2065 3a0a 2020 2020 2020 2020  n as e:.        
+0000b340: 2020 2020 636f 6e66 6967 2e6c 6f67 6765      config.logge
+0000b350: 722e 6572 726f 7228 652c 2065 7863 5f69  r.error(e, exc_i
+0000b360: 6e66 6f3d 5472 7565 290a 2020 2020 2020  nfo=True).      
+0000b370: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
+0000b380: 6765 722e 6572 726f 7228 0a20 2020 2020  ger.error(.     
+0000b390: 2020 2020 2020 2020 2020 2027 496e 6665             'Infe
+0000b3a0: 6173 6962 696c 6974 7920 6465 7465 6374  asibility detect
+0000b3b0: 6564 2069 6e20 6465 6163 7469 7661 7465  ed in deactivate
+0000b3c0: 5f74 7269 7669 616c 5f63 6f6e 7374 7261  _trivial_constra
+0000b3d0: 696e 7473 2e27 0a20 2020 2020 2020 2020  ints.'.         
+0000b3e0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+0000b3f0: 2072 6573 756c 7473 203d 2053 6f6c 7665   results = Solve
+0000b400: 7252 6573 756c 7473 2829 0a20 2020 2020  rResults().     
+0000b410: 2020 2020 2020 2072 6573 756c 7473 2e73         results.s
+0000b420: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+0000b430: 6e5f 636f 6e64 6974 696f 6e20 3d20 7463  n_condition = tc
+0000b440: 2e69 6e66 6561 7369 626c 650a 2020 2020  .infeasible.    
+0000b450: 2020 2020 2020 2020 7265 7475 726e 2073          return s
+0000b460: 656c 662e 6669 7865 645f 6e6c 702c 2072  elf.fixed_nlp, r
+0000b470: 6573 756c 7473 0a20 2020 2020 2020 2023  esults.        #
+0000b480: 2053 6f6c 7665 2074 6865 204e 4c50 0a20   Solve the NLP. 
+0000b490: 2020 2020 2020 206e 6c70 5f61 7267 7320         nlp_args 
+0000b4a0: 3d20 6469 6374 2863 6f6e 6669 672e 6e6c  = dict(config.nl
+0000b4b0: 705f 736f 6c76 6572 5f61 7267 7329 0a20  p_solver_args). 
+0000b4c0: 2020 2020 2020 2075 7064 6174 655f 736f         update_so
+0000b4d0: 6c76 6572 5f74 696d 656c 696d 6974 2873  lver_timelimit(s
+0000b4e0: 656c 662e 6e6c 705f 6f70 742c 2063 6f6e  elf.nlp_opt, con
+0000b4f0: 6669 672e 6e6c 705f 736f 6c76 6572 2c20  fig.nlp_solver, 
+0000b500: 7365 6c66 2e74 696d 696e 672c 2063 6f6e  self.timing, con
+0000b510: 6669 6729 0a20 2020 2020 2020 2077 6974  fig).        wit
+0000b520: 6820 5375 7070 7265 7373 496e 6665 6173  h SuppressInfeas
+0000b530: 6962 6c65 5761 726e 696e 6728 293a 0a20  ibleWarning():. 
+0000b540: 2020 2020 2020 2020 2020 2077 6974 6820             with 
+0000b550: 7469 6d65 5f63 6f64 6528 7365 6c66 2e74  time_code(self.t
+0000b560: 696d 696e 672c 2027 6669 7865 6420 7375  iming, 'fixed su
+0000b570: 6270 726f 626c 656d 2729 3a0a 2020 2020  bproblem'):.    
+0000b580: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+0000b590: 6c74 7320 3d20 7365 6c66 2e6e 6c70 5f6f  lts = self.nlp_o
+0000b5a0: 7074 2e73 6f6c 7665 280a 2020 2020 2020  pt.solve(.      
+0000b5b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000b5c0: 6c66 2e66 6978 6564 5f6e 6c70 2c0a 2020  lf.fixed_nlp,.  
+0000b5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b5e0: 2020 7465 653d 636f 6e66 6967 2e6e 6c70    tee=config.nlp
+0000b5f0: 5f73 6f6c 7665 725f 7465 652c 0a20 2020  _solver_tee,.   
+0000b600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b610: 206c 6f61 645f 736f 6c75 7469 6f6e 733d   load_solutions=
+0000b620: 7365 6c66 2e6e 6c70 5f6c 6f61 645f 736f  self.nlp_load_so
+0000b630: 6c75 7469 6f6e 732c 0a20 2020 2020 2020  lutions,.       
+0000b640: 2020 2020 2020 2020 2020 2020 202a 2a6e               **n
+0000b650: 6c70 5f61 7267 732c 0a20 2020 2020 2020  lp_args,.       
+0000b660: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+0000b670: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+0000b680: 6e28 7265 7375 6c74 732e 736f 6c75 7469  n(results.soluti
+0000b690: 6f6e 2920 3e20 303a 0a20 2020 2020 2020  on) > 0:.       
+0000b6a0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000b6b0: 662e 6669 7865 645f 6e6c 702e 736f 6c75  f.fixed_nlp.solu
+0000b6c0: 7469 6f6e 732e 6c6f 6164 5f66 726f 6d28  tions.load_from(
+0000b6d0: 7265 7375 6c74 7329 0a20 2020 2020 2020  results).       
+0000b6e0: 2054 7261 6e73 666f 726d 6174 696f 6e46   TransformationF
+0000b6f0: 6163 746f 7279 2827 636f 6e74 7269 622e  actory('contrib.
+0000b700: 6465 6163 7469 7661 7465 5f74 7269 7669  deactivate_trivi
+0000b710: 616c 5f63 6f6e 7374 7261 696e 7473 2729  al_constraints')
+0000b720: 2e72 6576 6572 7428 0a20 2020 2020 2020  .revert(.       
+0000b730: 2020 2020 2073 656c 662e 6669 7865 645f       self.fixed_
+0000b740: 6e6c 700a 2020 2020 2020 2020 290a 2020  nlp.        ).  
+0000b750: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
+0000b760: 662e 6669 7865 645f 6e6c 702c 2072 6573  f.fixed_nlp, res
+0000b770: 756c 7473 0a0a 2020 2020 6465 6620 6861  ults..    def ha
+0000b780: 6e64 6c65 5f6e 6c70 5f73 7562 7072 6f62  ndle_nlp_subprob
+0000b790: 6c65 6d5f 7463 2873 656c 662c 2066 6978  lem_tc(self, fix
+0000b7a0: 6564 5f6e 6c70 2c20 7265 7375 6c74 2c20  ed_nlp, result, 
+0000b7b0: 6362 5f6f 7074 3d4e 6f6e 6529 3a0a 2020  cb_opt=None):.  
+0000b7c0: 2020 2020 2020 2222 2254 6869 7320 6675        """This fu
+0000b7d0: 6e63 7469 6f6e 2068 616e 646c 6573 2064  nction handles d
+0000b7e0: 6966 6665 7265 6e74 2074 6572 6d69 6e61  ifferent termina
+0000b7f0: 746f 6e20 636f 6e64 6974 696f 6e73 206f  ton conditions o
+0000b800: 6620 7468 6520 6669 7865 642d 4e4c 5020  f the fixed-NLP 
+0000b810: 7375 6270 726f 626c 656d 2e0a 0a20 2020  subproblem...   
+0000b820: 2020 2020 2050 6172 616d 6574 6572 730a       Parameters.
+0000b830: 2020 2020 2020 2020 2d2d 2d2d 2d2d 2d2d          --------
+0000b840: 2d2d 0a20 2020 2020 2020 2066 6978 6564  --.        fixed
+0000b850: 5f6e 6c70 203a 2050 796f 6d6f 206d 6f64  _nlp : Pyomo mod
+0000b860: 656c 0a20 2020 2020 2020 2020 2020 2049  el.            I
+0000b870: 6e74 6567 6572 2d76 6172 6961 626c 652d  nteger-variable-
+0000b880: 6669 7865 6420 4e4c 5020 6d6f 6465 6c2e  fixed NLP model.
+0000b890: 0a20 2020 2020 2020 2072 6573 756c 7420  .        result 
+0000b8a0: 3a20 536f 6c76 6572 5265 7375 6c74 730a  : SolverResults.
+0000b8b0: 2020 2020 2020 2020 2020 2020 5265 7375              Resu
+0000b8c0: 6c74 7320 6672 6f6d 2073 6f6c 7669 6e67  lts from solving
+0000b8d0: 2074 6865 204e 4c50 2073 7562 7072 6f62   the NLP subprob
+0000b8e0: 6c65 6d2e 0a20 2020 2020 2020 2063 625f  lem..        cb_
+0000b8f0: 6f70 7420 3a20 536f 6c76 6572 4661 6374  opt : SolverFact
+0000b900: 6f72 792c 206f 7074 696f 6e61 6c0a 2020  ory, optional.  
+0000b910: 2020 2020 2020 2020 2020 5468 6520 6775            The gu
+0000b920: 726f 6269 5f70 6572 7369 7374 656e 7420  robi_persistent 
+0000b930: 736f 6c76 6572 2c20 6279 2064 6566 6175  solver, by defau
+0000b940: 6c74 204e 6f6e 652e 0a20 2020 2020 2020  lt None..       
+0000b950: 2022 2222 0a20 2020 2020 2020 2069 6620   """.        if 
+0000b960: 7265 7375 6c74 2e73 6f6c 7665 722e 7465  result.solver.te
+0000b970: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
+0000b980: 696f 6e20 696e 207b 0a20 2020 2020 2020  ion in {.       
+0000b990: 2020 2020 2074 632e 6f70 7469 6d61 6c2c       tc.optimal,
+0000b9a0: 0a20 2020 2020 2020 2020 2020 2074 632e  .            tc.
+0000b9b0: 6c6f 6361 6c6c 794f 7074 696d 616c 2c0a  locallyOptimal,.
+0000b9c0: 2020 2020 2020 2020 2020 2020 7463 2e66              tc.f
+0000b9d0: 6561 7369 626c 652c 0a20 2020 2020 2020  easible,.       
+0000b9e0: 207d 3a0a 2020 2020 2020 2020 2020 2020   }:.            
+0000b9f0: 7365 6c66 2e68 616e 646c 655f 7375 6270  self.handle_subp
+0000ba00: 726f 626c 656d 5f6f 7074 696d 616c 2866  roblem_optimal(f
+0000ba10: 6978 6564 5f6e 6c70 2c20 6362 5f6f 7074  ixed_nlp, cb_opt
+0000ba20: 290a 2020 2020 2020 2020 656c 6966 2072  ).        elif r
+0000ba30: 6573 756c 742e 736f 6c76 6572 2e74 6572  esult.solver.ter
+0000ba40: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+0000ba50: 6f6e 2069 6e20 7b74 632e 696e 6665 6173  on in {tc.infeas
+0000ba60: 6962 6c65 2c20 7463 2e6e 6f53 6f6c 7574  ible, tc.noSolut
+0000ba70: 696f 6e7d 3a0a 2020 2020 2020 2020 2020  ion}:.          
+0000ba80: 2020 7365 6c66 2e68 616e 646c 655f 7375    self.handle_su
+0000ba90: 6270 726f 626c 656d 5f69 6e66 6561 7369  bproblem_infeasi
+0000baa0: 626c 6528 6669 7865 645f 6e6c 702c 2063  ble(fixed_nlp, c
+0000bab0: 625f 6f70 7429 0a20 2020 2020 2020 2065  b_opt).        e
+0000bac0: 6c69 6620 7265 7375 6c74 2e73 6f6c 7665  lif result.solve
+0000bad0: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
+0000bae0: 6e64 6974 696f 6e20 6973 2074 632e 6d61  ndition is tc.ma
+0000baf0: 7854 696d 654c 696d 6974 3a0a 2020 2020  xTimeLimit:.    
+0000bb00: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
+0000bb10: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+0000bb20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bb30: 2027 4e4c 5020 7375 6270 726f 626c 656d   'NLP subproblem
+0000bb40: 2066 6169 6c65 6420 746f 2063 6f6e 7665   failed to conve
+0000bb50: 7267 6520 7769 7468 696e 2074 6865 2074  rge within the t
+0000bb60: 696d 6520 6c69 6d69 742e 270a 2020 2020  ime limit.'.    
+0000bb70: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000bb80: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
+0000bb90: 7473 2e73 6f6c 7665 722e 7465 726d 696e  ts.solver.termin
+0000bba0: 6174 696f 6e5f 636f 6e64 6974 696f 6e20  ation_condition 
+0000bbb0: 3d20 7463 2e6d 6178 5469 6d65 4c69 6d69  = tc.maxTimeLimi
+0000bbc0: 740a 2020 2020 2020 2020 2020 2020 7365  t.            se
+0000bbd0: 6c66 2e73 686f 756c 645f 7465 726d 696e  lf.should_termin
+0000bbe0: 6174 6520 3d20 5472 7565 0a20 2020 2020  ate = True.     
+0000bbf0: 2020 2065 6c69 6620 7265 7375 6c74 2e73     elif result.s
+0000bc00: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+0000bc10: 6e5f 636f 6e64 6974 696f 6e20 6973 2074  n_condition is t
+0000bc20: 632e 6d61 7845 7661 6c75 6174 696f 6e73  c.maxEvaluations
+0000bc30: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0000bc40: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
+0000bc50: 2e69 6e66 6f28 274e 4c50 2073 7562 7072  .info('NLP subpr
+0000bc60: 6f62 6c65 6d20 6661 696c 6564 2064 7565  oblem failed due
+0000bc70: 2074 6f20 6d61 7845 7661 6c75 6174 696f   to maxEvaluatio
+0000bc80: 6e73 2e27 290a 2020 2020 2020 2020 2020  ns.').          
+0000bc90: 2020 7365 6c66 2e72 6573 756c 7473 2e73    self.results.s
+0000bca0: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+0000bcb0: 6e5f 636f 6e64 6974 696f 6e20 3d20 7463  n_condition = tc
+0000bcc0: 2e6d 6178 4576 616c 7561 7469 6f6e 730a  .maxEvaluations.
+0000bcd0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000bce0: 2e73 686f 756c 645f 7465 726d 696e 6174  .should_terminat
+0000bcf0: 6520 3d20 5472 7565 0a20 2020 2020 2020  e = True.       
+0000bd00: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000bd10: 2020 2073 656c 662e 6861 6e64 6c65 5f73     self.handle_s
+0000bd20: 7562 7072 6f62 6c65 6d5f 6f74 6865 725f  ubproblem_other_
+0000bd30: 7465 726d 696e 6174 696f 6e28 0a20 2020  termination(.   
+0000bd40: 2020 2020 2020 2020 2020 2020 2066 6978               fix
+0000bd50: 6564 5f6e 6c70 2c20 7265 7375 6c74 2e73  ed_nlp, result.s
+0000bd60: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+0000bd70: 6e5f 636f 6e64 6974 696f 6e2c 2063 625f  n_condition, cb_
+0000bd80: 6f70 740a 2020 2020 2020 2020 2020 2020  opt.            
+0000bd90: 290a 0a20 2020 2064 6566 2068 616e 646c  )..    def handl
+0000bda0: 655f 7375 6270 726f 626c 656d 5f6f 7074  e_subproblem_opt
+0000bdb0: 696d 616c 2873 656c 662c 2066 6978 6564  imal(self, fixed
+0000bdc0: 5f6e 6c70 2c20 6362 5f6f 7074 3d4e 6f6e  _nlp, cb_opt=Non
+0000bdd0: 652c 2066 703d 4661 6c73 6529 3a0a 2020  e, fp=False):.  
+0000bde0: 2020 2020 2020 2222 2254 6869 7320 6675        """This fu
+0000bdf0: 6e63 7469 6f6e 2063 6f70 6965 7320 7468  nction copies th
+0000be00: 6520 7265 7375 6c74 206f 6620 7468 6520  e result of the 
+0000be10: 4e4c 5020 736f 6c76 6572 2066 756e 6374  NLP solver funct
+0000be20: 696f 6e20 2827 736f 6c76 655f 7375 6270  ion ('solve_subp
+0000be30: 726f 626c 656d 2729 2074 6f20 7468 6520  roblem') to the 
+0000be40: 776f 726b 696e 6720 6d6f 6465 6c2c 2075  working model, u
+0000be50: 7064 6174 6573 0a20 2020 2020 2020 2074  pdates.        t
+0000be60: 6865 2062 6f75 6e64 732c 2061 6464 7320  he bounds, adds 
+0000be70: 4f41 2061 6e64 206e 6f2d 676f 6f64 2063  OA and no-good c
+0000be80: 7574 732c 2061 6e64 2074 6865 6e20 7374  uts, and then st
+0000be90: 6f72 6573 2074 6865 206e 6577 2073 6f6c  ores the new sol
+0000bea0: 7574 696f 6e20 6966 2069 7420 6973 2074  ution if it is t
+0000beb0: 6865 206e 6577 2062 6573 7420 736f 6c75  he new best solu
+0000bec0: 7469 6f6e 2e20 5468 6973 0a20 2020 2020  tion. This.     
+0000bed0: 2020 2066 756e 6374 696f 6e20 6861 6e64     function hand
+0000bee0: 6c65 7320 7468 6520 7265 7375 6c74 206f  les the result o
+0000bef0: 6620 7468 6520 6c61 7465 7374 2069 7465  f the latest ite
+0000bf00: 7261 7469 6f6e 206f 6620 736f 6c76 696e  ration of solvin
+0000bf10: 6720 7468 6520 4e4c 5020 7375 6270 726f  g the NLP subpro
+0000bf20: 626c 656d 2067 6976 656e 2061 6e20 6f70  blem given an op
+0000bf30: 7469 6d61 6c20 736f 6c75 7469 6f6e 2e0a  timal solution..
+0000bf40: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+0000bf50: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+0000bf60: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2066  ------.        f
+0000bf70: 6978 6564 5f6e 6c70 203a 2050 796f 6d6f  ixed_nlp : Pyomo
+0000bf80: 206d 6f64 656c 0a20 2020 2020 2020 2020   model.         
+0000bf90: 2020 2049 6e74 6567 6572 2d76 6172 6961     Integer-varia
+0000bfa0: 626c 652d 6669 7865 6420 4e4c 5020 6d6f  ble-fixed NLP mo
+0000bfb0: 6465 6c2e 0a20 2020 2020 2020 2063 625f  del..        cb_
+0000bfc0: 6f70 7420 3a20 536f 6c76 6572 4661 6374  opt : SolverFact
+0000bfd0: 6f72 792c 206f 7074 696f 6e61 6c0a 2020  ory, optional.  
+0000bfe0: 2020 2020 2020 2020 2020 5468 6520 6775            The gu
+0000bff0: 726f 6269 5f70 6572 7369 7374 656e 7420  robi_persistent 
+0000c000: 736f 6c76 6572 2c20 6279 2064 6566 6175  solver, by defau
+0000c010: 6c74 204e 6f6e 652e 0a20 2020 2020 2020  lt None..       
+0000c020: 2066 7020 3a20 626f 6f6c 2c20 6f70 7469   fp : bool, opti
+0000c030: 6f6e 616c 0a20 2020 2020 2020 2020 2020  onal.           
+0000c040: 2057 6865 7468 6572 2069 7420 6973 2069   Whether it is i
+0000c050: 6e20 7468 6520 6c6f 6f70 206f 6620 6665  n the loop of fe
+0000c060: 6173 6962 696c 6974 7920 7075 6d70 2c20  asibility pump, 
+0000c070: 6279 2064 6566 6175 6c74 2046 616c 7365  by default False
+0000c080: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+0000c090: 2020 2020 2020 2320 544f 444f 3a20 6368        # TODO: ch
+0000c0a0: 6563 6b20 7768 6174 2069 7320 7468 6973  eck what is this
+0000c0b0: 2063 6f70 795f 7661 6c75 6520 6675 6e63   copy_value func
+0000c0c0: 7469 6f6e 2075 7365 6420 666f 723f 0a20  tion used for?. 
+0000c0d0: 2020 2020 2020 2023 2057 6172 6d73 7461         # Warmsta
+0000c0e0: 7274 3f0a 2020 2020 2020 2020 636f 6e66  rt?.        conf
+0000c0f0: 6967 203d 2073 656c 662e 636f 6e66 6967  ig = self.config
+0000c100: 0a20 2020 2020 2020 2063 6f70 795f 7661  .        copy_va
+0000c110: 725f 6c69 7374 5f76 616c 7565 7328 0a20  r_list_values(. 
+0000c120: 2020 2020 2020 2020 2020 2066 6978 6564             fixed
+0000c130: 5f6e 6c70 2e4d 696e 6474 5079 5f75 7469  _nlp.MindtPy_uti
+0000c140: 6c73 2e76 6172 6961 626c 655f 6c69 7374  ls.variable_list
+0000c150: 2c0a 2020 2020 2020 2020 2020 2020 7365  ,.            se
+0000c160: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
+0000c170: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+0000c180: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+0000c190: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+0000c1a0: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
+0000c1b0: 2020 2020 6966 2063 6f6e 6669 672e 6361      if config.ca
+0000c1c0: 6c63 756c 6174 655f 6475 616c 5f61 745f  lculate_dual_at_
+0000c1d0: 736f 6c75 7469 6f6e 3a0a 2020 2020 2020  solution:.      
+0000c1e0: 2020 2020 2020 666f 7220 6320 696e 2066        for c in f
+0000c1f0: 6978 6564 5f6e 6c70 2e74 6d70 5f64 7561  ixed_nlp.tmp_dua
+0000c200: 6c73 3a0a 2020 2020 2020 2020 2020 2020  ls:.            
+0000c210: 2020 2020 6966 2066 6978 6564 5f6e 6c70      if fixed_nlp
+0000c220: 2e64 7561 6c2e 6765 7428 632c 204e 6f6e  .dual.get(c, Non
+0000c230: 6529 2069 7320 4e6f 6e65 3a0a 2020 2020  e) is None:.    
+0000c240: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c250: 6669 7865 645f 6e6c 702e 6475 616c 5b63  fixed_nlp.dual[c
+0000c260: 5d20 3d20 6669 7865 645f 6e6c 702e 746d  ] = fixed_nlp.tm
+0000c270: 705f 6475 616c 735b 635d 0a20 2020 2020  p_duals[c].     
+0000c280: 2020 2020 2020 2020 2020 2065 6c69 6620             elif 
+0000c290: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000c2a0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
+0000c2b0: 672e 6e6c 705f 736f 6c76 6572 203d 3d20  g.nlp_solver == 
+0000c2c0: 2763 7969 706f 7074 270a 2020 2020 2020  'cyipopt'.      
+0000c2d0: 2020 2020 2020 2020 2020 2020 2020 616e                an
+0000c2e0: 6420 7365 6c66 2e6f 626a 6563 7469 7665  d self.objective
+0000c2f0: 5f73 656e 7365 203d 3d20 6d69 6e69 6d69  _sense == minimi
+0000c300: 7a65 0a20 2020 2020 2020 2020 2020 2020  ze.             
+0000c310: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
+0000c320: 2020 2020 2020 2020 2020 2320 544f 444f            # TODO
+0000c330: 3a20 7265 636f 7665 7220 7468 6520 6f70  : recover the op
+0000c340: 706f 7369 7465 2064 7561 6c20 7768 656e  posite dual when
+0000c350: 2063 7969 706f 7074 2069 7373 7565 2023   cyipopt issue #
+0000c360: 3238 3331 2069 7320 736f 6c76 6564 2e0a  2831 is solved..
+0000c370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c380: 2020 2020 6669 7865 645f 6e6c 702e 6475      fixed_nlp.du
+0000c390: 616c 5b63 5d20 3d20 2d66 6978 6564 5f6e  al[c] = -fixed_n
+0000c3a0: 6c70 2e64 7561 6c5b 635d 0a20 2020 2020  lp.dual[c].     
+0000c3b0: 2020 2020 2020 2064 7561 6c5f 7661 6c75         dual_valu
+0000c3c0: 6573 203d 206c 6973 7428 0a20 2020 2020  es = list(.     
+0000c3d0: 2020 2020 2020 2020 2020 2066 6978 6564             fixed
+0000c3e0: 5f6e 6c70 2e64 7561 6c5b 635d 2066 6f72  _nlp.dual[c] for
+0000c3f0: 2063 2069 6e20 6669 7865 645f 6e6c 702e   c in fixed_nlp.
+0000c400: 4d69 6e64 7450 795f 7574 696c 732e 636f  MindtPy_utils.co
+0000c410: 6e73 7472 6169 6e74 5f6c 6973 740a 2020  nstraint_list.  
+0000c420: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+0000c430: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0000c440: 2020 2020 2020 6475 616c 5f76 616c 7565        dual_value
+0000c450: 7320 3d20 4e6f 6e65 0a20 2020 2020 2020  s = None.       
+0000c460: 206d 6169 6e5f 6f62 6a65 6374 6976 6520   main_objective 
+0000c470: 3d20 6669 7865 645f 6e6c 702e 4d69 6e64  = fixed_nlp.Mind
+0000c480: 7450 795f 7574 696c 732e 6f62 6a65 6374  tPy_utils.object
+0000c490: 6976 655f 6c69 7374 5b2d 315d 0a20 2020  ive_list[-1].   
+0000c4a0: 2020 2020 2073 656c 662e 7570 6461 7465       self.update
+0000c4b0: 5f70 7269 6d61 6c5f 626f 756e 6428 7661  _primal_bound(va
+0000c4c0: 6c75 6528 6d61 696e 5f6f 626a 6563 7469  lue(main_objecti
+0000c4d0: 7665 2e65 7870 7229 290a 2020 2020 2020  ve.expr)).      
+0000c4e0: 2020 6966 2073 656c 662e 7072 696d 616c    if self.primal
+0000c4f0: 5f62 6f75 6e64 5f69 6d70 726f 7665 643a  _bound_improved:
+0000c500: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0000c510: 662e 6265 7374 5f73 6f6c 7574 696f 6e5f  f.best_solution_
+0000c520: 666f 756e 6420 3d20 6669 7865 645f 6e6c  found = fixed_nl
+0000c530: 702e 636c 6f6e 6528 290a 2020 2020 2020  p.clone().      
+0000c540: 2020 2020 2020 7365 6c66 2e62 6573 745f        self.best_
+0000c550: 736f 6c75 7469 6f6e 5f66 6f75 6e64 5f74  solution_found_t
+0000c560: 696d 6520 3d20 6765 745f 6d61 696e 5f65  ime = get_main_e
+0000c570: 6c61 7073 6564 5f74 696d 6528 7365 6c66  lapsed_time(self
+0000c580: 2e74 696d 696e 6729 0a20 2020 2020 2020  .timing).       
+0000c590: 2023 2041 6464 2074 6865 206c 696e 6561   # Add the linea
+0000c5a0: 7220 6375 740a 2020 2020 2020 2020 636f  r cut.        co
+0000c5b0: 7079 5f76 6172 5f6c 6973 745f 7661 6c75  py_var_list_valu
+0000c5c0: 6573 280a 2020 2020 2020 2020 2020 2020  es(.            
+0000c5d0: 6669 7865 645f 6e6c 702e 4d69 6e64 7450  fixed_nlp.MindtP
+0000c5e0: 795f 7574 696c 732e 7661 7269 6162 6c65  y_utils.variable
+0000c5f0: 5f6c 6973 742c 0a20 2020 2020 2020 2020  _list,.         
+0000c600: 2020 2073 656c 662e 6d69 702e 4d69 6e64     self.mip.Mind
+0000c610: 7450 795f 7574 696c 732e 7661 7269 6162  tPy_utils.variab
+0000c620: 6c65 5f6c 6973 742c 0a20 2020 2020 2020  le_list,.       
+0000c630: 2020 2020 2063 6f6e 6669 672c 0a20 2020       config,.   
+0000c640: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
+0000c650: 656c 662e 6164 645f 6375 7473 280a 2020  elf.add_cuts(.  
+0000c660: 2020 2020 2020 2020 2020 6475 616c 5f76            dual_v
+0000c670: 616c 7565 733d 6475 616c 5f76 616c 7565  alues=dual_value
+0000c680: 732c 0a20 2020 2020 2020 2020 2020 206c  s,.            l
+0000c690: 696e 6561 7269 7a65 5f61 6374 6976 653d  inearize_active=
+0000c6a0: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+0000c6b0: 2020 6c69 6e65 6172 697a 655f 7669 6f6c    linearize_viol
+0000c6c0: 6174 6564 3d54 7275 652c 0a20 2020 2020  ated=True,.     
+0000c6d0: 2020 2020 2020 2063 625f 6f70 743d 6362         cb_opt=cb
+0000c6e0: 5f6f 7074 2c0a 2020 2020 2020 2020 2020  _opt,.          
+0000c6f0: 2020 6e6c 703d 7365 6c66 2e66 6978 6564    nlp=self.fixed
+0000c700: 5f6e 6c70 2c0a 2020 2020 2020 2020 290a  _nlp,.        ).
+0000c710: 0a20 2020 2020 2020 2076 6172 5f76 616c  .        var_val
+0000c720: 7565 7320 3d20 6c69 7374 2876 2e76 616c  ues = list(v.val
+0000c730: 7565 2066 6f72 2076 2069 6e20 6669 7865  ue for v in fixe
+0000c740: 645f 6e6c 702e 4d69 6e64 7450 795f 7574  d_nlp.MindtPy_ut
+0000c750: 696c 732e 7661 7269 6162 6c65 5f6c 6973  ils.variable_lis
+0000c760: 7429 0a20 2020 2020 2020 2069 6620 636f  t).        if co
+0000c770: 6e66 6967 2e61 6464 5f6e 6f5f 676f 6f64  nfig.add_no_good
+0000c780: 5f63 7574 733a 0a20 2020 2020 2020 2020  _cuts:.         
+0000c790: 2020 2061 6464 5f6e 6f5f 676f 6f64 5f63     add_no_good_c
+0000c7a0: 7574 7328 0a20 2020 2020 2020 2020 2020  uts(.           
+0000c7b0: 2020 2020 2073 656c 662e 6d69 702c 2076       self.mip, v
+0000c7c0: 6172 5f76 616c 7565 732c 2063 6f6e 6669  ar_values, confi
+0000c7d0: 672c 2073 656c 662e 7469 6d69 6e67 2c20  g, self.timing, 
+0000c7e0: 7365 6c66 2e6d 6970 5f69 7465 722c 2063  self.mip_iter, c
+0000c7f0: 625f 6f70 740a 2020 2020 2020 2020 2020  b_opt.          
+0000c800: 2020 290a 0a20 2020 2020 2020 2063 6f6e    )..        con
+0000c810: 6669 672e 6361 6c6c 5f61 6674 6572 5f73  fig.call_after_s
+0000c820: 7562 7072 6f62 6c65 6d5f 6665 6173 6962  ubproblem_feasib
+0000c830: 6c65 2866 6978 6564 5f6e 6c70 290a 0a20  le(fixed_nlp).. 
+0000c840: 2020 2020 2020 2063 6f6e 6669 672e 6c6f         config.lo
+0000c850: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
+0000c860: 2020 2020 2020 2073 656c 662e 6669 7865         self.fixe
+0000c870: 645f 6e6c 705f 6c6f 675f 666f 726d 6174  d_nlp_log_format
+0000c880: 7465 722e 666f 726d 6174 280a 2020 2020  ter.format(.    
+0000c890: 2020 2020 2020 2020 2020 2020 272a 2720              '*' 
+0000c8a0: 6966 2073 656c 662e 7072 696d 616c 5f62  if self.primal_b
+0000c8b0: 6f75 6e64 5f69 6d70 726f 7665 6420 656c  ound_improved el
+0000c8c0: 7365 2027 2027 2c0a 2020 2020 2020 2020  se ' ',.        
+0000c8d0: 2020 2020 2020 2020 7365 6c66 2e6e 6c70          self.nlp
+0000c8e0: 5f69 7465 7220 6966 206e 6f74 2066 7020  _iter if not fp 
+0000c8f0: 656c 7365 2073 656c 662e 6670 5f69 7465  else self.fp_ite
+0000c900: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+0000c910: 2020 2027 4669 7865 6420 4e4c 5027 2c0a     'Fixed NLP',.
+0000c920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c930: 7661 6c75 6528 6d61 696e 5f6f 626a 6563  value(main_objec
+0000c940: 7469 7665 2e65 7870 7229 2c0a 2020 2020  tive.expr),.    
+0000c950: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000c960: 2e70 7269 6d61 6c5f 626f 756e 642c 0a20  .primal_bound,. 
+0000c970: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000c980: 656c 662e 6475 616c 5f62 6f75 6e64 2c0a  elf.dual_bound,.
+0000c990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c9a0: 7365 6c66 2e72 656c 5f67 6170 2c0a 2020  self.rel_gap,.  
+0000c9b0: 2020 2020 2020 2020 2020 2020 2020 6765                ge
+0000c9c0: 745f 6d61 696e 5f65 6c61 7073 6564 5f74  t_main_elapsed_t
+0000c9d0: 696d 6528 7365 6c66 2e74 696d 696e 6729  ime(self.timing)
+0000c9e0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
+0000c9f0: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+0000ca00: 6566 2068 616e 646c 655f 7375 6270 726f  ef handle_subpro
+0000ca10: 626c 656d 5f69 6e66 6561 7369 626c 6528  blem_infeasible(
+0000ca20: 7365 6c66 2c20 6669 7865 645f 6e6c 702c  self, fixed_nlp,
+0000ca30: 2063 625f 6f70 743d 4e6f 6e65 293a 0a20   cb_opt=None):. 
+0000ca40: 2020 2020 2020 2022 2222 536f 6c76 6573         """Solves
+0000ca50: 2066 6561 7369 6269 6c69 7479 2070 726f   feasibility pro
+0000ca60: 626c 656d 2061 6e64 2061 6464 7320 6375  blem and adds cu
+0000ca70: 7420 6163 636f 7264 696e 6720 746f 2074  t according to t
+0000ca80: 6865 2073 7065 6369 6669 6564 2073 7472  he specified str
+0000ca90: 6174 6567 792e 0a0a 2020 2020 2020 2020  ategy...        
+0000caa0: 5468 6973 2066 756e 6374 696f 6e20 6861  This function ha
+0000cab0: 6e64 6c65 7320 7468 6520 7265 7375 6c74  ndles the result
+0000cac0: 206f 6620 7468 6520 6c61 7465 7374 2069   of the latest i
+0000cad0: 7465 7261 7469 6f6e 206f 6620 736f 6c76  teration of solv
+0000cae0: 696e 6720 7468 6520 4e4c 5020 7375 6270  ing the NLP subp
+0000caf0: 726f 626c 656d 2067 6976 656e 2061 6e20  roblem given an 
+0000cb00: 696e 6665 6173 6962 6c65 0a20 2020 2020  infeasible.     
+0000cb10: 2020 2073 6f6c 7574 696f 6e20 616e 6420     solution and 
+0000cb20: 636f 7069 6573 2074 6865 2073 6f6c 7574  copies the solut
+0000cb30: 696f 6e20 6f66 2074 6865 2066 6561 7369  ion of the feasi
+0000cb40: 6269 6c69 7479 2070 726f 626c 656d 2074  bility problem t
+0000cb50: 6f20 7468 6520 776f 726b 696e 6720 6d6f  o the working mo
+0000cb60: 6465 6c2e 0a0a 2020 2020 2020 2020 5061  del...        Pa
+0000cb70: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
+0000cb80: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
+0000cb90: 2020 2020 6669 7865 645f 6e6c 7020 3a20      fixed_nlp : 
+0000cba0: 5079 6f6d 6f20 6d6f 6465 6c0a 2020 2020  Pyomo model.    
+0000cbb0: 2020 2020 2020 2020 496e 7465 6765 722d          Integer-
+0000cbc0: 7661 7269 6162 6c65 2d66 6978 6564 204e  variable-fixed N
+0000cbd0: 4c50 206d 6f64 656c 2e0a 2020 2020 2020  LP model..      
+0000cbe0: 2020 6362 5f6f 7074 203a 2053 6f6c 7665    cb_opt : Solve
+0000cbf0: 7246 6163 746f 7279 2c20 6f70 7469 6f6e  rFactory, option
+0000cc00: 616c 0a20 2020 2020 2020 2020 2020 2054  al.            T
+0000cc10: 6865 2067 7572 6f62 695f 7065 7273 6973  he gurobi_persis
+0000cc20: 7465 6e74 2073 6f6c 7665 722c 2062 7920  tent solver, by 
+0000cc30: 6465 6661 756c 7420 4e6f 6e65 2e0a 2020  default None..  
+0000cc40: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000cc50: 2020 2320 544f 444f 2074 7279 2073 6f6d    # TODO try som
+0000cc60: 6574 6869 6e67 2065 6c73 653f 2052 6569  ething else? Rei
+0000cc70: 6e69 7469 616c 697a 6520 7769 7468 2064  nitialize with d
+0000cc80: 6966 6665 7265 6e74 2069 6e69 7469 616c  ifferent initial
+0000cc90: 0a20 2020 2020 2020 2023 2076 616c 7565  .        # value
+0000cca0: 3f0a 2020 2020 2020 2020 636f 6e66 6967  ?.        config
+0000ccb0: 203d 2073 656c 662e 636f 6e66 6967 0a20   = self.config. 
+0000ccc0: 2020 2020 2020 2063 6f6e 6669 672e 6c6f         config.lo
+0000ccd0: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
+0000cce0: 2020 2020 2020 2073 656c 662e 696e 6665         self.infe
+0000ccf0: 6173 6962 6c65 5f66 6978 6564 5f6e 6c70  asible_fixed_nlp
+0000cd00: 5f6c 6f67 5f66 6f72 6d61 7474 6572 2e66  _log_formatter.f
+0000cd10: 6f72 6d61 7428 0a20 2020 2020 2020 2020  ormat(.         
+0000cd20: 2020 2020 2020 2027 2027 2c0a 2020 2020         ' ',.    
+0000cd30: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000cd40: 2e6e 6c70 5f69 7465 722c 0a20 2020 2020  .nlp_iter,.     
+0000cd50: 2020 2020 2020 2020 2020 2027 4669 7865             'Fixe
+0000cd60: 6420 4e4c 5027 2c0a 2020 2020 2020 2020  d NLP',.        
+0000cd70: 2020 2020 2020 2020 2749 6e66 6561 7369          'Infeasi
+0000cd80: 626c 6527 2c0a 2020 2020 2020 2020 2020  ble',.          
+0000cd90: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
+0000cda0: 6c5f 626f 756e 642c 0a20 2020 2020 2020  l_bound,.       
+0000cdb0: 2020 2020 2020 2020 2073 656c 662e 6475           self.du
+0000cdc0: 616c 5f62 6f75 6e64 2c0a 2020 2020 2020  al_bound,.      
+0000cdd0: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+0000cde0: 656c 5f67 6170 2c0a 2020 2020 2020 2020  el_gap,.        
+0000cdf0: 2020 2020 2020 2020 6765 745f 6d61 696e          get_main
+0000ce00: 5f65 6c61 7073 6564 5f74 696d 6528 7365  _elapsed_time(se
+0000ce10: 6c66 2e74 696d 696e 6729 2c0a 2020 2020  lf.timing),.    
+0000ce20: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000ce30: 2020 290a 2020 2020 2020 2020 7365 6c66    ).        self
+0000ce40: 2e6e 6c70 5f69 6e66 6561 7369 626c 655f  .nlp_infeasible_
+0000ce50: 636f 756e 7465 7220 2b3d 2031 0a20 2020  counter += 1.   
+0000ce60: 2020 2020 2069 6620 636f 6e66 6967 2e63       if config.c
+0000ce70: 616c 6375 6c61 7465 5f64 7561 6c5f 6174  alculate_dual_at
+0000ce80: 5f73 6f6c 7574 696f 6e3a 0a20 2020 2020  _solution:.     
+0000ce90: 2020 2020 2020 2066 6f72 2063 2069 6e20         for c in 
+0000cea0: 6669 7865 645f 6e6c 702e 4d69 6e64 7450  fixed_nlp.MindtP
+0000ceb0: 795f 7574 696c 732e 636f 6e73 7472 6169  y_utils.constrai
+0000cec0: 6e74 5f6c 6973 743a 0a20 2020 2020 2020  nt_list:.       
+0000ced0: 2020 2020 2020 2020 2072 6873 203d 2076           rhs = v
+0000cee0: 616c 7565 2863 2e75 7070 6572 2920 6966  alue(c.upper) if
+0000cef0: 2063 2e68 6173 5f75 6228 2920 656c 7365   c.has_ub() else
+0000cf00: 2076 616c 7565 2863 2e6c 6f77 6572 290a   value(c.lower).
+0000cf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf20: 635f 6765 7120 3d20 2d31 2069 6620 632e  c_geq = -1 if c.
+0000cf30: 6861 735f 7562 2829 2065 6c73 6520 310a  has_ub() else 1.
+0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cf50: 6669 7865 645f 6e6c 702e 6475 616c 5b63  fixed_nlp.dual[c
+0000cf60: 5d20 3d20 635f 6765 7120 2a20 6d61 7828  ] = c_geq * max(
+0000cf70: 302c 2063 5f67 6571 202a 2028 7268 7320  0, c_geq * (rhs 
+0000cf80: 2d20 7661 6c75 6528 632e 626f 6479 2929  - value(c.body))
+0000cf90: 290a 2020 2020 2020 2020 2020 2020 6475  ).            du
+0000cfa0: 616c 5f76 616c 7565 7320 3d20 6c69 7374  al_values = list
+0000cfb0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0000cfc0: 2020 6669 7865 645f 6e6c 702e 6475 616c    fixed_nlp.dual
+0000cfd0: 5b63 5d20 666f 7220 6320 696e 2066 6978  [c] for c in fix
+0000cfe0: 6564 5f6e 6c70 2e4d 696e 6474 5079 5f75  ed_nlp.MindtPy_u
+0000cff0: 7469 6c73 2e63 6f6e 7374 7261 696e 745f  tils.constraint_
+0000d000: 6c69 7374 0a20 2020 2020 2020 2020 2020  list.           
+0000d010: 2029 0a20 2020 2020 2020 2065 6c73 653a   ).        else:
+0000d020: 0a20 2020 2020 2020 2020 2020 2064 7561  .            dua
+0000d030: 6c5f 7661 6c75 6573 203d 204e 6f6e 650a  l_values = None.
+0000d040: 0a20 2020 2020 2020 2023 2069 6620 636f  .        # if co
+0000d050: 6e66 6967 2e73 7472 6174 6567 7920 3d3d  nfig.strategy ==
+0000d060: 2027 5053 4327 206f 7220 636f 6e66 6967   'PSC' or config
+0000d070: 2e73 7472 6174 6567 7920 3d3d 2027 4742  .strategy == 'GB
+0000d080: 4427 3a0a 2020 2020 2020 2020 2320 2020  D':.        #   
+0000d090: 2020 666f 7220 7661 7220 696e 2066 6978    for var in fix
+0000d0a0: 6564 5f6e 6c70 2e63 6f6d 706f 6e65 6e74  ed_nlp.component
+0000d0b0: 5f64 6174 615f 6f62 6a65 6374 7328 6374  _data_objects(ct
+0000d0c0: 7970 653d 5661 722c 2064 6573 6365 6e64  ype=Var, descend
+0000d0d0: 5f69 6e74 6f3d 5472 7565 293a 0a20 2020  _into=True):.   
+0000d0e0: 2020 2020 2023 2020 2020 2020 2020 2066       #         f
+0000d0f0: 6978 6564 5f6e 6c70 2e69 706f 7074 5f7a  ixed_nlp.ipopt_z
+0000d100: 4c5f 6f75 745b 7661 725d 203d 2030 0a20  L_out[var] = 0. 
+0000d110: 2020 2020 2020 2023 2020 2020 2020 2020         #        
+0000d120: 2066 6978 6564 5f6e 6c70 2e69 706f 7074   fixed_nlp.ipopt
+0000d130: 5f7a 555f 6f75 745b 7661 725d 203d 2030  _zU_out[var] = 0
+0000d140: 0a20 2020 2020 2020 2023 2020 2020 2020  .        #      
+0000d150: 2020 2069 6620 7661 722e 6861 735f 7562     if var.has_ub
+0000d160: 2829 2061 6e64 2061 6273 2876 6172 2e75  () and abs(var.u
+0000d170: 6220 2d20 7661 6c75 6528 7661 7229 2920  b - value(var)) 
+0000d180: 3c20 636f 6e66 6967 2e61 6273 6f6c 7574  < config.absolut
+0000d190: 655f 626f 756e 645f 746f 6c65 7261 6e63  e_bound_toleranc
+0000d1a0: 653a 0a20 2020 2020 2020 2023 2020 2020  e:.        #    
+0000d1b0: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
+0000d1c0: 6c70 2e69 706f 7074 5f7a 4c5f 6f75 745b  lp.ipopt_zL_out[
+0000d1d0: 7661 725d 203d 2031 0a20 2020 2020 2020  var] = 1.       
+0000d1e0: 2023 2020 2020 2020 2020 2065 6c69 6620   #         elif 
+0000d1f0: 7661 722e 6861 735f 6c62 2829 2061 6e64  var.has_lb() and
+0000d200: 2061 6273 2876 616c 7565 2876 6172 2920   abs(value(var) 
+0000d210: 2d20 7661 722e 6c62 2920 3c20 636f 6e66  - var.lb) < conf
+0000d220: 6967 2e61 6273 6f6c 7574 655f 626f 756e  ig.absolute_boun
+0000d230: 645f 746f 6c65 7261 6e63 653a 0a20 2020  d_tolerance:.   
+0000d240: 2020 2020 2023 2020 2020 2020 2020 2020       #          
+0000d250: 2020 2066 6978 6564 5f6e 6c70 2e69 706f     fixed_nlp.ipo
+0000d260: 7074 5f7a 555f 6f75 745b 7661 725d 203d  pt_zU_out[var] =
+0000d270: 202d 310a 0a20 2020 2020 2020 2066 6561   -1..        fea
+0000d280: 735f 7375 6270 726f 626c 656d 2c20 6665  s_subproblem, fe
+0000d290: 6173 5f73 7562 7072 6f62 6c65 6d5f 7265  as_subproblem_re
+0000d2a0: 7375 6c74 7320 3d20 7365 6c66 2e73 6f6c  sults = self.sol
+0000d2b0: 7665 5f66 6561 7369 6269 6c69 7479 5f73  ve_feasibility_s
+0000d2c0: 7562 7072 6f62 6c65 6d28 290a 2020 2020  ubproblem().    
+0000d2d0: 2020 2020 2320 544f 444f 3a20 646f 2077      # TODO: do w
+0000d2e0: 6520 7265 616c 6c79 206e 6565 6420 7468  e really need th
+0000d2f0: 6973 3f0a 2020 2020 2020 2020 6966 2073  is?.        if s
+0000d300: 656c 662e 7368 6f75 6c64 5f74 6572 6d69  elf.should_termi
+0000d310: 6e61 7465 3a0a 2020 2020 2020 2020 2020  nate:.          
+0000d320: 2020 7265 7475 726e 0a20 2020 2020 2020    return.       
+0000d330: 2063 6f70 795f 7661 725f 6c69 7374 5f76   copy_var_list_v
+0000d340: 616c 7565 7328 0a20 2020 2020 2020 2020  alues(.         
+0000d350: 2020 2066 6561 735f 7375 6270 726f 626c     feas_subprobl
+0000d360: 656d 2e4d 696e 6474 5079 5f75 7469 6c73  em.MindtPy_utils
+0000d370: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
+0000d380: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000d390: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
+0000d3a0: 6c73 2e76 6172 6961 626c 655f 6c69 7374  ls.variable_list
+0000d3b0: 2c0a 2020 2020 2020 2020 2020 2020 636f  ,.            co
+0000d3c0: 6e66 6967 2c0a 2020 2020 2020 2020 290a  nfig,.        ).
+0000d3d0: 2020 2020 2020 2020 7365 6c66 2e61 6464          self.add
+0000d3e0: 5f63 7574 7328 0a20 2020 2020 2020 2020  _cuts(.         
+0000d3f0: 2020 2064 7561 6c5f 7661 6c75 6573 3d64     dual_values=d
+0000d400: 7561 6c5f 7661 6c75 6573 2c0a 2020 2020  ual_values,.    
+0000d410: 2020 2020 2020 2020 6c69 6e65 6172 697a          lineariz
+0000d420: 655f 6163 7469 7665 3d54 7275 652c 0a20  e_active=True,. 
+0000d430: 2020 2020 2020 2020 2020 206c 696e 6561             linea
+0000d440: 7269 7a65 5f76 696f 6c61 7465 643d 5472  rize_violated=Tr
+0000d450: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+0000d460: 6362 5f6f 7074 3d63 625f 6f70 742c 0a20  cb_opt=cb_opt,. 
+0000d470: 2020 2020 2020 2020 2020 206e 6c70 3d66             nlp=f
+0000d480: 6561 735f 7375 6270 726f 626c 656d 2c0a  eas_subproblem,.
+0000d490: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000d4a0: 2020 2320 4164 6420 6120 6e6f 2d67 6f6f    # Add a no-goo
+0000d4b0: 6420 6375 7420 746f 2065 7863 6c75 6465  d cut to exclude
+0000d4c0: 2074 6869 7320 6469 7363 7265 7465 206f   this discrete o
+0000d4d0: 7074 696f 6e0a 2020 2020 2020 2020 7661  ption.        va
+0000d4e0: 725f 7661 6c75 6573 203d 206c 6973 7428  r_values = list(
+0000d4f0: 762e 7661 6c75 6520 666f 7220 7620 696e  v.value for v in
+0000d500: 2066 6978 6564 5f6e 6c70 2e4d 696e 6474   fixed_nlp.Mindt
+0000d510: 5079 5f75 7469 6c73 2e76 6172 6961 626c  Py_utils.variabl
+0000d520: 655f 6c69 7374 290a 2020 2020 2020 2020  e_list).        
+0000d530: 6966 2063 6f6e 6669 672e 6164 645f 6e6f  if config.add_no
+0000d540: 5f67 6f6f 645f 6375 7473 3a0a 2020 2020  _good_cuts:.    
+0000d550: 2020 2020 2020 2020 2320 6578 636c 7564          # exclud
+0000d560: 6573 2063 7572 7265 6e74 2064 6973 6372  es current discr
+0000d570: 6574 6520 6f70 7469 6f6e 0a20 2020 2020  ete option.     
+0000d580: 2020 2020 2020 2061 6464 5f6e 6f5f 676f         add_no_go
+0000d590: 6f64 5f63 7574 7328 0a20 2020 2020 2020  od_cuts(.       
+0000d5a0: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
+0000d5b0: 702c 2076 6172 5f76 616c 7565 732c 2063  p, var_values, c
+0000d5c0: 6f6e 6669 672c 2073 656c 662e 7469 6d69  onfig, self.timi
+0000d5d0: 6e67 2c20 7365 6c66 2e6d 6970 5f69 7465  ng, self.mip_ite
+0000d5e0: 722c 2063 625f 6f70 740a 2020 2020 2020  r, cb_opt.      
+0000d5f0: 2020 2020 2020 290a 0a20 2020 2064 6566        )..    def
+0000d600: 2068 616e 646c 655f 7375 6270 726f 626c   handle_subprobl
+0000d610: 656d 5f6f 7468 6572 5f74 6572 6d69 6e61  em_other_termina
+0000d620: 7469 6f6e 280a 2020 2020 2020 2020 7365  tion(.        se
+0000d630: 6c66 2c20 6669 7865 645f 6e6c 702c 2074  lf, fixed_nlp, t
+0000d640: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+0000d650: 7469 6f6e 2c20 6362 5f6f 7074 3d4e 6f6e  tion, cb_opt=Non
+0000d660: 650a 2020 2020 293a 0a20 2020 2020 2020  e.    ):.       
+0000d670: 2022 2222 4861 6e64 6c65 7320 7468 6520   """Handles the 
+0000d680: 7265 7375 6c74 206f 6620 7468 6520 6c61  result of the la
+0000d690: 7465 7374 2069 7465 7261 7469 6f6e 206f  test iteration o
+0000d6a0: 6620 736f 6c76 696e 6720 7468 6520 6669  f solving the fi
+0000d6b0: 7865 6420 4e4c 5020 7375 6270 726f 626c  xed NLP subprobl
+0000d6c0: 656d 2067 6976 656e 0a20 2020 2020 2020  em given.       
+0000d6d0: 2061 2073 6f6c 7574 696f 6e20 7468 6174   a solution that
+0000d6e0: 2069 7320 6e65 6974 6865 7220 6f70 7469   is neither opti
+0000d6f0: 6d61 6c20 6e6f 7220 696e 6665 6173 6962  mal nor infeasib
+0000d700: 6c65 2e0a 0a20 2020 2020 2020 2050 6172  le...        Par
+0000d710: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0000d720: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0000d730: 2020 2066 6978 6564 5f6e 6c70 203a 2050     fixed_nlp : P
+0000d740: 796f 6d6f 206d 6f64 656c 0a20 2020 2020  yomo model.     
+0000d750: 2020 2020 2020 2049 6e74 6567 6572 2d76         Integer-v
+0000d760: 6172 6961 626c 652d 6669 7865 6420 4e4c  ariable-fixed NL
+0000d770: 5020 6d6f 6465 6c2e 0a20 2020 2020 2020  P model..       
+0000d780: 2074 6572 6d69 6e61 7469 6f6e 5f63 6f6e   termination_con
+0000d790: 6469 7469 6f6e 203a 2050 796f 6d6f 2054  dition : Pyomo T
+0000d7a0: 6572 6d69 6e61 7469 6f6e 436f 6e64 6974  erminationCondit
+0000d7b0: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
+0000d7c0: 5468 6520 7465 726d 696e 6174 696f 6e20  The termination 
+0000d7d0: 636f 6e64 6974 696f 6e20 6f66 2074 6865  condition of the
+0000d7e0: 2066 6978 6564 204e 4c50 2073 7562 7072   fixed NLP subpr
+0000d7f0: 6f62 6c65 6d2e 0a20 2020 2020 2020 2063  oblem..        c
+0000d800: 625f 6f70 7420 3a20 536f 6c76 6572 4661  b_opt : SolverFa
+0000d810: 6374 6f72 792c 206f 7074 696f 6e61 6c0a  ctory, optional.
+0000d820: 2020 2020 2020 2020 2020 2020 5468 6520              The 
+0000d830: 6775 726f 6269 5f70 6572 7369 7374 656e  gurobi_persisten
+0000d840: 7420 736f 6c76 6572 2c20 6279 2064 6566  t solver, by def
+0000d850: 6175 6c74 204e 6f6e 652e 0a0a 2020 2020  ault None...    
+0000d860: 2020 2020 5261 6973 6573 0a20 2020 2020      Raises.     
+0000d870: 2020 202d 2d2d 2d2d 2d0a 2020 2020 2020     ------.      
+0000d880: 2020 5661 6c75 6545 7272 6f72 0a20 2020    ValueError.   
+0000d890: 2020 2020 2020 2020 204d 696e 6474 5079           MindtPy
+0000d8a0: 2075 6e61 626c 6520 746f 2068 616e 646c   unable to handl
+0000d8b0: 6520 7468 6520 4e4c 5020 7375 6270 726f  e the NLP subpro
+0000d8c0: 626c 656d 2074 6572 6d69 6e61 7469 6f6e  blem termination
+0000d8d0: 2063 6f6e 6469 7469 6f6e 2e0a 2020 2020   condition..    
+0000d8e0: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+0000d8f0: 6966 2074 6572 6d69 6e61 7469 6f6e 5f63  if termination_c
+0000d900: 6f6e 6469 7469 6f6e 2069 7320 7463 2e6d  ondition is tc.m
+0000d910: 6178 4974 6572 6174 696f 6e73 3a0a 2020  axIterations:.  
+0000d920: 2020 2020 2020 2020 2020 2320 544f 444f            # TODO
+0000d930: 2074 7279 2073 6f6d 6574 6869 6e67 2065   try something e
+0000d940: 6c73 653f 2052 6569 6e69 7469 616c 697a  lse? Reinitializ
+0000d950: 6520 7769 7468 2064 6966 6665 7265 6e74  e with different
+0000d960: 2069 6e69 7469 616c 2076 616c 7565 3f0a   initial value?.
+0000d970: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000d980: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e69  .config.logger.i
+0000d990: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+0000d9a0: 2020 2020 2027 4e4c 5020 7375 6270 726f       'NLP subpro
+0000d9b0: 626c 656d 2066 6169 6c65 6420 746f 2063  blem failed to c
+0000d9c0: 6f6e 7665 7267 6520 7769 7468 696e 2069  onverge within i
+0000d9d0: 7465 7261 7469 6f6e 206c 696d 6974 2e27  teration limit.'
+0000d9e0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+0000d9f0: 2020 2020 2020 2020 2020 2076 6172 5f76             var_v
+0000da00: 616c 7565 7320 3d20 6c69 7374 2876 2e76  alues = list(v.v
+0000da10: 616c 7565 2066 6f72 2076 2069 6e20 6669  alue for v in fi
+0000da20: 7865 645f 6e6c 702e 4d69 6e64 7450 795f  xed_nlp.MindtPy_
+0000da30: 7574 696c 732e 7661 7269 6162 6c65 5f6c  utils.variable_l
+0000da40: 6973 7429 0a20 2020 2020 2020 2020 2020  ist).           
+0000da50: 2069 6620 7365 6c66 2e63 6f6e 6669 672e   if self.config.
+0000da60: 6164 645f 6e6f 5f67 6f6f 645f 6375 7473  add_no_good_cuts
+0000da70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000da80: 2020 2320 6578 636c 7564 6573 2063 7572    # excludes cur
+0000da90: 7265 6e74 2064 6973 6372 6574 6520 6f70  rent discrete op
+0000daa0: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+0000dab0: 2020 2020 2061 6464 5f6e 6f5f 676f 6f64       add_no_good
+0000dac0: 5f63 7574 7328 0a20 2020 2020 2020 2020  _cuts(.         
+0000dad0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000dae0: 6d69 702c 0a20 2020 2020 2020 2020 2020  mip,.           
+0000daf0: 2020 2020 2020 2020 2076 6172 5f76 616c           var_val
+0000db00: 7565 732c 0a20 2020 2020 2020 2020 2020  ues,.           
+0000db10: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
+0000db20: 6e66 6967 2c0a 2020 2020 2020 2020 2020  nfig,.          
+0000db30: 2020 2020 2020 2020 2020 7365 6c66 2e74            self.t
+0000db40: 696d 696e 672c 0a20 2020 2020 2020 2020  iming,.         
+0000db50: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000db60: 6d69 705f 6974 6572 2c0a 2020 2020 2020  mip_iter,.      
+0000db70: 2020 2020 2020 2020 2020 2020 2020 6362                cb
+0000db80: 5f6f 7074 2c0a 2020 2020 2020 2020 2020  _opt,.          
+0000db90: 2020 2020 2020 290a 0a20 2020 2020 2020        )..       
+0000dba0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000dbb0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+0000dbc0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+0000dbd0: 2020 2020 2027 4d69 6e64 7450 7920 756e       'MindtPy un
+0000dbe0: 6162 6c65 2074 6f20 6861 6e64 6c65 204e  able to handle N
+0000dbf0: 4c50 2073 7562 7072 6f62 6c65 6d20 7465  LP subproblem te
+0000dc00: 726d 696e 6174 696f 6e20 270a 2020 2020  rmination '.    
+0000dc10: 2020 2020 2020 2020 2020 2020 2763 6f6e              'con
+0000dc20: 6469 7469 6f6e 206f 6620 7b7d 272e 666f  dition of {}'.fo
+0000dc30: 726d 6174 2874 6572 6d69 6e61 7469 6f6e  rmat(termination
+0000dc40: 5f63 6f6e 6469 7469 6f6e 290a 2020 2020  _condition).    
+0000dc50: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+0000dc60: 6566 2073 6f6c 7665 5f66 6561 7369 6269  ef solve_feasibi
+0000dc70: 6c69 7479 5f73 7562 7072 6f62 6c65 6d28  lity_subproblem(
+0000dc80: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0000dc90: 2222 536f 6c76 6573 2061 2066 6561 7369  ""Solves a feasi
+0000dca0: 6269 6c69 7479 204e 4c50 2069 6620 7468  bility NLP if th
+0000dcb0: 6520 6669 7865 645f 6e6c 7020 7072 6f62  e fixed_nlp prob
+0000dcc0: 6c65 6d20 6973 2069 6e66 6561 7369 626c  lem is infeasibl
+0000dcd0: 652e 0a0a 2020 2020 2020 2020 5265 7475  e...        Retu
+0000dce0: 726e 730a 2020 2020 2020 2020 2d2d 2d2d  rns.        ----
+0000dcf0: 2d2d 2d0a 2020 2020 2020 2020 6665 6173  ---.        feas
+0000dd00: 5f73 7562 7072 6f62 6c65 6d20 3a20 5079  _subproblem : Py
+0000dd10: 6f6d 6f20 6d6f 6465 6c0a 2020 2020 2020  omo model.      
+0000dd20: 2020 2020 2020 4665 6173 6962 696c 6974        Feasibilit
+0000dd30: 7920 4e4c 5020 6672 6f6d 2074 6865 206d  y NLP from the m
+0000dd40: 6f64 656c 2e0a 2020 2020 2020 2020 6665  odel..        fe
+0000dd50: 6173 5f73 6f6c 6e20 3a20 536f 6c76 6572  as_soln : Solver
+0000dd60: 5265 7375 6c74 730a 2020 2020 2020 2020  Results.        
+0000dd70: 2020 2020 5265 7375 6c74 7320 6672 6f6d      Results from
+0000dd80: 2073 6f6c 7669 6e67 2074 6865 2066 6561   solving the fea
+0000dd90: 7369 6269 6c69 7479 204e 4c50 2e0a 2020  sibility NLP..  
+0000dda0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+0000ddb0: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
+0000ddc0: 636f 6e66 6967 0a20 2020 2020 2020 2066  config.        f
+0000ddd0: 6561 735f 7375 6270 726f 626c 656d 203d  eas_subproblem =
+0000dde0: 2073 656c 662e 6669 7865 645f 6e6c 700a   self.fixed_nlp.
+0000ddf0: 2020 2020 2020 2020 4d69 6e64 7450 7920          MindtPy 
+0000de00: 3d20 6665 6173 5f73 7562 7072 6f62 6c65  = feas_subproble
+0000de10: 6d2e 4d69 6e64 7450 795f 7574 696c 730a  m.MindtPy_utils.
+0000de20: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+0000de30: 6665 6173 5f6f 7074 2e61 6374 6976 6174  feas_opt.activat
+0000de40: 6528 290a 2020 2020 2020 2020 6966 204d  e().        if M
+0000de50: 696e 6474 5079 2e63 6f6d 706f 6e65 6e74  indtPy.component
+0000de60: 2827 6f62 6a65 6374 6976 655f 7661 6c75  ('objective_valu
+0000de70: 6527 2920 6973 206e 6f74 204e 6f6e 653a  e') is not None:
+0000de80: 0a20 2020 2020 2020 2020 2020 204d 696e  .            Min
+0000de90: 6474 5079 2e6f 626a 6563 7469 7665 5f76  dtPy.objective_v
+0000dea0: 616c 7565 5b3a 5d2e 7365 745f 7661 6c75  alue[:].set_valu
+0000deb0: 6528 302c 2073 6b69 705f 7661 6c69 6461  e(0, skip_valida
+0000dec0: 7469 6f6e 3d54 7275 6529 0a0a 2020 2020  tion=True)..    
+0000ded0: 2020 2020 6163 7469 7665 5f6f 626a 203d      active_obj =
+0000dee0: 206e 6578 7428 0a20 2020 2020 2020 2020   next(.         
+0000def0: 2020 2066 6561 735f 7375 6270 726f 626c     feas_subprobl
+0000df00: 656d 2e63 6f6d 706f 6e65 6e74 5f64 6174  em.component_dat
+0000df10: 615f 6f62 6a65 6374 7328 4f62 6a65 6374  a_objects(Object
+0000df20: 6976 652c 2061 6374 6976 653d 5472 7565  ive, active=True
+0000df30: 290a 2020 2020 2020 2020 290a 2020 2020  ).        ).    
+0000df40: 2020 2020 6163 7469 7665 5f6f 626a 2e64      active_obj.d
+0000df50: 6561 6374 6976 6174 6528 290a 2020 2020  eactivate().    
+0000df60: 2020 2020 666f 7220 636f 6e73 7472 2069      for constr i
+0000df70: 6e20 4d69 6e64 7450 792e 6e6f 6e6c 696e  n MindtPy.nonlin
+0000df80: 6561 725f 636f 6e73 7472 6169 6e74 5f6c  ear_constraint_l
+0000df90: 6973 743a 0a20 2020 2020 2020 2020 2020  ist:.           
+0000dfa0: 2063 6f6e 7374 722e 6465 6163 7469 7661   constr.deactiva
+0000dfb0: 7465 2829 0a0a 2020 2020 2020 2020 4d69  te()..        Mi
+0000dfc0: 6e64 7450 792e 6665 6173 5f6f 7074 2e61  ndtPy.feas_opt.a
+0000dfd0: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
+0000dfe0: 2020 4d69 6e64 7450 792e 6665 6173 5f6f    MindtPy.feas_o
+0000dff0: 626a 2e61 6374 6976 6174 6528 290a 2020  bj.activate().  
+0000e000: 2020 2020 2020 6e6c 705f 6172 6773 203d        nlp_args =
+0000e010: 2064 6963 7428 636f 6e66 6967 2e6e 6c70   dict(config.nlp
+0000e020: 5f73 6f6c 7665 725f 6172 6773 290a 2020  _solver_args).  
+0000e030: 2020 2020 2020 7570 6461 7465 5f73 6f6c        update_sol
+0000e040: 7665 725f 7469 6d65 6c69 6d69 7428 0a20  ver_timelimit(. 
+0000e050: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000e060: 6665 6173 6962 696c 6974 795f 6e6c 705f  feasibility_nlp_
+0000e070: 6f70 742c 2063 6f6e 6669 672e 6e6c 705f  opt, config.nlp_
+0000e080: 736f 6c76 6572 2c20 7365 6c66 2e74 696d  solver, self.tim
+0000e090: 696e 672c 2063 6f6e 6669 670a 2020 2020  ing, config.    
+0000e0a0: 2020 2020 290a 2020 2020 2020 2020 7472      ).        tr
+0000e0b0: 793a 0a20 2020 2020 2020 2020 2020 2054  y:.            T
+0000e0c0: 7261 6e73 666f 726d 6174 696f 6e46 6163  ransformationFac
+0000e0d0: 746f 7279 2827 636f 6e74 7269 622e 6465  tory('contrib.de
+0000e0e0: 6163 7469 7661 7465 5f74 7269 7669 616c  activate_trivial
+0000e0f0: 5f63 6f6e 7374 7261 696e 7473 2729 2e61  _constraints').a
+0000e100: 7070 6c79 5f74 6f28 0a20 2020 2020 2020  pply_to(.       
+0000e110: 2020 2020 2020 2020 2073 656c 662e 6669           self.fi
+0000e120: 7865 645f 6e6c 702c 0a20 2020 2020 2020  xed_nlp,.       
+0000e130: 2020 2020 2020 2020 2074 6d70 3d54 7275           tmp=Tru
+0000e140: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+0000e150: 2020 2069 676e 6f72 655f 696e 6665 6173     ignore_infeas
+0000e160: 6962 6c65 3d46 616c 7365 2c0a 2020 2020  ible=False,.    
+0000e170: 2020 2020 2020 2020 2020 2020 746f 6c65              tole
+0000e180: 7261 6e63 653d 636f 6e66 6967 2e63 6f6e  rance=config.con
+0000e190: 7374 7261 696e 745f 746f 6c65 7261 6e63  straint_toleranc
+0000e1a0: 652c 0a20 2020 2020 2020 2020 2020 2029  e,.            )
+0000e1b0: 0a20 2020 2020 2020 2065 7863 6570 7420  .        except 
+0000e1c0: 496e 6665 6173 6962 6c65 436f 6e73 7472  InfeasibleConstr
+0000e1d0: 6169 6e74 4578 6365 7074 696f 6e20 6173  aintException as
+0000e1e0: 2065 3a0a 2020 2020 2020 2020 2020 2020   e:.            
+0000e1f0: 636f 6e66 6967 2e6c 6f67 6765 722e 6572  config.logger.er
+0000e200: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+0000e210: 2020 2020 2073 7472 2865 2920 2b20 275c       str(e) + '\
+0000e220: 6e49 6e66 6561 7369 6269 6c69 7479 2064  nInfeasibility d
+0000e230: 6574 6563 7465 6420 696e 2064 6561 6374  etected in deact
+0000e240: 6976 6174 655f 7472 6976 6961 6c5f 636f  ivate_trivial_co
+0000e250: 6e73 7472 6169 6e74 732e 270a 2020 2020  nstraints.'.    
+0000e260: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0000e270: 2020 2020 2020 7265 7375 6c74 7320 3d20        results = 
+0000e280: 536f 6c76 6572 5265 7375 6c74 7328 290a  SolverResults().
+0000e290: 2020 2020 2020 2020 2020 2020 7265 7375              resu
+0000e2a0: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+0000e2b0: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+0000e2c0: 203d 2074 632e 696e 6665 6173 6962 6c65   = tc.infeasible
+0000e2d0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+0000e2e0: 7572 6e20 7365 6c66 2e66 6978 6564 5f6e  urn self.fixed_n
+0000e2f0: 6c70 2c20 7265 7375 6c74 730a 2020 2020  lp, results.    
+0000e300: 2020 2020 7769 7468 2053 7570 7072 6573      with Suppres
+0000e310: 7349 6e66 6561 7369 626c 6557 6172 6e69  sInfeasibleWarni
+0000e320: 6e67 2829 3a0a 2020 2020 2020 2020 2020  ng():.          
+0000e330: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+0000e340: 2020 2020 2020 2077 6974 6820 7469 6d65         with time
+0000e350: 5f63 6f64 6528 7365 6c66 2e74 696d 696e  _code(self.timin
+0000e360: 672c 2027 6665 6173 6962 696c 6974 7920  g, 'feasibility 
+0000e370: 7375 6270 726f 626c 656d 2729 3a0a 2020  subproblem'):.  
+0000e380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e390: 2020 6665 6173 5f73 6f6c 6e20 3d20 7365    feas_soln = se
+0000e3a0: 6c66 2e66 6561 7369 6269 6c69 7479 5f6e  lf.feasibility_n
+0000e3b0: 6c70 5f6f 7074 2e73 6f6c 7665 280a 2020  lp_opt.solve(.  
+0000e3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e3d0: 2020 2020 2020 6665 6173 5f73 7562 7072        feas_subpr
+0000e3e0: 6f62 6c65 6d2c 0a20 2020 2020 2020 2020  oblem,.         
+0000e3f0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000e400: 6565 3d63 6f6e 6669 672e 6e6c 705f 736f  ee=config.nlp_so
+0000e410: 6c76 6572 5f74 6565 2c0a 2020 2020 2020  lver_tee,.      
+0000e420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e430: 2020 6c6f 6164 5f73 6f6c 7574 696f 6e73    load_solutions
+0000e440: 3d63 6f6e 6669 672e 6e6c 705f 736f 6c76  =config.nlp_solv
+0000e450: 6572 2021 3d20 2761 7070 7369 5f69 706f  er != 'appsi_ipo
+0000e460: 7074 272c 0a20 2020 2020 2020 2020 2020  pt',.           
+0000e470: 2020 2020 2020 2020 2020 2020 202a 2a6e               **n
+0000e480: 6c70 5f61 7267 732c 0a20 2020 2020 2020  lp_args,.       
+0000e490: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0000e4a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e4b0: 2020 2069 6620 6c65 6e28 6665 6173 5f73     if len(feas_s
+0000e4c0: 6f6c 6e2e 736f 6c75 7469 6f6e 2920 3e20  oln.solution) > 
+0000e4d0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
+0000e4e0: 2020 2020 2020 2020 2020 2066 6561 735f             feas_
+0000e4f0: 7375 6270 726f 626c 656d 2e73 6f6c 7574  subproblem.solut
+0000e500: 696f 6e73 2e6c 6f61 645f 6672 6f6d 2866  ions.load_from(f
+0000e510: 6561 735f 736f 6c6e 290a 2020 2020 2020  eas_soln).      
+0000e520: 2020 2020 2020 6578 6365 7074 2028 5661        except (Va
+0000e530: 6c75 6545 7272 6f72 2c20 4f76 6572 666c  lueError, Overfl
+0000e540: 6f77 4572 726f 7229 2061 7320 653a 0a20  owError) as e:. 
+0000e550: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+0000e560: 6f6e 6669 672e 6c6f 6767 6572 2e65 7272  onfig.logger.err
+0000e570: 6f72 2865 2c20 6578 635f 696e 666f 3d54  or(e, exc_info=T
+0000e580: 7275 6529 0a20 2020 2020 2020 2020 2020  rue).           
+0000e590: 2020 2020 2066 6f72 206e 6c70 5f76 6172       for nlp_var
+0000e5a0: 2c20 6f72 6967 5f76 616c 2069 6e20 7a69  , orig_val in zi
+0000e5b0: 7028 0a20 2020 2020 2020 2020 2020 2020  p(.             
+0000e5c0: 2020 2020 2020 204d 696e 6474 5079 2e76         MindtPy.v
+0000e5d0: 6172 6961 626c 655f 6c69 7374 2c20 7365  ariable_list, se
+0000e5e0: 6c66 2e69 6e69 7469 616c 5f76 6172 5f76  lf.initial_var_v
+0000e5f0: 616c 7565 730a 2020 2020 2020 2020 2020  alues.          
+0000e600: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+0000e610: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000e620: 6e6f 7420 6e6c 705f 7661 722e 6669 7865  not nlp_var.fixe
+0000e630: 6420 616e 6420 6e6f 7420 6e6c 705f 7661  d and not nlp_va
+0000e640: 722e 6973 5f62 696e 6172 7928 293a 0a20  r.is_binary():. 
+0000e650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e660: 2020 2020 2020 206e 6c70 5f76 6172 2e73         nlp_var.s
+0000e670: 6574 5f76 616c 7565 286f 7269 675f 7661  et_value(orig_va
+0000e680: 6c2c 2073 6b69 705f 7661 6c69 6461 7469  l, skip_validati
+0000e690: 6f6e 3d54 7275 6529 0a20 2020 2020 2020  on=True).       
+0000e6a0: 2020 2020 2020 2020 2077 6974 6820 7469           with ti
+0000e6b0: 6d65 5f63 6f64 6528 7365 6c66 2e74 696d  me_code(self.tim
+0000e6c0: 696e 672c 2027 6665 6173 6962 696c 6974  ing, 'feasibilit
+0000e6d0: 7920 7375 6270 726f 626c 656d 2729 3a0a  y subproblem'):.
+0000e6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e6f0: 2020 2020 6665 6173 5f73 6f6c 6e20 3d20      feas_soln = 
+0000e700: 7365 6c66 2e66 6561 7369 6269 6c69 7479  self.feasibility
+0000e710: 5f6e 6c70 5f6f 7074 2e73 6f6c 7665 280a  _nlp_opt.solve(.
+0000e720: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e730: 2020 2020 2020 2020 6665 6173 5f73 7562          feas_sub
+0000e740: 7072 6f62 6c65 6d2c 0a20 2020 2020 2020  problem,.       
+0000e750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e760: 2074 6565 3d63 6f6e 6669 672e 6e6c 705f   tee=config.nlp_
+0000e770: 736f 6c76 6572 5f74 6565 2c0a 2020 2020  solver_tee,.    
+0000e780: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000e790: 2020 2020 6c6f 6164 5f73 6f6c 7574 696f      load_solutio
+0000e7a0: 6e73 3d63 6f6e 6669 672e 6e6c 705f 736f  ns=config.nlp_so
+0000e7b0: 6c76 6572 2021 3d20 2761 7070 7369 5f69  lver != 'appsi_i
+0000e7c0: 706f 7074 272c 0a20 2020 2020 2020 2020  popt',.         
+0000e7d0: 2020 2020 2020 2020 2020 2020 2020 202a                 *
+0000e7e0: 2a6e 6c70 5f61 7267 732c 0a20 2020 2020  *nlp_args,.     
+0000e7f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0000e800: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000e810: 2020 2020 2069 6620 6c65 6e28 6665 6173       if len(feas
+0000e820: 5f73 6f6c 6e2e 736f 6c75 7469 6f6e 2920  _soln.solution) 
+0000e830: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
+0000e840: 2020 2020 2020 2020 2020 2020 2066 6561               fea
+0000e850: 735f 736f 6c6e 2e73 6f6c 7574 696f 6e73  s_soln.solutions
+0000e860: 2e6c 6f61 645f 6672 6f6d 2866 6561 735f  .load_from(feas_
+0000e870: 736f 6c6e 290a 2020 2020 2020 2020 7365  soln).        se
+0000e880: 6c66 2e68 616e 646c 655f 6665 6173 6962  lf.handle_feasib
+0000e890: 696c 6974 795f 7375 6270 726f 626c 656d  ility_subproblem
+0000e8a0: 5f74 6328 0a20 2020 2020 2020 2020 2020  _tc(.           
+0000e8b0: 2066 6561 735f 736f 6c6e 2e73 6f6c 7665   feas_soln.solve
+0000e8c0: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
+0000e8d0: 6e64 6974 696f 6e2c 204d 696e 6474 5079  ndition, MindtPy
 0000e8e0: 0a20 2020 2020 2020 2029 0a20 2020 2020  .        ).     
-0000e8f0: 2020 204d 696e 6474 5079 2e66 6561 735f     MindtPy.feas_
-0000e900: 6f70 742e 6465 6163 7469 7661 7465 2829  opt.deactivate()
-0000e910: 0a20 2020 2020 2020 2066 6f72 2063 6f6e  .        for con
-0000e920: 7374 7220 696e 204d 696e 6474 5079 2e6e  str in MindtPy.n
-0000e930: 6f6e 6c69 6e65 6172 5f63 6f6e 7374 7261  onlinear_constra
-0000e940: 696e 745f 6c69 7374 3a0a 2020 2020 2020  int_list:.      
-0000e950: 2020 2020 2020 636f 6e73 7472 2e61 6374        constr.act
-0000e960: 6976 6174 6528 290a 2020 2020 2020 2020  ivate().        
-0000e970: 6163 7469 7665 5f6f 626a 2e61 6374 6976  active_obj.activ
-0000e980: 6174 6528 290a 2020 2020 2020 2020 4d69  ate().        Mi
-0000e990: 6e64 7450 792e 6665 6173 5f6f 626a 2e64  ndtPy.feas_obj.d
-0000e9a0: 6561 6374 6976 6174 6528 290a 2020 2020  eactivate().    
-0000e9b0: 2020 2020 5472 616e 7366 6f72 6d61 7469      Transformati
-0000e9c0: 6f6e 4661 6374 6f72 7928 2763 6f6e 7472  onFactory('contr
-0000e9d0: 6962 2e64 6561 6374 6976 6174 655f 7472  ib.deactivate_tr
-0000e9e0: 6976 6961 6c5f 636f 6e73 7472 6169 6e74  ivial_constraint
-0000e9f0: 7327 292e 7265 7665 7274 280a 2020 2020  s').revert(.    
-0000ea00: 2020 2020 2020 2020 6665 6173 5f73 7562          feas_sub
-0000ea10: 7072 6f62 6c65 6d0a 2020 2020 2020 2020  problem.        
-0000ea20: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-0000ea30: 2066 6561 735f 7375 6270 726f 626c 656d   feas_subproblem
-0000ea40: 2c20 6665 6173 5f73 6f6c 6e0a 0a20 2020  , feas_soln..   
-0000ea50: 2064 6566 2068 616e 646c 655f 6665 6173   def handle_feas
-0000ea60: 6962 696c 6974 795f 7375 6270 726f 626c  ibility_subprobl
-0000ea70: 656d 5f74 6328 7365 6c66 2c20 7375 6270  em_tc(self, subp
-0000ea80: 726f 625f 7465 726d 696e 6174 655f 636f  rob_terminate_co
-0000ea90: 6e64 2c20 4d69 6e64 7450 7929 3a0a 2020  nd, MindtPy):.  
-0000eaa0: 2020 2020 2020 2222 2248 616e 646c 6573        """Handles
-0000eab0: 2074 6865 2072 6573 756c 7420 6f66 2074   the result of t
-0000eac0: 6865 206c 6174 6573 7420 6974 6572 6174  he latest iterat
-0000ead0: 696f 6e20 6f66 2073 6f6c 7669 6e67 2074  ion of solving t
-0000eae0: 6865 2066 6561 7369 6269 6c69 7479 204e  he feasibility N
-0000eaf0: 4c50 2073 7562 7072 6f62 6c65 6d2e 0a0a  LP subproblem...
-0000eb00: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-0000eb10: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
-0000eb20: 2d2d 2d2d 2d0a 2020 2020 2020 2020 7375  -----.        su
-0000eb30: 6270 726f 625f 7465 726d 696e 6174 655f  bprob_terminate_
-0000eb40: 636f 6e64 203a 2050 796f 6d6f 2054 6572  cond : Pyomo Ter
-0000eb50: 6d69 6e61 7469 6f6e 436f 6e64 6974 696f  minationConditio
-0000eb60: 6e0a 2020 2020 2020 2020 2020 2020 5468  n.            Th
-0000eb70: 6520 7465 726d 696e 6174 696f 6e20 636f  e termination co
-0000eb80: 6e64 6974 696f 6e20 6f66 2074 6865 2066  ndition of the f
-0000eb90: 6561 7369 6269 6c69 7479 204e 4c50 2073  easibility NLP s
-0000eba0: 7562 7072 6f62 6c65 6d2e 0a20 2020 2020  ubproblem..     
-0000ebb0: 2020 204d 696e 6474 5079 203a 2050 796f     MindtPy : Pyo
-0000ebc0: 6d6f 2042 6c6f 636b 0a20 2020 2020 2020  mo Block.       
-0000ebd0: 2020 2020 2054 6865 204d 696e 6474 5079       The MindtPy
-0000ebe0: 5f75 7469 6c73 2062 6c6f 636b 2e0a 2020  _utils block..  
-0000ebf0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
-0000ec00: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
-0000ec10: 636f 6e66 6967 0a20 2020 2020 2020 2069  config.        i
-0000ec20: 6620 7375 6270 726f 625f 7465 726d 696e  f subprob_termin
-0000ec30: 6174 655f 636f 6e64 2069 6e20 7b74 632e  ate_cond in {tc.
-0000ec40: 6f70 7469 6d61 6c2c 2074 632e 6c6f 6361  optimal, tc.loca
-0000ec50: 6c6c 794f 7074 696d 616c 2c20 7463 2e66  llyOptimal, tc.f
-0000ec60: 6561 7369 626c 657d 3a0a 2020 2020 2020  easible}:.      
-0000ec70: 2020 2020 2020 2320 544f 444f 3a20 6368        # TODO: ch
-0000ec80: 6563 6b20 7768 6174 2069 7320 7468 6973  eck what is this
-0000ec90: 2063 6f70 795f 7661 6c75 6520 7573 6564   copy_value used
-0000eca0: 2066 6f72 3f0a 2020 2020 2020 2020 2020   for?.          
-0000ecb0: 2020 636f 7079 5f76 6172 5f6c 6973 745f    copy_var_list_
-0000ecc0: 7661 6c75 6573 280a 2020 2020 2020 2020  values(.        
-0000ecd0: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
-0000ece0: 7661 7269 6162 6c65 5f6c 6973 742c 0a20  variable_list,. 
-0000ecf0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0000ed00: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
-0000ed10: 6c2e 4d69 6e64 7450 795f 7574 696c 732e  l.MindtPy_utils.
-0000ed20: 7661 7269 6162 6c65 5f6c 6973 742c 0a20  variable_list,. 
-0000ed30: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0000ed40: 6f6e 6669 672c 0a20 2020 2020 2020 2020  onfig,.         
-0000ed50: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-0000ed60: 2069 6620 7661 6c75 6528 4d69 6e64 7450   if value(MindtP
-0000ed70: 792e 6665 6173 5f6f 626a 2e65 7870 7229  y.feas_obj.expr)
-0000ed80: 203c 3d20 636f 6e66 6967 2e7a 6572 6f5f   <= config.zero_
-0000ed90: 746f 6c65 7261 6e63 653a 0a20 2020 2020  tolerance:.     
-0000eda0: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
-0000edb0: 672e 6c6f 6767 6572 2e77 6172 6e69 6e67  g.logger.warning
-0000edc0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000edd0: 2020 2020 2020 2754 6865 206f 626a 6563        'The objec
-0000ede0: 7469 7665 2076 616c 7565 2025 2e34 4520  tive value %.4E 
-0000edf0: 6f66 2066 6561 7369 6269 6c69 7479 2070  of feasibility p
-0000ee00: 726f 626c 656d 2069 7320 6c65 7373 2074  roblem is less t
-0000ee10: 6861 6e20 7a65 726f 5f74 6f6c 6572 616e  han zero_toleran
-0000ee20: 6365 2e20 270a 2020 2020 2020 2020 2020  ce. '.          
-0000ee30: 2020 2020 2020 2020 2020 2754 6869 7320            'This 
-0000ee40: 696e 6469 6361 7465 7320 7468 6174 2074  indicates that t
-0000ee50: 6865 206e 6c70 2073 7562 7072 6f62 6c65  he nlp subproble
-0000ee60: 6d20 6973 2066 6561 7369 626c 652c 2061  m is feasible, a
-0000ee70: 6c74 686f 7567 6820 6974 2069 7320 666f  lthough it is fo
-0000ee80: 756e 6420 696e 6665 6173 6962 6c65 2069  und infeasible i
-0000ee90: 6e20 7468 6520 7072 6576 696f 7573 2073  n the previous s
-0000eea0: 7465 702e 2027 0a20 2020 2020 2020 2020  tep. '.         
-0000eeb0: 2020 2020 2020 2020 2020 2027 4368 6563             'Chec
-0000eec0: 6b20 7468 6520 6e6c 7020 736f 6c76 6572  k the nlp solver
-0000eed0: 206f 7574 7075 7427 2025 2076 616c 7565   output' % value
-0000eee0: 284d 696e 6474 5079 2e66 6561 735f 6f62  (MindtPy.feas_ob
-0000eef0: 6a2e 6578 7072 290a 2020 2020 2020 2020  j.expr).        
-0000ef00: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0000ef10: 2020 656c 6966 2073 7562 7072 6f62 5f74    elif subprob_t
-0000ef20: 6572 6d69 6e61 7465 5f63 6f6e 6420 696e  erminate_cond in
-0000ef30: 207b 7463 2e69 6e66 6561 7369 626c 652c   {tc.infeasible,
-0000ef40: 2074 632e 6e6f 536f 6c75 7469 6f6e 7d3a   tc.noSolution}:
-0000ef50: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
-0000ef60: 6669 672e 6c6f 6767 6572 2e65 7272 6f72  fig.logger.error
-0000ef70: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0000ef80: 2020 2746 6561 7369 6269 6c69 7479 2073    'Feasibility s
-0000ef90: 7562 7072 6f62 6c65 6d20 696e 6665 6173  ubproblem infeas
-0000efa0: 6962 6c65 2e20 5468 6973 2073 686f 756c  ible. This shoul
-0000efb0: 6420 6e65 7665 7220 6861 7070 656e 2e27  d never happen.'
-0000efc0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-0000efd0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0000efe0: 7368 6f75 6c64 5f74 6572 6d69 6e61 7465  should_terminate
-0000eff0: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-0000f000: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
-0000f010: 2e73 6f6c 7665 722e 7374 6174 7573 203d  .solver.status =
-0000f020: 2053 6f6c 7665 7253 7461 7475 732e 6572   SolverStatus.er
-0000f030: 726f 720a 2020 2020 2020 2020 656c 6966  ror.        elif
-0000f040: 2073 7562 7072 6f62 5f74 6572 6d69 6e61   subprob_termina
-0000f050: 7465 5f63 6f6e 6420 6973 2074 632e 6d61  te_cond is tc.ma
-0000f060: 7849 7465 7261 7469 6f6e 733a 0a20 2020  xIterations:.   
-0000f070: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
-0000f080: 6c6f 6767 6572 2e65 7272 6f72 280a 2020  logger.error(.  
-0000f090: 2020 2020 2020 2020 2020 2020 2020 2753                'S
-0000f0a0: 7562 736f 6c76 6572 2072 6561 6368 6564  ubsolver reached
-0000f0b0: 2069 7473 206d 6178 696d 756d 206e 756d   its maximum num
-0000f0c0: 6265 7220 6f66 2069 7465 7261 7469 6f6e  ber of iteration
-0000f0d0: 7320 7769 7468 6f75 7420 636f 6e76 6572  s without conver
-0000f0e0: 6769 6e67 2c20 270a 2020 2020 2020 2020  ging, '.        
-0000f0f0: 2020 2020 2020 2020 2763 6f6e 7369 6465          'conside
-0000f100: 7220 696e 6372 6561 7369 6e67 2074 6865  r increasing the
-0000f110: 2069 7465 7261 7469 6f6e 7320 6c69 6d69   iterations limi
-0000f120: 7420 6f66 2074 6865 2073 7562 736f 6c76  t of the subsolv
-0000f130: 6572 206f 7220 7265 7669 6577 696e 6720  er or reviewing 
-0000f140: 796f 7572 2066 6f72 6d75 6c61 7469 6f6e  your formulation
-0000f150: 2e27 0a20 2020 2020 2020 2020 2020 2029  .'.            )
-0000f160: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0000f170: 662e 7368 6f75 6c64 5f74 6572 6d69 6e61  f.should_termina
-0000f180: 7465 203d 2054 7275 650a 2020 2020 2020  te = True.      
-0000f190: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
-0000f1a0: 7473 2e73 6f6c 7665 722e 7374 6174 7573  ts.solver.status
-0000f1b0: 203d 2053 6f6c 7665 7253 7461 7475 732e   = SolverStatus.
-0000f1c0: 6572 726f 720a 2020 2020 2020 2020 656c  error.        el
-0000f1d0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000f1e0: 636f 6e66 6967 2e6c 6f67 6765 722e 6572  config.logger.er
-0000f1f0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
-0000f200: 2020 2020 2027 4d69 6e64 7450 7920 756e       'MindtPy un
-0000f210: 6162 6c65 2074 6f20 6861 6e64 6c65 2066  able to handle f
-0000f220: 6561 7369 6269 6c69 7479 2073 7562 7072  easibility subpr
-0000f230: 6f62 6c65 6d20 7465 726d 696e 6174 696f  oblem terminatio
-0000f240: 6e20 636f 6e64 6974 696f 6e20 270a 2020  n condition '.  
-0000f250: 2020 2020 2020 2020 2020 2020 2020 276f                'o
-0000f260: 6620 7b7d 272e 666f 726d 6174 2873 7562  f {}'.format(sub
-0000f270: 7072 6f62 5f74 6572 6d69 6e61 7465 5f63  prob_terminate_c
-0000f280: 6f6e 6429 0a20 2020 2020 2020 2020 2020  ond).           
-0000f290: 2029 0a20 2020 2020 2020 2020 2020 2073   ).            s
-0000f2a0: 656c 662e 7368 6f75 6c64 5f74 6572 6d69  elf.should_termi
-0000f2b0: 6e61 7465 203d 2054 7275 650a 2020 2020  nate = True.    
-0000f2c0: 2020 2020 2020 2020 7365 6c66 2e72 6573          self.res
-0000f2d0: 756c 7473 2e73 6f6c 7665 722e 7374 6174  ults.solver.stat
-0000f2e0: 7573 203d 2053 6f6c 7665 7253 7461 7475  us = SolverStatu
-0000f2f0: 732e 6572 726f 720a 0a20 2020 2023 2323  s.error..    ###
-0000f300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000f390: 2323 230a 2020 2020 2320 6974 6572 6174  ###.    # iterat
-0000f3a0: 652e 7079 0a0a 2020 2020 6465 6620 616c  e.py..    def al
-0000f3b0: 676f 7269 7468 6d5f 7368 6f75 6c64 5f74  gorithm_should_t
-0000f3c0: 6572 6d69 6e61 7465 2873 656c 662c 2063  erminate(self, c
-0000f3d0: 6865 636b 5f63 7963 6c69 6e67 293a 0a20  heck_cycling):. 
-0000f3e0: 2020 2020 2020 2022 2222 4368 6563 6b73         """Checks
-0000f3f0: 2069 6620 7468 6520 616c 676f 7269 7468   if the algorith
-0000f400: 6d20 7368 6f75 6c64 2074 6572 6d69 6e61  m should termina
-0000f410: 7465 2061 7420 7468 6520 6769 7665 6e20  te at the given 
-0000f420: 706f 696e 742e 0a0a 2020 2020 2020 2020  point...        
-0000f430: 5468 6973 2066 756e 6374 696f 6e20 6465  This function de
-0000f440: 7465 726d 696e 6573 2077 6865 7468 6572  termines whether
-0000f450: 2074 6865 2061 6c67 6f72 6974 686d 2073   the algorithm s
-0000f460: 686f 756c 6420 7465 726d 696e 6174 6520  hould terminate 
-0000f470: 6261 7365 6420 6f6e 2074 6865 2073 6f6c  based on the sol
-0000f480: 7665 7220 6f70 7469 6f6e 7320 616e 6420  ver options and 
-0000f490: 7072 6f67 7265 7373 2e0a 2020 2020 2020  progress..      
-0000f4a0: 2020 2853 6574 7320 7468 6520 7365 6c66    (Sets the self
-0000f4b0: 2e72 6573 756c 7473 2e73 6f6c 7665 722e  .results.solver.
-0000f4c0: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
-0000f4d0: 6974 696f 6e20 746f 2074 6865 2061 7070  ition to the app
-0000f4e0: 726f 7072 6961 7465 2063 6f6e 6469 7469  ropriate conditi
-0000f4f0: 6f6e 2c20 692e 652e 206f 7074 696d 616c  on, i.e. optimal
-0000f500: 2c0a 2020 2020 2020 2020 6d61 7849 7465  ,.        maxIte
-0000f510: 7261 7469 6f6e 732c 206d 6178 5469 6d65  rations, maxTime
-0000f520: 4c69 6d69 7429 2e0a 0a20 2020 2020 2020  Limit)...       
-0000f530: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-0000f540: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-0000f550: 2020 2020 2020 2063 6865 636b 5f63 7963         check_cyc
-0000f560: 6c69 6e67 203a 2062 6f6f 6c0a 2020 2020  ling : bool.    
-0000f570: 2020 2020 2020 2020 5768 6574 6865 7220          Whether 
-0000f580: 746f 2063 6865 636b 2066 6f72 2061 2073  to check for a s
-0000f590: 7065 6369 616c 2063 6173 6520 7468 6174  pecial case that
-0000f5a0: 2063 6175 7365 7320 7468 6520 6469 7363   causes the disc
-0000f5b0: 7265 7465 2076 6172 6961 626c 6573 2074  rete variables t
-0000f5c0: 6f20 6c6f 6f70 2074 6872 6f75 6768 2074  o loop through t
-0000f5d0: 6865 2073 616d 6520 7661 6c75 6573 2e0a  he same values..
-0000f5e0: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-0000f5f0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-0000f600: 0a20 2020 2020 2020 2062 6f6f 6c0a 2020  .        bool.  
-0000f610: 2020 2020 2020 2020 2020 5472 7565 2069            True i
-0000f620: 6620 7468 6520 616c 676f 7269 7468 6d20  f the algorithm 
-0000f630: 7368 6f75 6c64 2074 6572 6d69 6e61 7465  should terminate
-0000f640: 2c20 4661 6c73 6520 6f74 6865 7277 6973  , False otherwis
-0000f650: 652e 0a20 2020 2020 2020 2022 2222 0a20  e..        """. 
-0000f660: 2020 2020 2020 2069 6620 7365 6c66 2e73         if self.s
-0000f670: 686f 756c 645f 7465 726d 696e 6174 653a  hould_terminate:
-0000f680: 0a20 2020 2020 2020 2020 2020 2023 2073  .            # s
-0000f690: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
-0000f6a0: 5f70 726f 6772 6573 735b 305d 2063 616e  _progress[0] can
-0000f6b0: 206f 6e6c 7920 6265 2069 6e66 206f 7220   only be inf or 
-0000f6c0: 2d69 6e66 2e0a 2020 2020 2020 2020 2020  -inf..          
-0000f6d0: 2020 2320 4966 2074 6865 2063 7572 7265    # If the curre
-0000f6e0: 6e74 2070 7269 6d61 6c20 626f 756e 6420  nt primal bound 
-0000f6f0: 6571 7561 6c73 2069 6e66 206f 7220 2d69  equals inf or -i
-0000f700: 6e66 2c20 7765 2063 616e 2069 6e66 6572  nf, we can infer
-0000f710: 2074 6865 7265 2069 7320 6e6f 2073 6f6c   there is no sol
-0000f720: 7574 696f 6e2e 0a20 2020 2020 2020 2020  ution..         
-0000f730: 2020 2069 6620 7365 6c66 2e70 7269 6d61     if self.prima
-0000f740: 6c5f 626f 756e 6420 3d3d 2073 656c 662e  l_bound == self.
-0000f750: 7072 696d 616c 5f62 6f75 6e64 5f70 726f  primal_bound_pro
-0000f760: 6772 6573 735b 305d 3a0a 2020 2020 2020  gress[0]:.      
-0000f770: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
-0000f780: 6573 756c 7473 2e73 6f6c 7665 722e 7465  esults.solver.te
-0000f790: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
-0000f7a0: 696f 6e20 3d20 7463 2e6e 6f53 6f6c 7574  ion = tc.noSolut
-0000f7b0: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
-0000f7c0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000f7d0: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
-0000f7e0: 7473 2e73 6f6c 7665 722e 7465 726d 696e  ts.solver.termin
-0000f7f0: 6174 696f 6e5f 636f 6e64 6974 696f 6e20  ation_condition 
-0000f800: 3d20 7463 2e66 6561 7369 626c 650a 2020  = tc.feasible.  
-0000f810: 2020 2020 2020 2020 2020 7265 7475 726e            return
-0000f820: 2054 7275 650a 2020 2020 2020 2020 7265   True.        re
-0000f830: 7475 726e 2028 0a20 2020 2020 2020 2020  turn (.         
-0000f840: 2020 2073 656c 662e 626f 756e 6473 5f63     self.bounds_c
-0000f850: 6f6e 7665 7267 6564 2829 0a20 2020 2020  onverged().     
-0000f860: 2020 2020 2020 206f 7220 7365 6c66 2e72         or self.r
-0000f870: 6561 6368 6564 5f69 7465 7261 7469 6f6e  eached_iteration
-0000f880: 5f6c 696d 6974 2829 0a20 2020 2020 2020  _limit().       
-0000f890: 2020 2020 206f 7220 7365 6c66 2e72 6561       or self.rea
-0000f8a0: 6368 6564 5f74 696d 655f 6c69 6d69 7428  ched_time_limit(
-0000f8b0: 290a 2020 2020 2020 2020 2020 2020 6f72  ).            or
-0000f8c0: 2073 656c 662e 7265 6163 6865 645f 7374   self.reached_st
-0000f8d0: 616c 6c69 6e67 5f6c 696d 6974 2829 0a20  alling_limit(). 
-0000f8e0: 2020 2020 2020 2020 2020 206f 7220 2863             or (c
-0000f8f0: 6865 636b 5f63 7963 6c69 6e67 2061 6e64  heck_cycling and
-0000f900: 2073 656c 662e 6974 6572 6174 696f 6e5f   self.iteration_
-0000f910: 6379 636c 696e 6728 2929 0a20 2020 2020  cycling()).     
-0000f920: 2020 2029 0a0a 2020 2020 6465 6620 6669     )..    def fi
-0000f930: 785f 6475 616c 5f62 6f75 6e64 2873 656c  x_dual_bound(sel
-0000f940: 662c 206c 6173 745f 6974 6572 5f63 7574  f, last_iter_cut
-0000f950: 7329 3a0a 2020 2020 2020 2020 2222 2246  s):.        """F
-0000f960: 6978 2074 6865 2064 7561 6c20 626f 756e  ix the dual boun
-0000f970: 6420 7768 656e 206e 6f2d 676f 6f64 2063  d when no-good c
-0000f980: 7574 7320 6f72 2074 6162 7520 6c69 7374  uts or tabu list
-0000f990: 2069 7320 6163 7469 7661 7465 642e 0a0a   is activated...
-0000f9a0: 2020 2020 2020 2020 5061 7261 6d65 7465          Paramete
-0000f9b0: 7273 0a20 2020 2020 2020 202d 2d2d 2d2d  rs.        -----
-0000f9c0: 2d2d 2d2d 2d0a 2020 2020 2020 2020 6c61  -----.        la
-0000f9d0: 7374 5f69 7465 725f 6375 7473 203a 2062  st_iter_cuts : b
-0000f9e0: 6f6f 6c0a 2020 2020 2020 2020 2020 2020  ool.            
-0000f9f0: 5768 6574 6865 7220 7468 6520 6375 7473  Whether the cuts
-0000fa00: 2069 6e20 7468 6520 6c61 7374 2069 7465   in the last ite
-0000fa10: 7261 7469 6f6e 2068 6176 6520 6265 656e  ration have been
-0000fa20: 2061 6464 6564 2e0a 2020 2020 2020 2020   added..        
-0000fa30: 2222 220a 2020 2020 2020 2020 2320 4966  """.        # If
-0000fa40: 206e 6f2d 676f 6f64 2063 7574 7320 6f72   no-good cuts or
-0000fa50: 2074 6162 7520 6c69 7374 2069 7320 6163   tabu list is ac
-0000fa60: 7469 7661 7465 642c 2074 6865 2064 7561  tivated, the dua
-0000fa70: 6c20 626f 756e 6420 6973 206e 6f74 2076  l bound is not v
-0000fa80: 616c 6964 2066 6f72 2074 6865 2066 696e  alid for the fin
-0000fa90: 616c 206f 7074 696d 616c 2073 6f6c 7574  al optimal solut
-0000faa0: 696f 6e2e 0a20 2020 2020 2020 2023 2054  ion..        # T
-0000fab0: 6865 7265 666f 7265 2c20 7765 206e 6565  herefore, we nee
-0000fac0: 6420 746f 2063 6f72 7265 6374 2069 7420  d to correct it 
-0000fad0: 6174 2074 6865 2065 6e64 2e0a 2020 2020  at the end..    
-0000fae0: 2020 2020 2320 496e 2073 696e 676c 6574      # In singlet
-0000faf0: 7265 6520 696d 706c 656d 656e 7461 7469  ree implementati
-0000fb00: 6f6e 2c20 7468 6520 6475 616c 2062 6f75  on, the dual bou
-0000fb10: 6e64 2061 7420 6f6e 6520 6974 6572 6174  nd at one iterat
-0000fb20: 696f 6e20 6265 666f 7265 2074 6865 206f  ion before the o
-0000fb30: 7074 696d 616c 2073 6f6c 7574 696f 6e2c  ptimal solution,
-0000fb40: 2069 7320 7661 6c69 6420 666f 7220 7468   is valid for th
-0000fb50: 6520 6f70 7469 6d61 6c20 736f 6c75 7469  e optimal soluti
-0000fb60: 6f6e 2e0a 2020 2020 2020 2020 2320 536f  on..        # So
-0000fb70: 2077 6520 7769 6c6c 2073 6574 2074 6865   we will set the
-0000fb80: 2064 7561 6c20 626f 756e 6420 746f 2069   dual bound to i
-0000fb90: 742e 0a20 2020 2020 2020 2063 6f6e 6669  t..        confi
-0000fba0: 6720 3d20 7365 6c66 2e63 6f6e 6669 670a  g = self.config.
-0000fbb0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-0000fbc0: 672e 7369 6e67 6c65 5f74 7265 653a 0a20  g.single_tree:. 
-0000fbd0: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
-0000fbe0: 672e 6c6f 6767 6572 2e69 6e66 6f28 0a20  g.logger.info(. 
-0000fbf0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0000fc00: 4669 7820 7468 6520 626f 756e 6420 746f  Fix the bound to
-0000fc10: 2074 6865 2076 616c 7565 206f 6620 6f6e   the value of on
-0000fc20: 6520 6974 6572 6174 696f 6e20 6265 666f  e iteration befo
-0000fc30: 7265 206f 7074 696d 616c 2073 6f6c 7574  re optimal solut
-0000fc40: 696f 6e20 6973 2066 6f75 6e64 2e27 0a20  ion is found.'. 
-0000fc50: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-0000fc60: 2020 2020 2020 2020 2074 7279 3a0a 2020           try:.  
-0000fc70: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0000fc80: 6c66 2e64 7561 6c5f 626f 756e 6420 3d20  lf.dual_bound = 
-0000fc90: 7365 6c66 2e73 746f 7265 645f 626f 756e  self.stored_boun
-0000fca0: 645b 7365 6c66 2e70 7269 6d61 6c5f 626f  d[self.primal_bo
-0000fcb0: 756e 645d 0a20 2020 2020 2020 2020 2020  und].           
-0000fcc0: 2065 7863 6570 7420 4b65 7945 7272 6f72   except KeyError
-0000fcd0: 2061 7320 653a 0a20 2020 2020 2020 2020   as e:.         
-0000fce0: 2020 2020 2020 2063 6f6e 6669 672e 6c6f         config.lo
-0000fcf0: 6767 6572 2e65 7272 6f72 2865 2c20 6578  gger.error(e, ex
-0000fd00: 635f 696e 666f 3d54 7275 6529 0a20 2020  c_info=True).   
-0000fd10: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-0000fd20: 6669 672e 6c6f 6767 6572 2e65 7272 6f72  fig.logger.error
-0000fd30: 2827 4e6f 2073 746f 7265 6420 626f 756e  ('No stored boun
-0000fd40: 6420 666f 756e 642e 2042 6f75 6e64 2066  d found. Bound f
-0000fd50: 6978 2066 6169 6c65 642e 2729 0a20 2020  ix failed.').   
-0000fd60: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-0000fd70: 2020 2020 2020 2063 6f6e 6669 672e 6c6f         config.lo
-0000fd80: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
-0000fd90: 2020 2020 2020 2020 2020 2027 536f 6c76             'Solv
-0000fda0: 6520 7468 6520 6d61 696e 2070 726f 626c  e the main probl
-0000fdb0: 656d 2077 6974 686f 7574 2074 6865 206c  em without the l
-0000fdc0: 6173 7420 6e6f 5f67 6f6f 6420 6375 7420  ast no_good cut 
-0000fdd0: 746f 2066 6978 2074 6865 2062 6f75 6e64  to fix the bound
-0000fde0: 2e27 0a20 2020 2020 2020 2020 2020 2020  .'.             
-0000fdf0: 2020 2027 7a65 726f 5f74 6f6c 6572 616e     'zero_toleran
-0000fe00: 6365 2069 7320 7365 7420 746f 2031 452d  ce is set to 1E-
-0000fe10: 3427 0a20 2020 2020 2020 2020 2020 2029  4'.            )
-0000fe20: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
-0000fe30: 6669 672e 7a65 726f 5f74 6f6c 6572 616e  fig.zero_toleran
-0000fe40: 6365 203d 2031 652d 340a 2020 2020 2020  ce = 1e-4.      
-0000fe50: 2020 2020 2020 2320 536f 6c76 6520 4e4c        # Solve NL
-0000fe60: 5020 7375 6270 726f 626c 656d 0a20 2020  P subproblem.   
-0000fe70: 2020 2020 2020 2020 2023 2054 6865 2063           # The c
-0000fe80: 6f6e 7374 7261 696e 7420 6c69 6e65 6172  onstraint linear
-0000fe90: 697a 6174 696f 6e20 6861 7070 656e 7320  ization happens 
-0000fea0: 696e 2074 6865 2068 616e 646c 6572 730a  in the handlers.
-0000feb0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-0000fec0: 6f74 206c 6173 745f 6974 6572 5f63 7574  ot last_iter_cut
-0000fed0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
-0000fee0: 2020 2066 6978 6564 5f6e 6c70 2c20 6669     fixed_nlp, fi
-0000fef0: 7865 645f 6e6c 705f 7265 7375 6c74 203d  xed_nlp_result =
-0000ff00: 2073 656c 662e 736f 6c76 655f 7375 6270   self.solve_subp
-0000ff10: 726f 626c 656d 2829 0a20 2020 2020 2020  roblem().       
-0000ff20: 2020 2020 2020 2020 2073 656c 662e 6861           self.ha
-0000ff30: 6e64 6c65 5f6e 6c70 5f73 7562 7072 6f62  ndle_nlp_subprob
-0000ff40: 6c65 6d5f 7463 2866 6978 6564 5f6e 6c70  lem_tc(fixed_nlp
-0000ff50: 2c20 6669 7865 645f 6e6c 705f 7265 7375  , fixed_nlp_resu
-0000ff60: 6c74 290a 0a20 2020 2020 2020 2020 2020  lt)..           
-0000ff70: 204d 696e 6474 5079 203d 2073 656c 662e   MindtPy = self.
-0000ff80: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
-0000ff90: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
-0000ffa0: 4465 6163 7469 7661 7465 2074 6865 2069  Deactivate the i
-0000ffb0: 6e74 6567 6572 2063 7574 7320 6765 6e65  nteger cuts gene
-0000ffc0: 7261 7465 6420 6166 7465 7220 7468 6520  rated after the 
-0000ffd0: 6265 7374 2073 6f6c 7574 696f 6e20 7761  best solution wa
-0000ffe0: 7320 666f 756e 642e 0a20 2020 2020 2020  s found..       
-0000fff0: 2020 2020 2073 656c 662e 6465 6163 7469       self.deacti
-00010000: 7661 7465 5f6e 6f5f 676f 6f64 5f63 7574  vate_no_good_cut
-00010010: 735f 7768 656e 5f66 6978 696e 675f 626f  s_when_fixing_bo
-00010020: 756e 6428 4d69 6e64 7450 792e 6375 7473  und(MindtPy.cuts
-00010030: 2e6e 6f5f 676f 6f64 5f63 7574 7329 0a20  .no_good_cuts). 
-00010040: 2020 2020 2020 2020 2020 2069 6620 280a             if (.
-00010050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010060: 636f 6e66 6967 2e61 6464 5f72 6567 756c  config.add_regul
-00010070: 6172 697a 6174 696f 6e20 6973 206e 6f74  arization is not
-00010080: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-00010090: 2020 2020 2020 616e 6420 4d69 6e64 7450        and MindtP
-000100a0: 792e 636f 6d70 6f6e 656e 7428 276d 6970  y.component('mip
-000100b0: 5f6f 626a 2729 2069 7320 4e6f 6e65 0a20  _obj') is None. 
-000100c0: 2020 2020 2020 2020 2020 2029 3a0a 2020             ):.  
-000100d0: 2020 2020 2020 2020 2020 2020 2020 4d69                Mi
-000100e0: 6e64 7450 792e 6f62 6a65 6374 6976 655f  ndtPy.objective_
-000100f0: 6c69 7374 5b2d 315d 2e61 6374 6976 6174  list[-1].activat
-00010100: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-00010110: 2320 6465 7465 726d 696e 6520 6966 2070  # determine if p
-00010120: 6572 7369 7374 656e 7420 736f 6c76 6572  ersistent solver
-00010130: 2069 7320 6361 6c6c 6564 2e0a 2020 2020   is called..    
-00010140: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00010150: 7461 6e63 6528 7365 6c66 2e6d 6970 5f6f  tance(self.mip_o
-00010160: 7074 2c20 5065 7273 6973 7465 6e74 536f  pt, PersistentSo
-00010170: 6c76 6572 293a 0a20 2020 2020 2020 2020  lver):.         
-00010180: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-00010190: 6f70 742e 7365 745f 696e 7374 616e 6365  opt.set_instance
-000101a0: 2873 656c 662e 6d69 702c 2073 796d 626f  (self.mip, symbo
-000101b0: 6c69 635f 736f 6c76 6572 5f6c 6162 656c  lic_solver_label
-000101c0: 733d 5472 7565 290a 2020 2020 2020 2020  s=True).        
-000101d0: 2020 2020 6d69 705f 6172 6773 203d 2064      mip_args = d
-000101e0: 6963 7428 636f 6e66 6967 2e6d 6970 5f73  ict(config.mip_s
-000101f0: 6f6c 7665 725f 6172 6773 290a 2020 2020  olver_args).    
-00010200: 2020 2020 2020 2020 7570 6461 7465 5f73          update_s
-00010210: 6f6c 7665 725f 7469 6d65 6c69 6d69 7428  olver_timelimit(
-00010220: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010230: 2073 656c 662e 6d69 705f 6f70 742c 2063   self.mip_opt, c
-00010240: 6f6e 6669 672e 6d69 705f 736f 6c76 6572  onfig.mip_solver
-00010250: 2c20 7365 6c66 2e74 696d 696e 672c 2063  , self.timing, c
-00010260: 6f6e 6669 670a 2020 2020 2020 2020 2020  onfig.          
-00010270: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00010280: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
-00010290: 203d 2073 656c 662e 6d69 705f 6f70 742e   = self.mip_opt.
-000102a0: 736f 6c76 6528 0a20 2020 2020 2020 2020  solve(.         
-000102b0: 2020 2020 2020 2073 656c 662e 6d69 702c         self.mip,
-000102c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000102d0: 2074 6565 3d63 6f6e 6669 672e 6d69 705f   tee=config.mip_
-000102e0: 736f 6c76 6572 5f74 6565 2c0a 2020 2020  solver_tee,.    
-000102f0: 2020 2020 2020 2020 2020 2020 6c6f 6164              load
-00010300: 5f73 6f6c 7574 696f 6e73 3d73 656c 662e  _solutions=self.
-00010310: 6c6f 6164 5f73 6f6c 7574 696f 6e73 2c0a  load_solutions,.
-00010320: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010330: 2a2a 6d69 705f 6172 6773 2c0a 2020 2020  **mip_args,.    
-00010340: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00010350: 2020 2020 2020 6966 206c 656e 286d 6169        if len(mai
-00010360: 6e5f 6d69 705f 7265 7375 6c74 732e 736f  n_mip_results.so
-00010370: 6c75 7469 6f6e 2920 3e20 303a 0a20 2020  lution) > 0:.   
-00010380: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-00010390: 662e 6d69 702e 736f 6c75 7469 6f6e 732e  f.mip.solutions.
-000103a0: 6c6f 6164 5f66 726f 6d28 6d61 696e 5f6d  load_from(main_m
-000103b0: 6970 5f72 6573 756c 7473 290a 0a20 2020  ip_results)..   
-000103c0: 2020 2020 2020 2020 2069 6620 6d61 696e           if main
-000103d0: 5f6d 6970 5f72 6573 756c 7473 2e73 6f6c  _mip_results.sol
-000103e0: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-000103f0: 636f 6e64 6974 696f 6e20 6973 2074 632e  condition is tc.
-00010400: 696e 6665 6173 6962 6c65 3a0a 2020 2020  infeasible:.    
-00010410: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-00010420: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-00010430: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010440: 2020 2020 2742 6f75 6e64 2066 6978 2066      'Bound fix f
-00010450: 6169 6c65 642e 2054 6865 2062 6f75 6e64  ailed. The bound
-00010460: 2066 6978 2070 726f 626c 656d 2069 7320   fix problem is 
-00010470: 696e 6665 6173 6962 6c65 270a 2020 2020  infeasible'.    
-00010480: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00010490: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000104a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000104b0: 7365 6c66 2e75 7064 6174 655f 7375 626f  self.update_subo
-000104c0: 7074 696d 616c 5f64 7561 6c5f 626f 756e  ptimal_dual_boun
-000104d0: 6428 6d61 696e 5f6d 6970 5f72 6573 756c  d(main_mip_resul
-000104e0: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
-000104f0: 2020 2020 636f 6e66 6967 2e6c 6f67 6765      config.logge
-00010500: 722e 696e 666f 280a 2020 2020 2020 2020  r.info(.        
-00010510: 2020 2020 2020 2020 2020 2020 2746 6978              'Fix
-00010520: 6564 2062 6f75 6e64 2076 616c 7565 733a  ed bound values:
-00010530: 2050 7269 6d61 6c20 426f 756e 643a 207b   Primal Bound: {
-00010540: 7d20 2044 7561 6c20 426f 756e 643a 207b  }  Dual Bound: {
-00010550: 7d27 2e66 6f72 6d61 7428 0a20 2020 2020  }'.format(.     
-00010560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010570: 2020 2073 656c 662e 7072 696d 616c 5f62     self.primal_b
-00010580: 6f75 6e64 2c20 7365 6c66 2e64 7561 6c5f  ound, self.dual_
-00010590: 626f 756e 640a 2020 2020 2020 2020 2020  bound.          
-000105a0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000105b0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000105c0: 2020 2020 2020 2020 2020 2320 4368 6563            # Chec
-000105d0: 6b20 626f 756e 6420 636f 6e76 6572 6765  k bound converge
-000105e0: 6e63 650a 2020 2020 2020 2020 2020 2020  nce.            
-000105f0: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
-00010600: 2020 2020 2061 6273 2873 656c 662e 7072       abs(self.pr
-00010610: 696d 616c 5f62 6f75 6e64 202d 2073 656c  imal_bound - sel
-00010620: 662e 6475 616c 5f62 6f75 6e64 290a 2020  f.dual_bound).  
-00010630: 2020 2020 2020 2020 2020 2020 2020 3c3d                <=
-00010640: 2063 6f6e 6669 672e 6162 736f 6c75 7465   config.absolute
-00010650: 5f62 6f75 6e64 5f74 6f6c 6572 616e 6365  _bound_tolerance
-00010660: 0a20 2020 2020 2020 2020 2020 2029 3a0a  .            ):.
-00010670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00010680: 7365 6c66 2e72 6573 756c 7473 2e73 6f6c  self.results.sol
-00010690: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-000106a0: 636f 6e64 6974 696f 6e20 3d20 7463 2e6f  condition = tc.o
-000106b0: 7074 696d 616c 0a0a 2020 2020 6465 6620  ptimal..    def 
-000106c0: 7365 745f 7570 5f74 6162 756c 6973 745f  set_up_tabulist_
-000106d0: 6361 6c6c 6261 636b 2873 656c 6629 3a0a  callback(self):.
-000106e0: 2020 2020 2020 2020 2222 2253 6574 7320          """Sets 
-000106f0: 7570 2074 6865 2074 6162 756c 6973 7420  up the tabulist 
-00010700: 7573 696e 6720 496e 6375 6d62 656e 7443  using IncumbentC
-00010710: 616c 6c62 6163 6b2e 0a20 2020 2020 2020  allback..       
-00010720: 2043 7572 7265 6e74 6c79 206f 6e6c 7920   Currently only 
-00010730: 7375 7070 6f72 7420 4350 4c45 582e 0a20  support CPLEX.. 
-00010740: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00010750: 2020 2074 6162 756c 6973 7420 3d20 7365     tabulist = se
-00010760: 6c66 2e6d 6970 5f6f 7074 2e5f 736f 6c76  lf.mip_opt._solv
-00010770: 6572 5f6d 6f64 656c 2e72 6567 6973 7465  er_model.registe
-00010780: 725f 6361 6c6c 6261 636b 280a 2020 2020  r_callback(.    
-00010790: 2020 2020 2020 2020 7461 6275 5f6c 6973          tabu_lis
-000107a0: 742e 496e 6375 6d62 656e 7443 616c 6c62  t.IncumbentCallb
-000107b0: 6163 6b5f 6370 6c65 780a 2020 2020 2020  ack_cplex.      
-000107c0: 2020 290a 2020 2020 2020 2020 7461 6275    ).        tabu
-000107d0: 6c69 7374 2e6f 7074 203d 2073 656c 662e  list.opt = self.
-000107e0: 6d69 705f 6f70 740a 2020 2020 2020 2020  mip_opt.        
-000107f0: 7461 6275 6c69 7374 2e63 6f6e 6669 6720  tabulist.config 
-00010800: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-00010810: 2020 2020 2020 7461 6275 6c69 7374 2e6d        tabulist.m
-00010820: 696e 6474 7079 5f73 6f6c 7665 7220 3d20  indtpy_solver = 
-00010830: 7365 6c66 0a20 2020 2020 2020 2073 656c  self.        sel
-00010840: 662e 6d69 705f 6f70 742e 6f70 7469 6f6e  f.mip_opt.option
-00010850: 735b 2770 7265 7072 6f63 6573 7369 6e67  s['preprocessing
-00010860: 5f72 6564 7563 6527 5d20 3d20 310a 2020  _reduce'] = 1.  
-00010870: 2020 2020 2020 2320 4966 2074 6865 2063        # If the c
-00010880: 616c 6c62 6163 6b20 6973 2075 7365 6420  allback is used 
-00010890: 746f 2072 656a 6563 7420 696e 6375 6d62  to reject incumb
-000108a0: 656e 7473 2c20 7468 6520 7573 6572 206d  ents, the user m
-000108b0: 7573 7420 7365 7420 7468 650a 2020 2020  ust set the.    
-000108c0: 2020 2020 2320 7061 7261 6d65 7465 7220      # parameter 
-000108d0: 632e 7061 7261 6d65 7465 7273 2e70 7265  c.parameters.pre
-000108e0: 7072 6f63 6573 7369 6e67 2e72 6564 7563  processing.reduc
-000108f0: 6520 6569 7468 6572 2074 6f20 7468 6520  e either to the 
-00010900: 7661 6c75 6520 3120 286f 6e65 290a 2020  value 1 (one).  
-00010910: 2020 2020 2020 2320 746f 2072 6573 7472        # to restr
-00010920: 6963 7420 7072 6573 6f6c 7665 2074 6f20  ict presolve to 
-00010930: 7072 696d 616c 2072 6564 7563 7469 6f6e  primal reduction
-00010940: 7320 6f6e 6c79 206f 7220 746f 2030 2028  s only or to 0 (
-00010950: 7a65 726f 2920 746f 2064 6973 6162 6c65  zero) to disable
-00010960: 2061 6c6c 2070 7265 736f 6c76 6520 7265   all presolve re
-00010970: 6475 6374 696f 6e73 0a20 2020 2020 2020  ductions.       
-00010980: 2073 656c 662e 6d69 705f 6f70 742e 5f73   self.mip_opt._s
-00010990: 6f6c 7665 725f 6d6f 6465 6c2e 7365 745f  olver_model.set_
-000109a0: 7761 726e 696e 675f 7374 7265 616d 284e  warning_stream(N
-000109b0: 6f6e 6529 0a20 2020 2020 2020 2073 656c  one).        sel
-000109c0: 662e 6d69 705f 6f70 742e 5f73 6f6c 7665  f.mip_opt._solve
-000109d0: 725f 6d6f 6465 6c2e 7365 745f 6c6f 675f  r_model.set_log_
-000109e0: 7374 7265 616d 284e 6f6e 6529 0a20 2020  stream(None).   
-000109f0: 2020 2020 2073 656c 662e 6d69 705f 6f70       self.mip_op
-00010a00: 742e 5f73 6f6c 7665 725f 6d6f 6465 6c2e  t._solver_model.
-00010a10: 7365 745f 6572 726f 725f 7374 7265 616d  set_error_stream
-00010a20: 284e 6f6e 6529 0a0a 2020 2020 6465 6620  (None)..    def 
-00010a30: 7365 745f 7570 5f6c 617a 795f 4f41 5f63  set_up_lazy_OA_c
-00010a40: 616c 6c62 6163 6b28 7365 6c66 293a 0a20  allback(self):. 
-00010a50: 2020 2020 2020 2022 2222 5365 7473 2075         """Sets u
-00010a60: 7020 7468 6520 6c61 7a79 204f 4120 7573  p the lazy OA us
-00010a70: 696e 6720 4c61 7a79 436f 6e73 7472 6169  ing LazyConstrai
-00010a80: 6e74 4361 6c6c 6261 636b 2e0a 2020 2020  ntCallback..    
-00010a90: 2020 2020 4375 7272 656e 746c 7920 6f6e      Currently on
-00010aa0: 6c79 2073 7570 706f 7274 2043 504c 4558  ly support CPLEX
-00010ab0: 2061 6e64 2047 7572 6f62 692e 0a20 2020   and Gurobi..   
-00010ac0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-00010ad0: 2069 6620 7365 6c66 2e63 6f6e 6669 672e   if self.config.
-00010ae0: 6d69 705f 736f 6c76 6572 203d 3d20 2763  mip_solver == 'c
-00010af0: 706c 6578 5f70 6572 7369 7374 656e 7427  plex_persistent'
-00010b00: 3a0a 2020 2020 2020 2020 2020 2020 6c61  :.            la
-00010b10: 7a79 6f61 203d 2073 656c 662e 6d69 705f  zyoa = self.mip_
-00010b20: 6f70 742e 5f73 6f6c 7665 725f 6d6f 6465  opt._solver_mode
-00010b30: 6c2e 7265 6769 7374 6572 5f63 616c 6c62  l.register_callb
-00010b40: 6163 6b28 0a20 2020 2020 2020 2020 2020  ack(.           
-00010b50: 2020 2020 2073 696e 676c 655f 7472 6565       single_tree
-00010b60: 2e4c 617a 794f 4143 616c 6c62 6163 6b5f  .LazyOACallback_
-00010b70: 6370 6c65 780a 2020 2020 2020 2020 2020  cplex.          
-00010b80: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00010b90: 2320 7061 7373 206e 6563 6573 7361 7279  # pass necessary
-00010ba0: 2064 6174 6120 616e 6420 7061 7261 6d65   data and parame
-00010bb0: 7465 7273 2074 6f20 6c61 7a79 6f61 0a20  ters to lazyoa. 
-00010bc0: 2020 2020 2020 2020 2020 206c 617a 796f             lazyo
-00010bd0: 612e 6d61 696e 5f6d 6970 203d 2073 656c  a.main_mip = sel
-00010be0: 662e 6d69 700a 2020 2020 2020 2020 2020  f.mip.          
-00010bf0: 2020 6c61 7a79 6f61 2e63 6f6e 6669 6720    lazyoa.config 
-00010c00: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-00010c10: 2020 2020 2020 2020 2020 6c61 7a79 6f61            lazyoa
-00010c20: 2e6f 7074 203d 2073 656c 662e 6d69 705f  .opt = self.mip_
-00010c30: 6f70 740a 2020 2020 2020 2020 2020 2020  opt.            
-00010c40: 6c61 7a79 6f61 2e6d 696e 6474 7079 5f73  lazyoa.mindtpy_s
-00010c50: 6f6c 7665 7220 3d20 7365 6c66 0a20 2020  olver = self.   
-00010c60: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-00010c70: 705f 6f70 742e 5f73 6f6c 7665 725f 6d6f  p_opt._solver_mo
-00010c80: 6465 6c2e 7365 745f 7761 726e 696e 675f  del.set_warning_
-00010c90: 7374 7265 616d 284e 6f6e 6529 0a20 2020  stream(None).   
-00010ca0: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-00010cb0: 705f 6f70 742e 5f73 6f6c 7665 725f 6d6f  p_opt._solver_mo
-00010cc0: 6465 6c2e 7365 745f 6c6f 675f 7374 7265  del.set_log_stre
-00010cd0: 616d 284e 6f6e 6529 0a20 2020 2020 2020  am(None).       
-00010ce0: 2020 2020 2073 656c 662e 6d69 705f 6f70       self.mip_op
-00010cf0: 742e 5f73 6f6c 7665 725f 6d6f 6465 6c2e  t._solver_model.
-00010d00: 7365 745f 6572 726f 725f 7374 7265 616d  set_error_stream
-00010d10: 284e 6f6e 6529 0a20 2020 2020 2020 2069  (None).        i
-00010d20: 6620 7365 6c66 2e63 6f6e 6669 672e 6d69  f self.config.mi
-00010d30: 705f 736f 6c76 6572 203d 3d20 2767 7572  p_solver == 'gur
-00010d40: 6f62 695f 7065 7273 6973 7465 6e74 273a  obi_persistent':
-00010d50: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00010d60: 662e 6d69 705f 6f70 742e 7365 745f 6361  f.mip_opt.set_ca
-00010d70: 6c6c 6261 636b 2873 696e 676c 655f 7472  llback(single_tr
-00010d80: 6565 2e4c 617a 794f 4143 616c 6c62 6163  ee.LazyOACallbac
-00010d90: 6b5f 6775 726f 6269 290a 2020 2020 2020  k_gurobi).      
-00010da0: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
-00010db0: 7074 2e6d 696e 6474 7079 5f73 6f6c 7665  pt.mindtpy_solve
-00010dc0: 7220 3d20 7365 6c66 0a20 2020 2020 2020  r = self.       
-00010dd0: 2020 2020 2073 656c 662e 6d69 705f 6f70       self.mip_op
-00010de0: 742e 636f 6e66 6967 203d 2073 656c 662e  t.config = self.
-00010df0: 636f 6e66 6967 0a0a 2020 2020 2323 2323  config..    ####
-00010e00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010e80: 2323 2323 2323 0a20 2020 2023 206d 6970  ######.    # mip
-00010e90: 5f73 6f6c 7665 2e70 790a 0a20 2020 2064  _solve.py..    d
-00010ea0: 6566 2073 6f6c 7665 5f6d 6169 6e28 7365  ef solve_main(se
-00010eb0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
-00010ec0: 5468 6973 2066 756e 6374 696f 6e20 736f  This function so
-00010ed0: 6c76 6573 2074 6865 204d 4950 206d 6169  lves the MIP mai
-00010ee0: 6e20 7072 6f62 6c65 6d2e 0a0a 2020 2020  n problem...    
-00010ef0: 2020 2020 5265 7475 726e 730a 2020 2020      Returns.    
-00010f00: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
-00010f10: 2020 2020 7365 6c66 2e6d 6970 203a 2050      self.mip : P
-00010f20: 796f 6d6f 206d 6f64 656c 0a20 2020 2020  yomo model.     
-00010f30: 2020 2020 2020 2054 6865 204d 4950 2073         The MIP s
-00010f40: 746f 7265 6420 696e 2073 656c 662e 0a20  tored in self.. 
-00010f50: 2020 2020 2020 206d 6169 6e5f 6d69 705f         main_mip_
-00010f60: 7265 7375 6c74 7320 3a20 536f 6c76 6572  results : Solver
-00010f70: 5265 7375 6c74 730a 2020 2020 2020 2020  Results.        
-00010f80: 2020 2020 5265 7375 6c74 7320 6672 6f6d      Results from
-00010f90: 2073 6f6c 7669 6e67 2074 6865 206d 6169   solving the mai
-00010fa0: 6e20 4d49 502e 0a20 2020 2020 2020 2022  n MIP..        "
-00010fb0: 2222 0a20 2020 2020 2020 2063 6f6e 6669  "".        confi
-00010fc0: 6720 3d20 7365 6c66 2e63 6f6e 6669 670a  g = self.config.
-00010fd0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-00010fe0: 5f69 7465 7220 2b3d 2031 0a0a 2020 2020  _iter += 1..    
-00010ff0: 2020 2020 2320 7365 7475 7020 6d61 696e      # setup main
-00011000: 2070 726f 626c 656d 0a20 2020 2020 2020   problem.       
-00011010: 2073 656c 662e 7365 7475 705f 6d61 696e   self.setup_main
-00011020: 2829 0a20 2020 2020 2020 206d 6970 5f61  ().        mip_a
-00011030: 7267 7320 3d20 7365 6c66 2e73 6574 5f75  rgs = self.set_u
-00011040: 705f 6d69 705f 736f 6c76 6572 2829 0a20  p_mip_solver(). 
-00011050: 2020 2020 2020 2075 7064 6174 655f 736f         update_so
-00011060: 6c76 6572 5f74 696d 656c 696d 6974 2873  lver_timelimit(s
-00011070: 656c 662e 6d69 705f 6f70 742c 2063 6f6e  elf.mip_opt, con
-00011080: 6669 672e 6d69 705f 736f 6c76 6572 2c20  fig.mip_solver, 
-00011090: 7365 6c66 2e74 696d 696e 672c 2063 6f6e  self.timing, con
-000110a0: 6669 6729 0a0a 2020 2020 2020 2020 7472  fig)..        tr
-000110b0: 793a 0a20 2020 2020 2020 2020 2020 206d  y:.            m
-000110c0: 6169 6e5f 6d69 705f 7265 7375 6c74 7320  ain_mip_results 
-000110d0: 3d20 7365 6c66 2e6d 6970 5f6f 7074 2e73  = self.mip_opt.s
-000110e0: 6f6c 7665 280a 2020 2020 2020 2020 2020  olve(.          
-000110f0: 2020 2020 2020 7365 6c66 2e6d 6970 2c0a        self.mip,.
-00011100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011110: 7465 653d 636f 6e66 6967 2e6d 6970 5f73  tee=config.mip_s
-00011120: 6f6c 7665 725f 7465 652c 0a20 2020 2020  olver_tee,.     
-00011130: 2020 2020 2020 2020 2020 206c 6f61 645f             load_
-00011140: 736f 6c75 7469 6f6e 733d 7365 6c66 2e6c  solutions=self.l
-00011150: 6f61 645f 736f 6c75 7469 6f6e 732c 0a20  oad_solutions,. 
-00011160: 2020 2020 2020 2020 2020 2020 2020 202a                 *
-00011170: 2a6d 6970 5f61 7267 732c 0a20 2020 2020  *mip_args,.     
-00011180: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00011190: 2020 2020 2023 2075 7064 6174 655f 6174       # update_at
-000111a0: 7472 6962 7574 6573 2073 686f 756c 6420  tributes should 
-000111b0: 6265 2062 6566 6f72 6520 6c6f 6164 5f66  be before load_f
-000111c0: 726f 6d28 6d61 696e 5f6d 6970 5f72 6573  rom(main_mip_res
-000111d0: 756c 7473 292c 2073 696e 6365 206c 6f61  ults), since loa
-000111e0: 645f 6672 6f6d 286d 6169 6e5f 6d69 705f  d_from(main_mip_
-000111f0: 7265 7375 6c74 7329 206d 6179 2066 6169  results) may fai
-00011200: 6c2e 0a20 2020 2020 2020 2020 2020 2069  l..            i
-00011210: 6620 6c65 6e28 6d61 696e 5f6d 6970 5f72  f len(main_mip_r
-00011220: 6573 756c 7473 2e73 6f6c 7574 696f 6e29  esults.solution)
-00011230: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
-00011240: 2020 2020 2020 7365 6c66 2e6d 6970 2e73        self.mip.s
-00011250: 6f6c 7574 696f 6e73 2e6c 6f61 645f 6672  olutions.load_fr
-00011260: 6f6d 286d 6169 6e5f 6d69 705f 7265 7375  om(main_mip_resu
-00011270: 6c74 7329 0a20 2020 2020 2020 2065 7863  lts).        exc
-00011280: 6570 7420 2856 616c 7565 4572 726f 722c  ept (ValueError,
-00011290: 2041 7474 7269 6275 7465 4572 726f 722c   AttributeError,
-000112a0: 2052 756e 7469 6d65 4572 726f 7229 2061   RuntimeError) a
-000112b0: 7320 653a 0a20 2020 2020 2020 2020 2020  s e:.           
-000112c0: 2063 6f6e 6669 672e 6c6f 6767 6572 2e65   config.logger.e
-000112d0: 7272 6f72 2865 2c20 6578 635f 696e 666f  rror(e, exc_info
-000112e0: 3d54 7275 6529 0a20 2020 2020 2020 2020  =True).         
-000112f0: 2020 2069 6620 636f 6e66 6967 2e73 696e     if config.sin
-00011300: 676c 655f 7472 6565 3a0a 2020 2020 2020  gle_tree:.      
-00011310: 2020 2020 2020 2020 2020 636f 6e66 6967            config
-00011320: 2e6c 6f67 6765 722e 7761 726e 696e 6728  .logger.warning(
-00011330: 2753 696e 676c 6520 7472 6565 2074 6572  'Single tree ter
-00011340: 6d69 6e61 7465 2e27 290a 2020 2020 2020  minate.').      
-00011350: 2020 2020 2020 2020 2020 6966 2067 6574            if get
-00011360: 5f6d 6169 6e5f 656c 6170 7365 645f 7469  _main_elapsed_ti
-00011370: 6d65 2873 656c 662e 7469 6d69 6e67 2920  me(self.timing) 
-00011380: 3e3d 2063 6f6e 6669 672e 7469 6d65 5f6c  >= config.time_l
-00011390: 696d 6974 3a0a 2020 2020 2020 2020 2020  imit:.          
-000113a0: 2020 2020 2020 2020 2020 636f 6e66 6967            config
-000113b0: 2e6c 6f67 6765 722e 7761 726e 696e 6728  .logger.warning(
-000113c0: 2764 7565 2074 6f20 7468 6520 7469 6d65  'due to the time
-000113d0: 6c69 6d69 742e 2729 0a20 2020 2020 2020  limit.').       
-000113e0: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000113f0: 662e 7265 7375 6c74 732e 736f 6c76 6572  f.results.solver
-00011400: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-00011410: 6469 7469 6f6e 203d 2074 632e 6d61 7854  dition = tc.maxT
-00011420: 696d 654c 696d 6974 0a20 2020 2020 2020  imeLimit.       
-00011430: 2020 2020 2020 2020 2069 6620 636f 6e66           if conf
-00011440: 6967 2e73 7472 6174 6567 7920 3d3d 2027  ig.strategy == '
-00011450: 474f 4127 206f 7220 636f 6e66 6967 2e61  GOA' or config.a
-00011460: 6464 5f6e 6f5f 676f 6f64 5f63 7574 733a  dd_no_good_cuts:
-00011470: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011480: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-00011490: 6572 2e77 6172 6e69 6e67 280a 2020 2020  er.warning(.    
-000114a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000114b0: 2020 2020 2745 7272 6f72 3a20 4361 6e6e      'Error: Cann
-000114c0: 6f74 206c 6f61 6420 6120 536f 6c76 6572  ot load a Solver
-000114d0: 5265 7375 6c74 7320 6f62 6a65 6374 2077  Results object w
-000114e0: 6974 6820 6261 6420 7374 6174 7573 3a20  ith bad status: 
-000114f0: 6572 726f 722e 2027 0a20 2020 2020 2020  error. '.       
-00011500: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011510: 2027 4d49 5020 736f 6c76 6572 2066 6169   'MIP solver fai
-00011520: 6c65 642e 2054 6869 7320 7573 7561 6c6c  led. This usuall
-00011530: 7920 6861 7070 656e 7320 696e 2074 6865  y happens in the
-00011540: 2073 696e 676c 652d 7472 6565 2047 4f41   single-tree GOA
-00011550: 2061 6c67 6f72 6974 686d 2e20 270a 2020   algorithm. '.  
-00011560: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011570: 2020 2020 2020 224e 6f2d 676f 6f64 2063        "No-good c
-00011580: 7574 7320 6172 6520 6164 6465 6420 616e  uts are added an
-00011590: 6420 474f 4120 616c 676f 7269 7468 6d20  d GOA algorithm 
-000115a0: 646f 6573 6e27 7420 636f 6e76 6572 6765  doesn't converge
-000115b0: 2077 6974 6869 6e20 7468 6520 7469 6d65   within the time
-000115c0: 206c 696d 6974 2e20 220a 2020 2020 2020   limit. ".      
-000115d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000115e0: 2020 274e 6f20 696e 7465 6765 7220 736f    'No integer so
-000115f0: 6c75 7469 6f6e 2069 7320 666f 756e 642c  lution is found,
-00011600: 2073 6f20 7468 6520 4350 4c45 5820 736f   so the CPLEX so
-00011610: 6c76 6572 2077 696c 6c20 7265 706f 7274  lver will report
-00011620: 2061 6e20 6572 726f 7220 7374 6174 7573   an error status
-00011630: 2e20 270a 2020 2020 2020 2020 2020 2020  . '.            
-00011640: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00011650: 2020 2020 2020 2320 5661 6c75 6520 6572        # Value er
-00011660: 726f 7220 7769 6c6c 2062 6520 7261 6973  ror will be rais
-00011670: 6564 2069 6620 7468 6520 4d49 5020 7072  ed if the MIP pr
-00011680: 6f62 6c65 6d20 6973 2075 6e62 6f75 6e64  oblem is unbound
-00011690: 6564 2061 6e64 2061 7070 7369 2073 6f6c  ed and appsi sol
-000116a0: 7665 7220 6973 2075 7365 6420 7768 656e  ver is used when
-000116b0: 206c 6f61 6469 6e67 2073 6f6c 7574 696f   loading solutio
-000116c0: 6e73 2e20 416c 7468 6f75 6768 2074 6865  ns. Although the
-000116d0: 2070 726f 626c 656d 2069 7320 756e 626f   problem is unbo
-000116e0: 756e 6465 642c 2061 2076 616c 6964 2072  unded, a valid r
-000116f0: 6573 756c 7420 6973 2070 726f 7669 6465  esult is provide
-00011700: 6420 616e 6420 7765 2064 6f20 6e6f 7420  d and we do not 
-00011710: 7265 7475 726e 204e 6f6e 6520 746f 206c  return None to l
-00011720: 6574 2074 6865 2061 6c67 6f72 6974 686d  et the algorithm
-00011730: 2063 6f6e 7469 6e75 652e 0a20 2020 2020   continue..     
-00011740: 2020 2020 2020 2069 6620 276d 6169 6e5f         if 'main_
-00011750: 6d69 705f 7265 7375 6c74 7327 2069 6e20  mip_results' in 
-00011760: 6c6f 6361 6c73 2829 3a0a 2020 2020 2020  locals():.      
-00011770: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00011780: 2073 656c 662e 6d69 702c 206d 6169 6e5f   self.mip, main_
-00011790: 6d69 705f 7265 7375 6c74 730a 2020 2020  mip_results.    
-000117a0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000117b0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-000117c0: 7475 726e 204e 6f6e 652c 204e 6f6e 650a  turn None, None.
-000117d0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-000117e0: 672e 736f 6c75 7469 6f6e 5f70 6f6f 6c3a  g.solution_pool:
-000117f0: 0a20 2020 2020 2020 2020 2020 206d 6169  .            mai
-00011800: 6e5f 6d69 705f 7265 7375 6c74 732e 5f73  n_mip_results._s
-00011810: 6f6c 7665 725f 6d6f 6465 6c20 3d20 7365  olver_model = se
-00011820: 6c66 2e6d 6970 5f6f 7074 2e5f 736f 6c76  lf.mip_opt._solv
-00011830: 6572 5f6d 6f64 656c 0a20 2020 2020 2020  er_model.       
-00011840: 2020 2020 206d 6169 6e5f 6d69 705f 7265       main_mip_re
-00011850: 7375 6c74 732e 5f70 796f 6d6f 5f76 6172  sults._pyomo_var
-00011860: 5f74 6f5f 736f 6c76 6572 5f76 6172 5f6d  _to_solver_var_m
-00011870: 6170 203d 2028 0a20 2020 2020 2020 2020  ap = (.         
-00011880: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-00011890: 6f70 742e 5f70 796f 6d6f 5f76 6172 5f74  opt._pyomo_var_t
-000118a0: 6f5f 736f 6c76 6572 5f76 6172 5f6d 6170  o_solver_var_map
-000118b0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-000118c0: 2020 2020 2020 2069 6620 6d61 696e 5f6d         if main_m
-000118d0: 6970 5f72 6573 756c 7473 2e73 6f6c 7665  ip_results.solve
-000118e0: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-000118f0: 6e64 6974 696f 6e20 6973 2074 632e 6f70  ndition is tc.op
-00011900: 7469 6d61 6c3a 0a20 2020 2020 2020 2020  timal:.         
-00011910: 2020 2069 6620 636f 6e66 6967 2e73 696e     if config.sin
-00011920: 676c 655f 7472 6565 2061 6e64 206e 6f74  gle_tree and not
-00011930: 2063 6f6e 6669 672e 6164 645f 6e6f 5f67   config.add_no_g
-00011940: 6f6f 645f 6375 7473 3a0a 2020 2020 2020  ood_cuts:.      
-00011950: 2020 2020 2020 2020 2020 7365 6c66 2e75            self.u
-00011960: 7064 6174 655f 7375 626f 7074 696d 616c  pdate_suboptimal
-00011970: 5f64 7561 6c5f 626f 756e 6428 6d61 696e  _dual_bound(main
-00011980: 5f6d 6970 5f72 6573 756c 7473 290a 2020  _mip_results).  
-00011990: 2020 2020 2020 656c 6966 206d 6169 6e5f        elif main_
-000119a0: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
-000119b0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
-000119c0: 6f6e 6469 7469 6f6e 2069 7320 7463 2e69  ondition is tc.i
-000119d0: 6e66 6561 7369 626c 654f 7255 6e62 6f75  nfeasibleOrUnbou
-000119e0: 6e64 6564 3a0a 2020 2020 2020 2020 2020  nded:.          
-000119f0: 2020 2320 4c69 6e65 6172 2073 6f6c 7665    # Linear solve
-00011a00: 7273 2077 696c 6c20 736f 6d65 7469 6d65  rs will sometime
-00011a10: 7320 7465 6c6c 206d 6520 7468 6174 2069  s tell me that i
-00011a20: 7427 7320 696e 6665 6173 6962 6c65 206f  t's infeasible o
-00011a30: 720a 2020 2020 2020 2020 2020 2020 2320  r.            # 
-00011a40: 756e 626f 756e 6465 6420 6475 7269 6e67  unbounded during
-00011a50: 2070 7265 736f 6c76 652c 2062 7574 2066   presolve, but f
-00011a60: 6169 6c73 2074 6f20 6469 7374 696e 6775  ails to distingu
-00011a70: 6973 682e 2057 6520 6e65 6564 2074 6f0a  ish. We need to.
-00011a80: 2020 2020 2020 2020 2020 2020 2320 7265              # re
-00011a90: 736f 6c76 6520 7769 7468 2061 2073 6f6c  solve with a sol
-00011aa0: 7665 7220 6f70 7469 6f6e 2066 6c61 6720  ver option flag 
-00011ab0: 6f6e 2e0a 2020 2020 2020 2020 2020 2020  on..            
-00011ac0: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
-00011ad0: 2c20 5f20 3d20 6469 7374 696e 6775 6973  , _ = distinguis
-00011ae0: 685f 6d69 705f 696e 6665 6173 6962 6c65  h_mip_infeasible
-00011af0: 5f6f 725f 756e 626f 756e 6465 6428 0a20  _or_unbounded(. 
-00011b00: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00011b10: 656c 662e 6d69 702c 2063 6f6e 6669 670a  elf.mip, config.
-00011b20: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00011b30: 2020 2020 2020 7265 7475 726e 2073 656c        return sel
-00011b40: 662e 6d69 702c 206d 6169 6e5f 6d69 705f  f.mip, main_mip_
-00011b50: 7265 7375 6c74 730a 0a20 2020 2064 6566  results..    def
-00011b60: 2073 6f6c 7665 5f66 705f 6d61 696e 2873   solve_fp_main(s
-00011b70: 656c 6629 3a0a 2020 2020 2020 2020 2222  elf):.        ""
-00011b80: 2254 6869 7320 6675 6e63 7469 6f6e 2073  "This function s
-00011b90: 6f6c 7665 7320 7468 6520 4d49 5020 6d61  olves the MIP ma
-00011ba0: 696e 2070 726f 626c 656d 2e0a 0a20 2020  in problem...   
-00011bb0: 2020 2020 2052 6574 7572 6e73 0a20 2020       Returns.   
-00011bc0: 2020 2020 202d 2d2d 2d2d 2d2d 0a20 2020       -------.   
-00011bd0: 2020 2020 2073 656c 662e 6d69 7020 3a20       self.mip : 
-00011be0: 5079 6f6d 6f20 6d6f 6465 6c0a 2020 2020  Pyomo model.    
-00011bf0: 2020 2020 2020 2020 5468 6520 4d49 5020          The MIP 
-00011c00: 7374 6f72 6564 2069 6e20 7365 6c66 2e0a  stored in self..
-00011c10: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-00011c20: 5f72 6573 756c 7473 203a 2053 6f6c 7665  _results : Solve
-00011c30: 7252 6573 756c 7473 0a20 2020 2020 2020  rResults.       
-00011c40: 2020 2020 2052 6573 756c 7473 2066 726f       Results fro
-00011c50: 6d20 736f 6c76 696e 6720 7468 6520 6d61  m solving the ma
-00011c60: 696e 204d 4950 2e0a 2020 2020 2020 2020  in MIP..        
-00011c70: 2222 220a 2020 2020 2020 2020 2320 7365  """.        # se
-00011c80: 7475 7020 6d61 696e 2070 726f 626c 656d  tup main problem
-00011c90: 0a20 2020 2020 2020 2063 6f6e 6669 6720  .        config 
-00011ca0: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-00011cb0: 2020 2020 2020 7365 6c66 2e73 6574 7570        self.setup
-00011cc0: 5f66 705f 6d61 696e 2829 0a20 2020 2020  _fp_main().     
-00011cd0: 2020 206d 6970 5f61 7267 7320 3d20 7365     mip_args = se
-00011ce0: 6c66 2e73 6574 5f75 705f 6d69 705f 736f  lf.set_up_mip_so
-00011cf0: 6c76 6572 2829 0a20 2020 2020 2020 2075  lver().        u
-00011d00: 7064 6174 655f 736f 6c76 6572 5f74 696d  pdate_solver_tim
-00011d10: 656c 696d 6974 2873 656c 662e 6d69 705f  elimit(self.mip_
-00011d20: 6f70 742c 2063 6f6e 6669 672e 6d69 705f  opt, config.mip_
-00011d30: 736f 6c76 6572 2c20 7365 6c66 2e74 696d  solver, self.tim
-00011d40: 696e 672c 2063 6f6e 6669 6729 0a0a 2020  ing, config)..  
-00011d50: 2020 2020 2020 6d61 696e 5f6d 6970 5f72        main_mip_r
-00011d60: 6573 756c 7473 203d 2073 656c 662e 6d69  esults = self.mi
-00011d70: 705f 6f70 742e 736f 6c76 6528 0a20 2020  p_opt.solve(.   
-00011d80: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-00011d90: 702c 0a20 2020 2020 2020 2020 2020 2074  p,.            t
-00011da0: 6565 3d63 6f6e 6669 672e 6d69 705f 736f  ee=config.mip_so
-00011db0: 6c76 6572 5f74 6565 2c0a 2020 2020 2020  lver_tee,.      
-00011dc0: 2020 2020 2020 6c6f 6164 5f73 6f6c 7574        load_solut
-00011dd0: 696f 6e73 3d73 656c 662e 6c6f 6164 5f73  ions=self.load_s
-00011de0: 6f6c 7574 696f 6e73 2c0a 2020 2020 2020  olutions,.      
-00011df0: 2020 2020 2020 2a2a 6d69 705f 6172 6773        **mip_args
-00011e00: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
-00011e10: 2020 2020 2320 7570 6461 7465 5f61 7474      # update_att
-00011e20: 7269 6275 7465 7320 7368 6f75 6c64 2062  ributes should b
-00011e30: 6520 6265 666f 7265 206c 6f61 645f 6672  e before load_fr
-00011e40: 6f6d 286d 6169 6e5f 6d69 705f 7265 7375  om(main_mip_resu
-00011e50: 6c74 7329 2c20 7369 6e63 6520 6c6f 6164  lts), since load
-00011e60: 5f66 726f 6d28 6d61 696e 5f6d 6970 5f72  _from(main_mip_r
-00011e70: 6573 756c 7473 2920 6d61 7920 6661 696c  esults) may fail
-00011e80: 2e0a 2020 2020 2020 2020 2320 6966 2063  ..        # if c
-00011e90: 6f6e 6669 672e 7369 6e67 6c65 5f74 7265  onfig.single_tre
-00011ea0: 6520 6f72 2063 6f6e 6669 672e 7573 655f  e or config.use_
-00011eb0: 7461 6275 5f6c 6973 743a 0a20 2020 2020  tabu_list:.     
-00011ec0: 2020 2023 2020 2020 2073 656c 662e 7570     #     self.up
-00011ed0: 6461 7465 5f61 7474 7269 6275 7465 7328  date_attributes(
-00011ee0: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
-00011ef0: 286d 6169 6e5f 6d69 705f 7265 7375 6c74  (main_mip_result
-00011f00: 732e 736f 6c75 7469 6f6e 2920 3e20 303a  s.solution) > 0:
-00011f10: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00011f20: 662e 6d69 702e 736f 6c75 7469 6f6e 732e  f.mip.solutions.
-00011f30: 6c6f 6164 5f66 726f 6d28 6d61 696e 5f6d  load_from(main_m
-00011f40: 6970 5f72 6573 756c 7473 290a 2020 2020  ip_results).    
-00011f50: 2020 2020 6966 206d 6169 6e5f 6d69 705f      if main_mip_
-00011f60: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
-00011f70: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-00011f80: 7469 6f6e 2069 7320 7463 2e69 6e66 6561  tion is tc.infea
-00011f90: 7369 626c 654f 7255 6e62 6f75 6e64 6564  sibleOrUnbounded
-00011fa0: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
-00011fb0: 4c69 6e65 6172 2073 6f6c 7665 7273 2077  Linear solvers w
-00011fc0: 696c 6c20 736f 6d65 7469 6d65 7320 7465  ill sometimes te
-00011fd0: 6c6c 206d 6520 7468 6174 2069 7427 7320  ll me that it's 
-00011fe0: 696e 6665 6173 6962 6c65 206f 720a 2020  infeasible or.  
-00011ff0: 2020 2020 2020 2020 2020 2320 756e 626f            # unbo
-00012000: 756e 6465 6420 6475 7269 6e67 2070 7265  unded during pre
-00012010: 736f 6c76 652c 2062 7574 2066 6169 6c73  solve, but fails
-00012020: 2074 6f20 6469 7374 696e 6775 6973 682e   to distinguish.
-00012030: 2057 6520 6e65 6564 2074 6f0a 2020 2020   We need to.    
-00012040: 2020 2020 2020 2020 2320 7265 736f 6c76          # resolv
-00012050: 6520 7769 7468 2061 2073 6f6c 7665 7220  e with a solver 
-00012060: 6f70 7469 6f6e 2066 6c61 6720 6f6e 2e0a  option flag on..
-00012070: 2020 2020 2020 2020 2020 2020 6d61 696e              main
-00012080: 5f6d 6970 5f72 6573 756c 7473 2c20 5f20  _mip_results, _ 
-00012090: 3d20 6469 7374 696e 6775 6973 685f 6d69  = distinguish_mi
-000120a0: 705f 696e 6665 6173 6962 6c65 5f6f 725f  p_infeasible_or_
-000120b0: 756e 626f 756e 6465 6428 0a20 2020 2020  unbounded(.     
-000120c0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000120d0: 6d69 702c 2063 6f6e 6669 670a 2020 2020  mip, config.    
-000120e0: 2020 2020 2020 2020 290a 0a20 2020 2020          )..     
-000120f0: 2020 2072 6574 7572 6e20 7365 6c66 2e6d     return self.m
-00012100: 6970 2c20 6d61 696e 5f6d 6970 5f72 6573  ip, main_mip_res
-00012110: 756c 7473 0a0a 2020 2020 6465 6620 736f  ults..    def so
-00012120: 6c76 655f 7265 6775 6c61 7269 7a61 7469  lve_regularizati
-00012130: 6f6e 5f6d 6169 6e28 7365 6c66 293a 0a20  on_main(self):. 
-00012140: 2020 2020 2020 2022 2222 5468 6973 2066         """This f
-00012150: 756e 6374 696f 6e20 736f 6c76 6573 2074  unction solves t
-00012160: 6865 204d 4950 206d 6169 6e20 7072 6f62  he MIP main prob
-00012170: 6c65 6d2e 0a0a 2020 2020 2020 2020 5265  lem...        Re
-00012180: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
-00012190: 2d2d 2d2d 2d0a 2020 2020 2020 2020 7365  -----.        se
-000121a0: 6c66 2e6d 6970 203a 2050 796f 6d6f 206d  lf.mip : Pyomo m
-000121b0: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
-000121c0: 2054 6865 204d 4950 2073 746f 7265 6420   The MIP stored 
-000121d0: 696e 2073 656c 662e 0a20 2020 2020 2020  in self..       
-000121e0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
-000121f0: 7320 3a20 536f 6c76 6572 5265 7375 6c74  s : SolverResult
-00012200: 730a 2020 2020 2020 2020 2020 2020 5265  s.            Re
-00012210: 7375 6c74 7320 6672 6f6d 2073 6f6c 7669  sults from solvi
-00012220: 6e67 2074 6865 206d 6169 6e20 4d49 502e  ng the main MIP.
-00012230: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
-00012240: 2020 2020 2063 6f6e 6669 6720 3d20 7365       config = se
-00012250: 6c66 2e63 6f6e 6669 670a 2020 2020 2020  lf.config.      
-00012260: 2020 2320 7365 7475 7020 6d61 696e 2070    # setup main p
-00012270: 726f 626c 656d 0a20 2020 2020 2020 2073  roblem.        s
-00012280: 656c 662e 7365 7475 705f 7265 6775 6c61  elf.setup_regula
-00012290: 7269 7a61 7469 6f6e 5f6d 6169 6e28 290a  rization_main().
-000122a0: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
-000122b0: 7374 616e 6365 2873 656c 662e 7265 6775  stance(self.regu
-000122c0: 6c61 7269 7a61 7469 6f6e 5f6d 6970 5f6f  larization_mip_o
-000122d0: 7074 2c20 5065 7273 6973 7465 6e74 536f  pt, PersistentSo
-000122e0: 6c76 6572 293a 0a20 2020 2020 2020 2020  lver):.         
-000122f0: 2020 2073 656c 662e 7265 6775 6c61 7269     self.regulari
-00012300: 7a61 7469 6f6e 5f6d 6970 5f6f 7074 2e73  zation_mip_opt.s
-00012310: 6574 5f69 6e73 7461 6e63 6528 7365 6c66  et_instance(self
-00012320: 2e6d 6970 290a 2020 2020 2020 2020 7570  .mip).        up
-00012330: 6461 7465 5f73 6f6c 7665 725f 7469 6d65  date_solver_time
-00012340: 6c69 6d69 7428 0a20 2020 2020 2020 2020  limit(.         
-00012350: 2020 2073 656c 662e 7265 6775 6c61 7269     self.regulari
-00012360: 7a61 7469 6f6e 5f6d 6970 5f6f 7074 2c0a  zation_mip_opt,.
-00012370: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-00012380: 6967 2e6d 6970 5f72 6567 756c 6172 697a  ig.mip_regulariz
-00012390: 6174 696f 6e5f 736f 6c76 6572 2c0a 2020  ation_solver,.  
-000123a0: 2020 2020 2020 2020 2020 7365 6c66 2e74            self.t
-000123b0: 696d 696e 672c 0a20 2020 2020 2020 2020  iming,.         
-000123c0: 2020 2063 6f6e 6669 672c 0a20 2020 2020     config,.     
-000123d0: 2020 2029 0a20 2020 2020 2020 206d 6169     ).        mai
-000123e0: 6e5f 6d69 705f 7265 7375 6c74 7320 3d20  n_mip_results = 
-000123f0: 7365 6c66 2e72 6567 756c 6172 697a 6174  self.regularizat
-00012400: 696f 6e5f 6d69 705f 6f70 742e 736f 6c76  ion_mip_opt.solv
-00012410: 6528 0a20 2020 2020 2020 2020 2020 2073  e(.            s
-00012420: 656c 662e 6d69 702c 0a20 2020 2020 2020  elf.mip,.       
-00012430: 2020 2020 2074 6565 3d63 6f6e 6669 672e       tee=config.
-00012440: 6d69 705f 736f 6c76 6572 5f74 6565 2c0a  mip_solver_tee,.
-00012450: 2020 2020 2020 2020 2020 2020 6c6f 6164              load
-00012460: 5f73 6f6c 7574 696f 6e73 3d73 656c 662e  _solutions=self.
-00012470: 6c6f 6164 5f73 6f6c 7574 696f 6e73 2c0a  load_solutions,.
-00012480: 2020 2020 2020 2020 2020 2020 2a2a 6469              **di
-00012490: 6374 2863 6f6e 6669 672e 6d69 705f 736f  ct(config.mip_so
-000124a0: 6c76 6572 5f61 7267 7329 2c0a 2020 2020  lver_args),.    
-000124b0: 2020 2020 290a 2020 2020 2020 2020 6966      ).        if
-000124c0: 206c 656e 286d 6169 6e5f 6d69 705f 7265   len(main_mip_re
-000124d0: 7375 6c74 732e 736f 6c75 7469 6f6e 2920  sults.solution) 
-000124e0: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
-000124f0: 2073 656c 662e 6d69 702e 736f 6c75 7469   self.mip.soluti
-00012500: 6f6e 732e 6c6f 6164 5f66 726f 6d28 6d61  ons.load_from(ma
-00012510: 696e 5f6d 6970 5f72 6573 756c 7473 290a  in_mip_results).
-00012520: 2020 2020 2020 2020 6966 206d 6169 6e5f          if main_
-00012530: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
-00012540: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
-00012550: 6f6e 6469 7469 6f6e 2069 7320 7463 2e6f  ondition is tc.o
-00012560: 7074 696d 616c 3a0a 2020 2020 2020 2020  ptimal:.        
-00012570: 2020 2020 636f 6e66 6967 2e6c 6f67 6765      config.logge
-00012580: 722e 696e 666f 280a 2020 2020 2020 2020  r.info(.        
-00012590: 2020 2020 2020 2020 7365 6c66 2e6c 6f67          self.log
-000125a0: 5f66 6f72 6d61 7474 6572 2e66 6f72 6d61  _formatter.forma
-000125b0: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-000125c0: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-000125d0: 6974 6572 2c0a 2020 2020 2020 2020 2020  iter,.          
-000125e0: 2020 2020 2020 2020 2020 2752 6567 2027            'Reg '
-000125f0: 202b 2073 656c 662e 7265 6775 6c61 7269   + self.regulari
-00012600: 7a61 7469 6f6e 5f6d 6970 5f74 7970 652c  zation_mip_type,
-00012610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00012620: 2020 2020 2076 616c 7565 2873 656c 662e       value(self.
-00012630: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
-00012640: 732e 726f 615f 7072 6f6a 5f6d 6970 5f6f  s.roa_proj_mip_o
-00012650: 626a 292c 0a20 2020 2020 2020 2020 2020  bj),.           
-00012660: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-00012670: 696d 616c 5f62 6f75 6e64 2c0a 2020 2020  imal_bound,.    
-00012680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012690: 7365 6c66 2e64 7561 6c5f 626f 756e 642c  self.dual_bound,
-000126a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000126b0: 2020 2020 2073 656c 662e 7265 6c5f 6761       self.rel_ga
-000126c0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-000126d0: 2020 2020 2020 2067 6574 5f6d 6169 6e5f         get_main_
-000126e0: 656c 6170 7365 645f 7469 6d65 2873 656c  elapsed_time(sel
-000126f0: 662e 7469 6d69 6e67 292c 0a20 2020 2020  f.timing),.     
-00012700: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00012710: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-00012720: 2020 2020 656c 6966 206d 6169 6e5f 6d69      elif main_mi
-00012730: 705f 7265 7375 6c74 732e 736f 6c76 6572  p_results.solver
-00012740: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-00012750: 6469 7469 6f6e 2069 7320 7463 2e69 6e66  dition is tc.inf
-00012760: 6561 7369 626c 654f 7255 6e62 6f75 6e64  easibleOrUnbound
-00012770: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
-00012780: 2320 4c69 6e65 6172 2073 6f6c 7665 7273  # Linear solvers
-00012790: 2077 696c 6c20 736f 6d65 7469 6d65 7320   will sometimes 
-000127a0: 7465 6c6c 206d 6520 7468 6174 2069 7427  tell me that it'
-000127b0: 7320 696e 6665 6173 6962 6c65 206f 720a  s infeasible or.
-000127c0: 2020 2020 2020 2020 2020 2020 2320 756e              # un
-000127d0: 626f 756e 6465 6420 6475 7269 6e67 2070  bounded during p
-000127e0: 7265 736f 6c76 652c 2062 7574 2066 6169  resolve, but fai
-000127f0: 6c73 2074 6f20 6469 7374 696e 6775 6973  ls to distinguis
-00012800: 682e 2057 6520 6e65 6564 2074 6f0a 2020  h. We need to.  
-00012810: 2020 2020 2020 2020 2020 2320 7265 736f            # reso
-00012820: 6c76 6520 7769 7468 2061 2073 6f6c 7665  lve with a solve
-00012830: 7220 6f70 7469 6f6e 2066 6c61 6720 6f6e  r option flag on
-00012840: 2e0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
-00012850: 696e 5f6d 6970 5f72 6573 756c 7473 2c20  in_mip_results, 
-00012860: 5f20 3d20 6469 7374 696e 6775 6973 685f  _ = distinguish_
-00012870: 6d69 705f 696e 6665 6173 6962 6c65 5f6f  mip_infeasible_o
-00012880: 725f 756e 626f 756e 6465 6428 0a20 2020  r_unbounded(.   
-00012890: 2020 2020 2020 2020 2020 2020 2073 656c               sel
-000128a0: 662e 6d69 702c 2063 6f6e 6669 670a 2020  f.mip, config.  
-000128b0: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
-000128c0: 2020 2020 2073 656c 662e 6d69 702e 4d69       self.mip.Mi
-000128d0: 6e64 7450 795f 7574 696c 732e 6f62 6a65  ndtPy_utils.obje
-000128e0: 6374 6976 655f 636f 6e73 7472 2e64 6561  ctive_constr.dea
-000128f0: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
-00012900: 2020 7365 6c66 2e6d 6970 2e4d 696e 6474    self.mip.Mindt
-00012910: 5079 5f75 7469 6c73 2e64 656c 5f63 6f6d  Py_utils.del_com
-00012920: 706f 6e65 6e74 2827 726f 615f 7072 6f6a  ponent('roa_proj
-00012930: 5f6d 6970 5f6f 626a 2729 0a20 2020 2020  _mip_obj').     
-00012940: 2020 2073 656c 662e 6d69 702e 4d69 6e64     self.mip.Mind
-00012950: 7450 795f 7574 696c 732e 6375 7473 2e64  tPy_utils.cuts.d
-00012960: 656c 5f63 6f6d 706f 6e65 6e74 2827 6f62  el_component('ob
-00012970: 6a5f 7265 675f 6573 7469 6d61 7465 2729  j_reg_estimate')
-00012980: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
-00012990: 6967 2e61 6464 5f72 6567 756c 6172 697a  ig.add_regulariz
-000129a0: 6174 696f 6e20 3d3d 2027 6c65 7665 6c5f  ation == 'level_
-000129b0: 4c31 273a 0a20 2020 2020 2020 2020 2020  L1':.           
-000129c0: 2073 656c 662e 6d69 702e 4d69 6e64 7450   self.mip.MindtP
-000129d0: 795f 7574 696c 732e 6465 6c5f 636f 6d70  y_utils.del_comp
-000129e0: 6f6e 656e 7428 274c 315f 6f62 6a27 290a  onent('L1_obj').
-000129f0: 2020 2020 2020 2020 656c 6966 2063 6f6e          elif con
-00012a00: 6669 672e 6164 645f 7265 6775 6c61 7269  fig.add_regulari
-00012a10: 7a61 7469 6f6e 203d 3d20 276c 6576 656c  zation == 'level
-00012a20: 5f4c 5f69 6e66 696e 6974 7927 3a0a 2020  _L_infinity':.  
-00012a30: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
-00012a40: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
-00012a50: 2e64 656c 5f63 6f6d 706f 6e65 6e74 2827  .del_component('
-00012a60: 4c5f 696e 6669 6e69 7479 5f6f 626a 2729  L_infinity_obj')
-00012a70: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
-00012a80: 2073 656c 662e 6d69 702c 206d 6169 6e5f   self.mip, main_
-00012a90: 6d69 705f 7265 7375 6c74 730a 0a20 2020  mip_results..   
-00012aa0: 2064 6566 2073 6574 5f75 705f 6d69 705f   def set_up_mip_
-00012ab0: 736f 6c76 6572 2873 656c 6629 3a0a 2020  solver(self):.  
-00012ac0: 2020 2020 2020 2222 2253 6574 2075 7020        """Set up 
-00012ad0: 7468 6520 4d49 5020 736f 6c76 6572 2e0a  the MIP solver..
-00012ae0: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
-00012af0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-00012b00: 0a20 2020 2020 2020 206d 6169 6e6f 7074  .        mainopt
-00012b10: 203a 2053 6f6c 7665 7246 6163 746f 7279   : SolverFactory
-00012b20: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00012b30: 2063 7573 746f 6d69 7a65 6420 4d49 5020   customized MIP 
-00012b40: 736f 6c76 6572 2e0a 2020 2020 2020 2020  solver..        
-00012b50: 2222 220a 2020 2020 2020 2020 2320 6465  """.        # de
-00012b60: 7465 726d 696e 6520 6966 2070 6572 7369  termine if persi
-00012b70: 7374 656e 7420 736f 6c76 6572 2069 7320  stent solver is 
-00012b80: 6361 6c6c 6564 2e0a 2020 2020 2020 2020  called..        
-00012b90: 636f 6e66 6967 203d 2073 656c 662e 636f  config = self.co
-00012ba0: 6e66 6967 0a20 2020 2020 2020 2069 6620  nfig.        if 
-00012bb0: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
-00012bc0: 6d69 705f 6f70 742c 2050 6572 7369 7374  mip_opt, Persist
-00012bd0: 656e 7453 6f6c 7665 7229 3a0a 2020 2020  entSolver):.    
-00012be0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-00012bf0: 5f6f 7074 2e73 6574 5f69 6e73 7461 6e63  _opt.set_instanc
-00012c00: 6528 7365 6c66 2e6d 6970 2c20 7379 6d62  e(self.mip, symb
-00012c10: 6f6c 6963 5f73 6f6c 7665 725f 6c61 6265  olic_solver_labe
-00012c20: 6c73 3d54 7275 6529 0a20 2020 2020 2020  ls=True).       
-00012c30: 2069 6620 636f 6e66 6967 2e73 696e 676c   if config.singl
-00012c40: 655f 7472 6565 3a0a 2020 2020 2020 2020  e_tree:.        
-00012c50: 2020 2020 7365 6c66 2e73 6574 5f75 705f      self.set_up_
-00012c60: 6c61 7a79 5f4f 415f 6361 6c6c 6261 636b  lazy_OA_callback
-00012c70: 2829 0a20 2020 2020 2020 2069 6620 636f  ().        if co
-00012c80: 6e66 6967 2e75 7365 5f74 6162 755f 6c69  nfig.use_tabu_li
-00012c90: 7374 3a0a 2020 2020 2020 2020 2020 2020  st:.            
-00012ca0: 7365 6c66 2e73 6574 5f75 705f 7461 6275  self.set_up_tabu
-00012cb0: 6c69 7374 5f63 616c 6c62 6163 6b28 290a  list_callback().
-00012cc0: 2020 2020 2020 2020 6d69 705f 6172 6773          mip_args
-00012cd0: 203d 2064 6963 7428 636f 6e66 6967 2e6d   = dict(config.m
-00012ce0: 6970 5f73 6f6c 7665 725f 6172 6773 290a  ip_solver_args).
-00012cf0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-00012d00: 672e 6d69 705f 736f 6c76 6572 2069 6e20  g.mip_solver in 
-00012d10: 7b0a 2020 2020 2020 2020 2020 2020 2763  {.            'c
-00012d20: 706c 6578 272c 0a20 2020 2020 2020 2020  plex',.         
-00012d30: 2020 2027 6370 6c65 785f 7065 7273 6973     'cplex_persis
-00012d40: 7465 6e74 272c 0a20 2020 2020 2020 2020  tent',.         
-00012d50: 2020 2027 6775 726f 6269 272c 0a20 2020     'gurobi',.   
-00012d60: 2020 2020 2020 2020 2027 6775 726f 6269           'gurobi
-00012d70: 5f70 6572 7369 7374 656e 7427 2c0a 2020  _persistent',.  
-00012d80: 2020 2020 2020 7d3a 0a20 2020 2020 2020        }:.       
-00012d90: 2020 2020 206d 6970 5f61 7267 735b 2777       mip_args['w
-00012da0: 6172 6d73 7461 7274 275d 203d 2054 7275  armstart'] = Tru
-00012db0: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
-00012dc0: 206d 6970 5f61 7267 730a 0a20 2020 2023   mip_args..    #
-00012dd0: 2054 6865 2066 6f6c 6c6f 7769 6e67 2066   The following f
-00012de0: 756e 6374 696f 6e73 2064 6561 6c20 7769  unctions deal wi
-00012df0: 7468 2068 616e 646c 696e 6720 7468 6520  th handling the 
-00012e00: 736f 6c75 7469 6f6e 2077 6520 6765 7420  solution we get 
-00012e10: 6672 6f6d 2074 6865 2061 626f 7665 204d  from the above M
-00012e20: 4950 2073 6f6c 7665 7220 6675 6e63 7469  IP solver functi
-00012e30: 6f6e 0a0a 2020 2020 6465 6620 6861 6e64  on..    def hand
-00012e40: 6c65 5f6d 6169 6e5f 6f70 7469 6d61 6c28  le_main_optimal(
-00012e50: 7365 6c66 2c20 6d61 696e 5f6d 6970 2c20  self, main_mip, 
-00012e60: 7570 6461 7465 5f62 6f75 6e64 3d54 7275  update_bound=Tru
-00012e70: 6529 3a0a 2020 2020 2020 2020 2222 2254  e):.        """T
-00012e80: 6869 7320 6675 6e63 7469 6f6e 2063 6f70  his function cop
-00012e90: 6965 7320 7468 6520 7265 7375 6c74 7320  ies the results 
-00012ea0: 6672 6f6d 2027 736f 6c76 655f 6d61 696e  from 'solve_main
-00012eb0: 2720 746f 2074 6865 2077 6f72 6b69 6e67  ' to the working
-00012ec0: 206d 6f64 656c 2061 6e64 2075 7064 6174   model and updat
-00012ed0: 6573 0a20 2020 2020 2020 2074 6865 2075  es.        the u
-00012ee0: 7070 6572 2f6c 6f77 6572 2062 6f75 6e64  pper/lower bound
-00012ef0: 2e20 5468 6973 2066 756e 6374 696f 6e20  . This function 
-00012f00: 6973 2063 616c 6c65 6420 6166 7465 7220  is called after 
-00012f10: 616e 206f 7074 696d 616c 2073 6f6c 7574  an optimal solut
-00012f20: 696f 6e20 6973 2066 6f75 6e64 2066 6f72  ion is found for
-00012f30: 0a20 2020 2020 2020 2074 6865 206d 6169  .        the mai
-00012f40: 6e20 7072 6f62 6c65 6d2e 0a0a 2020 2020  n problem...    
-00012f50: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
-00012f60: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
-00012f70: 2d0a 2020 2020 2020 2020 6d61 696e 5f6d  -.        main_m
-00012f80: 6970 203a 2050 796f 6d6f 206d 6f64 656c  ip : Pyomo model
-00012f90: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00012fa0: 204d 4950 206d 6169 6e20 7072 6f62 6c65   MIP main proble
-00012fb0: 6d2e 0a20 2020 2020 2020 2075 7064 6174  m..        updat
-00012fc0: 655f 626f 756e 6420 3a20 626f 6f6c 2c20  e_bound : bool, 
-00012fd0: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
-00012fe0: 2020 2020 2057 6865 7468 6572 2074 6f20       Whether to 
-00012ff0: 7570 6461 7465 2074 6865 2062 6f75 6e64  update the bound
-00013000: 2c20 6279 2064 6566 6175 6c74 2054 7275  , by default Tru
-00013010: 652e 0a20 2020 2020 2020 2020 2020 2042  e..            B
-00013020: 6f75 6e64 2077 696c 6c20 6e6f 7420 6265  ound will not be
-00013030: 2075 7064 6174 6564 2077 6865 6e20 6861   updated when ha
-00013040: 6e64 6c69 6e67 2072 6567 756c 6172 697a  ndling regulariz
-00013050: 6174 696f 6e20 7072 6f62 6c65 6d2e 0a20  ation problem.. 
-00013060: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-00013070: 2020 2023 2070 726f 6365 6564 2e20 4a75     # proceed. Ju
-00013080: 7374 206e 6565 6420 696e 7465 6765 7220  st need integer 
-00013090: 7661 6c75 6573 0a20 2020 2020 2020 204d  values.        M
-000130a0: 696e 6474 5079 203d 206d 6169 6e5f 6d69  indtPy = main_mi
-000130b0: 702e 4d69 6e64 7450 795f 7574 696c 730a  p.MindtPy_utils.
-000130c0: 2020 2020 2020 2020 2320 6368 6563 6b20          # check 
-000130d0: 6966 2074 6865 2076 616c 7565 206f 6620  if the value of 
-000130e0: 6269 6e61 7279 2076 6172 6961 626c 6520  binary variable 
-000130f0: 6973 2076 616c 6964 0a20 2020 2020 2020  is valid.       
-00013100: 2066 6f72 2076 6172 2069 6e20 4d69 6e64   for var in Mind
-00013110: 7450 792e 6469 7363 7265 7465 5f76 6172  tPy.discrete_var
-00013120: 6961 626c 655f 6c69 7374 3a0a 2020 2020  iable_list:.    
-00013130: 2020 2020 2020 2020 6966 2076 6172 2e76          if var.v
-00013140: 616c 7565 2069 7320 4e6f 6e65 3a0a 2020  alue is None:.  
-00013150: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00013160: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
-00013170: 2e77 6172 6e69 6e67 280a 2020 2020 2020  .warning(.      
-00013180: 2020 2020 2020 2020 2020 2020 2020 6622                f"
-00013190: 496e 7465 6765 7220 7661 7269 6162 6c65  Integer variable
-000131a0: 207b 7661 722e 6e61 6d65 7d20 6e6f 7420   {var.name} not 
-000131b0: 696e 6974 6961 6c69 7a65 642e 2020 220a  initialized.  ".
-000131c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000131d0: 2020 2020 2253 6574 7469 6e67 2069 7420      "Setting it 
-000131e0: 746f 2069 7473 206c 6f77 6572 2062 6f75  to its lower bou
-000131f0: 6e64 220a 2020 2020 2020 2020 2020 2020  nd".            
-00013200: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-00013210: 2020 2020 2020 7661 722e 7365 745f 7661        var.set_va
-00013220: 6c75 6528 7661 722e 6c62 2c20 736b 6970  lue(var.lb, skip
-00013230: 5f76 616c 6964 6174 696f 6e3d 5472 7565  _validation=True
-00013240: 290a 2020 2020 2020 2020 2320 7761 726d  ).        # warm
-00013250: 2073 7461 7274 2066 6f72 2074 6865 206e   start for the n
-00013260: 6c70 2073 7562 7072 6f62 6c65 6d0a 2020  lp subproblem.  
-00013270: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
-00013280: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
-00013290: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-000132a0: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-000132b0: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-000132c0: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
-000132d0: 6978 6564 5f6e 6c70 2e4d 696e 6474 5079  ixed_nlp.MindtPy
-000132e0: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
-000132f0: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
-00013300: 2020 7365 6c66 2e63 6f6e 6669 672c 0a20    self.config,. 
-00013310: 2020 2020 2020 2020 2020 2073 6b69 705f             skip_
-00013320: 6669 7865 643d 4661 6c73 652c 0a20 2020  fixed=False,.   
-00013330: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
-00013340: 6966 2075 7064 6174 655f 626f 756e 643a  if update_bound:
-00013350: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00013360: 662e 7570 6461 7465 5f64 7561 6c5f 626f  f.update_dual_bo
-00013370: 756e 6428 7661 6c75 6528 4d69 6e64 7450  und(value(MindtP
-00013380: 792e 6d69 705f 6f62 6a2e 6578 7072 2929  y.mip_obj.expr))
-00013390: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000133a0: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
-000133b0: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-000133c0: 2020 2020 2020 7365 6c66 2e6c 6f67 5f66        self.log_f
-000133d0: 6f72 6d61 7474 6572 2e66 6f72 6d61 7428  ormatter.format(
-000133e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000133f0: 2020 2020 2073 656c 662e 6d69 705f 6974       self.mip_it
-00013400: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
-00013410: 2020 2020 2020 2020 274d 494c 5027 2c0a          'MILP',.
-00013420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013430: 2020 2020 7661 6c75 6528 4d69 6e64 7450      value(MindtP
-00013440: 792e 6d69 705f 6f62 6a2e 6578 7072 292c  y.mip_obj.expr),
-00013450: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013460: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
-00013470: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
-00013480: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00013490: 2e64 7561 6c5f 626f 756e 642c 0a20 2020  .dual_bound,.   
-000134a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000134b0: 2073 656c 662e 7265 6c5f 6761 702c 0a20   self.rel_gap,. 
-000134c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000134d0: 2020 2067 6574 5f6d 6169 6e5f 656c 6170     get_main_elap
-000134e0: 7365 645f 7469 6d65 2873 656c 662e 7469  sed_time(self.ti
-000134f0: 6d69 6e67 292c 0a20 2020 2020 2020 2020  ming),.         
-00013500: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00013510: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
-00013520: 6861 6e64 6c65 5f6d 6169 6e5f 696e 6665  handle_main_infe
-00013530: 6173 6962 6c65 2873 656c 6629 3a0a 2020  asible(self):.  
-00013540: 2020 2020 2020 2222 2254 6869 7320 6675        """This fu
-00013550: 6e63 7469 6f6e 2068 616e 646c 6573 2074  nction handles t
-00013560: 6865 2072 6573 756c 7420 6f66 2074 6865  he result of the
-00013570: 206c 6174 6573 7420 6974 6572 6174 696f   latest iteratio
-00013580: 6e20 6f66 2073 6f6c 7669 6e67 0a20 2020  n of solving.   
-00013590: 2020 2020 2074 6865 204d 4950 2070 726f       the MIP pro
-000135a0: 626c 656d 2067 6976 656e 2061 6e20 696e  blem given an in
-000135b0: 6665 6173 6962 6c65 2073 6f6c 7574 696f  feasible solutio
-000135c0: 6e2e 0a20 2020 2020 2020 2022 2222 0a20  n..        """. 
-000135d0: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
-000135e0: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-000135f0: 2020 2020 2020 2020 2020 2020 274d 4950              'MIP
-00013600: 206d 6169 6e20 7072 6f62 6c65 6d20 6973   main problem is
-00013610: 2069 6e66 6561 7369 626c 652e 2027 0a20   infeasible. '. 
-00013620: 2020 2020 2020 2020 2020 2027 5072 6f62             'Prob
-00013630: 6c65 6d20 6d61 7920 6861 7665 206e 6f20  lem may have no 
-00013640: 6d6f 7265 2066 6561 7369 626c 6520 270a  more feasible '.
-00013650: 2020 2020 2020 2020 2020 2020 2762 696e              'bin
-00013660: 6172 7920 636f 6e66 6967 7572 6174 696f  ary configuratio
-00013670: 6e73 2e27 0a20 2020 2020 2020 2029 0a20  ns.'.        ). 
-00013680: 2020 2020 2020 2069 6620 7365 6c66 2e6d         if self.m
-00013690: 6970 5f69 7465 7220 3d3d 2031 3a0a 2020  ip_iter == 1:.  
-000136a0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-000136b0: 6f6e 6669 672e 6c6f 6767 6572 2e77 6172  onfig.logger.war
-000136c0: 6e69 6e67 280a 2020 2020 2020 2020 2020  ning(.          
-000136d0: 2020 2020 2020 274d 696e 6474 5079 2069        'MindtPy i
-000136e0: 6e69 7469 616c 697a 6174 696f 6e20 6d61  nitialization ma
-000136f0: 7920 6861 7665 2067 656e 6572 6174 6564  y have generated
-00013700: 2070 6f6f 7220 7175 616c 6974 7920 6375   poor quality cu
-00013710: 7473 2e27 0a20 2020 2020 2020 2020 2020  ts.'.           
-00013720: 2029 0a20 2020 2020 2020 2023 2054 4f44   ).        # TOD
-00013730: 4f20 6e6f 2d67 6f6f 6420 6375 7473 2066  O no-good cuts f
-00013740: 6f72 2073 696e 676c 6520 7472 6565 2063  or single tree c
-00013750: 6173 650a 2020 2020 2020 2020 2320 7365  ase.        # se
-00013760: 7420 6f70 7469 6d69 7374 6963 2062 6f75  t optimistic bou
-00013770: 6e64 2074 6f20 696e 6669 6e69 7479 0a20  nd to infinity. 
+0000e8f0: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+0000e900: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+0000e910: 2020 2073 656c 662e 6669 7865 645f 6e6c     self.fixed_nl
+0000e920: 705f 6c6f 675f 666f 726d 6174 7465 722e  p_log_formatter.
+0000e930: 666f 726d 6174 280a 2020 2020 2020 2020  format(.        
+0000e940: 2020 2020 2020 2020 2720 272c 0a20 2020          ' ',.   
+0000e950: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0000e960: 662e 6e6c 705f 6974 6572 2c0a 2020 2020  f.nlp_iter,.    
+0000e970: 2020 2020 2020 2020 2020 2020 2746 6561              'Fea
+0000e980: 7369 6269 6c69 7479 204e 4c50 272c 0a20  sibility NLP',. 
+0000e990: 2020 2020 2020 2020 2020 2020 2020 2076                 v
+0000e9a0: 616c 7565 2866 6561 735f 7375 6270 726f  alue(feas_subpro
+0000e9b0: 626c 656d 2e4d 696e 6474 5079 5f75 7469  blem.MindtPy_uti
+0000e9c0: 6c73 2e66 6561 735f 6f62 6a29 2c0a 2020  ls.feas_obj),.  
+0000e9d0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0000e9e0: 6c66 2e70 7269 6d61 6c5f 626f 756e 642c  lf.primal_bound,
+0000e9f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000ea00: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+0000ea10: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0000ea20: 2020 7365 6c66 2e72 656c 5f67 6170 2c0a    self.rel_gap,.
+0000ea30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ea40: 6765 745f 6d61 696e 5f65 6c61 7073 6564  get_main_elapsed
+0000ea50: 5f74 696d 6528 7365 6c66 2e74 696d 696e  _time(self.timin
+0000ea60: 6729 2c0a 2020 2020 2020 2020 2020 2020  g),.            
+0000ea70: 290a 2020 2020 2020 2020 290a 2020 2020  ).        ).    
+0000ea80: 2020 2020 4d69 6e64 7450 792e 6665 6173      MindtPy.feas
+0000ea90: 5f6f 7074 2e64 6561 6374 6976 6174 6528  _opt.deactivate(
+0000eaa0: 290a 2020 2020 2020 2020 666f 7220 636f  ).        for co
+0000eab0: 6e73 7472 2069 6e20 4d69 6e64 7450 792e  nstr in MindtPy.
+0000eac0: 6e6f 6e6c 696e 6561 725f 636f 6e73 7472  nonlinear_constr
+0000ead0: 6169 6e74 5f6c 6973 743a 0a20 2020 2020  aint_list:.     
+0000eae0: 2020 2020 2020 2063 6f6e 7374 722e 6163         constr.ac
+0000eaf0: 7469 7661 7465 2829 0a20 2020 2020 2020  tivate().       
+0000eb00: 2061 6374 6976 655f 6f62 6a2e 6163 7469   active_obj.acti
+0000eb10: 7661 7465 2829 0a20 2020 2020 2020 204d  vate().        M
+0000eb20: 696e 6474 5079 2e66 6561 735f 6f62 6a2e  indtPy.feas_obj.
+0000eb30: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
+0000eb40: 2020 2020 2054 7261 6e73 666f 726d 6174       Transformat
+0000eb50: 696f 6e46 6163 746f 7279 2827 636f 6e74  ionFactory('cont
+0000eb60: 7269 622e 6465 6163 7469 7661 7465 5f74  rib.deactivate_t
+0000eb70: 7269 7669 616c 5f63 6f6e 7374 7261 696e  rivial_constrain
+0000eb80: 7473 2729 2e72 6576 6572 7428 0a20 2020  ts').revert(.   
+0000eb90: 2020 2020 2020 2020 2066 6561 735f 7375           feas_su
+0000eba0: 6270 726f 626c 656d 0a20 2020 2020 2020  bproblem.       
+0000ebb0: 2029 0a20 2020 2020 2020 2072 6574 7572   ).        retur
+0000ebc0: 6e20 6665 6173 5f73 7562 7072 6f62 6c65  n feas_subproble
+0000ebd0: 6d2c 2066 6561 735f 736f 6c6e 0a0a 2020  m, feas_soln..  
+0000ebe0: 2020 6465 6620 6861 6e64 6c65 5f66 6561    def handle_fea
+0000ebf0: 7369 6269 6c69 7479 5f73 7562 7072 6f62  sibility_subprob
+0000ec00: 6c65 6d5f 7463 2873 656c 662c 2073 7562  lem_tc(self, sub
+0000ec10: 7072 6f62 5f74 6572 6d69 6e61 7465 5f63  prob_terminate_c
+0000ec20: 6f6e 642c 204d 696e 6474 5079 293a 0a20  ond, MindtPy):. 
+0000ec30: 2020 2020 2020 2022 2222 4861 6e64 6c65         """Handle
+0000ec40: 7320 7468 6520 7265 7375 6c74 206f 6620  s the result of 
+0000ec50: 7468 6520 6c61 7465 7374 2069 7465 7261  the latest itera
+0000ec60: 7469 6f6e 206f 6620 736f 6c76 696e 6720  tion of solving 
+0000ec70: 7468 6520 6665 6173 6962 696c 6974 7920  the feasibility 
+0000ec80: 4e4c 5020 7375 6270 726f 626c 656d 2e0a  NLP subproblem..
+0000ec90: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+0000eca0: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+0000ecb0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2073  ------.        s
+0000ecc0: 7562 7072 6f62 5f74 6572 6d69 6e61 7465  ubprob_terminate
+0000ecd0: 5f63 6f6e 6420 3a20 5079 6f6d 6f20 5465  _cond : Pyomo Te
+0000ece0: 726d 696e 6174 696f 6e43 6f6e 6469 7469  rminationConditi
+0000ecf0: 6f6e 0a20 2020 2020 2020 2020 2020 2054  on.            T
+0000ed00: 6865 2074 6572 6d69 6e61 7469 6f6e 2063  he termination c
+0000ed10: 6f6e 6469 7469 6f6e 206f 6620 7468 6520  ondition of the 
+0000ed20: 6665 6173 6962 696c 6974 7920 4e4c 5020  feasibility NLP 
+0000ed30: 7375 6270 726f 626c 656d 2e0a 2020 2020  subproblem..    
+0000ed40: 2020 2020 4d69 6e64 7450 7920 3a20 5079      MindtPy : Py
+0000ed50: 6f6d 6f20 426c 6f63 6b0a 2020 2020 2020  omo Block.      
+0000ed60: 2020 2020 2020 5468 6520 4d69 6e64 7450        The MindtP
+0000ed70: 795f 7574 696c 7320 626c 6f63 6b2e 0a20  y_utils block.. 
+0000ed80: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+0000ed90: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
+0000eda0: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
+0000edb0: 6966 2073 7562 7072 6f62 5f74 6572 6d69  if subprob_termi
+0000edc0: 6e61 7465 5f63 6f6e 6420 696e 207b 7463  nate_cond in {tc
+0000edd0: 2e6f 7074 696d 616c 2c20 7463 2e6c 6f63  .optimal, tc.loc
+0000ede0: 616c 6c79 4f70 7469 6d61 6c2c 2074 632e  allyOptimal, tc.
+0000edf0: 6665 6173 6962 6c65 7d3a 0a20 2020 2020  feasible}:.     
+0000ee00: 2020 2020 2020 2023 2054 4f44 4f3a 2063         # TODO: c
+0000ee10: 6865 636b 2077 6861 7420 6973 2074 6869  heck what is thi
+0000ee20: 7320 636f 7079 5f76 616c 7565 2075 7365  s copy_value use
+0000ee30: 6420 666f 723f 0a20 2020 2020 2020 2020  d for?.         
+0000ee40: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
+0000ee50: 5f76 616c 7565 7328 0a20 2020 2020 2020  _values(.       
+0000ee60: 2020 2020 2020 2020 204d 696e 6474 5079           MindtPy
+0000ee70: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
+0000ee80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee90: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
+0000eea0: 656c 2e4d 696e 6474 5079 5f75 7469 6c73  el.MindtPy_utils
+0000eeb0: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
+0000eec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000eed0: 636f 6e66 6967 2c0a 2020 2020 2020 2020  config,.        
+0000eee0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+0000eef0: 2020 6966 2076 616c 7565 284d 696e 6474    if value(Mindt
+0000ef00: 5079 2e66 6561 735f 6f62 6a2e 6578 7072  Py.feas_obj.expr
+0000ef10: 2920 3c3d 2063 6f6e 6669 672e 7a65 726f  ) <= config.zero
+0000ef20: 5f74 6f6c 6572 616e 6365 3a0a 2020 2020  _tolerance:.    
+0000ef30: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
+0000ef40: 6967 2e6c 6f67 6765 722e 7761 726e 696e  ig.logger.warnin
+0000ef50: 6728 0a20 2020 2020 2020 2020 2020 2020  g(.             
+0000ef60: 2020 2020 2020 2027 5468 6520 6f62 6a65         'The obje
+0000ef70: 6374 6976 6520 7661 6c75 6520 252e 3445  ctive value %.4E
+0000ef80: 206f 6620 6665 6173 6962 696c 6974 7920   of feasibility 
+0000ef90: 7072 6f62 6c65 6d20 6973 206c 6573 7320  problem is less 
+0000efa0: 7468 616e 207a 6572 6f5f 746f 6c65 7261  than zero_tolera
+0000efb0: 6e63 652e 2027 0a20 2020 2020 2020 2020  nce. '.         
+0000efc0: 2020 2020 2020 2020 2020 2027 5468 6973             'This
+0000efd0: 2069 6e64 6963 6174 6573 2074 6861 7420   indicates that 
+0000efe0: 7468 6520 6e6c 7020 7375 6270 726f 626c  the nlp subprobl
+0000eff0: 656d 2069 7320 6665 6173 6962 6c65 2c20  em is feasible, 
+0000f000: 616c 7468 6f75 6768 2069 7420 6973 2066  although it is f
+0000f010: 6f75 6e64 2069 6e66 6561 7369 626c 6520  ound infeasible 
+0000f020: 696e 2074 6865 2070 7265 7669 6f75 7320  in the previous 
+0000f030: 7374 6570 2e20 270a 2020 2020 2020 2020  step. '.        
+0000f040: 2020 2020 2020 2020 2020 2020 2743 6865              'Che
+0000f050: 636b 2074 6865 206e 6c70 2073 6f6c 7665  ck the nlp solve
+0000f060: 7220 6f75 7470 7574 2720 2520 7661 6c75  r output' % valu
+0000f070: 6528 4d69 6e64 7450 792e 6665 6173 5f6f  e(MindtPy.feas_o
+0000f080: 626a 2e65 7870 7229 0a20 2020 2020 2020  bj.expr).       
+0000f090: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+0000f0a0: 2020 2065 6c69 6620 7375 6270 726f 625f     elif subprob_
+0000f0b0: 7465 726d 696e 6174 655f 636f 6e64 2069  terminate_cond i
+0000f0c0: 6e20 7b74 632e 696e 6665 6173 6962 6c65  n {tc.infeasible
+0000f0d0: 2c20 7463 2e6e 6f53 6f6c 7574 696f 6e7d  , tc.noSolution}
+0000f0e0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+0000f0f0: 6e66 6967 2e6c 6f67 6765 722e 6572 726f  nfig.logger.erro
+0000f100: 7228 0a20 2020 2020 2020 2020 2020 2020  r(.             
+0000f110: 2020 2027 4665 6173 6962 696c 6974 7920     'Feasibility 
+0000f120: 7375 6270 726f 626c 656d 2069 6e66 6561  subproblem infea
+0000f130: 7369 626c 652e 2054 6869 7320 7368 6f75  sible. This shou
+0000f140: 6c64 206e 6576 6572 2068 6170 7065 6e2e  ld never happen.
+0000f150: 270a 2020 2020 2020 2020 2020 2020 290a  '.            ).
+0000f160: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0000f170: 2e73 686f 756c 645f 7465 726d 696e 6174  .should_terminat
+0000f180: 6520 3d20 5472 7565 0a20 2020 2020 2020  e = True.       
+0000f190: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
+0000f1a0: 732e 736f 6c76 6572 2e73 7461 7475 7320  s.solver.status 
+0000f1b0: 3d20 536f 6c76 6572 5374 6174 7573 2e65  = SolverStatus.e
+0000f1c0: 7272 6f72 0a20 2020 2020 2020 2065 6c69  rror.        eli
+0000f1d0: 6620 7375 6270 726f 625f 7465 726d 696e  f subprob_termin
+0000f1e0: 6174 655f 636f 6e64 2069 7320 7463 2e6d  ate_cond is tc.m
+0000f1f0: 6178 4974 6572 6174 696f 6e73 3a0a 2020  axIterations:.  
+0000f200: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+0000f210: 2e6c 6f67 6765 722e 6572 726f 7228 0a20  .logger.error(. 
+0000f220: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+0000f230: 5375 6273 6f6c 7665 7220 7265 6163 6865  Subsolver reache
+0000f240: 6420 6974 7320 6d61 7869 6d75 6d20 6e75  d its maximum nu
+0000f250: 6d62 6572 206f 6620 6974 6572 6174 696f  mber of iteratio
+0000f260: 6e73 2077 6974 686f 7574 2063 6f6e 7665  ns without conve
+0000f270: 7267 696e 672c 2027 0a20 2020 2020 2020  rging, '.       
+0000f280: 2020 2020 2020 2020 2027 636f 6e73 6964           'consid
+0000f290: 6572 2069 6e63 7265 6173 696e 6720 7468  er increasing th
+0000f2a0: 6520 6974 6572 6174 696f 6e73 206c 696d  e iterations lim
+0000f2b0: 6974 206f 6620 7468 6520 7375 6273 6f6c  it of the subsol
+0000f2c0: 7665 7220 6f72 2072 6576 6965 7769 6e67  ver or reviewing
+0000f2d0: 2079 6f75 7220 666f 726d 756c 6174 696f   your formulatio
+0000f2e0: 6e2e 270a 2020 2020 2020 2020 2020 2020  n.'.            
+0000f2f0: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+0000f300: 6c66 2e73 686f 756c 645f 7465 726d 696e  lf.should_termin
+0000f310: 6174 6520 3d20 5472 7565 0a20 2020 2020  ate = True.     
+0000f320: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+0000f330: 6c74 732e 736f 6c76 6572 2e73 7461 7475  lts.solver.statu
+0000f340: 7320 3d20 536f 6c76 6572 5374 6174 7573  s = SolverStatus
+0000f350: 2e65 7272 6f72 0a20 2020 2020 2020 2065  .error.        e
+0000f360: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000f370: 2063 6f6e 6669 672e 6c6f 6767 6572 2e65   config.logger.e
+0000f380: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
+0000f390: 2020 2020 2020 274d 696e 6474 5079 2075        'MindtPy u
+0000f3a0: 6e61 626c 6520 746f 2068 616e 646c 6520  nable to handle 
+0000f3b0: 6665 6173 6962 696c 6974 7920 7375 6270  feasibility subp
+0000f3c0: 726f 626c 656d 2074 6572 6d69 6e61 7469  roblem terminati
+0000f3d0: 6f6e 2063 6f6e 6469 7469 6f6e 2027 0a20  on condition '. 
+0000f3e0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+0000f3f0: 6f66 207b 7d27 2e66 6f72 6d61 7428 7375  of {}'.format(su
+0000f400: 6270 726f 625f 7465 726d 696e 6174 655f  bprob_terminate_
+0000f410: 636f 6e64 290a 2020 2020 2020 2020 2020  cond).          
+0000f420: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0000f430: 7365 6c66 2e73 686f 756c 645f 7465 726d  self.should_term
+0000f440: 696e 6174 6520 3d20 5472 7565 0a20 2020  inate = True.   
+0000f450: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+0000f460: 7375 6c74 732e 736f 6c76 6572 2e73 7461  sults.solver.sta
+0000f470: 7475 7320 3d20 536f 6c76 6572 5374 6174  tus = SolverStat
+0000f480: 7573 2e65 7272 6f72 0a0a 2020 2020 2323  us.error..    ##
+0000f490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f4f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000f520: 2323 2323 0a20 2020 2023 2069 7465 7261  ####.    # itera
+0000f530: 7465 2e70 790a 0a20 2020 2064 6566 2061  te.py..    def a
+0000f540: 6c67 6f72 6974 686d 5f73 686f 756c 645f  lgorithm_should_
+0000f550: 7465 726d 696e 6174 6528 7365 6c66 2c20  terminate(self, 
+0000f560: 6368 6563 6b5f 6379 636c 696e 6729 3a0a  check_cycling):.
+0000f570: 2020 2020 2020 2020 2222 2243 6865 636b          """Check
+0000f580: 7320 6966 2074 6865 2061 6c67 6f72 6974  s if the algorit
+0000f590: 686d 2073 686f 756c 6420 7465 726d 696e  hm should termin
+0000f5a0: 6174 6520 6174 2074 6865 2067 6976 656e  ate at the given
+0000f5b0: 2070 6f69 6e74 2e0a 0a20 2020 2020 2020   point...       
+0000f5c0: 2054 6869 7320 6675 6e63 7469 6f6e 2064   This function d
+0000f5d0: 6574 6572 6d69 6e65 7320 7768 6574 6865  etermines whethe
+0000f5e0: 7220 7468 6520 616c 676f 7269 7468 6d20  r the algorithm 
+0000f5f0: 7368 6f75 6c64 2074 6572 6d69 6e61 7465  should terminate
+0000f600: 2062 6173 6564 206f 6e20 7468 6520 736f   based on the so
+0000f610: 6c76 6572 206f 7074 696f 6e73 2061 6e64  lver options and
+0000f620: 2070 726f 6772 6573 732e 0a20 2020 2020   progress..     
+0000f630: 2020 2028 5365 7473 2074 6865 2073 656c     (Sets the sel
+0000f640: 662e 7265 7375 6c74 732e 736f 6c76 6572  f.results.solver
+0000f650: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
+0000f660: 6469 7469 6f6e 2074 6f20 7468 6520 6170  dition to the ap
+0000f670: 7072 6f70 7269 6174 6520 636f 6e64 6974  propriate condit
+0000f680: 696f 6e2c 2069 2e65 2e20 6f70 7469 6d61  ion, i.e. optima
+0000f690: 6c2c 0a20 2020 2020 2020 206d 6178 4974  l,.        maxIt
+0000f6a0: 6572 6174 696f 6e73 2c20 6d61 7854 696d  erations, maxTim
+0000f6b0: 654c 696d 6974 292e 0a0a 2020 2020 2020  eLimit)...      
+0000f6c0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+0000f6d0: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+0000f6e0: 2020 2020 2020 2020 6368 6563 6b5f 6379          check_cy
+0000f6f0: 636c 696e 6720 3a20 626f 6f6c 0a20 2020  cling : bool.   
+0000f700: 2020 2020 2020 2020 2057 6865 7468 6572           Whether
+0000f710: 2074 6f20 6368 6563 6b20 666f 7220 6120   to check for a 
+0000f720: 7370 6563 6961 6c20 6361 7365 2074 6861  special case tha
+0000f730: 7420 6361 7573 6573 2074 6865 2064 6973  t causes the dis
+0000f740: 6372 6574 6520 7661 7269 6162 6c65 7320  crete variables 
+0000f750: 746f 206c 6f6f 7020 7468 726f 7567 6820  to loop through 
+0000f760: 7468 6520 7361 6d65 2076 616c 7565 732e  the same values.
+0000f770: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
+0000f780: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
+0000f790: 2d0a 2020 2020 2020 2020 626f 6f6c 0a20  -.        bool. 
+0000f7a0: 2020 2020 2020 2020 2020 2054 7275 6520             True 
+0000f7b0: 6966 2074 6865 2061 6c67 6f72 6974 686d  if the algorithm
+0000f7c0: 2073 686f 756c 6420 7465 726d 696e 6174   should terminat
+0000f7d0: 652c 2046 616c 7365 206f 7468 6572 7769  e, False otherwi
+0000f7e0: 7365 2e0a 2020 2020 2020 2020 2222 220a  se..        """.
+0000f7f0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+0000f800: 7368 6f75 6c64 5f74 6572 6d69 6e61 7465  should_terminate
+0000f810: 3a0a 2020 2020 2020 2020 2020 2020 2320  :.            # 
+0000f820: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
+0000f830: 645f 7072 6f67 7265 7373 5b30 5d20 6361  d_progress[0] ca
+0000f840: 6e20 6f6e 6c79 2062 6520 696e 6620 6f72  n only be inf or
+0000f850: 202d 696e 662e 0a20 2020 2020 2020 2020   -inf..         
+0000f860: 2020 2023 2049 6620 7468 6520 6375 7272     # If the curr
+0000f870: 656e 7420 7072 696d 616c 2062 6f75 6e64  ent primal bound
+0000f880: 2065 7175 616c 7320 696e 6620 6f72 202d   equals inf or -
+0000f890: 696e 662c 2077 6520 6361 6e20 696e 6665  inf, we can infe
+0000f8a0: 7220 7468 6572 6520 6973 206e 6f20 736f  r there is no so
+0000f8b0: 6c75 7469 6f6e 2e0a 2020 2020 2020 2020  lution..        
+0000f8c0: 2020 2020 6966 2073 656c 662e 7072 696d      if self.prim
+0000f8d0: 616c 5f62 6f75 6e64 203d 3d20 7365 6c66  al_bound == self
+0000f8e0: 2e70 7269 6d61 6c5f 626f 756e 645f 7072  .primal_bound_pr
+0000f8f0: 6f67 7265 7373 5b30 5d3a 0a20 2020 2020  ogress[0]:.     
+0000f900: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0000f910: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
+0000f920: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+0000f930: 7469 6f6e 203d 2074 632e 6e6f 536f 6c75  tion = tc.noSolu
+0000f940: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
+0000f950: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+0000f960: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+0000f970: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+0000f980: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+0000f990: 203d 2074 632e 6665 6173 6962 6c65 0a20   = tc.feasible. 
+0000f9a0: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+0000f9b0: 6e20 5472 7565 0a20 2020 2020 2020 2072  n True.        r
+0000f9c0: 6574 7572 6e20 280a 2020 2020 2020 2020  eturn (.        
+0000f9d0: 2020 2020 7365 6c66 2e62 6f75 6e64 735f      self.bounds_
+0000f9e0: 636f 6e76 6572 6765 6428 290a 2020 2020  converged().    
+0000f9f0: 2020 2020 2020 2020 6f72 2073 656c 662e          or self.
+0000fa00: 7265 6163 6865 645f 6974 6572 6174 696f  reached_iteratio
+0000fa10: 6e5f 6c69 6d69 7428 290a 2020 2020 2020  n_limit().      
+0000fa20: 2020 2020 2020 6f72 2073 656c 662e 7265        or self.re
+0000fa30: 6163 6865 645f 7469 6d65 5f6c 696d 6974  ached_time_limit
+0000fa40: 2829 0a20 2020 2020 2020 2020 2020 206f  ().            o
+0000fa50: 7220 7365 6c66 2e72 6561 6368 6564 5f73  r self.reached_s
+0000fa60: 7461 6c6c 696e 675f 6c69 6d69 7428 290a  talling_limit().
+0000fa70: 2020 2020 2020 2020 2020 2020 6f72 2028              or (
+0000fa80: 6368 6563 6b5f 6379 636c 696e 6720 616e  check_cycling an
+0000fa90: 6420 7365 6c66 2e69 7465 7261 7469 6f6e  d self.iteration
+0000faa0: 5f63 7963 6c69 6e67 2829 290a 2020 2020  _cycling()).    
+0000fab0: 2020 2020 290a 0a20 2020 2064 6566 2066      )..    def f
+0000fac0: 6978 5f64 7561 6c5f 626f 756e 6428 7365  ix_dual_bound(se
+0000fad0: 6c66 2c20 6c61 7374 5f69 7465 725f 6375  lf, last_iter_cu
+0000fae0: 7473 293a 0a20 2020 2020 2020 2022 2222  ts):.        """
+0000faf0: 4669 7820 7468 6520 6475 616c 2062 6f75  Fix the dual bou
+0000fb00: 6e64 2077 6865 6e20 6e6f 2d67 6f6f 6420  nd when no-good 
+0000fb10: 6375 7473 206f 7220 7461 6275 206c 6973  cuts or tabu lis
+0000fb20: 7420 6973 2061 6374 6976 6174 6564 2e0a  t is activated..
+0000fb30: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+0000fb40: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+0000fb50: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 206c  ------.        l
+0000fb60: 6173 745f 6974 6572 5f63 7574 7320 3a20  ast_iter_cuts : 
+0000fb70: 626f 6f6c 0a20 2020 2020 2020 2020 2020  bool.           
+0000fb80: 2057 6865 7468 6572 2074 6865 2063 7574   Whether the cut
+0000fb90: 7320 696e 2074 6865 206c 6173 7420 6974  s in the last it
+0000fba0: 6572 6174 696f 6e20 6861 7665 2062 6565  eration have bee
+0000fbb0: 6e20 6164 6465 642e 0a20 2020 2020 2020  n added..       
+0000fbc0: 2022 2222 0a20 2020 2020 2020 2023 2049   """.        # I
+0000fbd0: 6620 6e6f 2d67 6f6f 6420 6375 7473 206f  f no-good cuts o
+0000fbe0: 7220 7461 6275 206c 6973 7420 6973 2061  r tabu list is a
+0000fbf0: 6374 6976 6174 6564 2c20 7468 6520 6475  ctivated, the du
+0000fc00: 616c 2062 6f75 6e64 2069 7320 6e6f 7420  al bound is not 
+0000fc10: 7661 6c69 6420 666f 7220 7468 6520 6669  valid for the fi
+0000fc20: 6e61 6c20 6f70 7469 6d61 6c20 736f 6c75  nal optimal solu
+0000fc30: 7469 6f6e 2e0a 2020 2020 2020 2020 2320  tion..        # 
+0000fc40: 5468 6572 6566 6f72 652c 2077 6520 6e65  Therefore, we ne
+0000fc50: 6564 2074 6f20 636f 7272 6563 7420 6974  ed to correct it
+0000fc60: 2061 7420 7468 6520 656e 642e 0a20 2020   at the end..   
+0000fc70: 2020 2020 2023 2049 6e20 7369 6e67 6c65       # In single
+0000fc80: 7472 6565 2069 6d70 6c65 6d65 6e74 6174  tree implementat
+0000fc90: 696f 6e2c 2074 6865 2064 7561 6c20 626f  ion, the dual bo
+0000fca0: 756e 6420 6174 206f 6e65 2069 7465 7261  und at one itera
+0000fcb0: 7469 6f6e 2062 6566 6f72 6520 7468 6520  tion before the 
+0000fcc0: 6f70 7469 6d61 6c20 736f 6c75 7469 6f6e  optimal solution
+0000fcd0: 2c20 6973 2076 616c 6964 2066 6f72 2074  , is valid for t
+0000fce0: 6865 206f 7074 696d 616c 2073 6f6c 7574  he optimal solut
+0000fcf0: 696f 6e2e 0a20 2020 2020 2020 2023 2053  ion..        # S
+0000fd00: 6f20 7765 2077 696c 6c20 7365 7420 7468  o we will set th
+0000fd10: 6520 6475 616c 2062 6f75 6e64 2074 6f20  e dual bound to 
+0000fd20: 6974 2e0a 2020 2020 2020 2020 636f 6e66  it..        conf
+0000fd30: 6967 203d 2073 656c 662e 636f 6e66 6967  ig = self.config
+0000fd40: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
+0000fd50: 6967 2e73 696e 676c 655f 7472 6565 3a0a  ig.single_tree:.
+0000fd60: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
+0000fd70: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
+0000fd80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000fd90: 2746 6978 2074 6865 2062 6f75 6e64 2074  'Fix the bound t
+0000fda0: 6f20 7468 6520 7661 6c75 6520 6f66 206f  o the value of o
+0000fdb0: 6e65 2069 7465 7261 7469 6f6e 2062 6566  ne iteration bef
+0000fdc0: 6f72 6520 6f70 7469 6d61 6c20 736f 6c75  ore optimal solu
+0000fdd0: 7469 6f6e 2069 7320 666f 756e 642e 270a  tion is found.'.
+0000fde0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+0000fdf0: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
+0000fe00: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0000fe10: 656c 662e 6475 616c 5f62 6f75 6e64 203d  elf.dual_bound =
+0000fe20: 2073 656c 662e 7374 6f72 6564 5f62 6f75   self.stored_bou
+0000fe30: 6e64 5b73 656c 662e 7072 696d 616c 5f62  nd[self.primal_b
+0000fe40: 6f75 6e64 5d0a 2020 2020 2020 2020 2020  ound].          
+0000fe50: 2020 6578 6365 7074 204b 6579 4572 726f    except KeyErro
+0000fe60: 7220 6173 2065 3a0a 2020 2020 2020 2020  r as e:.        
+0000fe70: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
+0000fe80: 6f67 6765 722e 6572 726f 7228 652c 2065  ogger.error(e, e
+0000fe90: 7863 5f69 6e66 6f3d 5472 7565 290a 2020  xc_info=True).  
+0000fea0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0000feb0: 6e66 6967 2e6c 6f67 6765 722e 6572 726f  nfig.logger.erro
+0000fec0: 7228 274e 6f20 7374 6f72 6564 2062 6f75  r('No stored bou
+0000fed0: 6e64 2066 6f75 6e64 2e20 426f 756e 6420  nd found. Bound 
+0000fee0: 6669 7820 6661 696c 6564 2e27 290a 2020  fix failed.').  
+0000fef0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+0000ff00: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
+0000ff10: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
+0000ff20: 2020 2020 2020 2020 2020 2020 2753 6f6c              'Sol
+0000ff30: 7665 2074 6865 206d 6169 6e20 7072 6f62  ve the main prob
+0000ff40: 6c65 6d20 7769 7468 6f75 7420 7468 6520  lem without the 
+0000ff50: 6c61 7374 206e 6f5f 676f 6f64 2063 7574  last no_good cut
+0000ff60: 2074 6f20 6669 7820 7468 6520 626f 756e   to fix the boun
+0000ff70: 642e 270a 2020 2020 2020 2020 2020 2020  d.'.            
+0000ff80: 2020 2020 277a 6572 6f5f 746f 6c65 7261      'zero_tolera
+0000ff90: 6e63 6520 6973 2073 6574 2074 6f20 3145  nce is set to 1E
+0000ffa0: 2d34 270a 2020 2020 2020 2020 2020 2020  -4'.            
+0000ffb0: 290a 2020 2020 2020 2020 2020 2020 636f  ).            co
+0000ffc0: 6e66 6967 2e7a 6572 6f5f 746f 6c65 7261  nfig.zero_tolera
+0000ffd0: 6e63 6520 3d20 3165 2d34 0a20 2020 2020  nce = 1e-4.     
+0000ffe0: 2020 2020 2020 2023 2053 6f6c 7665 204e         # Solve N
+0000fff0: 4c50 2073 7562 7072 6f62 6c65 6d0a 2020  LP subproblem.  
+00010000: 2020 2020 2020 2020 2020 2320 5468 6520            # The 
+00010010: 636f 6e73 7472 6169 6e74 206c 696e 6561  constraint linea
+00010020: 7269 7a61 7469 6f6e 2068 6170 7065 6e73  rization happens
+00010030: 2069 6e20 7468 6520 6861 6e64 6c65 7273   in the handlers
+00010040: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00010050: 6e6f 7420 6c61 7374 5f69 7465 725f 6375  not last_iter_cu
+00010060: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
+00010070: 2020 2020 6669 7865 645f 6e6c 702c 2066      fixed_nlp, f
+00010080: 6978 6564 5f6e 6c70 5f72 6573 756c 7420  ixed_nlp_result 
+00010090: 3d20 7365 6c66 2e73 6f6c 7665 5f73 7562  = self.solve_sub
+000100a0: 7072 6f62 6c65 6d28 290a 2020 2020 2020  problem().      
+000100b0: 2020 2020 2020 2020 2020 7365 6c66 2e68            self.h
+000100c0: 616e 646c 655f 6e6c 705f 7375 6270 726f  andle_nlp_subpro
+000100d0: 626c 656d 5f74 6328 6669 7865 645f 6e6c  blem_tc(fixed_nl
+000100e0: 702c 2066 6978 6564 5f6e 6c70 5f72 6573  p, fixed_nlp_res
+000100f0: 756c 7429 0a0a 2020 2020 2020 2020 2020  ult)..          
+00010100: 2020 4d69 6e64 7450 7920 3d20 7365 6c66    MindtPy = self
+00010110: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
+00010120: 6c73 0a20 2020 2020 2020 2020 2020 2023  ls.            #
+00010130: 2044 6561 6374 6976 6174 6520 7468 6520   Deactivate the 
+00010140: 696e 7465 6765 7220 6375 7473 2067 656e  integer cuts gen
+00010150: 6572 6174 6564 2061 6674 6572 2074 6865  erated after the
+00010160: 2062 6573 7420 736f 6c75 7469 6f6e 2077   best solution w
+00010170: 6173 2066 6f75 6e64 2e0a 2020 2020 2020  as found..      
+00010180: 2020 2020 2020 7365 6c66 2e64 6561 6374        self.deact
+00010190: 6976 6174 655f 6e6f 5f67 6f6f 645f 6375  ivate_no_good_cu
+000101a0: 7473 5f77 6865 6e5f 6669 7869 6e67 5f62  ts_when_fixing_b
+000101b0: 6f75 6e64 284d 696e 6474 5079 2e63 7574  ound(MindtPy.cut
+000101c0: 732e 6e6f 5f67 6f6f 645f 6375 7473 290a  s.no_good_cuts).
+000101d0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
+000101e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000101f0: 2063 6f6e 6669 672e 6164 645f 7265 6775   config.add_regu
+00010200: 6c61 7269 7a61 7469 6f6e 2069 7320 6e6f  larization is no
+00010210: 7420 4e6f 6e65 0a20 2020 2020 2020 2020  t None.         
+00010220: 2020 2020 2020 2061 6e64 204d 696e 6474         and Mindt
+00010230: 5079 2e63 6f6d 706f 6e65 6e74 2827 6d69  Py.component('mi
+00010240: 705f 6f62 6a27 2920 6973 204e 6f6e 650a  p_obj') is None.
+00010250: 2020 2020 2020 2020 2020 2020 293a 0a20              ):. 
+00010260: 2020 2020 2020 2020 2020 2020 2020 204d                 M
+00010270: 696e 6474 5079 2e6f 626a 6563 7469 7665  indtPy.objective
+00010280: 5f6c 6973 745b 2d31 5d2e 6163 7469 7661  _list[-1].activa
+00010290: 7465 2829 0a20 2020 2020 2020 2020 2020  te().           
+000102a0: 2023 2064 6574 6572 6d69 6e65 2069 6620   # determine if 
+000102b0: 7065 7273 6973 7465 6e74 2073 6f6c 7665  persistent solve
+000102c0: 7220 6973 2063 616c 6c65 642e 0a20 2020  r is called..   
+000102d0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+000102e0: 7374 616e 6365 2873 656c 662e 6d69 705f  stance(self.mip_
+000102f0: 6f70 742c 2050 6572 7369 7374 656e 7453  opt, PersistentS
+00010300: 6f6c 7665 7229 3a0a 2020 2020 2020 2020  olver):.        
+00010310: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00010320: 5f6f 7074 2e73 6574 5f69 6e73 7461 6e63  _opt.set_instanc
+00010330: 6528 7365 6c66 2e6d 6970 2c20 7379 6d62  e(self.mip, symb
+00010340: 6f6c 6963 5f73 6f6c 7665 725f 6c61 6265  olic_solver_labe
+00010350: 6c73 3d54 7275 6529 0a20 2020 2020 2020  ls=True).       
+00010360: 2020 2020 206d 6970 5f61 7267 7320 3d20       mip_args = 
+00010370: 6469 6374 2863 6f6e 6669 672e 6d69 705f  dict(config.mip_
+00010380: 736f 6c76 6572 5f61 7267 7329 0a20 2020  solver_args).   
+00010390: 2020 2020 2020 2020 2075 7064 6174 655f           update_
+000103a0: 736f 6c76 6572 5f74 696d 656c 696d 6974  solver_timelimit
+000103b0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000103c0: 2020 7365 6c66 2e6d 6970 5f6f 7074 2c20    self.mip_opt, 
+000103d0: 636f 6e66 6967 2e6d 6970 5f73 6f6c 7665  config.mip_solve
+000103e0: 722c 2073 656c 662e 7469 6d69 6e67 2c20  r, self.timing, 
+000103f0: 636f 6e66 6967 0a20 2020 2020 2020 2020  config.         
+00010400: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00010410: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+00010420: 7320 3d20 7365 6c66 2e6d 6970 5f6f 7074  s = self.mip_opt
+00010430: 2e73 6f6c 7665 280a 2020 2020 2020 2020  .solve(.        
+00010440: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00010450: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00010460: 2020 7465 653d 636f 6e66 6967 2e6d 6970    tee=config.mip
+00010470: 5f73 6f6c 7665 725f 7465 652c 0a20 2020  _solver_tee,.   
+00010480: 2020 2020 2020 2020 2020 2020 206c 6f61               loa
+00010490: 645f 736f 6c75 7469 6f6e 733d 7365 6c66  d_solutions=self
+000104a0: 2e6d 6970 5f6c 6f61 645f 736f 6c75 7469  .mip_load_soluti
+000104b0: 6f6e 732c 0a20 2020 2020 2020 2020 2020  ons,.           
+000104c0: 2020 2020 202a 2a6d 6970 5f61 7267 732c       **mip_args,
+000104d0: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
+000104e0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+000104f0: 6e28 6d61 696e 5f6d 6970 5f72 6573 756c  n(main_mip_resul
+00010500: 7473 2e73 6f6c 7574 696f 6e29 203e 2030  ts.solution) > 0
+00010510: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00010520: 2020 7365 6c66 2e6d 6970 2e73 6f6c 7574    self.mip.solut
+00010530: 696f 6e73 2e6c 6f61 645f 6672 6f6d 286d  ions.load_from(m
+00010540: 6169 6e5f 6d69 705f 7265 7375 6c74 7329  ain_mip_results)
+00010550: 0a0a 2020 2020 2020 2020 2020 2020 6966  ..            if
+00010560: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+00010570: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00010580: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 2069  tion_condition i
+00010590: 7320 7463 2e69 6e66 6561 7369 626c 653a  s tc.infeasible:
+000105a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000105b0: 2063 6f6e 6669 672e 6c6f 6767 6572 2e69   config.logger.i
+000105c0: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+000105d0: 2020 2020 2020 2020 2027 426f 756e 6420           'Bound 
+000105e0: 6669 7820 6661 696c 6564 2e20 5468 6520  fix failed. The 
+000105f0: 626f 756e 6420 6669 7820 7072 6f62 6c65  bound fix proble
+00010600: 6d20 6973 2069 6e66 6561 7369 626c 6527  m is infeasible'
+00010610: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010620: 2029 0a20 2020 2020 2020 2020 2020 2065   ).            e
+00010630: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00010640: 2020 2020 2073 656c 662e 7570 6461 7465       self.update
+00010650: 5f73 7562 6f70 7469 6d61 6c5f 6475 616c  _suboptimal_dual
+00010660: 5f62 6f75 6e64 286d 6169 6e5f 6d69 705f  _bound(main_mip_
+00010670: 7265 7375 6c74 7329 0a20 2020 2020 2020  results).       
+00010680: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00010690: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+000106a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000106b0: 2027 4669 7865 6420 626f 756e 6420 7661   'Fixed bound va
+000106c0: 6c75 6573 3a20 5072 696d 616c 2042 6f75  lues: Primal Bou
+000106d0: 6e64 3a20 7b7d 2020 4475 616c 2042 6f75  nd: {}  Dual Bou
+000106e0: 6e64 3a20 7b7d 272e 666f 726d 6174 280a  nd: {}'.format(.
+000106f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010700: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
+00010710: 6d61 6c5f 626f 756e 642c 2073 656c 662e  mal_bound, self.
+00010720: 6475 616c 5f62 6f75 6e64 0a20 2020 2020  dual_bound.     
+00010730: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00010740: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010750: 2029 0a20 2020 2020 2020 2020 2020 2023   ).            #
+00010760: 2043 6865 636b 2062 6f75 6e64 2063 6f6e   Check bound con
+00010770: 7665 7267 656e 6365 0a20 2020 2020 2020  vergence.       
+00010780: 2020 2020 2069 6620 280a 2020 2020 2020       if (.      
+00010790: 2020 2020 2020 2020 2020 6162 7328 7365            abs(se
+000107a0: 6c66 2e70 7269 6d61 6c5f 626f 756e 6420  lf.primal_bound 
+000107b0: 2d20 7365 6c66 2e64 7561 6c5f 626f 756e  - self.dual_boun
+000107c0: 6429 0a20 2020 2020 2020 2020 2020 2020  d).             
+000107d0: 2020 203c 3d20 636f 6e66 6967 2e61 6273     <= config.abs
+000107e0: 6f6c 7574 655f 626f 756e 645f 746f 6c65  olute_bound_tole
+000107f0: 7261 6e63 650a 2020 2020 2020 2020 2020  rance.          
+00010800: 2020 293a 0a20 2020 2020 2020 2020 2020    ):.           
+00010810: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
+00010820: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00010830: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 203d  tion_condition =
+00010840: 2074 632e 6f70 7469 6d61 6c0a 0a20 2020   tc.optimal..   
+00010850: 2064 6566 2073 6574 5f75 705f 7461 6275   def set_up_tabu
+00010860: 6c69 7374 5f63 616c 6c62 6163 6b28 7365  list_callback(se
+00010870: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
+00010880: 5365 7473 2075 7020 7468 6520 7461 6275  Sets up the tabu
+00010890: 6c69 7374 2075 7369 6e67 2049 6e63 756d  list using Incum
+000108a0: 6265 6e74 4361 6c6c 6261 636b 2e0a 2020  bentCallback..  
+000108b0: 2020 2020 2020 4375 7272 656e 746c 7920        Currently 
+000108c0: 6f6e 6c79 2073 7570 706f 7274 2043 504c  only support CPL
+000108d0: 4558 2e0a 2020 2020 2020 2020 2222 220a  EX..        """.
+000108e0: 2020 2020 2020 2020 7461 6275 6c69 7374          tabulist
+000108f0: 203d 2073 656c 662e 6d69 705f 6f70 742e   = self.mip_opt.
+00010900: 5f73 6f6c 7665 725f 6d6f 6465 6c2e 7265  _solver_model.re
+00010910: 6769 7374 6572 5f63 616c 6c62 6163 6b28  gister_callback(
+00010920: 0a20 2020 2020 2020 2020 2020 2074 6162  .            tab
+00010930: 755f 6c69 7374 2e49 6e63 756d 6265 6e74  u_list.Incumbent
+00010940: 4361 6c6c 6261 636b 5f63 706c 6578 0a20  Callback_cplex. 
+00010950: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00010960: 2074 6162 756c 6973 742e 6f70 7420 3d20   tabulist.opt = 
+00010970: 7365 6c66 2e6d 6970 5f6f 7074 0a20 2020  self.mip_opt.   
+00010980: 2020 2020 2074 6162 756c 6973 742e 636f       tabulist.co
+00010990: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
+000109a0: 6967 0a20 2020 2020 2020 2074 6162 756c  ig.        tabul
+000109b0: 6973 742e 6d69 6e64 7470 795f 736f 6c76  ist.mindtpy_solv
+000109c0: 6572 203d 2073 656c 660a 2020 2020 2020  er = self.      
+000109d0: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e6f    self.mip_opt.o
+000109e0: 7074 696f 6e73 5b27 7072 6570 726f 6365  ptions['preproce
+000109f0: 7373 696e 675f 7265 6475 6365 275d 203d  ssing_reduce'] =
+00010a00: 2031 0a20 2020 2020 2020 2023 2049 6620   1.        # If 
+00010a10: 7468 6520 6361 6c6c 6261 636b 2069 7320  the callback is 
+00010a20: 7573 6564 2074 6f20 7265 6a65 6374 2069  used to reject i
+00010a30: 6e63 756d 6265 6e74 732c 2074 6865 2075  ncumbents, the u
+00010a40: 7365 7220 6d75 7374 2073 6574 2074 6865  ser must set the
+00010a50: 0a20 2020 2020 2020 2023 2070 6172 616d  .        # param
+00010a60: 6574 6572 2063 2e70 6172 616d 6574 6572  eter c.parameter
+00010a70: 732e 7072 6570 726f 6365 7373 696e 672e  s.preprocessing.
+00010a80: 7265 6475 6365 2065 6974 6865 7220 746f  reduce either to
+00010a90: 2074 6865 2076 616c 7565 2031 2028 6f6e   the value 1 (on
+00010aa0: 6529 0a20 2020 2020 2020 2023 2074 6f20  e).        # to 
+00010ab0: 7265 7374 7269 6374 2070 7265 736f 6c76  restrict presolv
+00010ac0: 6520 746f 2070 7269 6d61 6c20 7265 6475  e to primal redu
+00010ad0: 6374 696f 6e73 206f 6e6c 7920 6f72 2074  ctions only or t
+00010ae0: 6f20 3020 287a 6572 6f29 2074 6f20 6469  o 0 (zero) to di
+00010af0: 7361 626c 6520 616c 6c20 7072 6573 6f6c  sable all presol
+00010b00: 7665 2072 6564 7563 7469 6f6e 730a 2020  ve reductions.  
+00010b10: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
+00010b20: 7074 2e5f 736f 6c76 6572 5f6d 6f64 656c  pt._solver_model
+00010b30: 2e73 6574 5f77 6172 6e69 6e67 5f73 7472  .set_warning_str
+00010b40: 6561 6d28 4e6f 6e65 290a 2020 2020 2020  eam(None).      
+00010b50: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e5f    self.mip_opt._
+00010b60: 736f 6c76 6572 5f6d 6f64 656c 2e73 6574  solver_model.set
+00010b70: 5f6c 6f67 5f73 7472 6561 6d28 4e6f 6e65  _log_stream(None
+00010b80: 290a 2020 2020 2020 2020 7365 6c66 2e6d  ).        self.m
+00010b90: 6970 5f6f 7074 2e5f 736f 6c76 6572 5f6d  ip_opt._solver_m
+00010ba0: 6f64 656c 2e73 6574 5f65 7272 6f72 5f73  odel.set_error_s
+00010bb0: 7472 6561 6d28 4e6f 6e65 290a 0a20 2020  tream(None)..   
+00010bc0: 2064 6566 2073 6574 5f75 705f 6c61 7a79   def set_up_lazy
+00010bd0: 5f4f 415f 6361 6c6c 6261 636b 2873 656c  _OA_callback(sel
+00010be0: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
+00010bf0: 6574 7320 7570 2074 6865 206c 617a 7920  ets up the lazy 
+00010c00: 4f41 2075 7369 6e67 204c 617a 7943 6f6e  OA using LazyCon
+00010c10: 7374 7261 696e 7443 616c 6c62 6163 6b2e  straintCallback.
+00010c20: 0a20 2020 2020 2020 2043 7572 7265 6e74  .        Current
+00010c30: 6c79 206f 6e6c 7920 7375 7070 6f72 7420  ly only support 
+00010c40: 4350 4c45 5820 616e 6420 4775 726f 6269  CPLEX and Gurobi
+00010c50: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
+00010c60: 2020 2020 2020 6966 2073 656c 662e 636f        if self.co
+00010c70: 6e66 6967 2e6d 6970 5f73 6f6c 7665 7220  nfig.mip_solver 
+00010c80: 3d3d 2027 6370 6c65 785f 7065 7273 6973  == 'cplex_persis
+00010c90: 7465 6e74 273a 0a20 2020 2020 2020 2020  tent':.         
+00010ca0: 2020 206c 617a 796f 6120 3d20 7365 6c66     lazyoa = self
+00010cb0: 2e6d 6970 5f6f 7074 2e5f 736f 6c76 6572  .mip_opt._solver
+00010cc0: 5f6d 6f64 656c 2e72 6567 6973 7465 725f  _model.register_
+00010cd0: 6361 6c6c 6261 636b 280a 2020 2020 2020  callback(.      
+00010ce0: 2020 2020 2020 2020 2020 7369 6e67 6c65            single
+00010cf0: 5f74 7265 652e 4c61 7a79 4f41 4361 6c6c  _tree.LazyOACall
+00010d00: 6261 636b 5f63 706c 6578 0a20 2020 2020  back_cplex.     
+00010d10: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00010d20: 2020 2020 2023 2070 6173 7320 6e65 6365       # pass nece
+00010d30: 7373 6172 7920 6461 7461 2061 6e64 2070  ssary data and p
+00010d40: 6172 616d 6574 6572 7320 746f 206c 617a  arameters to laz
+00010d50: 796f 610a 2020 2020 2020 2020 2020 2020  yoa.            
+00010d60: 6c61 7a79 6f61 2e6d 6169 6e5f 6d69 7020  lazyoa.main_mip 
+00010d70: 3d20 7365 6c66 2e6d 6970 0a20 2020 2020  = self.mip.     
+00010d80: 2020 2020 2020 206c 617a 796f 612e 636f         lazyoa.co
+00010d90: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
+00010da0: 6967 0a20 2020 2020 2020 2020 2020 206c  ig.            l
+00010db0: 617a 796f 612e 6f70 7420 3d20 7365 6c66  azyoa.opt = self
+00010dc0: 2e6d 6970 5f6f 7074 0a20 2020 2020 2020  .mip_opt.       
+00010dd0: 2020 2020 206c 617a 796f 612e 6d69 6e64       lazyoa.mind
+00010de0: 7470 795f 736f 6c76 6572 203d 2073 656c  tpy_solver = sel
+00010df0: 660a 2020 2020 2020 2020 2020 2020 7365  f.            se
+00010e00: 6c66 2e6d 6970 5f6f 7074 2e5f 736f 6c76  lf.mip_opt._solv
+00010e10: 6572 5f6d 6f64 656c 2e73 6574 5f77 6172  er_model.set_war
+00010e20: 6e69 6e67 5f73 7472 6561 6d28 4e6f 6e65  ning_stream(None
+00010e30: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00010e40: 6c66 2e6d 6970 5f6f 7074 2e5f 736f 6c76  lf.mip_opt._solv
+00010e50: 6572 5f6d 6f64 656c 2e73 6574 5f6c 6f67  er_model.set_log
+00010e60: 5f73 7472 6561 6d28 4e6f 6e65 290a 2020  _stream(None).  
+00010e70: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+00010e80: 6970 5f6f 7074 2e5f 736f 6c76 6572 5f6d  ip_opt._solver_m
+00010e90: 6f64 656c 2e73 6574 5f65 7272 6f72 5f73  odel.set_error_s
+00010ea0: 7472 6561 6d28 4e6f 6e65 290a 2020 2020  tream(None).    
+00010eb0: 2020 2020 6966 2073 656c 662e 636f 6e66      if self.conf
+00010ec0: 6967 2e6d 6970 5f73 6f6c 7665 7220 3d3d  ig.mip_solver ==
+00010ed0: 2027 6775 726f 6269 5f70 6572 7369 7374   'gurobi_persist
+00010ee0: 656e 7427 3a0a 2020 2020 2020 2020 2020  ent':.          
+00010ef0: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e73    self.mip_opt.s
+00010f00: 6574 5f63 616c 6c62 6163 6b28 7369 6e67  et_callback(sing
+00010f10: 6c65 5f74 7265 652e 4c61 7a79 4f41 4361  le_tree.LazyOACa
+00010f20: 6c6c 6261 636b 5f67 7572 6f62 6929 0a20  llback_gurobi). 
+00010f30: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00010f40: 6d69 705f 6f70 742e 6d69 6e64 7470 795f  mip_opt.mindtpy_
+00010f50: 736f 6c76 6572 203d 2073 656c 660a 2020  solver = self.  
+00010f60: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+00010f70: 6970 5f6f 7074 2e63 6f6e 6669 6720 3d20  ip_opt.config = 
+00010f80: 7365 6c66 2e63 6f6e 6669 670a 0a20 2020  self.config..   
+00010f90: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+00010fa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010fb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010fc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010fd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010fe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010ff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011010: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+00011020: 2320 6d69 705f 736f 6c76 652e 7079 0a0a  # mip_solve.py..
+00011030: 2020 2020 6465 6620 736f 6c76 655f 6d61      def solve_ma
+00011040: 696e 2873 656c 6629 3a0a 2020 2020 2020  in(self):.      
+00011050: 2020 2222 2254 6869 7320 6675 6e63 7469    """This functi
+00011060: 6f6e 2073 6f6c 7665 7320 7468 6520 4d49  on solves the MI
+00011070: 5020 6d61 696e 2070 726f 626c 656d 2e0a  P main problem..
+00011080: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+00011090: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+000110a0: 0a20 2020 2020 2020 2073 656c 662e 6d69  .        self.mi
+000110b0: 7020 3a20 5079 6f6d 6f20 6d6f 6465 6c0a  p : Pyomo model.
+000110c0: 2020 2020 2020 2020 2020 2020 5468 6520              The 
+000110d0: 4d49 5020 7374 6f72 6564 2069 6e20 7365  MIP stored in se
+000110e0: 6c66 2e0a 2020 2020 2020 2020 6d61 696e  lf..        main
+000110f0: 5f6d 6970 5f72 6573 756c 7473 203a 2053  _mip_results : S
+00011100: 6f6c 7665 7252 6573 756c 7473 0a20 2020  olverResults.   
+00011110: 2020 2020 2020 2020 2052 6573 756c 7473           Results
+00011120: 2066 726f 6d20 736f 6c76 696e 6720 7468   from solving th
+00011130: 6520 6d61 696e 204d 4950 2e0a 2020 2020  e main MIP..    
+00011140: 2020 2020 2222 220a 2020 2020 2020 2020      """.        
+00011150: 636f 6e66 6967 203d 2073 656c 662e 636f  config = self.co
+00011160: 6e66 6967 0a20 2020 2020 2020 2073 656c  nfig.        sel
+00011170: 662e 6d69 705f 6974 6572 202b 3d20 310a  f.mip_iter += 1.
+00011180: 0a20 2020 2020 2020 2023 2073 6574 7570  .        # setup
+00011190: 206d 6169 6e20 7072 6f62 6c65 6d0a 2020   main problem.  
+000111a0: 2020 2020 2020 7365 6c66 2e73 6574 7570        self.setup
+000111b0: 5f6d 6169 6e28 290a 2020 2020 2020 2020  _main().        
+000111c0: 6d69 705f 6172 6773 203d 2073 656c 662e  mip_args = self.
+000111d0: 7365 745f 7570 5f6d 6970 5f73 6f6c 7665  set_up_mip_solve
+000111e0: 7228 290a 2020 2020 2020 2020 7570 6461  r().        upda
+000111f0: 7465 5f73 6f6c 7665 725f 7469 6d65 6c69  te_solver_timeli
+00011200: 6d69 7428 7365 6c66 2e6d 6970 5f6f 7074  mit(self.mip_opt
+00011210: 2c20 636f 6e66 6967 2e6d 6970 5f73 6f6c  , config.mip_sol
+00011220: 7665 722c 2073 656c 662e 7469 6d69 6e67  ver, self.timing
+00011230: 2c20 636f 6e66 6967 290a 0a20 2020 2020  , config)..     
+00011240: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+00011250: 2020 2020 6d61 696e 5f6d 6970 5f72 6573      main_mip_res
+00011260: 756c 7473 203d 2073 656c 662e 6d69 705f  ults = self.mip_
+00011270: 6f70 742e 736f 6c76 6528 0a20 2020 2020  opt.solve(.     
+00011280: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00011290: 6d69 702c 0a20 2020 2020 2020 2020 2020  mip,.           
+000112a0: 2020 2020 2074 6565 3d63 6f6e 6669 672e       tee=config.
+000112b0: 6d69 705f 736f 6c76 6572 5f74 6565 2c0a  mip_solver_tee,.
+000112c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000112d0: 6c6f 6164 5f73 6f6c 7574 696f 6e73 3d73  load_solutions=s
+000112e0: 656c 662e 6d69 705f 6c6f 6164 5f73 6f6c  elf.mip_load_sol
+000112f0: 7574 696f 6e73 2c0a 2020 2020 2020 2020  utions,.        
+00011300: 2020 2020 2020 2020 2a2a 6d69 705f 6172          **mip_ar
+00011310: 6773 2c0a 2020 2020 2020 2020 2020 2020  gs,.            
+00011320: 290a 2020 2020 2020 2020 2020 2020 2320  ).            # 
+00011330: 7570 6461 7465 5f61 7474 7269 6275 7465  update_attribute
+00011340: 7320 7368 6f75 6c64 2062 6520 6265 666f  s should be befo
+00011350: 7265 206c 6f61 645f 6672 6f6d 286d 6169  re load_from(mai
+00011360: 6e5f 6d69 705f 7265 7375 6c74 7329 2c20  n_mip_results), 
+00011370: 7369 6e63 6520 6c6f 6164 5f66 726f 6d28  since load_from(
+00011380: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+00011390: 2920 6d61 7920 6661 696c 2e0a 2020 2020  ) may fail..    
+000113a0: 2020 2020 2020 2020 6966 206c 656e 286d          if len(m
+000113b0: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
+000113c0: 736f 6c75 7469 6f6e 2920 3e20 303a 0a20  solution) > 0:. 
+000113d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000113e0: 656c 662e 6d69 702e 736f 6c75 7469 6f6e  elf.mip.solution
+000113f0: 732e 6c6f 6164 5f66 726f 6d28 6d61 696e  s.load_from(main
+00011400: 5f6d 6970 5f72 6573 756c 7473 290a 2020  _mip_results).  
+00011410: 2020 2020 2020 6578 6365 7074 2028 5661        except (Va
+00011420: 6c75 6545 7272 6f72 2c20 4174 7472 6962  lueError, Attrib
+00011430: 7574 6545 7272 6f72 2c20 5275 6e74 696d  uteError, Runtim
+00011440: 6545 7272 6f72 2920 6173 2065 3a0a 2020  eError) as e:.  
+00011450: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+00011460: 2e6c 6f67 6765 722e 6572 726f 7228 652c  .logger.error(e,
+00011470: 2065 7863 5f69 6e66 6f3d 5472 7565 290a   exc_info=True).
+00011480: 2020 2020 2020 2020 2020 2020 6966 2063              if c
+00011490: 6f6e 6669 672e 7369 6e67 6c65 5f74 7265  onfig.single_tre
+000114a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+000114b0: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+000114c0: 2e77 6172 6e69 6e67 2827 5369 6e67 6c65  .warning('Single
+000114d0: 2074 7265 6520 7465 726d 696e 6174 652e   tree terminate.
+000114e0: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
+000114f0: 2020 2069 6620 6765 745f 6d61 696e 5f65     if get_main_e
+00011500: 6c61 7073 6564 5f74 696d 6528 7365 6c66  lapsed_time(self
+00011510: 2e74 696d 696e 6729 203e 3d20 636f 6e66  .timing) >= conf
+00011520: 6967 2e74 696d 655f 6c69 6d69 743a 0a20  ig.time_limit:. 
+00011530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011540: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
+00011550: 2e77 6172 6e69 6e67 2827 6475 6520 746f  .warning('due to
+00011560: 2074 6865 2074 696d 656c 696d 6974 2e27   the timelimit.'
+00011570: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00011580: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
+00011590: 7473 2e73 6f6c 7665 722e 7465 726d 696e  ts.solver.termin
+000115a0: 6174 696f 6e5f 636f 6e64 6974 696f 6e20  ation_condition 
+000115b0: 3d20 7463 2e6d 6178 5469 6d65 4c69 6d69  = tc.maxTimeLimi
+000115c0: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
+000115d0: 2020 6966 2063 6f6e 6669 672e 7374 7261    if config.stra
+000115e0: 7465 6779 203d 3d20 2747 4f41 2720 6f72  tegy == 'GOA' or
+000115f0: 2063 6f6e 6669 672e 6164 645f 6e6f 5f67   config.add_no_g
+00011600: 6f6f 645f 6375 7473 3a0a 2020 2020 2020  ood_cuts:.      
+00011610: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00011620: 6e66 6967 2e6c 6f67 6765 722e 7761 726e  nfig.logger.warn
+00011630: 696e 6728 0a20 2020 2020 2020 2020 2020  ing(.           
+00011640: 2020 2020 2020 2020 2020 2020 2027 4572               'Er
+00011650: 726f 723a 2043 616e 6e6f 7420 6c6f 6164  ror: Cannot load
+00011660: 2061 2053 6f6c 7665 7252 6573 756c 7473   a SolverResults
+00011670: 206f 626a 6563 7420 7769 7468 2062 6164   object with bad
+00011680: 2073 7461 7475 733a 2065 7272 6f72 2e20   status: error. 
+00011690: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+000116a0: 2020 2020 2020 2020 2020 274d 4950 2073            'MIP s
+000116b0: 6f6c 7665 7220 6661 696c 6564 2e20 5468  olver failed. Th
+000116c0: 6973 2075 7375 616c 6c79 2068 6170 7065  is usually happe
+000116d0: 6e73 2069 6e20 7468 6520 7369 6e67 6c65  ns in the single
+000116e0: 2d74 7265 6520 474f 4120 616c 676f 7269  -tree GOA algori
+000116f0: 7468 6d2e 2027 0a20 2020 2020 2020 2020  thm. '.         
+00011700: 2020 2020 2020 2020 2020 2020 2020 2022                 "
+00011710: 4e6f 2d67 6f6f 6420 6375 7473 2061 7265  No-good cuts are
+00011720: 2061 6464 6564 2061 6e64 2047 4f41 2061   added and GOA a
+00011730: 6c67 6f72 6974 686d 2064 6f65 736e 2774  lgorithm doesn't
+00011740: 2063 6f6e 7665 7267 6520 7769 7468 696e   converge within
+00011750: 2074 6865 2074 696d 6520 6c69 6d69 742e   the time limit.
+00011760: 2022 0a20 2020 2020 2020 2020 2020 2020   ".             
+00011770: 2020 2020 2020 2020 2020 2027 4e6f 2069             'No i
+00011780: 6e74 6567 6572 2073 6f6c 7574 696f 6e20  nteger solution 
+00011790: 6973 2066 6f75 6e64 2c20 736f 2074 6865  is found, so the
+000117a0: 2043 504c 4558 2073 6f6c 7665 7220 7769   CPLEX solver wi
+000117b0: 6c6c 2072 6570 6f72 7420 616e 2065 7272  ll report an err
+000117c0: 6f72 2073 7461 7475 732e 2027 0a20 2020  or status. '.   
+000117d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000117e0: 2029 0a20 2020 2020 2020 2020 2020 2023   ).            #
+000117f0: 2056 616c 7565 2065 7272 6f72 2077 696c   Value error wil
+00011800: 6c20 6265 2072 6169 7365 6420 6966 2074  l be raised if t
+00011810: 6865 204d 4950 2070 726f 626c 656d 2069  he MIP problem i
+00011820: 7320 756e 626f 756e 6465 6420 616e 6420  s unbounded and 
+00011830: 6170 7073 6920 736f 6c76 6572 2069 7320  appsi solver is 
+00011840: 7573 6564 2077 6865 6e20 6c6f 6164 696e  used when loadin
+00011850: 6720 736f 6c75 7469 6f6e 732e 2041 6c74  g solutions. Alt
+00011860: 686f 7567 6820 7468 6520 7072 6f62 6c65  hough the proble
+00011870: 6d20 6973 2075 6e62 6f75 6e64 6564 2c20  m is unbounded, 
+00011880: 6120 7661 6c69 6420 7265 7375 6c74 2069  a valid result i
+00011890: 7320 7072 6f76 6964 6564 2061 6e64 2077  s provided and w
+000118a0: 6520 646f 206e 6f74 2072 6574 7572 6e20  e do not return 
+000118b0: 4e6f 6e65 2074 6f20 6c65 7420 7468 6520  None to let the 
+000118c0: 616c 676f 7269 7468 6d20 636f 6e74 696e  algorithm contin
+000118d0: 7565 2e0a 2020 2020 2020 2020 2020 2020  ue..            
+000118e0: 6966 2027 6d61 696e 5f6d 6970 5f72 6573  if 'main_mip_res
+000118f0: 756c 7473 2720 696e 206c 6f63 616c 7328  ults' in locals(
+00011900: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00011910: 2020 2072 6574 7572 6e20 7365 6c66 2e6d     return self.m
+00011920: 6970 2c20 6d61 696e 5f6d 6970 5f72 6573  ip, main_mip_res
+00011930: 756c 7473 0a20 2020 2020 2020 2020 2020  ults.           
+00011940: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00011950: 2020 2020 2020 2072 6574 7572 6e20 4e6f         return No
+00011960: 6e65 2c20 4e6f 6e65 0a20 2020 2020 2020  ne, None.       
+00011970: 2069 6620 636f 6e66 6967 2e73 6f6c 7574   if config.solut
+00011980: 696f 6e5f 706f 6f6c 3a0a 2020 2020 2020  ion_pool:.      
+00011990: 2020 2020 2020 6d61 696e 5f6d 6970 5f72        main_mip_r
+000119a0: 6573 756c 7473 2e5f 736f 6c76 6572 5f6d  esults._solver_m
+000119b0: 6f64 656c 203d 2073 656c 662e 6d69 705f  odel = self.mip_
+000119c0: 6f70 742e 5f73 6f6c 7665 725f 6d6f 6465  opt._solver_mode
+000119d0: 6c0a 2020 2020 2020 2020 2020 2020 6d61  l.            ma
+000119e0: 696e 5f6d 6970 5f72 6573 756c 7473 2e5f  in_mip_results._
+000119f0: 7079 6f6d 6f5f 7661 725f 746f 5f73 6f6c  pyomo_var_to_sol
+00011a00: 7665 725f 7661 725f 6d61 7020 3d20 280a  ver_var_map = (.
+00011a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011a20: 7365 6c66 2e6d 6970 5f6f 7074 2e5f 7079  self.mip_opt._py
+00011a30: 6f6d 6f5f 7661 725f 746f 5f73 6f6c 7665  omo_var_to_solve
+00011a40: 725f 7661 725f 6d61 700a 2020 2020 2020  r_var_map.      
+00011a50: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00011a60: 6966 206d 6169 6e5f 6d69 705f 7265 7375  if main_mip_resu
+00011a70: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+00011a80: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+00011a90: 2069 7320 7463 2e6f 7074 696d 616c 3a0a   is tc.optimal:.
+00011aa0: 2020 2020 2020 2020 2020 2020 6966 2063              if c
+00011ab0: 6f6e 6669 672e 7369 6e67 6c65 5f74 7265  onfig.single_tre
+00011ac0: 6520 616e 6420 6e6f 7420 636f 6e66 6967  e and not config
+00011ad0: 2e61 6464 5f6e 6f5f 676f 6f64 5f63 7574  .add_no_good_cut
+00011ae0: 733a 0a20 2020 2020 2020 2020 2020 2020  s:.             
+00011af0: 2020 2073 656c 662e 7570 6461 7465 5f73     self.update_s
+00011b00: 7562 6f70 7469 6d61 6c5f 6475 616c 5f62  uboptimal_dual_b
+00011b10: 6f75 6e64 286d 6169 6e5f 6d69 705f 7265  ound(main_mip_re
+00011b20: 7375 6c74 7329 0a20 2020 2020 2020 2065  sults).        e
+00011b30: 6c69 6620 6d61 696e 5f6d 6970 5f72 6573  lif main_mip_res
+00011b40: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+00011b50: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+00011b60: 6e20 6973 2074 632e 696e 6665 6173 6962  n is tc.infeasib
+00011b70: 6c65 4f72 556e 626f 756e 6465 643a 0a20  leOrUnbounded:. 
+00011b80: 2020 2020 2020 2020 2020 2023 204c 696e             # Lin
+00011b90: 6561 7220 736f 6c76 6572 7320 7769 6c6c  ear solvers will
+00011ba0: 2073 6f6d 6574 696d 6573 2074 656c 6c20   sometimes tell 
+00011bb0: 6d65 2074 6861 7420 6974 2773 2069 6e66  me that it's inf
+00011bc0: 6561 7369 626c 6520 6f72 0a20 2020 2020  easible or.     
+00011bd0: 2020 2020 2020 2023 2075 6e62 6f75 6e64         # unbound
+00011be0: 6564 2064 7572 696e 6720 7072 6573 6f6c  ed during presol
+00011bf0: 7665 2c20 6275 7420 6661 696c 7320 746f  ve, but fails to
+00011c00: 2064 6973 7469 6e67 7569 7368 2e20 5765   distinguish. We
+00011c10: 206e 6565 6420 746f 0a20 2020 2020 2020   need to.       
+00011c20: 2020 2020 2023 2072 6573 6f6c 7665 2077       # resolve w
+00011c30: 6974 6820 6120 736f 6c76 6572 206f 7074  ith a solver opt
+00011c40: 696f 6e20 666c 6167 206f 6e2e 0a20 2020  ion flag on..   
+00011c50: 2020 2020 2020 2020 206d 6169 6e5f 6d69           main_mi
+00011c60: 705f 7265 7375 6c74 732c 205f 203d 2064  p_results, _ = d
+00011c70: 6973 7469 6e67 7569 7368 5f6d 6970 5f69  istinguish_mip_i
+00011c80: 6e66 6561 7369 626c 655f 6f72 5f75 6e62  nfeasible_or_unb
+00011c90: 6f75 6e64 6564 280a 2020 2020 2020 2020  ounded(.        
+00011ca0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00011cb0: 2c20 636f 6e66 6967 0a20 2020 2020 2020  , config.       
+00011cc0: 2020 2020 2029 0a20 2020 2020 2020 2072       ).        r
+00011cd0: 6574 7572 6e20 7365 6c66 2e6d 6970 2c20  eturn self.mip, 
+00011ce0: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+00011cf0: 0a0a 2020 2020 6465 6620 736f 6c76 655f  ..    def solve_
+00011d00: 6670 5f6d 6169 6e28 7365 6c66 293a 0a20  fp_main(self):. 
+00011d10: 2020 2020 2020 2022 2222 5468 6973 2066         """This f
+00011d20: 756e 6374 696f 6e20 736f 6c76 6573 2074  unction solves t
+00011d30: 6865 204d 4950 206d 6169 6e20 7072 6f62  he MIP main prob
+00011d40: 6c65 6d2e 0a0a 2020 2020 2020 2020 5265  lem...        Re
+00011d50: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
+00011d60: 2d2d 2d2d 2d0a 2020 2020 2020 2020 7365  -----.        se
+00011d70: 6c66 2e6d 6970 203a 2050 796f 6d6f 206d  lf.mip : Pyomo m
+00011d80: 6f64 656c 0a20 2020 2020 2020 2020 2020  odel.           
+00011d90: 2054 6865 204d 4950 2073 746f 7265 6420   The MIP stored 
+00011da0: 696e 2073 656c 662e 0a20 2020 2020 2020  in self..       
+00011db0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+00011dc0: 7320 3a20 536f 6c76 6572 5265 7375 6c74  s : SolverResult
+00011dd0: 730a 2020 2020 2020 2020 2020 2020 5265  s.            Re
+00011de0: 7375 6c74 7320 6672 6f6d 2073 6f6c 7669  sults from solvi
+00011df0: 6e67 2074 6865 206d 6169 6e20 4d49 502e  ng the main MIP.
+00011e00: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00011e10: 2020 2020 2023 2073 6574 7570 206d 6169       # setup mai
+00011e20: 6e20 7072 6f62 6c65 6d0a 2020 2020 2020  n problem.      
+00011e30: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
+00011e40: 636f 6e66 6967 0a20 2020 2020 2020 2073  config.        s
+00011e50: 656c 662e 7365 7475 705f 6670 5f6d 6169  elf.setup_fp_mai
+00011e60: 6e28 290a 2020 2020 2020 2020 6d69 705f  n().        mip_
+00011e70: 6172 6773 203d 2073 656c 662e 7365 745f  args = self.set_
+00011e80: 7570 5f6d 6970 5f73 6f6c 7665 7228 290a  up_mip_solver().
+00011e90: 2020 2020 2020 2020 7570 6461 7465 5f73          update_s
+00011ea0: 6f6c 7665 725f 7469 6d65 6c69 6d69 7428  olver_timelimit(
+00011eb0: 7365 6c66 2e6d 6970 5f6f 7074 2c20 636f  self.mip_opt, co
+00011ec0: 6e66 6967 2e6d 6970 5f73 6f6c 7665 722c  nfig.mip_solver,
+00011ed0: 2073 656c 662e 7469 6d69 6e67 2c20 636f   self.timing, co
+00011ee0: 6e66 6967 290a 0a20 2020 2020 2020 206d  nfig)..        m
+00011ef0: 6169 6e5f 6d69 705f 7265 7375 6c74 7320  ain_mip_results 
+00011f00: 3d20 7365 6c66 2e6d 6970 5f6f 7074 2e73  = self.mip_opt.s
+00011f10: 6f6c 7665 280a 2020 2020 2020 2020 2020  olve(.          
+00011f20: 2020 7365 6c66 2e6d 6970 2c0a 2020 2020    self.mip,.    
+00011f30: 2020 2020 2020 2020 7465 653d 636f 6e66          tee=conf
+00011f40: 6967 2e6d 6970 5f73 6f6c 7665 725f 7465  ig.mip_solver_te
+00011f50: 652c 0a20 2020 2020 2020 2020 2020 206c  e,.            l
+00011f60: 6f61 645f 736f 6c75 7469 6f6e 733d 7365  oad_solutions=se
+00011f70: 6c66 2e6d 6970 5f6c 6f61 645f 736f 6c75  lf.mip_load_solu
+00011f80: 7469 6f6e 732c 0a20 2020 2020 2020 2020  tions,.         
+00011f90: 2020 202a 2a6d 6970 5f61 7267 732c 0a20     **mip_args,. 
+00011fa0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00011fb0: 2023 2075 7064 6174 655f 6174 7472 6962   # update_attrib
+00011fc0: 7574 6573 2073 686f 756c 6420 6265 2062  utes should be b
+00011fd0: 6566 6f72 6520 6c6f 6164 5f66 726f 6d28  efore load_from(
+00011fe0: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+00011ff0: 292c 2073 696e 6365 206c 6f61 645f 6672  ), since load_fr
+00012000: 6f6d 286d 6169 6e5f 6d69 705f 7265 7375  om(main_mip_resu
+00012010: 6c74 7329 206d 6179 2066 6169 6c2e 0a20  lts) may fail.. 
+00012020: 2020 2020 2020 2023 2069 6620 636f 6e66         # if conf
+00012030: 6967 2e73 696e 676c 655f 7472 6565 206f  ig.single_tree o
+00012040: 7220 636f 6e66 6967 2e75 7365 5f74 6162  r config.use_tab
+00012050: 755f 6c69 7374 3a0a 2020 2020 2020 2020  u_list:.        
+00012060: 2320 2020 2020 7365 6c66 2e75 7064 6174  #     self.updat
+00012070: 655f 6174 7472 6962 7574 6573 2829 0a20  e_attributes(). 
+00012080: 2020 2020 2020 2069 6620 6c65 6e28 6d61         if len(ma
+00012090: 696e 5f6d 6970 5f72 6573 756c 7473 2e73  in_mip_results.s
+000120a0: 6f6c 7574 696f 6e29 203e 2030 3a0a 2020  olution) > 0:.  
+000120b0: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+000120c0: 6970 2e73 6f6c 7574 696f 6e73 2e6c 6f61  ip.solutions.loa
+000120d0: 645f 6672 6f6d 286d 6169 6e5f 6d69 705f  d_from(main_mip_
+000120e0: 7265 7375 6c74 7329 0a20 2020 2020 2020  results).       
+000120f0: 2069 6620 6d61 696e 5f6d 6970 5f72 6573   if main_mip_res
+00012100: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+00012110: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+00012120: 6e20 6973 2074 632e 696e 6665 6173 6962  n is tc.infeasib
+00012130: 6c65 4f72 556e 626f 756e 6465 643a 0a20  leOrUnbounded:. 
+00012140: 2020 2020 2020 2020 2020 2023 204c 696e             # Lin
+00012150: 6561 7220 736f 6c76 6572 7320 7769 6c6c  ear solvers will
+00012160: 2073 6f6d 6574 696d 6573 2074 656c 6c20   sometimes tell 
+00012170: 6d65 2074 6861 7420 6974 2773 2069 6e66  me that it's inf
+00012180: 6561 7369 626c 6520 6f72 0a20 2020 2020  easible or.     
+00012190: 2020 2020 2020 2023 2075 6e62 6f75 6e64         # unbound
+000121a0: 6564 2064 7572 696e 6720 7072 6573 6f6c  ed during presol
+000121b0: 7665 2c20 6275 7420 6661 696c 7320 746f  ve, but fails to
+000121c0: 2064 6973 7469 6e67 7569 7368 2e20 5765   distinguish. We
+000121d0: 206e 6565 6420 746f 0a20 2020 2020 2020   need to.       
+000121e0: 2020 2020 2023 2072 6573 6f6c 7665 2077       # resolve w
+000121f0: 6974 6820 6120 736f 6c76 6572 206f 7074  ith a solver opt
+00012200: 696f 6e20 666c 6167 206f 6e2e 0a20 2020  ion flag on..   
+00012210: 2020 2020 2020 2020 206d 6169 6e5f 6d69           main_mi
+00012220: 705f 7265 7375 6c74 732c 205f 203d 2064  p_results, _ = d
+00012230: 6973 7469 6e67 7569 7368 5f6d 6970 5f69  istinguish_mip_i
+00012240: 6e66 6561 7369 626c 655f 6f72 5f75 6e62  nfeasible_or_unb
+00012250: 6f75 6e64 6564 280a 2020 2020 2020 2020  ounded(.        
+00012260: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00012270: 2c20 636f 6e66 6967 0a20 2020 2020 2020  , config.       
+00012280: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+00012290: 7265 7475 726e 2073 656c 662e 6d69 702c  return self.mip,
+000122a0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+000122b0: 730a 0a20 2020 2064 6566 2073 6f6c 7665  s..    def solve
+000122c0: 5f72 6567 756c 6172 697a 6174 696f 6e5f  _regularization_
+000122d0: 6d61 696e 2873 656c 6629 3a0a 2020 2020  main(self):.    
+000122e0: 2020 2020 2222 2254 6869 7320 6675 6e63      """This func
+000122f0: 7469 6f6e 2073 6f6c 7665 7320 7468 6520  tion solves the 
+00012300: 4d49 5020 6d61 696e 2070 726f 626c 656d  MIP main problem
+00012310: 2e0a 0a20 2020 2020 2020 2052 6574 7572  ...        Retur
+00012320: 6e73 0a20 2020 2020 2020 202d 2d2d 2d2d  ns.        -----
+00012330: 2d2d 0a20 2020 2020 2020 2073 656c 662e  --.        self.
+00012340: 6d69 7020 3a20 5079 6f6d 6f20 6d6f 6465  mip : Pyomo mode
+00012350: 6c0a 2020 2020 2020 2020 2020 2020 5468  l.            Th
+00012360: 6520 4d49 5020 7374 6f72 6564 2069 6e20  e MIP stored in 
+00012370: 7365 6c66 2e0a 2020 2020 2020 2020 6d61  self..        ma
+00012380: 696e 5f6d 6970 5f72 6573 756c 7473 203a  in_mip_results :
+00012390: 2053 6f6c 7665 7252 6573 756c 7473 0a20   SolverResults. 
+000123a0: 2020 2020 2020 2020 2020 2052 6573 756c             Resul
+000123b0: 7473 2066 726f 6d20 736f 6c76 696e 6720  ts from solving 
+000123c0: 7468 6520 6d61 696e 204d 4950 2e0a 2020  the main MIP..  
+000123d0: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+000123e0: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
+000123f0: 636f 6e66 6967 0a20 2020 2020 2020 2023  config.        #
+00012400: 2073 6574 7570 206d 6169 6e20 7072 6f62   setup main prob
+00012410: 6c65 6d0a 2020 2020 2020 2020 7365 6c66  lem.        self
+00012420: 2e73 6574 7570 5f72 6567 756c 6172 697a  .setup_regulariz
+00012430: 6174 696f 6e5f 6d61 696e 2829 0a0a 2020  ation_main()..  
+00012440: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00012450: 6e63 6528 7365 6c66 2e72 6567 756c 6172  nce(self.regular
+00012460: 697a 6174 696f 6e5f 6d69 705f 6f70 742c  ization_mip_opt,
+00012470: 2050 6572 7369 7374 656e 7453 6f6c 7665   PersistentSolve
+00012480: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
+00012490: 7365 6c66 2e72 6567 756c 6172 697a 6174  self.regularizat
+000124a0: 696f 6e5f 6d69 705f 6f70 742e 7365 745f  ion_mip_opt.set_
+000124b0: 696e 7374 616e 6365 2873 656c 662e 6d69  instance(self.mi
+000124c0: 7029 0a20 2020 2020 2020 2075 7064 6174  p).        updat
+000124d0: 655f 736f 6c76 6572 5f74 696d 656c 696d  e_solver_timelim
+000124e0: 6974 280a 2020 2020 2020 2020 2020 2020  it(.            
+000124f0: 7365 6c66 2e72 6567 756c 6172 697a 6174  self.regularizat
+00012500: 696f 6e5f 6d69 705f 6f70 742c 0a20 2020  ion_mip_opt,.   
+00012510: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00012520: 6d69 705f 7265 6775 6c61 7269 7a61 7469  mip_regularizati
+00012530: 6f6e 5f73 6f6c 7665 722c 0a20 2020 2020  on_solver,.     
+00012540: 2020 2020 2020 2073 656c 662e 7469 6d69         self.timi
+00012550: 6e67 2c0a 2020 2020 2020 2020 2020 2020  ng,.            
+00012560: 636f 6e66 6967 2c0a 2020 2020 2020 2020  config,.        
+00012570: 290a 2020 2020 2020 2020 6d61 696e 5f6d  ).        main_m
+00012580: 6970 5f72 6573 756c 7473 203d 2073 656c  ip_results = sel
+00012590: 662e 7265 6775 6c61 7269 7a61 7469 6f6e  f.regularization
+000125a0: 5f6d 6970 5f6f 7074 2e73 6f6c 7665 280a  _mip_opt.solve(.
+000125b0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000125c0: 2e6d 6970 2c0a 2020 2020 2020 2020 2020  .mip,.          
+000125d0: 2020 7465 653d 636f 6e66 6967 2e6d 6970    tee=config.mip
+000125e0: 5f73 6f6c 7665 725f 7465 652c 0a20 2020  _solver_tee,.   
+000125f0: 2020 2020 2020 2020 206c 6f61 645f 736f           load_so
+00012600: 6c75 7469 6f6e 733d 7365 6c66 2e72 6567  lutions=self.reg
+00012610: 756c 6172 697a 6174 696f 6e5f 6d69 705f  ularization_mip_
+00012620: 6c6f 6164 5f73 6f6c 7574 696f 6e73 2c0a  load_solutions,.
+00012630: 2020 2020 2020 2020 2020 2020 2a2a 6469              **di
+00012640: 6374 2863 6f6e 6669 672e 6d69 705f 736f  ct(config.mip_so
+00012650: 6c76 6572 5f61 7267 7329 2c0a 2020 2020  lver_args),.    
+00012660: 2020 2020 290a 2020 2020 2020 2020 6966      ).        if
+00012670: 206c 656e 286d 6169 6e5f 6d69 705f 7265   len(main_mip_re
+00012680: 7375 6c74 732e 736f 6c75 7469 6f6e 2920  sults.solution) 
+00012690: 3e20 303a 0a20 2020 2020 2020 2020 2020  > 0:.           
+000126a0: 2073 656c 662e 6d69 702e 736f 6c75 7469   self.mip.soluti
+000126b0: 6f6e 732e 6c6f 6164 5f66 726f 6d28 6d61  ons.load_from(ma
+000126c0: 696e 5f6d 6970 5f72 6573 756c 7473 290a  in_mip_results).
+000126d0: 2020 2020 2020 2020 6966 206d 6169 6e5f          if main_
+000126e0: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
+000126f0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+00012700: 6f6e 6469 7469 6f6e 2069 7320 7463 2e6f  ondition is tc.o
+00012710: 7074 696d 616c 3a0a 2020 2020 2020 2020  ptimal:.        
+00012720: 2020 2020 636f 6e66 6967 2e6c 6f67 6765      config.logge
+00012730: 722e 696e 666f 280a 2020 2020 2020 2020  r.info(.        
+00012740: 2020 2020 2020 2020 7365 6c66 2e6c 6f67          self.log
+00012750: 5f66 6f72 6d61 7474 6572 2e66 6f72 6d61  _formatter.forma
+00012760: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+00012770: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
+00012780: 6974 6572 2c0a 2020 2020 2020 2020 2020  iter,.          
+00012790: 2020 2020 2020 2020 2020 2752 6567 2027            'Reg '
+000127a0: 202b 2073 656c 662e 7265 6775 6c61 7269   + self.regulari
+000127b0: 7a61 7469 6f6e 5f6d 6970 5f74 7970 652c  zation_mip_type,
+000127c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000127d0: 2020 2020 2076 616c 7565 2873 656c 662e       value(self.
+000127e0: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
+000127f0: 732e 726f 615f 7072 6f6a 5f6d 6970 5f6f  s.roa_proj_mip_o
+00012800: 626a 292c 0a20 2020 2020 2020 2020 2020  bj),.           
+00012810: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
+00012820: 696d 616c 5f62 6f75 6e64 2c0a 2020 2020  imal_bound,.    
+00012830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012840: 7365 6c66 2e64 7561 6c5f 626f 756e 642c  self.dual_bound,
+00012850: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012860: 2020 2020 2073 656c 662e 7265 6c5f 6761       self.rel_ga
+00012870: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
+00012880: 2020 2020 2020 2067 6574 5f6d 6169 6e5f         get_main_
+00012890: 656c 6170 7365 645f 7469 6d65 2873 656c  elapsed_time(sel
+000128a0: 662e 7469 6d69 6e67 292c 0a20 2020 2020  f.timing),.     
+000128b0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+000128c0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+000128d0: 2020 2020 656c 6966 206d 6169 6e5f 6d69      elif main_mi
+000128e0: 705f 7265 7375 6c74 732e 736f 6c76 6572  p_results.solver
+000128f0: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
+00012900: 6469 7469 6f6e 2069 7320 7463 2e69 6e66  dition is tc.inf
+00012910: 6561 7369 626c 654f 7255 6e62 6f75 6e64  easibleOrUnbound
+00012920: 6564 3a0a 2020 2020 2020 2020 2020 2020  ed:.            
+00012930: 2320 4c69 6e65 6172 2073 6f6c 7665 7273  # Linear solvers
+00012940: 2077 696c 6c20 736f 6d65 7469 6d65 7320   will sometimes 
+00012950: 7465 6c6c 206d 6520 7468 6174 2069 7427  tell me that it'
+00012960: 7320 696e 6665 6173 6962 6c65 206f 720a  s infeasible or.
+00012970: 2020 2020 2020 2020 2020 2020 2320 756e              # un
+00012980: 626f 756e 6465 6420 6475 7269 6e67 2070  bounded during p
+00012990: 7265 736f 6c76 652c 2062 7574 2066 6169  resolve, but fai
+000129a0: 6c73 2074 6f20 6469 7374 696e 6775 6973  ls to distinguis
+000129b0: 682e 2057 6520 6e65 6564 2074 6f0a 2020  h. We need to.  
+000129c0: 2020 2020 2020 2020 2020 2320 7265 736f            # reso
+000129d0: 6c76 6520 7769 7468 2061 2073 6f6c 7665  lve with a solve
+000129e0: 7220 6f70 7469 6f6e 2066 6c61 6720 6f6e  r option flag on
+000129f0: 2e0a 2020 2020 2020 2020 2020 2020 6d61  ..            ma
+00012a00: 696e 5f6d 6970 5f72 6573 756c 7473 2c20  in_mip_results, 
+00012a10: 5f20 3d20 6469 7374 696e 6775 6973 685f  _ = distinguish_
+00012a20: 6d69 705f 696e 6665 6173 6962 6c65 5f6f  mip_infeasible_o
+00012a30: 725f 756e 626f 756e 6465 6428 0a20 2020  r_unbounded(.   
+00012a40: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00012a50: 662e 6d69 702c 2063 6f6e 6669 670a 2020  f.mip, config.  
+00012a60: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00012a70: 2020 2020 2073 656c 662e 6d69 702e 4d69       self.mip.Mi
+00012a80: 6e64 7450 795f 7574 696c 732e 6f62 6a65  ndtPy_utils.obje
+00012a90: 6374 6976 655f 636f 6e73 7472 2e64 6561  ctive_constr.dea
+00012aa0: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
+00012ab0: 2020 7365 6c66 2e6d 6970 2e4d 696e 6474    self.mip.Mindt
+00012ac0: 5079 5f75 7469 6c73 2e64 656c 5f63 6f6d  Py_utils.del_com
+00012ad0: 706f 6e65 6e74 2827 726f 615f 7072 6f6a  ponent('roa_proj
+00012ae0: 5f6d 6970 5f6f 626a 2729 0a20 2020 2020  _mip_obj').     
+00012af0: 2020 2073 656c 662e 6d69 702e 4d69 6e64     self.mip.Mind
+00012b00: 7450 795f 7574 696c 732e 6375 7473 2e64  tPy_utils.cuts.d
+00012b10: 656c 5f63 6f6d 706f 6e65 6e74 2827 6f62  el_component('ob
+00012b20: 6a5f 7265 675f 6573 7469 6d61 7465 2729  j_reg_estimate')
+00012b30: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
+00012b40: 6967 2e61 6464 5f72 6567 756c 6172 697a  ig.add_regulariz
+00012b50: 6174 696f 6e20 3d3d 2027 6c65 7665 6c5f  ation == 'level_
+00012b60: 4c31 273a 0a20 2020 2020 2020 2020 2020  L1':.           
+00012b70: 2073 656c 662e 6d69 702e 4d69 6e64 7450   self.mip.MindtP
+00012b80: 795f 7574 696c 732e 6465 6c5f 636f 6d70  y_utils.del_comp
+00012b90: 6f6e 656e 7428 274c 315f 6f62 6a27 290a  onent('L1_obj').
+00012ba0: 2020 2020 2020 2020 656c 6966 2063 6f6e          elif con
+00012bb0: 6669 672e 6164 645f 7265 6775 6c61 7269  fig.add_regulari
+00012bc0: 7a61 7469 6f6e 203d 3d20 276c 6576 656c  zation == 'level
+00012bd0: 5f4c 5f69 6e66 696e 6974 7927 3a0a 2020  _L_infinity':.  
+00012be0: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+00012bf0: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
+00012c00: 2e64 656c 5f63 6f6d 706f 6e65 6e74 2827  .del_component('
+00012c10: 4c5f 696e 6669 6e69 7479 5f6f 626a 2729  L_infinity_obj')
+00012c20: 0a0a 2020 2020 2020 2020 7265 7475 726e  ..        return
+00012c30: 2073 656c 662e 6d69 702c 206d 6169 6e5f   self.mip, main_
+00012c40: 6d69 705f 7265 7375 6c74 730a 0a20 2020  mip_results..   
+00012c50: 2064 6566 2073 6574 5f75 705f 6d69 705f   def set_up_mip_
+00012c60: 736f 6c76 6572 2873 656c 6629 3a0a 2020  solver(self):.  
+00012c70: 2020 2020 2020 2222 2253 6574 2075 7020        """Set up 
+00012c80: 7468 6520 4d49 5020 736f 6c76 6572 2e0a  the MIP solver..
+00012c90: 0a20 2020 2020 2020 2052 6574 7572 6e73  .        Returns
+00012ca0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
+00012cb0: 0a20 2020 2020 2020 206d 6169 6e6f 7074  .        mainopt
+00012cc0: 203a 2053 6f6c 7665 7246 6163 746f 7279   : SolverFactory
+00012cd0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+00012ce0: 2063 7573 746f 6d69 7a65 6420 4d49 5020   customized MIP 
+00012cf0: 736f 6c76 6572 2e0a 2020 2020 2020 2020  solver..        
+00012d00: 2222 220a 2020 2020 2020 2020 2320 6465  """.        # de
+00012d10: 7465 726d 696e 6520 6966 2070 6572 7369  termine if persi
+00012d20: 7374 656e 7420 736f 6c76 6572 2069 7320  stent solver is 
+00012d30: 6361 6c6c 6564 2e0a 2020 2020 2020 2020  called..        
+00012d40: 636f 6e66 6967 203d 2073 656c 662e 636f  config = self.co
+00012d50: 6e66 6967 0a20 2020 2020 2020 2069 6620  nfig.        if 
+00012d60: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
+00012d70: 6d69 705f 6f70 742c 2050 6572 7369 7374  mip_opt, Persist
+00012d80: 656e 7453 6f6c 7665 7229 3a0a 2020 2020  entSolver):.    
+00012d90: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00012da0: 5f6f 7074 2e73 6574 5f69 6e73 7461 6e63  _opt.set_instanc
+00012db0: 6528 7365 6c66 2e6d 6970 2c20 7379 6d62  e(self.mip, symb
+00012dc0: 6f6c 6963 5f73 6f6c 7665 725f 6c61 6265  olic_solver_labe
+00012dd0: 6c73 3d54 7275 6529 0a20 2020 2020 2020  ls=True).       
+00012de0: 2069 6620 636f 6e66 6967 2e73 696e 676c   if config.singl
+00012df0: 655f 7472 6565 3a0a 2020 2020 2020 2020  e_tree:.        
+00012e00: 2020 2020 7365 6c66 2e73 6574 5f75 705f      self.set_up_
+00012e10: 6c61 7a79 5f4f 415f 6361 6c6c 6261 636b  lazy_OA_callback
+00012e20: 2829 0a20 2020 2020 2020 2069 6620 636f  ().        if co
+00012e30: 6e66 6967 2e75 7365 5f74 6162 755f 6c69  nfig.use_tabu_li
+00012e40: 7374 3a0a 2020 2020 2020 2020 2020 2020  st:.            
+00012e50: 7365 6c66 2e73 6574 5f75 705f 7461 6275  self.set_up_tabu
+00012e60: 6c69 7374 5f63 616c 6c62 6163 6b28 290a  list_callback().
+00012e70: 2020 2020 2020 2020 6d69 705f 6172 6773          mip_args
+00012e80: 203d 2064 6963 7428 636f 6e66 6967 2e6d   = dict(config.m
+00012e90: 6970 5f73 6f6c 7665 725f 6172 6773 290a  ip_solver_args).
+00012ea0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+00012eb0: 672e 6d69 705f 736f 6c76 6572 2069 6e20  g.mip_solver in 
+00012ec0: 7b0a 2020 2020 2020 2020 2020 2020 2763  {.            'c
+00012ed0: 706c 6578 272c 0a20 2020 2020 2020 2020  plex',.         
+00012ee0: 2020 2027 6370 6c65 785f 7065 7273 6973     'cplex_persis
+00012ef0: 7465 6e74 272c 0a20 2020 2020 2020 2020  tent',.         
+00012f00: 2020 2027 6775 726f 6269 272c 0a20 2020     'gurobi',.   
+00012f10: 2020 2020 2020 2020 2027 6775 726f 6269           'gurobi
+00012f20: 5f70 6572 7369 7374 656e 7427 2c0a 2020  _persistent',.  
+00012f30: 2020 2020 2020 7d3a 0a20 2020 2020 2020        }:.       
+00012f40: 2020 2020 206d 6970 5f61 7267 735b 2777       mip_args['w
+00012f50: 6172 6d73 7461 7274 275d 203d 2054 7275  armstart'] = Tru
+00012f60: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
+00012f70: 206d 6970 5f61 7267 730a 0a20 2020 2023   mip_args..    #
+00012f80: 2054 6865 2066 6f6c 6c6f 7769 6e67 2066   The following f
+00012f90: 756e 6374 696f 6e73 2064 6561 6c20 7769  unctions deal wi
+00012fa0: 7468 2068 616e 646c 696e 6720 7468 6520  th handling the 
+00012fb0: 736f 6c75 7469 6f6e 2077 6520 6765 7420  solution we get 
+00012fc0: 6672 6f6d 2074 6865 2061 626f 7665 204d  from the above M
+00012fd0: 4950 2073 6f6c 7665 7220 6675 6e63 7469  IP solver functi
+00012fe0: 6f6e 0a0a 2020 2020 6465 6620 6861 6e64  on..    def hand
+00012ff0: 6c65 5f6d 6169 6e5f 6f70 7469 6d61 6c28  le_main_optimal(
+00013000: 7365 6c66 2c20 6d61 696e 5f6d 6970 2c20  self, main_mip, 
+00013010: 7570 6461 7465 5f62 6f75 6e64 3d54 7275  update_bound=Tru
+00013020: 6529 3a0a 2020 2020 2020 2020 2222 2254  e):.        """T
+00013030: 6869 7320 6675 6e63 7469 6f6e 2063 6f70  his function cop
+00013040: 6965 7320 7468 6520 7265 7375 6c74 7320  ies the results 
+00013050: 6672 6f6d 2027 736f 6c76 655f 6d61 696e  from 'solve_main
+00013060: 2720 746f 2074 6865 2077 6f72 6b69 6e67  ' to the working
+00013070: 206d 6f64 656c 2061 6e64 2075 7064 6174   model and updat
+00013080: 6573 0a20 2020 2020 2020 2074 6865 2075  es.        the u
+00013090: 7070 6572 2f6c 6f77 6572 2062 6f75 6e64  pper/lower bound
+000130a0: 2e20 5468 6973 2066 756e 6374 696f 6e20  . This function 
+000130b0: 6973 2063 616c 6c65 6420 6166 7465 7220  is called after 
+000130c0: 616e 206f 7074 696d 616c 2073 6f6c 7574  an optimal solut
+000130d0: 696f 6e20 6973 2066 6f75 6e64 2066 6f72  ion is found for
+000130e0: 0a20 2020 2020 2020 2074 6865 206d 6169  .        the mai
+000130f0: 6e20 7072 6f62 6c65 6d2e 0a0a 2020 2020  n problem...    
+00013100: 2020 2020 5061 7261 6d65 7465 7273 0a20      Parameters. 
+00013110: 2020 2020 2020 202d 2d2d 2d2d 2d2d 2d2d         ---------
+00013120: 2d0a 2020 2020 2020 2020 6d61 696e 5f6d  -.        main_m
+00013130: 6970 203a 2050 796f 6d6f 206d 6f64 656c  ip : Pyomo model
+00013140: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
+00013150: 204d 4950 206d 6169 6e20 7072 6f62 6c65   MIP main proble
+00013160: 6d2e 0a20 2020 2020 2020 2075 7064 6174  m..        updat
+00013170: 655f 626f 756e 6420 3a20 626f 6f6c 2c20  e_bound : bool, 
+00013180: 6f70 7469 6f6e 616c 0a20 2020 2020 2020  optional.       
+00013190: 2020 2020 2057 6865 7468 6572 2074 6f20       Whether to 
+000131a0: 7570 6461 7465 2074 6865 2062 6f75 6e64  update the bound
+000131b0: 2c20 6279 2064 6566 6175 6c74 2054 7275  , by default Tru
+000131c0: 652e 0a20 2020 2020 2020 2020 2020 2042  e..            B
+000131d0: 6f75 6e64 2077 696c 6c20 6e6f 7420 6265  ound will not be
+000131e0: 2075 7064 6174 6564 2077 6865 6e20 6861   updated when ha
+000131f0: 6e64 6c69 6e67 2072 6567 756c 6172 697a  ndling regulariz
+00013200: 6174 696f 6e20 7072 6f62 6c65 6d2e 0a20  ation problem.. 
+00013210: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
+00013220: 2020 2023 2070 726f 6365 6564 2e20 4a75     # proceed. Ju
+00013230: 7374 206e 6565 6420 696e 7465 6765 7220  st need integer 
+00013240: 7661 6c75 6573 0a20 2020 2020 2020 204d  values.        M
+00013250: 696e 6474 5079 203d 206d 6169 6e5f 6d69  indtPy = main_mi
+00013260: 702e 4d69 6e64 7450 795f 7574 696c 730a  p.MindtPy_utils.
+00013270: 2020 2020 2020 2020 2320 6368 6563 6b20          # check 
+00013280: 6966 2074 6865 2076 616c 7565 206f 6620  if the value of 
+00013290: 6269 6e61 7279 2076 6172 6961 626c 6520  binary variable 
+000132a0: 6973 2076 616c 6964 0a20 2020 2020 2020  is valid.       
+000132b0: 2066 6f72 2076 6172 2069 6e20 4d69 6e64   for var in Mind
+000132c0: 7450 792e 6469 7363 7265 7465 5f76 6172  tPy.discrete_var
+000132d0: 6961 626c 655f 6c69 7374 3a0a 2020 2020  iable_list:.    
+000132e0: 2020 2020 2020 2020 6966 2076 6172 2e76          if var.v
+000132f0: 616c 7565 2069 7320 4e6f 6e65 3a0a 2020  alue is None:.  
+00013300: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00013310: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
+00013320: 2e77 6172 6e69 6e67 280a 2020 2020 2020  .warning(.      
+00013330: 2020 2020 2020 2020 2020 2020 2020 6622                f"
+00013340: 496e 7465 6765 7220 7661 7269 6162 6c65  Integer variable
+00013350: 207b 7661 722e 6e61 6d65 7d20 6e6f 7420   {var.name} not 
+00013360: 696e 6974 6961 6c69 7a65 642e 2020 220a  initialized.  ".
+00013370: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013380: 2020 2020 2253 6574 7469 6e67 2069 7420      "Setting it 
+00013390: 746f 2069 7473 206c 6f77 6572 2062 6f75  to its lower bou
+000133a0: 6e64 220a 2020 2020 2020 2020 2020 2020  nd".            
+000133b0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+000133c0: 2020 2020 2020 7661 722e 7365 745f 7661        var.set_va
+000133d0: 6c75 6528 7661 722e 6c62 2c20 736b 6970  lue(var.lb, skip
+000133e0: 5f76 616c 6964 6174 696f 6e3d 5472 7565  _validation=True
+000133f0: 290a 2020 2020 2020 2020 2320 7761 726d  ).        # warm
+00013400: 2073 7461 7274 2066 6f72 2074 6865 206e   start for the n
+00013410: 6c70 2073 7562 7072 6f62 6c65 6d0a 2020  lp subproblem.  
+00013420: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
+00013430: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
+00013440: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
+00013450: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+00013460: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+00013470: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
+00013480: 6978 6564 5f6e 6c70 2e4d 696e 6474 5079  ixed_nlp.MindtPy
+00013490: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
+000134a0: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
+000134b0: 2020 7365 6c66 2e63 6f6e 6669 672c 0a20    self.config,. 
+000134c0: 2020 2020 2020 2020 2020 2073 6b69 705f             skip_
+000134d0: 6669 7865 643d 4661 6c73 652c 0a20 2020  fixed=False,.   
+000134e0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+000134f0: 6966 2075 7064 6174 655f 626f 756e 643a  if update_bound:
+00013500: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00013510: 662e 7570 6461 7465 5f64 7561 6c5f 626f  f.update_dual_bo
+00013520: 756e 6428 7661 6c75 6528 4d69 6e64 7450  und(value(MindtP
+00013530: 792e 6d69 705f 6f62 6a2e 6578 7072 2929  y.mip_obj.expr))
+00013540: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+00013550: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
+00013560: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
+00013570: 2020 2020 2020 7365 6c66 2e6c 6f67 5f66        self.log_f
+00013580: 6f72 6d61 7474 6572 2e66 6f72 6d61 7428  ormatter.format(
+00013590: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000135a0: 2020 2020 2073 656c 662e 6d69 705f 6974       self.mip_it
+000135b0: 6572 2c0a 2020 2020 2020 2020 2020 2020  er,.            
+000135c0: 2020 2020 2020 2020 274d 494c 5027 2c0a          'MILP',.
+000135d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000135e0: 2020 2020 7661 6c75 6528 4d69 6e64 7450      value(MindtP
+000135f0: 792e 6d69 705f 6f62 6a2e 6578 7072 292c  y.mip_obj.expr),
+00013600: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013610: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
+00013620: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
+00013630: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00013640: 2e64 7561 6c5f 626f 756e 642c 0a20 2020  .dual_bound,.   
+00013650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013660: 2073 656c 662e 7265 6c5f 6761 702c 0a20   self.rel_gap,. 
+00013670: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013680: 2020 2067 6574 5f6d 6169 6e5f 656c 6170     get_main_elap
+00013690: 7365 645f 7469 6d65 2873 656c 662e 7469  sed_time(self.ti
+000136a0: 6d69 6e67 292c 0a20 2020 2020 2020 2020  ming),.         
+000136b0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000136c0: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
+000136d0: 6861 6e64 6c65 5f6d 6169 6e5f 696e 6665  handle_main_infe
+000136e0: 6173 6962 6c65 2873 656c 6629 3a0a 2020  asible(self):.  
+000136f0: 2020 2020 2020 2222 2254 6869 7320 6675        """This fu
+00013700: 6e63 7469 6f6e 2068 616e 646c 6573 2074  nction handles t
+00013710: 6865 2072 6573 756c 7420 6f66 2074 6865  he result of the
+00013720: 206c 6174 6573 7420 6974 6572 6174 696f   latest iteratio
+00013730: 6e20 6f66 2073 6f6c 7669 6e67 0a20 2020  n of solving.   
+00013740: 2020 2020 2074 6865 204d 4950 2070 726f       the MIP pro
+00013750: 626c 656d 2067 6976 656e 2061 6e20 696e  blem given an in
+00013760: 6665 6173 6962 6c65 2073 6f6c 7574 696f  feasible solutio
+00013770: 6e2e 0a20 2020 2020 2020 2022 2222 0a20  n..        """. 
 00013780: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
 00013790: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-000137a0: 2020 2020 2020 2020 2020 2020 274d 696e              'Min
-000137b0: 6474 5079 2065 7869 7469 6e67 2064 7565  dtPy exiting due
-000137c0: 2074 6f20 4d49 4c50 206d 6169 6e20 7072   to MILP main pr
-000137d0: 6f62 6c65 6d20 696e 6665 6173 6962 696c  oblem infeasibil
-000137e0: 6974 792e 270a 2020 2020 2020 2020 290a  ity.'.        ).
-000137f0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-00013800: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
-00013810: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-00013820: 7469 6f6e 2069 7320 4e6f 6e65 3a0a 2020  tion is None:.  
-00013830: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
-00013840: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00013850: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
-00013860: 203d 3d20 666c 6f61 7428 2769 6e66 2729   == float('inf')
-00013870: 2061 6e64 2073 656c 662e 6f62 6a65 6374   and self.object
-00013880: 6976 655f 7365 6e73 6520 3d3d 206d 696e  ive_sense == min
-00013890: 696d 697a 650a 2020 2020 2020 2020 2020  imize.          
-000138a0: 2020 2920 6f72 2028 0a20 2020 2020 2020    ) or (.       
-000138b0: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-000138c0: 696d 616c 5f62 6f75 6e64 203d 3d20 666c  imal_bound == fl
-000138d0: 6f61 7428 272d 696e 6627 2920 616e 6420  oat('-inf') and 
-000138e0: 7365 6c66 2e6f 626a 6563 7469 7665 5f73  self.objective_s
-000138f0: 656e 7365 203d 3d20 6d61 7869 6d69 7a65  ense == maximize
-00013900: 0a20 2020 2020 2020 2020 2020 2029 3a0a  .            ):.
-00013910: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013920: 2320 6966 2073 656c 662e 6d69 705f 6974  # if self.mip_it
-00013930: 6572 203d 3d20 303a 0a20 2020 2020 2020  er == 0:.       
-00013940: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
-00013950: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
-00013960: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
-00013970: 6f6e 203d 2074 632e 696e 6665 6173 6962  on = tc.infeasib
-00013980: 6c65 0a20 2020 2020 2020 2020 2020 2065  le.            e
-00013990: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-000139a0: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
-000139b0: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
-000139c0: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 203d  tion_condition =
-000139d0: 2074 632e 6665 6173 6962 6c65 0a0a 2020   tc.feasible..  
-000139e0: 2020 6465 6620 6861 6e64 6c65 5f6d 6169    def handle_mai
-000139f0: 6e5f 6d61 785f 7469 6d65 6c69 6d69 7428  n_max_timelimit(
-00013a00: 7365 6c66 2c20 6d61 696e 5f6d 6970 2c20  self, main_mip, 
-00013a10: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
-00013a20: 293a 0a20 2020 2020 2020 2022 2222 5468  ):.        """Th
-00013a30: 6973 2066 756e 6374 696f 6e20 6861 6e64  is function hand
-00013a40: 6c65 7320 7468 6520 7265 7375 6c74 206f  les the result o
-00013a50: 6620 7468 6520 6c61 7465 7374 2069 7465  f the latest ite
-00013a60: 7261 7469 6f6e 206f 6620 736f 6c76 696e  ration of solvin
-00013a70: 6720 7468 6520 4d49 5020 7072 6f62 6c65  g the MIP proble
-00013a80: 6d0a 2020 2020 2020 2020 6769 7665 6e20  m.        given 
-00013a90: 7468 6174 2073 6f6c 7669 6e67 2074 6865  that solving the
-00013aa0: 204d 4950 2074 616b 6573 2074 6f6f 206c   MIP takes too l
-00013ab0: 6f6e 672e 0a0a 2020 2020 2020 2020 5061  ong...        Pa
-00013ac0: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
-00013ad0: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00013ae0: 2020 2020 6d61 696e 5f6d 6970 203a 2050      main_mip : P
-00013af0: 796f 6d6f 206d 6f64 656c 0a20 2020 2020  yomo model.     
-00013b00: 2020 2020 2020 2054 6865 204d 4950 206d         The MIP m
-00013b10: 6169 6e20 7072 6f62 6c65 6d2e 0a20 2020  ain problem..   
-00013b20: 2020 2020 206d 6169 6e5f 6d69 705f 7265       main_mip_re
-00013b30: 7375 6c74 7320 3a20 5b74 7970 655d 0a20  sults : [type]. 
-00013b40: 2020 2020 2020 2020 2020 2052 6573 756c             Resul
-00013b50: 7473 2066 726f 6d20 736f 6c76 696e 6720  ts from solving 
-00013b60: 7468 6520 4d49 5020 6d61 696e 2073 7562  the MIP main sub
-00013b70: 7072 6f62 6c65 6d2e 0a20 2020 2020 2020  problem..       
-00013b80: 2022 2222 0a20 2020 2020 2020 2023 2049   """.        # I
-00013b90: 6620 7765 2068 6176 6520 666f 756e 6420  f we have found 
-00013ba0: 6120 7661 6c69 6420 6665 6173 6962 6c65  a valid feasible
-00013bb0: 2073 6f6c 7574 696f 6e2c 2077 6520 7461   solution, we ta
-00013bc0: 6b65 2074 6861 742e 2049 6620 6e6f 742c  ke that. If not,
-00013bd0: 2077 6520 6361 6e20 6174 206c 6561 7374   we can at least
-00013be0: 2075 7365 2074 6865 2064 7561 6c20 626f   use the dual bo
-00013bf0: 756e 642e 0a20 2020 2020 2020 204d 696e  und..        Min
-00013c00: 6474 5079 203d 206d 6169 6e5f 6d69 702e  dtPy = main_mip.
-00013c10: 4d69 6e64 7450 795f 7574 696c 730a 2020  MindtPy_utils.  
-00013c20: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
-00013c30: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
-00013c40: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-00013c50: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-00013c60: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-00013c70: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
-00013c80: 6978 6564 5f6e 6c70 2e4d 696e 6474 5079  ixed_nlp.MindtPy
-00013c90: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
-00013ca0: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
-00013cb0: 2020 7365 6c66 2e63 6f6e 6669 672c 0a20    self.config,. 
-00013cc0: 2020 2020 2020 2020 2020 2073 6b69 705f             skip_
-00013cd0: 6669 7865 643d 4661 6c73 652c 0a20 2020  fixed=False,.   
-00013ce0: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
-00013cf0: 656c 662e 7570 6461 7465 5f73 7562 6f70  elf.update_subop
-00013d00: 7469 6d61 6c5f 6475 616c 5f62 6f75 6e64  timal_dual_bound
-00013d10: 286d 6169 6e5f 6d69 705f 7265 7375 6c74  (main_mip_result
-00013d20: 7329 0a20 2020 2020 2020 2073 656c 662e  s).        self.
-00013d30: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
-00013d40: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
-00013d50: 7365 6c66 2e74 6572 6d69 6e61 7469 6f6e  self.termination
-00013d60: 5f63 6f6e 6469 7469 6f6e 5f6c 6f67 5f66  _condition_log_f
-00013d70: 6f72 6d61 7474 6572 2e66 6f72 6d61 7428  ormatter.format(
-00013d80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013d90: 2073 656c 662e 6d69 705f 6974 6572 2c0a   self.mip_iter,.
-00013da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00013db0: 274d 494c 5027 2c0a 2020 2020 2020 2020  'MILP',.        
-00013dc0: 2020 2020 2020 2020 276d 6178 5469 6d65          'maxTime
-00013dd0: 4c69 6d69 7427 2c0a 2020 2020 2020 2020  Limit',.        
-00013de0: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
-00013df0: 6d61 6c5f 626f 756e 642c 0a20 2020 2020  mal_bound,.     
-00013e00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00013e10: 6475 616c 5f62 6f75 6e64 2c0a 2020 2020  dual_bound,.    
-00013e20: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00013e30: 2e72 656c 5f67 6170 2c0a 2020 2020 2020  .rel_gap,.      
-00013e40: 2020 2020 2020 2020 2020 6765 745f 6d61            get_ma
-00013e50: 696e 5f65 6c61 7073 6564 5f74 696d 6528  in_elapsed_time(
-00013e60: 7365 6c66 2e74 696d 696e 6729 2c0a 2020  self.timing),.  
-00013e70: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00013e80: 2020 2020 290a 0a20 2020 2064 6566 2068      )..    def h
-00013e90: 616e 646c 655f 6d61 696e 5f75 6e62 6f75  andle_main_unbou
-00013ea0: 6e64 6564 2873 656c 662c 206d 6169 6e5f  nded(self, main_
-00013eb0: 6d69 7029 3a0a 2020 2020 2020 2020 2222  mip):.        ""
-00013ec0: 2254 6869 7320 6675 6e63 7469 6f6e 2068  "This function h
-00013ed0: 616e 646c 6573 2074 6865 2072 6573 756c  andles the resul
-00013ee0: 7420 6f66 2074 6865 206c 6174 6573 7420  t of the latest 
-00013ef0: 6974 6572 6174 696f 6e20 6f66 2073 6f6c  iteration of sol
-00013f00: 7669 6e67 2074 6865 204d 4950 0a20 2020  ving the MIP.   
-00013f10: 2020 2020 2070 726f 626c 656d 2067 6976       problem giv
-00013f20: 656e 2061 6e20 756e 626f 756e 6465 6420  en an unbounded 
-00013f30: 736f 6c75 7469 6f6e 2064 7565 2074 6f20  solution due to 
-00013f40: 7468 6520 7265 6c61 7861 7469 6f6e 2e0a  the relaxation..
-00013f50: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
-00013f60: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
-00013f70: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 206d  ------.        m
-00013f80: 6169 6e5f 6d69 7020 3a20 5079 6f6d 6f20  ain_mip : Pyomo 
-00013f90: 6d6f 6465 6c0a 2020 2020 2020 2020 2020  model.          
-00013fa0: 2020 5468 6520 4d49 5020 6d61 696e 2070    The MIP main p
-00013fb0: 726f 626c 656d 2e0a 0a20 2020 2020 2020  roblem...       
-00013fc0: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
-00013fd0: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
-00013fe0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
-00013ff0: 7320 3a20 536f 6c76 6572 5265 7375 6c74  s : SolverResult
-00014000: 730a 2020 2020 2020 2020 2020 2020 5468  s.            Th
-00014010: 6520 7265 7375 6c74 7320 6f66 2074 6865  e results of the
-00014020: 2062 6f75 6e64 6564 206d 6169 6e20 7072   bounded main pr
-00014030: 6f62 6c65 6d2e 0a20 2020 2020 2020 2022  oblem..        "
-00014040: 2222 0a20 2020 2020 2020 2023 2053 6f6c  "".        # Sol
-00014050: 7574 696f 6e20 6973 2075 6e62 6f75 6e64  ution is unbound
-00014060: 6564 2e20 4164 6420 616e 2061 7262 6974  ed. Add an arbit
-00014070: 7261 7279 2062 6f75 6e64 2074 6f20 7468  rary bound to th
-00014080: 6520 6f62 6a65 6374 6976 6520 616e 6420  e objective and 
-00014090: 7265 736f 6c76 652e 0a20 2020 2020 2020  resolve..       
-000140a0: 2023 2054 6869 7320 6f63 6375 7273 2077   # This occurs w
-000140b0: 6865 6e20 7468 6520 6f62 6a65 6374 6976  hen the objectiv
-000140c0: 6520 6973 206e 6f6e 6c69 6e65 6172 2e20  e is nonlinear. 
-000140d0: 5468 6520 6e6f 6e6c 696e 6561 7220 6f62  The nonlinear ob
-000140e0: 6a65 6374 6976 6520 6973 206d 6f76 6564  jective is moved
-000140f0: 0a20 2020 2020 2020 2023 2074 6f20 7468  .        # to th
-00014100: 6520 636f 6e73 7472 6169 6e74 732c 2061  e constraints, a
-00014110: 6e64 2064 6561 6374 6976 6174 6564 2066  nd deactivated f
-00014120: 6f72 2074 6865 206c 696e 6561 7220 6d61  or the linear ma
-00014130: 696e 2070 726f 626c 656d 2e0a 2020 2020  in problem..    
-00014140: 2020 2020 636f 6e66 6967 203d 2073 656c      config = sel
-00014150: 662e 636f 6e66 6967 0a20 2020 2020 2020  f.config.       
-00014160: 204d 696e 6474 5079 203d 206d 6169 6e5f   MindtPy = main_
-00014170: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
-00014180: 730a 2020 2020 2020 2020 636f 6e66 6967  s.        config
-00014190: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
-000141a0: 2020 2020 2020 2020 2020 7365 6c66 2e74            self.t
-000141b0: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-000141c0: 7469 6f6e 5f6c 6f67 5f66 6f72 6d61 7474  tion_log_formatt
-000141d0: 6572 2e66 6f72 6d61 7428 0a20 2020 2020  er.format(.     
-000141e0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-000141f0: 6d69 705f 6974 6572 2c0a 2020 2020 2020  mip_iter,.      
-00014200: 2020 2020 2020 2020 2020 274d 494c 5027            'MILP'
-00014210: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014220: 2020 2755 6e62 6f75 6e64 6564 272c 0a20    'Unbounded',. 
-00014230: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00014240: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
-00014250: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00014260: 2020 7365 6c66 2e64 7561 6c5f 626f 756e    self.dual_boun
-00014270: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-00014280: 2020 2073 656c 662e 7265 6c5f 6761 702c     self.rel_gap,
-00014290: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000142a0: 2067 6574 5f6d 6169 6e5f 656c 6170 7365   get_main_elapse
-000142b0: 645f 7469 6d65 2873 656c 662e 7469 6d69  d_time(self.timi
-000142c0: 6e67 292c 0a20 2020 2020 2020 2020 2020  ng),.           
-000142d0: 2029 0a20 2020 2020 2020 2029 0a20 2020   ).        ).   
-000142e0: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-000142f0: 6572 2e77 6172 6e69 6e67 280a 2020 2020  er.warning(.    
-00014300: 2020 2020 2020 2020 2752 6573 6f6c 7669          'Resolvi
-00014310: 6e67 2077 6974 6820 6172 6269 7472 6172  ng with arbitrar
-00014320: 7920 626f 756e 6420 7661 6c75 6573 206f  y bound values o
-00014330: 6620 282d 7b30 3a2e 3130 677d 2c20 7b30  f (-{0:.10g}, {0
-00014340: 3a2e 3130 677d 2920 6f6e 2074 6865 206f  :.10g}) on the o
-00014350: 626a 6563 7469 7665 2e20 270a 2020 2020  bjective. '.    
-00014360: 2020 2020 2020 2020 2759 6f75 2063 616e          'You can
-00014370: 2063 6861 6e67 6520 7468 6973 2062 6f75   change this bou
-00014380: 6e64 2077 6974 6820 7468 6520 6f70 7469  nd with the opti
-00014390: 6f6e 206f 626a 5f62 6f75 6e64 2e27 2e66  on obj_bound.'.f
-000143a0: 6f72 6d61 7428 0a20 2020 2020 2020 2020  ormat(.         
-000143b0: 2020 2020 2020 2063 6f6e 6669 672e 6f62         config.ob
-000143c0: 6a5f 626f 756e 640a 2020 2020 2020 2020  j_bound.        
-000143d0: 2020 2020 290a 2020 2020 2020 2020 290a      ).        ).
-000143e0: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
-000143f0: 6f62 6a65 6374 6976 655f 626f 756e 6420  objective_bound 
-00014400: 3d20 436f 6e73 7472 6169 6e74 280a 2020  = Constraint(.  
-00014410: 2020 2020 2020 2020 2020 6578 7072 3d28            expr=(
-00014420: 2d63 6f6e 6669 672e 6f62 6a5f 626f 756e  -config.obj_boun
-00014430: 642c 204d 696e 6474 5079 2e6d 6970 5f6f  d, MindtPy.mip_o
-00014440: 626a 2e65 7870 722c 2063 6f6e 6669 672e  bj.expr, config.
-00014450: 6f62 6a5f 626f 756e 6429 0a20 2020 2020  obj_bound).     
-00014460: 2020 2029 0a20 2020 2020 2020 2069 6620     ).        if 
-00014470: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
-00014480: 6d69 705f 6f70 742c 2050 6572 7369 7374  mip_opt, Persist
-00014490: 656e 7453 6f6c 7665 7229 3a0a 2020 2020  entSolver):.    
-000144a0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-000144b0: 5f6f 7074 2e73 6574 5f69 6e73 7461 6e63  _opt.set_instanc
-000144c0: 6528 6d61 696e 5f6d 6970 290a 2020 2020  e(main_mip).    
-000144d0: 2020 2020 7570 6461 7465 5f73 6f6c 7665      update_solve
-000144e0: 725f 7469 6d65 6c69 6d69 7428 7365 6c66  r_timelimit(self
-000144f0: 2e6d 6970 5f6f 7074 2c20 636f 6e66 6967  .mip_opt, config
-00014500: 2e6d 6970 5f73 6f6c 7665 722c 2073 656c  .mip_solver, sel
-00014510: 662e 7469 6d69 6e67 2c20 636f 6e66 6967  f.timing, config
-00014520: 290a 2020 2020 2020 2020 7769 7468 2053  ).        with S
-00014530: 7570 7072 6573 7349 6e66 6561 7369 626c  uppressInfeasibl
-00014540: 6557 6172 6e69 6e67 2829 3a0a 2020 2020  eWarning():.    
-00014550: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-00014560: 5f72 6573 756c 7473 203d 2073 656c 662e  _results = self.
-00014570: 6d69 705f 6f70 742e 736f 6c76 6528 0a20  mip_opt.solve(. 
-00014580: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00014590: 6169 6e5f 6d69 702c 0a20 2020 2020 2020  ain_mip,.       
-000145a0: 2020 2020 2020 2020 2074 6565 3d63 6f6e           tee=con
-000145b0: 6669 672e 6d69 705f 736f 6c76 6572 5f74  fig.mip_solver_t
-000145c0: 6565 2c0a 2020 2020 2020 2020 2020 2020  ee,.            
-000145d0: 2020 2020 6c6f 6164 5f73 6f6c 7574 696f      load_solutio
-000145e0: 6e73 3d73 656c 662e 6c6f 6164 5f73 6f6c  ns=self.load_sol
-000145f0: 7574 696f 6e73 2c0a 2020 2020 2020 2020  utions,.        
-00014600: 2020 2020 2020 2020 2a2a 636f 6e66 6967          **config
-00014610: 2e6d 6970 5f73 6f6c 7665 725f 6172 6773  .mip_solver_args
-00014620: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
-00014630: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-00014640: 656e 286d 6169 6e5f 6d69 705f 7265 7375  en(main_mip_resu
-00014650: 6c74 732e 736f 6c75 7469 6f6e 2920 3e20  lts.solution) > 
-00014660: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00014670: 2020 2073 656c 662e 6d69 702e 736f 6c75     self.mip.solu
-00014680: 7469 6f6e 732e 6c6f 6164 5f66 726f 6d28  tions.load_from(
-00014690: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
-000146a0: 290a 2020 2020 2020 2020 7265 7475 726e  ).        return
-000146b0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
-000146c0: 730a 0a20 2020 2064 6566 2068 616e 646c  s..    def handl
-000146d0: 655f 7265 6775 6c61 7269 7a61 7469 6f6e  e_regularization
-000146e0: 5f6d 6169 6e5f 7463 2873 656c 662c 206d  _main_tc(self, m
-000146f0: 6169 6e5f 6d69 702c 206d 6169 6e5f 6d69  ain_mip, main_mi
-00014700: 705f 7265 7375 6c74 7329 3a0a 2020 2020  p_results):.    
-00014710: 2020 2020 2222 2248 616e 646c 6573 2074      """Handles t
-00014720: 6865 2072 6573 756c 7420 6f66 2074 6865  he result of the
-00014730: 2072 6567 756c 6172 697a 6174 696f 6e20   regularization 
-00014740: 6d61 696e 2070 726f 626c 656d 2e0a 0a20  main problem... 
-00014750: 2020 2020 2020 2050 6172 616d 6574 6572         Parameter
-00014760: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
-00014770: 2d2d 2d2d 0a20 2020 2020 2020 206d 6169  ----.        mai
-00014780: 6e5f 6d69 7020 3a20 5079 6f6d 6f20 6d6f  n_mip : Pyomo mo
-00014790: 6465 6c0a 2020 2020 2020 2020 2020 2020  del.            
-000147a0: 5468 6520 4d49 5020 6d61 696e 2070 726f  The MIP main pro
-000147b0: 626c 656d 2e0a 2020 2020 2020 2020 6d61  blem..        ma
-000147c0: 696e 5f6d 6970 5f72 6573 756c 7473 203a  in_mip_results :
-000147d0: 2053 6f6c 7665 7252 6573 756c 7473 0a20   SolverResults. 
-000147e0: 2020 2020 2020 2020 2020 2052 6573 756c             Resul
-000147f0: 7473 2066 726f 6d20 736f 6c76 696e 6720  ts from solving 
-00014800: 7468 6520 7265 6775 6c61 7269 7a61 7469  the regularizati
-00014810: 6f6e 206d 6169 6e20 7375 6270 726f 626c  on main subprobl
-00014820: 656d 2e0a 0a20 2020 2020 2020 2052 6169  em...        Rai
-00014830: 7365 730a 2020 2020 2020 2020 2d2d 2d2d  ses.        ----
-00014840: 2d2d 0a20 2020 2020 2020 2056 616c 7565  --.        Value
-00014850: 4572 726f 720a 2020 2020 2020 2020 2020  Error.          
-00014860: 2020 4d69 6e64 7450 7920 756e 6162 6c65    MindtPy unable
-00014870: 2074 6f20 6861 6e64 6c65 2074 6865 2072   to handle the r
-00014880: 6567 756c 6172 697a 6174 696f 6e20 7072  egularization pr
-00014890: 6f62 6c65 6d20 7465 726d 696e 6174 696f  oblem terminatio
-000148a0: 6e20 636f 6e64 6974 696f 6e2e 0a20 2020  n condition..   
-000148b0: 2020 2020 2022 2222 0a20 2020 2020 2020       """.       
-000148c0: 2069 6620 6d61 696e 5f6d 6970 5f72 6573   if main_mip_res
-000148d0: 756c 7473 2069 7320 4e6f 6e65 3a0a 2020  ults is None:.  
-000148e0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-000148f0: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
-00014900: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
-00014910: 2020 2027 4661 696c 6564 2074 6f20 736f     'Failed to so
-00014920: 6c76 6520 7468 6520 7265 6775 6c61 7269  lve the regulari
-00014930: 7a61 7469 6f6e 2070 726f 626c 656d 2e27  zation problem.'
-00014940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014950: 2027 5468 6520 736f 6c75 7469 6f6e 206f   'The solution o
-00014960: 6620 7468 6520 4f41 206d 6169 6e20 7072  f the OA main pr
-00014970: 6f62 6c65 6d20 7769 6c6c 2062 6520 6164  oblem will be ad
-00014980: 6f70 7465 642e 270a 2020 2020 2020 2020  opted.'.        
-00014990: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
-000149a0: 6966 206d 6169 6e5f 6d69 705f 7265 7375  if main_mip_resu
-000149b0: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
-000149c0: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
-000149d0: 2069 6e20 7b74 632e 6f70 7469 6d61 6c2c   in {tc.optimal,
-000149e0: 2074 632e 6665 6173 6962 6c65 7d3a 0a20   tc.feasible}:. 
-000149f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00014a00: 6861 6e64 6c65 5f6d 6169 6e5f 6f70 7469  handle_main_opti
-00014a10: 6d61 6c28 6d61 696e 5f6d 6970 2c20 7570  mal(main_mip, up
-00014a20: 6461 7465 5f62 6f75 6e64 3d46 616c 7365  date_bound=False
-00014a30: 290a 2020 2020 2020 2020 656c 6966 206d  ).        elif m
-00014a40: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
-00014a50: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-00014a60: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 7320  on_condition is 
-00014a70: 7463 2e6d 6178 5469 6d65 4c69 6d69 743a  tc.maxTimeLimit:
-00014a80: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00014a90: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
-00014aa0: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-00014ab0: 2020 2020 2020 2752 6567 756c 6172 697a        'Regulariz
-00014ac0: 6174 696f 6e20 7072 6f62 6c65 6d20 6661  ation problem fa
-00014ad0: 696c 6564 2074 6f20 636f 6e76 6572 6765  iled to converge
-00014ae0: 2077 6974 6869 6e20 7468 6520 7469 6d65   within the time
-00014af0: 206c 696d 6974 2e27 0a20 2020 2020 2020   limit.'.       
-00014b00: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00014b10: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
-00014b20: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-00014b30: 6f6e 5f63 6f6e 6469 7469 6f6e 203d 2074  on_condition = t
-00014b40: 632e 6d61 7854 696d 654c 696d 6974 0a20  c.maxTimeLimit. 
-00014b50: 2020 2020 2020 2020 2020 2023 2062 7265             # bre
-00014b60: 616b 0a20 2020 2020 2020 2065 6c69 6620  ak.        elif 
-00014b70: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
-00014b80: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-00014b90: 696f 6e5f 636f 6e64 6974 696f 6e20 6973  ion_condition is
-00014ba0: 2074 632e 696e 6665 6173 6962 6c65 3a0a   tc.infeasible:.
-00014bb0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00014bc0: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e69  .config.logger.i
-00014bd0: 6e66 6f28 2752 6567 756c 6172 697a 6174  nfo('Regularizat
-00014be0: 696f 6e20 7072 6f62 6c65 6d20 696e 6665  ion problem infe
-00014bf0: 6173 6962 6c65 2e27 290a 2020 2020 2020  asible.').      
-00014c00: 2020 656c 6966 206d 6169 6e5f 6d69 705f    elif main_mip_
-00014c10: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
-00014c20: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-00014c30: 7469 6f6e 2069 7320 7463 2e75 6e62 6f75  tion is tc.unbou
-00014c40: 6e64 6564 3a0a 2020 2020 2020 2020 2020  nded:.          
-00014c50: 2020 7365 6c66 2e63 6f6e 6669 672e 6c6f    self.config.lo
-00014c60: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
-00014c70: 2020 2020 2020 2020 2020 2027 5265 6775             'Regu
-00014c80: 6c61 7269 7a61 7469 6f6e 2070 726f 626c  larization probl
-00014c90: 656d 2075 6e62 6f75 6e64 6564 2e27 0a20  em unbounded.'. 
-00014ca0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00014cb0: 536f 6d65 7469 6d65 7320 736f 6c76 696e  Sometimes solvin
-00014cc0: 6720 4d49 5143 5020 696e 2043 504c 4558  g MIQCP in CPLEX
-00014cd0: 2c20 756e 626f 756e 6465 6420 6d65 616e  , unbounded mean
-00014ce0: 7320 696e 6665 6173 6962 6c65 2e27 0a20  s infeasible.'. 
-00014cf0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-00014d00: 2020 2020 2065 6c69 6620 6d61 696e 5f6d       elif main_m
-00014d10: 6970 5f72 6573 756c 7473 2e73 6f6c 7665  ip_results.solve
-00014d20: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-00014d30: 6e64 6974 696f 6e20 6973 2074 632e 696e  ndition is tc.in
-00014d40: 6665 6173 6962 6c65 4f72 556e 626f 756e  feasibleOrUnboun
-00014d50: 6465 643a 0a20 2020 2020 2020 2020 2020  ded:.           
-00014d60: 2073 656c 662e 636f 6e66 6967 2e6c 6f67   self.config.log
-00014d70: 6765 722e 696e 666f 280a 2020 2020 2020  ger.info(.      
-00014d80: 2020 2020 2020 2020 2020 2752 6567 756c            'Regul
-00014d90: 6172 697a 6174 696f 6e20 7072 6f62 6c65  arization proble
-00014da0: 6d20 6973 2069 6e66 6561 7369 626c 6520  m is infeasible 
-00014db0: 6f72 2075 6e62 6f75 6e64 6564 2e27 0a20  or unbounded.'. 
-00014dc0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00014dd0: 4974 206d 6967 6874 2068 6170 7065 6e20  It might happen 
-00014de0: 7768 656e 2075 7369 6e67 2043 504c 4558  when using CPLEX
-00014df0: 2074 6f20 736f 6c76 6520 4d49 5150 2e27   to solve MIQP.'
-00014e00: 0a20 2020 2020 2020 2020 2020 2029 0a20  .            ). 
-00014e10: 2020 2020 2020 2065 6c69 6620 6d61 696e         elif main
-00014e20: 5f6d 6970 5f72 6573 756c 7473 2e73 6f6c  _mip_results.sol
-00014e30: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-00014e40: 636f 6e64 6974 696f 6e20 6973 2074 632e  condition is tc.
-00014e50: 756e 6b6e 6f77 6e3a 0a20 2020 2020 2020  unknown:.       
-00014e60: 2020 2020 2073 656c 662e 636f 6e66 6967       self.config
-00014e70: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
-00014e80: 2020 2020 2020 2020 2020 2020 2020 2754                'T
-00014e90: 6572 6d69 6e61 7469 6f6e 2063 6f6e 6469  ermination condi
-00014ea0: 7469 6f6e 206f 6620 7468 6520 7265 6775  tion of the regu
-00014eb0: 6c61 7269 7a61 7469 6f6e 2070 726f 626c  larization probl
-00014ec0: 656d 2069 7320 756e 6b6e 6f77 6e2e 270a  em is unknown.'.
-00014ed0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00014ee0: 2020 2020 2020 2020 2020 6966 206d 6169            if mai
-00014ef0: 6e5f 6d69 705f 7265 7375 6c74 732e 7072  n_mip_results.pr
-00014f00: 6f62 6c65 6d2e 6c6f 7765 725f 626f 756e  oblem.lower_boun
-00014f10: 6420 213d 2066 6c6f 6174 2827 2d69 6e66  d != float('-inf
-00014f20: 2729 3a0a 2020 2020 2020 2020 2020 2020  '):.            
-00014f30: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
-00014f40: 6c6f 6767 6572 2e69 6e66 6f28 2753 6f6c  logger.info('Sol
-00014f50: 7574 696f 6e20 6c69 6d69 7420 6861 7320  ution limit has 
-00014f60: 6265 656e 2072 6561 6368 6564 2e27 290a  been reached.').
-00014f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014f80: 7365 6c66 2e68 616e 646c 655f 6d61 696e  self.handle_main
-00014f90: 5f6f 7074 696d 616c 286d 6169 6e5f 6d69  _optimal(main_mi
-00014fa0: 702c 2075 7064 6174 655f 626f 756e 643d  p, update_bound=
-00014fb0: 4661 6c73 6529 0a20 2020 2020 2020 2020  False).         
-00014fc0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00014fd0: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
-00014fe0: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-00014ff0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00015000: 2020 2020 2020 274e 6f20 736f 6c75 7469        'No soluti
-00015010: 6f6e 206f 6274 6169 6e65 6420 6672 6f6d  on obtained from
-00015020: 2074 6865 2072 6567 756c 6172 697a 6174   the regularizat
-00015030: 696f 6e20 7375 6270 726f 626c 656d 2e27  ion subproblem.'
-00015040: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015050: 2020 2020 2027 506c 6561 7365 2073 6574       'Please set
-00015060: 206d 6970 5f73 6f6c 7665 725f 7465 6520   mip_solver_tee 
-00015070: 746f 2054 7275 6520 666f 7220 6d6f 7265  to True for more
-00015080: 2069 6e66 6f72 6d61 7469 6f6e 2e27 0a20   information.'. 
-00015090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000150a0: 2020 2027 5468 6520 736f 6c75 7469 6f6e     'The solution
-000150b0: 206f 6620 7468 6520 4f41 206d 6169 6e20   of the OA main 
-000150c0: 7072 6f62 6c65 6d20 7769 6c6c 2062 6520  problem will be 
-000150d0: 6164 6f70 7465 642e 270a 2020 2020 2020  adopted.'.      
-000150e0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000150f0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00015100: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00015110: 6545 7272 6f72 280a 2020 2020 2020 2020  eError(.        
-00015120: 2020 2020 2020 2020 274d 696e 6474 5079          'MindtPy
-00015130: 2075 6e61 626c 6520 746f 2068 616e 646c   unable to handl
-00015140: 6520 7265 6775 6c61 7269 7a61 7469 6f6e  e regularization
-00015150: 2070 726f 626c 656d 2074 6572 6d69 6e61   problem termina
-00015160: 7469 6f6e 2063 6f6e 6469 7469 6f6e 2027  tion condition '
-00015170: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015180: 2027 6f66 2025 732e 2053 6f6c 7665 7220   'of %s. Solver 
-00015190: 6d65 7373 6167 653a 2025 7327 0a20 2020  message: %s'.   
-000151a0: 2020 2020 2020 2020 2020 2020 2025 2028               % (
-000151b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000151c0: 2020 2020 206d 6169 6e5f 6d69 705f 7265       main_mip_re
-000151d0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
-000151e0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
-000151f0: 6f6e 2c0a 2020 2020 2020 2020 2020 2020  on,.            
-00015200: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-00015210: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
-00015220: 6d65 7373 6167 652c 0a20 2020 2020 2020  message,.       
-00015230: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-00015240: 2020 2020 2020 2029 0a0a 2020 2020 6465         )..    de
-00015250: 6620 7365 7475 705f 6d61 696e 2873 656c  f setup_main(sel
-00015260: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
-00015270: 6574 2075 7020 6d61 696e 2070 726f 626c  et up main probl
-00015280: 656d 2f6d 6169 6e20 7265 6775 6c61 7269  em/main regulari
-00015290: 7a61 7469 6f6e 2070 726f 626c 656d 2066  zation problem f
-000152a0: 6f72 204f 412c 2045 4350 2c20 4665 6173  or OA, ECP, Feas
-000152b0: 6962 696c 6974 7920 5075 6d70 2061 6e64  ibility Pump and
-000152c0: 2052 4f41 206d 6574 686f 6473 2e22 2222   ROA methods."""
-000152d0: 0a20 2020 2020 2020 2063 6f6e 6669 6720  .        config 
-000152e0: 3d20 7365 6c66 2e63 6f6e 6669 670a 2020  = self.config.  
-000152f0: 2020 2020 2020 4d69 6e64 7450 7920 3d20        MindtPy = 
-00015300: 7365 6c66 2e6d 6970 2e4d 696e 6474 5079  self.mip.MindtPy
-00015310: 5f75 7469 6c73 0a0a 2020 2020 2020 2020  _utils..        
-00015320: 666f 7220 6320 696e 204d 696e 6474 5079  for c in MindtPy
-00015330: 2e63 6f6e 7374 7261 696e 745f 6c69 7374  .constraint_list
-00015340: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
-00015350: 2063 2e62 6f64 792e 706f 6c79 6e6f 6d69   c.body.polynomi
-00015360: 616c 5f64 6567 7265 6528 2920 6e6f 7420  al_degree() not 
-00015370: 696e 2073 656c 662e 6d69 705f 636f 6e73  in self.mip_cons
-00015380: 7472 6169 6e74 5f70 6f6c 796e 6f6d 6961  traint_polynomia
-00015390: 6c5f 6465 6772 6565 3a0a 2020 2020 2020  l_degree:.      
-000153a0: 2020 2020 2020 2020 2020 632e 6465 6163            c.deac
-000153b0: 7469 7661 7465 2829 0a0a 2020 2020 2020  tivate()..      
-000153c0: 2020 4d69 6e64 7450 792e 6375 7473 2e61    MindtPy.cuts.a
-000153d0: 6374 6976 6174 6528 290a 0a20 2020 2020  ctivate()..     
-000153e0: 2020 2073 6967 6e5f 6164 6a75 7374 203d     sign_adjust =
-000153f0: 2031 2069 6620 7365 6c66 2e6f 626a 6563   1 if self.objec
-00015400: 7469 7665 5f73 656e 7365 203d 3d20 6d69  tive_sense == mi
-00015410: 6e69 6d69 7a65 2065 6c73 6520 2d31 0a20  nimize else -1. 
-00015420: 2020 2020 2020 204d 696e 6474 5079 2e64         MindtPy.d
-00015430: 656c 5f63 6f6d 706f 6e65 6e74 2827 6d69  el_component('mi
-00015440: 705f 6f62 6a27 290a 2020 2020 2020 2020  p_obj').        
-00015450: 6966 2063 6f6e 6669 672e 6164 645f 7265  if config.add_re
-00015460: 6775 6c61 7269 7a61 7469 6f6e 2069 7320  gularization is 
-00015470: 6e6f 7420 4e6f 6e65 2061 6e64 2063 6f6e  not None and con
-00015480: 6669 672e 6164 645f 6e6f 5f67 6f6f 645f  fig.add_no_good_
-00015490: 6375 7473 3a0a 2020 2020 2020 2020 2020  cuts:.          
-000154a0: 2020 4d69 6e64 7450 792e 6375 7473 2e6e    MindtPy.cuts.n
-000154b0: 6f5f 676f 6f64 5f63 7574 732e 6465 6163  o_good_cuts.deac
-000154c0: 7469 7661 7465 2829 0a0a 2020 2020 2020  tivate()..      
-000154d0: 2020 6966 2063 6f6e 6669 672e 6164 645f    if config.add_
-000154e0: 736c 6163 6b3a 0a20 2020 2020 2020 2020  slack:.         
-000154f0: 2020 204d 696e 6474 5079 2e64 656c 5f63     MindtPy.del_c
-00015500: 6f6d 706f 6e65 6e74 2827 6175 675f 7065  omponent('aug_pe
-00015510: 6e61 6c74 795f 6578 7072 2729 0a0a 2020  nalty_expr')..  
-00015520: 2020 2020 2020 2020 2020 4d69 6e64 7450            MindtP
-00015530: 792e 6175 675f 7065 6e61 6c74 795f 6578  y.aug_penalty_ex
-00015540: 7072 203d 2045 7870 7265 7373 696f 6e28  pr = Expression(
-00015550: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015560: 2065 7870 723d 7369 676e 5f61 646a 7573   expr=sign_adjus
-00015570: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-00015580: 2020 2a20 636f 6e66 6967 2e4f 415f 7065    * config.OA_pe
-00015590: 6e61 6c74 795f 6661 6374 6f72 0a20 2020  nalty_factor.   
-000155a0: 2020 2020 2020 2020 2020 2020 202a 2073               * s
-000155b0: 756d 2876 2066 6f72 2076 2069 6e20 4d69  um(v for v in Mi
-000155c0: 6e64 7450 792e 6375 7473 2e73 6c61 636b  ndtPy.cuts.slack
-000155d0: 5f76 6172 732e 7661 6c75 6573 2829 290a  _vars.values()).
-000155e0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000155f0: 2020 2020 2020 6d61 696e 5f6f 626a 6563        main_objec
-00015600: 7469 7665 203d 204d 696e 6474 5079 2e6f  tive = MindtPy.o
-00015610: 626a 6563 7469 7665 5f6c 6973 745b 2d31  bjective_list[-1
-00015620: 5d0a 2020 2020 2020 2020 4d69 6e64 7450  ].        MindtP
-00015630: 792e 6d69 705f 6f62 6a20 3d20 4f62 6a65  y.mip_obj = Obje
-00015640: 6374 6976 6528 0a20 2020 2020 2020 2020  ctive(.         
-00015650: 2020 2065 7870 723d 6d61 696e 5f6f 626a     expr=main_obj
-00015660: 6563 7469 7665 2e65 7870 720a 2020 2020  ective.expr.    
-00015670: 2020 2020 2020 2020 2b20 284d 696e 6474          + (Mindt
-00015680: 5079 2e61 7567 5f70 656e 616c 7479 5f65  Py.aug_penalty_e
-00015690: 7870 7220 6966 2063 6f6e 6669 672e 6164  xpr if config.ad
-000156a0: 645f 736c 6163 6b20 656c 7365 2030 292c  d_slack else 0),
-000156b0: 0a20 2020 2020 2020 2020 2020 2073 656e  .            sen
-000156c0: 7365 3d73 656c 662e 6f62 6a65 6374 6976  se=self.objectiv
-000156d0: 655f 7365 6e73 652c 0a20 2020 2020 2020  e_sense,.       
-000156e0: 2029 0a0a 2020 2020 2020 2020 6966 2063   )..        if c
-000156f0: 6f6e 6669 672e 7573 655f 6475 616c 5f62  onfig.use_dual_b
-00015700: 6f75 6e64 3a0a 2020 2020 2020 2020 2020  ound:.          
-00015710: 2020 2320 4465 6c65 7465 2070 7265 7669    # Delete previ
-00015720: 6f75 736c 7920 6164 6465 6420 6475 616c  ously added dual
-00015730: 2062 6f75 6e64 2063 6f6e 7374 7261 696e   bound constrain
-00015740: 740a 2020 2020 2020 2020 2020 2020 4d69  t.            Mi
-00015750: 6e64 7450 792e 6375 7473 2e64 656c 5f63  ndtPy.cuts.del_c
-00015760: 6f6d 706f 6e65 6e74 2827 6475 616c 5f62  omponent('dual_b
-00015770: 6f75 6e64 2729 0a20 2020 2020 2020 2020  ound').         
-00015780: 2020 2069 6620 7365 6c66 2e64 7561 6c5f     if self.dual_
-00015790: 626f 756e 6420 6e6f 7420 696e 207b 666c  bound not in {fl
-000157a0: 6f61 7428 2769 6e66 2729 2c20 666c 6f61  oat('inf'), floa
-000157b0: 7428 272d 696e 6627 297d 3a0a 2020 2020  t('-inf')}:.    
-000157c0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-000157d0: 656c 662e 6f62 6a65 6374 6976 655f 7365  elf.objective_se
-000157e0: 6e73 6520 3d3d 206d 696e 696d 697a 653a  nse == minimize:
-000157f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015800: 2020 2020 204d 696e 6474 5079 2e63 7574       MindtPy.cut
-00015810: 732e 6475 616c 5f62 6f75 6e64 203d 2043  s.dual_bound = C
-00015820: 6f6e 7374 7261 696e 7428 0a20 2020 2020  onstraint(.     
-00015830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015840: 2020 2065 7870 723d 6d61 696e 5f6f 626a     expr=main_obj
-00015850: 6563 7469 7665 2e65 7870 720a 2020 2020  ective.expr.    
-00015860: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015870: 2020 2020 2b20 284d 696e 6474 5079 2e61      + (MindtPy.a
-00015880: 7567 5f70 656e 616c 7479 5f65 7870 7220  ug_penalty_expr 
-00015890: 6966 2063 6f6e 6669 672e 6164 645f 736c  if config.add_sl
-000158a0: 6163 6b20 656c 7365 2030 290a 2020 2020  ack else 0).    
-000158b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158c0: 2020 2020 3e3d 2073 656c 662e 6475 616c      >= self.dual
-000158d0: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
-000158e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000158f0: 646f 633d 274f 626a 6563 7469 7665 2066  doc='Objective f
-00015900: 756e 6374 696f 6e20 6578 7072 6573 7369  unction expressi
-00015910: 6f6e 2073 686f 756c 6420 696d 7072 6f76  on should improv
-00015920: 6520 6f6e 2074 6865 2062 6573 7420 666f  e on the best fo
-00015930: 756e 6420 6475 616c 2062 6f75 6e64 272c  und dual bound',
-00015940: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00015950: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-00015960: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000137a0: 2020 2020 2020 2020 2020 2020 274d 4950              'MIP
+000137b0: 206d 6169 6e20 7072 6f62 6c65 6d20 6973   main problem is
+000137c0: 2069 6e66 6561 7369 626c 652e 2027 0a20   infeasible. '. 
+000137d0: 2020 2020 2020 2020 2020 2027 5072 6f62             'Prob
+000137e0: 6c65 6d20 6d61 7920 6861 7665 206e 6f20  lem may have no 
+000137f0: 6d6f 7265 2066 6561 7369 626c 6520 270a  more feasible '.
+00013800: 2020 2020 2020 2020 2020 2020 2762 696e              'bin
+00013810: 6172 7920 636f 6e66 6967 7572 6174 696f  ary configuratio
+00013820: 6e73 2e27 0a20 2020 2020 2020 2029 0a20  ns.'.        ). 
+00013830: 2020 2020 2020 2069 6620 7365 6c66 2e6d         if self.m
+00013840: 6970 5f69 7465 7220 3d3d 2031 3a0a 2020  ip_iter == 1:.  
+00013850: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
+00013860: 6f6e 6669 672e 6c6f 6767 6572 2e77 6172  onfig.logger.war
+00013870: 6e69 6e67 280a 2020 2020 2020 2020 2020  ning(.          
+00013880: 2020 2020 2020 274d 696e 6474 5079 2069        'MindtPy i
+00013890: 6e69 7469 616c 697a 6174 696f 6e20 6d61  nitialization ma
+000138a0: 7920 6861 7665 2067 656e 6572 6174 6564  y have generated
+000138b0: 2070 6f6f 7220 7175 616c 6974 7920 6375   poor quality cu
+000138c0: 7473 2e27 0a20 2020 2020 2020 2020 2020  ts.'.           
+000138d0: 2029 0a20 2020 2020 2020 2023 2054 4f44   ).        # TOD
+000138e0: 4f20 6e6f 2d67 6f6f 6420 6375 7473 2066  O no-good cuts f
+000138f0: 6f72 2073 696e 676c 6520 7472 6565 2063  or single tree c
+00013900: 6173 650a 2020 2020 2020 2020 2320 7365  ase.        # se
+00013910: 7420 6f70 7469 6d69 7374 6963 2062 6f75  t optimistic bou
+00013920: 6e64 2074 6f20 696e 6669 6e69 7479 0a20  nd to infinity. 
+00013930: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
+00013940: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
+00013950: 2020 2020 2020 2020 2020 2020 274d 696e              'Min
+00013960: 6474 5079 2065 7869 7469 6e67 2064 7565  dtPy exiting due
+00013970: 2074 6f20 4d49 4c50 206d 6169 6e20 7072   to MILP main pr
+00013980: 6f62 6c65 6d20 696e 6665 6173 6962 696c  oblem infeasibil
+00013990: 6974 792e 270a 2020 2020 2020 2020 290a  ity.'.        ).
+000139a0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+000139b0: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
+000139c0: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+000139d0: 7469 6f6e 2069 7320 4e6f 6e65 3a0a 2020  tion is None:.  
+000139e0: 2020 2020 2020 2020 2020 6966 2028 0a20            if (. 
+000139f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00013a00: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+00013a10: 203d 3d20 666c 6f61 7428 2769 6e66 2729   == float('inf')
+00013a20: 2061 6e64 2073 656c 662e 6f62 6a65 6374   and self.object
+00013a30: 6976 655f 7365 6e73 6520 3d3d 206d 696e  ive_sense == min
+00013a40: 696d 697a 650a 2020 2020 2020 2020 2020  imize.          
+00013a50: 2020 2920 6f72 2028 0a20 2020 2020 2020    ) or (.       
+00013a60: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
+00013a70: 696d 616c 5f62 6f75 6e64 203d 3d20 666c  imal_bound == fl
+00013a80: 6f61 7428 272d 696e 6627 2920 616e 6420  oat('-inf') and 
+00013a90: 7365 6c66 2e6f 626a 6563 7469 7665 5f73  self.objective_s
+00013aa0: 656e 7365 203d 3d20 6d61 7869 6d69 7a65  ense == maximize
+00013ab0: 0a20 2020 2020 2020 2020 2020 2029 3a0a  .            ):.
+00013ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013ad0: 2320 6966 2073 656c 662e 6d69 705f 6974  # if self.mip_it
+00013ae0: 6572 203d 3d20 303a 0a20 2020 2020 2020  er == 0:.       
+00013af0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+00013b00: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+00013b10: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+00013b20: 6f6e 203d 2074 632e 696e 6665 6173 6962  on = tc.infeasib
+00013b30: 6c65 0a20 2020 2020 2020 2020 2020 2065  le.            e
+00013b40: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00013b50: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
+00013b60: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00013b70: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 203d  tion_condition =
+00013b80: 2074 632e 6665 6173 6962 6c65 0a0a 2020   tc.feasible..  
+00013b90: 2020 6465 6620 6861 6e64 6c65 5f6d 6169    def handle_mai
+00013ba0: 6e5f 6d61 785f 7469 6d65 6c69 6d69 7428  n_max_timelimit(
+00013bb0: 7365 6c66 2c20 6d61 696e 5f6d 6970 2c20  self, main_mip, 
+00013bc0: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+00013bd0: 293a 0a20 2020 2020 2020 2022 2222 5468  ):.        """Th
+00013be0: 6973 2066 756e 6374 696f 6e20 6861 6e64  is function hand
+00013bf0: 6c65 7320 7468 6520 7265 7375 6c74 206f  les the result o
+00013c00: 6620 7468 6520 6c61 7465 7374 2069 7465  f the latest ite
+00013c10: 7261 7469 6f6e 206f 6620 736f 6c76 696e  ration of solvin
+00013c20: 6720 7468 6520 4d49 5020 7072 6f62 6c65  g the MIP proble
+00013c30: 6d0a 2020 2020 2020 2020 6769 7665 6e20  m.        given 
+00013c40: 7468 6174 2073 6f6c 7669 6e67 2074 6865  that solving the
+00013c50: 204d 4950 2074 616b 6573 2074 6f6f 206c   MIP takes too l
+00013c60: 6f6e 672e 0a0a 2020 2020 2020 2020 5061  ong...        Pa
+00013c70: 7261 6d65 7465 7273 0a20 2020 2020 2020  rameters.       
+00013c80: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
+00013c90: 2020 2020 6d61 696e 5f6d 6970 203a 2050      main_mip : P
+00013ca0: 796f 6d6f 206d 6f64 656c 0a20 2020 2020  yomo model.     
+00013cb0: 2020 2020 2020 2054 6865 204d 4950 206d         The MIP m
+00013cc0: 6169 6e20 7072 6f62 6c65 6d2e 0a20 2020  ain problem..   
+00013cd0: 2020 2020 206d 6169 6e5f 6d69 705f 7265       main_mip_re
+00013ce0: 7375 6c74 7320 3a20 5b74 7970 655d 0a20  sults : [type]. 
+00013cf0: 2020 2020 2020 2020 2020 2052 6573 756c             Resul
+00013d00: 7473 2066 726f 6d20 736f 6c76 696e 6720  ts from solving 
+00013d10: 7468 6520 4d49 5020 6d61 696e 2073 7562  the MIP main sub
+00013d20: 7072 6f62 6c65 6d2e 0a20 2020 2020 2020  problem..       
+00013d30: 2022 2222 0a20 2020 2020 2020 2023 2049   """.        # I
+00013d40: 6620 7765 2068 6176 6520 666f 756e 6420  f we have found 
+00013d50: 6120 7661 6c69 6420 6665 6173 6962 6c65  a valid feasible
+00013d60: 2073 6f6c 7574 696f 6e2c 2077 6520 7461   solution, we ta
+00013d70: 6b65 2074 6861 742e 2049 6620 6e6f 742c  ke that. If not,
+00013d80: 2077 6520 6361 6e20 6174 206c 6561 7374   we can at least
+00013d90: 2075 7365 2074 6865 2064 7561 6c20 626f   use the dual bo
+00013da0: 756e 642e 0a20 2020 2020 2020 204d 696e  und..        Min
+00013db0: 6474 5079 203d 206d 6169 6e5f 6d69 702e  dtPy = main_mip.
+00013dc0: 4d69 6e64 7450 795f 7574 696c 730a 2020  MindtPy_utils.  
+00013dd0: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
+00013de0: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
+00013df0: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
+00013e00: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+00013e10: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+00013e20: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
+00013e30: 6978 6564 5f6e 6c70 2e4d 696e 6474 5079  ixed_nlp.MindtPy
+00013e40: 5f75 7469 6c73 2e76 6172 6961 626c 655f  _utils.variable_
+00013e50: 6c69 7374 2c0a 2020 2020 2020 2020 2020  list,.          
+00013e60: 2020 7365 6c66 2e63 6f6e 6669 672c 0a20    self.config,. 
+00013e70: 2020 2020 2020 2020 2020 2073 6b69 705f             skip_
+00013e80: 6669 7865 643d 4661 6c73 652c 0a20 2020  fixed=False,.   
+00013e90: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
+00013ea0: 656c 662e 7570 6461 7465 5f73 7562 6f70  elf.update_subop
+00013eb0: 7469 6d61 6c5f 6475 616c 5f62 6f75 6e64  timal_dual_bound
+00013ec0: 286d 6169 6e5f 6d69 705f 7265 7375 6c74  (main_mip_result
+00013ed0: 7329 0a20 2020 2020 2020 2073 656c 662e  s).        self.
+00013ee0: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
+00013ef0: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
+00013f00: 7365 6c66 2e74 6572 6d69 6e61 7469 6f6e  self.termination
+00013f10: 5f63 6f6e 6469 7469 6f6e 5f6c 6f67 5f66  _condition_log_f
+00013f20: 6f72 6d61 7474 6572 2e66 6f72 6d61 7428  ormatter.format(
+00013f30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013f40: 2073 656c 662e 6d69 705f 6974 6572 2c0a   self.mip_iter,.
+00013f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013f60: 274d 494c 5027 2c0a 2020 2020 2020 2020  'MILP',.        
+00013f70: 2020 2020 2020 2020 276d 6178 5469 6d65          'maxTime
+00013f80: 4c69 6d69 7427 2c0a 2020 2020 2020 2020  Limit',.        
+00013f90: 2020 2020 2020 2020 7365 6c66 2e70 7269          self.pri
+00013fa0: 6d61 6c5f 626f 756e 642c 0a20 2020 2020  mal_bound,.     
+00013fb0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00013fc0: 6475 616c 5f62 6f75 6e64 2c0a 2020 2020  dual_bound,.    
+00013fd0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00013fe0: 2e72 656c 5f67 6170 2c0a 2020 2020 2020  .rel_gap,.      
+00013ff0: 2020 2020 2020 2020 2020 6765 745f 6d61            get_ma
+00014000: 696e 5f65 6c61 7073 6564 5f74 696d 6528  in_elapsed_time(
+00014010: 7365 6c66 2e74 696d 696e 6729 2c0a 2020  self.timing),.  
+00014020: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00014030: 2020 2020 290a 0a20 2020 2064 6566 2068      )..    def h
+00014040: 616e 646c 655f 6d61 696e 5f75 6e62 6f75  andle_main_unbou
+00014050: 6e64 6564 2873 656c 662c 206d 6169 6e5f  nded(self, main_
+00014060: 6d69 7029 3a0a 2020 2020 2020 2020 2222  mip):.        ""
+00014070: 2254 6869 7320 6675 6e63 7469 6f6e 2068  "This function h
+00014080: 616e 646c 6573 2074 6865 2072 6573 756c  andles the resul
+00014090: 7420 6f66 2074 6865 206c 6174 6573 7420  t of the latest 
+000140a0: 6974 6572 6174 696f 6e20 6f66 2073 6f6c  iteration of sol
+000140b0: 7669 6e67 2074 6865 204d 4950 0a20 2020  ving the MIP.   
+000140c0: 2020 2020 2070 726f 626c 656d 2067 6976       problem giv
+000140d0: 656e 2061 6e20 756e 626f 756e 6465 6420  en an unbounded 
+000140e0: 736f 6c75 7469 6f6e 2064 7565 2074 6f20  solution due to 
+000140f0: 7468 6520 7265 6c61 7861 7469 6f6e 2e0a  the relaxation..
+00014100: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+00014110: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+00014120: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 206d  ------.        m
+00014130: 6169 6e5f 6d69 7020 3a20 5079 6f6d 6f20  ain_mip : Pyomo 
+00014140: 6d6f 6465 6c0a 2020 2020 2020 2020 2020  model.          
+00014150: 2020 5468 6520 4d49 5020 6d61 696e 2070    The MIP main p
+00014160: 726f 626c 656d 2e0a 0a20 2020 2020 2020  roblem...       
+00014170: 2052 6574 7572 6e73 0a20 2020 2020 2020   Returns.       
+00014180: 202d 2d2d 2d2d 2d2d 0a20 2020 2020 2020   -------.       
+00014190: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+000141a0: 7320 3a20 536f 6c76 6572 5265 7375 6c74  s : SolverResult
+000141b0: 730a 2020 2020 2020 2020 2020 2020 5468  s.            Th
+000141c0: 6520 7265 7375 6c74 7320 6f66 2074 6865  e results of the
+000141d0: 2062 6f75 6e64 6564 206d 6169 6e20 7072   bounded main pr
+000141e0: 6f62 6c65 6d2e 0a20 2020 2020 2020 2022  oblem..        "
+000141f0: 2222 0a20 2020 2020 2020 2023 2053 6f6c  "".        # Sol
+00014200: 7574 696f 6e20 6973 2075 6e62 6f75 6e64  ution is unbound
+00014210: 6564 2e20 4164 6420 616e 2061 7262 6974  ed. Add an arbit
+00014220: 7261 7279 2062 6f75 6e64 2074 6f20 7468  rary bound to th
+00014230: 6520 6f62 6a65 6374 6976 6520 616e 6420  e objective and 
+00014240: 7265 736f 6c76 652e 0a20 2020 2020 2020  resolve..       
+00014250: 2023 2054 6869 7320 6f63 6375 7273 2077   # This occurs w
+00014260: 6865 6e20 7468 6520 6f62 6a65 6374 6976  hen the objectiv
+00014270: 6520 6973 206e 6f6e 6c69 6e65 6172 2e20  e is nonlinear. 
+00014280: 5468 6520 6e6f 6e6c 696e 6561 7220 6f62  The nonlinear ob
+00014290: 6a65 6374 6976 6520 6973 206d 6f76 6564  jective is moved
+000142a0: 0a20 2020 2020 2020 2023 2074 6f20 7468  .        # to th
+000142b0: 6520 636f 6e73 7472 6169 6e74 732c 2061  e constraints, a
+000142c0: 6e64 2064 6561 6374 6976 6174 6564 2066  nd deactivated f
+000142d0: 6f72 2074 6865 206c 696e 6561 7220 6d61  or the linear ma
+000142e0: 696e 2070 726f 626c 656d 2e0a 2020 2020  in problem..    
+000142f0: 2020 2020 636f 6e66 6967 203d 2073 656c      config = sel
+00014300: 662e 636f 6e66 6967 0a20 2020 2020 2020  f.config.       
+00014310: 204d 696e 6474 5079 203d 206d 6169 6e5f   MindtPy = main_
+00014320: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
+00014330: 730a 2020 2020 2020 2020 636f 6e66 6967  s.        config
+00014340: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
+00014350: 2020 2020 2020 2020 2020 7365 6c66 2e74            self.t
+00014360: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+00014370: 7469 6f6e 5f6c 6f67 5f66 6f72 6d61 7474  tion_log_formatt
+00014380: 6572 2e66 6f72 6d61 7428 0a20 2020 2020  er.format(.     
+00014390: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000143a0: 6d69 705f 6974 6572 2c0a 2020 2020 2020  mip_iter,.      
+000143b0: 2020 2020 2020 2020 2020 274d 494c 5027            'MILP'
+000143c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000143d0: 2020 2755 6e62 6f75 6e64 6564 272c 0a20    'Unbounded',. 
+000143e0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000143f0: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+00014400: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00014410: 2020 7365 6c66 2e64 7561 6c5f 626f 756e    self.dual_boun
+00014420: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
+00014430: 2020 2073 656c 662e 7265 6c5f 6761 702c     self.rel_gap,
+00014440: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014450: 2067 6574 5f6d 6169 6e5f 656c 6170 7365   get_main_elapse
+00014460: 645f 7469 6d65 2873 656c 662e 7469 6d69  d_time(self.timi
+00014470: 6e67 292c 0a20 2020 2020 2020 2020 2020  ng),.           
+00014480: 2029 0a20 2020 2020 2020 2029 0a20 2020   ).        ).   
+00014490: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
+000144a0: 6572 2e77 6172 6e69 6e67 280a 2020 2020  er.warning(.    
+000144b0: 2020 2020 2020 2020 2752 6573 6f6c 7669          'Resolvi
+000144c0: 6e67 2077 6974 6820 6172 6269 7472 6172  ng with arbitrar
+000144d0: 7920 626f 756e 6420 7661 6c75 6573 206f  y bound values o
+000144e0: 6620 282d 7b30 3a2e 3130 677d 2c20 7b30  f (-{0:.10g}, {0
+000144f0: 3a2e 3130 677d 2920 6f6e 2074 6865 206f  :.10g}) on the o
+00014500: 626a 6563 7469 7665 2e20 270a 2020 2020  bjective. '.    
+00014510: 2020 2020 2020 2020 2759 6f75 2063 616e          'You can
+00014520: 2063 6861 6e67 6520 7468 6973 2062 6f75   change this bou
+00014530: 6e64 2077 6974 6820 7468 6520 6f70 7469  nd with the opti
+00014540: 6f6e 206f 626a 5f62 6f75 6e64 2e27 2e66  on obj_bound.'.f
+00014550: 6f72 6d61 7428 0a20 2020 2020 2020 2020  ormat(.         
+00014560: 2020 2020 2020 2063 6f6e 6669 672e 6f62         config.ob
+00014570: 6a5f 626f 756e 640a 2020 2020 2020 2020  j_bound.        
+00014580: 2020 2020 290a 2020 2020 2020 2020 290a      ).        ).
+00014590: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+000145a0: 6f62 6a65 6374 6976 655f 626f 756e 6420  objective_bound 
+000145b0: 3d20 436f 6e73 7472 6169 6e74 280a 2020  = Constraint(.  
+000145c0: 2020 2020 2020 2020 2020 6578 7072 3d28            expr=(
+000145d0: 2d63 6f6e 6669 672e 6f62 6a5f 626f 756e  -config.obj_boun
+000145e0: 642c 204d 696e 6474 5079 2e6d 6970 5f6f  d, MindtPy.mip_o
+000145f0: 626a 2e65 7870 722c 2063 6f6e 6669 672e  bj.expr, config.
+00014600: 6f62 6a5f 626f 756e 6429 0a20 2020 2020  obj_bound).     
+00014610: 2020 2029 0a20 2020 2020 2020 2069 6620     ).        if 
+00014620: 6973 696e 7374 616e 6365 2873 656c 662e  isinstance(self.
+00014630: 6d69 705f 6f70 742c 2050 6572 7369 7374  mip_opt, Persist
+00014640: 656e 7453 6f6c 7665 7229 3a0a 2020 2020  entSolver):.    
+00014650: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+00014660: 5f6f 7074 2e73 6574 5f69 6e73 7461 6e63  _opt.set_instanc
+00014670: 6528 6d61 696e 5f6d 6970 290a 2020 2020  e(main_mip).    
+00014680: 2020 2020 7570 6461 7465 5f73 6f6c 7665      update_solve
+00014690: 725f 7469 6d65 6c69 6d69 7428 7365 6c66  r_timelimit(self
+000146a0: 2e6d 6970 5f6f 7074 2c20 636f 6e66 6967  .mip_opt, config
+000146b0: 2e6d 6970 5f73 6f6c 7665 722c 2073 656c  .mip_solver, sel
+000146c0: 662e 7469 6d69 6e67 2c20 636f 6e66 6967  f.timing, config
+000146d0: 290a 2020 2020 2020 2020 7769 7468 2053  ).        with S
+000146e0: 7570 7072 6573 7349 6e66 6561 7369 626c  uppressInfeasibl
+000146f0: 6557 6172 6e69 6e67 2829 3a0a 2020 2020  eWarning():.    
+00014700: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
+00014710: 5f72 6573 756c 7473 203d 2073 656c 662e  _results = self.
+00014720: 6d69 705f 6f70 742e 736f 6c76 6528 0a20  mip_opt.solve(. 
+00014730: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00014740: 6169 6e5f 6d69 702c 0a20 2020 2020 2020  ain_mip,.       
+00014750: 2020 2020 2020 2020 2074 6565 3d63 6f6e           tee=con
+00014760: 6669 672e 6d69 705f 736f 6c76 6572 5f74  fig.mip_solver_t
+00014770: 6565 2c0a 2020 2020 2020 2020 2020 2020  ee,.            
+00014780: 2020 2020 6c6f 6164 5f73 6f6c 7574 696f      load_solutio
+00014790: 6e73 3d73 656c 662e 6d69 705f 6c6f 6164  ns=self.mip_load
+000147a0: 5f73 6f6c 7574 696f 6e73 2c0a 2020 2020  _solutions,.    
+000147b0: 2020 2020 2020 2020 2020 2020 2a2a 636f              **co
+000147c0: 6e66 6967 2e6d 6970 5f73 6f6c 7665 725f  nfig.mip_solver_
+000147d0: 6172 6773 2c0a 2020 2020 2020 2020 2020  args,.          
+000147e0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+000147f0: 6966 206c 656e 286d 6169 6e5f 6d69 705f  if len(main_mip_
+00014800: 7265 7375 6c74 732e 736f 6c75 7469 6f6e  results.solution
+00014810: 2920 3e20 303a 0a20 2020 2020 2020 2020  ) > 0:.         
+00014820: 2020 2020 2020 2073 656c 662e 6d69 702e         self.mip.
+00014830: 736f 6c75 7469 6f6e 732e 6c6f 6164 5f66  solutions.load_f
+00014840: 726f 6d28 6d61 696e 5f6d 6970 5f72 6573  rom(main_mip_res
+00014850: 756c 7473 290a 2020 2020 2020 2020 7265  ults).        re
+00014860: 7475 726e 206d 6169 6e5f 6d69 705f 7265  turn main_mip_re
+00014870: 7375 6c74 730a 0a20 2020 2064 6566 2068  sults..    def h
+00014880: 616e 646c 655f 7265 6775 6c61 7269 7a61  andle_regulariza
+00014890: 7469 6f6e 5f6d 6169 6e5f 7463 2873 656c  tion_main_tc(sel
+000148a0: 662c 206d 6169 6e5f 6d69 702c 206d 6169  f, main_mip, mai
+000148b0: 6e5f 6d69 705f 7265 7375 6c74 7329 3a0a  n_mip_results):.
+000148c0: 2020 2020 2020 2020 2222 2248 616e 646c          """Handl
+000148d0: 6573 2074 6865 2072 6573 756c 7420 6f66  es the result of
+000148e0: 2074 6865 2072 6567 756c 6172 697a 6174   the regularizat
+000148f0: 696f 6e20 6d61 696e 2070 726f 626c 656d  ion main problem
+00014900: 2e0a 0a20 2020 2020 2020 2050 6172 616d  ...        Param
+00014910: 6574 6572 730a 2020 2020 2020 2020 2d2d  eters.        --
+00014920: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020 2020  --------.       
+00014930: 206d 6169 6e5f 6d69 7020 3a20 5079 6f6d   main_mip : Pyom
+00014940: 6f20 6d6f 6465 6c0a 2020 2020 2020 2020  o model.        
+00014950: 2020 2020 5468 6520 4d49 5020 6d61 696e      The MIP main
+00014960: 2070 726f 626c 656d 2e0a 2020 2020 2020   problem..      
+00014970: 2020 6d61 696e 5f6d 6970 5f72 6573 756c    main_mip_resul
+00014980: 7473 203a 2053 6f6c 7665 7252 6573 756c  ts : SolverResul
+00014990: 7473 0a20 2020 2020 2020 2020 2020 2052  ts.            R
+000149a0: 6573 756c 7473 2066 726f 6d20 736f 6c76  esults from solv
+000149b0: 696e 6720 7468 6520 7265 6775 6c61 7269  ing the regulari
+000149c0: 7a61 7469 6f6e 206d 6169 6e20 7375 6270  zation main subp
+000149d0: 726f 626c 656d 2e0a 0a20 2020 2020 2020  roblem...       
+000149e0: 2052 6169 7365 730a 2020 2020 2020 2020   Raises.        
+000149f0: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2056  ------.        V
+00014a00: 616c 7565 4572 726f 720a 2020 2020 2020  alueError.      
+00014a10: 2020 2020 2020 4d69 6e64 7450 7920 756e        MindtPy un
+00014a20: 6162 6c65 2074 6f20 6861 6e64 6c65 2074  able to handle t
+00014a30: 6865 2072 6567 756c 6172 697a 6174 696f  he regularizatio
+00014a40: 6e20 7072 6f62 6c65 6d20 7465 726d 696e  n problem termin
+00014a50: 6174 696f 6e20 636f 6e64 6974 696f 6e2e  ation condition.
+00014a60: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+00014a70: 2020 2020 2069 6620 6d61 696e 5f6d 6970       if main_mip
+00014a80: 5f72 6573 756c 7473 2069 7320 4e6f 6e65  _results is None
+00014a90: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+00014aa0: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
+00014ab0: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+00014ac0: 2020 2020 2020 2027 4661 696c 6564 2074         'Failed t
+00014ad0: 6f20 736f 6c76 6520 7468 6520 7265 6775  o solve the regu
+00014ae0: 6c61 7269 7a61 7469 6f6e 2070 726f 626c  larization probl
+00014af0: 656d 2e27 0a20 2020 2020 2020 2020 2020  em.'.           
+00014b00: 2020 2020 2027 5468 6520 736f 6c75 7469       'The soluti
+00014b10: 6f6e 206f 6620 7468 6520 4f41 206d 6169  on of the OA mai
+00014b20: 6e20 7072 6f62 6c65 6d20 7769 6c6c 2062  n problem will b
+00014b30: 6520 6164 6f70 7465 642e 270a 2020 2020  e adopted.'.    
+00014b40: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00014b50: 2020 656c 6966 206d 6169 6e5f 6d69 705f    elif main_mip_
+00014b60: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
+00014b70: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+00014b80: 7469 6f6e 2069 6e20 7b74 632e 6f70 7469  tion in {tc.opti
+00014b90: 6d61 6c2c 2074 632e 6665 6173 6962 6c65  mal, tc.feasible
+00014ba0: 7d3a 0a20 2020 2020 2020 2020 2020 2073  }:.            s
+00014bb0: 656c 662e 6861 6e64 6c65 5f6d 6169 6e5f  elf.handle_main_
+00014bc0: 6f70 7469 6d61 6c28 6d61 696e 5f6d 6970  optimal(main_mip
+00014bd0: 2c20 7570 6461 7465 5f62 6f75 6e64 3d46  , update_bound=F
+00014be0: 616c 7365 290a 2020 2020 2020 2020 656c  alse).        el
+00014bf0: 6966 206d 6169 6e5f 6d69 705f 7265 7375  if main_mip_resu
+00014c00: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+00014c10: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+00014c20: 2069 7320 7463 2e6d 6178 5469 6d65 4c69   is tc.maxTimeLi
+00014c30: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
+00014c40: 2073 656c 662e 636f 6e66 6967 2e6c 6f67   self.config.log
+00014c50: 6765 722e 696e 666f 280a 2020 2020 2020  ger.info(.      
+00014c60: 2020 2020 2020 2020 2020 2752 6567 756c            'Regul
+00014c70: 6172 697a 6174 696f 6e20 7072 6f62 6c65  arization proble
+00014c80: 6d20 6661 696c 6564 2074 6f20 636f 6e76  m failed to conv
+00014c90: 6572 6765 2077 6974 6869 6e20 7468 6520  erge within the 
+00014ca0: 7469 6d65 206c 696d 6974 2e27 0a20 2020  time limit.'.   
+00014cb0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00014cc0: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+00014cd0: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+00014ce0: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+00014cf0: 203d 2074 632e 6d61 7854 696d 654c 696d   = tc.maxTimeLim
+00014d00: 6974 0a20 2020 2020 2020 2020 2020 2023  it.            #
+00014d10: 2062 7265 616b 0a20 2020 2020 2020 2065   break.        e
+00014d20: 6c69 6620 6d61 696e 5f6d 6970 5f72 6573  lif main_mip_res
+00014d30: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+00014d40: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+00014d50: 6e20 6973 2074 632e 696e 6665 6173 6962  n is tc.infeasib
+00014d60: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
+00014d70: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
+00014d80: 6572 2e69 6e66 6f28 2752 6567 756c 6172  er.info('Regular
+00014d90: 697a 6174 696f 6e20 7072 6f62 6c65 6d20  ization problem 
+00014da0: 696e 6665 6173 6962 6c65 2e27 290a 2020  infeasible.').  
+00014db0: 2020 2020 2020 656c 6966 206d 6169 6e5f        elif main_
+00014dc0: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
+00014dd0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+00014de0: 6f6e 6469 7469 6f6e 2069 7320 7463 2e75  ondition is tc.u
+00014df0: 6e62 6f75 6e64 6564 3a0a 2020 2020 2020  nbounded:.      
+00014e00: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
+00014e10: 672e 6c6f 6767 6572 2e69 6e66 6f28 0a20  g.logger.info(. 
+00014e20: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00014e30: 5265 6775 6c61 7269 7a61 7469 6f6e 2070  Regularization p
+00014e40: 726f 626c 656d 2075 6e62 6f75 6e64 6564  roblem unbounded
+00014e50: 2e27 0a20 2020 2020 2020 2020 2020 2020  .'.             
+00014e60: 2020 2027 536f 6d65 7469 6d65 7320 736f     'Sometimes so
+00014e70: 6c76 696e 6720 4d49 5143 5020 696e 2043  lving MIQCP in C
+00014e80: 504c 4558 2c20 756e 626f 756e 6465 6420  PLEX, unbounded 
+00014e90: 6d65 616e 7320 696e 6665 6173 6962 6c65  means infeasible
+00014ea0: 2e27 0a20 2020 2020 2020 2020 2020 2029  .'.            )
+00014eb0: 0a20 2020 2020 2020 2065 6c69 6620 6d61  .        elif ma
+00014ec0: 696e 5f6d 6970 5f72 6573 756c 7473 2e73  in_mip_results.s
+00014ed0: 6f6c 7665 722e 7465 726d 696e 6174 696f  olver.terminatio
+00014ee0: 6e5f 636f 6e64 6974 696f 6e20 6973 2074  n_condition is t
+00014ef0: 632e 696e 6665 6173 6962 6c65 4f72 556e  c.infeasibleOrUn
+00014f00: 626f 756e 6465 643a 0a20 2020 2020 2020  bounded:.       
+00014f10: 2020 2020 2073 656c 662e 636f 6e66 6967       self.config
+00014f20: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
+00014f30: 2020 2020 2020 2020 2020 2020 2020 2752                'R
+00014f40: 6567 756c 6172 697a 6174 696f 6e20 7072  egularization pr
+00014f50: 6f62 6c65 6d20 6973 2069 6e66 6561 7369  oblem is infeasi
+00014f60: 626c 6520 6f72 2075 6e62 6f75 6e64 6564  ble or unbounded
+00014f70: 2e27 0a20 2020 2020 2020 2020 2020 2020  .'.             
+00014f80: 2020 2027 4974 206d 6967 6874 2068 6170     'It might hap
+00014f90: 7065 6e20 7768 656e 2075 7369 6e67 2043  pen when using C
+00014fa0: 504c 4558 2074 6f20 736f 6c76 6520 4d49  PLEX to solve MI
+00014fb0: 5150 2e27 0a20 2020 2020 2020 2020 2020  QP.'.           
+00014fc0: 2029 0a20 2020 2020 2020 2065 6c69 6620   ).        elif 
+00014fd0: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+00014fe0: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
+00014ff0: 696f 6e5f 636f 6e64 6974 696f 6e20 6973  ion_condition is
+00015000: 2074 632e 756e 6b6e 6f77 6e3a 0a20 2020   tc.unknown:.   
+00015010: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
+00015020: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
+00015030: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00015040: 2020 2754 6572 6d69 6e61 7469 6f6e 2063    'Termination c
+00015050: 6f6e 6469 7469 6f6e 206f 6620 7468 6520  ondition of the 
+00015060: 7265 6775 6c61 7269 7a61 7469 6f6e 2070  regularization p
+00015070: 726f 626c 656d 2069 7320 756e 6b6e 6f77  roblem is unknow
+00015080: 6e2e 270a 2020 2020 2020 2020 2020 2020  n.'.            
+00015090: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+000150a0: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
+000150b0: 732e 7072 6f62 6c65 6d2e 6c6f 7765 725f  s.problem.lower_
+000150c0: 626f 756e 6420 213d 2066 6c6f 6174 2827  bound != float('
+000150d0: 2d69 6e66 2729 3a0a 2020 2020 2020 2020  -inf'):.        
+000150e0: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
+000150f0: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+00015100: 2753 6f6c 7574 696f 6e20 6c69 6d69 7420  'Solution limit 
+00015110: 6861 7320 6265 656e 2072 6561 6368 6564  has been reached
+00015120: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
+00015130: 2020 2020 7365 6c66 2e68 616e 646c 655f      self.handle_
+00015140: 6d61 696e 5f6f 7074 696d 616c 286d 6169  main_optimal(mai
+00015150: 6e5f 6d69 702c 2075 7064 6174 655f 626f  n_mip, update_bo
+00015160: 756e 643d 4661 6c73 6529 0a20 2020 2020  und=False).     
+00015170: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00015180: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00015190: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
+000151a0: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
+000151b0: 2020 2020 2020 2020 2020 274e 6f20 736f            'No so
+000151c0: 6c75 7469 6f6e 206f 6274 6169 6e65 6420  lution obtained 
+000151d0: 6672 6f6d 2074 6865 2072 6567 756c 6172  from the regular
+000151e0: 697a 6174 696f 6e20 7375 6270 726f 626c  ization subprobl
+000151f0: 656d 2e27 0a20 2020 2020 2020 2020 2020  em.'.           
+00015200: 2020 2020 2020 2020 2027 506c 6561 7365           'Please
+00015210: 2073 6574 206d 6970 5f73 6f6c 7665 725f   set mip_solver_
+00015220: 7465 6520 746f 2054 7275 6520 666f 7220  tee to True for 
+00015230: 6d6f 7265 2069 6e66 6f72 6d61 7469 6f6e  more information
+00015240: 2e27 0a20 2020 2020 2020 2020 2020 2020  .'.             
+00015250: 2020 2020 2020 2027 5468 6520 736f 6c75         'The solu
+00015260: 7469 6f6e 206f 6620 7468 6520 4f41 206d  tion of the OA m
+00015270: 6169 6e20 7072 6f62 6c65 6d20 7769 6c6c  ain problem will
+00015280: 2062 6520 6164 6f70 7465 642e 270a 2020   be adopted.'.  
+00015290: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+000152a0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+000152b0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+000152c0: 5661 6c75 6545 7272 6f72 280a 2020 2020  ValueError(.    
+000152d0: 2020 2020 2020 2020 2020 2020 274d 696e              'Min
+000152e0: 6474 5079 2075 6e61 626c 6520 746f 2068  dtPy unable to h
+000152f0: 616e 646c 6520 7265 6775 6c61 7269 7a61  andle regulariza
+00015300: 7469 6f6e 2070 726f 626c 656d 2074 6572  tion problem ter
+00015310: 6d69 6e61 7469 6f6e 2063 6f6e 6469 7469  mination conditi
+00015320: 6f6e 2027 0a20 2020 2020 2020 2020 2020  on '.           
+00015330: 2020 2020 2027 6f66 2025 732e 2053 6f6c       'of %s. Sol
+00015340: 7665 7220 6d65 7373 6167 653a 2025 7327  ver message: %s'
+00015350: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015360: 2025 2028 0a20 2020 2020 2020 2020 2020   % (.           
+00015370: 2020 2020 2020 2020 206d 6169 6e5f 6d69           main_mi
+00015380: 705f 7265 7375 6c74 732e 736f 6c76 6572  p_results.solver
+00015390: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
+000153a0: 6469 7469 6f6e 2c0a 2020 2020 2020 2020  dition,.        
+000153b0: 2020 2020 2020 2020 2020 2020 6d61 696e              main
+000153c0: 5f6d 6970 5f72 6573 756c 7473 2e73 6f6c  _mip_results.sol
+000153d0: 7665 722e 6d65 7373 6167 652c 0a20 2020  ver.message,.   
+000153e0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+000153f0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+00015400: 2020 6465 6620 7365 7475 705f 6d61 696e    def setup_main
+00015410: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00015420: 2222 2253 6574 2075 7020 6d61 696e 2070  """Set up main p
+00015430: 726f 626c 656d 2f6d 6169 6e20 7265 6775  roblem/main regu
+00015440: 6c61 7269 7a61 7469 6f6e 2070 726f 626c  larization probl
+00015450: 656d 2066 6f72 204f 412c 2045 4350 2c20  em for OA, ECP, 
+00015460: 4665 6173 6962 696c 6974 7920 5075 6d70  Feasibility Pump
+00015470: 2061 6e64 2052 4f41 206d 6574 686f 6473   and ROA methods
+00015480: 2e22 2222 0a20 2020 2020 2020 2063 6f6e  .""".        con
+00015490: 6669 6720 3d20 7365 6c66 2e63 6f6e 6669  fig = self.confi
+000154a0: 670a 2020 2020 2020 2020 4d69 6e64 7450  g.        MindtP
+000154b0: 7920 3d20 7365 6c66 2e6d 6970 2e4d 696e  y = self.mip.Min
+000154c0: 6474 5079 5f75 7469 6c73 0a0a 2020 2020  dtPy_utils..    
+000154d0: 2020 2020 666f 7220 6320 696e 204d 696e      for c in Min
+000154e0: 6474 5079 2e63 6f6e 7374 7261 696e 745f  dtPy.constraint_
+000154f0: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
+00015500: 2020 6966 2063 2e62 6f64 792e 706f 6c79    if c.body.poly
+00015510: 6e6f 6d69 616c 5f64 6567 7265 6528 2920  nomial_degree() 
+00015520: 6e6f 7420 696e 2073 656c 662e 6d69 705f  not in self.mip_
+00015530: 636f 6e73 7472 6169 6e74 5f70 6f6c 796e  constraint_polyn
+00015540: 6f6d 6961 6c5f 6465 6772 6565 3a0a 2020  omial_degree:.  
+00015550: 2020 2020 2020 2020 2020 2020 2020 632e                c.
+00015560: 6465 6163 7469 7661 7465 2829 0a0a 2020  deactivate()..  
+00015570: 2020 2020 2020 4d69 6e64 7450 792e 6375        MindtPy.cu
+00015580: 7473 2e61 6374 6976 6174 6528 290a 0a20  ts.activate().. 
+00015590: 2020 2020 2020 2073 6967 6e5f 6164 6a75         sign_adju
+000155a0: 7374 203d 2031 2069 6620 7365 6c66 2e6f  st = 1 if self.o
+000155b0: 626a 6563 7469 7665 5f73 656e 7365 203d  bjective_sense =
+000155c0: 3d20 6d69 6e69 6d69 7a65 2065 6c73 6520  = minimize else 
+000155d0: 2d31 0a20 2020 2020 2020 204d 696e 6474  -1.        Mindt
+000155e0: 5079 2e64 656c 5f63 6f6d 706f 6e65 6e74  Py.del_component
+000155f0: 2827 6d69 705f 6f62 6a27 290a 2020 2020  ('mip_obj').    
+00015600: 2020 2020 6966 2063 6f6e 6669 672e 6164      if config.ad
+00015610: 645f 7265 6775 6c61 7269 7a61 7469 6f6e  d_regularization
+00015620: 2069 7320 6e6f 7420 4e6f 6e65 2061 6e64   is not None and
+00015630: 2063 6f6e 6669 672e 6164 645f 6e6f 5f67   config.add_no_g
+00015640: 6f6f 645f 6375 7473 3a0a 2020 2020 2020  ood_cuts:.      
+00015650: 2020 2020 2020 4d69 6e64 7450 792e 6375        MindtPy.cu
+00015660: 7473 2e6e 6f5f 676f 6f64 5f63 7574 732e  ts.no_good_cuts.
+00015670: 6465 6163 7469 7661 7465 2829 0a0a 2020  deactivate()..  
+00015680: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+00015690: 6164 645f 736c 6163 6b3a 0a20 2020 2020  add_slack:.     
+000156a0: 2020 2020 2020 204d 696e 6474 5079 2e64         MindtPy.d
+000156b0: 656c 5f63 6f6d 706f 6e65 6e74 2827 6175  el_component('au
+000156c0: 675f 7065 6e61 6c74 795f 6578 7072 2729  g_penalty_expr')
+000156d0: 0a0a 2020 2020 2020 2020 2020 2020 4d69  ..            Mi
+000156e0: 6e64 7450 792e 6175 675f 7065 6e61 6c74  ndtPy.aug_penalt
+000156f0: 795f 6578 7072 203d 2045 7870 7265 7373  y_expr = Express
+00015700: 696f 6e28 0a20 2020 2020 2020 2020 2020  ion(.           
+00015710: 2020 2020 2065 7870 723d 7369 676e 5f61       expr=sign_a
+00015720: 646a 7573 740a 2020 2020 2020 2020 2020  djust.          
+00015730: 2020 2020 2020 2a20 636f 6e66 6967 2e4f        * config.O
+00015740: 415f 7065 6e61 6c74 795f 6661 6374 6f72  A_penalty_factor
+00015750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015760: 202a 2073 756d 2876 2066 6f72 2076 2069   * sum(v for v i
+00015770: 6e20 4d69 6e64 7450 792e 6375 7473 2e73  n MindtPy.cuts.s
+00015780: 6c61 636b 5f76 6172 732e 7661 6c75 6573  lack_vars.values
+00015790: 2829 290a 2020 2020 2020 2020 2020 2020  ()).            
+000157a0: 290a 2020 2020 2020 2020 6d61 696e 5f6f  ).        main_o
+000157b0: 626a 6563 7469 7665 203d 204d 696e 6474  bjective = Mindt
+000157c0: 5079 2e6f 626a 6563 7469 7665 5f6c 6973  Py.objective_lis
+000157d0: 745b 2d31 5d0a 2020 2020 2020 2020 4d69  t[-1].        Mi
+000157e0: 6e64 7450 792e 6d69 705f 6f62 6a20 3d20  ndtPy.mip_obj = 
+000157f0: 4f62 6a65 6374 6976 6528 0a20 2020 2020  Objective(.     
+00015800: 2020 2020 2020 2065 7870 723d 6d61 696e         expr=main
+00015810: 5f6f 626a 6563 7469 7665 2e65 7870 720a  _objective.expr.
+00015820: 2020 2020 2020 2020 2020 2020 2b20 284d              + (M
+00015830: 696e 6474 5079 2e61 7567 5f70 656e 616c  indtPy.aug_penal
+00015840: 7479 5f65 7870 7220 6966 2063 6f6e 6669  ty_expr if confi
+00015850: 672e 6164 645f 736c 6163 6b20 656c 7365  g.add_slack else
+00015860: 2030 292c 0a20 2020 2020 2020 2020 2020   0),.           
+00015870: 2073 656e 7365 3d73 656c 662e 6f62 6a65   sense=self.obje
+00015880: 6374 6976 655f 7365 6e73 652c 0a20 2020  ctive_sense,.   
+00015890: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+000158a0: 6966 2063 6f6e 6669 672e 7573 655f 6475  if config.use_du
+000158b0: 616c 5f62 6f75 6e64 3a0a 2020 2020 2020  al_bound:.      
+000158c0: 2020 2020 2020 2320 4465 6c65 7465 2070        # Delete p
+000158d0: 7265 7669 6f75 736c 7920 6164 6465 6420  reviously added 
+000158e0: 6475 616c 2062 6f75 6e64 2063 6f6e 7374  dual bound const
+000158f0: 7261 696e 740a 2020 2020 2020 2020 2020  raint.          
+00015900: 2020 4d69 6e64 7450 792e 6375 7473 2e64    MindtPy.cuts.d
+00015910: 656c 5f63 6f6d 706f 6e65 6e74 2827 6475  el_component('du
+00015920: 616c 5f62 6f75 6e64 2729 0a20 2020 2020  al_bound').     
+00015930: 2020 2020 2020 2069 6620 7365 6c66 2e64         if self.d
+00015940: 7561 6c5f 626f 756e 6420 6e6f 7420 696e  ual_bound not in
+00015950: 207b 666c 6f61 7428 2769 6e66 2729 2c20   {float('inf'), 
+00015960: 666c 6f61 7428 272d 696e 6627 297d 3a0a  float('-inf')}:.
 00015970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015980: 204d 696e 6474 5079 2e63 7574 732e 6475   MindtPy.cuts.du
-00015990: 616c 5f62 6f75 6e64 203d 2043 6f6e 7374  al_bound = Const
-000159a0: 7261 696e 7428 0a20 2020 2020 2020 2020  raint(.         
-000159b0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-000159c0: 7870 723d 6d61 696e 5f6f 626a 6563 7469  xpr=main_objecti
-000159d0: 7665 2e65 7870 720a 2020 2020 2020 2020  ve.expr.        
+00015980: 6966 2073 656c 662e 6f62 6a65 6374 6976  if self.objectiv
+00015990: 655f 7365 6e73 6520 3d3d 206d 696e 696d  e_sense == minim
+000159a0: 697a 653a 0a20 2020 2020 2020 2020 2020  ize:.           
+000159b0: 2020 2020 2020 2020 204d 696e 6474 5079           MindtPy
+000159c0: 2e63 7574 732e 6475 616c 5f62 6f75 6e64  .cuts.dual_bound
+000159d0: 203d 2043 6f6e 7374 7261 696e 7428 0a20   = Constraint(. 
 000159e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000159f0: 2b20 284d 696e 6474 5079 2e61 7567 5f70  + (MindtPy.aug_p
-00015a00: 656e 616c 7479 5f65 7870 7220 6966 2063  enalty_expr if c
-00015a10: 6f6e 6669 672e 6164 645f 736c 6163 6b20  onfig.add_slack 
-00015a20: 656c 7365 2030 290a 2020 2020 2020 2020  else 0).        
-00015a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015a40: 3c3d 2073 656c 662e 6475 616c 5f62 6f75  <= self.dual_bou
-00015a50: 6e64 2c0a 2020 2020 2020 2020 2020 2020  nd,.            
-00015a60: 2020 2020 2020 2020 2020 2020 646f 633d              doc=
-00015a70: 274f 626a 6563 7469 7665 2066 756e 6374  'Objective funct
-00015a80: 696f 6e20 6578 7072 6573 7369 6f6e 2073  ion expression s
-00015a90: 686f 756c 6420 696d 7072 6f76 6520 6f6e  hould improve on
-00015aa0: 2074 6865 2062 6573 7420 666f 756e 6420   the best found 
-00015ab0: 6475 616c 2062 6f75 6e64 272c 0a20 2020  dual bound',.   
-00015ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015ad0: 2029 0a0a 2020 2020 6465 6620 7365 7475   )..    def setu
-00015ae0: 705f 6670 5f6d 6169 6e28 7365 6c66 293a  p_fp_main(self):
-00015af0: 0a20 2020 2020 2020 2022 2222 5365 7420  .        """Set 
-00015b00: 7570 206d 6169 6e20 7072 6f62 6c65 6d20  up main problem 
-00015b10: 666f 7220 4665 6173 6962 696c 6974 7920  for Feasibility 
-00015b20: 5075 6d70 206d 6574 686f 642e 2222 220a  Pump method.""".
-00015b30: 2020 2020 2020 2020 4d69 6e64 7450 7920          MindtPy 
-00015b40: 3d20 7365 6c66 2e6d 6970 2e4d 696e 6474  = self.mip.Mindt
-00015b50: 5079 5f75 7469 6c73 0a0a 2020 2020 2020  Py_utils..      
-00015b60: 2020 666f 7220 6320 696e 204d 696e 6474    for c in Mindt
-00015b70: 5079 2e63 6f6e 7374 7261 696e 745f 6c69  Py.constraint_li
-00015b80: 7374 3a0a 2020 2020 2020 2020 2020 2020  st:.            
-00015b90: 6966 2063 2e62 6f64 792e 706f 6c79 6e6f  if c.body.polyno
-00015ba0: 6d69 616c 5f64 6567 7265 6528 2920 6e6f  mial_degree() no
-00015bb0: 7420 696e 2073 656c 662e 6d69 705f 636f  t in self.mip_co
-00015bc0: 6e73 7472 6169 6e74 5f70 6f6c 796e 6f6d  nstraint_polynom
-00015bd0: 6961 6c5f 6465 6772 6565 3a0a 2020 2020  ial_degree:.    
-00015be0: 2020 2020 2020 2020 2020 2020 632e 6465              c.de
-00015bf0: 6163 7469 7661 7465 2829 0a0a 2020 2020  activate()..    
-00015c00: 2020 2020 4d69 6e64 7450 792e 6375 7473      MindtPy.cuts
-00015c10: 2e61 6374 6976 6174 6528 290a 2020 2020  .activate().    
-00015c20: 2020 2020 4d69 6e64 7450 792e 6465 6c5f      MindtPy.del_
-00015c30: 636f 6d70 6f6e 656e 7428 276d 6970 5f6f  component('mip_o
-00015c40: 626a 2729 0a20 2020 2020 2020 204d 696e  bj').        Min
-00015c50: 6474 5079 2e64 656c 5f63 6f6d 706f 6e65  dtPy.del_compone
-00015c60: 6e74 2827 6670 5f6d 6970 5f6f 626a 2729  nt('fp_mip_obj')
-00015c70: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00015c80: 2e63 6f6e 6669 672e 6670 5f6d 6169 6e5f  .config.fp_main_
-00015c90: 6e6f 726d 203d 3d20 274c 3127 3a0a 2020  norm == 'L1':.  
-00015ca0: 2020 2020 2020 2020 2020 4d69 6e64 7450            MindtP
-00015cb0: 792e 6670 5f6d 6970 5f6f 626a 203d 2067  y.fp_mip_obj = g
-00015cc0: 656e 6572 6174 655f 6e6f 726d 315f 6f62  enerate_norm1_ob
-00015cd0: 6a65 6374 6976 655f 6675 6e63 7469 6f6e  jective_function
-00015ce0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00015cf0: 2020 7365 6c66 2e6d 6970 2c20 7365 6c66    self.mip, self
-00015d00: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2c20  .working_model, 
-00015d10: 6469 7363 7265 7465 5f6f 6e6c 793d 7365  discrete_only=se
-00015d20: 6c66 2e63 6f6e 6669 672e 6670 5f64 6973  lf.config.fp_dis
-00015d30: 6372 6574 655f 6f6e 6c79 0a20 2020 2020  crete_only.     
-00015d40: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00015d50: 2065 6c69 6620 7365 6c66 2e63 6f6e 6669   elif self.confi
-00015d60: 672e 6670 5f6d 6169 6e5f 6e6f 726d 203d  g.fp_main_norm =
-00015d70: 3d20 274c 3227 3a0a 2020 2020 2020 2020  = 'L2':.        
-00015d80: 2020 2020 4d69 6e64 7450 792e 6670 5f6d      MindtPy.fp_m
-00015d90: 6970 5f6f 626a 203d 2067 656e 6572 6174  ip_obj = generat
-00015da0: 655f 6e6f 726d 3273 715f 6f62 6a65 6374  e_norm2sq_object
-00015db0: 6976 655f 6675 6e63 7469 6f6e 280a 2020  ive_function(.  
-00015dc0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00015dd0: 6c66 2e6d 6970 2c20 7365 6c66 2e77 6f72  lf.mip, self.wor
-00015de0: 6b69 6e67 5f6d 6f64 656c 2c20 6469 7363  king_model, disc
-00015df0: 7265 7465 5f6f 6e6c 793d 7365 6c66 2e63  rete_only=self.c
-00015e00: 6f6e 6669 672e 6670 5f64 6973 6372 6574  onfig.fp_discret
-00015e10: 655f 6f6e 6c79 0a20 2020 2020 2020 2020  e_only.         
-00015e20: 2020 2029 0a20 2020 2020 2020 2065 6c69     ).        eli
-00015e30: 6620 7365 6c66 2e63 6f6e 6669 672e 6670  f self.config.fp
-00015e40: 5f6d 6169 6e5f 6e6f 726d 203d 3d20 274c  _main_norm == 'L
-00015e50: 5f69 6e66 696e 6974 7927 3a0a 2020 2020  _infinity':.    
-00015e60: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
-00015e70: 6670 5f6d 6970 5f6f 626a 203d 2067 656e  fp_mip_obj = gen
-00015e80: 6572 6174 655f 6e6f 726d 5f69 6e66 5f6f  erate_norm_inf_o
-00015e90: 626a 6563 7469 7665 5f66 756e 6374 696f  bjective_functio
-00015ea0: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
-00015eb0: 2020 2073 656c 662e 6d69 702c 2073 656c     self.mip, sel
-00015ec0: 662e 776f 726b 696e 675f 6d6f 6465 6c2c  f.working_model,
-00015ed0: 2064 6973 6372 6574 655f 6f6e 6c79 3d73   discrete_only=s
-00015ee0: 656c 662e 636f 6e66 6967 2e66 705f 6469  elf.config.fp_di
-00015ef0: 7363 7265 7465 5f6f 6e6c 790a 2020 2020  screte_only.    
-00015f00: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
-00015f10: 6566 2073 6574 7570 5f72 6567 756c 6172  ef setup_regular
-00015f20: 697a 6174 696f 6e5f 6d61 696e 2873 656c  ization_main(sel
-00015f30: 6629 3a0a 2020 2020 2020 2020 2222 2253  f):.        """S
-00015f40: 6574 2075 7020 6d61 696e 2072 6567 756c  et up main regul
-00015f50: 6172 697a 6174 696f 6e20 7072 6f62 6c65  arization proble
-00015f60: 6d20 666f 7220 524f 4120 6d65 7468 6f64  m for ROA method
-00015f70: 2e22 2222 0a20 2020 2020 2020 2063 6f6e  .""".        con
-00015f80: 6669 6720 3d20 7365 6c66 2e63 6f6e 6669  fig = self.confi
-00015f90: 670a 2020 2020 2020 2020 4d69 6e64 7450  g.        MindtP
-00015fa0: 7920 3d20 7365 6c66 2e6d 6970 2e4d 696e  y = self.mip.Min
-00015fb0: 6474 5079 5f75 7469 6c73 0a0a 2020 2020  dtPy_utils..    
-00015fc0: 2020 2020 666f 7220 6320 696e 204d 696e      for c in Min
-00015fd0: 6474 5079 2e63 6f6e 7374 7261 696e 745f  dtPy.constraint_
-00015fe0: 6c69 7374 3a0a 2020 2020 2020 2020 2020  list:.          
-00015ff0: 2020 6966 2063 2e62 6f64 792e 706f 6c79    if c.body.poly
-00016000: 6e6f 6d69 616c 5f64 6567 7265 6528 2920  nomial_degree() 
-00016010: 6e6f 7420 696e 2073 656c 662e 6d69 705f  not in self.mip_
-00016020: 636f 6e73 7472 6169 6e74 5f70 6f6c 796e  constraint_polyn
-00016030: 6f6d 6961 6c5f 6465 6772 6565 3a0a 2020  omial_degree:.  
-00016040: 2020 2020 2020 2020 2020 2020 2020 632e                c.
-00016050: 6465 6163 7469 7661 7465 2829 0a0a 2020  deactivate()..  
-00016060: 2020 2020 2020 4d69 6e64 7450 792e 6375        MindtPy.cu
-00016070: 7473 2e61 6374 6976 6174 6528 290a 0a20  ts.activate().. 
-00016080: 2020 2020 2020 2073 6967 6e5f 6164 6a75         sign_adju
-00016090: 7374 203d 2031 2069 6620 7365 6c66 2e6f  st = 1 if self.o
-000160a0: 626a 6563 7469 7665 5f73 656e 7365 203d  bjective_sense =
-000160b0: 3d20 6d69 6e69 6d69 7a65 2065 6c73 6520  = minimize else 
-000160c0: 2d31 0a20 2020 2020 2020 204d 696e 6474  -1.        Mindt
-000160d0: 5079 2e64 656c 5f63 6f6d 706f 6e65 6e74  Py.del_component
-000160e0: 2827 6d69 705f 6f62 6a27 290a 2020 2020  ('mip_obj').    
-000160f0: 2020 2020 6966 2063 6f6e 6669 672e 7369      if config.si
-00016100: 6e67 6c65 5f74 7265 653a 0a20 2020 2020  ngle_tree:.     
-00016110: 2020 2020 2020 204d 696e 6474 5079 2e64         MindtPy.d
-00016120: 656c 5f63 6f6d 706f 6e65 6e74 2827 726f  el_component('ro
-00016130: 615f 7072 6f6a 5f6d 6970 5f6f 626a 2729  a_proj_mip_obj')
-00016140: 0a20 2020 2020 2020 2020 2020 204d 696e  .            Min
-00016150: 6474 5079 2e63 7574 732e 6465 6c5f 636f  dtPy.cuts.del_co
-00016160: 6d70 6f6e 656e 7428 276f 626a 5f72 6567  mponent('obj_reg
-00016170: 5f65 7374 696d 6174 6527 290a 2020 2020  _estimate').    
-00016180: 2020 2020 6966 2063 6f6e 6669 672e 6164      if config.ad
-00016190: 645f 7265 6775 6c61 7269 7a61 7469 6f6e  d_regularization
-000161a0: 2069 7320 6e6f 7420 4e6f 6e65 2061 6e64   is not None and
-000161b0: 2063 6f6e 6669 672e 6164 645f 6e6f 5f67   config.add_no_g
-000161c0: 6f6f 645f 6375 7473 3a0a 2020 2020 2020  ood_cuts:.      
-000161d0: 2020 2020 2020 4d69 6e64 7450 792e 6375        MindtPy.cu
-000161e0: 7473 2e6e 6f5f 676f 6f64 5f63 7574 732e  ts.no_good_cuts.
-000161f0: 6163 7469 7661 7465 2829 0a0a 2020 2020  activate()..    
-00016200: 2020 2020 2320 5468 6520 6570 6967 7261      # The epigra
-00016210: 7068 2063 6f6e 7374 7261 696e 7420 6973  ph constraint is
-00016220: 2076 6572 7920 2266 6c61 7422 2066 6f72   very "flat" for
-00016230: 2062 7261 6e63 6869 6e67 2072 756c 6573   branching rules
-00016240: 2e0a 2020 2020 2020 2020 2320 496e 2052  ..        # In R
-00016250: 4f41 2c20 6966 2074 6865 206f 626a 6563  OA, if the objec
-00016260: 7469 7665 2066 756e 6374 696f 6e20 6973  tive function is
-00016270: 206c 696e 6561 7228 6f72 2071 7561 6472   linear(or quadr
-00016280: 6174 6963 2077 6865 6e20 7175 6164 7261  atic when quadra
-00016290: 7469 635f 7374 7261 7465 6779 203d 2031  tic_strategy = 1
-000162a0: 206f 7220 3229 2c20 7468 6520 6f72 6967   or 2), the orig
-000162b0: 696e 616c 206f 626a 6563 7469 7665 2066  inal objective f
-000162c0: 756e 6374 696f 6e20 6973 2075 7365 6420  unction is used 
-000162d0: 696e 2074 6865 204d 4950 2070 726f 626c  in the MIP probl
-000162e0: 656d 2e0a 2020 2020 2020 2020 2320 496e  em..        # In
-000162f0: 2074 6865 204d 4950 2070 726f 6a65 6374   the MIP project
-00016300: 696f 6e20 7072 6f62 6c65 6d2c 2077 6520  ion problem, we 
-00016310: 6e65 6564 2074 6f20 7265 6163 7469 7661  need to reactiva
-00016320: 7465 2074 6865 2065 7069 6772 6170 6820  te the epigraph 
-00016330: 636f 6e73 7472 6169 6e74 286f 626a 6563  constraint(objec
-00016340: 7469 7665 5f63 6f6e 7374 7229 2e0a 2020  tive_constr)..  
-00016350: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
-00016360: 2020 2020 2020 204d 696e 6474 5079 2e6f         MindtPy.o
-00016370: 626a 6563 7469 7665 5f6c 6973 745b 305d  bjective_list[0]
-00016380: 2e65 7870 722e 706f 6c79 6e6f 6d69 616c  .expr.polynomial
-00016390: 5f64 6567 7265 6528 290a 2020 2020 2020  _degree().      
-000163a0: 2020 2020 2020 696e 2073 656c 662e 6d69        in self.mi
-000163b0: 705f 6f62 6a65 6374 6976 655f 706f 6c79  p_objective_poly
-000163c0: 6e6f 6d69 616c 5f64 6567 7265 650a 2020  nomial_degree.  
-000163d0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
-000163e0: 2020 2020 204d 696e 6474 5079 2e6f 626a       MindtPy.obj
-000163f0: 6563 7469 7665 5f63 6f6e 7374 722e 6163  ective_constr.ac
-00016400: 7469 7661 7465 2829 0a20 2020 2020 2020  tivate().       
-00016410: 2069 6620 636f 6e66 6967 2e61 6464 5f72   if config.add_r
-00016420: 6567 756c 6172 697a 6174 696f 6e20 3d3d  egularization ==
-00016430: 2027 6c65 7665 6c5f 4c31 273a 0a20 2020   'level_L1':.   
-00016440: 2020 2020 2020 2020 204d 696e 6474 5079           MindtPy
-00016450: 2e72 6f61 5f70 726f 6a5f 6d69 705f 6f62  .roa_proj_mip_ob
-00016460: 6a20 3d20 6765 6e65 7261 7465 5f6e 6f72  j = generate_nor
-00016470: 6d31 5f6f 626a 6563 7469 7665 5f66 756e  m1_objective_fun
-00016480: 6374 696f 6e28 0a20 2020 2020 2020 2020  ction(.         
-00016490: 2020 2020 2020 2073 656c 662e 6d69 702c         self.mip,
-000164a0: 2073 656c 662e 6265 7374 5f73 6f6c 7574   self.best_solut
-000164b0: 696f 6e5f 666f 756e 642c 2064 6973 6372  ion_found, discr
-000164c0: 6574 655f 6f6e 6c79 3d46 616c 7365 0a20  ete_only=False. 
-000164d0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-000164e0: 2020 2020 2065 6c69 6620 636f 6e66 6967       elif config
-000164f0: 2e61 6464 5f72 6567 756c 6172 697a 6174  .add_regularizat
-00016500: 696f 6e20 3d3d 2027 6c65 7665 6c5f 4c32  ion == 'level_L2
-00016510: 273a 0a20 2020 2020 2020 2020 2020 204d  ':.            M
-00016520: 696e 6474 5079 2e72 6f61 5f70 726f 6a5f  indtPy.roa_proj_
-00016530: 6d69 705f 6f62 6a20 3d20 6765 6e65 7261  mip_obj = genera
-00016540: 7465 5f6e 6f72 6d32 7371 5f6f 626a 6563  te_norm2sq_objec
-00016550: 7469 7665 5f66 756e 6374 696f 6e28 0a20  tive_function(. 
-00016560: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00016570: 656c 662e 6d69 702c 2073 656c 662e 6265  elf.mip, self.be
-00016580: 7374 5f73 6f6c 7574 696f 6e5f 666f 756e  st_solution_foun
-00016590: 642c 2064 6973 6372 6574 655f 6f6e 6c79  d, discrete_only
-000165a0: 3d46 616c 7365 0a20 2020 2020 2020 2020  =False.         
-000165b0: 2020 2029 0a20 2020 2020 2020 2065 6c69     ).        eli
-000165c0: 6620 636f 6e66 6967 2e61 6464 5f72 6567  f config.add_reg
-000165d0: 756c 6172 697a 6174 696f 6e20 3d3d 2027  ularization == '
-000165e0: 6c65 7665 6c5f 4c5f 696e 6669 6e69 7479  level_L_infinity
-000165f0: 273a 0a20 2020 2020 2020 2020 2020 204d  ':.            M
-00016600: 696e 6474 5079 2e72 6f61 5f70 726f 6a5f  indtPy.roa_proj_
-00016610: 6d69 705f 6f62 6a20 3d20 6765 6e65 7261  mip_obj = genera
-00016620: 7465 5f6e 6f72 6d5f 696e 665f 6f62 6a65  te_norm_inf_obje
-00016630: 6374 6976 655f 6675 6e63 7469 6f6e 280a  ctive_function(.
-00016640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016650: 7365 6c66 2e6d 6970 2c20 7365 6c66 2e62  self.mip, self.b
-00016660: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
-00016670: 6e64 2c20 6469 7363 7265 7465 5f6f 6e6c  nd, discrete_onl
-00016680: 793d 4661 6c73 650a 2020 2020 2020 2020  y=False.        
-00016690: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
-000166a0: 6966 2063 6f6e 6669 672e 6164 645f 7265  if config.add_re
-000166b0: 6775 6c61 7269 7a61 7469 6f6e 2069 6e20  gularization in 
-000166c0: 7b0a 2020 2020 2020 2020 2020 2020 2767  {.            'g
-000166d0: 7261 645f 6c61 6727 2c0a 2020 2020 2020  rad_lag',.      
-000166e0: 2020 2020 2020 2768 6573 735f 6c61 6727        'hess_lag'
-000166f0: 2c0a 2020 2020 2020 2020 2020 2020 2768  ,.            'h
-00016700: 6573 735f 6f6e 6c79 5f6c 6167 272c 0a20  ess_only_lag',. 
-00016710: 2020 2020 2020 2020 2020 2027 7371 705f             'sqp_
-00016720: 6c61 6727 2c0a 2020 2020 2020 2020 7d3a  lag',.        }:
-00016730: 0a20 2020 2020 2020 2020 2020 204d 696e  .            Min
-00016740: 6474 5079 2e72 6f61 5f70 726f 6a5f 6d69  dtPy.roa_proj_mi
-00016750: 705f 6f62 6a20 3d20 6765 6e65 7261 7465  p_obj = generate
-00016760: 5f6c 6167 5f6f 626a 6563 7469 7665 5f66  _lag_objective_f
-00016770: 756e 6374 696f 6e28 0a20 2020 2020 2020  unction(.       
-00016780: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-00016790: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-000167a0: 2020 2073 656c 662e 6265 7374 5f73 6f6c     self.best_sol
-000167b0: 7574 696f 6e5f 666f 756e 642c 0a20 2020  ution_found,.   
-000167c0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-000167d0: 6669 672c 0a20 2020 2020 2020 2020 2020  fig,.           
-000167e0: 2020 2020 2073 656c 662e 7469 6d69 6e67       self.timing
-000167f0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00016800: 2020 6469 7363 7265 7465 5f6f 6e6c 793d    discrete_only=
-00016810: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
-00016820: 2020 2029 0a20 2020 2020 2020 2069 6620     ).        if 
-00016830: 7365 6c66 2e6f 626a 6563 7469 7665 5f73  self.objective_s
-00016840: 656e 7365 203d 3d20 6d69 6e69 6d69 7a65  ense == minimize
-00016850: 3a0a 2020 2020 2020 2020 2020 2020 4d69  :.            Mi
-00016860: 6e64 7450 792e 6375 7473 2e6f 626a 5f72  ndtPy.cuts.obj_r
-00016870: 6567 5f65 7374 696d 6174 6520 3d20 436f  eg_estimate = Co
-00016880: 6e73 7472 6169 6e74 280a 2020 2020 2020  nstraint(.      
-00016890: 2020 2020 2020 2020 2020 6578 7072 3d73            expr=s
-000168a0: 756d 284d 696e 6474 5079 2e6f 626a 6563  um(MindtPy.objec
-000168b0: 7469 7665 5f76 616c 7565 5b3a 5d29 0a20  tive_value[:]). 
-000168c0: 2020 2020 2020 2020 2020 2020 2020 203c                 <
-000168d0: 3d20 2831 202d 2063 6f6e 6669 672e 6c65  = (1 - config.le
-000168e0: 7665 6c5f 636f 6566 2920 2a20 7365 6c66  vel_coef) * self
-000168f0: 2e70 7269 6d61 6c5f 626f 756e 640a 2020  .primal_bound.  
-00016900: 2020 2020 2020 2020 2020 2020 2020 2b20                + 
-00016910: 636f 6e66 6967 2e6c 6576 656c 5f63 6f65  config.level_coe
-00016920: 6620 2a20 7365 6c66 2e64 7561 6c5f 626f  f * self.dual_bo
-00016930: 756e 640a 2020 2020 2020 2020 2020 2020  und.            
-00016940: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-00016950: 2020 2020 2020 2020 2020 2020 4d69 6e64              Mind
-00016960: 7450 792e 6375 7473 2e6f 626a 5f72 6567  tPy.cuts.obj_reg
-00016970: 5f65 7374 696d 6174 6520 3d20 436f 6e73  _estimate = Cons
-00016980: 7472 6169 6e74 280a 2020 2020 2020 2020  traint(.        
-00016990: 2020 2020 2020 2020 6578 7072 3d73 756d          expr=sum
-000169a0: 284d 696e 6474 5079 2e6f 626a 6563 7469  (MindtPy.objecti
-000169b0: 7665 5f76 616c 7565 5b3a 5d29 0a20 2020  ve_value[:]).   
-000169c0: 2020 2020 2020 2020 2020 2020 203e 3d20               >= 
-000169d0: 2831 202d 2063 6f6e 6669 672e 6c65 7665  (1 - config.leve
-000169e0: 6c5f 636f 6566 2920 2a20 7365 6c66 2e70  l_coef) * self.p
-000169f0: 7269 6d61 6c5f 626f 756e 640a 2020 2020  rimal_bound.    
-00016a00: 2020 2020 2020 2020 2020 2020 2b20 636f              + co
-00016a10: 6e66 6967 2e6c 6576 656c 5f63 6f65 6620  nfig.level_coef 
-00016a20: 2a20 7365 6c66 2e64 7561 6c5f 626f 756e  * self.dual_boun
-00016a30: 640a 2020 2020 2020 2020 2020 2020 290a  d.            ).
-00016a40: 0a20 2020 2064 6566 2075 7064 6174 655f  .    def update_
-00016a50: 7265 7375 6c74 2873 656c 6629 3a0a 2020  result(self):.  
-00016a60: 2020 2020 2020 6966 2073 656c 662e 6f62        if self.ob
-00016a70: 6a65 6374 6976 655f 7365 6e73 6520 3d3d  jective_sense ==
-00016a80: 206d 696e 696d 697a 653a 0a20 2020 2020   minimize:.     
-00016a90: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
-00016aa0: 6c74 732e 7072 6f62 6c65 6d2e 6c6f 7765  lts.problem.lowe
-00016ab0: 725f 626f 756e 6420 3d20 7365 6c66 2e64  r_bound = self.d
-00016ac0: 7561 6c5f 626f 756e 640a 2020 2020 2020  ual_bound.      
-00016ad0: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
-00016ae0: 7473 2e70 726f 626c 656d 2e75 7070 6572  ts.problem.upper
-00016af0: 5f62 6f75 6e64 203d 2073 656c 662e 7072  _bound = self.pr
-00016b00: 696d 616c 5f62 6f75 6e64 0a20 2020 2020  imal_bound.     
-00016b10: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00016b20: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
-00016b30: 732e 7072 6f62 6c65 6d2e 6c6f 7765 725f  s.problem.lower_
-00016b40: 626f 756e 6420 3d20 7365 6c66 2e70 7269  bound = self.pri
-00016b50: 6d61 6c5f 626f 756e 640a 2020 2020 2020  mal_bound.      
-00016b60: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
-00016b70: 7473 2e70 726f 626c 656d 2e75 7070 6572  ts.problem.upper
-00016b80: 5f62 6f75 6e64 203d 2073 656c 662e 6475  _bound = self.du
-00016b90: 616c 5f62 6f75 6e64 0a0a 2020 2020 2020  al_bound..      
-00016ba0: 2020 7365 6c66 2e72 6573 756c 7473 2e73    self.results.s
-00016bb0: 6f6c 7665 722e 7469 6d69 6e67 203d 2073  olver.timing = s
-00016bc0: 656c 662e 7469 6d69 6e67 0a20 2020 2020  elf.timing.     
-00016bd0: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
-00016be0: 736f 6c76 6572 2e75 7365 725f 7469 6d65  solver.user_time
-00016bf0: 203d 2073 656c 662e 7469 6d69 6e67 2e74   = self.timing.t
-00016c00: 6f74 616c 0a20 2020 2020 2020 2073 656c  otal.        sel
-00016c10: 662e 7265 7375 6c74 732e 736f 6c76 6572  f.results.solver
-00016c20: 2e77 616c 6c63 6c6f 636b 5f74 696d 6520  .wallclock_time 
-00016c30: 3d20 7365 6c66 2e74 696d 696e 672e 746f  = self.timing.to
-00016c40: 7461 6c0a 2020 2020 2020 2020 7365 6c66  tal.        self
-00016c50: 2e72 6573 756c 7473 2e73 6f6c 7665 722e  .results.solver.
-00016c60: 6974 6572 6174 696f 6e73 203d 2073 656c  iterations = sel
-00016c70: 662e 6d69 705f 6974 6572 0a20 2020 2020  f.mip_iter.     
-00016c80: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
-00016c90: 736f 6c76 6572 2e6e 756d 5f69 6e66 6561  solver.num_infea
-00016ca0: 7369 626c 655f 6e6c 705f 7375 6270 726f  sible_nlp_subpro
-00016cb0: 626c 656d 203d 2073 656c 662e 6e6c 705f  blem = self.nlp_
-00016cc0: 696e 6665 6173 6962 6c65 5f63 6f75 6e74  infeasible_count
-00016cd0: 6572 0a20 2020 2020 2020 2073 656c 662e  er.        self.
-00016ce0: 7265 7375 6c74 732e 736f 6c76 6572 2e62  results.solver.b
-00016cf0: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
-00016d00: 6e64 5f74 696d 6520 3d20 7365 6c66 2e62  nd_time = self.b
-00016d10: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
-00016d20: 6e64 5f74 696d 650a 2020 2020 2020 2020  nd_time.        
-00016d30: 7365 6c66 2e72 6573 756c 7473 2e73 6f6c  self.results.sol
-00016d40: 7665 722e 7072 696d 616c 5f69 6e74 6567  ver.primal_integ
-00016d50: 7261 6c20 3d20 7365 6c66 2e70 7269 6d61  ral = self.prima
-00016d60: 6c5f 696e 7465 6772 616c 0a20 2020 2020  l_integral.     
-00016d70: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
-00016d80: 736f 6c76 6572 2e64 7561 6c5f 696e 7465  solver.dual_inte
-00016d90: 6772 616c 203d 2073 656c 662e 6475 616c  gral = self.dual
-00016da0: 5f69 6e74 6567 7261 6c0a 2020 2020 2020  _integral.      
-00016db0: 2020 7365 6c66 2e72 6573 756c 7473 2e73    self.results.s
-00016dc0: 6f6c 7665 722e 7072 696d 616c 5f64 7561  olver.primal_dua
-00016dd0: 6c5f 6761 705f 696e 7465 6772 616c 203d  l_gap_integral =
-00016de0: 2073 656c 662e 7072 696d 616c 5f64 7561   self.primal_dua
-00016df0: 6c5f 6761 705f 696e 7465 6772 616c 0a0a  l_gap_integral..
-00016e00: 2020 2020 6465 6620 6c6f 6164 5f73 6f6c      def load_sol
-00016e10: 7574 696f 6e28 7365 6c66 293a 0a20 2020  ution(self):.   
-00016e20: 2020 2020 2023 2055 7064 6174 6520 7661       # Update va
-00016e30: 6c75 6573 2069 6e20 6f72 6967 696e 616c  lues in original
-00016e40: 206d 6f64 656c 0a20 2020 2020 2020 2063   model.        c
-00016e50: 6f6e 6669 6720 3d20 7365 6c66 2e63 6f6e  onfig = self.con
-00016e60: 6669 670a 2020 2020 2020 2020 4d69 6e64  fig.        Mind
-00016e70: 7450 7920 3d20 7365 6c66 2e77 6f72 6b69  tPy = self.worki
-00016e80: 6e67 5f6d 6f64 656c 2e4d 696e 6474 5079  ng_model.MindtPy
-00016e90: 5f75 7469 6c73 0a20 2020 2020 2020 2063  _utils.        c
-00016ea0: 6f70 795f 7661 725f 6c69 7374 5f76 616c  opy_var_list_val
-00016eb0: 7565 7328 0a20 2020 2020 2020 2020 2020  ues(.           
-00016ec0: 2066 726f 6d5f 6c69 7374 3d73 656c 662e   from_list=self.
-00016ed0: 6265 7374 5f73 6f6c 7574 696f 6e5f 666f  best_solution_fo
-00016ee0: 756e 642e 4d69 6e64 7450 795f 7574 696c  und.MindtPy_util
-00016ef0: 732e 7661 7269 6162 6c65 5f6c 6973 742c  s.variable_list,
-00016f00: 0a20 2020 2020 2020 2020 2020 2074 6f5f  .            to_
-00016f10: 6c69 7374 3d4d 696e 6474 5079 2e76 6172  list=MindtPy.var
-00016f20: 6961 626c 655f 6c69 7374 2c0a 2020 2020  iable_list,.    
-00016f30: 2020 2020 2020 2020 636f 6e66 6967 3d63          config=c
-00016f40: 6f6e 6669 672c 0a20 2020 2020 2020 2029  onfig,.        )
-00016f50: 0a20 2020 2020 2020 2023 2054 6865 206f  .        # The o
-00016f60: 7269 6769 6e61 6c20 646f 6573 206e 6f74  riginal does not
-00016f70: 2068 6176 6520 7661 7269 6162 6c65 206c   have variable l
-00016f80: 6973 742e 0a20 2020 2020 2020 2023 2055  ist..        # U
-00016f90: 7365 2067 6574 5f76 6172 735f 6672 6f6d  se get_vars_from
-00016fa0: 5f63 6f6d 706f 6e65 6e74 7328 2920 7368  _components() sh
-00016fb0: 6f75 6c64 2062 6520 7573 6564 2066 6f72  ould be used for
-00016fc0: 2062 6f74 6820 776f 726b 696e 675f 6d6f   both working_mo
-00016fd0: 6465 6c20 616e 6420 6f72 6967 696e 616c  del and original
-00016fe0: 5f6d 6f64 656c 2074 6f20 6578 636c 7564  _model to exclud
-00016ff0: 6520 7468 6520 756e 7573 6564 2076 6172  e the unused var
-00017000: 6961 626c 6573 2e0a 2020 2020 2020 2020  iables..        
-00017010: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
-00017020: 656c 2e4d 696e 6474 5079 5f75 7469 6c73  el.MindtPy_utils
-00017030: 2e64 6561 6374 6976 6174 6528 290a 2020  .deactivate().  
-00017040: 2020 2020 2020 2320 5468 6520 6f72 6967        # The orig
-00017050: 696e 616c 206f 626a 6563 7469 7665 2073  inal objective s
-00017060: 686f 756c 6420 6265 2061 6374 6976 6174  hould be activat
-00017070: 6564 2074 6f20 6d61 6b65 2073 7572 6520  ed to make sure 
-00017080: 7468 6520 7661 7269 6162 6c65 206c 6973  the variable lis
-00017090: 7420 6973 2069 6e20 7468 6520 7361 6d65  t is in the same
-000170a0: 206f 7264 6572 2028 6765 745f 7661 7273   order (get_vars
-000170b0: 5f66 726f 6d5f 636f 6d70 6f6e 656e 7473  _from_components
-000170c0: 292e 0a20 2020 2020 2020 2073 656c 662e  )..        self.
-000170d0: 776f 726b 696e 675f 6d6f 6465 6c2e 4d69  working_model.Mi
-000170e0: 6e64 7450 795f 7574 696c 732e 6f62 6a65  ndtPy_utils.obje
-000170f0: 6374 6976 655f 6c69 7374 5b30 5d2e 6163  ctive_list[0].ac
-00017100: 7469 7661 7465 2829 0a20 2020 2020 2020  tivate().       
-00017110: 2069 6620 7365 6c66 2e77 6f72 6b69 6e67   if self.working
-00017120: 5f6d 6f64 656c 2e63 6f6d 706f 6e65 6e74  _model.component
-00017130: 2822 5f69 6e74 5f74 6f5f 6269 6e61 7279  ("_int_to_binary
-00017140: 5f72 6566 6f72 6d22 2920 6973 206e 6f74  _reform") is not
-00017150: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-00017160: 2020 2073 656c 662e 776f 726b 696e 675f     self.working_
-00017170: 6d6f 6465 6c2e 5f69 6e74 5f74 6f5f 6269  model._int_to_bi
-00017180: 6e61 7279 5f72 6566 6f72 6d2e 6465 6163  nary_reform.deac
-00017190: 7469 7661 7465 2829 0a20 2020 2020 2020  tivate().       
-000171a0: 2023 2065 7863 6c75 6465 2066 6978 6564   # exclude fixed
-000171b0: 2076 6172 6961 626c 6573 2068 6572 652e   variables here.
-000171c0: 2054 6869 7320 6973 2063 6f6e 7369 7374   This is consist
-000171d0: 656e 7420 7769 7468 2074 6865 2064 6566  ent with the def
-000171e0: 696e 6974 696f 6e20 6f66 2076 6172 6961  inition of varia
-000171f0: 626c 655f 6c69 7374 2e0a 2020 2020 2020  ble_list..      
-00017200: 2020 776f 726b 696e 675f 6d6f 6465 6c5f    working_model_
-00017210: 7661 7269 6162 6c65 5f6c 6973 7420 3d20  variable_list = 
-00017220: 6c69 7374 280a 2020 2020 2020 2020 2020  list(.          
-00017230: 2020 6765 745f 7661 7273 5f66 726f 6d5f    get_vars_from_
-00017240: 636f 6d70 6f6e 656e 7473 280a 2020 2020  components(.    
-00017250: 2020 2020 2020 2020 2020 2020 626c 6f63              bloc
-00017260: 6b3d 7365 6c66 2e77 6f72 6b69 6e67 5f6d  k=self.working_m
-00017270: 6f64 656c 2c0a 2020 2020 2020 2020 2020  odel,.          
-00017280: 2020 2020 2020 6374 7970 653d 2843 6f6e        ctype=(Con
-00017290: 7374 7261 696e 742c 204f 626a 6563 7469  straint, Objecti
-000172a0: 7665 292c 0a20 2020 2020 2020 2020 2020  ve),.           
-000172b0: 2020 2020 2069 6e63 6c75 6465 5f66 6978       include_fix
-000172c0: 6564 3d46 616c 7365 2c0a 2020 2020 2020  ed=False,.      
-000172d0: 2020 2020 2020 2020 2020 6163 7469 7665            active
-000172e0: 3d54 7275 652c 0a20 2020 2020 2020 2020  =True,.         
-000172f0: 2020 2020 2020 2073 6f72 743d 5472 7565         sort=True
-00017300: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00017310: 2020 6465 7363 656e 645f 696e 746f 3d54    descend_into=T
-00017320: 7275 652c 0a20 2020 2020 2020 2020 2020  rue,.           
-00017330: 2020 2020 2064 6573 6365 6e74 5f6f 7264       descent_ord
-00017340: 6572 3d4e 6f6e 652c 0a20 2020 2020 2020  er=None,.       
-00017350: 2020 2020 2029 0a20 2020 2020 2020 2029       ).        )
-00017360: 0a20 2020 2020 2020 206f 7269 6769 6e61  .        origina
-00017370: 6c5f 6d6f 6465 6c5f 7661 7269 6162 6c65  l_model_variable
-00017380: 5f6c 6973 7420 3d20 6c69 7374 280a 2020  _list = list(.  
-00017390: 2020 2020 2020 2020 2020 6765 745f 7661            get_va
-000173a0: 7273 5f66 726f 6d5f 636f 6d70 6f6e 656e  rs_from_componen
-000173b0: 7473 280a 2020 2020 2020 2020 2020 2020  ts(.            
-000173c0: 2020 2020 626c 6f63 6b3d 7365 6c66 2e6f      block=self.o
-000173d0: 7269 6769 6e61 6c5f 6d6f 6465 6c2c 0a20  riginal_model,. 
-000173e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-000173f0: 7479 7065 3d28 436f 6e73 7472 6169 6e74  type=(Constraint
-00017400: 2c20 4f62 6a65 6374 6976 6529 2c0a 2020  , Objective),.  
-00017410: 2020 2020 2020 2020 2020 2020 2020 696e                in
-00017420: 636c 7564 655f 6669 7865 643d 4661 6c73  clude_fixed=Fals
-00017430: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
-00017440: 2020 2061 6374 6976 653d 5472 7565 2c0a     active=True,.
-00017450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017460: 736f 7274 3d54 7275 652c 0a20 2020 2020  sort=True,.     
-00017470: 2020 2020 2020 2020 2020 2064 6573 6365             desce
-00017480: 6e64 5f69 6e74 6f3d 5472 7565 2c0a 2020  nd_into=True,.  
-00017490: 2020 2020 2020 2020 2020 2020 2020 6465                de
-000174a0: 7363 656e 745f 6f72 6465 723d 4e6f 6e65  scent_order=None
-000174b0: 2c0a 2020 2020 2020 2020 2020 2020 290a  ,.            ).
-000174c0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000174d0: 2020 666f 7220 765f 6672 6f6d 2c20 765f    for v_from, v_
-000174e0: 746f 2069 6e20 7a69 7028 0a20 2020 2020  to in zip(.     
-000174f0: 2020 2020 2020 2077 6f72 6b69 6e67 5f6d         working_m
-00017500: 6f64 656c 5f76 6172 6961 626c 655f 6c69  odel_variable_li
-00017510: 7374 2c20 6f72 6967 696e 616c 5f6d 6f64  st, original_mod
-00017520: 656c 5f76 6172 6961 626c 655f 6c69 7374  el_variable_list
-00017530: 0a20 2020 2020 2020 2029 3a0a 2020 2020  .        ):.    
-00017540: 2020 2020 2020 2020 6966 2076 5f66 726f          if v_fro
-00017550: 6d2e 6e61 6d65 2021 3d20 765f 746f 2e6e  m.name != v_to.n
-00017560: 616d 653a 0a20 2020 2020 2020 2020 2020  ame:.           
-00017570: 2020 2020 2072 6169 7365 2044 6576 656c       raise Devel
-00017580: 6f70 6572 4572 726f 7228 0a20 2020 2020  operError(.     
-00017590: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-000175a0: 5468 6520 6e61 6d65 206f 6620 7468 6520  The name of the 
-000175b0: 7477 6f20 7661 7269 6162 6c65 7320 6973  two variables is
-000175c0: 206e 6f74 2074 6865 2073 616d 652e 204c   not the same. L
-000175d0: 6f61 6469 6e67 2066 696e 616c 2073 6f6c  oading final sol
-000175e0: 7574 696f 6e27 0a20 2020 2020 2020 2020  ution'.         
-000175f0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-00017600: 2063 6f70 795f 7661 725f 6c69 7374 5f76   copy_var_list_v
-00017610: 616c 7565 7328 0a20 2020 2020 2020 2020  alues(.         
-00017620: 2020 2077 6f72 6b69 6e67 5f6d 6f64 656c     working_model
-00017630: 5f76 6172 6961 626c 655f 6c69 7374 2c20  _variable_list, 
-00017640: 6f72 6967 696e 616c 5f6d 6f64 656c 5f76  original_model_v
-00017650: 6172 6961 626c 655f 6c69 7374 2c20 636f  ariable_list, co
-00017660: 6e66 6967 3d63 6f6e 6669 670a 2020 2020  nfig=config.    
-00017670: 2020 2020 290a 0a20 2020 2064 6566 2063      )..    def c
-00017680: 6865 636b 5f73 7562 736f 6c76 6572 5f76  heck_subsolver_v
-00017690: 616c 6964 6974 7928 7365 6c66 293a 0a20  alidity(self):. 
-000176a0: 2020 2020 2020 2022 2222 4368 6563 6b20         """Check 
-000176b0: 6966 2074 6865 2073 7562 736f 6c76 6572  if the subsolver
-000176c0: 7320 6172 6520 6176 6169 6c61 626c 6520  s are available 
-000176d0: 616e 6420 6c69 6365 6e73 6564 2e22 2222  and licensed."""
-000176e0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-000176f0: 7365 6c66 2e6d 6970 5f6f 7074 2e61 7661  self.mip_opt.ava
-00017700: 696c 6162 6c65 2829 3a0a 2020 2020 2020  ilable():.      
-00017710: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00017720: 6545 7272 6f72 2873 656c 662e 636f 6e66  eError(self.conf
-00017730: 6967 2e6d 6970 5f73 6f6c 7665 7220 2b20  ig.mip_solver + 
-00017740: 2720 6973 206e 6f74 2061 7661 696c 6162  ' is not availab
-00017750: 6c65 2e27 290a 2020 2020 2020 2020 6966  le.').        if
-00017760: 206e 6f74 2073 656c 662e 6d69 705f 6f70   not self.mip_op
-00017770: 742e 6c69 6365 6e73 655f 6973 5f76 616c  t.license_is_val
-00017780: 6964 2829 3a0a 2020 2020 2020 2020 2020  id():.          
-00017790: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-000177a0: 6f72 2873 656c 662e 636f 6e66 6967 2e6d  or(self.config.m
-000177b0: 6970 5f73 6f6c 7665 7220 2b20 2720 6973  ip_solver + ' is
-000177c0: 206e 6f74 206c 6963 656e 7365 642e 2729   not licensed.')
-000177d0: 0a20 2020 2020 2020 2069 6620 6e6f 7420  .        if not 
-000177e0: 7365 6c66 2e6e 6c70 5f6f 7074 2e61 7661  self.nlp_opt.ava
-000177f0: 696c 6162 6c65 2829 3a0a 2020 2020 2020  ilable():.      
-00017800: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
-00017810: 6545 7272 6f72 2873 656c 662e 636f 6e66  eError(self.conf
-00017820: 6967 2e6e 6c70 5f73 6f6c 7665 7220 2b20  ig.nlp_solver + 
-00017830: 2720 6973 206e 6f74 2061 7661 696c 6162  ' is not availab
-00017840: 6c65 2e27 290a 2020 2020 2020 2020 6966  le.').        if
-00017850: 206e 6f74 2073 656c 662e 6e6c 705f 6f70   not self.nlp_op
-00017860: 742e 6c69 6365 6e73 655f 6973 5f76 616c  t.license_is_val
-00017870: 6964 2829 3a0a 2020 2020 2020 2020 2020  id():.          
-00017880: 2020 7261 6973 6520 5661 6c75 6545 7272    raise ValueErr
-00017890: 6f72 2873 656c 662e 636f 6e66 6967 2e6e  or(self.config.n
-000178a0: 6c70 5f73 6f6c 7665 7220 2b20 2720 6973  lp_solver + ' is
-000178b0: 206e 6f74 206c 6963 656e 7365 642e 2729   not licensed.')
-000178c0: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-000178d0: 2e63 6f6e 6669 672e 6164 645f 7265 6775  .config.add_regu
-000178e0: 6c61 7269 7a61 7469 6f6e 2069 7320 6e6f  larization is no
-000178f0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-00017900: 2020 2020 6966 206e 6f74 2073 656c 662e      if not self.
-00017910: 7265 6775 6c61 7269 7a61 7469 6f6e 5f6d  regularization_m
-00017920: 6970 5f6f 7074 2e61 7661 696c 6162 6c65  ip_opt.available
-00017930: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-00017940: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-00017950: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
-00017960: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-00017970: 6f6e 6669 672e 6d69 705f 7265 6775 6c61  onfig.mip_regula
-00017980: 7269 7a61 7469 6f6e 5f73 6f6c 7665 7220  rization_solver 
-00017990: 2b20 2720 6973 206e 6f74 2061 7661 696c  + ' is not avail
-000179a0: 6162 6c65 2e27 0a20 2020 2020 2020 2020  able.'.         
-000179b0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-000179c0: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
-000179d0: 2e72 6567 756c 6172 697a 6174 696f 6e5f  .regularization_
-000179e0: 6d69 705f 6f70 742e 6c69 6365 6e73 655f  mip_opt.license_
-000179f0: 6973 5f76 616c 6964 2829 3a0a 2020 2020  is_valid():.    
-00017a00: 2020 2020 2020 2020 2020 2020 7261 6973              rais
-00017a10: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
-00017a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017a30: 2020 7365 6c66 2e63 6f6e 6669 672e 6d69    self.config.mi
-00017a40: 705f 7265 6775 6c61 7269 7a61 7469 6f6e  p_regularization
-00017a50: 5f73 6f6c 7665 7220 2b20 2720 6973 206e  _solver + ' is n
-00017a60: 6f74 206c 6963 656e 7365 642e 270a 2020  ot licensed.'.  
-00017a70: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-00017a80: 0a20 2020 2064 6566 2063 6865 636b 5f63  .    def check_c
-00017a90: 6f6e 6669 6728 7365 6c66 293a 0a20 2020  onfig(self):.   
-00017aa0: 2020 2020 2022 2222 4368 6563 6b73 2069       """Checks i
-00017ab0: 6620 7468 6520 636f 6e66 6967 7572 6174  f the configurat
-00017ac0: 696f 6e20 6f70 7469 6f6e 7320 6d61 6b65  ion options make
-00017ad0: 2073 656e 7365 2e22 2222 0a20 2020 2020   sense.""".     
-00017ae0: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
-00017af0: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
-00017b00: 2320 636f 6e66 6967 7572 6174 696f 6e20  # configuration 
-00017b10: 636f 6e66 6972 6d61 7469 6f6e 0a20 2020  confirmation.   
-00017b20: 2020 2020 2069 6620 636f 6e66 6967 2e69       if config.i
-00017b30: 6e69 745f 7374 7261 7465 6779 203d 3d20  nit_strategy == 
-00017b40: 2746 5027 3a0a 2020 2020 2020 2020 2020  'FP':.          
-00017b50: 2020 636f 6e66 6967 2e61 6464 5f6e 6f5f    config.add_no_
-00017b60: 676f 6f64 5f63 7574 7320 3d20 5472 7565  good_cuts = True
-00017b70: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
-00017b80: 6669 672e 7573 655f 7461 6275 5f6c 6973  fig.use_tabu_lis
-00017b90: 7420 3d20 4661 6c73 650a 0a20 2020 2020  t = False..     
-00017ba0: 2020 2069 6620 636f 6e66 6967 2e6e 6c70     if config.nlp
-00017bb0: 5f73 6f6c 7665 7220 3d3d 2027 6261 726f  _solver == 'baro
-00017bc0: 6e27 3a0a 2020 2020 2020 2020 2020 2020  n':.            
-00017bd0: 636f 6e66 6967 2e65 7175 616c 6974 795f  config.equality_
-00017be0: 7265 6c61 7861 7469 6f6e 203d 2046 616c  relaxation = Fal
-00017bf0: 7365 0a20 2020 2020 2020 2069 6620 636f  se.        if co
-00017c00: 6e66 6967 2e6e 6c70 5f73 6f6c 7665 7220  nfig.nlp_solver 
-00017c10: 3d3d 2027 6761 6d73 2720 616e 6420 636f  == 'gams' and co
-00017c20: 6e66 6967 2e6e 6c70 5f73 6f6c 7665 722e  nfig.nlp_solver.
-00017c30: 5f5f 636f 6e74 6169 6e73 5f5f 2827 736f  __contains__('so
-00017c40: 6c76 6572 2729 3a0a 2020 2020 2020 2020  lver'):.        
-00017c50: 2020 2020 6966 2063 6f6e 6669 672e 6e6c      if config.nl
-00017c60: 705f 736f 6c76 6572 5f61 7267 735b 2773  p_solver_args['s
-00017c70: 6f6c 7665 7227 5d20 3d3d 2027 6261 726f  olver'] == 'baro
-00017c80: 6e27 3a0a 2020 2020 2020 2020 2020 2020  n':.            
-00017c90: 2020 2020 636f 6e66 6967 2e65 7175 616c      config.equal
-00017ca0: 6974 795f 7265 6c61 7861 7469 6f6e 203d  ity_relaxation =
-00017cb0: 2046 616c 7365 0a0a 2020 2020 2020 2020   False..        
-00017cc0: 6966 2063 6f6e 6669 672e 736f 6c76 6572  if config.solver
-00017cd0: 5f74 6565 3a0a 2020 2020 2020 2020 2020  _tee:.          
-00017ce0: 2020 636f 6e66 6967 2e6d 6970 5f73 6f6c    config.mip_sol
-00017cf0: 7665 725f 7465 6520 3d20 5472 7565 0a20  ver_tee = True. 
-00017d00: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
-00017d10: 672e 6e6c 705f 736f 6c76 6572 5f74 6565  g.nlp_solver_tee
-00017d20: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-00017d30: 6966 2063 6f6e 6669 672e 6164 645f 6e6f  if config.add_no
-00017d40: 5f67 6f6f 645f 6375 7473 3a0a 2020 2020  _good_cuts:.    
-00017d50: 2020 2020 2020 2020 636f 6e66 6967 2e69          config.i
-00017d60: 6e74 6567 6572 5f74 6f5f 6269 6e61 7279  nteger_to_binary
-00017d70: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-00017d80: 6966 2063 6f6e 6669 672e 7573 655f 7461  if config.use_ta
-00017d90: 6275 5f6c 6973 743a 0a20 2020 2020 2020  bu_list:.       
-00017da0: 2020 2020 2063 6f6e 6669 672e 6d69 705f       config.mip_
-00017db0: 736f 6c76 6572 203d 2027 6370 6c65 785f  solver = 'cplex_
-00017dc0: 7065 7273 6973 7465 6e74 270a 2020 2020  persistent'.    
-00017dd0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-00017de0: 672e 7468 7265 6164 7320 3e20 313a 0a20  g.threads > 1:. 
-00017df0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-00017e00: 6f6e 6669 672e 7468 7265 6164 7320 3d20  onfig.threads = 
-00017e10: 310a 2020 2020 2020 2020 2020 2020 2020  1.              
-00017e20: 2020 636f 6e66 6967 2e6c 6f67 6765 722e    config.logger.
-00017e30: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-00017e40: 2020 2020 2020 2020 2020 2754 6865 2074            'The t
-00017e50: 6872 6561 6473 2070 6172 616d 6574 6572  hreads parameter
-00017e60: 2069 7320 636f 7272 6563 7465 6420 746f   is corrected to
-00017e70: 2031 2073 696e 6365 2069 6e63 756d 6265   1 since incumbe
-00017e80: 6e74 2063 616c 6c62 6163 6b20 636f 6e66  nt callback conf
-00017e90: 6c69 6374 7320 7769 7468 206d 756c 7469  licts with multi
-00017ea0: 2d74 6872 6561 6473 206d 6f64 652e 270a  -threads mode.'.
-00017eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017ec0: 290a 2020 2020 2020 2020 6966 2063 6f6e  ).        if con
-00017ed0: 6669 672e 736f 6c75 7469 6f6e 5f70 6f6f  fig.solution_poo
-00017ee0: 6c3a 0a20 2020 2020 2020 2020 2020 2069  l:.            i
-00017ef0: 6620 636f 6e66 6967 2e6d 6970 5f73 6f6c  f config.mip_sol
-00017f00: 7665 7220 6e6f 7420 696e 207b 2763 706c  ver not in {'cpl
-00017f10: 6578 5f70 6572 7369 7374 656e 7427 2c20  ex_persistent', 
-00017f20: 2767 7572 6f62 695f 7065 7273 6973 7465  'gurobi_persiste
-00017f30: 6e74 277d 3a0a 2020 2020 2020 2020 2020  nt'}:.          
-00017f40: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
-00017f50: 6d69 705f 736f 6c76 6572 2069 6e20 7b27  mip_solver in {'
-00017f60: 6170 7073 695f 6370 6c65 7827 2c20 2761  appsi_cplex', 'a
-00017f70: 7070 7369 5f67 7572 6f62 6927 7d3a 0a20  ppsi_gurobi'}:. 
-00017f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00017f90: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
-00017fa0: 2e69 6e66 6f28 2253 6f6c 7574 696f 6e20  .info("Solution 
-00017fb0: 706f 6f6c 2064 6f65 7320 6e6f 7420 7375  pool does not su
-00017fc0: 7070 6f72 7420 4150 5053 4920 736f 6c76  pport APPSI solv
-00017fd0: 6572 2e22 290a 2020 2020 2020 2020 2020  er.").          
-00017fe0: 2020 2020 2020 636f 6e66 6967 2e6d 6970        config.mip
-00017ff0: 5f73 6f6c 7665 7220 3d20 2763 706c 6578  _solver = 'cplex
-00018000: 5f70 6572 7369 7374 656e 7427 0a0a 2020  _persistent'..  
-00018010: 2020 2020 2020 2320 7265 6c61 7465 6420        # related 
-00018020: 746f 2068 7474 7073 3a2f 2f67 6974 6875  to https://githu
-00018030: 622e 636f 6d2f 5079 6f6d 6f2f 7079 6f6d  b.com/Pyomo/pyom
-00018040: 6f2f 6973 7375 6573 2f32 3336 330a 2020  o/issues/2363.  
-00018050: 2020 2020 2020 6966 2028 0a20 2020 2020        if (.     
-00018060: 2020 2020 2020 2027 6170 7073 6927 2069         'appsi' i
-00018070: 6e20 636f 6e66 6967 2e6d 6970 5f73 6f6c  n config.mip_sol
-00018080: 7665 720a 2020 2020 2020 2020 2020 2020  ver.            
-00018090: 6f72 2027 6170 7073 6927 2069 6e20 636f  or 'appsi' in co
-000180a0: 6e66 6967 2e6e 6c70 5f73 6f6c 7665 720a  nfig.nlp_solver.
-000180b0: 2020 2020 2020 2020 2020 2020 6f72 2028              or (
-000180c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000180d0: 2063 6f6e 6669 672e 6d69 705f 7265 6775   config.mip_regu
-000180e0: 6c61 7269 7a61 7469 6f6e 5f73 6f6c 7665  larization_solve
-000180f0: 7220 6973 206e 6f74 204e 6f6e 650a 2020  r is not None.  
-00018100: 2020 2020 2020 2020 2020 2020 2020 616e                an
-00018110: 6420 2761 7070 7369 2720 696e 2063 6f6e  d 'appsi' in con
-00018120: 6669 672e 6d69 705f 7265 6775 6c61 7269  fig.mip_regulari
-00018130: 7a61 7469 6f6e 5f73 6f6c 7665 720a 2020  zation_solver.  
-00018140: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00018150: 2020 2020 293a 0a20 2020 2020 2020 2020      ):.         
-00018160: 2020 2073 656c 662e 6c6f 6164 5f73 6f6c     self.load_sol
-00018170: 7574 696f 6e73 203d 2046 616c 7365 0a0a  utions = False..
-00018180: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-00018190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00018200: 2323 2323 0a20 2020 2023 2046 6561 7369  ####.    # Feasi
-00018210: 6269 6c69 7479 2050 756d 700a 0a20 2020  bility Pump..   
-00018220: 2064 6566 2073 6f6c 7665 5f66 705f 7375   def solve_fp_su
-00018230: 6270 726f 626c 656d 2873 656c 6629 3a0a  bproblem(self):.
-00018240: 2020 2020 2020 2020 2222 2253 6f6c 7665          """Solve
-00018250: 7320 7468 6520 6665 6173 6962 696c 6974  s the feasibilit
-00018260: 7920 7075 6d70 204e 4c50 2073 7562 7072  y pump NLP subpr
-00018270: 6f62 6c65 6d2e 0a0a 2020 2020 2020 2020  oblem...        
-00018280: 5468 6973 2066 756e 6374 696f 6e20 7365  This function se
-00018290: 7473 2075 7020 7468 6520 2766 705f 6e6c  ts up the 'fp_nl
-000182a0: 7027 2062 7920 7265 6c61 7820 696e 7465  p' by relax inte
-000182b0: 6765 7220 7661 7269 6162 6c65 732e 0a20  ger variables.. 
-000182c0: 2020 2020 2020 2070 7265 636f 6d70 7574         precomput
-000182d0: 6573 2064 7561 6c20 7661 6c75 6573 2c20  es dual values, 
-000182e0: 6465 6163 7469 7661 7465 7320 7472 6976  deactivates triv
-000182f0: 6961 6c20 636f 6e73 7472 6169 6e74 732c  ial constraints,
-00018300: 2061 6e64 2074 6865 6e20 736f 6c76 6573   and then solves
-00018310: 204e 4c50 206d 6f64 656c 2e0a 0a20 2020   NLP model...   
-00018320: 2020 2020 2052 6574 7572 6e73 0a20 2020       Returns.   
-00018330: 2020 2020 202d 2d2d 2d2d 2d2d 0a20 2020       -------.   
-00018340: 2020 2020 2066 705f 6e6c 7020 3a20 5079       fp_nlp : Py
-00018350: 6f6d 6f20 6d6f 6465 6c0a 2020 2020 2020  omo model.      
-00018360: 2020 2020 2020 4669 7865 642d 4e4c 5020        Fixed-NLP 
-00018370: 6672 6f6d 2074 6865 206d 6f64 656c 2e0a  from the model..
-00018380: 2020 2020 2020 2020 7265 7375 6c74 7320          results 
-00018390: 3a20 536f 6c76 6572 5265 7375 6c74 730a  : SolverResults.
-000183a0: 2020 2020 2020 2020 2020 2020 5265 7375              Resu
-000183b0: 6c74 7320 6672 6f6d 2073 6f6c 7669 6e67  lts from solving
-000183c0: 2074 6865 2066 6978 6564 2d4e 4c50 2073   the fixed-NLP s
-000183d0: 7562 7072 6f62 6c65 6d2e 0a20 2020 2020  ubproblem..     
-000183e0: 2020 2022 2222 0a20 2020 2020 2020 2066     """.        f
-000183f0: 705f 6e6c 7020 3d20 7365 6c66 2e77 6f72  p_nlp = self.wor
-00018400: 6b69 6e67 5f6d 6f64 656c 2e63 6c6f 6e65  king_model.clone
-00018410: 2829 0a20 2020 2020 2020 204d 696e 6474  ().        Mindt
-00018420: 5079 203d 2066 705f 6e6c 702e 4d69 6e64  Py = fp_nlp.Mind
-00018430: 7450 795f 7574 696c 730a 2020 2020 2020  tPy_utils.      
-00018440: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
-00018450: 636f 6e66 6967 0a0a 2020 2020 2020 2020  config..        
-00018460: 2320 5365 7420 7570 204e 4c50 0a20 2020  # Set up NLP.   
-00018470: 2020 2020 2066 705f 6e6c 702e 4d69 6e64       fp_nlp.Mind
-00018480: 7450 795f 7574 696c 732e 6f62 6a65 6374  tPy_utils.object
-00018490: 6976 655f 6c69 7374 5b2d 315d 2e64 6561  ive_list[-1].dea
-000184a0: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
-000184b0: 2020 6966 2073 656c 662e 6f62 6a65 6374    if self.object
-000184c0: 6976 655f 7365 6e73 6520 3d3d 206d 696e  ive_sense == min
-000184d0: 696d 697a 653a 0a20 2020 2020 2020 2020  imize:.         
-000184e0: 2020 2066 705f 6e6c 702e 696d 7072 6f76     fp_nlp.improv
-000184f0: 696e 675f 6f62 6a65 6374 6976 655f 6375  ing_objective_cu
-00018500: 7420 3d20 436f 6e73 7472 6169 6e74 280a  t = Constraint(.
-00018510: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018520: 6578 7072 3d73 756d 2866 705f 6e6c 702e  expr=sum(fp_nlp.
-00018530: 4d69 6e64 7450 795f 7574 696c 732e 6f62  MindtPy_utils.ob
-00018540: 6a65 6374 6976 655f 7661 6c75 655b 3a5d  jective_value[:]
-00018550: 2920 3c3d 2073 656c 662e 7072 696d 616c  ) <= self.primal
-00018560: 5f62 6f75 6e64 0a20 2020 2020 2020 2020  _bound.         
-00018570: 2020 2029 0a20 2020 2020 2020 2065 6c73     ).        els
-00018580: 653a 0a20 2020 2020 2020 2020 2020 2066  e:.            f
-00018590: 705f 6e6c 702e 696d 7072 6f76 696e 675f  p_nlp.improving_
-000185a0: 6f62 6a65 6374 6976 655f 6375 7420 3d20  objective_cut = 
-000185b0: 436f 6e73 7472 6169 6e74 280a 2020 2020  Constraint(.    
-000185c0: 2020 2020 2020 2020 2020 2020 6578 7072              expr
-000185d0: 3d73 756d 2866 705f 6e6c 702e 4d69 6e64  =sum(fp_nlp.Mind
-000185e0: 7450 795f 7574 696c 732e 6f62 6a65 6374  tPy_utils.object
-000185f0: 6976 655f 7661 6c75 655b 3a5d 2920 3e3d  ive_value[:]) >=
-00018600: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
-00018610: 6e64 0a20 2020 2020 2020 2020 2020 2029  nd.            )
-00018620: 0a0a 2020 2020 2020 2020 2320 4164 6420  ..        # Add 
-00018630: 6e6f 726d 5f63 6f6e 7374 7261 696e 742c  norm_constraint,
-00018640: 2077 6869 6368 2067 7561 7261 6e74 6565   which guarantee
-00018650: 7320 7468 6520 6d6f 6e6f 746f 6e69 6369  s the monotonici
-00018660: 7479 206f 6620 7468 6520 6e6f 726d 206f  ty of the norm o
-00018670: 626a 6563 7469 7665 2076 616c 7565 2073  bjective value s
-00018680: 6571 7565 6e63 6520 6f66 2061 6c6c 2069  equence of all i
-00018690: 7465 7261 7469 6f6e 730a 2020 2020 2020  terations.      
-000186a0: 2020 2320 5265 663a 2050 6170 6572 2027    # Ref: Paper '
-000186b0: 4120 7374 6f72 6d20 6f66 2066 6561 7369  A storm of feasi
-000186c0: 6269 6c69 7479 2070 756d 7073 2066 6f72  bility pumps for
-000186d0: 206e 6f6e 636f 6e76 6578 204d 494e 4c50   nonconvex MINLP
-000186e0: 2720 2020 6874 7470 733a 2f2f 646f 692e  '   https://doi.
-000186f0: 6f72 672f 3130 2e31 3030 372f 7331 3031  org/10.1007/s101
-00018700: 3037 2d30 3132 2d30 3630 382d 780a 2020  07-012-0608-x.  
-00018710: 2020 2020 2020 2320 7468 6520 6e6f 726d        # the norm
-00018720: 2074 7970 6520 6973 2063 6f6e 7369 7374   type is consist
-00018730: 656e 7420 7769 7468 2074 6865 206e 6f72  ent with the nor
-00018740: 6d20 6f62 6a20 6f66 2074 6865 2046 502d  m obj of the FP-
-00018750: 6d61 696e 2070 726f 626c 656d 2e0a 2020  main problem..  
-00018760: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
-00018770: 6670 5f6e 6f72 6d5f 636f 6e73 7472 6169  fp_norm_constrai
-00018780: 6e74 3a0a 2020 2020 2020 2020 2020 2020  nt:.            
-00018790: 6765 6e65 7261 7465 5f6e 6f72 6d5f 636f  generate_norm_co
-000187a0: 6e73 7472 6169 6e74 2866 705f 6e6c 702c  nstraint(fp_nlp,
-000187b0: 2073 656c 662e 6d69 702c 2063 6f6e 6669   self.mip, confi
-000187c0: 6729 0a0a 2020 2020 2020 2020 4d69 6e64  g)..        Mind
-000187d0: 7450 792e 6670 5f6e 6c70 5f6f 626a 203d  tPy.fp_nlp_obj =
-000187e0: 2067 656e 6572 6174 655f 6e6f 726d 3273   generate_norm2s
-000187f0: 715f 6f62 6a65 6374 6976 655f 6675 6e63  q_objective_func
-00018800: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
-00018810: 2020 6670 5f6e 6c70 2c20 7365 6c66 2e6d    fp_nlp, self.m
-00018820: 6970 2c20 6469 7363 7265 7465 5f6f 6e6c  ip, discrete_onl
-00018830: 793d 636f 6e66 6967 2e66 705f 6469 7363  y=config.fp_disc
-00018840: 7265 7465 5f6f 6e6c 790a 2020 2020 2020  rete_only.      
-00018850: 2020 290a 0a20 2020 2020 2020 204d 696e    )..        Min
-00018860: 6474 5079 2e63 7574 732e 6465 6163 7469  dtPy.cuts.deacti
-00018870: 7661 7465 2829 0a20 2020 2020 2020 2054  vate().        T
-00018880: 7261 6e73 666f 726d 6174 696f 6e46 6163  ransformationFac
-00018890: 746f 7279 2827 636f 7265 2e72 656c 6178  tory('core.relax
-000188a0: 5f69 6e74 6567 6572 5f76 6172 7327 292e  _integer_vars').
-000188b0: 6170 706c 795f 746f 2866 705f 6e6c 7029  apply_to(fp_nlp)
-000188c0: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
-000188d0: 2020 2020 2020 2020 2020 5472 616e 7366            Transf
-000188e0: 6f72 6d61 7469 6f6e 4661 6374 6f72 7928  ormationFactory(
-000188f0: 2763 6f6e 7472 6962 2e64 6561 6374 6976  'contrib.deactiv
-00018900: 6174 655f 7472 6976 6961 6c5f 636f 6e73  ate_trivial_cons
-00018910: 7472 6169 6e74 7327 292e 6170 706c 795f  traints').apply_
-00018920: 746f 280a 2020 2020 2020 2020 2020 2020  to(.            
-00018930: 2020 2020 6670 5f6e 6c70 2c0a 2020 2020      fp_nlp,.    
-00018940: 2020 2020 2020 2020 2020 2020 746d 703d              tmp=
-00018950: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
-00018960: 2020 2020 2020 6967 6e6f 7265 5f69 6e66        ignore_inf
-00018970: 6561 7369 626c 653d 4661 6c73 652c 0a20  easible=False,. 
-00018980: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00018990: 6f6c 6572 616e 6365 3d63 6f6e 6669 672e  olerance=config.
-000189a0: 636f 6e73 7472 6169 6e74 5f74 6f6c 6572  constraint_toler
-000189b0: 616e 6365 2c0a 2020 2020 2020 2020 2020  ance,.          
-000189c0: 2020 290a 2020 2020 2020 2020 6578 6365    ).        exce
-000189d0: 7074 2049 6e66 6561 7369 626c 6543 6f6e  pt InfeasibleCon
-000189e0: 7374 7261 696e 7445 7863 6570 7469 6f6e  straintException
-000189f0: 2061 7320 653a 0a20 2020 2020 2020 2020   as e:.         
-00018a00: 2020 2063 6f6e 6669 672e 6c6f 6767 6572     config.logger
-00018a10: 2e65 7272 6f72 2865 2c20 6578 635f 696e  .error(e, exc_in
-00018a20: 666f 3d54 7275 6529 0a20 2020 2020 2020  fo=True).       
-00018a30: 2020 2020 2063 6f6e 6669 672e 6c6f 6767       config.logg
-00018a40: 6572 2e65 7272 6f72 280a 2020 2020 2020  er.error(.      
-00018a50: 2020 2020 2020 2020 2020 2749 6e66 6561            'Infea
-00018a60: 7369 6269 6c69 7479 2064 6574 6563 7465  sibility detecte
-00018a70: 6420 696e 2064 6561 6374 6976 6174 655f  d in deactivate_
-00018a80: 7472 6976 6961 6c5f 636f 6e73 7472 6169  trivial_constrai
-00018a90: 6e74 732e 270a 2020 2020 2020 2020 2020  nts.'.          
-00018aa0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00018ab0: 7265 7375 6c74 7320 3d20 536f 6c76 6572  results = Solver
-00018ac0: 5265 7375 6c74 7328 290a 2020 2020 2020  Results().      
-00018ad0: 2020 2020 2020 7265 7375 6c74 732e 736f        results.so
-00018ae0: 6c76 6572 2e74 6572 6d69 6e61 7469 6f6e  lver.termination
-00018af0: 5f63 6f6e 6469 7469 6f6e 203d 2074 632e  _condition = tc.
-00018b00: 696e 6665 6173 6962 6c65 0a20 2020 2020  infeasible.     
-00018b10: 2020 2020 2020 2072 6574 7572 6e20 6670         return fp
-00018b20: 5f6e 6c70 2c20 7265 7375 6c74 730a 2020  _nlp, results.  
-00018b30: 2020 2020 2020 2320 536f 6c76 6520 7468        # Solve th
-00018b40: 6520 4e4c 500a 2020 2020 2020 2020 6e6c  e NLP.        nl
-00018b50: 705f 6172 6773 203d 2064 6963 7428 636f  p_args = dict(co
-00018b60: 6e66 6967 2e6e 6c70 5f73 6f6c 7665 725f  nfig.nlp_solver_
-00018b70: 6172 6773 290a 2020 2020 2020 2020 7570  args).        up
-00018b80: 6461 7465 5f73 6f6c 7665 725f 7469 6d65  date_solver_time
-00018b90: 6c69 6d69 7428 7365 6c66 2e6e 6c70 5f6f  limit(self.nlp_o
-00018ba0: 7074 2c20 636f 6e66 6967 2e6e 6c70 5f73  pt, config.nlp_s
-00018bb0: 6f6c 7665 722c 2073 656c 662e 7469 6d69  olver, self.timi
-00018bc0: 6e67 2c20 636f 6e66 6967 290a 2020 2020  ng, config).    
-00018bd0: 2020 2020 7769 7468 2053 7570 7072 6573      with Suppres
-00018be0: 7349 6e66 6561 7369 626c 6557 6172 6e69  sInfeasibleWarni
-00018bf0: 6e67 2829 3a0a 2020 2020 2020 2020 2020  ng():.          
-00018c00: 2020 7769 7468 2074 696d 655f 636f 6465    with time_code
-00018c10: 2873 656c 662e 7469 6d69 6e67 2c20 2766  (self.timing, 'f
-00018c20: 7020 7375 6270 726f 626c 656d 2729 3a0a  p subproblem'):.
-00018c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c40: 7265 7375 6c74 7320 3d20 7365 6c66 2e6e  results = self.n
-00018c50: 6c70 5f6f 7074 2e73 6f6c 7665 280a 2020  lp_opt.solve(.  
-00018c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018c70: 2020 6670 5f6e 6c70 2c0a 2020 2020 2020    fp_nlp,.      
-00018c80: 2020 2020 2020 2020 2020 2020 2020 7465                te
-00018c90: 653d 636f 6e66 6967 2e6e 6c70 5f73 6f6c  e=config.nlp_sol
-00018ca0: 7665 725f 7465 652c 0a20 2020 2020 2020  ver_tee,.       
-00018cb0: 2020 2020 2020 2020 2020 2020 206c 6f61               loa
-00018cc0: 645f 736f 6c75 7469 6f6e 733d 7365 6c66  d_solutions=self
-00018cd0: 2e6c 6f61 645f 736f 6c75 7469 6f6e 732c  .load_solutions,
-00018ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018cf0: 2020 2020 202a 2a6e 6c70 5f61 7267 732c       **nlp_args,
-00018d00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018d10: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
-00018d20: 2020 2069 6620 6c65 6e28 7265 7375 6c74     if len(result
-00018d30: 732e 736f 6c75 7469 6f6e 2920 3e20 303a  s.solution) > 0:
-00018d40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00018d50: 2020 2020 2066 705f 6e6c 702e 736f 6c75       fp_nlp.solu
-00018d60: 7469 6f6e 732e 6c6f 6164 5f66 726f 6d28  tions.load_from(
-00018d70: 7265 7375 6c74 7329 0a20 2020 2020 2020  results).       
-00018d80: 2072 6574 7572 6e20 6670 5f6e 6c70 2c20   return fp_nlp, 
-00018d90: 7265 7375 6c74 730a 0a20 2020 2064 6566  results..    def
-00018da0: 2068 616e 646c 655f 6670 5f73 7562 7072   handle_fp_subpr
-00018db0: 6f62 6c65 6d5f 6f70 7469 6d61 6c28 7365  oblem_optimal(se
-00018dc0: 6c66 2c20 6670 5f6e 6c70 293a 0a20 2020  lf, fp_nlp):.   
-00018dd0: 2020 2020 2022 2222 436f 7069 6573 2074       """Copies t
-00018de0: 6865 2073 6f6c 7574 696f 6e20 746f 2074  he solution to t
-00018df0: 6865 2077 6f72 6b69 6e67 206d 6f64 656c  he working model
-00018e00: 2c20 7570 6461 7465 7320 626f 756e 642c  , updates bound,
-00018e10: 2061 6464 7320 4f41 2063 7574 7320 2f20   adds OA cuts / 
-00018e20: 6e6f 2d67 6f6f 6420 6375 7473 202f 0a20  no-good cuts /. 
-00018e30: 2020 2020 2020 2069 6e63 7265 6173 696e         increasin
-00018e40: 6720 6f62 6a65 6374 6976 6520 6375 742c  g objective cut,
-00018e50: 2063 616c 6375 6c61 7465 7320 7468 6520   calculates the 
-00018e60: 6475 616c 7320 616e 6420 7374 6f72 6573  duals and stores
-00018e70: 2069 6e63 756d 6265 6e74 2073 6f6c 7574   incumbent solut
-00018e80: 696f 6e20 6966 2069 7420 6861 7320 6265  ion if it has be
-00018e90: 656e 2069 6d70 726f 7665 642e 0a0a 2020  en improved...  
-00018ea0: 2020 2020 2020 5061 7261 6d65 7465 7273        Parameters
-00018eb0: 0a20 2020 2020 2020 202d 2d2d 2d2d 2d2d  .        -------
-00018ec0: 2d2d 2d0a 2020 2020 2020 2020 6670 5f6e  ---.        fp_n
-00018ed0: 6c70 203a 2050 796f 6d6f 206d 6f64 656c  lp : Pyomo model
-00018ee0: 0a20 2020 2020 2020 2020 2020 2054 6865  .            The
-00018ef0: 2066 6561 7369 6269 6c69 7479 2070 756d   feasibility pum
-00018f00: 7020 4e4c 5020 7375 6270 726f 626c 656d  p NLP subproblem
-00018f10: 2e0a 2020 2020 2020 2020 2222 220a 2020  ..        """.  
-00018f20: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
-00018f30: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
-00018f40: 2020 2020 2020 2020 6670 5f6e 6c70 2e4d          fp_nlp.M
-00018f50: 696e 6474 5079 5f75 7469 6c73 2e76 6172  indtPy_utils.var
-00018f60: 6961 626c 655f 6c69 7374 2c0a 2020 2020  iable_list,.    
-00018f70: 2020 2020 2020 2020 7365 6c66 2e77 6f72          self.wor
-00018f80: 6b69 6e67 5f6d 6f64 656c 2e4d 696e 6474  king_model.Mindt
-00018f90: 5079 5f75 7469 6c73 2e76 6172 6961 626c  Py_utils.variabl
-00018fa0: 655f 6c69 7374 2c0a 2020 2020 2020 2020  e_list,.        
-00018fb0: 2020 2020 7365 6c66 2e63 6f6e 6669 672c      self.config,
-00018fc0: 0a20 2020 2020 2020 2020 2020 2069 676e  .            ign
-00018fd0: 6f72 655f 696e 7465 6772 616c 6974 793d  ore_integrality=
-00018fe0: 5472 7565 2c0a 2020 2020 2020 2020 290a  True,.        ).
-00018ff0: 2020 2020 2020 2020 6164 645f 6f72 7468          add_orth
-00019000: 6f67 6f6e 616c 6974 795f 6375 7473 2873  ogonality_cuts(s
-00019010: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
-00019020: 6c2c 2073 656c 662e 6d69 702c 2073 656c  l, self.mip, sel
-00019030: 662e 636f 6e66 6967 290a 0a20 2020 2020  f.config)..     
-00019040: 2020 2023 2069 6620 4f41 2d6c 696b 6520     # if OA-like 
-00019050: 6f72 2066 7020 636f 6e76 6572 6765 642c  or fp converged,
-00019060: 2075 7064 6174 6520 5570 7065 7220 626f   update Upper bo
-00019070: 756e 642c 0a20 2020 2020 2020 2023 2061  und,.        # a
-00019080: 6464 206e 6f5f 676f 6f64 2063 7574 7320  dd no_good cuts 
-00019090: 616e 6420 696e 6372 6561 7369 6e67 206f  and increasing o
-000190a0: 626a 6563 7469 7665 2063 7574 7320 2866  bjective cuts (f
-000190b0: 7029 0a20 2020 2020 2020 2069 6620 6670  p).        if fp
-000190c0: 5f63 6f6e 7665 7267 6564 280a 2020 2020  _converged(.    
-000190d0: 2020 2020 2020 2020 7365 6c66 2e77 6f72          self.wor
-000190e0: 6b69 6e67 5f6d 6f64 656c 2c0a 2020 2020  king_model,.    
-000190f0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-00019100: 2c0a 2020 2020 2020 2020 2020 2020 7072  ,.            pr
-00019110: 6f6a 5f7a 6572 6f5f 746f 6c65 7261 6e63  oj_zero_toleranc
-00019120: 653d 7365 6c66 2e63 6f6e 6669 672e 6670  e=self.config.fp
-00019130: 5f70 726f 6a7a 6572 6f74 6f6c 2c0a 2020  _projzerotol,.  
-00019140: 2020 2020 2020 2020 2020 6469 7363 7265            discre
-00019150: 7465 5f6f 6e6c 793d 7365 6c66 2e63 6f6e  te_only=self.con
-00019160: 6669 672e 6670 5f64 6973 6372 6574 655f  fig.fp_discrete_
-00019170: 6f6e 6c79 2c0a 2020 2020 2020 2020 293a  only,.        ):
-00019180: 0a20 2020 2020 2020 2020 2020 2063 6f70  .            cop
-00019190: 795f 7661 725f 6c69 7374 5f76 616c 7565  y_var_list_value
-000191a0: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
-000191b0: 2020 2073 656c 662e 6d69 702e 4d69 6e64     self.mip.Mind
-000191c0: 7450 795f 7574 696c 732e 7661 7269 6162  tPy_utils.variab
-000191d0: 6c65 5f6c 6973 742c 0a20 2020 2020 2020  le_list,.       
-000191e0: 2020 2020 2020 2020 2073 656c 662e 6669           self.fi
-000191f0: 7865 645f 6e6c 702e 4d69 6e64 7450 795f  xed_nlp.MindtPy_
-00019200: 7574 696c 732e 7661 7269 6162 6c65 5f6c  utils.variable_l
-00019210: 6973 742c 0a20 2020 2020 2020 2020 2020  ist,.           
-00019220: 2020 2020 2073 656c 662e 636f 6e66 6967       self.config
-00019230: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00019240: 2020 736b 6970 5f66 6978 6564 3d46 616c    skip_fixed=Fal
-00019250: 7365 2c0a 2020 2020 2020 2020 2020 2020  se,.            
-00019260: 290a 2020 2020 2020 2020 2020 2020 6669  ).            fi
-00019270: 7865 645f 6e6c 702c 2066 6978 6564 5f6e  xed_nlp, fixed_n
-00019280: 6c70 5f72 6573 756c 7473 203d 2073 656c  lp_results = sel
-00019290: 662e 736f 6c76 655f 7375 6270 726f 626c  f.solve_subprobl
-000192a0: 656d 2829 0a20 2020 2020 2020 2020 2020  em().           
-000192b0: 2069 6620 6669 7865 645f 6e6c 705f 7265   if fixed_nlp_re
-000192c0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
-000192d0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
-000192e0: 6f6e 2069 6e20 7b0a 2020 2020 2020 2020  on in {.        
-000192f0: 2020 2020 2020 2020 7463 2e6f 7074 696d          tc.optim
-00019300: 616c 2c0a 2020 2020 2020 2020 2020 2020  al,.            
-00019310: 2020 2020 7463 2e6c 6f63 616c 6c79 4f70      tc.locallyOp
-00019320: 7469 6d61 6c2c 0a20 2020 2020 2020 2020  timal,.         
-00019330: 2020 2020 2020 2074 632e 6665 6173 6962         tc.feasib
-00019340: 6c65 2c0a 2020 2020 2020 2020 2020 2020  le,.            
-00019350: 7d3a 0a20 2020 2020 2020 2020 2020 2020  }:.             
-00019360: 2020 2073 656c 662e 6861 6e64 6c65 5f73     self.handle_s
-00019370: 7562 7072 6f62 6c65 6d5f 6f70 7469 6d61  ubproblem_optima
-00019380: 6c28 6669 7865 645f 6e6c 7029 0a20 2020  l(fixed_nlp).   
-00019390: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-000193a0: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
-000193b0: 645f 696d 7072 6f76 6564 3a0a 2020 2020  d_improved:.    
-000193c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000193d0: 7365 6c66 2e6d 6970 2e4d 696e 6474 5079  self.mip.MindtPy
-000193e0: 5f75 7469 6c73 2e63 7574 732e 6465 6c5f  _utils.cuts.del_
-000193f0: 636f 6d70 6f6e 656e 7428 2769 6d70 726f  component('impro
-00019400: 7669 6e67 5f6f 626a 6563 7469 7665 5f63  ving_objective_c
-00019410: 7574 2729 0a20 2020 2020 2020 2020 2020  ut').           
-00019420: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
-00019430: 2e6f 626a 6563 7469 7665 5f73 656e 7365  .objective_sense
-00019440: 203d 3d20 6d69 6e69 6d69 7a65 3a0a 2020   == minimize:.  
-00019450: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019460: 2020 2020 2020 7365 6c66 2e6d 6970 2e4d        self.mip.M
-00019470: 696e 6474 5079 5f75 7469 6c73 2e63 7574  indtPy_utils.cut
-00019480: 732e 696d 7072 6f76 696e 675f 6f62 6a65  s.improving_obje
-00019490: 6374 6976 655f 6375 7420 3d20 280a 2020  ctive_cut = (.  
-000194a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000194b0: 2020 2020 2020 2020 2020 436f 6e73 7472            Constr
-000194c0: 6169 6e74 280a 2020 2020 2020 2020 2020  aint(.          
-000194d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000194e0: 2020 2020 2020 6578 7072 3d73 756d 2873        expr=sum(s
-000194f0: 656c 662e 6d69 702e 4d69 6e64 7450 795f  elf.mip.MindtPy_
-00019500: 7574 696c 732e 6f62 6a65 6374 6976 655f  utils.objective_
-00019510: 7661 6c75 655b 3a5d 290a 2020 2020 2020  value[:]).      
-00019520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019530: 2020 2020 2020 2020 2020 3c3d 2073 656c            <= sel
-00019540: 662e 7072 696d 616c 5f62 6f75 6e64 0a20  f.primal_bound. 
-00019550: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019560: 2020 2020 2020 2020 2020 2020 2020 202d                 -
-00019570: 2073 656c 662e 636f 6e66 6967 2e66 705f   self.config.fp_
-00019580: 6375 746f 6666 6465 6372 0a20 2020 2020  cutoffdecr.     
-00019590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000195a0: 2020 2020 2020 2020 2020 202a 206d 6178             * max
-000195b0: 2831 2c20 6162 7328 7365 6c66 2e70 7269  (1, abs(self.pri
-000195c0: 6d61 6c5f 626f 756e 6429 290a 2020 2020  mal_bound)).    
-000195d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000195e0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000195f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019600: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00019610: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00019620: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019630: 2020 2020 2020 7365 6c66 2e6d 6970 2e4d        self.mip.M
-00019640: 696e 6474 5079 5f75 7469 6c73 2e63 7574  indtPy_utils.cut
-00019650: 732e 696d 7072 6f76 696e 675f 6f62 6a65  s.improving_obje
-00019660: 6374 6976 655f 6375 7420 3d20 280a 2020  ctive_cut = (.  
-00019670: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019680: 2020 2020 2020 2020 2020 436f 6e73 7472            Constr
-00019690: 6169 6e74 280a 2020 2020 2020 2020 2020  aint(.          
-000196a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000196b0: 2020 2020 2020 6578 7072 3d73 756d 2873        expr=sum(s
-000196c0: 656c 662e 6d69 702e 4d69 6e64 7450 795f  elf.mip.MindtPy_
-000196d0: 7574 696c 732e 6f62 6a65 6374 6976 655f  utils.objective_
-000196e0: 7661 6c75 655b 3a5d 290a 2020 2020 2020  value[:]).      
-000196f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019700: 2020 2020 2020 2020 2020 3e3d 2073 656c            >= sel
-00019710: 662e 7072 696d 616c 5f62 6f75 6e64 0a20  f.primal_bound. 
-00019720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019730: 2020 2020 2020 2020 2020 2020 2020 202b                 +
-00019740: 2073 656c 662e 636f 6e66 6967 2e66 705f   self.config.fp_
-00019750: 6375 746f 6666 6465 6372 0a20 2020 2020  cutoffdecr.     
-00019760: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019770: 2020 2020 2020 2020 2020 202a 206d 6178             * max
-00019780: 2831 2c20 6162 7328 7365 6c66 2e70 7269  (1, abs(self.pri
-00019790: 6d61 6c5f 626f 756e 6429 290a 2020 2020  mal_bound)).    
+000159f0: 2020 2020 2020 2065 7870 723d 6d61 696e         expr=main
+00015a00: 5f6f 626a 6563 7469 7665 2e65 7870 720a  _objective.expr.
+00015a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015a20: 2020 2020 2020 2020 2b20 284d 696e 6474          + (Mindt
+00015a30: 5079 2e61 7567 5f70 656e 616c 7479 5f65  Py.aug_penalty_e
+00015a40: 7870 7220 6966 2063 6f6e 6669 672e 6164  xpr if config.ad
+00015a50: 645f 736c 6163 6b20 656c 7365 2030 290a  d_slack else 0).
+00015a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015a70: 2020 2020 2020 2020 3e3d 2073 656c 662e          >= self.
+00015a80: 6475 616c 5f62 6f75 6e64 2c0a 2020 2020  dual_bound,.    
+00015a90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015aa0: 2020 2020 646f 633d 274f 626a 6563 7469      doc='Objecti
+00015ab0: 7665 2066 756e 6374 696f 6e20 6578 7072  ve function expr
+00015ac0: 6573 7369 6f6e 2073 686f 756c 6420 696d  ession should im
+00015ad0: 7072 6f76 6520 6f6e 2074 6865 2062 6573  prove on the bes
+00015ae0: 7420 666f 756e 6420 6475 616c 2062 6f75  t found dual bou
+00015af0: 6e64 272c 0a20 2020 2020 2020 2020 2020  nd',.           
+00015b00: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00015b10: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00015b20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015b30: 2020 2020 204d 696e 6474 5079 2e63 7574       MindtPy.cut
+00015b40: 732e 6475 616c 5f62 6f75 6e64 203d 2043  s.dual_bound = C
+00015b50: 6f6e 7374 7261 696e 7428 0a20 2020 2020  onstraint(.     
+00015b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015b70: 2020 2065 7870 723d 6d61 696e 5f6f 626a     expr=main_obj
+00015b80: 6563 7469 7665 2e65 7870 720a 2020 2020  ective.expr.    
+00015b90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015ba0: 2020 2020 2b20 284d 696e 6474 5079 2e61      + (MindtPy.a
+00015bb0: 7567 5f70 656e 616c 7479 5f65 7870 7220  ug_penalty_expr 
+00015bc0: 6966 2063 6f6e 6669 672e 6164 645f 736c  if config.add_sl
+00015bd0: 6163 6b20 656c 7365 2030 290a 2020 2020  ack else 0).    
+00015be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015bf0: 2020 2020 3c3d 2073 656c 662e 6475 616c      <= self.dual
+00015c00: 5f62 6f75 6e64 2c0a 2020 2020 2020 2020  _bound,.        
+00015c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015c20: 646f 633d 274f 626a 6563 7469 7665 2066  doc='Objective f
+00015c30: 756e 6374 696f 6e20 6578 7072 6573 7369  unction expressi
+00015c40: 6f6e 2073 686f 756c 6420 696d 7072 6f76  on should improv
+00015c50: 6520 6f6e 2074 6865 2062 6573 7420 666f  e on the best fo
+00015c60: 756e 6420 6475 616c 2062 6f75 6e64 272c  und dual bound',
+00015c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00015c80: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
+00015c90: 7365 7475 705f 6670 5f6d 6169 6e28 7365  setup_fp_main(se
+00015ca0: 6c66 293a 0a20 2020 2020 2020 2022 2222  lf):.        """
+00015cb0: 5365 7420 7570 206d 6169 6e20 7072 6f62  Set up main prob
+00015cc0: 6c65 6d20 666f 7220 4665 6173 6962 696c  lem for Feasibil
+00015cd0: 6974 7920 5075 6d70 206d 6574 686f 642e  ity Pump method.
+00015ce0: 2222 220a 2020 2020 2020 2020 4d69 6e64  """.        Mind
+00015cf0: 7450 7920 3d20 7365 6c66 2e6d 6970 2e4d  tPy = self.mip.M
+00015d00: 696e 6474 5079 5f75 7469 6c73 0a0a 2020  indtPy_utils..  
+00015d10: 2020 2020 2020 666f 7220 6320 696e 204d        for c in M
+00015d20: 696e 6474 5079 2e63 6f6e 7374 7261 696e  indtPy.constrain
+00015d30: 745f 6c69 7374 3a0a 2020 2020 2020 2020  t_list:.        
+00015d40: 2020 2020 6966 2063 2e62 6f64 792e 706f      if c.body.po
+00015d50: 6c79 6e6f 6d69 616c 5f64 6567 7265 6528  lynomial_degree(
+00015d60: 2920 6e6f 7420 696e 2073 656c 662e 6d69  ) not in self.mi
+00015d70: 705f 636f 6e73 7472 6169 6e74 5f70 6f6c  p_constraint_pol
+00015d80: 796e 6f6d 6961 6c5f 6465 6772 6565 3a0a  ynomial_degree:.
+00015d90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015da0: 632e 6465 6163 7469 7661 7465 2829 0a0a  c.deactivate()..
+00015db0: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+00015dc0: 6375 7473 2e61 6374 6976 6174 6528 290a  cuts.activate().
+00015dd0: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+00015de0: 6465 6c5f 636f 6d70 6f6e 656e 7428 276d  del_component('m
+00015df0: 6970 5f6f 626a 2729 0a20 2020 2020 2020  ip_obj').       
+00015e00: 204d 696e 6474 5079 2e64 656c 5f63 6f6d   MindtPy.del_com
+00015e10: 706f 6e65 6e74 2827 6670 5f6d 6970 5f6f  ponent('fp_mip_o
+00015e20: 626a 2729 0a20 2020 2020 2020 2069 6620  bj').        if 
+00015e30: 7365 6c66 2e63 6f6e 6669 672e 6670 5f6d  self.config.fp_m
+00015e40: 6169 6e5f 6e6f 726d 203d 3d20 274c 3127  ain_norm == 'L1'
+00015e50: 3a0a 2020 2020 2020 2020 2020 2020 4d69  :.            Mi
+00015e60: 6e64 7450 792e 6670 5f6d 6970 5f6f 626a  ndtPy.fp_mip_obj
+00015e70: 203d 2067 656e 6572 6174 655f 6e6f 726d   = generate_norm
+00015e80: 315f 6f62 6a65 6374 6976 655f 6675 6e63  1_objective_func
+00015e90: 7469 6f6e 280a 2020 2020 2020 2020 2020  tion(.          
+00015ea0: 2020 2020 2020 7365 6c66 2e6d 6970 2c20        self.mip, 
+00015eb0: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
+00015ec0: 656c 2c20 6469 7363 7265 7465 5f6f 6e6c  el, discrete_onl
+00015ed0: 793d 7365 6c66 2e63 6f6e 6669 672e 6670  y=self.config.fp
+00015ee0: 5f64 6973 6372 6574 655f 6f6e 6c79 0a20  _discrete_only. 
+00015ef0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00015f00: 2020 2020 2065 6c69 6620 7365 6c66 2e63       elif self.c
+00015f10: 6f6e 6669 672e 6670 5f6d 6169 6e5f 6e6f  onfig.fp_main_no
+00015f20: 726d 203d 3d20 274c 3227 3a0a 2020 2020  rm == 'L2':.    
+00015f30: 2020 2020 2020 2020 4d69 6e64 7450 792e          MindtPy.
+00015f40: 6670 5f6d 6970 5f6f 626a 203d 2067 656e  fp_mip_obj = gen
+00015f50: 6572 6174 655f 6e6f 726d 3273 715f 6f62  erate_norm2sq_ob
+00015f60: 6a65 6374 6976 655f 6675 6e63 7469 6f6e  jective_function
+00015f70: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00015f80: 2020 7365 6c66 2e6d 6970 2c20 7365 6c66    self.mip, self
+00015f90: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2c20  .working_model, 
+00015fa0: 6469 7363 7265 7465 5f6f 6e6c 793d 7365  discrete_only=se
+00015fb0: 6c66 2e63 6f6e 6669 672e 6670 5f64 6973  lf.config.fp_dis
+00015fc0: 6372 6574 655f 6f6e 6c79 0a20 2020 2020  crete_only.     
+00015fd0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00015fe0: 2065 6c69 6620 7365 6c66 2e63 6f6e 6669   elif self.confi
+00015ff0: 672e 6670 5f6d 6169 6e5f 6e6f 726d 203d  g.fp_main_norm =
+00016000: 3d20 274c 5f69 6e66 696e 6974 7927 3a0a  = 'L_infinity':.
+00016010: 2020 2020 2020 2020 2020 2020 4d69 6e64              Mind
+00016020: 7450 792e 6670 5f6d 6970 5f6f 626a 203d  tPy.fp_mip_obj =
+00016030: 2067 656e 6572 6174 655f 6e6f 726d 5f69   generate_norm_i
+00016040: 6e66 5f6f 626a 6563 7469 7665 5f66 756e  nf_objective_fun
+00016050: 6374 696f 6e28 0a20 2020 2020 2020 2020  ction(.         
+00016060: 2020 2020 2020 2073 656c 662e 6d69 702c         self.mip,
+00016070: 2073 656c 662e 776f 726b 696e 675f 6d6f   self.working_mo
+00016080: 6465 6c2c 2064 6973 6372 6574 655f 6f6e  del, discrete_on
+00016090: 6c79 3d73 656c 662e 636f 6e66 6967 2e66  ly=self.config.f
+000160a0: 705f 6469 7363 7265 7465 5f6f 6e6c 790a  p_discrete_only.
+000160b0: 2020 2020 2020 2020 2020 2020 290a 0a20              ).. 
+000160c0: 2020 2064 6566 2073 6574 7570 5f72 6567     def setup_reg
+000160d0: 756c 6172 697a 6174 696f 6e5f 6d61 696e  ularization_main
+000160e0: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+000160f0: 2222 2253 6574 2075 7020 6d61 696e 2072  """Set up main r
+00016100: 6567 756c 6172 697a 6174 696f 6e20 7072  egularization pr
+00016110: 6f62 6c65 6d20 666f 7220 524f 4120 6d65  oblem for ROA me
+00016120: 7468 6f64 2e22 2222 0a20 2020 2020 2020  thod.""".       
+00016130: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
+00016140: 6f6e 6669 670a 2020 2020 2020 2020 4d69  onfig.        Mi
+00016150: 6e64 7450 7920 3d20 7365 6c66 2e6d 6970  ndtPy = self.mip
+00016160: 2e4d 696e 6474 5079 5f75 7469 6c73 0a0a  .MindtPy_utils..
+00016170: 2020 2020 2020 2020 666f 7220 6320 696e          for c in
+00016180: 204d 696e 6474 5079 2e63 6f6e 7374 7261   MindtPy.constra
+00016190: 696e 745f 6c69 7374 3a0a 2020 2020 2020  int_list:.      
+000161a0: 2020 2020 2020 6966 2063 2e62 6f64 792e        if c.body.
+000161b0: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+000161c0: 6528 2920 6e6f 7420 696e 2073 656c 662e  e() not in self.
+000161d0: 6d69 705f 636f 6e73 7472 6169 6e74 5f70  mip_constraint_p
+000161e0: 6f6c 796e 6f6d 6961 6c5f 6465 6772 6565  olynomial_degree
+000161f0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016200: 2020 632e 6465 6163 7469 7661 7465 2829    c.deactivate()
+00016210: 0a0a 2020 2020 2020 2020 4d69 6e64 7450  ..        MindtP
+00016220: 792e 6375 7473 2e61 6374 6976 6174 6528  y.cuts.activate(
+00016230: 290a 0a20 2020 2020 2020 2073 6967 6e5f  )..        sign_
+00016240: 6164 6a75 7374 203d 2031 2069 6620 7365  adjust = 1 if se
+00016250: 6c66 2e6f 626a 6563 7469 7665 5f73 656e  lf.objective_sen
+00016260: 7365 203d 3d20 6d69 6e69 6d69 7a65 2065  se == minimize e
+00016270: 6c73 6520 2d31 0a20 2020 2020 2020 204d  lse -1.        M
+00016280: 696e 6474 5079 2e64 656c 5f63 6f6d 706f  indtPy.del_compo
+00016290: 6e65 6e74 2827 6d69 705f 6f62 6a27 290a  nent('mip_obj').
+000162a0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+000162b0: 672e 7369 6e67 6c65 5f74 7265 653a 0a20  g.single_tree:. 
+000162c0: 2020 2020 2020 2020 2020 204d 696e 6474             Mindt
+000162d0: 5079 2e64 656c 5f63 6f6d 706f 6e65 6e74  Py.del_component
+000162e0: 2827 726f 615f 7072 6f6a 5f6d 6970 5f6f  ('roa_proj_mip_o
+000162f0: 626a 2729 0a20 2020 2020 2020 2020 2020  bj').           
+00016300: 204d 696e 6474 5079 2e63 7574 732e 6465   MindtPy.cuts.de
+00016310: 6c5f 636f 6d70 6f6e 656e 7428 276f 626a  l_component('obj
+00016320: 5f72 6567 5f65 7374 696d 6174 6527 290a  _reg_estimate').
+00016330: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+00016340: 672e 6164 645f 7265 6775 6c61 7269 7a61  g.add_regulariza
+00016350: 7469 6f6e 2069 7320 6e6f 7420 4e6f 6e65  tion is not None
+00016360: 2061 6e64 2063 6f6e 6669 672e 6164 645f   and config.add_
+00016370: 6e6f 5f67 6f6f 645f 6375 7473 3a0a 2020  no_good_cuts:.  
+00016380: 2020 2020 2020 2020 2020 4d69 6e64 7450            MindtP
+00016390: 792e 6375 7473 2e6e 6f5f 676f 6f64 5f63  y.cuts.no_good_c
+000163a0: 7574 732e 6163 7469 7661 7465 2829 0a0a  uts.activate()..
+000163b0: 2020 2020 2020 2020 2320 5468 6520 6570          # The ep
+000163c0: 6967 7261 7068 2063 6f6e 7374 7261 696e  igraph constrain
+000163d0: 7420 6973 2076 6572 7920 2266 6c61 7422  t is very "flat"
+000163e0: 2066 6f72 2062 7261 6e63 6869 6e67 2072   for branching r
+000163f0: 756c 6573 2e0a 2020 2020 2020 2020 2320  ules..        # 
+00016400: 496e 2052 4f41 2c20 6966 2074 6865 206f  In ROA, if the o
+00016410: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
+00016420: 6e20 6973 206c 696e 6561 7228 6f72 2071  n is linear(or q
+00016430: 7561 6472 6174 6963 2077 6865 6e20 7175  uadratic when qu
+00016440: 6164 7261 7469 635f 7374 7261 7465 6779  adratic_strategy
+00016450: 203d 2031 206f 7220 3229 2c20 7468 6520   = 1 or 2), the 
+00016460: 6f72 6967 696e 616c 206f 626a 6563 7469  original objecti
+00016470: 7665 2066 756e 6374 696f 6e20 6973 2075  ve function is u
+00016480: 7365 6420 696e 2074 6865 204d 4950 2070  sed in the MIP p
+00016490: 726f 626c 656d 2e0a 2020 2020 2020 2020  roblem..        
+000164a0: 2320 496e 2074 6865 204d 4950 2070 726f  # In the MIP pro
+000164b0: 6a65 6374 696f 6e20 7072 6f62 6c65 6d2c  jection problem,
+000164c0: 2077 6520 6e65 6564 2074 6f20 7265 6163   we need to reac
+000164d0: 7469 7661 7465 2074 6865 2065 7069 6772  tivate the epigr
+000164e0: 6170 6820 636f 6e73 7472 6169 6e74 286f  aph constraint(o
+000164f0: 626a 6563 7469 7665 5f63 6f6e 7374 7229  bjective_constr)
+00016500: 2e0a 2020 2020 2020 2020 6966 2028 0a20  ..        if (. 
+00016510: 2020 2020 2020 2020 2020 204d 696e 6474             Mindt
+00016520: 5079 2e6f 626a 6563 7469 7665 5f6c 6973  Py.objective_lis
+00016530: 745b 305d 2e65 7870 722e 706f 6c79 6e6f  t[0].expr.polyno
+00016540: 6d69 616c 5f64 6567 7265 6528 290a 2020  mial_degree().  
+00016550: 2020 2020 2020 2020 2020 696e 2073 656c            in sel
+00016560: 662e 6d69 705f 6f62 6a65 6374 6976 655f  f.mip_objective_
+00016570: 706f 6c79 6e6f 6d69 616c 5f64 6567 7265  polynomial_degre
+00016580: 650a 2020 2020 2020 2020 293a 0a20 2020  e.        ):.   
+00016590: 2020 2020 2020 2020 204d 696e 6474 5079           MindtPy
+000165a0: 2e6f 626a 6563 7469 7665 5f63 6f6e 7374  .objective_const
+000165b0: 722e 6163 7469 7661 7465 2829 0a20 2020  r.activate().   
+000165c0: 2020 2020 2069 6620 636f 6e66 6967 2e61       if config.a
+000165d0: 6464 5f72 6567 756c 6172 697a 6174 696f  dd_regularizatio
+000165e0: 6e20 3d3d 2027 6c65 7665 6c5f 4c31 273a  n == 'level_L1':
+000165f0: 0a20 2020 2020 2020 2020 2020 204d 696e  .            Min
+00016600: 6474 5079 2e72 6f61 5f70 726f 6a5f 6d69  dtPy.roa_proj_mi
+00016610: 705f 6f62 6a20 3d20 6765 6e65 7261 7465  p_obj = generate
+00016620: 5f6e 6f72 6d31 5f6f 626a 6563 7469 7665  _norm1_objective
+00016630: 5f66 756e 6374 696f 6e28 0a20 2020 2020  _function(.     
+00016640: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00016650: 6d69 702c 2073 656c 662e 6265 7374 5f73  mip, self.best_s
+00016660: 6f6c 7574 696f 6e5f 666f 756e 642c 2064  olution_found, d
+00016670: 6973 6372 6574 655f 6f6e 6c79 3d46 616c  iscrete_only=Fal
+00016680: 7365 0a20 2020 2020 2020 2020 2020 2029  se.            )
+00016690: 0a20 2020 2020 2020 2065 6c69 6620 636f  .        elif co
+000166a0: 6e66 6967 2e61 6464 5f72 6567 756c 6172  nfig.add_regular
+000166b0: 697a 6174 696f 6e20 3d3d 2027 6c65 7665  ization == 'leve
+000166c0: 6c5f 4c32 273a 0a20 2020 2020 2020 2020  l_L2':.         
+000166d0: 2020 204d 696e 6474 5079 2e72 6f61 5f70     MindtPy.roa_p
+000166e0: 726f 6a5f 6d69 705f 6f62 6a20 3d20 6765  roj_mip_obj = ge
+000166f0: 6e65 7261 7465 5f6e 6f72 6d32 7371 5f6f  nerate_norm2sq_o
+00016700: 626a 6563 7469 7665 5f66 756e 6374 696f  bjective_functio
+00016710: 6e28 0a20 2020 2020 2020 2020 2020 2020  n(.             
+00016720: 2020 2073 656c 662e 6d69 702c 2073 656c     self.mip, sel
+00016730: 662e 6265 7374 5f73 6f6c 7574 696f 6e5f  f.best_solution_
+00016740: 666f 756e 642c 2064 6973 6372 6574 655f  found, discrete_
+00016750: 6f6e 6c79 3d46 616c 7365 0a20 2020 2020  only=False.     
+00016760: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00016770: 2065 6c69 6620 636f 6e66 6967 2e61 6464   elif config.add
+00016780: 5f72 6567 756c 6172 697a 6174 696f 6e20  _regularization 
+00016790: 3d3d 2027 6c65 7665 6c5f 4c5f 696e 6669  == 'level_L_infi
+000167a0: 6e69 7479 273a 0a20 2020 2020 2020 2020  nity':.         
+000167b0: 2020 204d 696e 6474 5079 2e72 6f61 5f70     MindtPy.roa_p
+000167c0: 726f 6a5f 6d69 705f 6f62 6a20 3d20 6765  roj_mip_obj = ge
+000167d0: 6e65 7261 7465 5f6e 6f72 6d5f 696e 665f  nerate_norm_inf_
+000167e0: 6f62 6a65 6374 6976 655f 6675 6e63 7469  objective_functi
+000167f0: 6f6e 280a 2020 2020 2020 2020 2020 2020  on(.            
+00016800: 2020 2020 7365 6c66 2e6d 6970 2c20 7365      self.mip, se
+00016810: 6c66 2e62 6573 745f 736f 6c75 7469 6f6e  lf.best_solution
+00016820: 5f66 6f75 6e64 2c20 6469 7363 7265 7465  _found, discrete
+00016830: 5f6f 6e6c 793d 4661 6c73 650a 2020 2020  _only=False.    
+00016840: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00016850: 2020 656c 6966 2063 6f6e 6669 672e 6164    elif config.ad
+00016860: 645f 7265 6775 6c61 7269 7a61 7469 6f6e  d_regularization
+00016870: 2069 6e20 7b0a 2020 2020 2020 2020 2020   in {.          
+00016880: 2020 2767 7261 645f 6c61 6727 2c0a 2020    'grad_lag',.  
+00016890: 2020 2020 2020 2020 2020 2768 6573 735f            'hess_
+000168a0: 6c61 6727 2c0a 2020 2020 2020 2020 2020  lag',.          
+000168b0: 2020 2768 6573 735f 6f6e 6c79 5f6c 6167    'hess_only_lag
+000168c0: 272c 0a20 2020 2020 2020 2020 2020 2027  ',.            '
+000168d0: 7371 705f 6c61 6727 2c0a 2020 2020 2020  sqp_lag',.      
+000168e0: 2020 7d3a 0a20 2020 2020 2020 2020 2020    }:.           
+000168f0: 204d 696e 6474 5079 2e72 6f61 5f70 726f   MindtPy.roa_pro
+00016900: 6a5f 6d69 705f 6f62 6a20 3d20 6765 6e65  j_mip_obj = gene
+00016910: 7261 7465 5f6c 6167 5f6f 626a 6563 7469  rate_lag_objecti
+00016920: 7665 5f66 756e 6374 696f 6e28 0a20 2020  ve_function(.   
+00016930: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00016940: 662e 6d69 702c 0a20 2020 2020 2020 2020  f.mip,.         
+00016950: 2020 2020 2020 2073 656c 662e 6265 7374         self.best
+00016960: 5f73 6f6c 7574 696f 6e5f 666f 756e 642c  _solution_found,
+00016970: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016980: 2063 6f6e 6669 672c 0a20 2020 2020 2020   config,.       
+00016990: 2020 2020 2020 2020 2073 656c 662e 7469           self.ti
+000169a0: 6d69 6e67 2c0a 2020 2020 2020 2020 2020  ming,.          
+000169b0: 2020 2020 2020 6469 7363 7265 7465 5f6f        discrete_o
+000169c0: 6e6c 793d 4661 6c73 652c 0a20 2020 2020  nly=False,.     
+000169d0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+000169e0: 2069 6620 7365 6c66 2e6f 626a 6563 7469   if self.objecti
+000169f0: 7665 5f73 656e 7365 203d 3d20 6d69 6e69  ve_sense == mini
+00016a00: 6d69 7a65 3a0a 2020 2020 2020 2020 2020  mize:.          
+00016a10: 2020 4d69 6e64 7450 792e 6375 7473 2e6f    MindtPy.cuts.o
+00016a20: 626a 5f72 6567 5f65 7374 696d 6174 6520  bj_reg_estimate 
+00016a30: 3d20 436f 6e73 7472 6169 6e74 280a 2020  = Constraint(.  
+00016a40: 2020 2020 2020 2020 2020 2020 2020 6578                ex
+00016a50: 7072 3d73 756d 284d 696e 6474 5079 2e6f  pr=sum(MindtPy.o
+00016a60: 626a 6563 7469 7665 5f76 616c 7565 5b3a  bjective_value[:
+00016a70: 5d29 0a20 2020 2020 2020 2020 2020 2020  ]).             
+00016a80: 2020 203c 3d20 2831 202d 2063 6f6e 6669     <= (1 - confi
+00016a90: 672e 6c65 7665 6c5f 636f 6566 2920 2a20  g.level_coef) * 
+00016aa0: 7365 6c66 2e70 7269 6d61 6c5f 626f 756e  self.primal_boun
+00016ab0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
+00016ac0: 2020 2b20 636f 6e66 6967 2e6c 6576 656c    + config.level
+00016ad0: 5f63 6f65 6620 2a20 7365 6c66 2e64 7561  _coef * self.dua
+00016ae0: 6c5f 626f 756e 640a 2020 2020 2020 2020  l_bound.        
+00016af0: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+00016b00: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00016b10: 4d69 6e64 7450 792e 6375 7473 2e6f 626a  MindtPy.cuts.obj
+00016b20: 5f72 6567 5f65 7374 696d 6174 6520 3d20  _reg_estimate = 
+00016b30: 436f 6e73 7472 6169 6e74 280a 2020 2020  Constraint(.    
+00016b40: 2020 2020 2020 2020 2020 2020 6578 7072              expr
+00016b50: 3d73 756d 284d 696e 6474 5079 2e6f 626a  =sum(MindtPy.obj
+00016b60: 6563 7469 7665 5f76 616c 7565 5b3a 5d29  ective_value[:])
+00016b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00016b80: 203e 3d20 2831 202d 2063 6f6e 6669 672e   >= (1 - config.
+00016b90: 6c65 7665 6c5f 636f 6566 2920 2a20 7365  level_coef) * se
+00016ba0: 6c66 2e70 7269 6d61 6c5f 626f 756e 640a  lf.primal_bound.
+00016bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016bc0: 2b20 636f 6e66 6967 2e6c 6576 656c 5f63  + config.level_c
+00016bd0: 6f65 6620 2a20 7365 6c66 2e64 7561 6c5f  oef * self.dual_
+00016be0: 626f 756e 640a 2020 2020 2020 2020 2020  bound.          
+00016bf0: 2020 290a 0a20 2020 2064 6566 2075 7064    )..    def upd
+00016c00: 6174 655f 7265 7375 6c74 2873 656c 6629  ate_result(self)
+00016c10: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+00016c20: 662e 6f62 6a65 6374 6976 655f 7365 6e73  f.objective_sens
+00016c30: 6520 3d3d 206d 696e 696d 697a 653a 0a20  e == minimize:. 
+00016c40: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00016c50: 7265 7375 6c74 732e 7072 6f62 6c65 6d2e  results.problem.
+00016c60: 6c6f 7765 725f 626f 756e 6420 3d20 7365  lower_bound = se
+00016c70: 6c66 2e64 7561 6c5f 626f 756e 640a 2020  lf.dual_bound.  
+00016c80: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+00016c90: 6573 756c 7473 2e70 726f 626c 656d 2e75  esults.problem.u
+00016ca0: 7070 6572 5f62 6f75 6e64 203d 2073 656c  pper_bound = sel
+00016cb0: 662e 7072 696d 616c 5f62 6f75 6e64 0a20  f.primal_bound. 
+00016cc0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00016cd0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+00016ce0: 7375 6c74 732e 7072 6f62 6c65 6d2e 6c6f  sults.problem.lo
+00016cf0: 7765 725f 626f 756e 6420 3d20 7365 6c66  wer_bound = self
+00016d00: 2e70 7269 6d61 6c5f 626f 756e 640a 2020  .primal_bound.  
+00016d10: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+00016d20: 6573 756c 7473 2e70 726f 626c 656d 2e75  esults.problem.u
+00016d30: 7070 6572 5f62 6f75 6e64 203d 2073 656c  pper_bound = sel
+00016d40: 662e 6475 616c 5f62 6f75 6e64 0a0a 2020  f.dual_bound..  
+00016d50: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
+00016d60: 7473 2e73 6f6c 7665 722e 7469 6d69 6e67  ts.solver.timing
+00016d70: 203d 2073 656c 662e 7469 6d69 6e67 0a20   = self.timing. 
+00016d80: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+00016d90: 6c74 732e 736f 6c76 6572 2e75 7365 725f  lts.solver.user_
+00016da0: 7469 6d65 203d 2073 656c 662e 7469 6d69  time = self.timi
+00016db0: 6e67 2e74 6f74 616c 0a20 2020 2020 2020  ng.total.       
+00016dc0: 2073 656c 662e 7265 7375 6c74 732e 736f   self.results.so
+00016dd0: 6c76 6572 2e77 616c 6c63 6c6f 636b 5f74  lver.wallclock_t
+00016de0: 696d 6520 3d20 7365 6c66 2e74 696d 696e  ime = self.timin
+00016df0: 672e 746f 7461 6c0a 2020 2020 2020 2020  g.total.        
+00016e00: 7365 6c66 2e72 6573 756c 7473 2e73 6f6c  self.results.sol
+00016e10: 7665 722e 6974 6572 6174 696f 6e73 203d  ver.iterations =
+00016e20: 2073 656c 662e 6d69 705f 6974 6572 0a20   self.mip_iter. 
+00016e30: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+00016e40: 6c74 732e 736f 6c76 6572 2e6e 756d 5f69  lts.solver.num_i
+00016e50: 6e66 6561 7369 626c 655f 6e6c 705f 7375  nfeasible_nlp_su
+00016e60: 6270 726f 626c 656d 203d 2073 656c 662e  bproblem = self.
+00016e70: 6e6c 705f 696e 6665 6173 6962 6c65 5f63  nlp_infeasible_c
+00016e80: 6f75 6e74 6572 0a20 2020 2020 2020 2073  ounter.        s
+00016e90: 656c 662e 7265 7375 6c74 732e 736f 6c76  elf.results.solv
+00016ea0: 6572 2e62 6573 745f 736f 6c75 7469 6f6e  er.best_solution
+00016eb0: 5f66 6f75 6e64 5f74 696d 6520 3d20 7365  _found_time = se
+00016ec0: 6c66 2e62 6573 745f 736f 6c75 7469 6f6e  lf.best_solution
+00016ed0: 5f66 6f75 6e64 5f74 696d 650a 2020 2020  _found_time.    
+00016ee0: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
+00016ef0: 2e73 6f6c 7665 722e 7072 696d 616c 5f69  .solver.primal_i
+00016f00: 6e74 6567 7261 6c20 3d20 7365 6c66 2e70  ntegral = self.p
+00016f10: 7269 6d61 6c5f 696e 7465 6772 616c 0a20  rimal_integral. 
+00016f20: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+00016f30: 6c74 732e 736f 6c76 6572 2e64 7561 6c5f  lts.solver.dual_
+00016f40: 696e 7465 6772 616c 203d 2073 656c 662e  integral = self.
+00016f50: 6475 616c 5f69 6e74 6567 7261 6c0a 2020  dual_integral.  
+00016f60: 2020 2020 2020 7365 6c66 2e72 6573 756c        self.resul
+00016f70: 7473 2e73 6f6c 7665 722e 7072 696d 616c  ts.solver.primal
+00016f80: 5f64 7561 6c5f 6761 705f 696e 7465 6772  _dual_gap_integr
+00016f90: 616c 203d 2073 656c 662e 7072 696d 616c  al = self.primal
+00016fa0: 5f64 7561 6c5f 6761 705f 696e 7465 6772  _dual_gap_integr
+00016fb0: 616c 0a0a 2020 2020 6465 6620 6c6f 6164  al..    def load
+00016fc0: 5f73 6f6c 7574 696f 6e28 7365 6c66 293a  _solution(self):
+00016fd0: 0a20 2020 2020 2020 2023 2055 7064 6174  .        # Updat
+00016fe0: 6520 7661 6c75 6573 2069 6e20 6f72 6967  e values in orig
+00016ff0: 696e 616c 206d 6f64 656c 0a20 2020 2020  inal model.     
+00017000: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
+00017010: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
+00017020: 4d69 6e64 7450 7920 3d20 7365 6c66 2e77  MindtPy = self.w
+00017030: 6f72 6b69 6e67 5f6d 6f64 656c 2e4d 696e  orking_model.Min
+00017040: 6474 5079 5f75 7469 6c73 0a20 2020 2020  dtPy_utils.     
+00017050: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
+00017060: 5f76 616c 7565 7328 0a20 2020 2020 2020  _values(.       
+00017070: 2020 2020 2066 726f 6d5f 6c69 7374 3d73       from_list=s
+00017080: 656c 662e 6265 7374 5f73 6f6c 7574 696f  elf.best_solutio
+00017090: 6e5f 666f 756e 642e 4d69 6e64 7450 795f  n_found.MindtPy_
+000170a0: 7574 696c 732e 7661 7269 6162 6c65 5f6c  utils.variable_l
+000170b0: 6973 742c 0a20 2020 2020 2020 2020 2020  ist,.           
+000170c0: 2074 6f5f 6c69 7374 3d4d 696e 6474 5079   to_list=MindtPy
+000170d0: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
+000170e0: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
+000170f0: 6967 3d63 6f6e 6669 672c 0a20 2020 2020  ig=config,.     
+00017100: 2020 2029 0a20 2020 2020 2020 2023 2054     ).        # T
+00017110: 6865 206f 7269 6769 6e61 6c20 646f 6573  he original does
+00017120: 206e 6f74 2068 6176 6520 7661 7269 6162   not have variab
+00017130: 6c65 206c 6973 742e 0a20 2020 2020 2020  le list..       
+00017140: 2023 2055 7365 2067 6574 5f76 6172 735f   # Use get_vars_
+00017150: 6672 6f6d 5f63 6f6d 706f 6e65 6e74 7328  from_components(
+00017160: 2920 7368 6f75 6c64 2062 6520 7573 6564  ) should be used
+00017170: 2066 6f72 2062 6f74 6820 776f 726b 696e   for both workin
+00017180: 675f 6d6f 6465 6c20 616e 6420 6f72 6967  g_model and orig
+00017190: 696e 616c 5f6d 6f64 656c 2074 6f20 6578  inal_model to ex
+000171a0: 636c 7564 6520 7468 6520 756e 7573 6564  clude the unused
+000171b0: 2076 6172 6961 626c 6573 2e0a 2020 2020   variables..    
+000171c0: 2020 2020 7365 6c66 2e77 6f72 6b69 6e67      self.working
+000171d0: 5f6d 6f64 656c 2e4d 696e 6474 5079 5f75  _model.MindtPy_u
+000171e0: 7469 6c73 2e64 6561 6374 6976 6174 6528  tils.deactivate(
+000171f0: 290a 2020 2020 2020 2020 2320 5468 6520  ).        # The 
+00017200: 6f72 6967 696e 616c 206f 626a 6563 7469  original objecti
+00017210: 7665 2073 686f 756c 6420 6265 2061 6374  ve should be act
+00017220: 6976 6174 6564 2074 6f20 6d61 6b65 2073  ivated to make s
+00017230: 7572 6520 7468 6520 7661 7269 6162 6c65  ure the variable
+00017240: 206c 6973 7420 6973 2069 6e20 7468 6520   list is in the 
+00017250: 7361 6d65 206f 7264 6572 2028 6765 745f  same order (get_
+00017260: 7661 7273 5f66 726f 6d5f 636f 6d70 6f6e  vars_from_compon
+00017270: 656e 7473 292e 0a20 2020 2020 2020 2073  ents)..        s
+00017280: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+00017290: 6c2e 4d69 6e64 7450 795f 7574 696c 732e  l.MindtPy_utils.
+000172a0: 6f62 6a65 6374 6976 655f 6c69 7374 5b30  objective_list[0
+000172b0: 5d2e 6163 7469 7661 7465 2829 0a20 2020  ].activate().   
+000172c0: 2020 2020 2069 6620 7365 6c66 2e77 6f72       if self.wor
+000172d0: 6b69 6e67 5f6d 6f64 656c 2e63 6f6d 706f  king_model.compo
+000172e0: 6e65 6e74 2822 5f69 6e74 5f74 6f5f 6269  nent("_int_to_bi
+000172f0: 6e61 7279 5f72 6566 6f72 6d22 2920 6973  nary_reform") is
+00017300: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
+00017310: 2020 2020 2020 2073 656c 662e 776f 726b         self.work
+00017320: 696e 675f 6d6f 6465 6c2e 5f69 6e74 5f74  ing_model._int_t
+00017330: 6f5f 6269 6e61 7279 5f72 6566 6f72 6d2e  o_binary_reform.
+00017340: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
+00017350: 2020 2020 2023 2065 7863 6c75 6465 2066       # exclude f
+00017360: 6978 6564 2076 6172 6961 626c 6573 2068  ixed variables h
+00017370: 6572 652e 2054 6869 7320 6973 2063 6f6e  ere. This is con
+00017380: 7369 7374 656e 7420 7769 7468 2074 6865  sistent with the
+00017390: 2064 6566 696e 6974 696f 6e20 6f66 2076   definition of v
+000173a0: 6172 6961 626c 655f 6c69 7374 2e0a 2020  ariable_list..  
+000173b0: 2020 2020 2020 776f 726b 696e 675f 6d6f        working_mo
+000173c0: 6465 6c5f 7661 7269 6162 6c65 5f6c 6973  del_variable_lis
+000173d0: 7420 3d20 6c69 7374 280a 2020 2020 2020  t = list(.      
+000173e0: 2020 2020 2020 6765 745f 7661 7273 5f66        get_vars_f
+000173f0: 726f 6d5f 636f 6d70 6f6e 656e 7473 280a  rom_components(.
+00017400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017410: 626c 6f63 6b3d 7365 6c66 2e77 6f72 6b69  block=self.worki
+00017420: 6e67 5f6d 6f64 656c 2c0a 2020 2020 2020  ng_model,.      
+00017430: 2020 2020 2020 2020 2020 6374 7970 653d            ctype=
+00017440: 2843 6f6e 7374 7261 696e 742c 204f 626a  (Constraint, Obj
+00017450: 6563 7469 7665 292c 0a20 2020 2020 2020  ective),.       
+00017460: 2020 2020 2020 2020 2069 6e63 6c75 6465           include
+00017470: 5f66 6978 6564 3d46 616c 7365 2c0a 2020  _fixed=False,.  
+00017480: 2020 2020 2020 2020 2020 2020 2020 6163                ac
+00017490: 7469 7665 3d54 7275 652c 0a20 2020 2020  tive=True,.     
+000174a0: 2020 2020 2020 2020 2020 2073 6f72 743d             sort=
+000174b0: 5472 7565 2c0a 2020 2020 2020 2020 2020  True,.          
+000174c0: 2020 2020 2020 6465 7363 656e 645f 696e        descend_in
+000174d0: 746f 3d54 7275 652c 0a20 2020 2020 2020  to=True,.       
+000174e0: 2020 2020 2020 2020 2064 6573 6365 6e74           descent
+000174f0: 5f6f 7264 6572 3d4e 6f6e 652c 0a20 2020  _order=None,.   
+00017500: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+00017510: 2020 2029 0a20 2020 2020 2020 206f 7269     ).        ori
+00017520: 6769 6e61 6c5f 6d6f 6465 6c5f 7661 7269  ginal_model_vari
+00017530: 6162 6c65 5f6c 6973 7420 3d20 6c69 7374  able_list = list
+00017540: 280a 2020 2020 2020 2020 2020 2020 6765  (.            ge
+00017550: 745f 7661 7273 5f66 726f 6d5f 636f 6d70  t_vars_from_comp
+00017560: 6f6e 656e 7473 280a 2020 2020 2020 2020  onents(.        
+00017570: 2020 2020 2020 2020 626c 6f63 6b3d 7365          block=se
+00017580: 6c66 2e6f 7269 6769 6e61 6c5f 6d6f 6465  lf.original_mode
+00017590: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
+000175a0: 2020 2063 7479 7065 3d28 436f 6e73 7472     ctype=(Constr
+000175b0: 6169 6e74 2c20 4f62 6a65 6374 6976 6529  aint, Objective)
+000175c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+000175d0: 2020 696e 636c 7564 655f 6669 7865 643d    include_fixed=
+000175e0: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
+000175f0: 2020 2020 2020 2061 6374 6976 653d 5472         active=Tr
+00017600: 7565 2c0a 2020 2020 2020 2020 2020 2020  ue,.            
+00017610: 2020 2020 736f 7274 3d54 7275 652c 0a20      sort=True,. 
+00017620: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00017630: 6573 6365 6e64 5f69 6e74 6f3d 5472 7565  escend_into=True
+00017640: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00017650: 2020 6465 7363 656e 745f 6f72 6465 723d    descent_order=
+00017660: 4e6f 6e65 2c0a 2020 2020 2020 2020 2020  None,.          
+00017670: 2020 290a 2020 2020 2020 2020 290a 2020    ).        ).  
+00017680: 2020 2020 2020 666f 7220 765f 6672 6f6d        for v_from
+00017690: 2c20 765f 746f 2069 6e20 7a69 7028 0a20  , v_to in zip(. 
+000176a0: 2020 2020 2020 2020 2020 2077 6f72 6b69             worki
+000176b0: 6e67 5f6d 6f64 656c 5f76 6172 6961 626c  ng_model_variabl
+000176c0: 655f 6c69 7374 2c20 6f72 6967 696e 616c  e_list, original
+000176d0: 5f6d 6f64 656c 5f76 6172 6961 626c 655f  _model_variable_
+000176e0: 6c69 7374 0a20 2020 2020 2020 2029 3a0a  list.        ):.
+000176f0: 2020 2020 2020 2020 2020 2020 6966 2076              if v
+00017700: 5f66 726f 6d2e 6e61 6d65 2021 3d20 765f  _from.name != v_
+00017710: 746f 2e6e 616d 653a 0a20 2020 2020 2020  to.name:.       
+00017720: 2020 2020 2020 2020 2072 6169 7365 2044           raise D
+00017730: 6576 656c 6f70 6572 4572 726f 7228 0a20  eveloperError(. 
+00017740: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017750: 2020 2027 5468 6520 6e61 6d65 206f 6620     'The name of 
+00017760: 7468 6520 7477 6f20 7661 7269 6162 6c65  the two variable
+00017770: 7320 6973 206e 6f74 2074 6865 2073 616d  s is not the sam
+00017780: 652e 204c 6f61 6469 6e67 2066 696e 616c  e. Loading final
+00017790: 2073 6f6c 7574 696f 6e27 0a20 2020 2020   solution'.     
+000177a0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+000177b0: 2020 2020 2063 6f70 795f 7661 725f 6c69       copy_var_li
+000177c0: 7374 5f76 616c 7565 7328 0a20 2020 2020  st_values(.     
+000177d0: 2020 2020 2020 2077 6f72 6b69 6e67 5f6d         working_m
+000177e0: 6f64 656c 5f76 6172 6961 626c 655f 6c69  odel_variable_li
+000177f0: 7374 2c20 6f72 6967 696e 616c 5f6d 6f64  st, original_mod
+00017800: 656c 5f76 6172 6961 626c 655f 6c69 7374  el_variable_list
+00017810: 2c20 636f 6e66 6967 3d63 6f6e 6669 670a  , config=config.
+00017820: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+00017830: 6566 2063 6865 636b 5f73 7562 736f 6c76  ef check_subsolv
+00017840: 6572 5f76 616c 6964 6974 7928 7365 6c66  er_validity(self
+00017850: 293a 0a20 2020 2020 2020 2022 2222 4368  ):.        """Ch
+00017860: 6563 6b20 6966 2074 6865 2073 7562 736f  eck if the subso
+00017870: 6c76 6572 7320 6172 6520 6176 6169 6c61  lvers are availa
+00017880: 626c 6520 616e 6420 6c69 6365 6e73 6564  ble and licensed
+00017890: 2e22 2222 0a20 2020 2020 2020 2069 6620  .""".        if 
+000178a0: 6e6f 7420 7365 6c66 2e6d 6970 5f6f 7074  not self.mip_opt
+000178b0: 2e61 7661 696c 6162 6c65 2829 3a0a 2020  .available():.  
+000178c0: 2020 2020 2020 2020 2020 7261 6973 6520            raise 
+000178d0: 5661 6c75 6545 7272 6f72 2873 656c 662e  ValueError(self.
+000178e0: 636f 6e66 6967 2e6d 6970 5f73 6f6c 7665  config.mip_solve
+000178f0: 7220 2b20 2720 6973 206e 6f74 2061 7661  r + ' is not ava
+00017900: 696c 6162 6c65 2e27 290a 2020 2020 2020  ilable.').      
+00017910: 2020 6966 206e 6f74 2073 656c 662e 6d69    if not self.mi
+00017920: 705f 6f70 742e 6c69 6365 6e73 655f 6973  p_opt.license_is
+00017930: 5f76 616c 6964 2829 3a0a 2020 2020 2020  _valid():.      
+00017940: 2020 2020 2020 7261 6973 6520 5661 6c75        raise Valu
+00017950: 6545 7272 6f72 2873 656c 662e 636f 6e66  eError(self.conf
+00017960: 6967 2e6d 6970 5f73 6f6c 7665 7220 2b20  ig.mip_solver + 
+00017970: 2720 6973 206e 6f74 206c 6963 656e 7365  ' is not license
+00017980: 642e 2729 0a20 2020 2020 2020 2069 6620  d.').        if 
+00017990: 7365 6c66 2e63 6f6e 6669 672e 6d69 705f  self.config.mip_
+000179a0: 736f 6c76 6572 203d 3d20 2261 7070 7369  solver == "appsi
+000179b0: 5f68 6967 6873 223a 0a20 2020 2020 2020  _highs":.       
+000179c0: 2020 2020 2069 6620 7365 6c66 2e6d 6970       if self.mip
+000179d0: 5f6f 7074 2e76 6572 7369 6f6e 2829 203c  _opt.version() <
+000179e0: 2028 312c 2037 2c20 3029 3a0a 2020 2020   (1, 7, 0):.    
+000179f0: 2020 2020 2020 2020 2020 2020 7261 6973              rais
+00017a00: 6520 5661 6c75 6545 7272 6f72 280a 2020  e ValueError(.  
+00017a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017a20: 2020 224d 696e 6474 5079 2072 6571 7569    "MindtPy requi
+00017a30: 7265 7320 7468 6520 7573 6520 6f66 2048  res the use of H
+00017a40: 4947 4853 2076 6572 7369 6f6e 2031 2e37  IGHS version 1.7
+00017a50: 2e30 206f 7220 6869 6768 6572 2066 6f72  .0 or higher for
+00017a60: 2066 756c 6c20 636f 6d70 6174 6962 696c   full compatibil
+00017a70: 6974 792e 220a 2020 2020 2020 2020 2020  ity.".          
+00017a80: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+00017a90: 6966 206e 6f74 2073 656c 662e 6e6c 705f  if not self.nlp_
+00017aa0: 6f70 742e 6176 6169 6c61 626c 6528 293a  opt.available():
+00017ab0: 0a20 2020 2020 2020 2020 2020 2072 6169  .            rai
+00017ac0: 7365 2056 616c 7565 4572 726f 7228 7365  se ValueError(se
+00017ad0: 6c66 2e63 6f6e 6669 672e 6e6c 705f 736f  lf.config.nlp_so
+00017ae0: 6c76 6572 202b 2027 2069 7320 6e6f 7420  lver + ' is not 
+00017af0: 6176 6169 6c61 626c 652e 2729 0a20 2020  available.').   
+00017b00: 2020 2020 2069 6620 6e6f 7420 7365 6c66       if not self
+00017b10: 2e6e 6c70 5f6f 7074 2e6c 6963 656e 7365  .nlp_opt.license
+00017b20: 5f69 735f 7661 6c69 6428 293a 0a20 2020  _is_valid():.   
+00017b30: 2020 2020 2020 2020 2072 6169 7365 2056           raise V
+00017b40: 616c 7565 4572 726f 7228 7365 6c66 2e63  alueError(self.c
+00017b50: 6f6e 6669 672e 6e6c 705f 736f 6c76 6572  onfig.nlp_solver
+00017b60: 202b 2027 2069 7320 6e6f 7420 6c69 6365   + ' is not lice
+00017b70: 6e73 6564 2e27 290a 2020 2020 2020 2020  nsed.').        
+00017b80: 6966 2073 656c 662e 636f 6e66 6967 2e61  if self.config.a
+00017b90: 6464 5f72 6567 756c 6172 697a 6174 696f  dd_regularizatio
+00017ba0: 6e20 6973 206e 6f74 204e 6f6e 653a 0a20  n is not None:. 
+00017bb0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00017bc0: 7420 7365 6c66 2e72 6567 756c 6172 697a  t self.regulariz
+00017bd0: 6174 696f 6e5f 6d69 705f 6f70 742e 6176  ation_mip_opt.av
+00017be0: 6169 6c61 626c 6528 293a 0a20 2020 2020  ailable():.     
+00017bf0: 2020 2020 2020 2020 2020 2072 6169 7365             raise
+00017c00: 2056 616c 7565 4572 726f 7228 0a20 2020   ValueError(.   
+00017c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00017c20: 2073 656c 662e 636f 6e66 6967 2e6d 6970   self.config.mip
+00017c30: 5f72 6567 756c 6172 697a 6174 696f 6e5f  _regularization_
+00017c40: 736f 6c76 6572 202b 2027 2069 7320 6e6f  solver + ' is no
+00017c50: 7420 6176 6169 6c61 626c 652e 270a 2020  t available.'.  
+00017c60: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00017c70: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+00017c80: 6f74 2073 656c 662e 7265 6775 6c61 7269  ot self.regulari
+00017c90: 7a61 7469 6f6e 5f6d 6970 5f6f 7074 2e6c  zation_mip_opt.l
+00017ca0: 6963 656e 7365 5f69 735f 7661 6c69 6428  icense_is_valid(
+00017cb0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00017cc0: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+00017cd0: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+00017ce0: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
+00017cf0: 6e66 6967 2e6d 6970 5f72 6567 756c 6172  nfig.mip_regular
+00017d00: 697a 6174 696f 6e5f 736f 6c76 6572 202b  ization_solver +
+00017d10: 2027 2069 7320 6e6f 7420 6c69 6365 6e73   ' is not licens
+00017d20: 6564 2e27 0a20 2020 2020 2020 2020 2020  ed.'.           
+00017d30: 2020 2020 2029 0a0a 2020 2020 6465 6620       )..    def 
+00017d40: 6368 6563 6b5f 636f 6e66 6967 2873 656c  check_config(sel
+00017d50: 6629 3a0a 2020 2020 2020 2020 2222 2243  f):.        """C
+00017d60: 6865 636b 7320 6966 2074 6865 2063 6f6e  hecks if the con
+00017d70: 6669 6775 7261 7469 6f6e 206f 7074 696f  figuration optio
+00017d80: 6e73 206d 616b 6520 7365 6e73 652e 2222  ns make sense.""
+00017d90: 220a 2020 2020 2020 2020 636f 6e66 6967  ".        config
+00017da0: 203d 2073 656c 662e 636f 6e66 6967 0a20   = self.config. 
+00017db0: 2020 2020 2020 2023 2063 6f6e 6669 6775         # configu
+00017dc0: 7261 7469 6f6e 2063 6f6e 6669 726d 6174  ration confirmat
+00017dd0: 696f 6e0a 2020 2020 2020 2020 6966 2063  ion.        if c
+00017de0: 6f6e 6669 672e 696e 6974 5f73 7472 6174  onfig.init_strat
+00017df0: 6567 7920 3d3d 2027 4650 273a 0a20 2020  egy == 'FP':.   
+00017e00: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00017e10: 6164 645f 6e6f 5f67 6f6f 645f 6375 7473  add_no_good_cuts
+00017e20: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
+00017e30: 2020 2020 636f 6e66 6967 2e75 7365 5f74      config.use_t
+00017e40: 6162 755f 6c69 7374 203d 2046 616c 7365  abu_list = False
+00017e50: 0a0a 2020 2020 2020 2020 6966 2063 6f6e  ..        if con
+00017e60: 6669 672e 6e6c 705f 736f 6c76 6572 203d  fig.nlp_solver =
+00017e70: 3d20 2762 6172 6f6e 273a 0a20 2020 2020  = 'baron':.     
+00017e80: 2020 2020 2020 2063 6f6e 6669 672e 6571         config.eq
+00017e90: 7561 6c69 7479 5f72 656c 6178 6174 696f  uality_relaxatio
+00017ea0: 6e20 3d20 4661 6c73 650a 2020 2020 2020  n = False.      
+00017eb0: 2020 6966 2063 6f6e 6669 672e 6e6c 705f    if config.nlp_
+00017ec0: 736f 6c76 6572 203d 3d20 2767 616d 7327  solver == 'gams'
+00017ed0: 2061 6e64 2063 6f6e 6669 672e 6e6c 705f   and config.nlp_
+00017ee0: 736f 6c76 6572 2e5f 5f63 6f6e 7461 696e  solver.__contain
+00017ef0: 735f 5f28 2773 6f6c 7665 7227 293a 0a20  s__('solver'):. 
+00017f00: 2020 2020 2020 2020 2020 2069 6620 636f             if co
+00017f10: 6e66 6967 2e6e 6c70 5f73 6f6c 7665 725f  nfig.nlp_solver_
+00017f20: 6172 6773 5b27 736f 6c76 6572 275d 203d  args['solver'] =
+00017f30: 3d20 2762 6172 6f6e 273a 0a20 2020 2020  = 'baron':.     
+00017f40: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+00017f50: 672e 6571 7561 6c69 7479 5f72 656c 6178  g.equality_relax
+00017f60: 6174 696f 6e20 3d20 4661 6c73 650a 0a20  ation = False.. 
+00017f70: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
+00017f80: 2e73 6f6c 7665 725f 7465 653a 0a20 2020  .solver_tee:.   
+00017f90: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00017fa0: 6d69 705f 736f 6c76 6572 5f74 6565 203d  mip_solver_tee =
+00017fb0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+00017fc0: 2020 636f 6e66 6967 2e6e 6c70 5f73 6f6c    config.nlp_sol
+00017fd0: 7665 725f 7465 6520 3d20 5472 7565 0a20  ver_tee = True. 
+00017fe0: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
+00017ff0: 2e61 6464 5f6e 6f5f 676f 6f64 5f63 7574  .add_no_good_cut
+00018000: 733a 0a20 2020 2020 2020 2020 2020 2063  s:.            c
+00018010: 6f6e 6669 672e 696e 7465 6765 725f 746f  onfig.integer_to
+00018020: 5f62 696e 6172 7920 3d20 5472 7565 0a20  _binary = True. 
+00018030: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
+00018040: 2e75 7365 5f74 6162 755f 6c69 7374 3a0a  .use_tabu_list:.
+00018050: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
+00018060: 6967 2e6d 6970 5f73 6f6c 7665 7220 3d20  ig.mip_solver = 
+00018070: 2763 706c 6578 5f70 6572 7369 7374 656e  'cplex_persisten
+00018080: 7427 0a20 2020 2020 2020 2020 2020 2069  t'.            i
+00018090: 6620 636f 6e66 6967 2e74 6872 6561 6473  f config.threads
+000180a0: 203e 2031 3a0a 2020 2020 2020 2020 2020   > 1:.          
+000180b0: 2020 2020 2020 636f 6e66 6967 2e74 6872        config.thr
+000180c0: 6561 6473 203d 2031 0a20 2020 2020 2020  eads = 1.       
+000180d0: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+000180e0: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+000180f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018100: 2027 5468 6520 7468 7265 6164 7320 7061   'The threads pa
+00018110: 7261 6d65 7465 7220 6973 2063 6f72 7265  rameter is corre
+00018120: 6374 6564 2074 6f20 3120 7369 6e63 6520  cted to 1 since 
+00018130: 696e 6375 6d62 656e 7420 6361 6c6c 6261  incumbent callba
+00018140: 636b 2063 6f6e 666c 6963 7473 2077 6974  ck conflicts wit
+00018150: 6820 6d75 6c74 692d 7468 7265 6164 7320  h multi-threads 
+00018160: 6d6f 6465 2e27 0a20 2020 2020 2020 2020  mode.'.         
+00018170: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00018180: 2069 6620 636f 6e66 6967 2e73 6f6c 7574   if config.solut
+00018190: 696f 6e5f 706f 6f6c 3a0a 2020 2020 2020  ion_pool:.      
+000181a0: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+000181b0: 6d69 705f 736f 6c76 6572 206e 6f74 2069  mip_solver not i
+000181c0: 6e20 7b27 6370 6c65 785f 7065 7273 6973  n {'cplex_persis
+000181d0: 7465 6e74 272c 2027 6775 726f 6269 5f70  tent', 'gurobi_p
+000181e0: 6572 7369 7374 656e 7427 7d3a 0a20 2020  ersistent'}:.   
+000181f0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00018200: 636f 6e66 6967 2e6d 6970 5f73 6f6c 7665  config.mip_solve
+00018210: 7220 696e 207b 2761 7070 7369 5f63 706c  r in {'appsi_cpl
+00018220: 6578 272c 2027 6170 7073 695f 6775 726f  ex', 'appsi_guro
+00018230: 6269 277d 3a0a 2020 2020 2020 2020 2020  bi'}:.          
+00018240: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+00018250: 2e6c 6f67 6765 722e 696e 666f 2822 536f  .logger.info("So
+00018260: 6c75 7469 6f6e 2070 6f6f 6c20 646f 6573  lution pool does
+00018270: 206e 6f74 2073 7570 706f 7274 2041 5050   not support APP
+00018280: 5349 2073 6f6c 7665 722e 2229 0a20 2020  SI solver.").   
+00018290: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+000182a0: 6669 672e 6d69 705f 736f 6c76 6572 203d  fig.mip_solver =
+000182b0: 2027 6370 6c65 785f 7065 7273 6973 7465   'cplex_persiste
+000182c0: 6e74 270a 0a20 2020 2020 2020 2023 2072  nt'..        # r
+000182d0: 656c 6174 6564 2074 6f20 6874 7470 733a  elated to https:
+000182e0: 2f2f 6769 7468 7562 2e63 6f6d 2f50 796f  //github.com/Pyo
+000182f0: 6d6f 2f70 796f 6d6f 2f69 7373 7565 732f  mo/pyomo/issues/
+00018300: 3233 3633 0a20 2020 2020 2020 2069 6620  2363.        if 
+00018310: 2761 7070 7369 2720 696e 2063 6f6e 6669  'appsi' in confi
+00018320: 672e 6d69 705f 736f 6c76 6572 3a0a 2020  g.mip_solver:.  
+00018330: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+00018340: 6970 5f6c 6f61 645f 736f 6c75 7469 6f6e  ip_load_solution
+00018350: 7320 3d20 4661 6c73 650a 2020 2020 2020  s = False.      
+00018360: 2020 6966 2027 6170 7073 6927 2069 6e20    if 'appsi' in 
+00018370: 636f 6e66 6967 2e6e 6c70 5f73 6f6c 7665  config.nlp_solve
+00018380: 723a 0a20 2020 2020 2020 2020 2020 2073  r:.            s
+00018390: 656c 662e 6e6c 705f 6c6f 6164 5f73 6f6c  elf.nlp_load_sol
+000183a0: 7574 696f 6e73 203d 2046 616c 7365 0a20  utions = False. 
+000183b0: 2020 2020 2020 2069 6620 280a 2020 2020         if (.    
+000183c0: 2020 2020 2020 2020 636f 6e66 6967 2e6d          config.m
+000183d0: 6970 5f72 6567 756c 6172 697a 6174 696f  ip_regularizatio
+000183e0: 6e5f 736f 6c76 6572 2069 7320 6e6f 7420  n_solver is not 
+000183f0: 4e6f 6e65 0a20 2020 2020 2020 2020 2020  None.           
+00018400: 2061 6e64 2027 6170 7073 6927 2069 6e20   and 'appsi' in 
+00018410: 636f 6e66 6967 2e6d 6970 5f72 6567 756c  config.mip_regul
+00018420: 6172 697a 6174 696f 6e5f 736f 6c76 6572  arization_solver
+00018430: 0a20 2020 2020 2020 2029 3a0a 2020 2020  .        ):.    
+00018440: 2020 2020 2020 2020 7365 6c66 2e72 6567          self.reg
+00018450: 756c 6172 697a 6174 696f 6e5f 6d69 705f  ularization_mip_
+00018460: 6c6f 6164 5f73 6f6c 7574 696f 6e73 203d  load_solutions =
+00018470: 2046 616c 7365 0a0a 2020 2020 2323 2323   False..    ####
+00018480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000184f0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+00018500: 2023 2046 6561 7369 6269 6c69 7479 2050   # Feasibility P
+00018510: 756d 700a 0a20 2020 2064 6566 2073 6f6c  ump..    def sol
+00018520: 7665 5f66 705f 7375 6270 726f 626c 656d  ve_fp_subproblem
+00018530: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
+00018540: 2222 2253 6f6c 7665 7320 7468 6520 6665  """Solves the fe
+00018550: 6173 6962 696c 6974 7920 7075 6d70 204e  asibility pump N
+00018560: 4c50 2073 7562 7072 6f62 6c65 6d2e 0a0a  LP subproblem...
+00018570: 2020 2020 2020 2020 5468 6973 2066 756e          This fun
+00018580: 6374 696f 6e20 7365 7473 2075 7020 7468  ction sets up th
+00018590: 6520 2766 705f 6e6c 7027 2062 7920 7265  e 'fp_nlp' by re
+000185a0: 6c61 7820 696e 7465 6765 7220 7661 7269  lax integer vari
+000185b0: 6162 6c65 732e 0a20 2020 2020 2020 2070  ables..        p
+000185c0: 7265 636f 6d70 7574 6573 2064 7561 6c20  recomputes dual 
+000185d0: 7661 6c75 6573 2c20 6465 6163 7469 7661  values, deactiva
+000185e0: 7465 7320 7472 6976 6961 6c20 636f 6e73  tes trivial cons
+000185f0: 7472 6169 6e74 732c 2061 6e64 2074 6865  traints, and the
+00018600: 6e20 736f 6c76 6573 204e 4c50 206d 6f64  n solves NLP mod
+00018610: 656c 2e0a 0a20 2020 2020 2020 2052 6574  el...        Ret
+00018620: 7572 6e73 0a20 2020 2020 2020 202d 2d2d  urns.        ---
+00018630: 2d2d 2d2d 0a20 2020 2020 2020 2066 705f  ----.        fp_
+00018640: 6e6c 7020 3a20 5079 6f6d 6f20 6d6f 6465  nlp : Pyomo mode
+00018650: 6c0a 2020 2020 2020 2020 2020 2020 4669  l.            Fi
+00018660: 7865 642d 4e4c 5020 6672 6f6d 2074 6865  xed-NLP from the
+00018670: 206d 6f64 656c 2e0a 2020 2020 2020 2020   model..        
+00018680: 7265 7375 6c74 7320 3a20 536f 6c76 6572  results : Solver
+00018690: 5265 7375 6c74 730a 2020 2020 2020 2020  Results.        
+000186a0: 2020 2020 5265 7375 6c74 7320 6672 6f6d      Results from
+000186b0: 2073 6f6c 7669 6e67 2074 6865 2066 6978   solving the fix
+000186c0: 6564 2d4e 4c50 2073 7562 7072 6f62 6c65  ed-NLP subproble
+000186d0: 6d2e 0a20 2020 2020 2020 2022 2222 0a20  m..        """. 
+000186e0: 2020 2020 2020 2066 705f 6e6c 7020 3d20         fp_nlp = 
+000186f0: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
+00018700: 656c 2e63 6c6f 6e65 2829 0a20 2020 2020  el.clone().     
+00018710: 2020 204d 696e 6474 5079 203d 2066 705f     MindtPy = fp_
+00018720: 6e6c 702e 4d69 6e64 7450 795f 7574 696c  nlp.MindtPy_util
+00018730: 730a 2020 2020 2020 2020 636f 6e66 6967  s.        config
+00018740: 203d 2073 656c 662e 636f 6e66 6967 0a0a   = self.config..
+00018750: 2020 2020 2020 2020 2320 5365 7420 7570          # Set up
+00018760: 204e 4c50 0a20 2020 2020 2020 2066 705f   NLP.        fp_
+00018770: 6e6c 702e 4d69 6e64 7450 795f 7574 696c  nlp.MindtPy_util
+00018780: 732e 6f62 6a65 6374 6976 655f 6c69 7374  s.objective_list
+00018790: 5b2d 315d 2e64 6561 6374 6976 6174 6528  [-1].deactivate(
+000187a0: 290a 2020 2020 2020 2020 6966 2073 656c  ).        if sel
+000187b0: 662e 6f62 6a65 6374 6976 655f 7365 6e73  f.objective_sens
+000187c0: 6520 3d3d 206d 696e 696d 697a 653a 0a20  e == minimize:. 
+000187d0: 2020 2020 2020 2020 2020 2066 705f 6e6c             fp_nl
+000187e0: 702e 696d 7072 6f76 696e 675f 6f62 6a65  p.improving_obje
+000187f0: 6374 6976 655f 6375 7420 3d20 436f 6e73  ctive_cut = Cons
+00018800: 7472 6169 6e74 280a 2020 2020 2020 2020  traint(.        
+00018810: 2020 2020 2020 2020 6578 7072 3d73 756d          expr=sum
+00018820: 2866 705f 6e6c 702e 4d69 6e64 7450 795f  (fp_nlp.MindtPy_
+00018830: 7574 696c 732e 6f62 6a65 6374 6976 655f  utils.objective_
+00018840: 7661 6c75 655b 3a5d 2920 3c3d 2073 656c  value[:]) <= sel
+00018850: 662e 7072 696d 616c 5f62 6f75 6e64 0a20  f.primal_bound. 
+00018860: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00018870: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00018880: 2020 2020 2020 2066 705f 6e6c 702e 696d         fp_nlp.im
+00018890: 7072 6f76 696e 675f 6f62 6a65 6374 6976  proving_objectiv
+000188a0: 655f 6375 7420 3d20 436f 6e73 7472 6169  e_cut = Constrai
+000188b0: 6e74 280a 2020 2020 2020 2020 2020 2020  nt(.            
+000188c0: 2020 2020 6578 7072 3d73 756d 2866 705f      expr=sum(fp_
+000188d0: 6e6c 702e 4d69 6e64 7450 795f 7574 696c  nlp.MindtPy_util
+000188e0: 732e 6f62 6a65 6374 6976 655f 7661 6c75  s.objective_valu
+000188f0: 655b 3a5d 2920 3e3d 2073 656c 662e 7072  e[:]) >= self.pr
+00018900: 696d 616c 5f62 6f75 6e64 0a20 2020 2020  imal_bound.     
+00018910: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+00018920: 2020 2320 4164 6420 6e6f 726d 5f63 6f6e    # Add norm_con
+00018930: 7374 7261 696e 742c 2077 6869 6368 2067  straint, which g
+00018940: 7561 7261 6e74 6565 7320 7468 6520 6d6f  uarantees the mo
+00018950: 6e6f 746f 6e69 6369 7479 206f 6620 7468  notonicity of th
+00018960: 6520 6e6f 726d 206f 626a 6563 7469 7665  e norm objective
+00018970: 2076 616c 7565 2073 6571 7565 6e63 6520   value sequence 
+00018980: 6f66 2061 6c6c 2069 7465 7261 7469 6f6e  of all iteration
+00018990: 730a 2020 2020 2020 2020 2320 5265 663a  s.        # Ref:
+000189a0: 2050 6170 6572 2027 4120 7374 6f72 6d20   Paper 'A storm 
+000189b0: 6f66 2066 6561 7369 6269 6c69 7479 2070  of feasibility p
+000189c0: 756d 7073 2066 6f72 206e 6f6e 636f 6e76  umps for nonconv
+000189d0: 6578 204d 494e 4c50 2720 2020 6874 7470  ex MINLP'   http
+000189e0: 733a 2f2f 646f 692e 6f72 672f 3130 2e31  s://doi.org/10.1
+000189f0: 3030 372f 7331 3031 3037 2d30 3132 2d30  007/s10107-012-0
+00018a00: 3630 382d 780a 2020 2020 2020 2020 2320  608-x.        # 
+00018a10: 7468 6520 6e6f 726d 2074 7970 6520 6973  the norm type is
+00018a20: 2063 6f6e 7369 7374 656e 7420 7769 7468   consistent with
+00018a30: 2074 6865 206e 6f72 6d20 6f62 6a20 6f66   the norm obj of
+00018a40: 2074 6865 2046 502d 6d61 696e 2070 726f   the FP-main pro
+00018a50: 626c 656d 2e0a 2020 2020 2020 2020 6966  blem..        if
+00018a60: 2063 6f6e 6669 672e 6670 5f6e 6f72 6d5f   config.fp_norm_
+00018a70: 636f 6e73 7472 6169 6e74 3a0a 2020 2020  constraint:.    
+00018a80: 2020 2020 2020 2020 6765 6e65 7261 7465          generate
+00018a90: 5f6e 6f72 6d5f 636f 6e73 7472 6169 6e74  _norm_constraint
+00018aa0: 2866 705f 6e6c 702c 2073 656c 662e 6d69  (fp_nlp, self.mi
+00018ab0: 702c 2063 6f6e 6669 6729 0a0a 2020 2020  p, config)..    
+00018ac0: 2020 2020 4d69 6e64 7450 792e 6670 5f6e      MindtPy.fp_n
+00018ad0: 6c70 5f6f 626a 203d 2067 656e 6572 6174  lp_obj = generat
+00018ae0: 655f 6e6f 726d 3273 715f 6f62 6a65 6374  e_norm2sq_object
+00018af0: 6976 655f 6675 6e63 7469 6f6e 280a 2020  ive_function(.  
+00018b00: 2020 2020 2020 2020 2020 6670 5f6e 6c70            fp_nlp
+00018b10: 2c20 7365 6c66 2e6d 6970 2c20 6469 7363  , self.mip, disc
+00018b20: 7265 7465 5f6f 6e6c 793d 636f 6e66 6967  rete_only=config
+00018b30: 2e66 705f 6469 7363 7265 7465 5f6f 6e6c  .fp_discrete_onl
+00018b40: 790a 2020 2020 2020 2020 290a 0a20 2020  y.        )..   
+00018b50: 2020 2020 204d 696e 6474 5079 2e63 7574       MindtPy.cut
+00018b60: 732e 6465 6163 7469 7661 7465 2829 0a20  s.deactivate(). 
+00018b70: 2020 2020 2020 2054 7261 6e73 666f 726d         Transform
+00018b80: 6174 696f 6e46 6163 746f 7279 2827 636f  ationFactory('co
+00018b90: 7265 2e72 656c 6178 5f69 6e74 6567 6572  re.relax_integer
+00018ba0: 5f76 6172 7327 292e 6170 706c 795f 746f  _vars').apply_to
+00018bb0: 2866 705f 6e6c 7029 0a20 2020 2020 2020  (fp_nlp).       
+00018bc0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00018bd0: 2020 5472 616e 7366 6f72 6d61 7469 6f6e    Transformation
+00018be0: 4661 6374 6f72 7928 2763 6f6e 7472 6962  Factory('contrib
+00018bf0: 2e64 6561 6374 6976 6174 655f 7472 6976  .deactivate_triv
+00018c00: 6961 6c5f 636f 6e73 7472 6169 6e74 7327  ial_constraints'
+00018c10: 292e 6170 706c 795f 746f 280a 2020 2020  ).apply_to(.    
+00018c20: 2020 2020 2020 2020 2020 2020 6670 5f6e              fp_n
+00018c30: 6c70 2c0a 2020 2020 2020 2020 2020 2020  lp,.            
+00018c40: 2020 2020 746d 703d 5472 7565 2c0a 2020      tmp=True,.  
+00018c50: 2020 2020 2020 2020 2020 2020 2020 6967                ig
+00018c60: 6e6f 7265 5f69 6e66 6561 7369 626c 653d  nore_infeasible=
+00018c70: 4661 6c73 652c 0a20 2020 2020 2020 2020  False,.         
+00018c80: 2020 2020 2020 2074 6f6c 6572 616e 6365         tolerance
+00018c90: 3d63 6f6e 6669 672e 636f 6e73 7472 6169  =config.constrai
+00018ca0: 6e74 5f74 6f6c 6572 616e 6365 2c0a 2020  nt_tolerance,.  
+00018cb0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00018cc0: 2020 2020 6578 6365 7074 2049 6e66 6561      except Infea
+00018cd0: 7369 626c 6543 6f6e 7374 7261 696e 7445  sibleConstraintE
+00018ce0: 7863 6570 7469 6f6e 2061 7320 653a 0a20  xception as e:. 
+00018cf0: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+00018d00: 672e 6c6f 6767 6572 2e65 7272 6f72 2865  g.logger.error(e
+00018d10: 2c20 6578 635f 696e 666f 3d54 7275 6529  , exc_info=True)
+00018d20: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
+00018d30: 6669 672e 6c6f 6767 6572 2e65 7272 6f72  fig.logger.error
+00018d40: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+00018d50: 2020 2749 6e66 6561 7369 6269 6c69 7479    'Infeasibility
+00018d60: 2064 6574 6563 7465 6420 696e 2064 6561   detected in dea
+00018d70: 6374 6976 6174 655f 7472 6976 6961 6c5f  ctivate_trivial_
+00018d80: 636f 6e73 7472 6169 6e74 732e 270a 2020  constraints.'.  
+00018d90: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00018da0: 2020 2020 2020 2020 7265 7375 6c74 7320          results 
+00018db0: 3d20 536f 6c76 6572 5265 7375 6c74 7328  = SolverResults(
+00018dc0: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+00018dd0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+00018de0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+00018df0: 6f6e 203d 2074 632e 696e 6665 6173 6962  on = tc.infeasib
+00018e00: 6c65 0a20 2020 2020 2020 2020 2020 2072  le.            r
+00018e10: 6574 7572 6e20 6670 5f6e 6c70 2c20 7265  eturn fp_nlp, re
+00018e20: 7375 6c74 730a 2020 2020 2020 2020 2320  sults.        # 
+00018e30: 536f 6c76 6520 7468 6520 4e4c 500a 2020  Solve the NLP.  
+00018e40: 2020 2020 2020 6e6c 705f 6172 6773 203d        nlp_args =
+00018e50: 2064 6963 7428 636f 6e66 6967 2e6e 6c70   dict(config.nlp
+00018e60: 5f73 6f6c 7665 725f 6172 6773 290a 2020  _solver_args).  
+00018e70: 2020 2020 2020 7570 6461 7465 5f73 6f6c        update_sol
+00018e80: 7665 725f 7469 6d65 6c69 6d69 7428 7365  ver_timelimit(se
+00018e90: 6c66 2e6e 6c70 5f6f 7074 2c20 636f 6e66  lf.nlp_opt, conf
+00018ea0: 6967 2e6e 6c70 5f73 6f6c 7665 722c 2073  ig.nlp_solver, s
+00018eb0: 656c 662e 7469 6d69 6e67 2c20 636f 6e66  elf.timing, conf
+00018ec0: 6967 290a 2020 2020 2020 2020 7769 7468  ig).        with
+00018ed0: 2053 7570 7072 6573 7349 6e66 6561 7369   SuppressInfeasi
+00018ee0: 626c 6557 6172 6e69 6e67 2829 3a0a 2020  bleWarning():.  
+00018ef0: 2020 2020 2020 2020 2020 7769 7468 2074            with t
+00018f00: 696d 655f 636f 6465 2873 656c 662e 7469  ime_code(self.ti
+00018f10: 6d69 6e67 2c20 2766 7020 7375 6270 726f  ming, 'fp subpro
+00018f20: 626c 656d 2729 3a0a 2020 2020 2020 2020  blem'):.        
+00018f30: 2020 2020 2020 2020 7265 7375 6c74 7320          results 
+00018f40: 3d20 7365 6c66 2e6e 6c70 5f6f 7074 2e73  = self.nlp_opt.s
+00018f50: 6f6c 7665 280a 2020 2020 2020 2020 2020  olve(.          
+00018f60: 2020 2020 2020 2020 2020 6670 5f6e 6c70            fp_nlp
+00018f70: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00018f80: 2020 2020 2020 7465 653d 636f 6e66 6967        tee=config
+00018f90: 2e6e 6c70 5f73 6f6c 7665 725f 7465 652c  .nlp_solver_tee,
+00018fa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00018fb0: 2020 2020 206c 6f61 645f 736f 6c75 7469       load_soluti
+00018fc0: 6f6e 733d 7365 6c66 2e6e 6c70 5f6c 6f61  ons=self.nlp_loa
+00018fd0: 645f 736f 6c75 7469 6f6e 732c 0a20 2020  d_solutions,.   
+00018fe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018ff0: 202a 2a6e 6c70 5f61 7267 732c 0a20 2020   **nlp_args,.   
+00019000: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00019010: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00019020: 6620 6c65 6e28 7265 7375 6c74 732e 736f  f len(results.so
+00019030: 6c75 7469 6f6e 2920 3e20 303a 0a20 2020  lution) > 0:.   
+00019040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019050: 2066 705f 6e6c 702e 736f 6c75 7469 6f6e   fp_nlp.solution
+00019060: 732e 6c6f 6164 5f66 726f 6d28 7265 7375  s.load_from(resu
+00019070: 6c74 7329 0a20 2020 2020 2020 2072 6574  lts).        ret
+00019080: 7572 6e20 6670 5f6e 6c70 2c20 7265 7375  urn fp_nlp, resu
+00019090: 6c74 730a 0a20 2020 2064 6566 2068 616e  lts..    def han
+000190a0: 646c 655f 6670 5f73 7562 7072 6f62 6c65  dle_fp_subproble
+000190b0: 6d5f 6f70 7469 6d61 6c28 7365 6c66 2c20  m_optimal(self, 
+000190c0: 6670 5f6e 6c70 293a 0a20 2020 2020 2020  fp_nlp):.       
+000190d0: 2022 2222 436f 7069 6573 2074 6865 2073   """Copies the s
+000190e0: 6f6c 7574 696f 6e20 746f 2074 6865 2077  olution to the w
+000190f0: 6f72 6b69 6e67 206d 6f64 656c 2c20 7570  orking model, up
+00019100: 6461 7465 7320 626f 756e 642c 2061 6464  dates bound, add
+00019110: 7320 4f41 2063 7574 7320 2f20 6e6f 2d67  s OA cuts / no-g
+00019120: 6f6f 6420 6375 7473 202f 0a20 2020 2020  ood cuts /.     
+00019130: 2020 2069 6e63 7265 6173 696e 6720 6f62     increasing ob
+00019140: 6a65 6374 6976 6520 6375 742c 2063 616c  jective cut, cal
+00019150: 6375 6c61 7465 7320 7468 6520 6475 616c  culates the dual
+00019160: 7320 616e 6420 7374 6f72 6573 2069 6e63  s and stores inc
+00019170: 756d 6265 6e74 2073 6f6c 7574 696f 6e20  umbent solution 
+00019180: 6966 2069 7420 6861 7320 6265 656e 2069  if it has been i
+00019190: 6d70 726f 7665 642e 0a0a 2020 2020 2020  mproved...      
+000191a0: 2020 5061 7261 6d65 7465 7273 0a20 2020    Parameters.   
+000191b0: 2020 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a       ----------.
+000191c0: 2020 2020 2020 2020 6670 5f6e 6c70 203a          fp_nlp :
+000191d0: 2050 796f 6d6f 206d 6f64 656c 0a20 2020   Pyomo model.   
+000191e0: 2020 2020 2020 2020 2054 6865 2066 6561           The fea
+000191f0: 7369 6269 6c69 7479 2070 756d 7020 4e4c  sibility pump NL
+00019200: 5020 7375 6270 726f 626c 656d 2e0a 2020  P subproblem..  
+00019210: 2020 2020 2020 2222 220a 2020 2020 2020        """.      
+00019220: 2020 636f 7079 5f76 6172 5f6c 6973 745f    copy_var_list_
+00019230: 7661 6c75 6573 280a 2020 2020 2020 2020  values(.        
+00019240: 2020 2020 6670 5f6e 6c70 2e4d 696e 6474      fp_nlp.Mindt
+00019250: 5079 5f75 7469 6c73 2e76 6172 6961 626c  Py_utils.variabl
+00019260: 655f 6c69 7374 2c0a 2020 2020 2020 2020  e_list,.        
+00019270: 2020 2020 7365 6c66 2e77 6f72 6b69 6e67      self.working
+00019280: 5f6d 6f64 656c 2e4d 696e 6474 5079 5f75  _model.MindtPy_u
+00019290: 7469 6c73 2e76 6172 6961 626c 655f 6c69  tils.variable_li
+000192a0: 7374 2c0a 2020 2020 2020 2020 2020 2020  st,.            
+000192b0: 7365 6c66 2e63 6f6e 6669 672c 0a20 2020  self.config,.   
+000192c0: 2020 2020 2020 2020 2069 676e 6f72 655f           ignore_
+000192d0: 696e 7465 6772 616c 6974 793d 5472 7565  integrality=True
+000192e0: 2c0a 2020 2020 2020 2020 290a 2020 2020  ,.        ).    
+000192f0: 2020 2020 6164 645f 6f72 7468 6f67 6f6e      add_orthogon
+00019300: 616c 6974 795f 6375 7473 2873 656c 662e  ality_cuts(self.
+00019310: 776f 726b 696e 675f 6d6f 6465 6c2c 2073  working_model, s
+00019320: 656c 662e 6d69 702c 2073 656c 662e 636f  elf.mip, self.co
+00019330: 6e66 6967 290a 0a20 2020 2020 2020 2023  nfig)..        #
+00019340: 2069 6620 4f41 2d6c 696b 6520 6f72 2066   if OA-like or f
+00019350: 7020 636f 6e76 6572 6765 642c 2075 7064  p converged, upd
+00019360: 6174 6520 5570 7065 7220 626f 756e 642c  ate Upper bound,
+00019370: 0a20 2020 2020 2020 2023 2061 6464 206e  .        # add n
+00019380: 6f5f 676f 6f64 2063 7574 7320 616e 6420  o_good cuts and 
+00019390: 696e 6372 6561 7369 6e67 206f 626a 6563  increasing objec
+000193a0: 7469 7665 2063 7574 7320 2866 7029 0a20  tive cuts (fp). 
+000193b0: 2020 2020 2020 2069 6620 6670 5f63 6f6e         if fp_con
+000193c0: 7665 7267 6564 280a 2020 2020 2020 2020  verged(.        
+000193d0: 2020 2020 7365 6c66 2e77 6f72 6b69 6e67      self.working
+000193e0: 5f6d 6f64 656c 2c0a 2020 2020 2020 2020  _model,.        
+000193f0: 2020 2020 7365 6c66 2e6d 6970 2c0a 2020      self.mip,.  
+00019400: 2020 2020 2020 2020 2020 7072 6f6a 5f7a            proj_z
+00019410: 6572 6f5f 746f 6c65 7261 6e63 653d 7365  ero_tolerance=se
+00019420: 6c66 2e63 6f6e 6669 672e 6670 5f70 726f  lf.config.fp_pro
+00019430: 6a7a 6572 6f74 6f6c 2c0a 2020 2020 2020  jzerotol,.      
+00019440: 2020 2020 2020 6469 7363 7265 7465 5f6f        discrete_o
+00019450: 6e6c 793d 7365 6c66 2e63 6f6e 6669 672e  nly=self.config.
+00019460: 6670 5f64 6973 6372 6574 655f 6f6e 6c79  fp_discrete_only
+00019470: 2c0a 2020 2020 2020 2020 293a 0a20 2020  ,.        ):.   
+00019480: 2020 2020 2020 2020 2063 6f70 795f 7661           copy_va
+00019490: 725f 6c69 7374 5f76 616c 7565 7328 0a20  r_list_values(. 
+000194a0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000194b0: 656c 662e 6d69 702e 4d69 6e64 7450 795f  elf.mip.MindtPy_
+000194c0: 7574 696c 732e 7661 7269 6162 6c65 5f6c  utils.variable_l
+000194d0: 6973 742c 0a20 2020 2020 2020 2020 2020  ist,.           
+000194e0: 2020 2020 2073 656c 662e 6669 7865 645f       self.fixed_
+000194f0: 6e6c 702e 4d69 6e64 7450 795f 7574 696c  nlp.MindtPy_util
+00019500: 732e 7661 7269 6162 6c65 5f6c 6973 742c  s.variable_list,
+00019510: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019520: 2073 656c 662e 636f 6e66 6967 2c0a 2020   self.config,.  
+00019530: 2020 2020 2020 2020 2020 2020 2020 736b                sk
+00019540: 6970 5f66 6978 6564 3d46 616c 7365 2c0a  ip_fixed=False,.
+00019550: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
+00019560: 2020 2020 2020 2020 2020 6669 7865 645f            fixed_
+00019570: 6e6c 702c 2066 6978 6564 5f6e 6c70 5f72  nlp, fixed_nlp_r
+00019580: 6573 756c 7473 203d 2073 656c 662e 736f  esults = self.so
+00019590: 6c76 655f 7375 6270 726f 626c 656d 2829  lve_subproblem()
+000195a0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000195b0: 6669 7865 645f 6e6c 705f 7265 7375 6c74  fixed_nlp_result
+000195c0: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+000195d0: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 2069  tion_condition i
+000195e0: 6e20 7b0a 2020 2020 2020 2020 2020 2020  n {.            
+000195f0: 2020 2020 7463 2e6f 7074 696d 616c 2c0a      tc.optimal,.
+00019600: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019610: 7463 2e6c 6f63 616c 6c79 4f70 7469 6d61  tc.locallyOptima
+00019620: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
+00019630: 2020 2074 632e 6665 6173 6962 6c65 2c0a     tc.feasible,.
+00019640: 2020 2020 2020 2020 2020 2020 7d3a 0a20              }:. 
+00019650: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00019660: 656c 662e 6861 6e64 6c65 5f73 7562 7072  elf.handle_subpr
+00019670: 6f62 6c65 6d5f 6f70 7469 6d61 6c28 6669  oblem_optimal(fi
+00019680: 7865 645f 6e6c 7029 0a20 2020 2020 2020  xed_nlp).       
+00019690: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+000196a0: 2e70 7269 6d61 6c5f 626f 756e 645f 696d  .primal_bound_im
+000196b0: 7072 6f76 6564 3a0a 2020 2020 2020 2020  proved:.        
+000196c0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000196d0: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
+000196e0: 6c73 2e63 7574 732e 6465 6c5f 636f 6d70  ls.cuts.del_comp
+000196f0: 6f6e 656e 7428 2769 6d70 726f 7669 6e67  onent('improving
+00019700: 5f6f 626a 6563 7469 7665 5f63 7574 2729  _objective_cut')
+00019710: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00019720: 2020 2020 2069 6620 7365 6c66 2e6f 626a       if self.obj
+00019730: 6563 7469 7665 5f73 656e 7365 203d 3d20  ective_sense == 
+00019740: 6d69 6e69 6d69 7a65 3a0a 2020 2020 2020  minimize:.      
+00019750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019760: 2020 7365 6c66 2e6d 6970 2e4d 696e 6474    self.mip.Mindt
+00019770: 5079 5f75 7469 6c73 2e63 7574 732e 696d  Py_utils.cuts.im
+00019780: 7072 6f76 696e 675f 6f62 6a65 6374 6976  proving_objectiv
+00019790: 655f 6375 7420 3d20 280a 2020 2020 2020  e_cut = (.      
 000197a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000197b0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-000197c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000197d0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-000197e0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000197f0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
-00019800: 672e 6c6f 6767 6572 2e65 7272 6f72 280a  g.logger.error(.
-00019810: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019820: 2020 2020 2746 6561 7369 6269 6c69 7479      'Feasibility
-00019830: 2070 756d 7020 4669 7865 642d 4e4c 5020   pump Fixed-NLP 
-00019840: 6973 2069 6e66 6561 7369 626c 652c 2073  is infeasible, s
-00019850: 6f6d 6574 6869 6e67 206d 6967 6874 2062  omething might b
-00019860: 6520 7772 6f6e 672e 2027 0a20 2020 2020  e wrong. '.     
-00019870: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-00019880: 5468 6572 6520 6d69 6768 7420 6265 2061  There might be a
-00019890: 2070 726f 626c 656d 2077 6974 6820 7468   problem with th
-000198a0: 6520 7072 6563 6973 696f 6e73 202d 2074  e precisions - t
-000198b0: 6865 2066 6561 7369 6269 6c69 7479 2070  he feasibility p
-000198c0: 756d 7020 7365 656d 7320 746f 2068 6176  ump seems to hav
-000198d0: 6520 636f 6e76 6572 6765 6427 0a20 2020  e converged'.   
-000198e0: 2020 2020 2020 2020 2020 2020 2029 0a0a               )..
-000198f0: 2020 2020 6465 6620 6861 6e64 6c65 5f66      def handle_f
-00019900: 705f 6d61 696e 5f74 6328 7365 6c66 2c20  p_main_tc(self, 
-00019910: 6670 5f6d 6169 6e5f 7265 7375 6c74 7329  fp_main_results)
-00019920: 3a0a 2020 2020 2020 2020 2222 2248 616e  :.        """Han
-00019930: 646c 6520 7468 6520 7465 726d 696e 6174  dle the terminat
-00019940: 696f 6e20 636f 6e64 6974 696f 6e20 6f66  ion condition of
-00019950: 2074 6865 2066 6561 7369 6269 6c69 7479   the feasibility
-00019960: 2070 756d 7020 6d61 696e 2070 726f 626c   pump main probl
-00019970: 656d 2e0a 0a20 2020 2020 2020 2050 6172  em...        Par
-00019980: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
-00019990: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
-000199a0: 2020 2066 705f 6d61 696e 5f72 6573 756c     fp_main_resul
-000199b0: 7473 203a 2053 6f6c 7665 7252 6573 756c  ts : SolverResul
-000199c0: 7473 0a20 2020 2020 2020 2020 2020 2054  ts.            T
-000199d0: 6865 2072 6573 756c 7473 2066 726f 6d20  he results from 
-000199e0: 736f 6c76 696e 6720 7468 6520 4650 206d  solving the FP m
-000199f0: 6169 6e20 7072 6f62 6c65 6d2e 0a0a 2020  ain problem...  
-00019a00: 2020 2020 2020 5265 7475 726e 730a 2020        Returns.  
-00019a10: 2020 2020 2020 2d2d 2d2d 2d2d 2d0a 2020        -------.  
-00019a20: 2020 2020 2020 626f 6f6c 0a20 2020 2020        bool.     
-00019a30: 2020 2020 2020 2054 7275 6520 6966 2046         True if F
-00019a40: 5020 6c6f 6f70 2073 686f 756c 6420 7465  P loop should te
-00019a50: 726d 696e 6174 652c 2046 616c 7365 206f  rminate, False o
-00019a60: 7468 6572 7769 7365 2e0a 2020 2020 2020  therwise..      
-00019a70: 2020 2222 220a 2020 2020 2020 2020 6966    """.        if
-00019a80: 2066 705f 6d61 696e 5f72 6573 756c 7473   fp_main_results
-00019a90: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-00019aa0: 696f 6e5f 636f 6e64 6974 696f 6e20 6973  ion_condition is
-00019ab0: 2074 632e 6f70 7469 6d61 6c3a 0a20 2020   tc.optimal:.   
-00019ac0: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
-00019ad0: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-00019ae0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00019af0: 2020 7365 6c66 2e6c 6f67 5f66 6f72 6d61    self.log_forma
-00019b00: 7474 6572 2e66 6f72 6d61 7428 0a20 2020  tter.format(.   
+000197b0: 2020 2020 2020 436f 6e73 7472 6169 6e74        Constraint
+000197c0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000197d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000197e0: 2020 6578 7072 3d73 756d 2873 656c 662e    expr=sum(self.
+000197f0: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
+00019800: 732e 6f62 6a65 6374 6976 655f 7661 6c75  s.objective_valu
+00019810: 655b 3a5d 290a 2020 2020 2020 2020 2020  e[:]).          
+00019820: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019830: 2020 2020 2020 3c3d 2073 656c 662e 7072        <= self.pr
+00019840: 696d 616c 5f62 6f75 6e64 0a20 2020 2020  imal_bound.     
+00019850: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019860: 2020 2020 2020 2020 2020 202d 2073 656c             - sel
+00019870: 662e 636f 6e66 6967 2e66 705f 6375 746f  f.config.fp_cuto
+00019880: 6666 6465 6372 0a20 2020 2020 2020 2020  ffdecr.         
+00019890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000198a0: 2020 2020 2020 202a 206d 6178 2831 2c20         * max(1, 
+000198b0: 6162 7328 7365 6c66 2e70 7269 6d61 6c5f  abs(self.primal_
+000198c0: 626f 756e 6429 290a 2020 2020 2020 2020  bound)).        
+000198d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000198e0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+000198f0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00019900: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019910: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00019920: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019930: 2020 7365 6c66 2e6d 6970 2e4d 696e 6474    self.mip.Mindt
+00019940: 5079 5f75 7469 6c73 2e63 7574 732e 696d  Py_utils.cuts.im
+00019950: 7072 6f76 696e 675f 6f62 6a65 6374 6976  proving_objectiv
+00019960: 655f 6375 7420 3d20 280a 2020 2020 2020  e_cut = (.      
+00019970: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019980: 2020 2020 2020 436f 6e73 7472 6169 6e74        Constraint
+00019990: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000199a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000199b0: 2020 6578 7072 3d73 756d 2873 656c 662e    expr=sum(self.
+000199c0: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
+000199d0: 732e 6f62 6a65 6374 6976 655f 7661 6c75  s.objective_valu
+000199e0: 655b 3a5d 290a 2020 2020 2020 2020 2020  e[:]).          
+000199f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019a00: 2020 2020 2020 3e3d 2073 656c 662e 7072        >= self.pr
+00019a10: 696d 616c 5f62 6f75 6e64 0a20 2020 2020  imal_bound.     
+00019a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019a30: 2020 2020 2020 2020 2020 202b 2073 656c             + sel
+00019a40: 662e 636f 6e66 6967 2e66 705f 6375 746f  f.config.fp_cuto
+00019a50: 6666 6465 6372 0a20 2020 2020 2020 2020  ffdecr.         
+00019a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019a70: 2020 2020 2020 202a 206d 6178 2831 2c20         * max(1, 
+00019a80: 6162 7328 7365 6c66 2e70 7269 6d61 6c5f  abs(self.primal_
+00019a90: 626f 756e 6429 290a 2020 2020 2020 2020  bound)).        
+00019aa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019ab0: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
+00019ac0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
+00019ad0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00019ae0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00019af0: 2020 7365 6c66 2e63 6f6e 6669 672e 6c6f    self.config.lo
+00019b00: 6767 6572 2e65 7272 6f72 280a 2020 2020  gger.error(.    
 00019b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019b20: 2073 656c 662e 6670 5f69 7465 722c 0a20   self.fp_iter,. 
-00019b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019b40: 2020 2027 4650 2d4d 4950 272c 0a20 2020     'FP-MIP',.   
-00019b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019b60: 2076 616c 7565 2873 656c 662e 6d69 702e   value(self.mip.
-00019b70: 4d69 6e64 7450 795f 7574 696c 732e 6670  MindtPy_utils.fp
-00019b80: 5f6d 6970 5f6f 626a 292c 0a20 2020 2020  _mip_obj),.     
-00019b90: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00019ba0: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
-00019bb0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00019bc0: 2020 2020 2020 7365 6c66 2e64 7561 6c5f        self.dual_
-00019bd0: 626f 756e 642c 0a20 2020 2020 2020 2020  bound,.         
-00019be0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00019bf0: 7265 6c5f 6761 702c 0a20 2020 2020 2020  rel_gap,.       
-00019c00: 2020 2020 2020 2020 2020 2020 2067 6574               get
-00019c10: 5f6d 6169 6e5f 656c 6170 7365 645f 7469  _main_elapsed_ti
-00019c20: 6d65 2873 656c 662e 7469 6d69 6e67 292c  me(self.timing),
-00019c30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00019c40: 2029 0a20 2020 2020 2020 2020 2020 2029   ).            )
-00019c50: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00019c60: 7572 6e20 4661 6c73 650a 2020 2020 2020  urn False.      
-00019c70: 2020 656c 6966 2066 705f 6d61 696e 5f72    elif fp_main_r
-00019c80: 6573 756c 7473 2e73 6f6c 7665 722e 7465  esults.solver.te
-00019c90: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
-00019ca0: 696f 6e20 6973 2074 632e 6d61 7854 696d  ion is tc.maxTim
-00019cb0: 654c 696d 6974 3a0a 2020 2020 2020 2020  eLimit:.        
-00019cc0: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
-00019cd0: 6c6f 6767 6572 2e77 6172 6e69 6e67 2827  logger.warning('
-00019ce0: 4650 2d4d 4950 2072 6561 6368 6573 206d  FP-MIP reaches m
-00019cf0: 6178 2054 696d 654c 696d 6974 2729 0a20  ax TimeLimit'). 
-00019d00: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00019d10: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
-00019d20: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
-00019d30: 7469 6f6e 203d 2074 632e 6d61 7854 696d  tion = tc.maxTim
-00019d40: 654c 696d 6974 0a20 2020 2020 2020 2020  eLimit.         
-00019d50: 2020 2072 6574 7572 6e20 5472 7565 0a20     return True. 
-00019d60: 2020 2020 2020 2065 6c69 6620 6670 5f6d         elif fp_m
-00019d70: 6169 6e5f 7265 7375 6c74 732e 736f 6c76  ain_results.solv
-00019d80: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
-00019d90: 6f6e 6469 7469 6f6e 2069 7320 7463 2e69  ondition is tc.i
-00019da0: 6e66 6561 7369 626c 653a 0a20 2020 2020  nfeasible:.     
-00019db0: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
-00019dc0: 6967 2e6c 6f67 6765 722e 7761 726e 696e  ig.logger.warnin
-00019dd0: 6728 2746 502d 4d49 5020 696e 6665 6173  g('FP-MIP infeas
-00019de0: 6962 6c65 2729 0a20 2020 2020 2020 2020  ible').         
-00019df0: 2020 206e 6f5f 676f 6f64 5f63 7574 7320     no_good_cuts 
-00019e00: 3d20 7365 6c66 2e6d 6970 2e4d 696e 6474  = self.mip.Mindt
-00019e10: 5079 5f75 7469 6c73 2e63 7574 732e 6e6f  Py_utils.cuts.no
-00019e20: 5f67 6f6f 645f 6375 7473 0a20 2020 2020  _good_cuts.     
-00019e30: 2020 2020 2020 2069 6620 6e6f 5f67 6f6f         if no_goo
-00019e40: 645f 6375 7473 2e5f 5f6c 656e 5f5f 2829  d_cuts.__len__()
-00019e50: 203e 2030 3a0a 2020 2020 2020 2020 2020   > 0:.          
-00019e60: 2020 2020 2020 6e6f 5f67 6f6f 645f 6375        no_good_cu
-00019e70: 7473 5b6e 6f5f 676f 6f64 5f63 7574 732e  ts[no_good_cuts.
-00019e80: 5f5f 6c65 6e5f 5f28 295d 2e64 6561 6374  __len__()].deact
-00019e90: 6976 6174 6528 290a 2020 2020 2020 2020  ivate().        
-00019ea0: 2020 2020 7265 7475 726e 2054 7275 650a      return True.
-00019eb0: 2020 2020 2020 2020 656c 6966 2066 705f          elif fp_
-00019ec0: 6d61 696e 5f72 6573 756c 7473 2e73 6f6c  main_results.sol
-00019ed0: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-00019ee0: 636f 6e64 6974 696f 6e20 6973 2074 632e  condition is tc.
-00019ef0: 756e 626f 756e 6465 643a 0a20 2020 2020  unbounded:.     
-00019f00: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
-00019f10: 6967 2e6c 6f67 6765 722e 7761 726e 696e  ig.logger.warnin
-00019f20: 6728 2746 502d 4d49 5020 756e 626f 756e  g('FP-MIP unboun
-00019f30: 6465 6427 290a 2020 2020 2020 2020 2020  ded').          
-00019f40: 2020 7265 7475 726e 2054 7275 650a 2020    return True.  
-00019f50: 2020 2020 2020 656c 6966 2028 0a20 2020        elif (.   
-00019f60: 2020 2020 2020 2020 2066 705f 6d61 696e           fp_main
-00019f70: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
-00019f80: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
-00019f90: 6974 696f 6e20 6973 2074 632e 6f74 6865  ition is tc.othe
-00019fa0: 720a 2020 2020 2020 2020 2020 2020 616e  r.            an
-00019fb0: 6420 6670 5f6d 6169 6e5f 7265 7375 6c74  d fp_main_result
-00019fc0: 732e 736f 6c75 7469 6f6e 2e73 7461 7475  s.solution.statu
-00019fd0: 7320 6973 2053 6f6c 7574 696f 6e53 7461  s is SolutionSta
-00019fe0: 7475 732e 6665 6173 6962 6c65 0a20 2020  tus.feasible.   
-00019ff0: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-0001a000: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
-0001a010: 6c6f 6767 6572 2e77 6172 6e69 6e67 280a  logger.warning(.
-0001a020: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a030: 274d 494c 5020 736f 6c76 6572 2072 6570  'MILP solver rep
-0001a040: 6f72 7465 6420 6665 6173 6962 6c65 2073  orted feasible s
-0001a050: 6f6c 7574 696f 6e20 6f66 2046 502d 4d49  olution of FP-MI
-0001a060: 502c 2027 0a20 2020 2020 2020 2020 2020  P, '.           
-0001a070: 2020 2020 2027 6275 7420 6e6f 7420 6775       'but not gu
-0001a080: 6172 616e 7465 6564 2074 6f20 6265 206f  aranteed to be o
-0001a090: 7074 696d 616c 2e27 0a20 2020 2020 2020  ptimal.'.       
-0001a0a0: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0001a0b0: 2020 2072 6574 7572 6e20 4661 6c73 650a     return False.
-0001a0c0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001a0d0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-0001a0e0: 6f6e 6669 672e 6c6f 6767 6572 2e77 6172  onfig.logger.war
-0001a0f0: 6e69 6e67 2827 556e 6578 7065 6374 6564  ning('Unexpected
-0001a100: 2072 6573 756c 7420 6f66 2046 502d 4d49   result of FP-MI
-0001a110: 5027 290a 2020 2020 2020 2020 2020 2020  P').            
-0001a120: 7265 7475 726e 2054 7275 650a 0a20 2020  return True..   
-0001a130: 2064 6566 2066 705f 6c6f 6f70 2873 656c   def fp_loop(sel
-0001a140: 6629 3a0a 2020 2020 2020 2020 2222 2246  f):.        """F
-0001a150: 6561 7369 6269 6c69 7479 2070 756d 7020  easibility pump 
-0001a160: 6c6f 6f70 2e0a 0a20 2020 2020 2020 2054  loop...        T
-0001a170: 6869 7320 6973 2074 6865 206f 7574 6572  his is the outer
-0001a180: 6d6f 7374 2066 756e 6374 696f 6e20 666f  most function fo
-0001a190: 7220 7468 6520 4665 6173 6962 696c 6974  r the Feasibilit
-0001a1a0: 7920 5075 6d70 2061 6c67 6f72 6974 686d  y Pump algorithm
-0001a1b0: 2069 6e20 7468 6973 2070 6163 6b61 6765   in this package
-0001a1c0: 3b20 7468 6973 2066 756e 6374 696f 6e0a  ; this function.
-0001a1d0: 2020 2020 2020 2020 636f 6e74 726f 6c73          controls
-0001a1e0: 2074 6865 2070 726f 6772 6573 7320 6f66   the progress of
-0001a1f0: 2073 6f6c 7669 6e67 2074 6865 206d 6f64   solving the mod
-0001a200: 656c 2e0a 0a20 2020 2020 2020 2052 6169  el...        Rai
-0001a210: 7365 730a 2020 2020 2020 2020 2d2d 2d2d  ses.        ----
-0001a220: 2d2d 0a20 2020 2020 2020 2056 616c 7565  --.        Value
-0001a230: 4572 726f 720a 2020 2020 2020 2020 2020  Error.          
-0001a240: 2020 4d69 6e64 7450 7920 756e 6162 6c65    MindtPy unable
-0001a250: 2074 6f20 6861 6e64 6c65 2074 6865 2074   to handle the t
-0001a260: 6572 6d69 6e61 7469 6f6e 2063 6f6e 6469  ermination condi
-0001a270: 7469 6f6e 206f 6620 7468 6520 4650 2d4e  tion of the FP-N
-0001a280: 4c50 2073 7562 7072 6f62 6c65 6d2e 0a20  LP subproblem.. 
-0001a290: 2020 2020 2020 2022 2222 0a20 2020 2020         """.     
-0001a2a0: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
-0001a2b0: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
-0001a2c0: 7768 696c 6520 7365 6c66 2e66 705f 6974  while self.fp_it
-0001a2d0: 6572 203c 2063 6f6e 6669 672e 6670 5f69  er < config.fp_i
-0001a2e0: 7465 7261 7469 6f6e 5f6c 696d 6974 3a0a  teration_limit:.
-0001a2f0: 2020 2020 2020 2020 2020 2020 2320 736f              # so
-0001a300: 6c76 6520 4d49 5020 6d61 696e 2070 726f  lve MIP main pro
-0001a310: 626c 656d 0a20 2020 2020 2020 2020 2020  blem.           
-0001a320: 2077 6974 6820 7469 6d65 5f63 6f64 6528   with time_code(
-0001a330: 7365 6c66 2e74 696d 696e 672c 2027 6670  self.timing, 'fp
-0001a340: 206d 6169 6e27 293a 0a20 2020 2020 2020   main'):.       
-0001a350: 2020 2020 2020 2020 2066 705f 6d61 696e           fp_main
-0001a360: 2c20 6670 5f6d 6169 6e5f 7265 7375 6c74  , fp_main_result
-0001a370: 7320 3d20 7365 6c66 2e73 6f6c 7665 5f66  s = self.solve_f
-0001a380: 705f 6d61 696e 2829 0a20 2020 2020 2020  p_main().       
-0001a390: 2020 2020 2066 705f 7368 6f75 6c64 5f74       fp_should_t
-0001a3a0: 6572 6d69 6e61 7465 203d 2073 656c 662e  erminate = self.
-0001a3b0: 6861 6e64 6c65 5f66 705f 6d61 696e 5f74  handle_fp_main_t
-0001a3c0: 6328 6670 5f6d 6169 6e5f 7265 7375 6c74  c(fp_main_result
-0001a3d0: 7329 0a20 2020 2020 2020 2020 2020 2069  s).            i
-0001a3e0: 6620 6670 5f73 686f 756c 645f 7465 726d  f fp_should_term
-0001a3f0: 696e 6174 653a 0a20 2020 2020 2020 2020  inate:.         
-0001a400: 2020 2020 2020 2062 7265 616b 0a0a 2020         break..  
-0001a410: 2020 2020 2020 2020 2020 2320 536f 6c76            # Solv
-0001a420: 6520 4e4c 5020 7375 6270 726f 626c 656d  e NLP subproblem
-0001a430: 0a20 2020 2020 2020 2020 2020 2023 2054  .            # T
-0001a440: 6865 2063 6f6e 7374 7261 696e 7420 6c69  he constraint li
-0001a450: 6e65 6172 697a 6174 696f 6e20 6861 7070  nearization happ
-0001a460: 656e 7320 696e 2074 6865 2068 616e 646c  ens in the handl
-0001a470: 6572 730a 2020 2020 2020 2020 2020 2020  ers.            
-0001a480: 6670 5f6e 6c70 2c20 6670 5f6e 6c70 5f72  fp_nlp, fp_nlp_r
-0001a490: 6573 756c 7420 3d20 7365 6c66 2e73 6f6c  esult = self.sol
-0001a4a0: 7665 5f66 705f 7375 6270 726f 626c 656d  ve_fp_subproblem
-0001a4b0: 2829 0a0a 2020 2020 2020 2020 2020 2020  ()..            
-0001a4c0: 6966 2066 705f 6e6c 705f 7265 7375 6c74  if fp_nlp_result
-0001a4d0: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-0001a4e0: 696f 6e5f 636f 6e64 6974 696f 6e20 696e  ion_condition in
-0001a4f0: 207b 0a20 2020 2020 2020 2020 2020 2020   {.             
-0001a500: 2020 2074 632e 6f70 7469 6d61 6c2c 0a20     tc.optimal,. 
-0001a510: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0001a520: 632e 6c6f 6361 6c6c 794f 7074 696d 616c  c.locallyOptimal
-0001a530: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001a540: 2020 7463 2e66 6561 7369 626c 652c 0a20    tc.feasible,. 
-0001a550: 2020 2020 2020 2020 2020 207d 3a0a 2020             }:.  
-0001a560: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0001a570: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-0001a580: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0001a590: 2020 2020 2020 7365 6c66 2e6c 6f67 5f66        self.log_f
-0001a5a0: 6f72 6d61 7474 6572 2e66 6f72 6d61 7428  ormatter.format(
-0001a5b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a5c0: 2020 2020 2020 2020 2073 656c 662e 6670           self.fp
-0001a5d0: 5f69 7465 722c 0a20 2020 2020 2020 2020  _iter,.         
-0001a5e0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0001a5f0: 4650 2d4e 4c50 272c 0a20 2020 2020 2020  FP-NLP',.       
-0001a600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a610: 2076 616c 7565 2866 705f 6e6c 702e 4d69   value(fp_nlp.Mi
-0001a620: 6e64 7450 795f 7574 696c 732e 6670 5f6e  ndtPy_utils.fp_n
-0001a630: 6c70 5f6f 626a 292c 0a20 2020 2020 2020  lp_obj),.       
-0001a640: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a650: 2073 656c 662e 7072 696d 616c 5f62 6f75   self.primal_bou
-0001a660: 6e64 2c0a 2020 2020 2020 2020 2020 2020  nd,.            
-0001a670: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001a680: 2e64 7561 6c5f 626f 756e 642c 0a20 2020  .dual_bound,.   
-0001a690: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a6a0: 2020 2020 2073 656c 662e 7265 6c5f 6761       self.rel_ga
-0001a6b0: 702c 0a20 2020 2020 2020 2020 2020 2020  p,.             
-0001a6c0: 2020 2020 2020 2020 2020 2067 6574 5f6d             get_m
-0001a6d0: 6169 6e5f 656c 6170 7365 645f 7469 6d65  ain_elapsed_time
-0001a6e0: 2873 656c 662e 7469 6d69 6e67 292c 0a20  (self.timing),. 
-0001a6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a700: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-0001a710: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0001a720: 2020 2020 2020 2073 656c 662e 6861 6e64         self.hand
-0001a730: 6c65 5f66 705f 7375 6270 726f 626c 656d  le_fp_subproblem
-0001a740: 5f6f 7074 696d 616c 2866 705f 6e6c 7029  _optimal(fp_nlp)
-0001a750: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
-0001a760: 6620 6670 5f6e 6c70 5f72 6573 756c 742e  f fp_nlp_result.
-0001a770: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-0001a780: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 6e20  on_condition in 
-0001a790: 7b0a 2020 2020 2020 2020 2020 2020 2020  {.              
-0001a7a0: 2020 7463 2e69 6e66 6561 7369 626c 652c    tc.infeasible,
-0001a7b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a7c0: 2074 632e 6e6f 536f 6c75 7469 6f6e 2c0a   tc.noSolution,.
-0001a7d0: 2020 2020 2020 2020 2020 2020 7d3a 0a20              }:. 
-0001a7e0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
-0001a7f0: 6f6e 6669 672e 6c6f 6767 6572 2e65 7272  onfig.logger.err
-0001a800: 6f72 2827 4665 6173 6962 696c 6974 7920  or('Feasibility 
-0001a810: 7075 6d70 204e 4c50 2073 7562 7072 6f62  pump NLP subprob
-0001a820: 6c65 6d20 696e 6665 6173 6962 6c65 2729  lem infeasible')
-0001a830: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001a840: 2073 656c 662e 7368 6f75 6c64 5f74 6572   self.should_ter
-0001a850: 6d69 6e61 7465 203d 2054 7275 650a 2020  minate = True.  
-0001a860: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0001a870: 6c66 2e72 6573 756c 7473 2e73 6f6c 7665  lf.results.solve
-0001a880: 722e 7374 6174 7573 203d 2053 6f6c 7665  r.status = Solve
-0001a890: 7253 7461 7475 732e 6572 726f 720a 2020  rStatus.error.  
-0001a8a0: 2020 2020 2020 2020 2020 2020 2020 7265                re
-0001a8b0: 7475 726e 0a20 2020 2020 2020 2020 2020  turn.           
-0001a8c0: 2065 6c69 6620 6670 5f6e 6c70 5f72 6573   elif fp_nlp_res
-0001a8d0: 756c 742e 736f 6c76 6572 2e74 6572 6d69  ult.solver.termi
-0001a8e0: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
-0001a8f0: 2069 7320 7463 2e6d 6178 4974 6572 6174   is tc.maxIterat
-0001a900: 696f 6e73 3a0a 2020 2020 2020 2020 2020  ions:.          
-0001a910: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
-0001a920: 6765 722e 6572 726f 7228 0a20 2020 2020  ger.error(.     
-0001a930: 2020 2020 2020 2020 2020 2020 2020 2027                 '
-0001a940: 4665 6173 6962 696c 6974 7920 7075 6d70  Feasibility pump
-0001a950: 204e 4c50 2073 7562 7072 6f62 6c65 6d20   NLP subproblem 
-0001a960: 6661 696c 6564 2074 6f20 636f 6e76 6572  failed to conver
-0001a970: 6765 2077 6974 6869 6e20 6974 6572 6174  ge within iterat
-0001a980: 696f 6e20 6c69 6d69 742e 270a 2020 2020  ion limit.'.    
-0001a990: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0001a9a0: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0001a9b0: 6c66 2e73 686f 756c 645f 7465 726d 696e  lf.should_termin
-0001a9c0: 6174 6520 3d20 5472 7565 0a20 2020 2020  ate = True.     
-0001a9d0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001a9e0: 7265 7375 6c74 732e 736f 6c76 6572 2e73  results.solver.s
-0001a9f0: 7461 7475 7320 3d20 536f 6c76 6572 5374  tatus = SolverSt
-0001aa00: 6174 7573 2e65 7272 6f72 0a20 2020 2020  atus.error.     
-0001aa10: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-0001aa20: 6e0a 2020 2020 2020 2020 2020 2020 656c  n.            el
-0001aa30: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0001aa40: 2020 2020 7261 6973 6520 5661 6c75 6545      raise ValueE
-0001aa50: 7272 6f72 280a 2020 2020 2020 2020 2020  rror(.          
-0001aa60: 2020 2020 2020 2020 2020 274d 696e 6474            'Mindt
-0001aa70: 5079 2075 6e61 626c 6520 746f 2068 616e  Py unable to han
-0001aa80: 646c 6520 4e4c 5020 7375 6270 726f 626c  dle NLP subprobl
-0001aa90: 656d 2074 6572 6d69 6e61 7469 6f6e 2027  em termination '
-0001aaa0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001aab0: 2020 2020 2027 636f 6e64 6974 696f 6e20       'condition 
-0001aac0: 6f66 207b 7d27 2e66 6f72 6d61 7428 6670  of {}'.format(fp
-0001aad0: 5f6e 6c70 5f72 6573 756c 742e 736f 6c76  _nlp_result.solv
-0001aae0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
-0001aaf0: 6f6e 6469 7469 6f6e 290a 2020 2020 2020  ondition).      
-0001ab00: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0001ab10: 2020 2020 2020 2020 2320 4361 6c6c 2074          # Call t
-0001ab20: 6865 204e 4c50 2070 6f73 742d 736f 6c76  he NLP post-solv
-0001ab30: 6520 6361 6c6c 6261 636b 0a20 2020 2020  e callback.     
-0001ab40: 2020 2020 2020 2063 6f6e 6669 672e 6361         config.ca
-0001ab50: 6c6c 5f61 6674 6572 5f73 7562 7072 6f62  ll_after_subprob
-0001ab60: 6c65 6d5f 736f 6c76 6528 6670 5f6e 6c70  lem_solve(fp_nlp
-0001ab70: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
-0001ab80: 6c66 2e66 705f 6974 6572 202b 3d20 310a  lf.fp_iter += 1.
-0001ab90: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-0001aba0: 2e4d 696e 6474 5079 5f75 7469 6c73 2e64  .MindtPy_utils.d
-0001abb0: 656c 5f63 6f6d 706f 6e65 6e74 2827 6670  el_component('fp
-0001abc0: 5f6d 6970 5f6f 626a 2729 0a0a 2020 2020  _mip_obj')..    
-0001abd0: 2020 2020 6966 2063 6f6e 6669 672e 6670      if config.fp
-0001abe0: 5f6d 6169 6e5f 6e6f 726d 203d 3d20 274c  _main_norm == 'L
-0001abf0: 3127 3a0a 2020 2020 2020 2020 2020 2020  1':.            
-0001ac00: 7365 6c66 2e6d 6970 2e4d 696e 6474 5079  self.mip.MindtPy
-0001ac10: 5f75 7469 6c73 2e64 656c 5f63 6f6d 706f  _utils.del_compo
-0001ac20: 6e65 6e74 2827 4c31 5f6f 626a 2729 0a20  nent('L1_obj'). 
-0001ac30: 2020 2020 2020 2065 6c69 6620 636f 6e66         elif conf
-0001ac40: 6967 2e66 705f 6d61 696e 5f6e 6f72 6d20  ig.fp_main_norm 
-0001ac50: 3d3d 2027 4c5f 696e 6669 6e69 7479 273a  == 'L_infinity':
-0001ac60: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001ac70: 662e 6d69 702e 4d69 6e64 7450 795f 7574  f.mip.MindtPy_ut
-0001ac80: 696c 732e 6465 6c5f 636f 6d70 6f6e 656e  ils.del_componen
-0001ac90: 7428 274c 5f69 6e66 696e 6974 795f 6f62  t('L_infinity_ob
-0001aca0: 6a27 290a 0a20 2020 2020 2020 2023 2064  j')..        # d
-0001acb0: 6561 6374 6976 6174 6520 7468 6520 696d  eactivate the im
-0001acc0: 7072 6f76 696e 675f 6f62 6a65 6374 6976  proving_objectiv
-0001acd0: 655f 6375 740a 2020 2020 2020 2020 7365  e_cut.        se
-0001ace0: 6c66 2e6d 6970 2e4d 696e 6474 5079 5f75  lf.mip.MindtPy_u
-0001acf0: 7469 6c73 2e63 7574 732e 6465 6c5f 636f  tils.cuts.del_co
-0001ad00: 6d70 6f6e 656e 7428 2769 6d70 726f 7669  mponent('improvi
-0001ad10: 6e67 5f6f 626a 6563 7469 7665 5f63 7574  ng_objective_cut
-0001ad20: 2729 0a20 2020 2020 2020 2069 6620 6e6f  ').        if no
-0001ad30: 7420 636f 6e66 6967 2e66 705f 7472 616e  t config.fp_tran
-0001ad40: 7366 6572 6375 7473 3a0a 2020 2020 2020  sfercuts:.      
-0001ad50: 2020 2020 2020 666f 7220 6320 696e 2073        for c in s
-0001ad60: 656c 662e 6d69 702e 4d69 6e64 7450 795f  elf.mip.MindtPy_
-0001ad70: 7574 696c 732e 6375 7473 2e6f 615f 6375  utils.cuts.oa_cu
-0001ad80: 7473 3a0a 2020 2020 2020 2020 2020 2020  ts:.            
-0001ad90: 2020 2020 632e 6465 6163 7469 7661 7465      c.deactivate
-0001ada0: 2829 0a20 2020 2020 2020 2020 2020 2066  ().            f
-0001adb0: 6f72 2063 2069 6e20 7365 6c66 2e6d 6970  or c in self.mip
-0001adc0: 2e4d 696e 6474 5079 5f75 7469 6c73 2e63  .MindtPy_utils.c
-0001add0: 7574 732e 6e6f 5f67 6f6f 645f 6375 7473  uts.no_good_cuts
-0001ade0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001adf0: 2020 632e 6465 6163 7469 7661 7465 2829    c.deactivate()
-0001ae00: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
-0001ae10: 6967 2e66 705f 7072 6f6a 6375 7473 3a0a  ig.fp_projcuts:.
-0001ae20: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001ae30: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2e4d  .working_model.M
-0001ae40: 696e 6474 5079 5f75 7469 6c73 2e63 7574  indtPy_utils.cut
-0001ae50: 732e 6465 6c5f 636f 6d70 6f6e 656e 7428  s.del_component(
-0001ae60: 2766 705f 6f72 7468 6f67 6f6e 616c 6974  'fp_orthogonalit
-0001ae70: 795f 6375 7473 2729 0a0a 2020 2020 6465  y_cuts')..    de
-0001ae80: 6620 696e 6974 6961 6c69 7a65 5f6d 6970  f initialize_mip
-0001ae90: 5f70 726f 626c 656d 2873 656c 6629 3a0a  _problem(self):.
-0001aea0: 2020 2020 2020 2020 2222 2244 6561 6374          """Deact
-0001aeb0: 6976 6174 6520 7468 6520 6e6f 6e6c 696e  ivate the nonlin
-0001aec0: 6561 7220 636f 6e73 7472 6169 6e74 7320  ear constraints 
-0001aed0: 746f 2063 7265 6174 6520 7468 6520 4d49  to create the MI
-0001aee0: 5020 7072 6f62 6c65 6d2e 2222 220a 2020  P problem.""".  
-0001aef0: 2020 2020 2020 2320 6966 2073 696e 676c        # if singl
-0001af00: 6520 7472 6565 2069 7320 6163 7469 7661  e tree is activa
-0001af10: 7465 642c 2077 6520 6e65 6564 2074 6f20  ted, we need to 
-0001af20: 6164 6420 626f 756e 6473 2066 6f72 2075  add bounds for u
-0001af30: 6e62 6f75 6e64 6564 2076 6172 6961 626c  nbounded variabl
-0001af40: 6573 2069 6e20 6e6f 6e6c 696e 6561 7220  es in nonlinear 
-0001af50: 636f 6e73 7472 6169 6e74 7320 746f 2061  constraints to a
-0001af60: 766f 6964 2075 6e62 6f75 6e64 6564 206d  void unbounded m
-0001af70: 6169 6e20 7072 6f62 6c65 6d2e 0a20 2020  ain problem..   
-0001af80: 2020 2020 2063 6f6e 6669 6720 3d20 7365       config = se
-0001af90: 6c66 2e63 6f6e 6669 670a 2020 2020 2020  lf.config.      
-0001afa0: 2020 6966 2063 6f6e 6669 672e 7369 6e67    if config.sing
-0001afb0: 6c65 5f74 7265 653a 0a20 2020 2020 2020  le_tree:.       
-0001afc0: 2020 2020 2061 6464 5f76 6172 5f62 6f75       add_var_bou
-0001afd0: 6e64 2873 656c 662e 776f 726b 696e 675f  nd(self.working_
-0001afe0: 6d6f 6465 6c2c 2063 6f6e 6669 6729 0a0a  model, config)..
-0001aff0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
-0001b000: 203d 2073 656c 662e 776f 726b 696e 675f   = self.working_
-0001b010: 6d6f 6465 6c2e 636c 6f6e 6528 290a 2020  model.clone().  
-0001b020: 2020 2020 2020 6e65 7874 2873 656c 662e        next(self.
-0001b030: 6d69 702e 636f 6d70 6f6e 656e 745f 6461  mip.component_da
-0001b040: 7461 5f6f 626a 6563 7473 284f 626a 6563  ta_objects(Objec
-0001b050: 7469 7665 2c20 6163 7469 7665 3d54 7275  tive, active=Tru
-0001b060: 6529 292e 6465 6163 7469 7661 7465 2829  e)).deactivate()
-0001b070: 0a20 2020 2020 2020 2069 6620 6861 7361  .        if hasa
-0001b080: 7474 7228 7365 6c66 2e6d 6970 2c20 2764  ttr(self.mip, 'd
-0001b090: 7561 6c27 2920 616e 6420 6973 696e 7374  ual') and isinst
-0001b0a0: 616e 6365 2873 656c 662e 6d69 702e 6475  ance(self.mip.du
-0001b0b0: 616c 2c20 5375 6666 6978 293a 0a20 2020  al, Suffix):.   
-0001b0c0: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
-0001b0d0: 702e 6465 6c5f 636f 6d70 6f6e 656e 7428  p.del_component(
-0001b0e0: 2764 7561 6c27 290a 2020 2020 2020 2020  'dual').        
-0001b0f0: 2320 4465 6163 7469 7661 7465 2065 7874  # Deactivate ext
-0001b100: 7261 6e65 6f75 7320 494d 504f 5254 2f45  raneous IMPORT/E
-0001b110: 5850 4f52 5420 7375 6666 6978 6573 0a20  XPORT suffixes. 
-0001b120: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
-0001b130: 2e6e 6c70 5f73 6f6c 7665 7220 696e 207b  .nlp_solver in {
-0001b140: 2769 706f 7074 272c 2027 6379 6970 6f70  'ipopt', 'cyipop
-0001b150: 7427 7d3a 0a20 2020 2020 2020 2020 2020  t'}:.           
-0001b160: 2067 6574 6174 7472 2873 656c 662e 6d69   getattr(self.mi
-0001b170: 702c 2027 6970 6f70 745f 7a4c 5f6f 7574  p, 'ipopt_zL_out
-0001b180: 272c 205f 446f 4e6f 7468 696e 6728 2929  ', _DoNothing())
-0001b190: 2e64 6561 6374 6976 6174 6528 290a 2020  .deactivate().  
-0001b1a0: 2020 2020 2020 2020 2020 6765 7461 7474            getatt
-0001b1b0: 7228 7365 6c66 2e6d 6970 2c20 2769 706f  r(self.mip, 'ipo
-0001b1c0: 7074 5f7a 555f 6f75 7427 2c20 5f44 6f4e  pt_zU_out', _DoN
-0001b1d0: 6f74 6869 6e67 2829 292e 6465 6163 7469  othing()).deacti
-0001b1e0: 7661 7465 2829 0a0a 2020 2020 2020 2020  vate()..        
-0001b1f0: 4d69 6e64 7450 7920 3d20 7365 6c66 2e6d  MindtPy = self.m
-0001b200: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
-0001b210: 0a20 2020 2020 2020 2069 6620 6c65 6e28  .        if len(
-0001b220: 4d69 6e64 7450 792e 6772 6579 5f62 6f78  MindtPy.grey_box
-0001b230: 5f6c 6973 7429 203e 2030 3a0a 2020 2020  _list) > 0:.    
-0001b240: 2020 2020 2020 2020 666f 7220 6772 6579          for grey
-0001b250: 5f62 6f78 2069 6e20 4d69 6e64 7450 792e  _box in MindtPy.
-0001b260: 6772 6579 5f62 6f78 5f6c 6973 743a 0a20  grey_box_list:. 
-0001b270: 2020 2020 2020 2020 2020 2020 2020 2067                 g
-0001b280: 7265 795f 626f 782e 6465 6163 7469 7661  rey_box.deactiva
-0001b290: 7465 2829 0a0a 2020 2020 2020 2020 6966  te()..        if
-0001b2a0: 2063 6f6e 6669 672e 696e 6974 5f73 7472   config.init_str
-0001b2b0: 6174 6567 7920 3d3d 2027 4650 273a 0a20  ategy == 'FP':. 
-0001b2c0: 2020 2020 2020 2020 2020 204d 696e 6474             Mindt
-0001b2d0: 5079 2e63 7574 732e 6670 5f6f 7274 686f  Py.cuts.fp_ortho
-0001b2e0: 676f 6e61 6c69 7479 5f63 7574 7320 3d20  gonality_cuts = 
-0001b2f0: 436f 6e73 7472 6169 6e74 4c69 7374 280a  ConstraintList(.
-0001b300: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b310: 646f 633d 274f 7274 686f 676f 6e61 6c69  doc='Orthogonali
-0001b320: 7479 2063 7574 7320 696e 2066 6561 7369  ty cuts in feasi
-0001b330: 6269 6c69 7479 2070 756d 7027 0a20 2020  bility pump'.   
-0001b340: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-0001b350: 2020 2020 2020 2069 6620 636f 6e66 6967         if config
-0001b360: 2e66 705f 7072 6f6a 6375 7473 3a0a 2020  .fp_projcuts:.  
-0001b370: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0001b380: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
-0001b390: 2e4d 696e 6474 5079 5f75 7469 6c73 2e63  .MindtPy_utils.c
-0001b3a0: 7574 732e 6670 5f6f 7274 686f 676f 6e61  uts.fp_orthogona
-0001b3b0: 6c69 7479 5f63 7574 7320 3d20 280a 2020  lity_cuts = (.  
-0001b3c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b3d0: 2020 436f 6e73 7472 6169 6e74 4c69 7374    ConstraintList
-0001b3e0: 2864 6f63 3d27 4f72 7468 6f67 6f6e 616c  (doc='Orthogonal
-0001b3f0: 6974 7920 6375 7473 2069 6e20 6665 6173  ity cuts in feas
-0001b400: 6962 696c 6974 7920 7075 6d70 2729 0a20  ibility pump'). 
-0001b410: 2020 2020 2020 2020 2020 2020 2020 2029                 )
-0001b420: 0a0a 2020 2020 2020 2020 7365 6c66 2e66  ..        self.f
-0001b430: 6978 6564 5f6e 6c70 203d 2073 656c 662e  ixed_nlp = self.
-0001b440: 776f 726b 696e 675f 6d6f 6465 6c2e 636c  working_model.cl
-0001b450: 6f6e 6528 290a 2020 2020 2020 2020 5472  one().        Tr
-0001b460: 616e 7366 6f72 6d61 7469 6f6e 4661 6374  ansformationFact
-0001b470: 6f72 7928 2763 6f72 652e 6669 785f 696e  ory('core.fix_in
-0001b480: 7465 6765 725f 7661 7273 2729 2e61 7070  teger_vars').app
-0001b490: 6c79 5f74 6f28 7365 6c66 2e66 6978 6564  ly_to(self.fixed
-0001b4a0: 5f6e 6c70 290a 2020 2020 2020 2020 696e  _nlp).        in
-0001b4b0: 6974 6961 6c69 7a65 5f66 6561 735f 7375  itialize_feas_su
-0001b4c0: 6270 726f 626c 656d 2873 656c 662e 6669  bproblem(self.fi
-0001b4d0: 7865 645f 6e6c 702c 2063 6f6e 6669 672e  xed_nlp, config.
-0001b4e0: 6665 6173 6962 696c 6974 795f 6e6f 726d  feasibility_norm
-0001b4f0: 290a 0a20 2020 2064 6566 2069 6e69 7469  )..    def initi
-0001b500: 616c 697a 655f 7375 6273 6f6c 7665 7273  alize_subsolvers
-0001b510: 2873 656c 6629 3a0a 2020 2020 2020 2020  (self):.        
-0001b520: 2222 2249 6e69 7469 616c 697a 6520 616e  """Initialize an
-0001b530: 6420 7365 7420 6f70 7469 6f6e 7320 666f  d set options fo
-0001b540: 7220 4d49 5020 616e 6420 4e4c 5020 7375  r MIP and NLP su
-0001b550: 6273 6f6c 7665 7273 2e22 2222 0a20 2020  bsolvers.""".   
-0001b560: 2020 2020 2063 6f6e 6669 6720 3d20 7365       config = se
-0001b570: 6c66 2e63 6f6e 6669 670a 2020 2020 2020  lf.config.      
-0001b580: 2020 6966 2063 6f6e 6669 672e 6d69 705f    if config.mip_
-0001b590: 736f 6c76 6572 203d 3d20 2767 7572 6f62  solver == 'gurob
-0001b5a0: 695f 7065 7273 6973 7465 6e74 2720 616e  i_persistent' an
-0001b5b0: 6420 636f 6e66 6967 2e73 696e 676c 655f  d config.single_
-0001b5c0: 7472 6565 3a0a 2020 2020 2020 2020 2020  tree:.          
-0001b5d0: 2020 7365 6c66 2e6d 6970 5f6f 7074 203d    self.mip_opt =
-0001b5e0: 2047 7572 6f62 6950 6572 7369 7374 656e   GurobiPersisten
-0001b5f0: 7434 4d69 6e64 7450 7928 290a 2020 2020  t4MindtPy().    
-0001b600: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-0001b610: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
-0001b620: 7074 203d 2053 6f6c 7665 7246 6163 746f  pt = SolverFacto
-0001b630: 7279 2863 6f6e 6669 672e 6d69 705f 736f  ry(config.mip_so
-0001b640: 6c76 6572 290a 2020 2020 2020 2020 7365  lver).        se
-0001b650: 6c66 2e6e 6c70 5f6f 7074 203d 2053 6f6c  lf.nlp_opt = Sol
-0001b660: 7665 7246 6163 746f 7279 2863 6f6e 6669  verFactory(confi
-0001b670: 672e 6e6c 705f 736f 6c76 6572 290a 2020  g.nlp_solver).  
-0001b680: 2020 2020 2020 7365 6c66 2e66 6561 7369        self.feasi
-0001b690: 6269 6c69 7479 5f6e 6c70 5f6f 7074 203d  bility_nlp_opt =
-0001b6a0: 2053 6f6c 7665 7246 6163 746f 7279 2863   SolverFactory(c
-0001b6b0: 6f6e 6669 672e 6e6c 705f 736f 6c76 6572  onfig.nlp_solver
-0001b6c0: 290a 2020 2020 2020 2020 6966 2063 6f6e  ).        if con
-0001b6d0: 6669 672e 6d69 705f 7265 6775 6c61 7269  fig.mip_regulari
-0001b6e0: 7a61 7469 6f6e 5f73 6f6c 7665 7220 6973  zation_solver is
-0001b6f0: 206e 6f74 204e 6f6e 653a 0a20 2020 2020   not None:.     
-0001b700: 2020 2020 2020 2073 656c 662e 7265 6775         self.regu
-0001b710: 6c61 7269 7a61 7469 6f6e 5f6d 6970 5f6f  larization_mip_o
-0001b720: 7074 203d 2053 6f6c 7665 7246 6163 746f  pt = SolverFacto
-0001b730: 7279 280a 2020 2020 2020 2020 2020 2020  ry(.            
-0001b740: 2020 2020 636f 6e66 6967 2e6d 6970 5f72      config.mip_r
-0001b750: 6567 756c 6172 697a 6174 696f 6e5f 736f  egularization_so
-0001b760: 6c76 6572 0a20 2020 2020 2020 2020 2020  lver.           
-0001b770: 2029 0a0a 2020 2020 2020 2020 7365 6c66   )..        self
-0001b780: 2e63 6865 636b 5f73 7562 736f 6c76 6572  .check_subsolver
-0001b790: 5f76 616c 6964 6974 7928 290a 2020 2020  _validity().    
-0001b7a0: 2020 2020 6966 2063 6f6e 6669 672e 6d69      if config.mi
-0001b7b0: 705f 736f 6c76 6572 203d 3d20 2767 616d  p_solver == 'gam
-0001b7c0: 7327 3a0a 2020 2020 2020 2020 2020 2020  s':.            
-0001b7d0: 7365 6c66 2e6d 6970 5f6f 7074 2e6f 7074  self.mip_opt.opt
-0001b7e0: 696f 6e73 5b27 6164 645f 6f70 7469 6f6e  ions['add_option
-0001b7f0: 7327 5d20 3d20 5b5d 0a20 2020 2020 2020  s'] = [].       
-0001b800: 2069 6620 636f 6e66 6967 2e6e 6c70 5f73   if config.nlp_s
-0001b810: 6f6c 7665 7220 3d3d 2027 6761 6d73 273a  olver == 'gams':
-0001b820: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001b830: 662e 6e6c 705f 6f70 742e 6f70 7469 6f6e  f.nlp_opt.option
-0001b840: 735b 2761 6464 5f6f 7074 696f 6e73 275d  s['add_options']
-0001b850: 203d 205b 5d0a 2020 2020 2020 2020 2020   = [].          
-0001b860: 2020 7365 6c66 2e66 6561 7369 6269 6c69    self.feasibili
-0001b870: 7479 5f6e 6c70 5f6f 7074 2e6f 7074 696f  ty_nlp_opt.optio
-0001b880: 6e73 5b27 6164 645f 6f70 7469 6f6e 7327  ns['add_options'
-0001b890: 5d20 3d20 5b5d 0a20 2020 2020 2020 2073  ] = [].        s
-0001b8a0: 6574 5f73 6f6c 7665 725f 6d69 7067 6170  et_solver_mipgap
-0001b8b0: 2873 656c 662e 6d69 705f 6f70 742c 2063  (self.mip_opt, c
-0001b8c0: 6f6e 6669 672e 6d69 705f 736f 6c76 6572  onfig.mip_solver
-0001b8d0: 2c20 636f 6e66 6967 290a 0a20 2020 2020  , config)..     
-0001b8e0: 2020 2073 6574 5f73 6f6c 7665 725f 636f     set_solver_co
-0001b8f0: 6e73 7472 6169 6e74 5f76 696f 6c61 7469  nstraint_violati
-0001b900: 6f6e 5f74 6f6c 6572 616e 6365 280a 2020  on_tolerance(.  
-0001b910: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
-0001b920: 6c70 5f6f 7074 2c20 636f 6e66 6967 2e6e  lp_opt, config.n
-0001b930: 6c70 5f73 6f6c 7665 722c 2063 6f6e 6669  lp_solver, confi
-0001b940: 670a 2020 2020 2020 2020 290a 2020 2020  g.        ).    
-0001b950: 2020 2020 7365 745f 736f 6c76 6572 5f63      set_solver_c
-0001b960: 6f6e 7374 7261 696e 745f 7669 6f6c 6174  onstraint_violat
-0001b970: 696f 6e5f 746f 6c65 7261 6e63 6528 0a20  ion_tolerance(. 
-0001b980: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001b990: 6665 6173 6962 696c 6974 795f 6e6c 705f  feasibility_nlp_
-0001b9a0: 6f70 742c 2063 6f6e 6669 672e 6e6c 705f  opt, config.nlp_
-0001b9b0: 736f 6c76 6572 2c20 636f 6e66 6967 2c20  solver, config, 
-0001b9c0: 7761 726d 5f73 7461 7274 3d46 616c 7365  warm_start=False
-0001b9d0: 0a20 2020 2020 2020 2029 0a0a 2020 2020  .        )..    
-0001b9e0: 2020 2020 7365 6c66 2e73 6574 5f61 7070      self.set_app
-0001b9f0: 7369 5f73 6f6c 7665 725f 7570 6461 7465  si_solver_update
-0001ba00: 5f63 6f6e 6669 6728 290a 0a20 2020 2020  _config()..     
-0001ba10: 2020 2069 6620 636f 6e66 6967 2e6d 6970     if config.mip
-0001ba20: 5f73 6f6c 7665 7220 3d3d 2027 6775 726f  _solver == 'guro
-0001ba30: 6269 5f70 6572 7369 7374 656e 7427 2061  bi_persistent' a
-0001ba40: 6e64 2063 6f6e 6669 672e 7369 6e67 6c65  nd config.single
-0001ba50: 5f74 7265 653a 0a20 2020 2020 2020 2020  _tree:.         
-0001ba60: 2020 2023 2050 7265 4372 7573 683a 2043     # PreCrush: C
-0001ba70: 6f6e 7472 6f6c 7320 7072 6573 6f6c 7665  ontrols presolve
-0001ba80: 2072 6564 7563 7469 6f6e 7320 7468 6174   reductions that
-0001ba90: 2061 6666 6563 7420 7573 6572 2063 7574   affect user cut
-0001baa0: 730a 2020 2020 2020 2020 2020 2020 2320  s.            # 
-0001bab0: 596f 7520 7368 6f75 6c64 2063 6f6e 7369  You should consi
-0001bac0: 6465 7220 7365 7474 696e 6720 7468 6973  der setting this
-0001bad0: 2070 6172 616d 6574 6572 2074 6f20 3120   parameter to 1 
-0001bae0: 6966 2079 6f75 2061 7265 2075 7369 6e67  if you are using
-0001baf0: 2063 616c 6c62 6163 6b73 2074 6f20 6164   callbacks to ad
-0001bb00: 6420 796f 7572 206f 776e 2063 7574 732e  d your own cuts.
-0001bb10: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001bb20: 662e 6d69 705f 6f70 742e 6f70 7469 6f6e  f.mip_opt.option
-0001bb30: 735b 2750 7265 4372 7573 6827 5d20 3d20  s['PreCrush'] = 
-0001bb40: 310a 2020 2020 2020 2020 2020 2020 7365  1.            se
-0001bb50: 6c66 2e6d 6970 5f6f 7074 2e6f 7074 696f  lf.mip_opt.optio
-0001bb60: 6e73 5b27 4c61 7a79 436f 6e73 7472 6169  ns['LazyConstrai
-0001bb70: 6e74 7327 5d20 3d20 310a 0a20 2020 2020  nts'] = 1..     
-0001bb80: 2020 2023 2073 6574 2074 6872 6561 6473     # set threads
-0001bb90: 0a20 2020 2020 2020 2069 6620 636f 6e66  .        if conf
-0001bba0: 6967 2e74 6872 6561 6473 203e 2030 3a0a  ig.threads > 0:.
-0001bbb0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001bbc0: 2e6d 6970 5f6f 7074 2e6f 7074 696f 6e73  .mip_opt.options
-0001bbd0: 5b27 7468 7265 6164 7327 5d20 3d20 636f  ['threads'] = co
-0001bbe0: 6e66 6967 2e74 6872 6561 6473 0a20 2020  nfig.threads.   
-0001bbf0: 2020 2020 2023 2072 6567 756c 6172 697a       # regulariz
-0001bc00: 6174 696f 6e20 736f 6c76 6572 0a20 2020  ation solver.   
-0001bc10: 2020 2020 2069 6620 636f 6e66 6967 2e6d       if config.m
-0001bc20: 6970 5f72 6567 756c 6172 697a 6174 696f  ip_regularizatio
-0001bc30: 6e5f 736f 6c76 6572 2069 7320 6e6f 7420  n_solver is not 
-0001bc40: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001bc50: 2020 7365 745f 736f 6c76 6572 5f6d 6970    set_solver_mip
-0001bc60: 6761 7028 0a20 2020 2020 2020 2020 2020  gap(.           
-0001bc70: 2020 2020 2073 656c 662e 7265 6775 6c61       self.regula
-0001bc80: 7269 7a61 7469 6f6e 5f6d 6970 5f6f 7074  rization_mip_opt
-0001bc90: 2c20 636f 6e66 6967 2e6d 6970 5f72 6567  , config.mip_reg
-0001bca0: 756c 6172 697a 6174 696f 6e5f 736f 6c76  ularization_solv
-0001bcb0: 6572 2c20 636f 6e66 6967 0a20 2020 2020  er, config.     
-0001bcc0: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
-0001bcd0: 2020 2020 2069 6620 636f 6e66 6967 2e6d       if config.m
-0001bce0: 6970 5f72 6567 756c 6172 697a 6174 696f  ip_regularizatio
-0001bcf0: 6e5f 736f 6c76 6572 203d 3d20 2767 616d  n_solver == 'gam
-0001bd00: 7327 3a0a 2020 2020 2020 2020 2020 2020  s':.            
-0001bd10: 2020 2020 7365 6c66 2e72 6567 756c 6172      self.regular
-0001bd20: 697a 6174 696f 6e5f 6d69 705f 6f70 742e  ization_mip_opt.
-0001bd30: 6f70 7469 6f6e 735b 2761 6464 5f6f 7074  options['add_opt
-0001bd40: 696f 6e73 275d 203d 205b 5d0a 2020 2020  ions'] = [].    
-0001bd50: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-0001bd60: 672e 7265 6775 6c61 7269 7a61 7469 6f6e  g.regularization
-0001bd70: 5f6d 6970 5f74 6872 6561 6473 203e 2030  _mip_threads > 0
-0001bd80: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001bd90: 2020 7365 6c66 2e72 6567 756c 6172 697a    self.regulariz
-0001bda0: 6174 696f 6e5f 6d69 705f 6f70 742e 6f70  ation_mip_opt.op
-0001bdb0: 7469 6f6e 735b 2774 6872 6561 6473 275d  tions['threads']
-0001bdc0: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
-0001bdd0: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
-0001bde0: 7265 6775 6c61 7269 7a61 7469 6f6e 5f6d  regularization_m
-0001bdf0: 6970 5f74 6872 6561 6473 0a20 2020 2020  ip_threads.     
-0001be00: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-0001be10: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0001be20: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0001be30: 656c 662e 7265 6775 6c61 7269 7a61 7469  elf.regularizati
-0001be40: 6f6e 5f6d 6970 5f6f 7074 2e6f 7074 696f  on_mip_opt.optio
-0001be50: 6e73 5b27 7468 7265 6164 7327 5d20 3d20  ns['threads'] = 
-0001be60: 636f 6e66 6967 2e74 6872 6561 6473 0a0a  config.threads..
-0001be70: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-0001be80: 6f6e 6669 672e 6d69 705f 7265 6775 6c61  onfig.mip_regula
-0001be90: 7269 7a61 7469 6f6e 5f73 6f6c 7665 7220  rization_solver 
-0001bea0: 696e 207b 0a20 2020 2020 2020 2020 2020  in {.           
-0001beb0: 2020 2020 2027 6370 6c65 7827 2c0a 2020       'cplex',.  
-0001bec0: 2020 2020 2020 2020 2020 2020 2020 2761                'a
-0001bed0: 7070 7369 5f63 706c 6578 272c 0a20 2020  ppsi_cplex',.   
-0001bee0: 2020 2020 2020 2020 2020 2020 2027 6370               'cp
-0001bef0: 6c65 785f 7065 7273 6973 7465 6e74 272c  lex_persistent',
-0001bf00: 0a20 2020 2020 2020 2020 2020 207d 3a0a  .            }:.
-0001bf10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bf20: 6966 2063 6f6e 6669 672e 736f 6c75 7469  if config.soluti
-0001bf30: 6f6e 5f6c 696d 6974 2069 7320 6e6f 7420  on_limit is not 
-0001bf40: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001bf50: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
-0001bf60: 6567 756c 6172 697a 6174 696f 6e5f 6d69  egularization_mi
-0001bf70: 705f 6f70 742e 6f70 7469 6f6e 735b 276d  p_opt.options['m
-0001bf80: 6970 5f6c 696d 6974 735f 736f 6c75 7469  ip_limits_soluti
-0001bf90: 6f6e 7327 5d20 3d20 280a 2020 2020 2020  ons'] = (.      
-0001bfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001bfb0: 2020 636f 6e66 6967 2e73 6f6c 7574 696f    config.solutio
-0001bfc0: 6e5f 6c69 6d69 740a 2020 2020 2020 2020  n_limit.        
-0001bfd0: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-0001bfe0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
-0001bff0: 5765 2064 6f6e 2774 206e 6565 6420 746f  We don't need to
-0001c000: 2073 6f6c 7665 2074 6865 2072 6567 756c   solve the regul
-0001c010: 6172 697a 6174 696f 6e20 7072 6f62 6c65  arization proble
-0001c020: 6d20 746f 206f 7074 696d 616c 6974 792e  m to optimality.
-0001c030: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001c040: 2023 2057 6520 7769 6c6c 2063 686f 6f73   # We will choos
-0001c050: 6520 746f 2070 6572 666f 726d 2061 6767  e to perform agg
-0001c060: 7265 7373 6976 6520 6e6f 6465 2070 726f  ressive node pro
-0001c070: 6269 6e67 2064 7572 696e 6720 7072 6573  bing during pres
-0001c080: 6f6c 7665 2e0a 2020 2020 2020 2020 2020  olve..          
-0001c090: 2020 2020 2020 7365 6c66 2e72 6567 756c        self.regul
-0001c0a0: 6172 697a 6174 696f 6e5f 6d69 705f 6f70  arization_mip_op
-0001c0b0: 742e 6f70 7469 6f6e 735b 276d 6970 5f73  t.options['mip_s
-0001c0c0: 7472 6174 6567 795f 7072 6573 6f6c 7665  trategy_presolve
-0001c0d0: 6e6f 6465 275d 203d 2033 0a20 2020 2020  node'] = 3.     
-0001c0e0: 2020 2020 2020 2020 2020 2023 2057 6865             # Whe
-0001c0f0: 6e20 7573 696e 6720 524f 4120 6d65 7468  n using ROA meth
-0001c100: 6f64 2074 6f20 736f 6c76 6520 636f 6e76  od to solve conv
-0001c110: 6578 204d 494e 4c50 732c 2074 6865 2048  ex MINLPs, the H
-0001c120: 6573 7369 616e 206f 6620 7468 6520 4c61  essian of the La
-0001c130: 6772 616e 6765 616e 2069 7320 616c 7761  grangean is alwa
-0001c140: 7973 2070 6f73 6974 6976 6520 7365 6d69  ys positive semi
-0001c150: 6465 6669 6e69 7465 2c0a 2020 2020 2020  definite,.      
-0001c160: 2020 2020 2020 2020 2020 2320 616e 6420            # and 
-0001c170: 7468 6520 7265 6775 6c61 7269 7a61 7469  the regularizati
-0001c180: 6f6e 2073 7562 7072 6f62 6c65 6d73 2061  on subproblems a
-0001c190: 7265 2061 6c77 6179 7320 636f 6e76 6578  re always convex
-0001c1a0: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
-0001c1b0: 2020 2320 486f 7765 7665 722c 2064 7565    # However, due
-0001c1c0: 2074 6f20 6e75 6d65 7269 6361 6c20 6163   to numerical ac
-0001c1d0: 6375 7261 6379 2c20 7468 6520 7265 6775  curacy, the regu
-0001c1e0: 6c61 7269 7a61 7469 6f6e 2070 726f 626c  larization probl
-0001c1f0: 656d 2065 6e64 6564 2075 7020 6e6f 6e63  em ended up nonc
-0001c200: 6f6e 7665 7820 666f 7220 6120 6665 7720  onvex for a few 
-0001c210: 6361 7365 732c 0a20 2020 2020 2020 2020  cases,.         
-0001c220: 2020 2020 2020 2023 2065 2e67 2e2c 2074         # e.g., t
-0001c230: 6865 2073 6d61 6c6c 6573 7420 6569 6765  he smallest eige
-0001c240: 6e76 616c 7565 206f 6620 7468 6520 4865  nvalue of the He
-0001c250: 7373 6961 6e20 7761 7320 736c 6967 6874  ssian was slight
-0001c260: 6c79 206e 6567 6174 6976 652e 0a20 2020  ly negative..   
-0001c270: 2020 2020 2020 2020 2020 2020 2023 2054               # T
-0001c280: 6865 7265 666f 7265 2c20 7765 2073 6574  herefore, we set
-0001c290: 2074 6865 206f 7074 696d 616c 6974 7974   the optimalityt
-0001c2a0: 6172 6765 7420 7061 7261 6d65 7465 7220  arget parameter 
-0001c2b0: 746f 2033 2074 6f20 656e 6162 6c65 2043  to 3 to enable C
-0001c2c0: 504c 4558 2074 6f20 736f 6c76 6520 6e6f  PLEX to solve no
-0001c2d0: 6e63 6f6e 7665 7820 4d49 5150 7320 696e  nconvex MIQPs in
-0001c2e0: 2074 6865 2052 4f41 2d4c 3220 616e 6420   the ROA-L2 and 
-0001c2f0: 524f 412d e288 8732 4c20 6d65 7468 6f64  ROA-...2L method
-0001c300: 732e 0a20 2020 2020 2020 2020 2020 2020  s..             
-0001c310: 2020 2069 6620 636f 6e66 6967 2e61 6464     if config.add
-0001c320: 5f72 6567 756c 6172 697a 6174 696f 6e20  _regularization 
-0001c330: 696e 207b 2768 6573 735f 6c61 6727 2c20  in {'hess_lag', 
-0001c340: 2768 6573 735f 6f6e 6c79 5f6c 6167 277d  'hess_only_lag'}
-0001c350: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001c360: 2020 2020 2020 7365 6c66 2e72 6567 756c        self.regul
-0001c370: 6172 697a 6174 696f 6e5f 6d69 705f 6f70  arization_mip_op
-0001c380: 742e 6f70 7469 6f6e 735b 276f 7074 696d  t.options['optim
-0001c390: 616c 6974 7974 6172 6765 7427 5d20 3d20  alitytarget'] = 
-0001c3a0: 330a 2020 2020 2020 2020 2020 2020 656c  3.            el
-0001c3b0: 6966 2063 6f6e 6669 672e 6d69 705f 7265  if config.mip_re
-0001c3c0: 6775 6c61 7269 7a61 7469 6f6e 5f73 6f6c  gularization_sol
-0001c3d0: 7665 7220 3d3d 2027 6775 726f 6269 273a  ver == 'gurobi':
-0001c3e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001c3f0: 2069 6620 636f 6e66 6967 2e73 6f6c 7574   if config.solut
-0001c400: 696f 6e5f 6c69 6d69 7420 6973 206e 6f74  ion_limit is not
-0001c410: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-0001c420: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001c430: 7265 6775 6c61 7269 7a61 7469 6f6e 5f6d  regularization_m
-0001c440: 6970 5f6f 7074 2e6f 7074 696f 6e73 5b27  ip_opt.options['
-0001c450: 536f 6c75 7469 6f6e 4c69 6d69 7427 5d20  SolutionLimit'] 
-0001c460: 3d20 280a 2020 2020 2020 2020 2020 2020  = (.            
-0001c470: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-0001c480: 6967 2e73 6f6c 7574 696f 6e5f 6c69 6d69  ig.solution_limi
-0001c490: 740a 2020 2020 2020 2020 2020 2020 2020  t.              
-0001c4a0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-0001c4b0: 2020 2020 2020 2020 2320 5361 6d65 2072          # Same r
-0001c4c0: 6561 736f 6e20 6173 206d 6970 5f73 7472  eason as mip_str
-0001c4d0: 6174 6567 795f 7072 6573 6f6c 7665 6e6f  ategy_presolveno
-0001c4e0: 6465 2e0a 2020 2020 2020 2020 2020 2020  de..            
-0001c4f0: 2020 2020 7365 6c66 2e72 6567 756c 6172      self.regular
-0001c500: 697a 6174 696f 6e5f 6d69 705f 6f70 742e  ization_mip_opt.
-0001c510: 6f70 7469 6f6e 735b 2750 7265 736f 6c76  options['Presolv
-0001c520: 6527 5d20 3d20 320a 0a20 2020 2064 6566  e'] = 2..    def
-0001c530: 2073 6574 5f61 7070 7369 5f73 6f6c 7665   set_appsi_solve
-0001c540: 725f 7570 6461 7465 5f63 6f6e 6669 6728  r_update_config(
-0001c550: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
-0001c560: 2222 5365 7420 7570 6461 7465 2063 6f6e  ""Set update con
-0001c570: 6669 6720 666f 7220 4150 5053 4920 736f  fig for APPSI so
-0001c580: 6c76 6572 732e 2222 220a 2020 2020 2020  lvers.""".      
-0001c590: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
-0001c5a0: 636f 6e66 6967 0a20 2020 2020 2020 2069  config.        i
-0001c5b0: 6620 636f 6e66 6967 2e6d 6970 5f73 6f6c  f config.mip_sol
-0001c5c0: 7665 7220 696e 207b 2761 7070 7369 5f63  ver in {'appsi_c
-0001c5d0: 706c 6578 272c 2027 6170 7073 695f 6775  plex', 'appsi_gu
-0001c5e0: 726f 6269 272c 2027 6170 7073 695f 6869  robi', 'appsi_hi
-0001c5f0: 6768 7327 7d3a 0a20 2020 2020 2020 2020  ghs'}:.         
-0001c600: 2020 2023 206d 6970 206d 6169 6e20 7072     # mip main pr
-0001c610: 6f62 6c65 6d0a 2020 2020 2020 2020 2020  oblem.          
-0001c620: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e75    self.mip_opt.u
-0001c630: 7064 6174 655f 636f 6e66 6967 2e63 6865  pdate_config.che
-0001c640: 636b 5f66 6f72 5f6e 6577 5f6f 725f 7265  ck_for_new_or_re
-0001c650: 6d6f 7665 645f 636f 6e73 7472 6169 6e74  moved_constraint
-0001c660: 7320 3d20 5472 7565 0a20 2020 2020 2020  s = True.       
-0001c670: 2020 2020 2073 656c 662e 6d69 705f 6f70       self.mip_op
-0001c680: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
-0001c690: 6368 6563 6b5f 666f 725f 6e65 775f 6f72  check_for_new_or
-0001c6a0: 5f72 656d 6f76 6564 5f76 6172 7320 3d20  _removed_vars = 
-0001c6b0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-0001c6c0: 2073 656c 662e 6d69 705f 6f70 742e 7570   self.mip_opt.up
-0001c6d0: 6461 7465 5f63 6f6e 6669 672e 6368 6563  date_config.chec
-0001c6e0: 6b5f 666f 725f 6e65 775f 6f72 5f72 656d  k_for_new_or_rem
-0001c6f0: 6f76 6564 5f70 6172 616d 7320 3d20 4661  oved_params = Fa
-0001c700: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
-0001c710: 7365 6c66 2e6d 6970 5f6f 7074 2e75 7064  self.mip_opt.upd
-0001c720: 6174 655f 636f 6e66 6967 2e63 6865 636b  ate_config.check
-0001c730: 5f66 6f72 5f6e 6577 5f6f 626a 6563 7469  _for_new_objecti
-0001c740: 7665 203d 2054 7275 650a 2020 2020 2020  ve = True.      
-0001c750: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
-0001c760: 7074 2e75 7064 6174 655f 636f 6e66 6967  pt.update_config
-0001c770: 2e75 7064 6174 655f 636f 6e73 7472 6169  .update_constrai
-0001c780: 6e74 7320 3d20 5472 7565 0a20 2020 2020  nts = True.     
-0001c790: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
-0001c7a0: 6f70 742e 7570 6461 7465 5f63 6f6e 6669  opt.update_confi
-0001c7b0: 672e 7570 6461 7465 5f76 6172 7320 3d20  g.update_vars = 
-0001c7c0: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-0001c7d0: 2073 656c 662e 6d69 705f 6f70 742e 7570   self.mip_opt.up
-0001c7e0: 6461 7465 5f63 6f6e 6669 672e 7570 6461  date_config.upda
-0001c7f0: 7465 5f70 6172 616d 7320 3d20 4661 6c73  te_params = Fals
-0001c800: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001c810: 6c66 2e6d 6970 5f6f 7074 2e75 7064 6174  lf.mip_opt.updat
-0001c820: 655f 636f 6e66 6967 2e75 7064 6174 655f  e_config.update_
-0001c830: 6e61 6d65 645f 6578 7072 6573 7369 6f6e  named_expression
-0001c840: 7320 3d20 4661 6c73 650a 2020 2020 2020  s = False.      
-0001c850: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
-0001c860: 7074 2e75 7064 6174 655f 636f 6e66 6967  pt.update_config
-0001c870: 2e75 7064 6174 655f 6f62 6a65 6374 6976  .update_objectiv
-0001c880: 6520 3d20 4661 6c73 650a 2020 2020 2020  e = False.      
-0001c890: 2020 2020 2020 7365 6c66 2e6d 6970 5f6f        self.mip_o
-0001c8a0: 7074 2e75 7064 6174 655f 636f 6e66 6967  pt.update_config
-0001c8b0: 2e74 7265 6174 5f66 6978 6564 5f76 6172  .treat_fixed_var
-0001c8c0: 735f 6173 5f70 6172 616d 7320 3d20 5472  s_as_params = Tr
-0001c8d0: 7565 0a0a 2020 2020 2020 2020 6966 2063  ue..        if c
-0001c8e0: 6f6e 6669 672e 6e6c 705f 736f 6c76 6572  onfig.nlp_solver
-0001c8f0: 203d 3d20 2761 7070 7369 5f69 706f 7074   == 'appsi_ipopt
-0001c900: 273a 0a20 2020 2020 2020 2020 2020 2023  ':.            #
-0001c910: 2066 6978 6564 2d6e 6c70 0a20 2020 2020   fixed-nlp.     
-0001c920: 2020 2020 2020 2073 656c 662e 6e6c 705f         self.nlp_
-0001c930: 6f70 742e 7570 6461 7465 5f63 6f6e 6669  opt.update_confi
-0001c940: 672e 6368 6563 6b5f 666f 725f 6e65 775f  g.check_for_new_
-0001c950: 6f72 5f72 656d 6f76 6564 5f63 6f6e 7374  or_removed_const
-0001c960: 7261 696e 7473 203d 2046 616c 7365 0a20  raints = False. 
-0001c970: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001c980: 6e6c 705f 6f70 742e 7570 6461 7465 5f63  nlp_opt.update_c
-0001c990: 6f6e 6669 672e 6368 6563 6b5f 666f 725f  onfig.check_for_
-0001c9a0: 6e65 775f 6f72 5f72 656d 6f76 6564 5f76  new_or_removed_v
-0001c9b0: 6172 7320 3d20 4661 6c73 650a 2020 2020  ars = False.    
-0001c9c0: 2020 2020 2020 2020 7365 6c66 2e6e 6c70          self.nlp
-0001c9d0: 5f6f 7074 2e75 7064 6174 655f 636f 6e66  _opt.update_conf
-0001c9e0: 6967 2e63 6865 636b 5f66 6f72 5f6e 6577  ig.check_for_new
-0001c9f0: 5f6f 725f 7265 6d6f 7665 645f 7061 7261  _or_removed_para
-0001ca00: 6d73 203d 2046 616c 7365 0a20 2020 2020  ms = False.     
-0001ca10: 2020 2020 2020 2073 656c 662e 6e6c 705f         self.nlp_
-0001ca20: 6f70 742e 7570 6461 7465 5f63 6f6e 6669  opt.update_confi
-0001ca30: 672e 6368 6563 6b5f 666f 725f 6e65 775f  g.check_for_new_
-0001ca40: 6f62 6a65 6374 6976 6520 3d20 4661 6c73  objective = Fals
-0001ca50: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001ca60: 6c66 2e6e 6c70 5f6f 7074 2e75 7064 6174  lf.nlp_opt.updat
-0001ca70: 655f 636f 6e66 6967 2e75 7064 6174 655f  e_config.update_
-0001ca80: 636f 6e73 7472 6169 6e74 7320 3d20 5472  constraints = Tr
-0001ca90: 7565 0a20 2020 2020 2020 2020 2020 2073  ue.            s
-0001caa0: 656c 662e 6e6c 705f 6f70 742e 7570 6461  elf.nlp_opt.upda
-0001cab0: 7465 5f63 6f6e 6669 672e 7570 6461 7465  te_config.update
-0001cac0: 5f76 6172 7320 3d20 5472 7565 0a20 2020  _vars = True.   
-0001cad0: 2020 2020 2020 2020 2073 656c 662e 6e6c           self.nl
-0001cae0: 705f 6f70 742e 7570 6461 7465 5f63 6f6e  p_opt.update_con
-0001caf0: 6669 672e 7570 6461 7465 5f70 6172 616d  fig.update_param
-0001cb00: 7320 3d20 4661 6c73 650a 2020 2020 2020  s = False.      
-0001cb10: 2020 2020 2020 7365 6c66 2e6e 6c70 5f6f        self.nlp_o
-0001cb20: 7074 2e75 7064 6174 655f 636f 6e66 6967  pt.update_config
-0001cb30: 2e75 7064 6174 655f 6e61 6d65 645f 6578  .update_named_ex
-0001cb40: 7072 6573 7369 6f6e 7320 3d20 4661 6c73  pressions = Fals
-0001cb50: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001cb60: 6c66 2e6e 6c70 5f6f 7074 2e75 7064 6174  lf.nlp_opt.updat
-0001cb70: 655f 636f 6e66 6967 2e75 7064 6174 655f  e_config.update_
-0001cb80: 6f62 6a65 6374 6976 6520 3d20 4661 6c73  objective = Fals
-0001cb90: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001cba0: 6c66 2e6e 6c70 5f6f 7074 2e75 7064 6174  lf.nlp_opt.updat
-0001cbb0: 655f 636f 6e66 6967 2e74 7265 6174 5f66  e_config.treat_f
-0001cbc0: 6978 6564 5f76 6172 735f 6173 5f70 6172  ixed_vars_as_par
-0001cbd0: 616d 7320 3d20 4661 6c73 650a 0a20 2020  ams = False..   
-0001cbe0: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
-0001cbf0: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
-0001cc00: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
-0001cc10: 6368 6563 6b5f 666f 725f 6e65 775f 6f72  check_for_new_or
-0001cc20: 5f72 656d 6f76 6564 5f63 6f6e 7374 7261  _removed_constra
-0001cc30: 696e 7473 203d 2028 0a20 2020 2020 2020  ints = (.       
-0001cc40: 2020 2020 2020 2020 2046 616c 7365 0a20           False. 
-0001cc50: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-0001cc60: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
-0001cc70: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
-0001cc80: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
-0001cc90: 6368 6563 6b5f 666f 725f 6e65 775f 6f72  check_for_new_or
-0001cca0: 5f72 656d 6f76 6564 5f76 6172 7320 3d20  _removed_vars = 
-0001ccb0: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
-0001ccc0: 2020 7365 6c66 2e66 6561 7369 6269 6c69    self.feasibili
-0001ccd0: 7479 5f6e 6c70 5f6f 7074 2e75 7064 6174  ty_nlp_opt.updat
-0001cce0: 655f 636f 6e66 6967 2e63 6865 636b 5f66  e_config.check_f
-0001ccf0: 6f72 5f6e 6577 5f6f 725f 7265 6d6f 7665  or_new_or_remove
-0001cd00: 645f 7061 7261 6d73 203d 2028 0a20 2020  d_params = (.   
-0001cd10: 2020 2020 2020 2020 2020 2020 2046 616c               Fal
-0001cd20: 7365 0a20 2020 2020 2020 2020 2020 2029  se.            )
-0001cd30: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001cd40: 662e 6665 6173 6962 696c 6974 795f 6e6c  f.feasibility_nl
-0001cd50: 705f 6f70 742e 7570 6461 7465 5f63 6f6e  p_opt.update_con
-0001cd60: 6669 672e 6368 6563 6b5f 666f 725f 6e65  fig.check_for_ne
-0001cd70: 775f 6f62 6a65 6374 6976 6520 3d20 4661  w_objective = Fa
-0001cd80: 6c73 650a 2020 2020 2020 2020 2020 2020  lse.            
-0001cd90: 7365 6c66 2e66 6561 7369 6269 6c69 7479  self.feasibility
-0001cda0: 5f6e 6c70 5f6f 7074 2e75 7064 6174 655f  _nlp_opt.update_
-0001cdb0: 636f 6e66 6967 2e75 7064 6174 655f 636f  config.update_co
-0001cdc0: 6e73 7472 6169 6e74 7320 3d20 4661 6c73  nstraints = Fals
-0001cdd0: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
-0001cde0: 6c66 2e66 6561 7369 6269 6c69 7479 5f6e  lf.feasibility_n
-0001cdf0: 6c70 5f6f 7074 2e75 7064 6174 655f 636f  lp_opt.update_co
-0001ce00: 6e66 6967 2e75 7064 6174 655f 7661 7273  nfig.update_vars
-0001ce10: 203d 2054 7275 650a 2020 2020 2020 2020   = True.        
-0001ce20: 2020 2020 7365 6c66 2e66 6561 7369 6269      self.feasibi
-0001ce30: 6c69 7479 5f6e 6c70 5f6f 7074 2e75 7064  lity_nlp_opt.upd
-0001ce40: 6174 655f 636f 6e66 6967 2e75 7064 6174  ate_config.updat
-0001ce50: 655f 7061 7261 6d73 203d 2046 616c 7365  e_params = False
-0001ce60: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001ce70: 662e 6665 6173 6962 696c 6974 795f 6e6c  f.feasibility_nl
-0001ce80: 705f 6f70 742e 7570 6461 7465 5f63 6f6e  p_opt.update_con
-0001ce90: 6669 672e 7570 6461 7465 5f6e 616d 6564  fig.update_named
-0001cea0: 5f65 7870 7265 7373 696f 6e73 203d 2046  _expressions = F
-0001ceb0: 616c 7365 0a20 2020 2020 2020 2020 2020  alse.           
-0001cec0: 2073 656c 662e 6665 6173 6962 696c 6974   self.feasibilit
-0001ced0: 795f 6e6c 705f 6f70 742e 7570 6461 7465  y_nlp_opt.update
-0001cee0: 5f63 6f6e 6669 672e 7570 6461 7465 5f6f  _config.update_o
-0001cef0: 626a 6563 7469 7665 203d 2046 616c 7365  bjective = False
-0001cf00: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-0001cf10: 662e 6665 6173 6962 696c 6974 795f 6e6c  f.feasibility_nl
-0001cf20: 705f 6f70 742e 7570 6461 7465 5f63 6f6e  p_opt.update_con
-0001cf30: 6669 672e 7472 6561 745f 6669 7865 645f  fig.treat_fixed_
-0001cf40: 7661 7273 5f61 735f 7061 7261 6d73 203d  vars_as_params =
-0001cf50: 2046 616c 7365 0a0a 2020 2020 6465 6620   False..    def 
-0001cf60: 736f 6c76 6528 7365 6c66 2c20 6d6f 6465  solve(self, mode
-0001cf70: 6c2c 202a 2a6b 7764 7329 3a0a 2020 2020  l, **kwds):.    
-0001cf80: 2020 2020 2222 2253 6f6c 7665 2074 6865      """Solve the
-0001cf90: 206d 6f64 656c 2e0a 0a20 2020 2020 2020   model...       
-0001cfa0: 2050 6172 616d 6574 6572 730a 2020 2020   Parameters.    
-0001cfb0: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-0001cfc0: 2020 2020 2020 206d 6f64 656c 203a 2050         model : P
-0001cfd0: 796f 6d6f 206d 6f64 656c 0a20 2020 2020  yomo model.     
-0001cfe0: 2020 2020 2020 2054 6865 204d 494e 4c50         The MINLP
-0001cff0: 206d 6f64 656c 2074 6f20 6265 2073 6f6c   model to be sol
-0001d000: 7665 642e 0a0a 2020 2020 2020 2020 5265  ved...        Re
-0001d010: 7475 726e 730a 2020 2020 2020 2020 2d2d  turns.        --
-0001d020: 2d2d 2d2d 2d0a 2020 2020 2020 2020 7265  -----.        re
-0001d030: 7375 6c74 7320 3a20 536f 6c76 6572 5265  sults : SolverRe
-0001d040: 7375 6c74 730a 2020 2020 2020 2020 2020  sults.          
-0001d050: 2020 5265 7375 6c74 7320 6672 6f6d 2073    Results from s
-0001d060: 6f6c 7669 6e67 2074 6865 204d 494e 4c50  olving the MINLP
-0001d070: 2070 726f 626c 656d 2062 7920 4d69 6e64   problem by Mind
-0001d080: 7450 792e 0a20 2020 2020 2020 2022 2222  tPy..        """
-0001d090: 0a20 2020 2020 2020 2063 6f6e 6669 6720  .        config 
-0001d0a0: 3d20 7365 6c66 2e63 6f6e 6669 6720 3d20  = self.config = 
-0001d0b0: 7365 6c66 2e43 4f4e 4649 4728 0a20 2020  self.CONFIG(.   
-0001d0c0: 2020 2020 2020 2020 206b 7764 732e 706f           kwds.po
-0001d0d0: 7028 276f 7074 696f 6e73 272c 207b 7d29  p('options', {})
-0001d0e0: 2c20 7072 6573 6572 7665 5f69 6d70 6c69  , preserve_impli
-0001d0f0: 6369 743d 5472 7565 0a20 2020 2020 2020  cit=True.       
-0001d100: 2029 0a20 2020 2020 2020 2063 6f6e 6669   ).        confi
-0001d110: 672e 7365 745f 7661 6c75 6528 6b77 6473  g.set_value(kwds
-0001d120: 290a 2020 2020 2020 2020 7365 6c66 2e73  ).        self.s
-0001d130: 6574 5f75 705f 6c6f 6767 6572 2829 0a20  et_up_logger(). 
-0001d140: 2020 2020 2020 206e 6577 5f6c 6f67 6769         new_loggi
-0001d150: 6e67 5f6c 6576 656c 203d 206c 6f67 6769  ng_level = loggi
-0001d160: 6e67 2e49 4e46 4f20 6966 2063 6f6e 6669  ng.INFO if confi
-0001d170: 672e 7465 6520 656c 7365 204e 6f6e 650a  g.tee else None.
-0001d180: 2020 2020 2020 2020 7769 7468 206c 6f77          with low
-0001d190: 6572 5f6c 6f67 6765 725f 6c65 7665 6c5f  er_logger_level_
-0001d1a0: 746f 2863 6f6e 6669 672e 6c6f 6767 6572  to(config.logger
-0001d1b0: 2c20 6e65 775f 6c6f 6767 696e 675f 6c65  , new_logging_le
-0001d1c0: 7665 6c29 3a0a 2020 2020 2020 2020 2020  vel):.          
-0001d1d0: 2020 7365 6c66 2e63 6865 636b 5f63 6f6e    self.check_con
-0001d1e0: 6669 6728 290a 0a20 2020 2020 2020 2073  fig()..        s
-0001d1f0: 656c 662e 7365 745f 7570 5f73 6f6c 7665  elf.set_up_solve
-0001d200: 5f64 6174 6128 6d6f 6465 6c29 0a0a 2020  _data(model)..  
-0001d210: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
-0001d220: 696e 7465 6765 725f 746f 5f62 696e 6172  integer_to_binar
-0001d230: 793a 0a20 2020 2020 2020 2020 2020 2054  y:.            T
-0001d240: 7261 6e73 666f 726d 6174 696f 6e46 6163  ransformationFac
-0001d250: 746f 7279 2827 636f 6e74 7269 622e 696e  tory('contrib.in
-0001d260: 7465 6765 725f 746f 5f62 696e 6172 7927  teger_to_binary'
-0001d270: 292e 6170 706c 795f 746f 280a 2020 2020  ).apply_to(.    
-0001d280: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001d290: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 0a20  .working_model. 
-0001d2a0: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
-0001d2b0: 2020 2020 2020 7365 6c66 2e63 7265 6174        self.creat
-0001d2c0: 655f 7574 696c 6974 795f 626c 6f63 6b28  e_utility_block(
-0001d2d0: 7365 6c66 2e77 6f72 6b69 6e67 5f6d 6f64  self.working_mod
-0001d2e0: 656c 2c20 274d 696e 6474 5079 5f75 7469  el, 'MindtPy_uti
-0001d2f0: 6c73 2729 0a20 2020 2020 2020 2077 6974  ls').        wit
-0001d300: 6820 7469 6d65 5f63 6f64 6528 7365 6c66  h time_code(self
-0001d310: 2e74 696d 696e 672c 2027 746f 7461 6c27  .timing, 'total'
-0001d320: 2c20 6973 5f6d 6169 6e5f 7469 6d65 723d  , is_main_timer=
-0001d330: 5472 7565 292c 206c 6f77 6572 5f6c 6f67  True), lower_log
-0001d340: 6765 725f 6c65 7665 6c5f 746f 280a 2020  ger_level_to(.  
-0001d350: 2020 2020 2020 2020 2020 636f 6e66 6967            config
-0001d360: 2e6c 6f67 6765 722c 206e 6577 5f6c 6f67  .logger, new_log
-0001d370: 6769 6e67 5f6c 6576 656c 0a20 2020 2020  ging_level.     
-0001d380: 2020 2029 3a0a 2020 2020 2020 2020 2020     ):.          
-0001d390: 2020 7365 6c66 2e5f 6c6f 675f 736f 6c76    self._log_solv
-0001d3a0: 6572 5f69 6e74 726f 5f6d 6573 7361 6765  er_intro_message
-0001d3b0: 2829 0a20 2020 2020 2020 2020 2020 2073  ().            s
-0001d3c0: 656c 662e 696e 6974 6961 6c69 7a65 5f73  elf.initialize_s
-0001d3d0: 7562 736f 6c76 6572 7328 290a 0a20 2020  ubsolvers()..   
-0001d3e0: 2020 2020 2020 2020 2023 2056 616c 6964           # Valid
-0001d3f0: 6174 6520 7468 6520 6d6f 6465 6c20 746f  ate the model to
-0001d400: 2065 6e73 7572 6520 7468 6174 204d 696e   ensure that Min
-0001d410: 6474 5079 2069 7320 6162 6c65 2074 6f20  dtPy is able to 
-0001d420: 736f 6c76 6520 6974 2e0a 2020 2020 2020  solve it..      
-0001d430: 2020 2020 2020 6966 206e 6f74 2073 656c        if not sel
-0001d440: 662e 6d6f 6465 6c5f 6973 5f76 616c 6964  f.model_is_valid
-0001d450: 2829 3a0a 2020 2020 2020 2020 2020 2020  ():.            
-0001d460: 2020 2020 7265 7475 726e 0a0a 2020 2020      return..    
-0001d470: 2020 2020 2020 2020 4d69 6e64 7450 7920          MindtPy 
-0001d480: 3d20 7365 6c66 2e77 6f72 6b69 6e67 5f6d  = self.working_m
-0001d490: 6f64 656c 2e4d 696e 6474 5079 5f75 7469  odel.MindtPy_uti
-0001d4a0: 6c73 0a0a 2020 2020 2020 2020 2020 2020  ls..            
-0001d4b0: 7365 7475 705f 7265 7375 6c74 735f 6f62  setup_results_ob
-0001d4c0: 6a65 6374 2873 656c 662e 7265 7375 6c74  ject(self.result
-0001d4d0: 732c 2073 656c 662e 6f72 6967 696e 616c  s, self.original
-0001d4e0: 5f6d 6f64 656c 2c20 636f 6e66 6967 290a  _model, config).
-0001d4f0: 0a20 2020 2020 2020 2020 2020 2023 2052  .            # R
-0001d500: 6566 6f72 6d75 6c61 7465 2074 6865 206f  eformulate the o
-0001d510: 626a 6563 7469 7665 2066 756e 6374 696f  bjective functio
-0001d520: 6e2e 0a20 2020 2020 2020 2020 2020 2073  n..            s
-0001d530: 656c 662e 6f62 6a65 6374 6976 655f 7265  elf.objective_re
-0001d540: 666f 726d 756c 6174 696f 6e28 290a 0a20  formulation().. 
-0001d550: 2020 2020 2020 2020 2020 2023 2053 6176             # Sav
-0001d560: 6520 6d6f 6465 6c20 696e 6974 6961 6c20  e model initial 
-0001d570: 7661 6c75 6573 2e0a 2020 2020 2020 2020  values..        
-0001d580: 2020 2020 7365 6c66 2e69 6e69 7469 616c      self.initial
-0001d590: 5f76 6172 5f76 616c 7565 7320 3d20 6c69  _var_values = li
-0001d5a0: 7374 2876 2e76 616c 7565 2066 6f72 2076  st(v.value for v
-0001d5b0: 2069 6e20 4d69 6e64 7450 792e 7661 7269   in MindtPy.vari
-0001d5c0: 6162 6c65 5f6c 6973 7429 0a0a 2020 2020  able_list)..    
-0001d5d0: 2020 2020 2020 2020 2320 544f 444f 3a20          # TODO: 
-0001d5e0: 6966 2074 6865 204d 696e 6474 5079 2073  if the MindtPy s
-0001d5f0: 6f6c 7665 7220 6973 2064 6566 696e 6564  olver is defined
-0001d600: 206f 6e63 6520 616e 6420 6361 6c6c 6564   once and called
-0001d610: 2073 6576 6572 616c 2074 696d 6573 2074   several times t
-0001d620: 6f20 736f 6c76 6520 6d6f 6465 6c73 2e20  o solve models. 
-0001d630: 5468 6520 666f 6c6c 6f77 696e 6720 7477  The following tw
-0001d640: 6f20 6c69 6e65 7320 6172 6520 6e65 6365  o lines are nece
-0001d650: 7373 6172 792e 2049 7420 7365 656d 7320  ssary. It seems 
-0001d660: 7468 6174 2074 6865 2073 6f6c 7665 7220  that the solver 
-0001d670: 636c 6173 7320 7769 6c6c 206e 6f74 2062  class will not b
-0001d680: 6520 696e 6974 2065 7665 7279 2074 696d  e init every tim
-0001d690: 6520 6361 6c6c 2e0a 2020 2020 2020 2020  e call..        
-0001d6a0: 2020 2020 2320 466f 7220 6578 616d 706c      # For exampl
-0001d6b0: 652c 2069 6620 7765 2072 656d 6f76 6520  e, if we remove 
-0001d6c0: 7468 6520 666f 6c6c 6f77 696e 6720 7477  the following tw
-0001d6d0: 6f20 6c69 6e65 732e 2074 6573 745f 524c  o lines. test_RL
-0001d6e0: 504e 4c50 5f4c 3120 7769 6c6c 2066 6169  PNLP_L1 will fai
-0001d6f0: 6c2e 0a20 2020 2020 2020 2020 2020 2073  l..            s
-0001d700: 656c 662e 6265 7374 5f73 6f6c 7574 696f  elf.best_solutio
-0001d710: 6e5f 666f 756e 6420 3d20 4e6f 6e65 0a20  n_found = None. 
-0001d720: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001d730: 6265 7374 5f73 6f6c 7574 696f 6e5f 666f  best_solution_fo
-0001d740: 756e 645f 7469 6d65 203d 204e 6f6e 650a  und_time = None.
-0001d750: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001d760: 2e69 6e69 7469 616c 697a 655f 6d69 705f  .initialize_mip_
-0001d770: 7072 6f62 6c65 6d28 290a 0a20 2020 2020  problem()..     
-0001d780: 2020 2020 2020 2023 2049 6e69 7469 616c         # Initial
-0001d790: 697a 6174 696f 6e0a 2020 2020 2020 2020  ization.        
-0001d7a0: 2020 2020 7769 7468 2074 696d 655f 636f      with time_co
-0001d7b0: 6465 2873 656c 662e 7469 6d69 6e67 2c20  de(self.timing, 
-0001d7c0: 2769 6e69 7469 616c 697a 6174 696f 6e27  'initialization'
-0001d7d0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-0001d7e0: 2020 2073 656c 662e 4d69 6e64 7450 795f     self.MindtPy_
-0001d7f0: 696e 6974 6961 6c69 7a61 7469 6f6e 2829  initialization()
-0001d800: 0a0a 2020 2020 2020 2020 2020 2020 2320  ..            # 
-0001d810: 416c 676f 7269 7468 6d20 6d61 696e 206c  Algorithm main l
-0001d820: 6f6f 700a 2020 2020 2020 2020 2020 2020  oop.            
-0001d830: 7769 7468 2074 696d 655f 636f 6465 2873  with time_code(s
-0001d840: 656c 662e 7469 6d69 6e67 2c20 276d 6169  elf.timing, 'mai
-0001d850: 6e20 6c6f 6f70 2729 3a0a 2020 2020 2020  n loop'):.      
-0001d860: 2020 2020 2020 2020 2020 7365 6c66 2e4d            self.M
-0001d870: 696e 6474 5079 5f69 7465 7261 7469 6f6e  indtPy_iteration
-0001d880: 5f6c 6f6f 7028 290a 0a20 2020 2020 2020  _loop()..       
-0001d890: 2020 2020 2023 204c 6f61 6420 736f 6c75       # Load solu
-0001d8a0: 7469 6f6e 0a20 2020 2020 2020 2020 2020  tion.           
-0001d8b0: 2069 6620 7365 6c66 2e62 6573 745f 736f   if self.best_so
-0001d8c0: 6c75 7469 6f6e 5f66 6f75 6e64 2069 7320  lution_found is 
-0001d8d0: 6e6f 7420 4e6f 6e65 3a0a 2020 2020 2020  not None:.      
-0001d8e0: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
-0001d8f0: 6f61 645f 736f 6c75 7469 6f6e 2829 0a0a  oad_solution()..
-0001d900: 2020 2020 2020 2020 2020 2020 2320 4765              # Ge
-0001d910: 7420 696e 7465 6772 616c 2069 6e66 6f0a  t integral info.
-0001d920: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001d930: 2e67 6574 5f69 6e74 6567 7261 6c5f 696e  .get_integral_in
-0001d940: 666f 2829 0a0a 2020 2020 2020 2020 2020  fo()..          
-0001d950: 2020 636f 6e66 6967 2e6c 6f67 6765 722e    config.logger.
-0001d960: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-0001d970: 2020 2020 2020 2720 7b3a 3c32 357d 3a20        ' {:<25}: 
-0001d980: 2020 7b3a 3e37 2e34 667d 2027 2e66 6f72    {:>7.4f} '.for
-0001d990: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-0001d9a0: 2020 2020 2020 2020 2027 5072 696d 616c           'Primal
-0001d9b0: 2d64 7561 6c20 6761 7020 696e 7465 6772  -dual gap integr
-0001d9c0: 616c 272c 2073 656c 662e 7072 696d 616c  al', self.primal
-0001d9d0: 5f64 7561 6c5f 6761 705f 696e 7465 6772  _dual_gap_integr
-0001d9e0: 616c 0a20 2020 2020 2020 2020 2020 2020  al.             
-0001d9f0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
-0001da00: 2029 0a0a 2020 2020 2020 2020 2320 5570   )..        # Up
-0001da10: 6461 7465 2072 6573 756c 740a 2020 2020  date result.    
-0001da20: 2020 2020 7365 6c66 2e75 7064 6174 655f      self.update_
-0001da30: 7265 7375 6c74 2829 0a20 2020 2020 2020  result().       
-0001da40: 2069 6620 636f 6e66 6967 2e73 696e 676c   if config.singl
-0001da50: 655f 7472 6565 3a0a 2020 2020 2020 2020  e_tree:.        
-0001da60: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
-0001da70: 2e73 6f6c 7665 722e 6e75 6d5f 6e6f 6465  .solver.num_node
-0001da80: 7320 3d20 7365 6c66 2e6e 6c70 5f69 7465  s = self.nlp_ite
-0001da90: 7220 2d20 280a 2020 2020 2020 2020 2020  r - (.          
-0001daa0: 2020 2020 2020 3120 6966 2063 6f6e 6669        1 if confi
-0001dab0: 672e 696e 6974 5f73 7472 6174 6567 7920  g.init_strategy 
-0001dac0: 3d3d 2027 724e 4c50 2720 656c 7365 2030  == 'rNLP' else 0
-0001dad0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
-0001dae0: 2020 2020 2020 2020 7265 7475 726e 2073          return s
-0001daf0: 656c 662e 7265 7375 6c74 730a 0a20 2020  elf.results..   
-0001db00: 2064 6566 206f 626a 6563 7469 7665 5f72   def objective_r
-0001db10: 6566 6f72 6d75 6c61 7469 6f6e 2873 656c  eformulation(sel
-0001db20: 6629 3a0a 2020 2020 2020 2020 2320 496e  f):.        # In
-0001db30: 2074 6865 2070 726f 6365 7373 5f6f 626a   the process_obj
-0001db40: 6563 7469 7665 2066 756e 6374 696f 6e2c  ective function,
-0001db50: 2061 7320 6c6f 6e67 2061 7320 7468 6520   as long as the 
-0001db60: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
-0001db70: 6f6e 2069 7320 6e6f 6e6c 696e 6561 722c  on is nonlinear,
-0001db80: 2069 7420 7769 6c6c 2062 6520 7265 666f   it will be refo
-0001db90: 726d 756c 6174 6564 2061 6e64 2074 6865  rmulated and the
-0001dba0: 2076 6172 6961 626c 652f 636f 6e73 7472   variable/constr
-0001dbb0: 6169 6e74 2f6f 626a 6563 7469 7665 206c  aint/objective l
-0001dbc0: 6973 7473 2077 696c 6c20 6265 2075 7064  ists will be upd
-0001dbd0: 6174 6564 2e0a 2020 2020 2020 2020 2320  ated..        # 
-0001dbe0: 466f 7220 4f41 2f47 4f41 2f4c 502d 4e4c  For OA/GOA/LP-NL
-0001dbf0: 5020 616c 676f 7269 7468 6d2c 2069 6620  P algorithm, if 
-0001dc00: 7468 6520 6f62 6a65 6374 6976 6520 6675  the objective fu
-0001dc10: 6e63 7469 6f6e 2069 7320 6c69 6e65 6172  nction is linear
-0001dc20: 2c20 6974 2077 696c 6c20 6e6f 7420 6265  , it will not be
-0001dc30: 2072 6566 6f72 6d75 6c61 7465 6420 6173   reformulated as
-0001dc40: 2065 7069 6772 6170 6820 636f 6e73 7472   epigraph constr
-0001dc50: 6169 6e74 2e0a 2020 2020 2020 2020 2320  aint..        # 
-0001dc60: 4966 2074 6865 206f 626a 6563 7469 7665  If the objective
-0001dc70: 2066 756e 6374 696f 6e20 6973 206c 696e   function is lin
-0001dc80: 6561 722c 2069 7420 7769 6c6c 2062 6520  ear, it will be 
-0001dc90: 7265 666f 726d 756c 6174 6564 2061 7320  reformulated as 
-0001dca0: 6570 6967 7261 7068 2063 6f6e 7374 7261  epigraph constra
-0001dcb0: 696e 7420 6f6e 6c79 2069 6620 7468 6520  int only if the 
-0001dcc0: 4665 6173 6962 696c 6974 7920 5075 6d70  Feasibility Pump
-0001dcd0: 206f 7220 524f 412f 524c 502d 4e4c 5020   or ROA/RLP-NLP 
-0001dce0: 616c 676f 7269 7468 6d20 6973 2061 6374  algorithm is act
-0001dcf0: 6976 6174 6564 2e20 286d 6f76 655f 6f62  ivated. (move_ob
-0001dd00: 6a65 6374 6976 6520 3d20 5472 7565 290a  jective = True).
-0001dd10: 2020 2020 2020 2020 2320 496e 2073 6f6d          # In som
-0001dd20: 6520 6361 7365 732c 2074 6865 2076 6172  e cases, the var
-0001dd30: 6961 626c 652f 636f 6e73 7472 6169 6e74  iable/constraint
-0001dd40: 2f6f 626a 6563 7469 7665 206c 6973 7473  /objective lists
-0001dd50: 2077 696c 6c20 6e6f 7420 6265 2075 7064   will not be upd
-0001dd60: 6174 6564 2065 7665 6e20 6966 2074 6865  ated even if the
-0001dd70: 206f 626a 6563 7469 7665 2069 7320 6570   objective is ep
-0001dd80: 6967 7261 7068 2d72 6566 6f72 6d75 6c61  igraph-reformula
-0001dd90: 7465 642e 0a20 2020 2020 2020 2023 2049  ted..        # I
-0001dda0: 6e20 4665 6173 6962 696c 6974 7920 5075  n Feasibility Pu
-0001ddb0: 6d70 2c20 7369 6e63 6520 7468 6520 6469  mp, since the di
-0001ddc0: 7374 616e 6365 2063 616c 6375 6c61 7469  stance calculati
-0001ddd0: 6f6e 206f 6e6c 7920 696e 636c 7564 6573  on only includes
-0001dde0: 2064 6973 6372 6574 6520 7661 7269 6162   discrete variab
-0001ddf0: 6c65 7320 616e 6420 7468 6520 6570 6967  les and the epig
-0001de00: 7261 7068 2073 6c61 636b 2076 6172 6961  raph slack varia
-0001de10: 626c 6573 2061 7265 2063 6f6e 7469 6e75  bles are continu
-0001de20: 6f75 7320 7661 7269 6162 6c65 732c 2074  ous variables, t
-0001de30: 6865 2046 6561 7369 6269 6c69 7479 2050  he Feasibility P
-0001de40: 756d 7020 616c 676f 7269 7468 6d20 7769  ump algorithm wi
-0001de50: 6c6c 206e 6f74 2061 6666 6563 7465 6420  ll not affected 
-0001de60: 6576 656e 2069 6620 7468 6520 7661 7269  even if the vari
-0001de70: 6162 6c65 206c 6973 7420 6172 6520 7570  able list are up
-0001de80: 6461 7465 642e 0a20 2020 2020 2020 2023  dated..        #
-0001de90: 2049 6e20 524f 4120 616e 6420 524c 502f   In ROA and RLP/
-0001dea0: 4e4c 502c 2073 696e 6365 2074 6865 2064  NLP, since the d
-0001deb0: 6973 7461 6e63 6520 6361 6c63 756c 6174  istance calculat
-0001dec0: 696f 6e20 646f 6573 206e 6f74 2069 6e63  ion does not inc
-0001ded0: 6c75 6465 2074 6865 7365 2065 7069 6772  lude these epigr
-0001dee0: 6170 6820 736c 6163 6b20 7661 7269 6162  aph slack variab
-0001def0: 6c65 732c 2074 6865 7920 7368 6f75 6c64  les, they should
-0001df00: 206e 6f74 2062 6520 6164 6465 6420 746f   not be added to
-0001df10: 2074 6865 2076 6172 6961 626c 6520 6c69   the variable li
-0001df20: 7374 2e20 2875 7064 6174 655f 7661 725f  st. (update_var_
-0001df30: 636f 6e5f 6c69 7374 203d 2046 616c 7365  con_list = False
-0001df40: 290a 2020 2020 2020 2020 2320 496e 2074  ).        # In t
-0001df50: 6865 2070 726f 6365 7373 5f6f 626a 6563  he process_objec
-0001df60: 7469 7665 2066 756e 6374 696f 6e2c 206f  tive function, o
-0001df70: 6e63 6520 7468 6520 6f62 6a65 6374 6976  nce the objectiv
-0001df80: 6520 6675 6e63 7469 6f6e 2068 6173 2062  e function has b
-0001df90: 6565 6e20 7265 666f 726d 756c 6174 6564  een reformulated
-0001dfa0: 2061 7320 6570 6967 7261 7068 2063 6f6e   as epigraph con
-0001dfb0: 7374 7261 696e 742c 2074 6865 2076 6172  straint, the var
-0001dfc0: 6961 626c 652f 636f 6e73 7472 6169 6e74  iable/constraint
-0001dfd0: 2f6f 626a 6563 7469 7665 206c 6973 7473  /objective lists
-0001dfe0: 2077 696c 6c20 6e6f 7420 6265 2075 7064   will not be upd
-0001dff0: 6174 6564 206f 6e6c 7920 6966 2074 6865  ated only if the
-0001e000: 204d 494e 4c50 2068 6173 2061 206c 696e   MINLP has a lin
-0001e010: 6561 7220 6f62 6a65 6374 6976 6520 6675  ear objective fu
-0001e020: 6e63 7469 6f6e 2061 6e64 2072 6567 756c  nction and regul
-0001e030: 6172 697a 6174 696f 6e20 6973 2061 6374  arization is act
-0001e040: 6976 6174 6564 2061 7420 7468 6520 7361  ivated at the sa
-0001e050: 6d65 2074 696d 652e 0a20 2020 2020 2020  me time..       
-0001e060: 2023 2054 6869 7320 6973 2062 6563 6175   # This is becau
-0001e070: 7365 2074 6865 2065 7069 6772 6170 6820  se the epigraph 
-0001e080: 636f 6e73 7472 6169 6e74 2069 7320 7665  constraint is ve
-0001e090: 7279 2022 666c 6174 2220 666f 7220 6272  ry "flat" for br
-0001e0a0: 616e 6368 696e 6720 7275 6c65 732e 2054  anching rules. T
-0001e0b0: 6865 206f 7269 6769 6e61 6c20 6f62 6a65  he original obje
-0001e0c0: 6374 6976 6520 6675 6e63 7469 6f6e 2077  ctive function w
-0001e0d0: 696c 6c20 6265 2075 7365 6420 666f 7220  ill be used for 
-0001e0e0: 7468 6520 6d61 696e 2070 726f 626c 656d  the main problem
-0001e0f0: 2061 6e64 2065 7069 6772 6170 6820 7265   and epigraph re
-0001e100: 666f 726d 756c 6174 696f 6e20 7769 6c6c  formulation will
-0001e110: 2062 6520 7573 6564 2066 6f72 2074 6865   be used for the
-0001e120: 2070 726f 6a65 6374 696f 6e20 7072 6f62   projection prob
-0001e130: 6c65 6d2e 0a20 2020 2020 2020 2073 656c  lem..        sel
-0001e140: 662e 7072 6f63 6573 735f 6f62 6a65 6374  f.process_object
-0001e150: 6976 6528 7570 6461 7465 5f76 6172 5f63  ive(update_var_c
-0001e160: 6f6e 5f6c 6973 743d 5472 7565 290a 0a20  on_list=True).. 
-0001e170: 2020 2064 6566 2068 616e 646c 655f 6d61     def handle_ma
-0001e180: 696e 5f6d 6970 5f74 6572 6d69 6e61 7469  in_mip_terminati
-0001e190: 6f6e 2873 656c 662c 206d 6169 6e5f 6d69  on(self, main_mi
-0001e1a0: 702c 206d 6169 6e5f 6d69 705f 7265 7375  p, main_mip_resu
-0001e1b0: 6c74 7329 3a0a 2020 2020 2020 2020 7368  lts):.        sh
-0001e1c0: 6f75 6c64 5f74 6572 6d69 6e61 7465 203d  ould_terminate =
-0001e1d0: 2046 616c 7365 0a20 2020 2020 2020 2069   False.        i
-0001e1e0: 6620 6d61 696e 5f6d 6970 5f72 6573 756c  f main_mip_resul
-0001e1f0: 7473 2069 7320 6e6f 7420 4e6f 6e65 3a0a  ts is not None:.
-0001e200: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-0001e210: 6f74 2073 656c 662e 636f 6e66 6967 2e73  ot self.config.s
-0001e220: 696e 676c 655f 7472 6565 3a0a 2020 2020  ingle_tree:.    
-0001e230: 2020 2020 2020 2020 2020 2020 6966 206d              if m
-0001e240: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
-0001e250: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-0001e260: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 7320  on_condition is 
-0001e270: 7463 2e6f 7074 696d 616c 3a0a 2020 2020  tc.optimal:.    
-0001e280: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e290: 7365 6c66 2e68 616e 646c 655f 6d61 696e  self.handle_main
-0001e2a0: 5f6f 7074 696d 616c 286d 6169 6e5f 6d69  _optimal(main_mi
-0001e2b0: 7029 0a20 2020 2020 2020 2020 2020 2020  p).             
-0001e2c0: 2020 2065 6c69 6620 6d61 696e 5f6d 6970     elif main_mip
-0001e2d0: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
-0001e2e0: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
-0001e2f0: 6974 696f 6e20 6973 2074 632e 696e 6665  ition is tc.infe
-0001e300: 6173 6962 6c65 3a0a 2020 2020 2020 2020  asible:.        
-0001e310: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001e320: 2e68 616e 646c 655f 6d61 696e 5f69 6e66  .handle_main_inf
-0001e330: 6561 7369 626c 6528 290a 2020 2020 2020  easible().      
-0001e340: 2020 2020 2020 2020 2020 2020 2020 7365                se
-0001e350: 6c66 2e6c 6173 745f 6974 6572 5f63 7574  lf.last_iter_cut
-0001e360: 7320 3d20 5472 7565 0a20 2020 2020 2020  s = True.       
-0001e370: 2020 2020 2020 2020 2020 2020 2073 686f               sho
-0001e380: 756c 645f 7465 726d 696e 6174 6520 3d20  uld_terminate = 
-0001e390: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-0001e3a0: 2020 2020 2065 6c69 6620 6d61 696e 5f6d       elif main_m
-0001e3b0: 6970 5f72 6573 756c 7473 2e73 6f6c 7665  ip_results.solve
-0001e3c0: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-0001e3d0: 6e64 6974 696f 6e20 6973 2074 632e 756e  ndition is tc.un
-0001e3e0: 626f 756e 6465 643a 0a20 2020 2020 2020  bounded:.       
-0001e3f0: 2020 2020 2020 2020 2020 2020 2074 656d               tem
-0001e400: 705f 7265 7375 6c74 7320 3d20 7365 6c66  p_results = self
-0001e410: 2e68 616e 646c 655f 6d61 696e 5f75 6e62  .handle_main_unb
-0001e420: 6f75 6e64 6564 286d 6169 6e5f 6d69 7029  ounded(main_mip)
-0001e430: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e440: 2065 6c69 6620 280a 2020 2020 2020 2020   elif (.        
-0001e450: 2020 2020 2020 2020 2020 2020 6d61 696e              main
-0001e460: 5f6d 6970 5f72 6573 756c 7473 2e73 6f6c  _mip_results.sol
-0001e470: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
-0001e480: 636f 6e64 6974 696f 6e0a 2020 2020 2020  condition.      
-0001e490: 2020 2020 2020 2020 2020 2020 2020 6973                is
-0001e4a0: 2074 632e 696e 6665 6173 6962 6c65 4f72   tc.infeasibleOr
-0001e4b0: 556e 626f 756e 6465 640a 2020 2020 2020  Unbounded.      
-0001e4c0: 2020 2020 2020 2020 2020 293a 0a20 2020            ):.   
-0001e4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e4e0: 2074 656d 705f 7265 7375 6c74 7320 3d20   temp_results = 
-0001e4f0: 7365 6c66 2e68 616e 646c 655f 6d61 696e  self.handle_main
-0001e500: 5f75 6e62 6f75 6e64 6564 286d 6169 6e5f  _unbounded(main_
-0001e510: 6d69 7029 0a20 2020 2020 2020 2020 2020  mip).           
-0001e520: 2020 2020 2020 2020 2069 6620 7465 6d70           if temp
-0001e530: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
-0001e540: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
-0001e550: 6974 696f 6e20 6973 2074 632e 696e 6665  ition is tc.infe
-0001e560: 6173 6962 6c65 3a0a 2020 2020 2020 2020  asible:.        
-0001e570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e580: 7365 6c66 2e68 616e 646c 655f 6d61 696e  self.handle_main
-0001e590: 5f69 6e66 6561 7369 626c 6528 290a 2020  _infeasible().  
-0001e5a0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-0001e5b0: 6966 206d 6169 6e5f 6d69 705f 7265 7375  if main_mip_resu
-0001e5c0: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
-0001e5d0: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
-0001e5e0: 2069 7320 7463 2e6d 6178 5469 6d65 4c69   is tc.maxTimeLi
-0001e5f0: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
-0001e600: 2020 2020 2020 2020 2073 656c 662e 6861           self.ha
-0001e610: 6e64 6c65 5f6d 6169 6e5f 6d61 785f 7469  ndle_main_max_ti
-0001e620: 6d65 6c69 6d69 7428 6d61 696e 5f6d 6970  melimit(main_mip
-0001e630: 2c20 6d61 696e 5f6d 6970 5f72 6573 756c  , main_mip_resul
-0001e640: 7473 290a 2020 2020 2020 2020 2020 2020  ts).            
-0001e650: 2020 2020 2020 2020 7365 6c66 2e72 6573          self.res
-0001e660: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
-0001e670: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
-0001e680: 6e20 3d20 7463 2e6d 6178 5469 6d65 4c69  n = tc.maxTimeLi
-0001e690: 6d69 740a 2020 2020 2020 2020 2020 2020  mit.            
-0001e6a0: 2020 2020 656c 6966 206d 6169 6e5f 6d69      elif main_mi
-0001e6b0: 705f 7265 7375 6c74 732e 736f 6c76 6572  p_results.solver
-0001e6c0: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-0001e6d0: 6469 7469 6f6e 2069 7320 7463 2e66 6561  dition is tc.fea
-0001e6e0: 7369 626c 6520 6f72 2028 0a20 2020 2020  sible or (.     
-0001e6f0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0001e700: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
-0001e710: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-0001e720: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 7320  on_condition is 
-0001e730: 7463 2e6f 7468 6572 0a20 2020 2020 2020  tc.other.       
-0001e740: 2020 2020 2020 2020 2020 2020 2061 6e64               and
-0001e750: 206d 6169 6e5f 6d69 705f 7265 7375 6c74   main_mip_result
-0001e760: 732e 736f 6c75 7469 6f6e 2e73 7461 7475  s.solution.statu
-0001e770: 7320 6973 2053 6f6c 7574 696f 6e53 7461  s is SolutionSta
-0001e780: 7475 732e 6665 6173 6962 6c65 0a20 2020  tus.feasible.   
-0001e790: 2020 2020 2020 2020 2020 2020 2029 3a0a               ):.
-0001e7a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e7b0: 2020 2020 2320 6c6f 6164 2074 6865 2073      # load the s
-0001e7c0: 6f6c 7574 696f 6e20 616e 6420 7375 7070  olution and supp
-0001e7d0: 7265 7373 2074 6865 2077 6172 6e69 6e67  ress the warning
-0001e7e0: 206d 6573 7361 6765 2062 7920 7365 7474   message by sett
-0001e7f0: 696e 670a 2020 2020 2020 2020 2020 2020  ing.            
-0001e800: 2020 2020 2020 2020 2320 736f 6c76 6572          # solver
-0001e810: 2073 7461 7475 7320 746f 206f 6b2e 0a20   status to ok.. 
-0001e820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e830: 2020 204d 696e 6474 5079 203d 206d 6169     MindtPy = mai
-0001e840: 6e5f 6d69 702e 4d69 6e64 7450 795f 7574  n_mip.MindtPy_ut
-0001e850: 696c 730a 2020 2020 2020 2020 2020 2020  ils.            
-0001e860: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
-0001e870: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
-0001e880: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001e890: 2020 2020 2020 2020 2027 4d49 4c50 2073           'MILP s
-0001e8a0: 6f6c 7665 7220 7265 706f 7274 6564 2066  olver reported f
-0001e8b0: 6561 7369 626c 6520 736f 6c75 7469 6f6e  easible solution
-0001e8c0: 2c20 270a 2020 2020 2020 2020 2020 2020  , '.            
-0001e8d0: 2020 2020 2020 2020 2020 2020 2762 7574              'but
-0001e8e0: 206e 6f74 2067 7561 7261 6e74 6565 6420   not guaranteed 
-0001e8f0: 746f 2062 6520 6f70 7469 6d61 6c2e 270a  to be optimal.'.
-0001e900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e910: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-0001e920: 2020 2020 2020 2020 2020 636f 7079 5f76            copy_v
-0001e930: 6172 5f6c 6973 745f 7661 6c75 6573 280a  ar_list_values(.
+00019b20: 2746 6561 7369 6269 6c69 7479 2070 756d  'Feasibility pum
+00019b30: 7020 4669 7865 642d 4e4c 5020 6973 2069  p Fixed-NLP is i
+00019b40: 6e66 6561 7369 626c 652c 2073 6f6d 6574  nfeasible, somet
+00019b50: 6869 6e67 206d 6967 6874 2062 6520 7772  hing might be wr
+00019b60: 6f6e 672e 2027 0a20 2020 2020 2020 2020  ong. '.         
+00019b70: 2020 2020 2020 2020 2020 2027 5468 6572             'Ther
+00019b80: 6520 6d69 6768 7420 6265 2061 2070 726f  e might be a pro
+00019b90: 626c 656d 2077 6974 6820 7468 6520 7072  blem with the pr
+00019ba0: 6563 6973 696f 6e73 202d 2074 6865 2066  ecisions - the f
+00019bb0: 6561 7369 6269 6c69 7479 2070 756d 7020  easibility pump 
+00019bc0: 7365 656d 7320 746f 2068 6176 6520 636f  seems to have co
+00019bd0: 6e76 6572 6765 6427 0a20 2020 2020 2020  nverged'.       
+00019be0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+00019bf0: 6465 6620 6861 6e64 6c65 5f66 705f 6d61  def handle_fp_ma
+00019c00: 696e 5f74 6328 7365 6c66 2c20 6670 5f6d  in_tc(self, fp_m
+00019c10: 6169 6e5f 7265 7375 6c74 7329 3a0a 2020  ain_results):.  
+00019c20: 2020 2020 2020 2222 2248 616e 646c 6520        """Handle 
+00019c30: 7468 6520 7465 726d 696e 6174 696f 6e20  the termination 
+00019c40: 636f 6e64 6974 696f 6e20 6f66 2074 6865  condition of the
+00019c50: 2066 6561 7369 6269 6c69 7479 2070 756d   feasibility pum
+00019c60: 7020 6d61 696e 2070 726f 626c 656d 2e0a  p main problem..
+00019c70: 0a20 2020 2020 2020 2050 6172 616d 6574  .        Paramet
+00019c80: 6572 730a 2020 2020 2020 2020 2d2d 2d2d  ers.        ----
+00019c90: 2d2d 2d2d 2d2d 0a20 2020 2020 2020 2066  ------.        f
+00019ca0: 705f 6d61 696e 5f72 6573 756c 7473 203a  p_main_results :
+00019cb0: 2053 6f6c 7665 7252 6573 756c 7473 0a20   SolverResults. 
+00019cc0: 2020 2020 2020 2020 2020 2054 6865 2072             The r
+00019cd0: 6573 756c 7473 2066 726f 6d20 736f 6c76  esults from solv
+00019ce0: 696e 6720 7468 6520 4650 206d 6169 6e20  ing the FP main 
+00019cf0: 7072 6f62 6c65 6d2e 0a0a 2020 2020 2020  problem...      
+00019d00: 2020 5265 7475 726e 730a 2020 2020 2020    Returns.      
+00019d10: 2020 2d2d 2d2d 2d2d 2d0a 2020 2020 2020    -------.      
+00019d20: 2020 626f 6f6c 0a20 2020 2020 2020 2020    bool.         
+00019d30: 2020 2054 7275 6520 6966 2046 5020 6c6f     True if FP lo
+00019d40: 6f70 2073 686f 756c 6420 7465 726d 696e  op should termin
+00019d50: 6174 652c 2046 616c 7365 206f 7468 6572  ate, False other
+00019d60: 7769 7365 2e0a 2020 2020 2020 2020 2222  wise..        ""
+00019d70: 220a 2020 2020 2020 2020 6966 2066 705f  ".        if fp_
+00019d80: 6d61 696e 5f72 6573 756c 7473 2e73 6f6c  main_results.sol
+00019d90: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
+00019da0: 636f 6e64 6974 696f 6e20 6973 2074 632e  condition is tc.
+00019db0: 6f70 7469 6d61 6c3a 0a20 2020 2020 2020  optimal:.       
+00019dc0: 2020 2020 2073 656c 662e 636f 6e66 6967       self.config
+00019dd0: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
+00019de0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+00019df0: 6c66 2e6c 6f67 5f66 6f72 6d61 7474 6572  lf.log_formatter
+00019e00: 2e66 6f72 6d61 7428 0a20 2020 2020 2020  .format(.       
+00019e10: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+00019e20: 662e 6670 5f69 7465 722c 0a20 2020 2020  f.fp_iter,.     
+00019e30: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00019e40: 4650 2d4d 4950 272c 0a20 2020 2020 2020  FP-MIP',.       
+00019e50: 2020 2020 2020 2020 2020 2020 2076 616c               val
+00019e60: 7565 2873 656c 662e 6d69 702e 4d69 6e64  ue(self.mip.Mind
+00019e70: 7450 795f 7574 696c 732e 6670 5f6d 6970  tPy_utils.fp_mip
+00019e80: 5f6f 626a 292c 0a20 2020 2020 2020 2020  _obj),.         
+00019e90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00019ea0: 7072 696d 616c 5f62 6f75 6e64 2c0a 2020  primal_bound,.  
+00019eb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019ec0: 2020 7365 6c66 2e64 7561 6c5f 626f 756e    self.dual_boun
+00019ed0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
+00019ee0: 2020 2020 2020 2073 656c 662e 7265 6c5f         self.rel_
+00019ef0: 6761 702c 0a20 2020 2020 2020 2020 2020  gap,.           
+00019f00: 2020 2020 2020 2020 2067 6574 5f6d 6169           get_mai
+00019f10: 6e5f 656c 6170 7365 645f 7469 6d65 2873  n_elapsed_time(s
+00019f20: 656c 662e 7469 6d69 6e67 292c 0a20 2020  elf.timing),.   
+00019f30: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00019f40: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00019f50: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00019f60: 4661 6c73 650a 2020 2020 2020 2020 656c  False.        el
+00019f70: 6966 2066 705f 6d61 696e 5f72 6573 756c  if fp_main_resul
+00019f80: 7473 2e73 6f6c 7665 722e 7465 726d 696e  ts.solver.termin
+00019f90: 6174 696f 6e5f 636f 6e64 6974 696f 6e20  ation_condition 
+00019fa0: 6973 2074 632e 6d61 7854 696d 654c 696d  is tc.maxTimeLim
+00019fb0: 6974 3a0a 2020 2020 2020 2020 2020 2020  it:.            
+00019fc0: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
+00019fd0: 6572 2e77 6172 6e69 6e67 2827 4650 2d4d  er.warning('FP-M
+00019fe0: 4950 2072 6561 6368 6573 206d 6178 2054  IP reaches max T
+00019ff0: 696d 654c 696d 6974 2729 0a20 2020 2020  imeLimit').     
+0001a000: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+0001a010: 6c74 732e 736f 6c76 6572 2e74 6572 6d69  lts.solver.termi
+0001a020: 6e61 7469 6f6e 5f63 6f6e 6469 7469 6f6e  nation_condition
+0001a030: 203d 2074 632e 6d61 7854 696d 654c 696d   = tc.maxTimeLim
+0001a040: 6974 0a20 2020 2020 2020 2020 2020 2072  it.            r
+0001a050: 6574 7572 6e20 5472 7565 0a20 2020 2020  eturn True.     
+0001a060: 2020 2065 6c69 6620 6670 5f6d 6169 6e5f     elif fp_main_
+0001a070: 7265 7375 6c74 732e 736f 6c76 6572 2e74  results.solver.t
+0001a080: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+0001a090: 7469 6f6e 2069 7320 7463 2e69 6e66 6561  tion is tc.infea
+0001a0a0: 7369 626c 653a 0a20 2020 2020 2020 2020  sible:.         
+0001a0b0: 2020 2073 656c 662e 636f 6e66 6967 2e6c     self.config.l
+0001a0c0: 6f67 6765 722e 7761 726e 696e 6728 2746  ogger.warning('F
+0001a0d0: 502d 4d49 5020 696e 6665 6173 6962 6c65  P-MIP infeasible
+0001a0e0: 2729 0a20 2020 2020 2020 2020 2020 206e  ').            n
+0001a0f0: 6f5f 676f 6f64 5f63 7574 7320 3d20 7365  o_good_cuts = se
+0001a100: 6c66 2e6d 6970 2e4d 696e 6474 5079 5f75  lf.mip.MindtPy_u
+0001a110: 7469 6c73 2e63 7574 732e 6e6f 5f67 6f6f  tils.cuts.no_goo
+0001a120: 645f 6375 7473 0a20 2020 2020 2020 2020  d_cuts.         
+0001a130: 2020 2069 6620 6e6f 5f67 6f6f 645f 6375     if no_good_cu
+0001a140: 7473 2e5f 5f6c 656e 5f5f 2829 203e 2030  ts.__len__() > 0
+0001a150: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001a160: 2020 6e6f 5f67 6f6f 645f 6375 7473 5b6e    no_good_cuts[n
+0001a170: 6f5f 676f 6f64 5f63 7574 732e 5f5f 6c65  o_good_cuts.__le
+0001a180: 6e5f 5f28 295d 2e64 6561 6374 6976 6174  n__()].deactivat
+0001a190: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
+0001a1a0: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
+0001a1b0: 2020 2020 656c 6966 2066 705f 6d61 696e      elif fp_main
+0001a1c0: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
+0001a1d0: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
+0001a1e0: 6974 696f 6e20 6973 2074 632e 756e 626f  ition is tc.unbo
+0001a1f0: 756e 6465 643a 0a20 2020 2020 2020 2020  unded:.         
+0001a200: 2020 2073 656c 662e 636f 6e66 6967 2e6c     self.config.l
+0001a210: 6f67 6765 722e 7761 726e 696e 6728 2746  ogger.warning('F
+0001a220: 502d 4d49 5020 756e 626f 756e 6465 6427  P-MIP unbounded'
+0001a230: 290a 2020 2020 2020 2020 2020 2020 7265  ).            re
+0001a240: 7475 726e 2054 7275 650a 2020 2020 2020  turn True.      
+0001a250: 2020 656c 6966 2028 0a20 2020 2020 2020    elif (.       
+0001a260: 2020 2020 2066 705f 6d61 696e 5f72 6573       fp_main_res
+0001a270: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+0001a280: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+0001a290: 6e20 6973 2074 632e 6f74 6865 720a 2020  n is tc.other.  
+0001a2a0: 2020 2020 2020 2020 2020 616e 6420 6670            and fp
+0001a2b0: 5f6d 6169 6e5f 7265 7375 6c74 732e 736f  _main_results.so
+0001a2c0: 6c75 7469 6f6e 2e73 7461 7475 7320 6973  lution.status is
+0001a2d0: 2053 6f6c 7574 696f 6e53 7461 7475 732e   SolutionStatus.
+0001a2e0: 6665 6173 6962 6c65 0a20 2020 2020 2020  feasible.       
+0001a2f0: 2029 3a0a 2020 2020 2020 2020 2020 2020   ):.            
+0001a300: 7365 6c66 2e63 6f6e 6669 672e 6c6f 6767  self.config.logg
+0001a310: 6572 2e77 6172 6e69 6e67 280a 2020 2020  er.warning(.    
+0001a320: 2020 2020 2020 2020 2020 2020 274d 494c              'MIL
+0001a330: 5020 736f 6c76 6572 2072 6570 6f72 7465  P solver reporte
+0001a340: 6420 6665 6173 6962 6c65 2073 6f6c 7574  d feasible solut
+0001a350: 696f 6e20 6f66 2046 502d 4d49 502c 2027  ion of FP-MIP, '
+0001a360: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001a370: 2027 6275 7420 6e6f 7420 6775 6172 616e   'but not guaran
+0001a380: 7465 6564 2074 6f20 6265 206f 7074 696d  teed to be optim
+0001a390: 616c 2e27 0a20 2020 2020 2020 2020 2020  al.'.           
+0001a3a0: 2029 0a20 2020 2020 2020 2020 2020 2072   ).            r
+0001a3b0: 6574 7572 6e20 4661 6c73 650a 2020 2020  eturn False.    
+0001a3c0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+0001a3d0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
+0001a3e0: 672e 6c6f 6767 6572 2e77 6172 6e69 6e67  g.logger.warning
+0001a3f0: 2827 556e 6578 7065 6374 6564 2072 6573  ('Unexpected res
+0001a400: 756c 7420 6f66 2046 502d 4d49 5027 290a  ult of FP-MIP').
+0001a410: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+0001a420: 726e 2054 7275 650a 0a20 2020 2064 6566  rn True..    def
+0001a430: 2066 705f 6c6f 6f70 2873 656c 6629 3a0a   fp_loop(self):.
+0001a440: 2020 2020 2020 2020 2222 2246 6561 7369          """Feasi
+0001a450: 6269 6c69 7479 2070 756d 7020 6c6f 6f70  bility pump loop
+0001a460: 2e0a 0a20 2020 2020 2020 2054 6869 7320  ...        This 
+0001a470: 6973 2074 6865 206f 7574 6572 6d6f 7374  is the outermost
+0001a480: 2066 756e 6374 696f 6e20 666f 7220 7468   function for th
+0001a490: 6520 4665 6173 6962 696c 6974 7920 5075  e Feasibility Pu
+0001a4a0: 6d70 2061 6c67 6f72 6974 686d 2069 6e20  mp algorithm in 
+0001a4b0: 7468 6973 2070 6163 6b61 6765 3b20 7468  this package; th
+0001a4c0: 6973 2066 756e 6374 696f 6e0a 2020 2020  is function.    
+0001a4d0: 2020 2020 636f 6e74 726f 6c73 2074 6865      controls the
+0001a4e0: 2070 726f 6772 6573 7320 6f66 2073 6f6c   progress of sol
+0001a4f0: 7669 6e67 2074 6865 206d 6f64 656c 2e0a  ving the model..
+0001a500: 0a20 2020 2020 2020 2052 6169 7365 730a  .        Raises.
+0001a510: 2020 2020 2020 2020 2d2d 2d2d 2d2d 0a20          ------. 
+0001a520: 2020 2020 2020 2056 616c 7565 4572 726f         ValueErro
+0001a530: 720a 2020 2020 2020 2020 2020 2020 4d69  r.            Mi
+0001a540: 6e64 7450 7920 756e 6162 6c65 2074 6f20  ndtPy unable to 
+0001a550: 6861 6e64 6c65 2074 6865 2074 6572 6d69  handle the termi
+0001a560: 6e61 7469 6f6e 2063 6f6e 6469 7469 6f6e  nation condition
+0001a570: 206f 6620 7468 6520 4650 2d4e 4c50 2073   of the FP-NLP s
+0001a580: 7562 7072 6f62 6c65 6d2e 0a20 2020 2020  ubproblem..     
+0001a590: 2020 2022 2222 0a20 2020 2020 2020 2063     """.        c
+0001a5a0: 6f6e 6669 6720 3d20 7365 6c66 2e63 6f6e  onfig = self.con
+0001a5b0: 6669 670a 2020 2020 2020 2020 7768 696c  fig.        whil
+0001a5c0: 6520 7365 6c66 2e66 705f 6974 6572 203c  e self.fp_iter <
+0001a5d0: 2063 6f6e 6669 672e 6670 5f69 7465 7261   config.fp_itera
+0001a5e0: 7469 6f6e 5f6c 696d 6974 3a0a 2020 2020  tion_limit:.    
+0001a5f0: 2020 2020 2020 2020 2320 736f 6c76 6520          # solve 
+0001a600: 4d49 5020 6d61 696e 2070 726f 626c 656d  MIP main problem
+0001a610: 0a20 2020 2020 2020 2020 2020 2077 6974  .            wit
+0001a620: 6820 7469 6d65 5f63 6f64 6528 7365 6c66  h time_code(self
+0001a630: 2e74 696d 696e 672c 2027 6670 206d 6169  .timing, 'fp mai
+0001a640: 6e27 293a 0a20 2020 2020 2020 2020 2020  n'):.           
+0001a650: 2020 2020 2066 705f 6d61 696e 2c20 6670       fp_main, fp
+0001a660: 5f6d 6169 6e5f 7265 7375 6c74 7320 3d20  _main_results = 
+0001a670: 7365 6c66 2e73 6f6c 7665 5f66 705f 6d61  self.solve_fp_ma
+0001a680: 696e 2829 0a20 2020 2020 2020 2020 2020  in().           
+0001a690: 2066 705f 7368 6f75 6c64 5f74 6572 6d69   fp_should_termi
+0001a6a0: 6e61 7465 203d 2073 656c 662e 6861 6e64  nate = self.hand
+0001a6b0: 6c65 5f66 705f 6d61 696e 5f74 6328 6670  le_fp_main_tc(fp
+0001a6c0: 5f6d 6169 6e5f 7265 7375 6c74 7329 0a20  _main_results). 
+0001a6d0: 2020 2020 2020 2020 2020 2069 6620 6670             if fp
+0001a6e0: 5f73 686f 756c 645f 7465 726d 696e 6174  _should_terminat
+0001a6f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001a700: 2020 2062 7265 616b 0a0a 2020 2020 2020     break..      
+0001a710: 2020 2020 2020 2320 536f 6c76 6520 4e4c        # Solve NL
+0001a720: 5020 7375 6270 726f 626c 656d 0a20 2020  P subproblem.   
+0001a730: 2020 2020 2020 2020 2023 2054 6865 2063           # The c
+0001a740: 6f6e 7374 7261 696e 7420 6c69 6e65 6172  onstraint linear
+0001a750: 697a 6174 696f 6e20 6861 7070 656e 7320  ization happens 
+0001a760: 696e 2074 6865 2068 616e 646c 6572 730a  in the handlers.
+0001a770: 2020 2020 2020 2020 2020 2020 6670 5f6e              fp_n
+0001a780: 6c70 2c20 6670 5f6e 6c70 5f72 6573 756c  lp, fp_nlp_resul
+0001a790: 7420 3d20 7365 6c66 2e73 6f6c 7665 5f66  t = self.solve_f
+0001a7a0: 705f 7375 6270 726f 626c 656d 2829 0a0a  p_subproblem()..
+0001a7b0: 2020 2020 2020 2020 2020 2020 6966 2066              if f
+0001a7c0: 705f 6e6c 705f 7265 7375 6c74 2e73 6f6c  p_nlp_result.sol
+0001a7d0: 7665 722e 7465 726d 696e 6174 696f 6e5f  ver.termination_
+0001a7e0: 636f 6e64 6974 696f 6e20 696e 207b 0a20  condition in {. 
+0001a7f0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0001a800: 632e 6f70 7469 6d61 6c2c 0a20 2020 2020  c.optimal,.     
+0001a810: 2020 2020 2020 2020 2020 2074 632e 6c6f             tc.lo
+0001a820: 6361 6c6c 794f 7074 696d 616c 2c0a 2020  callyOptimal,.  
+0001a830: 2020 2020 2020 2020 2020 2020 2020 7463                tc
+0001a840: 2e66 6561 7369 626c 652c 0a20 2020 2020  .feasible,.     
+0001a850: 2020 2020 2020 207d 3a0a 2020 2020 2020         }:.      
+0001a860: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+0001a870: 2e6c 6f67 6765 722e 696e 666f 280a 2020  .logger.info(.  
+0001a880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a890: 2020 7365 6c66 2e6c 6f67 5f66 6f72 6d61    self.log_forma
+0001a8a0: 7474 6572 2e66 6f72 6d61 7428 0a20 2020  tter.format(.   
+0001a8b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a8c0: 2020 2020 2073 656c 662e 6670 5f69 7465       self.fp_ite
+0001a8d0: 722c 0a20 2020 2020 2020 2020 2020 2020  r,.             
+0001a8e0: 2020 2020 2020 2020 2020 2027 4650 2d4e             'FP-N
+0001a8f0: 4c50 272c 0a20 2020 2020 2020 2020 2020  LP',.           
+0001a900: 2020 2020 2020 2020 2020 2020 2076 616c               val
+0001a910: 7565 2866 705f 6e6c 702e 4d69 6e64 7450  ue(fp_nlp.MindtP
+0001a920: 795f 7574 696c 732e 6670 5f6e 6c70 5f6f  y_utils.fp_nlp_o
+0001a930: 626a 292c 0a20 2020 2020 2020 2020 2020  bj),.           
+0001a940: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0001a950: 662e 7072 696d 616c 5f62 6f75 6e64 2c0a  f.primal_bound,.
+0001a960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a970: 2020 2020 2020 2020 7365 6c66 2e64 7561          self.dua
+0001a980: 6c5f 626f 756e 642c 0a20 2020 2020 2020  l_bound,.       
+0001a990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a9a0: 2073 656c 662e 7265 6c5f 6761 702c 0a20   self.rel_gap,. 
+0001a9b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001a9c0: 2020 2020 2020 2067 6574 5f6d 6169 6e5f         get_main_
+0001a9d0: 656c 6170 7365 645f 7469 6d65 2873 656c  elapsed_time(sel
+0001a9e0: 662e 7469 6d69 6e67 292c 0a20 2020 2020  f.timing),.     
+0001a9f0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0001aa00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001aa10: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+0001aa20: 2020 2073 656c 662e 6861 6e64 6c65 5f66     self.handle_f
+0001aa30: 705f 7375 6270 726f 626c 656d 5f6f 7074  p_subproblem_opt
+0001aa40: 696d 616c 2866 705f 6e6c 7029 0a20 2020  imal(fp_nlp).   
+0001aa50: 2020 2020 2020 2020 2065 6c69 6620 6670           elif fp
+0001aa60: 5f6e 6c70 5f72 6573 756c 742e 736f 6c76  _nlp_result.solv
+0001aa70: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+0001aa80: 6f6e 6469 7469 6f6e 2069 6e20 7b0a 2020  ondition in {.  
+0001aa90: 2020 2020 2020 2020 2020 2020 2020 7463                tc
+0001aaa0: 2e69 6e66 6561 7369 626c 652c 0a20 2020  .infeasible,.   
+0001aab0: 2020 2020 2020 2020 2020 2020 2074 632e               tc.
+0001aac0: 6e6f 536f 6c75 7469 6f6e 2c0a 2020 2020  noSolution,.    
+0001aad0: 2020 2020 2020 2020 7d3a 0a20 2020 2020          }:.     
+0001aae0: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
+0001aaf0: 672e 6c6f 6767 6572 2e65 7272 6f72 2827  g.logger.error('
+0001ab00: 4665 6173 6962 696c 6974 7920 7075 6d70  Feasibility pump
+0001ab10: 204e 4c50 2073 7562 7072 6f62 6c65 6d20   NLP subproblem 
+0001ab20: 696e 6665 6173 6962 6c65 2729 0a20 2020  infeasible').   
+0001ab30: 2020 2020 2020 2020 2020 2020 2073 656c               sel
+0001ab40: 662e 7368 6f75 6c64 5f74 6572 6d69 6e61  f.should_termina
+0001ab50: 7465 203d 2054 7275 650a 2020 2020 2020  te = True.      
+0001ab60: 2020 2020 2020 2020 2020 7365 6c66 2e72            self.r
+0001ab70: 6573 756c 7473 2e73 6f6c 7665 722e 7374  esults.solver.st
+0001ab80: 6174 7573 203d 2053 6f6c 7665 7253 7461  atus = SolverSta
+0001ab90: 7475 732e 6572 726f 720a 2020 2020 2020  tus.error.      
+0001aba0: 2020 2020 2020 2020 2020 7265 7475 726e            return
+0001abb0: 0a20 2020 2020 2020 2020 2020 2065 6c69  .            eli
+0001abc0: 6620 6670 5f6e 6c70 5f72 6573 756c 742e  f fp_nlp_result.
+0001abd0: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
+0001abe0: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 7320  on_condition is 
+0001abf0: 7463 2e6d 6178 4974 6572 6174 696f 6e73  tc.maxIterations
+0001ac00: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001ac10: 2020 636f 6e66 6967 2e6c 6f67 6765 722e    config.logger.
+0001ac20: 6572 726f 7228 0a20 2020 2020 2020 2020  error(.         
+0001ac30: 2020 2020 2020 2020 2020 2027 4665 6173             'Feas
+0001ac40: 6962 696c 6974 7920 7075 6d70 204e 4c50  ibility pump NLP
+0001ac50: 2073 7562 7072 6f62 6c65 6d20 6661 696c   subproblem fail
+0001ac60: 6564 2074 6f20 636f 6e76 6572 6765 2077  ed to converge w
+0001ac70: 6974 6869 6e20 6974 6572 6174 696f 6e20  ithin iteration 
+0001ac80: 6c69 6d69 742e 270a 2020 2020 2020 2020  limit.'.        
+0001ac90: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0001aca0: 2020 2020 2020 2020 2020 7365 6c66 2e73            self.s
+0001acb0: 686f 756c 645f 7465 726d 696e 6174 6520  hould_terminate 
+0001acc0: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+0001acd0: 2020 2020 2020 2073 656c 662e 7265 7375         self.resu
+0001ace0: 6c74 732e 736f 6c76 6572 2e73 7461 7475  lts.solver.statu
+0001acf0: 7320 3d20 536f 6c76 6572 5374 6174 7573  s = SolverStatus
+0001ad00: 2e65 7272 6f72 0a20 2020 2020 2020 2020  .error.         
+0001ad10: 2020 2020 2020 2072 6574 7572 6e0a 2020         return.  
+0001ad20: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0001ad30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ad40: 7261 6973 6520 5661 6c75 6545 7272 6f72  raise ValueError
+0001ad50: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001ad60: 2020 2020 2020 274d 696e 6474 5079 2075        'MindtPy u
+0001ad70: 6e61 626c 6520 746f 2068 616e 646c 6520  nable to handle 
+0001ad80: 4e4c 5020 7375 6270 726f 626c 656d 2074  NLP subproblem t
+0001ad90: 6572 6d69 6e61 7469 6f6e 2027 0a20 2020  ermination '.   
+0001ada0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001adb0: 2027 636f 6e64 6974 696f 6e20 6f66 207b   'condition of {
+0001adc0: 7d27 2e66 6f72 6d61 7428 6670 5f6e 6c70  }'.format(fp_nlp
+0001add0: 5f72 6573 756c 742e 736f 6c76 6572 2e74  _result.solver.t
+0001ade0: 6572 6d69 6e61 7469 6f6e 5f63 6f6e 6469  ermination_condi
+0001adf0: 7469 6f6e 290a 2020 2020 2020 2020 2020  tion).          
+0001ae00: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001ae10: 2020 2020 2320 4361 6c6c 2074 6865 204e      # Call the N
+0001ae20: 4c50 2070 6f73 742d 736f 6c76 6520 6361  LP post-solve ca
+0001ae30: 6c6c 6261 636b 0a20 2020 2020 2020 2020  llback.         
+0001ae40: 2020 2063 6f6e 6669 672e 6361 6c6c 5f61     config.call_a
+0001ae50: 6674 6572 5f73 7562 7072 6f62 6c65 6d5f  fter_subproblem_
+0001ae60: 736f 6c76 6528 6670 5f6e 6c70 290a 2020  solve(fp_nlp).  
+0001ae70: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
+0001ae80: 705f 6974 6572 202b 3d20 310a 2020 2020  p_iter += 1.    
+0001ae90: 2020 2020 7365 6c66 2e6d 6970 2e4d 696e      self.mip.Min
+0001aea0: 6474 5079 5f75 7469 6c73 2e64 656c 5f63  dtPy_utils.del_c
+0001aeb0: 6f6d 706f 6e65 6e74 2827 6670 5f6d 6970  omponent('fp_mip
+0001aec0: 5f6f 626a 2729 0a0a 2020 2020 2020 2020  _obj')..        
+0001aed0: 6966 2063 6f6e 6669 672e 6670 5f6d 6169  if config.fp_mai
+0001aee0: 6e5f 6e6f 726d 203d 3d20 274c 3127 3a0a  n_norm == 'L1':.
+0001aef0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001af00: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
+0001af10: 6c73 2e64 656c 5f63 6f6d 706f 6e65 6e74  ls.del_component
+0001af20: 2827 4c31 5f6f 626a 2729 0a20 2020 2020  ('L1_obj').     
+0001af30: 2020 2065 6c69 6620 636f 6e66 6967 2e66     elif config.f
+0001af40: 705f 6d61 696e 5f6e 6f72 6d20 3d3d 2027  p_main_norm == '
+0001af50: 4c5f 696e 6669 6e69 7479 273a 0a20 2020  L_infinity':.   
+0001af60: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
+0001af70: 702e 4d69 6e64 7450 795f 7574 696c 732e  p.MindtPy_utils.
+0001af80: 6465 6c5f 636f 6d70 6f6e 656e 7428 274c  del_component('L
+0001af90: 5f69 6e66 696e 6974 795f 6f62 6a27 290a  _infinity_obj').
+0001afa0: 0a20 2020 2020 2020 2023 2064 6561 6374  .        # deact
+0001afb0: 6976 6174 6520 7468 6520 696d 7072 6f76  ivate the improv
+0001afc0: 696e 675f 6f62 6a65 6374 6976 655f 6375  ing_objective_cu
+0001afd0: 740a 2020 2020 2020 2020 7365 6c66 2e6d  t.        self.m
+0001afe0: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
+0001aff0: 2e63 7574 732e 6465 6c5f 636f 6d70 6f6e  .cuts.del_compon
+0001b000: 656e 7428 2769 6d70 726f 7669 6e67 5f6f  ent('improving_o
+0001b010: 626a 6563 7469 7665 5f63 7574 2729 0a20  bjective_cut'). 
+0001b020: 2020 2020 2020 2069 6620 6e6f 7420 636f         if not co
+0001b030: 6e66 6967 2e66 705f 7472 616e 7366 6572  nfig.fp_transfer
+0001b040: 6375 7473 3a0a 2020 2020 2020 2020 2020  cuts:.          
+0001b050: 2020 666f 7220 6320 696e 2073 656c 662e    for c in self.
+0001b060: 6d69 702e 4d69 6e64 7450 795f 7574 696c  mip.MindtPy_util
+0001b070: 732e 6375 7473 2e6f 615f 6375 7473 3a0a  s.cuts.oa_cuts:.
+0001b080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b090: 632e 6465 6163 7469 7661 7465 2829 0a20  c.deactivate(). 
+0001b0a0: 2020 2020 2020 2020 2020 2066 6f72 2063             for c
+0001b0b0: 2069 6e20 7365 6c66 2e6d 6970 2e4d 696e   in self.mip.Min
+0001b0c0: 6474 5079 5f75 7469 6c73 2e63 7574 732e  dtPy_utils.cuts.
+0001b0d0: 6e6f 5f67 6f6f 645f 6375 7473 3a0a 2020  no_good_cuts:.  
+0001b0e0: 2020 2020 2020 2020 2020 2020 2020 632e                c.
+0001b0f0: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
+0001b100: 2020 2020 2069 6620 636f 6e66 6967 2e66       if config.f
+0001b110: 705f 7072 6f6a 6375 7473 3a0a 2020 2020  p_projcuts:.    
+0001b120: 2020 2020 2020 2020 7365 6c66 2e77 6f72          self.wor
+0001b130: 6b69 6e67 5f6d 6f64 656c 2e4d 696e 6474  king_model.Mindt
+0001b140: 5079 5f75 7469 6c73 2e63 7574 732e 6465  Py_utils.cuts.de
+0001b150: 6c5f 636f 6d70 6f6e 656e 7428 2766 705f  l_component('fp_
+0001b160: 6f72 7468 6f67 6f6e 616c 6974 795f 6375  orthogonality_cu
+0001b170: 7473 2729 0a0a 2020 2020 6465 6620 696e  ts')..    def in
+0001b180: 6974 6961 6c69 7a65 5f6d 6970 5f70 726f  itialize_mip_pro
+0001b190: 626c 656d 2873 656c 6629 3a0a 2020 2020  blem(self):.    
+0001b1a0: 2020 2020 2222 2244 6561 6374 6976 6174      """Deactivat
+0001b1b0: 6520 7468 6520 6e6f 6e6c 696e 6561 7220  e the nonlinear 
+0001b1c0: 636f 6e73 7472 6169 6e74 7320 746f 2063  constraints to c
+0001b1d0: 7265 6174 6520 7468 6520 4d49 5020 7072  reate the MIP pr
+0001b1e0: 6f62 6c65 6d2e 2222 220a 2020 2020 2020  oblem.""".      
+0001b1f0: 2020 2320 6966 2073 696e 676c 6520 7472    # if single tr
+0001b200: 6565 2069 7320 6163 7469 7661 7465 642c  ee is activated,
+0001b210: 2077 6520 6e65 6564 2074 6f20 6164 6420   we need to add 
+0001b220: 626f 756e 6473 2066 6f72 2075 6e62 6f75  bounds for unbou
+0001b230: 6e64 6564 2076 6172 6961 626c 6573 2069  nded variables i
+0001b240: 6e20 6e6f 6e6c 696e 6561 7220 636f 6e73  n nonlinear cons
+0001b250: 7472 6169 6e74 7320 746f 2061 766f 6964  traints to avoid
+0001b260: 2075 6e62 6f75 6e64 6564 206d 6169 6e20   unbounded main 
+0001b270: 7072 6f62 6c65 6d2e 0a20 2020 2020 2020  problem..       
+0001b280: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
+0001b290: 6f6e 6669 670a 2020 2020 2020 2020 6966  onfig.        if
+0001b2a0: 2063 6f6e 6669 672e 7369 6e67 6c65 5f74   config.single_t
+0001b2b0: 7265 653a 0a20 2020 2020 2020 2020 2020  ree:.           
+0001b2c0: 2061 6464 5f76 6172 5f62 6f75 6e64 2873   add_var_bound(s
+0001b2d0: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+0001b2e0: 6c2c 2063 6f6e 6669 6729 0a0a 2020 2020  l, config)..    
+0001b2f0: 2020 2020 7365 6c66 2e6d 6970 203d 2073      self.mip = s
+0001b300: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+0001b310: 6c2e 636c 6f6e 6528 290a 2020 2020 2020  l.clone().      
+0001b320: 2020 6e65 7874 2873 656c 662e 6d69 702e    next(self.mip.
+0001b330: 636f 6d70 6f6e 656e 745f 6461 7461 5f6f  component_data_o
+0001b340: 626a 6563 7473 284f 626a 6563 7469 7665  bjects(Objective
+0001b350: 2c20 6163 7469 7665 3d54 7275 6529 292e  , active=True)).
+0001b360: 6465 6163 7469 7661 7465 2829 0a20 2020  deactivate().   
+0001b370: 2020 2020 2069 6620 6861 7361 7474 7228       if hasattr(
+0001b380: 7365 6c66 2e6d 6970 2c20 2764 7561 6c27  self.mip, 'dual'
+0001b390: 2920 616e 6420 6973 696e 7374 616e 6365  ) and isinstance
+0001b3a0: 2873 656c 662e 6d69 702e 6475 616c 2c20  (self.mip.dual, 
+0001b3b0: 5375 6666 6978 293a 0a20 2020 2020 2020  Suffix):.       
+0001b3c0: 2020 2020 2073 656c 662e 6d69 702e 6465       self.mip.de
+0001b3d0: 6c5f 636f 6d70 6f6e 656e 7428 2764 7561  l_component('dua
+0001b3e0: 6c27 290a 2020 2020 2020 2020 2320 4465  l').        # De
+0001b3f0: 6163 7469 7661 7465 2065 7874 7261 6e65  activate extrane
+0001b400: 6f75 7320 494d 504f 5254 2f45 5850 4f52  ous IMPORT/EXPOR
+0001b410: 5420 7375 6666 6978 6573 0a20 2020 2020  T suffixes.     
+0001b420: 2020 2069 6620 636f 6e66 6967 2e6e 6c70     if config.nlp
+0001b430: 5f73 6f6c 7665 7220 696e 207b 2769 706f  _solver in {'ipo
+0001b440: 7074 272c 2027 6379 6970 6f70 7427 7d3a  pt', 'cyipopt'}:
+0001b450: 0a20 2020 2020 2020 2020 2020 2067 6574  .            get
+0001b460: 6174 7472 2873 656c 662e 6d69 702c 2027  attr(self.mip, '
+0001b470: 6970 6f70 745f 7a4c 5f6f 7574 272c 205f  ipopt_zL_out', _
+0001b480: 446f 4e6f 7468 696e 6728 2929 2e64 6561  DoNothing()).dea
+0001b490: 6374 6976 6174 6528 290a 2020 2020 2020  ctivate().      
+0001b4a0: 2020 2020 2020 6765 7461 7474 7228 7365        getattr(se
+0001b4b0: 6c66 2e6d 6970 2c20 2769 706f 7074 5f7a  lf.mip, 'ipopt_z
+0001b4c0: 555f 6f75 7427 2c20 5f44 6f4e 6f74 6869  U_out', _DoNothi
+0001b4d0: 6e67 2829 292e 6465 6163 7469 7661 7465  ng()).deactivate
+0001b4e0: 2829 0a0a 2020 2020 2020 2020 4d69 6e64  ()..        Mind
+0001b4f0: 7450 7920 3d20 7365 6c66 2e6d 6970 2e4d  tPy = self.mip.M
+0001b500: 696e 6474 5079 5f75 7469 6c73 0a20 2020  indtPy_utils.   
+0001b510: 2020 2020 2069 6620 6c65 6e28 4d69 6e64       if len(Mind
+0001b520: 7450 792e 6772 6579 5f62 6f78 5f6c 6973  tPy.grey_box_lis
+0001b530: 7429 203e 2030 3a0a 2020 2020 2020 2020  t) > 0:.        
+0001b540: 2020 2020 666f 7220 6772 6579 5f62 6f78      for grey_box
+0001b550: 2069 6e20 4d69 6e64 7450 792e 6772 6579   in MindtPy.grey
+0001b560: 5f62 6f78 5f6c 6973 743a 0a20 2020 2020  _box_list:.     
+0001b570: 2020 2020 2020 2020 2020 2067 7265 795f             grey_
+0001b580: 626f 782e 6465 6163 7469 7661 7465 2829  box.deactivate()
+0001b590: 0a0a 2020 2020 2020 2020 6966 2063 6f6e  ..        if con
+0001b5a0: 6669 672e 696e 6974 5f73 7472 6174 6567  fig.init_strateg
+0001b5b0: 7920 3d3d 2027 4650 273a 0a20 2020 2020  y == 'FP':.     
+0001b5c0: 2020 2020 2020 204d 696e 6474 5079 2e63         MindtPy.c
+0001b5d0: 7574 732e 6670 5f6f 7274 686f 676f 6e61  uts.fp_orthogona
+0001b5e0: 6c69 7479 5f63 7574 7320 3d20 436f 6e73  lity_cuts = Cons
+0001b5f0: 7472 6169 6e74 4c69 7374 280a 2020 2020  traintList(.    
+0001b600: 2020 2020 2020 2020 2020 2020 646f 633d              doc=
+0001b610: 274f 7274 686f 676f 6e61 6c69 7479 2063  'Orthogonality c
+0001b620: 7574 7320 696e 2066 6561 7369 6269 6c69  uts in feasibili
+0001b630: 7479 2070 756d 7027 0a20 2020 2020 2020  ty pump'.       
+0001b640: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+0001b650: 2020 2069 6620 636f 6e66 6967 2e66 705f     if config.fp_
+0001b660: 7072 6f6a 6375 7473 3a0a 2020 2020 2020  projcuts:.      
+0001b670: 2020 2020 2020 2020 2020 7365 6c66 2e77            self.w
+0001b680: 6f72 6b69 6e67 5f6d 6f64 656c 2e4d 696e  orking_model.Min
+0001b690: 6474 5079 5f75 7469 6c73 2e63 7574 732e  dtPy_utils.cuts.
+0001b6a0: 6670 5f6f 7274 686f 676f 6e61 6c69 7479  fp_orthogonality
+0001b6b0: 5f63 7574 7320 3d20 280a 2020 2020 2020  _cuts = (.      
+0001b6c0: 2020 2020 2020 2020 2020 2020 2020 436f                Co
+0001b6d0: 6e73 7472 6169 6e74 4c69 7374 2864 6f63  nstraintList(doc
+0001b6e0: 3d27 4f72 7468 6f67 6f6e 616c 6974 7920  ='Orthogonality 
+0001b6f0: 6375 7473 2069 6e20 6665 6173 6962 696c  cuts in feasibil
+0001b700: 6974 7920 7075 6d70 2729 0a20 2020 2020  ity pump').     
+0001b710: 2020 2020 2020 2020 2020 2029 0a0a 2020             )..  
+0001b720: 2020 2020 2020 7365 6c66 2e66 6978 6564        self.fixed
+0001b730: 5f6e 6c70 203d 2073 656c 662e 776f 726b  _nlp = self.work
+0001b740: 696e 675f 6d6f 6465 6c2e 636c 6f6e 6528  ing_model.clone(
+0001b750: 290a 2020 2020 2020 2020 5472 616e 7366  ).        Transf
+0001b760: 6f72 6d61 7469 6f6e 4661 6374 6f72 7928  ormationFactory(
+0001b770: 2763 6f72 652e 6669 785f 696e 7465 6765  'core.fix_intege
+0001b780: 725f 7661 7273 2729 2e61 7070 6c79 5f74  r_vars').apply_t
+0001b790: 6f28 7365 6c66 2e66 6978 6564 5f6e 6c70  o(self.fixed_nlp
+0001b7a0: 290a 2020 2020 2020 2020 696e 6974 6961  ).        initia
+0001b7b0: 6c69 7a65 5f66 6561 735f 7375 6270 726f  lize_feas_subpro
+0001b7c0: 626c 656d 2873 656c 662e 6669 7865 645f  blem(self.fixed_
+0001b7d0: 6e6c 702c 2063 6f6e 6669 672e 6665 6173  nlp, config.feas
+0001b7e0: 6962 696c 6974 795f 6e6f 726d 290a 0a20  ibility_norm).. 
+0001b7f0: 2020 2064 6566 2069 6e69 7469 616c 697a     def initializ
+0001b800: 655f 7375 6273 6f6c 7665 7273 2873 656c  e_subsolvers(sel
+0001b810: 6629 3a0a 2020 2020 2020 2020 2222 2249  f):.        """I
+0001b820: 6e69 7469 616c 697a 6520 616e 6420 7365  nitialize and se
+0001b830: 7420 6f70 7469 6f6e 7320 666f 7220 4d49  t options for MI
+0001b840: 5020 616e 6420 4e4c 5020 7375 6273 6f6c  P and NLP subsol
+0001b850: 7665 7273 2e22 2222 0a20 2020 2020 2020  vers.""".       
+0001b860: 2063 6f6e 6669 6720 3d20 7365 6c66 2e63   config = self.c
+0001b870: 6f6e 6669 670a 2020 2020 2020 2020 6966  onfig.        if
+0001b880: 2063 6f6e 6669 672e 6d69 705f 736f 6c76   config.mip_solv
+0001b890: 6572 203d 3d20 2767 7572 6f62 695f 7065  er == 'gurobi_pe
+0001b8a0: 7273 6973 7465 6e74 2720 616e 6420 636f  rsistent' and co
+0001b8b0: 6e66 6967 2e73 696e 676c 655f 7472 6565  nfig.single_tree
+0001b8c0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0001b8d0: 6c66 2e6d 6970 5f6f 7074 203d 2047 7572  lf.mip_opt = Gur
+0001b8e0: 6f62 6950 6572 7369 7374 656e 7434 4d69  obiPersistent4Mi
+0001b8f0: 6e64 7450 7928 290a 2020 2020 2020 2020  ndtPy().        
+0001b900: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001b910: 2020 7365 6c66 2e6d 6970 5f6f 7074 203d    self.mip_opt =
+0001b920: 2053 6f6c 7665 7246 6163 746f 7279 2863   SolverFactory(c
+0001b930: 6f6e 6669 672e 6d69 705f 736f 6c76 6572  onfig.mip_solver
+0001b940: 290a 2020 2020 2020 2020 7365 6c66 2e6e  ).        self.n
+0001b950: 6c70 5f6f 7074 203d 2053 6f6c 7665 7246  lp_opt = SolverF
+0001b960: 6163 746f 7279 2863 6f6e 6669 672e 6e6c  actory(config.nl
+0001b970: 705f 736f 6c76 6572 290a 2020 2020 2020  p_solver).      
+0001b980: 2020 7365 6c66 2e66 6561 7369 6269 6c69    self.feasibili
+0001b990: 7479 5f6e 6c70 5f6f 7074 203d 2053 6f6c  ty_nlp_opt = Sol
+0001b9a0: 7665 7246 6163 746f 7279 2863 6f6e 6669  verFactory(confi
+0001b9b0: 672e 6e6c 705f 736f 6c76 6572 290a 2020  g.nlp_solver).  
+0001b9c0: 2020 2020 2020 6966 2063 6f6e 6669 672e        if config.
+0001b9d0: 6d69 705f 7265 6775 6c61 7269 7a61 7469  mip_regularizati
+0001b9e0: 6f6e 5f73 6f6c 7665 7220 6973 206e 6f74  on_solver is not
+0001b9f0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+0001ba00: 2020 2073 656c 662e 7265 6775 6c61 7269     self.regulari
+0001ba10: 7a61 7469 6f6e 5f6d 6970 5f6f 7074 203d  zation_mip_opt =
+0001ba20: 2053 6f6c 7665 7246 6163 746f 7279 280a   SolverFactory(.
+0001ba30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ba40: 636f 6e66 6967 2e6d 6970 5f72 6567 756c  config.mip_regul
+0001ba50: 6172 697a 6174 696f 6e5f 736f 6c76 6572  arization_solver
+0001ba60: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0001ba70: 2020 2020 2020 2020 7365 6c66 2e63 6865          self.che
+0001ba80: 636b 5f73 7562 736f 6c76 6572 5f76 616c  ck_subsolver_val
+0001ba90: 6964 6974 7928 290a 2020 2020 2020 2020  idity().        
+0001baa0: 6966 2063 6f6e 6669 672e 6d69 705f 736f  if config.mip_so
+0001bab0: 6c76 6572 203d 3d20 2767 616d 7327 3a0a  lver == 'gams':.
+0001bac0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001bad0: 2e6d 6970 5f6f 7074 2e6f 7074 696f 6e73  .mip_opt.options
+0001bae0: 5b27 6164 645f 6f70 7469 6f6e 7327 5d20  ['add_options'] 
+0001baf0: 3d20 5b5d 0a20 2020 2020 2020 2069 6620  = [].        if 
+0001bb00: 636f 6e66 6967 2e6e 6c70 5f73 6f6c 7665  config.nlp_solve
+0001bb10: 7220 3d3d 2027 6761 6d73 273a 0a20 2020  r == 'gams':.   
+0001bb20: 2020 2020 2020 2020 2073 656c 662e 6e6c           self.nl
+0001bb30: 705f 6f70 742e 6f70 7469 6f6e 735b 2761  p_opt.options['a
+0001bb40: 6464 5f6f 7074 696f 6e73 275d 203d 205b  dd_options'] = [
+0001bb50: 5d0a 2020 2020 2020 2020 2020 2020 7365  ].            se
+0001bb60: 6c66 2e66 6561 7369 6269 6c69 7479 5f6e  lf.feasibility_n
+0001bb70: 6c70 5f6f 7074 2e6f 7074 696f 6e73 5b27  lp_opt.options['
+0001bb80: 6164 645f 6f70 7469 6f6e 7327 5d20 3d20  add_options'] = 
+0001bb90: 5b5d 0a20 2020 2020 2020 2073 6574 5f73  [].        set_s
+0001bba0: 6f6c 7665 725f 6d69 7067 6170 2873 656c  olver_mipgap(sel
+0001bbb0: 662e 6d69 705f 6f70 742c 2063 6f6e 6669  f.mip_opt, confi
+0001bbc0: 672e 6d69 705f 736f 6c76 6572 2c20 636f  g.mip_solver, co
+0001bbd0: 6e66 6967 290a 0a20 2020 2020 2020 2073  nfig)..        s
+0001bbe0: 6574 5f73 6f6c 7665 725f 636f 6e73 7472  et_solver_constr
+0001bbf0: 6169 6e74 5f76 696f 6c61 7469 6f6e 5f74  aint_violation_t
+0001bc00: 6f6c 6572 616e 6365 280a 2020 2020 2020  olerance(.      
+0001bc10: 2020 2020 2020 7365 6c66 2e6e 6c70 5f6f        self.nlp_o
+0001bc20: 7074 2c20 636f 6e66 6967 2e6e 6c70 5f73  pt, config.nlp_s
+0001bc30: 6f6c 7665 722c 2063 6f6e 6669 670a 2020  olver, config.  
+0001bc40: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
+0001bc50: 7365 745f 736f 6c76 6572 5f63 6f6e 7374  set_solver_const
+0001bc60: 7261 696e 745f 7669 6f6c 6174 696f 6e5f  raint_violation_
+0001bc70: 746f 6c65 7261 6e63 6528 0a20 2020 2020  tolerance(.     
+0001bc80: 2020 2020 2020 2073 656c 662e 6665 6173         self.feas
+0001bc90: 6962 696c 6974 795f 6e6c 705f 6f70 742c  ibility_nlp_opt,
+0001bca0: 2063 6f6e 6669 672e 6e6c 705f 736f 6c76   config.nlp_solv
+0001bcb0: 6572 2c20 636f 6e66 6967 2c20 7761 726d  er, config, warm
+0001bcc0: 5f73 7461 7274 3d46 616c 7365 0a20 2020  _start=False.   
+0001bcd0: 2020 2020 2029 0a0a 2020 2020 2020 2020       )..        
+0001bce0: 7365 6c66 2e73 6574 5f61 7070 7369 5f73  self.set_appsi_s
+0001bcf0: 6f6c 7665 725f 7570 6461 7465 5f63 6f6e  olver_update_con
+0001bd00: 6669 6728 290a 0a20 2020 2020 2020 2069  fig()..        i
+0001bd10: 6620 636f 6e66 6967 2e6d 6970 5f73 6f6c  f config.mip_sol
+0001bd20: 7665 7220 3d3d 2027 6775 726f 6269 5f70  ver == 'gurobi_p
+0001bd30: 6572 7369 7374 656e 7427 2061 6e64 2063  ersistent' and c
+0001bd40: 6f6e 6669 672e 7369 6e67 6c65 5f74 7265  onfig.single_tre
+0001bd50: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+0001bd60: 2050 7265 4372 7573 683a 2043 6f6e 7472   PreCrush: Contr
+0001bd70: 6f6c 7320 7072 6573 6f6c 7665 2072 6564  ols presolve red
+0001bd80: 7563 7469 6f6e 7320 7468 6174 2061 6666  uctions that aff
+0001bd90: 6563 7420 7573 6572 2063 7574 730a 2020  ect user cuts.  
+0001bda0: 2020 2020 2020 2020 2020 2320 596f 7520            # You 
+0001bdb0: 7368 6f75 6c64 2063 6f6e 7369 6465 7220  should consider 
+0001bdc0: 7365 7474 696e 6720 7468 6973 2070 6172  setting this par
+0001bdd0: 616d 6574 6572 2074 6f20 3120 6966 2079  ameter to 1 if y
+0001bde0: 6f75 2061 7265 2075 7369 6e67 2063 616c  ou are using cal
+0001bdf0: 6c62 6163 6b73 2074 6f20 6164 6420 796f  lbacks to add yo
+0001be00: 7572 206f 776e 2063 7574 732e 0a20 2020  ur own cuts..   
+0001be10: 2020 2020 2020 2020 2073 656c 662e 6d69           self.mi
+0001be20: 705f 6f70 742e 6f70 7469 6f6e 735b 2750  p_opt.options['P
+0001be30: 7265 4372 7573 6827 5d20 3d20 310a 2020  reCrush'] = 1.  
+0001be40: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+0001be50: 6970 5f6f 7074 2e6f 7074 696f 6e73 5b27  ip_opt.options['
+0001be60: 4c61 7a79 436f 6e73 7472 6169 6e74 7327  LazyConstraints'
+0001be70: 5d20 3d20 310a 0a20 2020 2020 2020 2023  ] = 1..        #
+0001be80: 2073 6574 2074 6872 6561 6473 0a20 2020   set threads.   
+0001be90: 2020 2020 2069 6620 636f 6e66 6967 2e74       if config.t
+0001bea0: 6872 6561 6473 203e 2030 3a0a 2020 2020  hreads > 0:.    
+0001beb0: 2020 2020 2020 2020 7365 6c66 2e6d 6970          self.mip
+0001bec0: 5f6f 7074 2e6f 7074 696f 6e73 5b27 7468  _opt.options['th
+0001bed0: 7265 6164 7327 5d20 3d20 636f 6e66 6967  reads'] = config
+0001bee0: 2e74 6872 6561 6473 0a20 2020 2020 2020  .threads.       
+0001bef0: 2023 2072 6567 756c 6172 697a 6174 696f   # regularizatio
+0001bf00: 6e20 736f 6c76 6572 0a20 2020 2020 2020  n solver.       
+0001bf10: 2069 6620 636f 6e66 6967 2e6d 6970 5f72   if config.mip_r
+0001bf20: 6567 756c 6172 697a 6174 696f 6e5f 736f  egularization_so
+0001bf30: 6c76 6572 2069 7320 6e6f 7420 4e6f 6e65  lver is not None
+0001bf40: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0001bf50: 745f 736f 6c76 6572 5f6d 6970 6761 7028  t_solver_mipgap(
+0001bf60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001bf70: 2073 656c 662e 7265 6775 6c61 7269 7a61   self.regulariza
+0001bf80: 7469 6f6e 5f6d 6970 5f6f 7074 2c20 636f  tion_mip_opt, co
+0001bf90: 6e66 6967 2e6d 6970 5f72 6567 756c 6172  nfig.mip_regular
+0001bfa0: 697a 6174 696f 6e5f 736f 6c76 6572 2c20  ization_solver, 
+0001bfb0: 636f 6e66 6967 0a20 2020 2020 2020 2020  config.         
+0001bfc0: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+0001bfd0: 2069 6620 636f 6e66 6967 2e6d 6970 5f72   if config.mip_r
+0001bfe0: 6567 756c 6172 697a 6174 696f 6e5f 736f  egularization_so
+0001bff0: 6c76 6572 203d 3d20 2767 616d 7327 3a0a  lver == 'gams':.
+0001c000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c010: 7365 6c66 2e72 6567 756c 6172 697a 6174  self.regularizat
+0001c020: 696f 6e5f 6d69 705f 6f70 742e 6f70 7469  ion_mip_opt.opti
+0001c030: 6f6e 735b 2761 6464 5f6f 7074 696f 6e73  ons['add_options
+0001c040: 275d 203d 205b 5d0a 2020 2020 2020 2020  '] = [].        
+0001c050: 2020 2020 6966 2063 6f6e 6669 672e 7265      if config.re
+0001c060: 6775 6c61 7269 7a61 7469 6f6e 5f6d 6970  gularization_mip
+0001c070: 5f74 6872 6561 6473 203e 2030 3a0a 2020  _threads > 0:.  
+0001c080: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001c090: 6c66 2e72 6567 756c 6172 697a 6174 696f  lf.regularizatio
+0001c0a0: 6e5f 6d69 705f 6f70 742e 6f70 7469 6f6e  n_mip_opt.option
+0001c0b0: 735b 2774 6872 6561 6473 275d 203d 2028  s['threads'] = (
+0001c0c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c0d0: 2020 2020 2063 6f6e 6669 672e 7265 6775       config.regu
+0001c0e0: 6c61 7269 7a61 7469 6f6e 5f6d 6970 5f74  larization_mip_t
+0001c0f0: 6872 6561 6473 0a20 2020 2020 2020 2020  hreads.         
+0001c100: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001c110: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+0001c120: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001c130: 7265 6775 6c61 7269 7a61 7469 6f6e 5f6d  regularization_m
+0001c140: 6970 5f6f 7074 2e6f 7074 696f 6e73 5b27  ip_opt.options['
+0001c150: 7468 7265 6164 7327 5d20 3d20 636f 6e66  threads'] = conf
+0001c160: 6967 2e74 6872 6561 6473 0a0a 2020 2020  ig.threads..    
+0001c170: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+0001c180: 672e 6d69 705f 7265 6775 6c61 7269 7a61  g.mip_regulariza
+0001c190: 7469 6f6e 5f73 6f6c 7665 7220 696e 207b  tion_solver in {
+0001c1a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001c1b0: 2027 6370 6c65 7827 2c0a 2020 2020 2020   'cplex',.      
+0001c1c0: 2020 2020 2020 2020 2020 2761 7070 7369            'appsi
+0001c1d0: 5f63 706c 6578 272c 0a20 2020 2020 2020  _cplex',.       
+0001c1e0: 2020 2020 2020 2020 2027 6370 6c65 785f           'cplex_
+0001c1f0: 7065 7273 6973 7465 6e74 272c 0a20 2020  persistent',.   
+0001c200: 2020 2020 2020 2020 207d 3a0a 2020 2020           }:.    
+0001c210: 2020 2020 2020 2020 2020 2020 6966 2063              if c
+0001c220: 6f6e 6669 672e 736f 6c75 7469 6f6e 5f6c  onfig.solution_l
+0001c230: 696d 6974 2069 7320 6e6f 7420 4e6f 6e65  imit is not None
+0001c240: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001c250: 2020 2020 2020 7365 6c66 2e72 6567 756c        self.regul
+0001c260: 6172 697a 6174 696f 6e5f 6d69 705f 6f70  arization_mip_op
+0001c270: 742e 6f70 7469 6f6e 735b 276d 6970 5f6c  t.options['mip_l
+0001c280: 696d 6974 735f 736f 6c75 7469 6f6e 7327  imits_solutions'
+0001c290: 5d20 3d20 280a 2020 2020 2020 2020 2020  ] = (.          
+0001c2a0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0001c2b0: 6e66 6967 2e73 6f6c 7574 696f 6e5f 6c69  nfig.solution_li
+0001c2c0: 6d69 740a 2020 2020 2020 2020 2020 2020  mit.            
+0001c2d0: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+0001c2e0: 2020 2020 2020 2020 2020 2320 5765 2064            # We d
+0001c2f0: 6f6e 2774 206e 6565 6420 746f 2073 6f6c  on't need to sol
+0001c300: 7665 2074 6865 2072 6567 756c 6172 697a  ve the regulariz
+0001c310: 6174 696f 6e20 7072 6f62 6c65 6d20 746f  ation problem to
+0001c320: 206f 7074 696d 616c 6974 792e 0a20 2020   optimality..   
+0001c330: 2020 2020 2020 2020 2020 2020 2023 2057               # W
+0001c340: 6520 7769 6c6c 2063 686f 6f73 6520 746f  e will choose to
+0001c350: 2070 6572 666f 726d 2061 6767 7265 7373   perform aggress
+0001c360: 6976 6520 6e6f 6465 2070 726f 6269 6e67  ive node probing
+0001c370: 2064 7572 696e 6720 7072 6573 6f6c 7665   during presolve
+0001c380: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0001c390: 2020 7365 6c66 2e72 6567 756c 6172 697a    self.regulariz
+0001c3a0: 6174 696f 6e5f 6d69 705f 6f70 742e 6f70  ation_mip_opt.op
+0001c3b0: 7469 6f6e 735b 276d 6970 5f73 7472 6174  tions['mip_strat
+0001c3c0: 6567 795f 7072 6573 6f6c 7665 6e6f 6465  egy_presolvenode
+0001c3d0: 275d 203d 2033 0a20 2020 2020 2020 2020  '] = 3.         
+0001c3e0: 2020 2020 2020 2023 2057 6865 6e20 7573         # When us
+0001c3f0: 696e 6720 524f 4120 6d65 7468 6f64 2074  ing ROA method t
+0001c400: 6f20 736f 6c76 6520 636f 6e76 6578 204d  o solve convex M
+0001c410: 494e 4c50 732c 2074 6865 2048 6573 7369  INLPs, the Hessi
+0001c420: 616e 206f 6620 7468 6520 4c61 6772 616e  an of the Lagran
+0001c430: 6765 616e 2069 7320 616c 7761 7973 2070  gean is always p
+0001c440: 6f73 6974 6976 6520 7365 6d69 6465 6669  ositive semidefi
+0001c450: 6e69 7465 2c0a 2020 2020 2020 2020 2020  nite,.          
+0001c460: 2020 2020 2020 2320 616e 6420 7468 6520        # and the 
+0001c470: 7265 6775 6c61 7269 7a61 7469 6f6e 2073  regularization s
+0001c480: 7562 7072 6f62 6c65 6d73 2061 7265 2061  ubproblems are a
+0001c490: 6c77 6179 7320 636f 6e76 6578 2e0a 2020  lways convex..  
+0001c4a0: 2020 2020 2020 2020 2020 2020 2020 2320                # 
+0001c4b0: 486f 7765 7665 722c 2064 7565 2074 6f20  However, due to 
+0001c4c0: 6e75 6d65 7269 6361 6c20 6163 6375 7261  numerical accura
+0001c4d0: 6379 2c20 7468 6520 7265 6775 6c61 7269  cy, the regulari
+0001c4e0: 7a61 7469 6f6e 2070 726f 626c 656d 2065  zation problem e
+0001c4f0: 6e64 6564 2075 7020 6e6f 6e63 6f6e 7665  nded up nonconve
+0001c500: 7820 666f 7220 6120 6665 7720 6361 7365  x for a few case
+0001c510: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+0001c520: 2020 2023 2065 2e67 2e2c 2074 6865 2073     # e.g., the s
+0001c530: 6d61 6c6c 6573 7420 6569 6765 6e76 616c  mallest eigenval
+0001c540: 7565 206f 6620 7468 6520 4865 7373 6961  ue of the Hessia
+0001c550: 6e20 7761 7320 736c 6967 6874 6c79 206e  n was slightly n
+0001c560: 6567 6174 6976 652e 0a20 2020 2020 2020  egative..       
+0001c570: 2020 2020 2020 2020 2023 2054 6865 7265           # There
+0001c580: 666f 7265 2c20 7765 2073 6574 2074 6865  fore, we set the
+0001c590: 206f 7074 696d 616c 6974 7974 6172 6765   optimalitytarge
+0001c5a0: 7420 7061 7261 6d65 7465 7220 746f 2033  t parameter to 3
+0001c5b0: 2074 6f20 656e 6162 6c65 2043 504c 4558   to enable CPLEX
+0001c5c0: 2074 6f20 736f 6c76 6520 6e6f 6e63 6f6e   to solve noncon
+0001c5d0: 7665 7820 4d49 5150 7320 696e 2074 6865  vex MIQPs in the
+0001c5e0: 2052 4f41 2d4c 3220 616e 6420 524f 412d   ROA-L2 and ROA-
+0001c5f0: e288 8732 4c20 6d65 7468 6f64 732e 0a20  ...2L methods.. 
+0001c600: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+0001c610: 6620 636f 6e66 6967 2e61 6464 5f72 6567  f config.add_reg
+0001c620: 756c 6172 697a 6174 696f 6e20 696e 207b  ularization in {
+0001c630: 2768 6573 735f 6c61 6727 2c20 2768 6573  'hess_lag', 'hes
+0001c640: 735f 6f6e 6c79 5f6c 6167 277d 3a0a 2020  s_only_lag'}:.  
+0001c650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c660: 2020 7365 6c66 2e72 6567 756c 6172 697a    self.regulariz
+0001c670: 6174 696f 6e5f 6d69 705f 6f70 742e 6f70  ation_mip_opt.op
+0001c680: 7469 6f6e 735b 276f 7074 696d 616c 6974  tions['optimalit
+0001c690: 7974 6172 6765 7427 5d20 3d20 330a 2020  ytarget'] = 3.  
+0001c6a0: 2020 2020 2020 2020 2020 656c 6966 2063            elif c
+0001c6b0: 6f6e 6669 672e 6d69 705f 7265 6775 6c61  onfig.mip_regula
+0001c6c0: 7269 7a61 7469 6f6e 5f73 6f6c 7665 7220  rization_solver 
+0001c6d0: 3d3d 2027 6775 726f 6269 273a 0a20 2020  == 'gurobi':.   
+0001c6e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0001c6f0: 636f 6e66 6967 2e73 6f6c 7574 696f 6e5f  config.solution_
+0001c700: 6c69 6d69 7420 6973 206e 6f74 204e 6f6e  limit is not Non
+0001c710: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+0001c720: 2020 2020 2020 2073 656c 662e 7265 6775         self.regu
+0001c730: 6c61 7269 7a61 7469 6f6e 5f6d 6970 5f6f  larization_mip_o
+0001c740: 7074 2e6f 7074 696f 6e73 5b27 536f 6c75  pt.options['Solu
+0001c750: 7469 6f6e 4c69 6d69 7427 5d20 3d20 280a  tionLimit'] = (.
+0001c760: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c770: 2020 2020 2020 2020 636f 6e66 6967 2e73          config.s
+0001c780: 6f6c 7574 696f 6e5f 6c69 6d69 740a 2020  olution_limit.  
+0001c790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c7a0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+0001c7b0: 2020 2020 2320 5361 6d65 2072 6561 736f      # Same reaso
+0001c7c0: 6e20 6173 206d 6970 5f73 7472 6174 6567  n as mip_strateg
+0001c7d0: 795f 7072 6573 6f6c 7665 6e6f 6465 2e0a  y_presolvenode..
+0001c7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c7f0: 7365 6c66 2e72 6567 756c 6172 697a 6174  self.regularizat
+0001c800: 696f 6e5f 6d69 705f 6f70 742e 6f70 7469  ion_mip_opt.opti
+0001c810: 6f6e 735b 2750 7265 736f 6c76 6527 5d20  ons['Presolve'] 
+0001c820: 3d20 320a 0a20 2020 2064 6566 2073 6574  = 2..    def set
+0001c830: 5f61 7070 7369 5f73 6f6c 7665 725f 7570  _appsi_solver_up
+0001c840: 6461 7465 5f63 6f6e 6669 6728 7365 6c66  date_config(self
+0001c850: 293a 0a20 2020 2020 2020 2022 2222 5365  ):.        """Se
+0001c860: 7420 7570 6461 7465 2063 6f6e 6669 6720  t update config 
+0001c870: 666f 7220 4150 5053 4920 736f 6c76 6572  for APPSI solver
+0001c880: 732e 2222 220a 2020 2020 2020 2020 636f  s.""".        co
+0001c890: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
+0001c8a0: 6967 0a20 2020 2020 2020 2069 6620 636f  ig.        if co
+0001c8b0: 6e66 6967 2e6d 6970 5f73 6f6c 7665 7220  nfig.mip_solver 
+0001c8c0: 696e 207b 2761 7070 7369 5f63 706c 6578  in {'appsi_cplex
+0001c8d0: 272c 2027 6170 7073 695f 6775 726f 6269  ', 'appsi_gurobi
+0001c8e0: 272c 2027 6170 7073 695f 6869 6768 7327  ', 'appsi_highs'
+0001c8f0: 7d3a 0a20 2020 2020 2020 2020 2020 2023  }:.            #
+0001c900: 206d 6970 206d 6169 6e20 7072 6f62 6c65   mip main proble
+0001c910: 6d0a 2020 2020 2020 2020 2020 2020 7365  m.            se
+0001c920: 6c66 2e6d 6970 5f6f 7074 2e75 7064 6174  lf.mip_opt.updat
+0001c930: 655f 636f 6e66 6967 2e63 6865 636b 5f66  e_config.check_f
+0001c940: 6f72 5f6e 6577 5f6f 725f 7265 6d6f 7665  or_new_or_remove
+0001c950: 645f 636f 6e73 7472 6169 6e74 7320 3d20  d_constraints = 
+0001c960: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0001c970: 2073 656c 662e 6d69 705f 6f70 742e 7570   self.mip_opt.up
+0001c980: 6461 7465 5f63 6f6e 6669 672e 6368 6563  date_config.chec
+0001c990: 6b5f 666f 725f 6e65 775f 6f72 5f72 656d  k_for_new_or_rem
+0001c9a0: 6f76 6564 5f76 6172 7320 3d20 5472 7565  oved_vars = True
+0001c9b0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0001c9c0: 662e 6d69 705f 6f70 742e 7570 6461 7465  f.mip_opt.update
+0001c9d0: 5f63 6f6e 6669 672e 6368 6563 6b5f 666f  _config.check_fo
+0001c9e0: 725f 6e65 775f 6f72 5f72 656d 6f76 6564  r_new_or_removed
+0001c9f0: 5f70 6172 616d 7320 3d20 4661 6c73 650a  _params = False.
+0001ca00: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001ca10: 2e6d 6970 5f6f 7074 2e75 7064 6174 655f  .mip_opt.update_
+0001ca20: 636f 6e66 6967 2e63 6865 636b 5f66 6f72  config.check_for
+0001ca30: 5f6e 6577 5f6f 626a 6563 7469 7665 203d  _new_objective =
+0001ca40: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+0001ca50: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e75    self.mip_opt.u
+0001ca60: 7064 6174 655f 636f 6e66 6967 2e75 7064  pdate_config.upd
+0001ca70: 6174 655f 636f 6e73 7472 6169 6e74 7320  ate_constraints 
+0001ca80: 3d20 5472 7565 0a20 2020 2020 2020 2020  = True.         
+0001ca90: 2020 2073 656c 662e 6d69 705f 6f70 742e     self.mip_opt.
+0001caa0: 7570 6461 7465 5f63 6f6e 6669 672e 7570  update_config.up
+0001cab0: 6461 7465 5f76 6172 7320 3d20 5472 7565  date_vars = True
+0001cac0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0001cad0: 662e 6d69 705f 6f70 742e 7570 6461 7465  f.mip_opt.update
+0001cae0: 5f63 6f6e 6669 672e 7570 6461 7465 5f70  _config.update_p
+0001caf0: 6172 616d 7320 3d20 4661 6c73 650a 2020  arams = False.  
+0001cb00: 2020 2020 2020 2020 2020 7365 6c66 2e6d            self.m
+0001cb10: 6970 5f6f 7074 2e75 7064 6174 655f 636f  ip_opt.update_co
+0001cb20: 6e66 6967 2e75 7064 6174 655f 6e61 6d65  nfig.update_name
+0001cb30: 645f 6578 7072 6573 7369 6f6e 7320 3d20  d_expressions = 
+0001cb40: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
+0001cb50: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e75    self.mip_opt.u
+0001cb60: 7064 6174 655f 636f 6e66 6967 2e75 7064  pdate_config.upd
+0001cb70: 6174 655f 6f62 6a65 6374 6976 6520 3d20  ate_objective = 
+0001cb80: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
+0001cb90: 2020 7365 6c66 2e6d 6970 5f6f 7074 2e75    self.mip_opt.u
+0001cba0: 7064 6174 655f 636f 6e66 6967 2e74 7265  pdate_config.tre
+0001cbb0: 6174 5f66 6978 6564 5f76 6172 735f 6173  at_fixed_vars_as
+0001cbc0: 5f70 6172 616d 7320 3d20 5472 7565 0a0a  _params = True..
+0001cbd0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+0001cbe0: 672e 6e6c 705f 736f 6c76 6572 203d 3d20  g.nlp_solver == 
+0001cbf0: 2761 7070 7369 5f69 706f 7074 273a 0a20  'appsi_ipopt':. 
+0001cc00: 2020 2020 2020 2020 2020 2023 2066 6978             # fix
+0001cc10: 6564 2d6e 6c70 0a20 2020 2020 2020 2020  ed-nlp.         
+0001cc20: 2020 2073 656c 662e 6e6c 705f 6f70 742e     self.nlp_opt.
+0001cc30: 7570 6461 7465 5f63 6f6e 6669 672e 6368  update_config.ch
+0001cc40: 6563 6b5f 666f 725f 6e65 775f 6f72 5f72  eck_for_new_or_r
+0001cc50: 656d 6f76 6564 5f63 6f6e 7374 7261 696e  emoved_constrain
+0001cc60: 7473 203d 2046 616c 7365 0a20 2020 2020  ts = False.     
+0001cc70: 2020 2020 2020 2073 656c 662e 6e6c 705f         self.nlp_
+0001cc80: 6f70 742e 7570 6461 7465 5f63 6f6e 6669  opt.update_confi
+0001cc90: 672e 6368 6563 6b5f 666f 725f 6e65 775f  g.check_for_new_
+0001cca0: 6f72 5f72 656d 6f76 6564 5f76 6172 7320  or_removed_vars 
+0001ccb0: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+0001ccc0: 2020 2020 7365 6c66 2e6e 6c70 5f6f 7074      self.nlp_opt
+0001ccd0: 2e75 7064 6174 655f 636f 6e66 6967 2e63  .update_config.c
+0001cce0: 6865 636b 5f66 6f72 5f6e 6577 5f6f 725f  heck_for_new_or_
+0001ccf0: 7265 6d6f 7665 645f 7061 7261 6d73 203d  removed_params =
+0001cd00: 2046 616c 7365 0a20 2020 2020 2020 2020   False.         
+0001cd10: 2020 2073 656c 662e 6e6c 705f 6f70 742e     self.nlp_opt.
+0001cd20: 7570 6461 7465 5f63 6f6e 6669 672e 6368  update_config.ch
+0001cd30: 6563 6b5f 666f 725f 6e65 775f 6f62 6a65  eck_for_new_obje
+0001cd40: 6374 6976 6520 3d20 4661 6c73 650a 2020  ctive = False.  
+0001cd50: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0001cd60: 6c70 5f6f 7074 2e75 7064 6174 655f 636f  lp_opt.update_co
+0001cd70: 6e66 6967 2e75 7064 6174 655f 636f 6e73  nfig.update_cons
+0001cd80: 7472 6169 6e74 7320 3d20 5472 7565 0a20  traints = True. 
+0001cd90: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001cda0: 6e6c 705f 6f70 742e 7570 6461 7465 5f63  nlp_opt.update_c
+0001cdb0: 6f6e 6669 672e 7570 6461 7465 5f76 6172  onfig.update_var
+0001cdc0: 7320 3d20 5472 7565 0a20 2020 2020 2020  s = True.       
+0001cdd0: 2020 2020 2073 656c 662e 6e6c 705f 6f70       self.nlp_op
+0001cde0: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
+0001cdf0: 7570 6461 7465 5f70 6172 616d 7320 3d20  update_params = 
+0001ce00: 4661 6c73 650a 2020 2020 2020 2020 2020  False.          
+0001ce10: 2020 7365 6c66 2e6e 6c70 5f6f 7074 2e75    self.nlp_opt.u
+0001ce20: 7064 6174 655f 636f 6e66 6967 2e75 7064  pdate_config.upd
+0001ce30: 6174 655f 6e61 6d65 645f 6578 7072 6573  ate_named_expres
+0001ce40: 7369 6f6e 7320 3d20 4661 6c73 650a 2020  sions = False.  
+0001ce50: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0001ce60: 6c70 5f6f 7074 2e75 7064 6174 655f 636f  lp_opt.update_co
+0001ce70: 6e66 6967 2e75 7064 6174 655f 6f62 6a65  nfig.update_obje
+0001ce80: 6374 6976 6520 3d20 4661 6c73 650a 2020  ctive = False.  
+0001ce90: 2020 2020 2020 2020 2020 7365 6c66 2e6e            self.n
+0001cea0: 6c70 5f6f 7074 2e75 7064 6174 655f 636f  lp_opt.update_co
+0001ceb0: 6e66 6967 2e74 7265 6174 5f66 6978 6564  nfig.treat_fixed
+0001cec0: 5f76 6172 735f 6173 5f70 6172 616d 7320  _vars_as_params 
+0001ced0: 3d20 4661 6c73 650a 0a20 2020 2020 2020  = False..       
+0001cee0: 2020 2020 2073 656c 662e 6665 6173 6962       self.feasib
+0001cef0: 696c 6974 795f 6e6c 705f 6f70 742e 7570  ility_nlp_opt.up
+0001cf00: 6461 7465 5f63 6f6e 6669 672e 6368 6563  date_config.chec
+0001cf10: 6b5f 666f 725f 6e65 775f 6f72 5f72 656d  k_for_new_or_rem
+0001cf20: 6f76 6564 5f63 6f6e 7374 7261 696e 7473  oved_constraints
+0001cf30: 203d 2028 0a20 2020 2020 2020 2020 2020   = (.           
+0001cf40: 2020 2020 2046 616c 7365 0a20 2020 2020       False.     
+0001cf50: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001cf60: 2020 2020 2073 656c 662e 6665 6173 6962       self.feasib
+0001cf70: 696c 6974 795f 6e6c 705f 6f70 742e 7570  ility_nlp_opt.up
+0001cf80: 6461 7465 5f63 6f6e 6669 672e 6368 6563  date_config.chec
+0001cf90: 6b5f 666f 725f 6e65 775f 6f72 5f72 656d  k_for_new_or_rem
+0001cfa0: 6f76 6564 5f76 6172 7320 3d20 4661 6c73  oved_vars = Fals
+0001cfb0: 650a 2020 2020 2020 2020 2020 2020 7365  e.            se
+0001cfc0: 6c66 2e66 6561 7369 6269 6c69 7479 5f6e  lf.feasibility_n
+0001cfd0: 6c70 5f6f 7074 2e75 7064 6174 655f 636f  lp_opt.update_co
+0001cfe0: 6e66 6967 2e63 6865 636b 5f66 6f72 5f6e  nfig.check_for_n
+0001cff0: 6577 5f6f 725f 7265 6d6f 7665 645f 7061  ew_or_removed_pa
+0001d000: 7261 6d73 203d 2028 0a20 2020 2020 2020  rams = (.       
+0001d010: 2020 2020 2020 2020 2046 616c 7365 0a20           False. 
+0001d020: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+0001d030: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
+0001d040: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
+0001d050: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
+0001d060: 6368 6563 6b5f 666f 725f 6e65 775f 6f62  check_for_new_ob
+0001d070: 6a65 6374 6976 6520 3d20 4661 6c73 650a  jective = False.
+0001d080: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001d090: 2e66 6561 7369 6269 6c69 7479 5f6e 6c70  .feasibility_nlp
+0001d0a0: 5f6f 7074 2e75 7064 6174 655f 636f 6e66  _opt.update_conf
+0001d0b0: 6967 2e75 7064 6174 655f 636f 6e73 7472  ig.update_constr
+0001d0c0: 6169 6e74 7320 3d20 4661 6c73 650a 2020  aints = False.  
+0001d0d0: 2020 2020 2020 2020 2020 7365 6c66 2e66            self.f
+0001d0e0: 6561 7369 6269 6c69 7479 5f6e 6c70 5f6f  easibility_nlp_o
+0001d0f0: 7074 2e75 7064 6174 655f 636f 6e66 6967  pt.update_config
+0001d100: 2e75 7064 6174 655f 7661 7273 203d 2054  .update_vars = T
+0001d110: 7275 650a 2020 2020 2020 2020 2020 2020  rue.            
+0001d120: 7365 6c66 2e66 6561 7369 6269 6c69 7479  self.feasibility
+0001d130: 5f6e 6c70 5f6f 7074 2e75 7064 6174 655f  _nlp_opt.update_
+0001d140: 636f 6e66 6967 2e75 7064 6174 655f 7061  config.update_pa
+0001d150: 7261 6d73 203d 2046 616c 7365 0a20 2020  rams = False.   
+0001d160: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
+0001d170: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
+0001d180: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
+0001d190: 7570 6461 7465 5f6e 616d 6564 5f65 7870  update_named_exp
+0001d1a0: 7265 7373 696f 6e73 203d 2046 616c 7365  ressions = False
+0001d1b0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
+0001d1c0: 662e 6665 6173 6962 696c 6974 795f 6e6c  f.feasibility_nl
+0001d1d0: 705f 6f70 742e 7570 6461 7465 5f63 6f6e  p_opt.update_con
+0001d1e0: 6669 672e 7570 6461 7465 5f6f 626a 6563  fig.update_objec
+0001d1f0: 7469 7665 203d 2046 616c 7365 0a20 2020  tive = False.   
+0001d200: 2020 2020 2020 2020 2073 656c 662e 6665           self.fe
+0001d210: 6173 6962 696c 6974 795f 6e6c 705f 6f70  asibility_nlp_op
+0001d220: 742e 7570 6461 7465 5f63 6f6e 6669 672e  t.update_config.
+0001d230: 7472 6561 745f 6669 7865 645f 7661 7273  treat_fixed_vars
+0001d240: 5f61 735f 7061 7261 6d73 203d 2046 616c  _as_params = Fal
+0001d250: 7365 0a0a 2020 2020 6465 6620 736f 6c76  se..    def solv
+0001d260: 6528 7365 6c66 2c20 6d6f 6465 6c2c 202a  e(self, model, *
+0001d270: 2a6b 7764 7329 3a0a 2020 2020 2020 2020  *kwds):.        
+0001d280: 2222 2253 6f6c 7665 2074 6865 206d 6f64  """Solve the mod
+0001d290: 656c 2e0a 0a20 2020 2020 2020 2050 6172  el...        Par
+0001d2a0: 616d 6574 6572 730a 2020 2020 2020 2020  ameters.        
+0001d2b0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020  ----------.     
+0001d2c0: 2020 206d 6f64 656c 203a 2050 796f 6d6f     model : Pyomo
+0001d2d0: 206d 6f64 656c 0a20 2020 2020 2020 2020   model.         
+0001d2e0: 2020 2054 6865 204d 494e 4c50 206d 6f64     The MINLP mod
+0001d2f0: 656c 2074 6f20 6265 2073 6f6c 7665 642e  el to be solved.
+0001d300: 0a0a 2020 2020 2020 2020 5265 7475 726e  ..        Return
+0001d310: 730a 2020 2020 2020 2020 2d2d 2d2d 2d2d  s.        ------
+0001d320: 2d0a 2020 2020 2020 2020 7265 7375 6c74  -.        result
+0001d330: 7320 3a20 536f 6c76 6572 5265 7375 6c74  s : SolverResult
+0001d340: 730a 2020 2020 2020 2020 2020 2020 5265  s.            Re
+0001d350: 7375 6c74 7320 6672 6f6d 2073 6f6c 7669  sults from solvi
+0001d360: 6e67 2074 6865 204d 494e 4c50 2070 726f  ng the MINLP pro
+0001d370: 626c 656d 2062 7920 4d69 6e64 7450 792e  blem by MindtPy.
+0001d380: 0a20 2020 2020 2020 2022 2222 0a20 2020  .        """.   
+0001d390: 2020 2020 2063 6f6e 6669 6720 3d20 7365       config = se
+0001d3a0: 6c66 2e63 6f6e 6669 6720 3d20 7365 6c66  lf.config = self
+0001d3b0: 2e43 4f4e 4649 4728 0a20 2020 2020 2020  .CONFIG(.       
+0001d3c0: 2020 2020 206b 7764 732e 706f 7028 276f       kwds.pop('o
+0001d3d0: 7074 696f 6e73 272c 207b 7d29 2c20 7072  ptions', {}), pr
+0001d3e0: 6573 6572 7665 5f69 6d70 6c69 6369 743d  eserve_implicit=
+0001d3f0: 5472 7565 0a20 2020 2020 2020 2029 0a20  True.        ). 
+0001d400: 2020 2020 2020 2063 6f6e 6669 672e 7365         config.se
+0001d410: 745f 7661 6c75 6528 6b77 6473 290a 2020  t_value(kwds).  
+0001d420: 2020 2020 2020 7365 6c66 2e73 6574 5f75        self.set_u
+0001d430: 705f 6c6f 6767 6572 2829 0a20 2020 2020  p_logger().     
+0001d440: 2020 206e 6577 5f6c 6f67 6769 6e67 5f6c     new_logging_l
+0001d450: 6576 656c 203d 206c 6f67 6769 6e67 2e49  evel = logging.I
+0001d460: 4e46 4f20 6966 2063 6f6e 6669 672e 7465  NFO if config.te
+0001d470: 6520 656c 7365 204e 6f6e 650a 2020 2020  e else None.    
+0001d480: 2020 2020 7769 7468 206c 6f77 6572 5f6c      with lower_l
+0001d490: 6f67 6765 725f 6c65 7665 6c5f 746f 2863  ogger_level_to(c
+0001d4a0: 6f6e 6669 672e 6c6f 6767 6572 2c20 6e65  onfig.logger, ne
+0001d4b0: 775f 6c6f 6767 696e 675f 6c65 7665 6c29  w_logging_level)
+0001d4c0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0001d4d0: 6c66 2e63 6865 636b 5f63 6f6e 6669 6728  lf.check_config(
+0001d4e0: 290a 0a20 2020 2020 2020 2073 656c 662e  )..        self.
+0001d4f0: 7365 745f 7570 5f73 6f6c 7665 5f64 6174  set_up_solve_dat
+0001d500: 6128 6d6f 6465 6c29 0a0a 2020 2020 2020  a(model)..      
+0001d510: 2020 6966 2063 6f6e 6669 672e 696e 7465    if config.inte
+0001d520: 6765 725f 746f 5f62 696e 6172 793a 0a20  ger_to_binary:. 
+0001d530: 2020 2020 2020 2020 2020 2054 7261 6e73             Trans
+0001d540: 666f 726d 6174 696f 6e46 6163 746f 7279  formationFactory
+0001d550: 2827 636f 6e74 7269 622e 696e 7465 6765  ('contrib.intege
+0001d560: 725f 746f 5f62 696e 6172 7927 292e 6170  r_to_binary').ap
+0001d570: 706c 795f 746f 280a 2020 2020 2020 2020  ply_to(.        
+0001d580: 2020 2020 2020 2020 7365 6c66 2e77 6f72          self.wor
+0001d590: 6b69 6e67 5f6d 6f64 656c 0a20 2020 2020  king_model.     
+0001d5a0: 2020 2020 2020 2029 0a0a 2020 2020 2020         )..      
+0001d5b0: 2020 7365 6c66 2e63 7265 6174 655f 7574    self.create_ut
+0001d5c0: 696c 6974 795f 626c 6f63 6b28 7365 6c66  ility_block(self
+0001d5d0: 2e77 6f72 6b69 6e67 5f6d 6f64 656c 2c20  .working_model, 
+0001d5e0: 274d 696e 6474 5079 5f75 7469 6c73 2729  'MindtPy_utils')
+0001d5f0: 0a20 2020 2020 2020 2077 6974 6820 7469  .        with ti
+0001d600: 6d65 5f63 6f64 6528 7365 6c66 2e74 696d  me_code(self.tim
+0001d610: 696e 672c 2027 746f 7461 6c27 2c20 6973  ing, 'total', is
+0001d620: 5f6d 6169 6e5f 7469 6d65 723d 5472 7565  _main_timer=True
+0001d630: 292c 206c 6f77 6572 5f6c 6f67 6765 725f  ), lower_logger_
+0001d640: 6c65 7665 6c5f 746f 280a 2020 2020 2020  level_to(.      
+0001d650: 2020 2020 2020 636f 6e66 6967 2e6c 6f67        config.log
+0001d660: 6765 722c 206e 6577 5f6c 6f67 6769 6e67  ger, new_logging
+0001d670: 5f6c 6576 656c 0a20 2020 2020 2020 2029  _level.        )
+0001d680: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+0001d690: 6c66 2e5f 6c6f 675f 736f 6c76 6572 5f69  lf._log_solver_i
+0001d6a0: 6e74 726f 5f6d 6573 7361 6765 2829 0a20  ntro_message(). 
+0001d6b0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001d6c0: 696e 6974 6961 6c69 7a65 5f73 7562 736f  initialize_subso
+0001d6d0: 6c76 6572 7328 290a 0a20 2020 2020 2020  lvers()..       
+0001d6e0: 2020 2020 2023 2056 616c 6964 6174 6520       # Validate 
+0001d6f0: 7468 6520 6d6f 6465 6c20 746f 2065 6e73  the model to ens
+0001d700: 7572 6520 7468 6174 204d 696e 6474 5079  ure that MindtPy
+0001d710: 2069 7320 6162 6c65 2074 6f20 736f 6c76   is able to solv
+0001d720: 6520 6974 2e0a 2020 2020 2020 2020 2020  e it..          
+0001d730: 2020 6966 206e 6f74 2073 656c 662e 6d6f    if not self.mo
+0001d740: 6465 6c5f 6973 5f76 616c 6964 2829 3a0a  del_is_valid():.
+0001d750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001d760: 7265 7475 726e 0a0a 2020 2020 2020 2020  return..        
+0001d770: 2020 2020 4d69 6e64 7450 7920 3d20 7365      MindtPy = se
+0001d780: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
+0001d790: 2e4d 696e 6474 5079 5f75 7469 6c73 0a0a  .MindtPy_utils..
+0001d7a0: 2020 2020 2020 2020 2020 2020 7365 7475              setu
+0001d7b0: 705f 7265 7375 6c74 735f 6f62 6a65 6374  p_results_object
+0001d7c0: 2873 656c 662e 7265 7375 6c74 732c 2073  (self.results, s
+0001d7d0: 656c 662e 6f72 6967 696e 616c 5f6d 6f64  elf.original_mod
+0001d7e0: 656c 2c20 636f 6e66 6967 290a 0a20 2020  el, config)..   
+0001d7f0: 2020 2020 2020 2020 2023 2052 6566 6f72           # Refor
+0001d800: 6d75 6c61 7465 2074 6865 206f 626a 6563  mulate the objec
+0001d810: 7469 7665 2066 756e 6374 696f 6e2e 0a20  tive function.. 
+0001d820: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001d830: 6f62 6a65 6374 6976 655f 7265 666f 726d  objective_reform
+0001d840: 756c 6174 696f 6e28 290a 0a20 2020 2020  ulation()..     
+0001d850: 2020 2020 2020 2023 2053 6176 6520 6d6f         # Save mo
+0001d860: 6465 6c20 696e 6974 6961 6c20 7661 6c75  del initial valu
+0001d870: 6573 2e0a 2020 2020 2020 2020 2020 2020  es..            
+0001d880: 7365 6c66 2e69 6e69 7469 616c 5f76 6172  self.initial_var
+0001d890: 5f76 616c 7565 7320 3d20 6c69 7374 2876  _values = list(v
+0001d8a0: 2e76 616c 7565 2066 6f72 2076 2069 6e20  .value for v in 
+0001d8b0: 4d69 6e64 7450 792e 7661 7269 6162 6c65  MindtPy.variable
+0001d8c0: 5f6c 6973 7429 0a0a 2020 2020 2020 2020  _list)..        
+0001d8d0: 2020 2020 2320 544f 444f 3a20 6966 2074      # TODO: if t
+0001d8e0: 6865 204d 696e 6474 5079 2073 6f6c 7665  he MindtPy solve
+0001d8f0: 7220 6973 2064 6566 696e 6564 206f 6e63  r is defined onc
+0001d900: 6520 616e 6420 6361 6c6c 6564 2073 6576  e and called sev
+0001d910: 6572 616c 2074 696d 6573 2074 6f20 736f  eral times to so
+0001d920: 6c76 6520 6d6f 6465 6c73 2e20 5468 6520  lve models. The 
+0001d930: 666f 6c6c 6f77 696e 6720 7477 6f20 6c69  following two li
+0001d940: 6e65 7320 6172 6520 6e65 6365 7373 6172  nes are necessar
+0001d950: 792e 2049 7420 7365 656d 7320 7468 6174  y. It seems that
+0001d960: 2074 6865 2073 6f6c 7665 7220 636c 6173   the solver clas
+0001d970: 7320 7769 6c6c 206e 6f74 2062 6520 696e  s will not be in
+0001d980: 6974 2065 7665 7279 2074 696d 6520 6361  it every time ca
+0001d990: 6c6c 2e0a 2020 2020 2020 2020 2020 2020  ll..            
+0001d9a0: 2320 466f 7220 6578 616d 706c 652c 2069  # For example, i
+0001d9b0: 6620 7765 2072 656d 6f76 6520 7468 6520  f we remove the 
+0001d9c0: 666f 6c6c 6f77 696e 6720 7477 6f20 6c69  following two li
+0001d9d0: 6e65 732e 2074 6573 745f 524c 504e 4c50  nes. test_RLPNLP
+0001d9e0: 5f4c 3120 7769 6c6c 2066 6169 6c2e 0a20  _L1 will fail.. 
+0001d9f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001da00: 6265 7374 5f73 6f6c 7574 696f 6e5f 666f  best_solution_fo
+0001da10: 756e 6420 3d20 4e6f 6e65 0a20 2020 2020  und = None.     
+0001da20: 2020 2020 2020 2073 656c 662e 6265 7374         self.best
+0001da30: 5f73 6f6c 7574 696f 6e5f 666f 756e 645f  _solution_found_
+0001da40: 7469 6d65 203d 204e 6f6e 650a 2020 2020  time = None.    
+0001da50: 2020 2020 2020 2020 7365 6c66 2e69 6e69          self.ini
+0001da60: 7469 616c 697a 655f 6d69 705f 7072 6f62  tialize_mip_prob
+0001da70: 6c65 6d28 290a 0a20 2020 2020 2020 2020  lem()..         
+0001da80: 2020 2023 2049 6e69 7469 616c 697a 6174     # Initializat
+0001da90: 696f 6e0a 2020 2020 2020 2020 2020 2020  ion.            
+0001daa0: 7769 7468 2074 696d 655f 636f 6465 2873  with time_code(s
+0001dab0: 656c 662e 7469 6d69 6e67 2c20 2769 6e69  elf.timing, 'ini
+0001dac0: 7469 616c 697a 6174 696f 6e27 293a 0a20  tialization'):. 
+0001dad0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0001dae0: 656c 662e 4d69 6e64 7450 795f 696e 6974  elf.MindtPy_init
+0001daf0: 6961 6c69 7a61 7469 6f6e 2829 0a0a 2020  ialization()..  
+0001db00: 2020 2020 2020 2020 2020 2320 416c 676f            # Algo
+0001db10: 7269 7468 6d20 6d61 696e 206c 6f6f 700a  rithm main loop.
+0001db20: 2020 2020 2020 2020 2020 2020 7769 7468              with
+0001db30: 2074 696d 655f 636f 6465 2873 656c 662e   time_code(self.
+0001db40: 7469 6d69 6e67 2c20 276d 6169 6e20 6c6f  timing, 'main lo
+0001db50: 6f70 2729 3a0a 2020 2020 2020 2020 2020  op'):.          
+0001db60: 2020 2020 2020 7365 6c66 2e4d 696e 6474        self.Mindt
+0001db70: 5079 5f69 7465 7261 7469 6f6e 5f6c 6f6f  Py_iteration_loo
+0001db80: 7028 290a 0a20 2020 2020 2020 2020 2020  p()..           
+0001db90: 2023 204c 6f61 6420 736f 6c75 7469 6f6e   # Load solution
+0001dba0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001dbb0: 7365 6c66 2e62 6573 745f 736f 6c75 7469  self.best_soluti
+0001dbc0: 6f6e 5f66 6f75 6e64 2069 7320 6e6f 7420  on_found is not 
+0001dbd0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0001dbe0: 2020 2020 2020 7365 6c66 2e6c 6f61 645f        self.load_
+0001dbf0: 736f 6c75 7469 6f6e 2829 0a0a 2020 2020  solution()..    
+0001dc00: 2020 2020 2020 2020 2320 4765 7420 696e          # Get in
+0001dc10: 7465 6772 616c 2069 6e66 6f0a 2020 2020  tegral info.    
+0001dc20: 2020 2020 2020 2020 7365 6c66 2e67 6574          self.get
+0001dc30: 5f69 6e74 6567 7261 6c5f 696e 666f 2829  _integral_info()
+0001dc40: 0a0a 2020 2020 2020 2020 2020 2020 636f  ..            co
+0001dc50: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
+0001dc60: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001dc70: 2020 2720 7b3a 3c32 357d 3a20 2020 7b3a    ' {:<25}:   {:
+0001dc80: 3e37 2e34 667d 2027 2e66 6f72 6d61 7428  >7.4f} '.format(
+0001dc90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001dca0: 2020 2020 2027 5072 696d 616c 2d64 7561       'Primal-dua
+0001dcb0: 6c20 6761 7020 696e 7465 6772 616c 272c  l gap integral',
+0001dcc0: 2073 656c 662e 7072 696d 616c 5f64 7561   self.primal_dua
+0001dcd0: 6c5f 6761 705f 696e 7465 6772 616c 0a20  l_gap_integral. 
+0001dce0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0001dcf0: 0a20 2020 2020 2020 2020 2020 2029 0a0a  .            )..
+0001dd00: 2020 2020 2020 2020 2320 5570 6461 7465          # Update
+0001dd10: 2072 6573 756c 740a 2020 2020 2020 2020   result.        
+0001dd20: 7365 6c66 2e75 7064 6174 655f 7265 7375  self.update_resu
+0001dd30: 6c74 2829 0a20 2020 2020 2020 2069 6620  lt().        if 
+0001dd40: 636f 6e66 6967 2e73 696e 676c 655f 7472  config.single_tr
+0001dd50: 6565 3a0a 2020 2020 2020 2020 2020 2020  ee:.            
+0001dd60: 7365 6c66 2e72 6573 756c 7473 2e73 6f6c  self.results.sol
+0001dd70: 7665 722e 6e75 6d5f 6e6f 6465 7320 3d20  ver.num_nodes = 
+0001dd80: 7365 6c66 2e6e 6c70 5f69 7465 7220 2d20  self.nlp_iter - 
+0001dd90: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+0001dda0: 2020 3120 6966 2063 6f6e 6669 672e 696e    1 if config.in
+0001ddb0: 6974 5f73 7472 6174 6567 7920 3d3d 2027  it_strategy == '
+0001ddc0: 724e 4c50 2720 656c 7365 2030 0a20 2020  rNLP' else 0.   
+0001ddd0: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
+0001dde0: 2020 2020 7265 7475 726e 2073 656c 662e      return self.
+0001ddf0: 7265 7375 6c74 730a 0a20 2020 2064 6566  results..    def
+0001de00: 206f 626a 6563 7469 7665 5f72 6566 6f72   objective_refor
+0001de10: 6d75 6c61 7469 6f6e 2873 656c 6629 3a0a  mulation(self):.
+0001de20: 2020 2020 2020 2020 2320 496e 2074 6865          # In the
+0001de30: 2070 726f 6365 7373 5f6f 626a 6563 7469   process_objecti
+0001de40: 7665 2066 756e 6374 696f 6e2c 2061 7320  ve function, as 
+0001de50: 6c6f 6e67 2061 7320 7468 6520 6f62 6a65  long as the obje
+0001de60: 6374 6976 6520 6675 6e63 7469 6f6e 2069  ctive function i
+0001de70: 7320 6e6f 6e6c 696e 6561 722c 2069 7420  s nonlinear, it 
+0001de80: 7769 6c6c 2062 6520 7265 666f 726d 756c  will be reformul
+0001de90: 6174 6564 2061 6e64 2074 6865 2076 6172  ated and the var
+0001dea0: 6961 626c 652f 636f 6e73 7472 6169 6e74  iable/constraint
+0001deb0: 2f6f 626a 6563 7469 7665 206c 6973 7473  /objective lists
+0001dec0: 2077 696c 6c20 6265 2075 7064 6174 6564   will be updated
+0001ded0: 2e0a 2020 2020 2020 2020 2320 466f 7220  ..        # For 
+0001dee0: 4f41 2f47 4f41 2f4c 502d 4e4c 5020 616c  OA/GOA/LP-NLP al
+0001def0: 676f 7269 7468 6d2c 2069 6620 7468 6520  gorithm, if the 
+0001df00: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+0001df10: 6f6e 2069 7320 6c69 6e65 6172 2c20 6974  on is linear, it
+0001df20: 2077 696c 6c20 6e6f 7420 6265 2072 6566   will not be ref
+0001df30: 6f72 6d75 6c61 7465 6420 6173 2065 7069  ormulated as epi
+0001df40: 6772 6170 6820 636f 6e73 7472 6169 6e74  graph constraint
+0001df50: 2e0a 2020 2020 2020 2020 2320 4966 2074  ..        # If t
+0001df60: 6865 206f 626a 6563 7469 7665 2066 756e  he objective fun
+0001df70: 6374 696f 6e20 6973 206c 696e 6561 722c  ction is linear,
+0001df80: 2069 7420 7769 6c6c 2062 6520 7265 666f   it will be refo
+0001df90: 726d 756c 6174 6564 2061 7320 6570 6967  rmulated as epig
+0001dfa0: 7261 7068 2063 6f6e 7374 7261 696e 7420  raph constraint 
+0001dfb0: 6f6e 6c79 2069 6620 7468 6520 4665 6173  only if the Feas
+0001dfc0: 6962 696c 6974 7920 5075 6d70 206f 7220  ibility Pump or 
+0001dfd0: 524f 412f 524c 502d 4e4c 5020 616c 676f  ROA/RLP-NLP algo
+0001dfe0: 7269 7468 6d20 6973 2061 6374 6976 6174  rithm is activat
+0001dff0: 6564 2e20 286d 6f76 655f 6f62 6a65 6374  ed. (move_object
+0001e000: 6976 6520 3d20 5472 7565 290a 2020 2020  ive = True).    
+0001e010: 2020 2020 2320 496e 2073 6f6d 6520 6361      # In some ca
+0001e020: 7365 732c 2074 6865 2076 6172 6961 626c  ses, the variabl
+0001e030: 652f 636f 6e73 7472 6169 6e74 2f6f 626a  e/constraint/obj
+0001e040: 6563 7469 7665 206c 6973 7473 2077 696c  ective lists wil
+0001e050: 6c20 6e6f 7420 6265 2075 7064 6174 6564  l not be updated
+0001e060: 2065 7665 6e20 6966 2074 6865 206f 626a   even if the obj
+0001e070: 6563 7469 7665 2069 7320 6570 6967 7261  ective is epigra
+0001e080: 7068 2d72 6566 6f72 6d75 6c61 7465 642e  ph-reformulated.
+0001e090: 0a20 2020 2020 2020 2023 2049 6e20 4665  .        # In Fe
+0001e0a0: 6173 6962 696c 6974 7920 5075 6d70 2c20  asibility Pump, 
+0001e0b0: 7369 6e63 6520 7468 6520 6469 7374 616e  since the distan
+0001e0c0: 6365 2063 616c 6375 6c61 7469 6f6e 206f  ce calculation o
+0001e0d0: 6e6c 7920 696e 636c 7564 6573 2064 6973  nly includes dis
+0001e0e0: 6372 6574 6520 7661 7269 6162 6c65 7320  crete variables 
+0001e0f0: 616e 6420 7468 6520 6570 6967 7261 7068  and the epigraph
+0001e100: 2073 6c61 636b 2076 6172 6961 626c 6573   slack variables
+0001e110: 2061 7265 2063 6f6e 7469 6e75 6f75 7320   are continuous 
+0001e120: 7661 7269 6162 6c65 732c 2074 6865 2046  variables, the F
+0001e130: 6561 7369 6269 6c69 7479 2050 756d 7020  easibility Pump 
+0001e140: 616c 676f 7269 7468 6d20 7769 6c6c 206e  algorithm will n
+0001e150: 6f74 2061 6666 6563 7465 6420 6576 656e  ot affected even
+0001e160: 2069 6620 7468 6520 7661 7269 6162 6c65   if the variable
+0001e170: 206c 6973 7420 6172 6520 7570 6461 7465   list are update
+0001e180: 642e 0a20 2020 2020 2020 2023 2049 6e20  d..        # In 
+0001e190: 524f 4120 616e 6420 524c 502f 4e4c 502c  ROA and RLP/NLP,
+0001e1a0: 2073 696e 6365 2074 6865 2064 6973 7461   since the dista
+0001e1b0: 6e63 6520 6361 6c63 756c 6174 696f 6e20  nce calculation 
+0001e1c0: 646f 6573 206e 6f74 2069 6e63 6c75 6465  does not include
+0001e1d0: 2074 6865 7365 2065 7069 6772 6170 6820   these epigraph 
+0001e1e0: 736c 6163 6b20 7661 7269 6162 6c65 732c  slack variables,
+0001e1f0: 2074 6865 7920 7368 6f75 6c64 206e 6f74   they should not
+0001e200: 2062 6520 6164 6465 6420 746f 2074 6865   be added to the
+0001e210: 2076 6172 6961 626c 6520 6c69 7374 2e20   variable list. 
+0001e220: 2875 7064 6174 655f 7661 725f 636f 6e5f  (update_var_con_
+0001e230: 6c69 7374 203d 2046 616c 7365 290a 2020  list = False).  
+0001e240: 2020 2020 2020 2320 496e 2074 6865 2070        # In the p
+0001e250: 726f 6365 7373 5f6f 626a 6563 7469 7665  rocess_objective
+0001e260: 2066 756e 6374 696f 6e2c 206f 6e63 6520   function, once 
+0001e270: 7468 6520 6f62 6a65 6374 6976 6520 6675  the objective fu
+0001e280: 6e63 7469 6f6e 2068 6173 2062 6565 6e20  nction has been 
+0001e290: 7265 666f 726d 756c 6174 6564 2061 7320  reformulated as 
+0001e2a0: 6570 6967 7261 7068 2063 6f6e 7374 7261  epigraph constra
+0001e2b0: 696e 742c 2074 6865 2076 6172 6961 626c  int, the variabl
+0001e2c0: 652f 636f 6e73 7472 6169 6e74 2f6f 626a  e/constraint/obj
+0001e2d0: 6563 7469 7665 206c 6973 7473 2077 696c  ective lists wil
+0001e2e0: 6c20 6e6f 7420 6265 2075 7064 6174 6564  l not be updated
+0001e2f0: 206f 6e6c 7920 6966 2074 6865 204d 494e   only if the MIN
+0001e300: 4c50 2068 6173 2061 206c 696e 6561 7220  LP has a linear 
+0001e310: 6f62 6a65 6374 6976 6520 6675 6e63 7469  objective functi
+0001e320: 6f6e 2061 6e64 2072 6567 756c 6172 697a  on and regulariz
+0001e330: 6174 696f 6e20 6973 2061 6374 6976 6174  ation is activat
+0001e340: 6564 2061 7420 7468 6520 7361 6d65 2074  ed at the same t
+0001e350: 696d 652e 0a20 2020 2020 2020 2023 2054  ime..        # T
+0001e360: 6869 7320 6973 2062 6563 6175 7365 2074  his is because t
+0001e370: 6865 2065 7069 6772 6170 6820 636f 6e73  he epigraph cons
+0001e380: 7472 6169 6e74 2069 7320 7665 7279 2022  traint is very "
+0001e390: 666c 6174 2220 666f 7220 6272 616e 6368  flat" for branch
+0001e3a0: 696e 6720 7275 6c65 732e 2054 6865 206f  ing rules. The o
+0001e3b0: 7269 6769 6e61 6c20 6f62 6a65 6374 6976  riginal objectiv
+0001e3c0: 6520 6675 6e63 7469 6f6e 2077 696c 6c20  e function will 
+0001e3d0: 6265 2075 7365 6420 666f 7220 7468 6520  be used for the 
+0001e3e0: 6d61 696e 2070 726f 626c 656d 2061 6e64  main problem and
+0001e3f0: 2065 7069 6772 6170 6820 7265 666f 726d   epigraph reform
+0001e400: 756c 6174 696f 6e20 7769 6c6c 2062 6520  ulation will be 
+0001e410: 7573 6564 2066 6f72 2074 6865 2070 726f  used for the pro
+0001e420: 6a65 6374 696f 6e20 7072 6f62 6c65 6d2e  jection problem.
+0001e430: 0a20 2020 2020 2020 2073 656c 662e 7072  .        self.pr
+0001e440: 6f63 6573 735f 6f62 6a65 6374 6976 6528  ocess_objective(
+0001e450: 7570 6461 7465 5f76 6172 5f63 6f6e 5f6c  update_var_con_l
+0001e460: 6973 743d 5472 7565 290a 0a20 2020 2064  ist=True)..    d
+0001e470: 6566 2068 616e 646c 655f 6d61 696e 5f6d  ef handle_main_m
+0001e480: 6970 5f74 6572 6d69 6e61 7469 6f6e 2873  ip_termination(s
+0001e490: 656c 662c 206d 6169 6e5f 6d69 702c 206d  elf, main_mip, m
+0001e4a0: 6169 6e5f 6d69 705f 7265 7375 6c74 7329  ain_mip_results)
+0001e4b0: 3a0a 2020 2020 2020 2020 7368 6f75 6c64  :.        should
+0001e4c0: 5f74 6572 6d69 6e61 7465 203d 2046 616c  _terminate = Fal
+0001e4d0: 7365 0a20 2020 2020 2020 2069 6620 6d61  se.        if ma
+0001e4e0: 696e 5f6d 6970 5f72 6573 756c 7473 2069  in_mip_results i
+0001e4f0: 7320 6e6f 7420 4e6f 6e65 3a0a 2020 2020  s not None:.    
+0001e500: 2020 2020 2020 2020 6966 206e 6f74 2073          if not s
+0001e510: 656c 662e 636f 6e66 6967 2e73 696e 676c  elf.config.singl
+0001e520: 655f 7472 6565 3a0a 2020 2020 2020 2020  e_tree:.        
+0001e530: 2020 2020 2020 2020 6966 206d 6169 6e5f          if main_
+0001e540: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
+0001e550: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+0001e560: 6f6e 6469 7469 6f6e 2069 7320 7463 2e6f  ondition is tc.o
+0001e570: 7074 696d 616c 3a0a 2020 2020 2020 2020  ptimal:.        
+0001e580: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001e590: 2e68 616e 646c 655f 6d61 696e 5f6f 7074  .handle_main_opt
+0001e5a0: 696d 616c 286d 6169 6e5f 6d69 7029 0a20  imal(main_mip). 
+0001e5b0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+0001e5c0: 6c69 6620 6d61 696e 5f6d 6970 5f72 6573  lif main_mip_res
+0001e5d0: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+0001e5e0: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+0001e5f0: 6e20 6973 2074 632e 696e 6665 6173 6962  n is tc.infeasib
+0001e600: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
+0001e610: 2020 2020 2020 2020 7365 6c66 2e68 616e          self.han
+0001e620: 646c 655f 6d61 696e 5f69 6e66 6561 7369  dle_main_infeasi
+0001e630: 626c 6528 290a 2020 2020 2020 2020 2020  ble().          
+0001e640: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
+0001e650: 6173 745f 6974 6572 5f63 7574 7320 3d20  ast_iter_cuts = 
+0001e660: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
+0001e670: 2020 2020 2020 2020 2073 686f 756c 645f           should_
+0001e680: 7465 726d 696e 6174 6520 3d20 5472 7565  terminate = True
+0001e690: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e6a0: 2065 6c69 6620 6d61 696e 5f6d 6970 5f72   elif main_mip_r
+0001e6b0: 6573 756c 7473 2e73 6f6c 7665 722e 7465  esults.solver.te
+0001e6c0: 726d 696e 6174 696f 6e5f 636f 6e64 6974  rmination_condit
+0001e6d0: 696f 6e20 6973 2074 632e 756e 626f 756e  ion is tc.unboun
+0001e6e0: 6465 643a 0a20 2020 2020 2020 2020 2020  ded:.           
+0001e6f0: 2020 2020 2020 2020 2074 656d 705f 7265           temp_re
+0001e700: 7375 6c74 7320 3d20 7365 6c66 2e68 616e  sults = self.han
+0001e710: 646c 655f 6d61 696e 5f75 6e62 6f75 6e64  dle_main_unbound
+0001e720: 6564 286d 6169 6e5f 6d69 7029 0a20 2020  ed(main_mip).   
+0001e730: 2020 2020 2020 2020 2020 2020 2065 6c69               eli
+0001e740: 6620 280a 2020 2020 2020 2020 2020 2020  f (.            
+0001e750: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
+0001e760: 5f72 6573 756c 7473 2e73 6f6c 7665 722e  _results.solver.
+0001e770: 7465 726d 696e 6174 696f 6e5f 636f 6e64  termination_cond
+0001e780: 6974 696f 6e0a 2020 2020 2020 2020 2020  ition.          
+0001e790: 2020 2020 2020 2020 2020 6973 2074 632e            is tc.
+0001e7a0: 696e 6665 6173 6962 6c65 4f72 556e 626f  infeasibleOrUnbo
+0001e7b0: 756e 6465 640a 2020 2020 2020 2020 2020  unded.          
+0001e7c0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+0001e7d0: 2020 2020 2020 2020 2020 2020 2074 656d               tem
+0001e7e0: 705f 7265 7375 6c74 7320 3d20 7365 6c66  p_results = self
+0001e7f0: 2e68 616e 646c 655f 6d61 696e 5f75 6e62  .handle_main_unb
+0001e800: 6f75 6e64 6564 286d 6169 6e5f 6d69 7029  ounded(main_mip)
+0001e810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e820: 2020 2020 2069 6620 7465 6d70 5f72 6573       if temp_res
+0001e830: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
+0001e840: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
+0001e850: 6e20 6973 2074 632e 696e 6665 6173 6962  n is tc.infeasib
+0001e860: 6c65 3a0a 2020 2020 2020 2020 2020 2020  le:.            
+0001e870: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+0001e880: 2e68 616e 646c 655f 6d61 696e 5f69 6e66  .handle_main_inf
+0001e890: 6561 7369 626c 6528 290a 2020 2020 2020  easible().      
+0001e8a0: 2020 2020 2020 2020 2020 656c 6966 206d            elif m
+0001e8b0: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
+0001e8c0: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
+0001e8d0: 6f6e 5f63 6f6e 6469 7469 6f6e 2069 7320  on_condition is 
+0001e8e0: 7463 2e6d 6178 5469 6d65 4c69 6d69 743a  tc.maxTimeLimit:
+0001e8f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001e900: 2020 2020 2073 656c 662e 6861 6e64 6c65       self.handle
+0001e910: 5f6d 6169 6e5f 6d61 785f 7469 6d65 6c69  _main_max_timeli
+0001e920: 6d69 7428 6d61 696e 5f6d 6970 2c20 6d61  mit(main_mip, ma
+0001e930: 696e 5f6d 6970 5f72 6573 756c 7473 290a  in_mip_results).
 0001e940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e950: 2020 2020 2020 2020 6d61 696e 5f6d 6970          main_mip
-0001e960: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-0001e970: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-0001e980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001e990: 2020 2020 2020 7365 6c66 2e66 6978 6564        self.fixed
-0001e9a0: 5f6e 6c70 2e4d 696e 6474 5079 5f75 7469  _nlp.MindtPy_uti
-0001e9b0: 6c73 2e76 6172 6961 626c 655f 6c69 7374  ls.variable_list
-0001e9c0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001e9d0: 2020 2020 2020 2020 2020 7365 6c66 2e63            self.c
-0001e9e0: 6f6e 6669 672c 0a20 2020 2020 2020 2020  onfig,.         
-0001e9f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0001ea00: 6b69 705f 6669 7865 643d 4661 6c73 652c  kip_fixed=False,
-0001ea10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ea20: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0001ea30: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001ea40: 7570 6461 7465 5f73 7562 6f70 7469 6d61  update_suboptima
-0001ea50: 6c5f 6475 616c 5f62 6f75 6e64 286d 6169  l_dual_bound(mai
-0001ea60: 6e5f 6d69 705f 7265 7375 6c74 7329 0a20  n_mip_results). 
-0001ea70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ea80: 2020 2073 656c 662e 636f 6e66 6967 2e6c     self.config.l
-0001ea90: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
+0001e950: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
+0001e960: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
+0001e970: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
+0001e980: 7463 2e6d 6178 5469 6d65 4c69 6d69 740a  tc.maxTimeLimit.
+0001e990: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001e9a0: 656c 6966 206d 6169 6e5f 6d69 705f 7265  elif main_mip_re
+0001e9b0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+0001e9c0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+0001e9d0: 6f6e 2069 7320 7463 2e66 6561 7369 626c  on is tc.feasibl
+0001e9e0: 6520 6f72 2028 0a20 2020 2020 2020 2020  e or (.         
+0001e9f0: 2020 2020 2020 2020 2020 206d 6169 6e5f             main_
+0001ea00: 6d69 705f 7265 7375 6c74 732e 736f 6c76  mip_results.solv
+0001ea10: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+0001ea20: 6f6e 6469 7469 6f6e 2069 7320 7463 2e6f  ondition is tc.o
+0001ea30: 7468 6572 0a20 2020 2020 2020 2020 2020  ther.           
+0001ea40: 2020 2020 2020 2020 2061 6e64 206d 6169           and mai
+0001ea50: 6e5f 6d69 705f 7265 7375 6c74 732e 736f  n_mip_results.so
+0001ea60: 6c75 7469 6f6e 2e73 7461 7475 7320 6973  lution.status is
+0001ea70: 2053 6f6c 7574 696f 6e53 7461 7475 732e   SolutionStatus.
+0001ea80: 6665 6173 6962 6c65 0a20 2020 2020 2020  feasible.       
+0001ea90: 2020 2020 2020 2020 2029 3a0a 2020 2020           ):.    
 0001eaa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eab0: 2020 2020 7365 6c66 2e6c 6f67 5f66 6f72      self.log_for
-0001eac0: 6d61 7474 6572 2e66 6f72 6d61 7428 0a20  matter.format(. 
-0001ead0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eae0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-0001eaf0: 6d69 705f 6974 6572 2c0a 2020 2020 2020  mip_iter,.      
-0001eb00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eb10: 2020 2020 2020 274d 494c 5027 2c0a 2020        'MILP',.  
-0001eb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eb30: 2020 2020 2020 2020 2020 7661 6c75 6528            value(
-0001eb40: 4d69 6e64 7450 792e 6d69 705f 6f62 6a2e  MindtPy.mip_obj.
-0001eb50: 6578 7072 292c 0a20 2020 2020 2020 2020  expr),.         
-0001eb60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eb70: 2020 2073 656c 662e 7072 696d 616c 5f62     self.primal_b
-0001eb80: 6f75 6e64 2c0a 2020 2020 2020 2020 2020  ound,.          
-0001eb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eba0: 2020 7365 6c66 2e64 7561 6c5f 626f 756e    self.dual_boun
-0001ebb0: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-0001ebc0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-0001ebd0: 656c 662e 7265 6c5f 6761 702c 0a20 2020  elf.rel_gap,.   
-0001ebe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ebf0: 2020 2020 2020 2020 2067 6574 5f6d 6169           get_mai
-0001ec00: 6e5f 656c 6170 7365 645f 7469 6d65 2873  n_elapsed_time(s
-0001ec10: 656c 662e 7469 6d69 6e67 292c 0a20 2020  elf.timing),.   
-0001ec20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ec30: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
-0001ec40: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
-0001ec50: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-0001ec60: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-0001ec70: 2020 2020 2020 2072 6169 7365 2056 616c         raise Val
-0001ec80: 7565 4572 726f 7228 0a20 2020 2020 2020  ueError(.       
-0001ec90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001eca0: 2027 4d69 6e64 7450 7920 756e 6162 6c65   'MindtPy unable
-0001ecb0: 2074 6f20 6861 6e64 6c65 204d 494c 5020   to handle MILP 
-0001ecc0: 6d61 696e 2074 6572 6d69 6e61 7469 6f6e  main termination
-0001ecd0: 2063 6f6e 6469 7469 6f6e 2027 0a20 2020   condition '.   
-0001ece0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ecf0: 2020 2020 2027 6f66 2025 732e 2053 6f6c       'of %s. Sol
-0001ed00: 7665 7220 6d65 7373 6167 653a 2025 7327  ver message: %s'
-0001ed10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ed20: 2020 2020 2020 2020 2025 2028 0a20 2020           % (.   
-0001ed30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ed40: 2020 2020 2020 2020 206d 6169 6e5f 6d69           main_mi
-0001ed50: 705f 7265 7375 6c74 732e 736f 6c76 6572  p_results.solver
-0001ed60: 2e74 6572 6d69 6e61 7469 6f6e 5f63 6f6e  .termination_con
-0001ed70: 6469 7469 6f6e 2c0a 2020 2020 2020 2020  dition,.        
-0001ed80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ed90: 2020 2020 6d61 696e 5f6d 6970 5f72 6573      main_mip_res
-0001eda0: 756c 7473 2e73 6f6c 7665 722e 6d65 7373  ults.solver.mess
-0001edb0: 6167 652c 0a20 2020 2020 2020 2020 2020  age,.           
-0001edc0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+0001eab0: 2320 6c6f 6164 2074 6865 2073 6f6c 7574  # load the solut
+0001eac0: 696f 6e20 616e 6420 7375 7070 7265 7373  ion and suppress
+0001ead0: 2074 6865 2077 6172 6e69 6e67 206d 6573   the warning mes
+0001eae0: 7361 6765 2062 7920 7365 7474 696e 670a  sage by setting.
+0001eaf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eb00: 2020 2020 2320 736f 6c76 6572 2073 7461      # solver sta
+0001eb10: 7475 7320 746f 206f 6b2e 0a20 2020 2020  tus to ok..     
+0001eb20: 2020 2020 2020 2020 2020 2020 2020 204d                 M
+0001eb30: 696e 6474 5079 203d 206d 6169 6e5f 6d69  indtPy = main_mi
+0001eb40: 702e 4d69 6e64 7450 795f 7574 696c 730a  p.MindtPy_utils.
+0001eb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eb60: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
+0001eb70: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+0001eb80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eb90: 2020 2020 2027 4d49 4c50 2073 6f6c 7665       'MILP solve
+0001eba0: 7220 7265 706f 7274 6564 2066 6561 7369  r reported feasi
+0001ebb0: 626c 6520 736f 6c75 7469 6f6e 2c20 270a  ble solution, '.
+0001ebc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ebd0: 2020 2020 2020 2020 2762 7574 206e 6f74          'but not
+0001ebe0: 2067 7561 7261 6e74 6565 6420 746f 2062   guaranteed to b
+0001ebf0: 6520 6f70 7469 6d61 6c2e 270a 2020 2020  e optimal.'.    
+0001ec00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ec10: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0001ec20: 2020 2020 2020 636f 7079 5f76 6172 5f6c        copy_var_l
+0001ec30: 6973 745f 7661 6c75 6573 280a 2020 2020  ist_values(.    
+0001ec40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ec50: 2020 2020 6d61 696e 5f6d 6970 2e4d 696e      main_mip.Min
+0001ec60: 6474 5079 5f75 7469 6c73 2e76 6172 6961  dtPy_utils.varia
+0001ec70: 626c 655f 6c69 7374 2c0a 2020 2020 2020  ble_list,.      
+0001ec80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ec90: 2020 7365 6c66 2e66 6978 6564 5f6e 6c70    self.fixed_nlp
+0001eca0: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+0001ecb0: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+0001ecc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ecd0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
+0001ece0: 672c 0a20 2020 2020 2020 2020 2020 2020  g,.             
+0001ecf0: 2020 2020 2020 2020 2020 2073 6b69 705f             skip_
+0001ed00: 6669 7865 643d 4661 6c73 652c 0a20 2020  fixed=False,.   
+0001ed10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ed20: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+0001ed30: 2020 2020 2020 2073 656c 662e 7570 6461         self.upda
+0001ed40: 7465 5f73 7562 6f70 7469 6d61 6c5f 6475  te_suboptimal_du
+0001ed50: 616c 5f62 6f75 6e64 286d 6169 6e5f 6d69  al_bound(main_mi
+0001ed60: 705f 7265 7375 6c74 7329 0a20 2020 2020  p_results).     
+0001ed70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0001ed80: 656c 662e 636f 6e66 6967 2e6c 6f67 6765  elf.config.logge
+0001ed90: 722e 696e 666f 280a 2020 2020 2020 2020  r.info(.        
+0001eda0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001edb0: 7365 6c66 2e6c 6f67 5f66 6f72 6d61 7474  self.log_formatt
+0001edc0: 6572 2e66 6f72 6d61 7428 0a20 2020 2020  er.format(.     
 0001edd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ede0: 2020 2029 0a20 2020 2020 2020 2065 6c73     ).        els
-0001edf0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-0001ee00: 656c 662e 636f 6e66 6967 2e6c 6f67 6765  elf.config.logge
-0001ee10: 722e 696e 666f 2827 416c 676f 7269 7468  r.info('Algorith
-0001ee20: 6d20 7368 6f75 6c64 2074 6572 6d69 6e61  m should termina
-0001ee30: 7465 2068 6572 652e 2729 0a20 2020 2020  te here.').     
-0001ee40: 2020 2020 2020 2073 686f 756c 645f 7465         should_te
-0001ee50: 726d 696e 6174 6520 3d20 5472 7565 0a20  rminate = True. 
-0001ee60: 2020 2020 2020 2020 2020 2023 2062 7265             # bre
-0001ee70: 616b 0a20 2020 2020 2020 2072 6574 7572  ak.        retur
-0001ee80: 6e20 7368 6f75 6c64 5f74 6572 6d69 6e61  n should_termina
-0001ee90: 7465 0a0a 2020 2020 2320 6974 6572 6174  te..    # iterat
-0001eea0: 652e 7079 0a20 2020 2064 6566 204d 696e  e.py.    def Min
-0001eeb0: 6474 5079 5f69 7465 7261 7469 6f6e 5f6c  dtPy_iteration_l
-0001eec0: 6f6f 7028 7365 6c66 293a 0a20 2020 2020  oop(self):.     
-0001eed0: 2020 2022 2222 4d61 696e 206c 6f6f 7020     """Main loop 
-0001eee0: 666f 7220 4d69 6e64 7450 7920 416c 676f  for MindtPy Algo
-0001eef0: 7269 7468 6d73 2e0a 0a20 2020 2020 2020  rithms...       
-0001ef00: 2054 6869 7320 6973 2074 6865 206f 7574   This is the out
-0001ef10: 6572 6d6f 7374 2066 756e 6374 696f 6e20  ermost function 
-0001ef20: 666f 7220 7468 6520 4f75 7465 7220 4170  for the Outer Ap
-0001ef30: 7072 6f78 696d 6174 696f 6e20 616c 676f  proximation algo
-0001ef40: 7269 7468 6d20 696e 2074 6869 7320 7061  rithm in this pa
-0001ef50: 636b 6167 653b 2074 6869 7320 6675 6e63  ckage; this func
-0001ef60: 7469 6f6e 2063 6f6e 7472 6f6c 7320 7468  tion controls th
-0001ef70: 6520 7072 6f67 7265 7373 206f 660a 2020  e progress of.  
-0001ef80: 2020 2020 2020 736f 6c76 696e 6720 7468        solving th
-0001ef90: 6520 6d6f 6465 6c2e 0a0a 2020 2020 2020  e model...      
-0001efa0: 2020 5261 6973 6573 0a20 2020 2020 2020    Raises.       
-0001efb0: 202d 2d2d 2d2d 2d0a 2020 2020 2020 2020   ------.        
-0001efc0: 5661 6c75 6545 7272 6f72 0a20 2020 2020  ValueError.     
-0001efd0: 2020 2020 2020 2054 6865 2073 7472 6174         The strat
-0001efe0: 6567 7920 7661 6c75 6520 6973 206e 6f74  egy value is not
-0001eff0: 2063 6f72 7265 6374 206f 7220 6e6f 7420   correct or not 
-0001f000: 696e 636c 7564 6564 2e0a 2020 2020 2020  included..      
-0001f010: 2020 2222 220a 2020 2020 2020 2020 636f    """.        co
-0001f020: 6e66 6967 203d 2073 656c 662e 636f 6e66  nfig = self.conf
-0001f030: 6967 0a20 2020 2020 2020 2077 6869 6c65  ig.        while
-0001f040: 2073 656c 662e 6d69 705f 6974 6572 203c   self.mip_iter <
-0001f050: 2063 6f6e 6669 672e 6974 6572 6174 696f   config.iteratio
-0001f060: 6e5f 6c69 6d69 743a 0a20 2020 2020 2020  n_limit:.       
-0001f070: 2020 2020 2023 2073 6f6c 7665 204d 4950       # solve MIP
-0001f080: 206d 6169 6e20 7072 6f62 6c65 6d0a 2020   main problem.  
-0001f090: 2020 2020 2020 2020 2020 7769 7468 2074            with t
-0001f0a0: 696d 655f 636f 6465 2873 656c 662e 7469  ime_code(self.ti
-0001f0b0: 6d69 6e67 2c20 276d 6169 6e27 293a 0a20  ming, 'main'):. 
-0001f0c0: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-0001f0d0: 6169 6e5f 6d69 702c 206d 6169 6e5f 6d69  ain_mip, main_mi
-0001f0e0: 705f 7265 7375 6c74 7320 3d20 7365 6c66  p_results = self
-0001f0f0: 2e73 6f6c 7665 5f6d 6169 6e28 290a 2020  .solve_main().  
-0001f100: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0001f110: 662e 6861 6e64 6c65 5f6d 6169 6e5f 6d69  f.handle_main_mi
-0001f120: 705f 7465 726d 696e 6174 696f 6e28 6d61  p_termination(ma
-0001f130: 696e 5f6d 6970 2c20 6d61 696e 5f6d 6970  in_mip, main_mip
-0001f140: 5f72 6573 756c 7473 293a 0a20 2020 2020  _results):.     
-0001f150: 2020 2020 2020 2020 2020 2062 7265 616b             break
-0001f160: 0a20 2020 2020 2020 2020 2020 2023 2043  .            # C
-0001f170: 616c 6c20 7468 6520 4d49 5020 706f 7374  all the MIP post
-0001f180: 2d73 6f6c 7665 2063 616c 6c62 6163 6b0a  -solve callback.
-0001f190: 2020 2020 2020 2020 2020 2020 7769 7468              with
-0001f1a0: 2074 696d 655f 636f 6465 2873 656c 662e   time_code(self.
-0001f1b0: 7469 6d69 6e67 2c20 2743 616c 6c20 6166  timing, 'Call af
-0001f1c0: 7465 7220 6d61 696e 2073 6f6c 7665 2729  ter main solve')
-0001f1d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001f1e0: 2020 636f 6e66 6967 2e63 616c 6c5f 6166    config.call_af
-0001f1f0: 7465 725f 6d61 696e 5f73 6f6c 7665 286d  ter_main_solve(m
-0001f200: 6169 6e5f 6d69 7029 0a0a 2020 2020 2020  ain_mip)..      
-0001f210: 2020 2020 2020 2320 5265 6775 6c61 7269        # Regulari
-0001f220: 7a61 7469 6f6e 2069 7320 6163 7469 7661  zation is activa
-0001f230: 7465 6420 6166 7465 7220 7468 6520 6669  ted after the fi
-0001f240: 7273 7420 6665 6173 6962 6c65 2073 6f6c  rst feasible sol
-0001f250: 7574 696f 6e20 6973 2066 6f75 6e64 2e0a  ution is found..
-0001f260: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-0001f270: 6f6e 6669 672e 6164 645f 7265 6775 6c61  onfig.add_regula
-0001f280: 7269 7a61 7469 6f6e 2069 7320 6e6f 7420  rization is not 
-0001f290: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0001f2a0: 2020 2020 2020 6966 206e 6f74 2063 6f6e        if not con
-0001f2b0: 6669 672e 7369 6e67 6c65 5f74 7265 653a  fig.single_tree:
-0001f2c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001f2d0: 2020 2020 2073 656c 662e 6164 645f 7265       self.add_re
-0001f2e0: 6775 6c61 7269 7a61 7469 6f6e 2829 0a0a  gularization()..
-0001f2f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f300: 2320 496e 2052 2d4c 502f 4e4c 502c 2077  # In R-LP/NLP, w
-0001f310: 6520 6d69 6768 7420 656e 6420 7570 2077  e might end up w
-0001f320: 6974 6820 616e 2069 6e74 6567 6572 2063  ith an integer c
-0001f330: 6f6d 6269 6e61 7469 6f6e 2074 6861 7420  ombination that 
-0001f340: 6861 736e 2774 2062 6565 6e20 6578 706c  hasn't been expl
-0001f350: 6f72 6564 2e0a 2020 2020 2020 2020 2020  ored..          
-0001f360: 2020 2020 2020 2320 5468 6572 6566 6f72        # Therefor
-0001f370: 652c 2077 6520 6e65 6564 2074 6f20 736f  e, we need to so
-0001f380: 6c76 6520 6669 7865 6420 4e4c 5020 7375  lve fixed NLP su
-0001f390: 6270 726f 626c 656d 206f 6e65 206d 6f72  bproblem one mor
-0001f3a0: 6520 7469 6d65 2e0a 2020 2020 2020 2020  e time..        
-0001f3b0: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
-0001f3c0: 672e 7369 6e67 6c65 5f74 7265 653a 0a20  g.single_tree:. 
-0001f3d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f3e0: 2020 2073 656c 662e 6375 7272 5f69 6e74     self.curr_int
-0001f3f0: 5f73 6f6c 203d 2067 6574 5f69 6e74 6567  _sol = get_integ
-0001f400: 6572 5f73 6f6c 7574 696f 6e28 7365 6c66  er_solution(self
-0001f410: 2e6d 6970 2c20 7374 7269 6e67 5f7a 6572  .mip, string_zer
-0001f420: 6f3d 5472 7565 290a 2020 2020 2020 2020  o=True).        
-0001f430: 2020 2020 2020 2020 2020 2020 636f 7079              copy
-0001f440: 5f76 6172 5f6c 6973 745f 7661 6c75 6573  _var_list_values
-0001f450: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-0001f460: 2020 2020 2020 2020 2020 6d61 696e 5f6d            main_m
-0001f470: 6970 2e4d 696e 6474 5079 5f75 7469 6c73  ip.MindtPy_utils
-0001f480: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
-0001f490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f4a0: 2020 2020 2020 2020 7365 6c66 2e66 6978          self.fix
-0001f4b0: 6564 5f6e 6c70 2e4d 696e 6474 5079 5f75  ed_nlp.MindtPy_u
-0001f4c0: 7469 6c73 2e76 6172 6961 626c 655f 6c69  tils.variable_li
-0001f4d0: 7374 2c0a 2020 2020 2020 2020 2020 2020  st,.            
-0001f4e0: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-0001f4f0: 6967 2c0a 2020 2020 2020 2020 2020 2020  ig,.            
-0001f500: 2020 2020 2020 2020 2020 2020 736b 6970              skip
-0001f510: 5f66 6978 6564 3d46 616c 7365 2c0a 2020  _fixed=False,.  
-0001f520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f530: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-0001f540: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-0001f550: 6375 7272 5f69 6e74 5f73 6f6c 206e 6f74  curr_int_sol not
-0001f560: 2069 6e20 7365 7428 7365 6c66 2e69 6e74   in set(self.int
-0001f570: 6567 6572 5f6c 6973 7429 3a0a 2020 2020  eger_list):.    
-0001f580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f590: 2020 2020 6669 7865 645f 6e6c 702c 2066      fixed_nlp, f
-0001f5a0: 6978 6564 5f6e 6c70 5f72 6573 756c 7420  ixed_nlp_result 
-0001f5b0: 3d20 7365 6c66 2e73 6f6c 7665 5f73 7562  = self.solve_sub
-0001f5c0: 7072 6f62 6c65 6d28 290a 2020 2020 2020  problem().      
-0001f5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f5e0: 2020 7365 6c66 2e68 616e 646c 655f 6e6c    self.handle_nl
-0001f5f0: 705f 7375 6270 726f 626c 656d 5f74 6328  p_subproblem_tc(
-0001f600: 6669 7865 645f 6e6c 702c 2066 6978 6564  fixed_nlp, fixed
-0001f610: 5f6e 6c70 5f72 6573 756c 7429 0a0a 2020  _nlp_result)..  
-0001f620: 2020 2020 2020 2020 2020 6966 2073 656c            if sel
-0001f630: 662e 616c 676f 7269 7468 6d5f 7368 6f75  f.algorithm_shou
-0001f640: 6c64 5f74 6572 6d69 6e61 7465 2863 6865  ld_terminate(che
-0001f650: 636b 5f63 7963 6c69 6e67 3d54 7275 6529  ck_cycling=True)
-0001f660: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0001f670: 2020 7365 6c66 2e6c 6173 745f 6974 6572    self.last_iter
-0001f680: 5f63 7574 7320 3d20 4661 6c73 650a 2020  _cuts = False.  
-0001f690: 2020 2020 2020 2020 2020 2020 2020 6272                br
-0001f6a0: 6561 6b0a 0a20 2020 2020 2020 2020 2020  eak..           
-0001f6b0: 2069 6620 6e6f 7420 636f 6e66 6967 2e73   if not config.s
-0001f6c0: 696e 676c 655f 7472 6565 3a20 2023 2069  ingle_tree:  # i
-0001f6d0: 6620 7765 2064 6f6e 2774 2075 7365 206c  f we don't use l
-0001f6e0: 617a 7920 6361 6c6c 6261 636b 2c20 692e  azy callback, i.
-0001f6f0: 652e 204c 505f 4e4c 500a 2020 2020 2020  e. LP_NLP.      
-0001f700: 2020 2020 2020 2020 2020 2320 536f 6c76            # Solv
-0001f710: 6520 4e4c 5020 7375 6270 726f 626c 656d  e NLP subproblem
-0001f720: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001f730: 2023 2054 6865 2063 6f6e 7374 7261 696e   # The constrain
-0001f740: 7420 6c69 6e65 6172 697a 6174 696f 6e20  t linearization 
-0001f750: 6861 7070 656e 7320 696e 2074 6865 2068  happens in the h
-0001f760: 616e 646c 6572 730a 2020 2020 2020 2020  andlers.        
-0001f770: 2020 2020 2020 2020 6966 206e 6f74 2063          if not c
-0001f780: 6f6e 6669 672e 736f 6c75 7469 6f6e 5f70  onfig.solution_p
-0001f790: 6f6f 6c3a 0a20 2020 2020 2020 2020 2020  ool:.           
-0001f7a0: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
-0001f7b0: 6c70 2c20 6669 7865 645f 6e6c 705f 7265  lp, fixed_nlp_re
-0001f7c0: 7375 6c74 203d 2073 656c 662e 736f 6c76  sult = self.solv
-0001f7d0: 655f 7375 6270 726f 626c 656d 2829 0a20  e_subproblem(). 
-0001f7e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f7f0: 2020 2073 656c 662e 6861 6e64 6c65 5f6e     self.handle_n
-0001f800: 6c70 5f73 7562 7072 6f62 6c65 6d5f 7463  lp_subproblem_tc
-0001f810: 2866 6978 6564 5f6e 6c70 2c20 6669 7865  (fixed_nlp, fixe
-0001f820: 645f 6e6c 705f 7265 7375 6c74 290a 0a20  d_nlp_result).. 
+0001ede0: 2020 2020 2020 2073 656c 662e 6d69 705f         self.mip_
+0001edf0: 6974 6572 2c0a 2020 2020 2020 2020 2020  iter,.          
+0001ee00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ee10: 2020 274d 494c 5027 2c0a 2020 2020 2020    'MILP',.      
+0001ee20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ee30: 2020 2020 2020 7661 6c75 6528 4d69 6e64        value(Mind
+0001ee40: 7450 792e 6d69 705f 6f62 6a2e 6578 7072  tPy.mip_obj.expr
+0001ee50: 292c 0a20 2020 2020 2020 2020 2020 2020  ),.             
+0001ee60: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0001ee70: 656c 662e 7072 696d 616c 5f62 6f75 6e64  elf.primal_bound
+0001ee80: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+0001ee90: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001eea0: 6c66 2e64 7561 6c5f 626f 756e 642c 0a20  lf.dual_bound,. 
+0001eeb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eec0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001eed0: 7265 6c5f 6761 702c 0a20 2020 2020 2020  rel_gap,.       
+0001eee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eef0: 2020 2020 2067 6574 5f6d 6169 6e5f 656c       get_main_el
+0001ef00: 6170 7365 645f 7469 6d65 2873 656c 662e  apsed_time(self.
+0001ef10: 7469 6d69 6e67 292c 0a20 2020 2020 2020  timing),.       
+0001ef20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ef30: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+0001ef40: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+0001ef50: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0001ef60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ef70: 2020 2072 6169 7365 2056 616c 7565 4572     raise ValueEr
+0001ef80: 726f 7228 0a20 2020 2020 2020 2020 2020  ror(.           
+0001ef90: 2020 2020 2020 2020 2020 2020 2027 4d69               'Mi
+0001efa0: 6e64 7450 7920 756e 6162 6c65 2074 6f20  ndtPy unable to 
+0001efb0: 6861 6e64 6c65 204d 494c 5020 6d61 696e  handle MILP main
+0001efc0: 2074 6572 6d69 6e61 7469 6f6e 2063 6f6e   termination con
+0001efd0: 6469 7469 6f6e 2027 0a20 2020 2020 2020  dition '.       
+0001efe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001eff0: 2027 6f66 2025 732e 2053 6f6c 7665 7220   'of %s. Solver 
+0001f000: 6d65 7373 6167 653a 2025 7327 0a20 2020  message: %s'.   
+0001f010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f020: 2020 2020 2025 2028 0a20 2020 2020 2020       % (.       
+0001f030: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f040: 2020 2020 206d 6169 6e5f 6d69 705f 7265       main_mip_re
+0001f050: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+0001f060: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+0001f070: 6f6e 2c0a 2020 2020 2020 2020 2020 2020  on,.            
+0001f080: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f090: 6d61 696e 5f6d 6970 5f72 6573 756c 7473  main_mip_results
+0001f0a0: 2e73 6f6c 7665 722e 6d65 7373 6167 652c  .solver.message,
+0001f0b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001f0c0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+0001f0d0: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+0001f0e0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+0001f0f0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+0001f100: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
+0001f110: 666f 2827 416c 676f 7269 7468 6d20 7368  fo('Algorithm sh
+0001f120: 6f75 6c64 2074 6572 6d69 6e61 7465 2068  ould terminate h
+0001f130: 6572 652e 2729 0a20 2020 2020 2020 2020  ere.').         
+0001f140: 2020 2073 686f 756c 645f 7465 726d 696e     should_termin
+0001f150: 6174 6520 3d20 5472 7565 0a20 2020 2020  ate = True.     
+0001f160: 2020 2020 2020 2023 2062 7265 616b 0a20         # break. 
+0001f170: 2020 2020 2020 2072 6574 7572 6e20 7368         return sh
+0001f180: 6f75 6c64 5f74 6572 6d69 6e61 7465 0a0a  ould_terminate..
+0001f190: 2020 2020 2320 6974 6572 6174 652e 7079      # iterate.py
+0001f1a0: 0a20 2020 2064 6566 204d 696e 6474 5079  .    def MindtPy
+0001f1b0: 5f69 7465 7261 7469 6f6e 5f6c 6f6f 7028  _iteration_loop(
+0001f1c0: 7365 6c66 293a 0a20 2020 2020 2020 2022  self):.        "
+0001f1d0: 2222 4d61 696e 206c 6f6f 7020 666f 7220  ""Main loop for 
+0001f1e0: 4d69 6e64 7450 7920 416c 676f 7269 7468  MindtPy Algorith
+0001f1f0: 6d73 2e0a 0a20 2020 2020 2020 2054 6869  ms...        Thi
+0001f200: 7320 6973 2074 6865 206f 7574 6572 6d6f  s is the outermo
+0001f210: 7374 2066 756e 6374 696f 6e20 666f 7220  st function for 
+0001f220: 7468 6520 4f75 7465 7220 4170 7072 6f78  the Outer Approx
+0001f230: 696d 6174 696f 6e20 616c 676f 7269 7468  imation algorith
+0001f240: 6d20 696e 2074 6869 7320 7061 636b 6167  m in this packag
+0001f250: 653b 2074 6869 7320 6675 6e63 7469 6f6e  e; this function
+0001f260: 2063 6f6e 7472 6f6c 7320 7468 6520 7072   controls the pr
+0001f270: 6f67 7265 7373 206f 660a 2020 2020 2020  ogress of.      
+0001f280: 2020 736f 6c76 696e 6720 7468 6520 6d6f    solving the mo
+0001f290: 6465 6c2e 0a0a 2020 2020 2020 2020 5261  del...        Ra
+0001f2a0: 6973 6573 0a20 2020 2020 2020 202d 2d2d  ises.        ---
+0001f2b0: 2d2d 2d0a 2020 2020 2020 2020 5661 6c75  ---.        Valu
+0001f2c0: 6545 7272 6f72 0a20 2020 2020 2020 2020  eError.         
+0001f2d0: 2020 2054 6865 2073 7472 6174 6567 7920     The strategy 
+0001f2e0: 7661 6c75 6520 6973 206e 6f74 2063 6f72  value is not cor
+0001f2f0: 7265 6374 206f 7220 6e6f 7420 696e 636c  rect or not incl
+0001f300: 7564 6564 2e0a 2020 2020 2020 2020 2222  uded..        ""
+0001f310: 220a 2020 2020 2020 2020 636f 6e66 6967  ".        config
+0001f320: 203d 2073 656c 662e 636f 6e66 6967 0a20   = self.config. 
+0001f330: 2020 2020 2020 2077 6869 6c65 2073 656c         while sel
+0001f340: 662e 6d69 705f 6974 6572 203c 2063 6f6e  f.mip_iter < con
+0001f350: 6669 672e 6974 6572 6174 696f 6e5f 6c69  fig.iteration_li
+0001f360: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
+0001f370: 2023 2073 6f6c 7665 204d 4950 206d 6169   # solve MIP mai
+0001f380: 6e20 7072 6f62 6c65 6d0a 2020 2020 2020  n problem.      
+0001f390: 2020 2020 2020 7769 7468 2074 696d 655f        with time_
+0001f3a0: 636f 6465 2873 656c 662e 7469 6d69 6e67  code(self.timing
+0001f3b0: 2c20 276d 6169 6e27 293a 0a20 2020 2020  , 'main'):.     
+0001f3c0: 2020 2020 2020 2020 2020 206d 6169 6e5f             main_
+0001f3d0: 6d69 702c 206d 6169 6e5f 6d69 705f 7265  mip, main_mip_re
+0001f3e0: 7375 6c74 7320 3d20 7365 6c66 2e73 6f6c  sults = self.sol
+0001f3f0: 7665 5f6d 6169 6e28 290a 2020 2020 2020  ve_main().      
+0001f400: 2020 2020 2020 6966 2073 656c 662e 6861        if self.ha
+0001f410: 6e64 6c65 5f6d 6169 6e5f 6d69 705f 7465  ndle_main_mip_te
+0001f420: 726d 696e 6174 696f 6e28 6d61 696e 5f6d  rmination(main_m
+0001f430: 6970 2c20 6d61 696e 5f6d 6970 5f72 6573  ip, main_mip_res
+0001f440: 756c 7473 293a 0a20 2020 2020 2020 2020  ults):.         
+0001f450: 2020 2020 2020 2062 7265 616b 0a20 2020         break.   
+0001f460: 2020 2020 2020 2020 2023 2043 616c 6c20           # Call 
+0001f470: 7468 6520 4d49 5020 706f 7374 2d73 6f6c  the MIP post-sol
+0001f480: 7665 2063 616c 6c62 6163 6b0a 2020 2020  ve callback.    
+0001f490: 2020 2020 2020 2020 7769 7468 2074 696d          with tim
+0001f4a0: 655f 636f 6465 2873 656c 662e 7469 6d69  e_code(self.timi
+0001f4b0: 6e67 2c20 2743 616c 6c20 6166 7465 7220  ng, 'Call after 
+0001f4c0: 6d61 696e 2073 6f6c 7665 2729 3a0a 2020  main solve'):.  
+0001f4d0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0001f4e0: 6e66 6967 2e63 616c 6c5f 6166 7465 725f  nfig.call_after_
+0001f4f0: 6d61 696e 5f73 6f6c 7665 286d 6169 6e5f  main_solve(main_
+0001f500: 6d69 7029 0a0a 2020 2020 2020 2020 2020  mip)..          
+0001f510: 2020 2320 5265 6775 6c61 7269 7a61 7469    # Regularizati
+0001f520: 6f6e 2069 7320 6163 7469 7661 7465 6420  on is activated 
+0001f530: 6166 7465 7220 7468 6520 6669 7273 7420  after the first 
+0001f540: 6665 6173 6962 6c65 2073 6f6c 7574 696f  feasible solutio
+0001f550: 6e20 6973 2066 6f75 6e64 2e0a 2020 2020  n is found..    
+0001f560: 2020 2020 2020 2020 6966 2063 6f6e 6669          if confi
+0001f570: 672e 6164 645f 7265 6775 6c61 7269 7a61  g.add_regulariza
+0001f580: 7469 6f6e 2069 7320 6e6f 7420 4e6f 6e65  tion is not None
+0001f590: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0001f5a0: 2020 6966 206e 6f74 2063 6f6e 6669 672e    if not config.
+0001f5b0: 7369 6e67 6c65 5f74 7265 653a 0a20 2020  single_tree:.   
+0001f5c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f5d0: 2073 656c 662e 6164 645f 7265 6775 6c61   self.add_regula
+0001f5e0: 7269 7a61 7469 6f6e 2829 0a0a 2020 2020  rization()..    
+0001f5f0: 2020 2020 2020 2020 2020 2020 2320 496e              # In
+0001f600: 2052 2d4c 502f 4e4c 502c 2077 6520 6d69   R-LP/NLP, we mi
+0001f610: 6768 7420 656e 6420 7570 2077 6974 6820  ght end up with 
+0001f620: 616e 2069 6e74 6567 6572 2063 6f6d 6269  an integer combi
+0001f630: 6e61 7469 6f6e 2074 6861 7420 6861 736e  nation that hasn
+0001f640: 2774 2062 6565 6e20 6578 706c 6f72 6564  't been explored
+0001f650: 2e0a 2020 2020 2020 2020 2020 2020 2020  ..              
+0001f660: 2020 2320 5468 6572 6566 6f72 652c 2077    # Therefore, w
+0001f670: 6520 6e65 6564 2074 6f20 736f 6c76 6520  e need to solve 
+0001f680: 6669 7865 6420 4e4c 5020 7375 6270 726f  fixed NLP subpro
+0001f690: 626c 656d 206f 6e65 206d 6f72 6520 7469  blem one more ti
+0001f6a0: 6d65 2e0a 2020 2020 2020 2020 2020 2020  me..            
+0001f6b0: 2020 2020 6966 2063 6f6e 6669 672e 7369      if config.si
+0001f6c0: 6e67 6c65 5f74 7265 653a 0a20 2020 2020  ngle_tree:.     
+0001f6d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+0001f6e0: 656c 662e 6375 7272 5f69 6e74 5f73 6f6c  elf.curr_int_sol
+0001f6f0: 203d 2067 6574 5f69 6e74 6567 6572 5f73   = get_integer_s
+0001f700: 6f6c 7574 696f 6e28 7365 6c66 2e6d 6970  olution(self.mip
+0001f710: 2c20 7374 7269 6e67 5f7a 6572 6f3d 5472  , string_zero=Tr
+0001f720: 7565 290a 2020 2020 2020 2020 2020 2020  ue).            
+0001f730: 2020 2020 2020 2020 636f 7079 5f76 6172          copy_var
+0001f740: 5f6c 6973 745f 7661 6c75 6573 280a 2020  _list_values(.  
+0001f750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f760: 2020 2020 2020 6d61 696e 5f6d 6970 2e4d        main_mip.M
+0001f770: 696e 6474 5079 5f75 7469 6c73 2e76 6172  indtPy_utils.var
+0001f780: 6961 626c 655f 6c69 7374 2c0a 2020 2020  iable_list,.    
+0001f790: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f7a0: 2020 2020 7365 6c66 2e66 6978 6564 5f6e      self.fixed_n
+0001f7b0: 6c70 2e4d 696e 6474 5079 5f75 7469 6c73  lp.MindtPy_utils
+0001f7c0: 2e76 6172 6961 626c 655f 6c69 7374 2c0a  .variable_list,.
+0001f7d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f7e0: 2020 2020 2020 2020 636f 6e66 6967 2c0a          config,.
+0001f7f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f800: 2020 2020 2020 2020 736b 6970 5f66 6978          skip_fix
+0001f810: 6564 3d46 616c 7365 2c0a 2020 2020 2020  ed=False,.      
+0001f820: 2020 2020 2020 2020 2020 2020 2020 290a                ).
 0001f830: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f840: 2020 2023 2043 616c 6c20 7468 6520 4e4c     # Call the NL
-0001f850: 5020 706f 7374 2d73 6f6c 7665 2063 616c  P post-solve cal
-0001f860: 6c62 6163 6b0a 2020 2020 2020 2020 2020  lback.          
-0001f870: 2020 2020 2020 2020 2020 7769 7468 2074            with t
-0001f880: 696d 655f 636f 6465 2873 656c 662e 7469  ime_code(self.ti
-0001f890: 6d69 6e67 2c20 2743 616c 6c20 6166 7465  ming, 'Call afte
-0001f8a0: 7220 7375 6270 726f 626c 656d 2073 6f6c  r subproblem sol
-0001f8b0: 7665 2729 3a0a 2020 2020 2020 2020 2020  ve'):.          
-0001f8c0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0001f8d0: 6e66 6967 2e63 616c 6c5f 6166 7465 725f  nfig.call_after_
-0001f8e0: 7375 6270 726f 626c 656d 5f73 6f6c 7665  subproblem_solve
-0001f8f0: 2866 6978 6564 5f6e 6c70 290a 0a20 2020  (fixed_nlp)..   
-0001f900: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f910: 2069 6620 7365 6c66 2e61 6c67 6f72 6974   if self.algorit
-0001f920: 686d 5f73 686f 756c 645f 7465 726d 696e  hm_should_termin
-0001f930: 6174 6528 6368 6563 6b5f 6379 636c 696e  ate(check_cyclin
-0001f940: 673d 4661 6c73 6529 3a0a 2020 2020 2020  g=False):.      
-0001f950: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f960: 2020 7365 6c66 2e6c 6173 745f 6974 6572    self.last_iter
-0001f970: 5f63 7574 7320 3d20 5472 7565 0a20 2020  _cuts = True.   
-0001f980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001f990: 2020 2020 2062 7265 616b 0a20 2020 2020       break.     
-0001f9a0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-0001f9b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001f9c0: 2020 2020 2073 6f6c 7574 696f 6e5f 6e61       solution_na
-0001f9d0: 6d65 5f6f 626a 203d 2073 656c 662e 6765  me_obj = self.ge
-0001f9e0: 745f 736f 6c75 7469 6f6e 5f6e 616d 655f  t_solution_name_
-0001f9f0: 6f62 6a28 6d61 696e 5f6d 6970 5f72 6573  obj(main_mip_res
-0001fa00: 756c 7473 290a 2020 2020 2020 2020 2020  ults).          
-0001fa10: 2020 2020 2020 2020 2020 666f 7220 696e            for in
-0001fa20: 6465 782c 2028 6e61 6d65 2c20 5f29 2069  dex, (name, _) i
-0001fa30: 6e20 656e 756d 6572 6174 6528 736f 6c75  n enumerate(solu
-0001fa40: 7469 6f6e 5f6e 616d 655f 6f62 6a29 3a0a  tion_name_obj):.
-0001fa50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fa60: 2020 2020 2020 2020 2320 7468 6520 6f70          # the op
-0001fa70: 7469 6d61 6c20 736f 6c75 7469 6f6e 206f  timal solution o
-0001fa80: 6620 7468 6520 6d61 696e 2070 726f 626c  f the main probl
-0001fa90: 656d 2068 6173 2062 6565 6e20 6164 6465  em has been adde
-0001faa0: 6420 746f 2069 6e74 6567 6572 5f6c 6973  d to integer_lis
-0001fab0: 7420 6162 6f76 650a 2020 2020 2020 2020  t above.        
-0001fac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fad0: 2320 736f 2077 6520 7368 6f75 6c64 2073  # so we should s
-0001fae0: 6b69 7020 6368 6563 6b69 6e67 2063 7963  kip checking cyc
-0001faf0: 6c69 6e67 2066 6f72 2074 6865 2066 6972  ling for the fir
-0001fb00: 7374 2073 6f6c 7574 696f 6e20 696e 2074  st solution in t
-0001fb10: 6865 2073 6f6c 7574 696f 6e20 706f 6f6c  he solution pool
-0001fb20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001fb30: 2020 2020 2020 2020 2069 6620 696e 6465           if inde
-0001fb40: 7820 3e20 303a 0a20 2020 2020 2020 2020  x > 0:.         
-0001fb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fb60: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
-0001fb70: 5f76 616c 7565 735f 6672 6f6d 5f73 6f6c  _values_from_sol
-0001fb80: 7574 696f 6e5f 706f 6f6c 280a 2020 2020  ution_pool(.    
-0001fb90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fba0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-0001fbb0: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
-0001fbc0: 6c73 2e76 6172 6961 626c 655f 6c69 7374  ls.variable_list
-0001fbd0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0001fbe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fbf0: 2020 7365 6c66 2e66 6978 6564 5f6e 6c70    self.fixed_nlp
-0001fc00: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
-0001fc10: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
-0001fc20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fc30: 2020 2020 2020 2020 2020 2020 2020 636f                co
-0001fc40: 6e66 6967 2c0a 2020 2020 2020 2020 2020  nfig,.          
-0001fc50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fc60: 2020 2020 2020 736f 6c76 6572 5f6d 6f64        solver_mod
-0001fc70: 656c 3d6d 6169 6e5f 6d69 705f 7265 7375  el=main_mip_resu
-0001fc80: 6c74 732e 5f73 6f6c 7665 725f 6d6f 6465  lts._solver_mode
-0001fc90: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
-0001fca0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fcb0: 2020 2076 6172 5f6d 6170 3d6d 6169 6e5f     var_map=main_
-0001fcc0: 6d69 705f 7265 7375 6c74 732e 5f70 796f  mip_results._pyo
-0001fcd0: 6d6f 5f76 6172 5f74 6f5f 736f 6c76 6572  mo_var_to_solver
-0001fce0: 5f76 6172 5f6d 6170 2c0a 2020 2020 2020  _var_map,.      
-0001fcf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd00: 2020 2020 2020 2020 2020 736f 6c75 7469            soluti
-0001fd10: 6f6e 5f6e 616d 653d 6e61 6d65 2c0a 2020  on_name=name,.  
-0001fd20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd30: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-0001fd40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fd50: 2020 2020 2020 2020 7365 6c66 2e63 7572          self.cur
-0001fd60: 725f 696e 745f 736f 6c20 3d20 6765 745f  r_int_sol = get_
-0001fd70: 696e 7465 6765 725f 736f 6c75 7469 6f6e  integer_solution
-0001fd80: 2873 656c 662e 6669 7865 645f 6e6c 7029  (self.fixed_nlp)
-0001fd90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001fda0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0001fdb0: 7365 6c66 2e63 7572 725f 696e 745f 736f  self.curr_int_so
-0001fdc0: 6c20 696e 2073 6574 2873 656c 662e 696e  l in set(self.in
-0001fdd0: 7465 6765 725f 6c69 7374 293a 0a20 2020  teger_list):.   
-0001fde0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fdf0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-0001fe00: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
-0001fe10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001fe20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fe30: 2020 2020 2027 5468 6520 7361 6d65 2063       'The same c
-0001fe40: 6f6d 6269 6e61 7469 6f6e 2068 6173 2062  ombination has b
-0001fe50: 6565 6e20 6578 706c 6f72 6564 2061 6e64  een explored and
-0001fe60: 2077 696c 6c20 6265 2073 6b69 7070 6564   will be skipped
-0001fe70: 2068 6572 652e 270a 2020 2020 2020 2020   here.'.        
-0001fe80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001fe90: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-0001fea0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001feb0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-0001fec0: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
-0001fed0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
-0001fee0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001fef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ff00: 2020 2020 2073 656c 662e 696e 7465 6765       self.intege
-0001ff10: 725f 6c69 7374 2e61 7070 656e 6428 7365  r_list.append(se
-0001ff20: 6c66 2e63 7572 725f 696e 745f 736f 6c29  lf.curr_int_sol)
-0001ff30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0001ff40: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
-0001ff50: 6c70 2c20 6669 7865 645f 6e6c 705f 7265  lp, fixed_nlp_re
-0001ff60: 7375 6c74 203d 2073 656c 662e 736f 6c76  sult = self.solv
-0001ff70: 655f 7375 6270 726f 626c 656d 2829 0a20  e_subproblem(). 
-0001ff80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001ff90: 2020 2020 2020 2073 656c 662e 6861 6e64         self.hand
-0001ffa0: 6c65 5f6e 6c70 5f73 7562 7072 6f62 6c65  le_nlp_subproble
-0001ffb0: 6d5f 7463 2866 6978 6564 5f6e 6c70 2c20  m_tc(fixed_nlp, 
-0001ffc0: 6669 7865 645f 6e6c 705f 7265 7375 6c74  fixed_nlp_result
-0001ffd0: 290a 0a20 2020 2020 2020 2020 2020 2020  )..             
-0001ffe0: 2020 2020 2020 2020 2020 2023 2043 616c             # Cal
-0001fff0: 6c20 7468 6520 4e4c 5020 706f 7374 2d73  l the NLP post-s
-00020000: 6f6c 7665 2063 616c 6c62 6163 6b0a 2020  olve callback.  
-00020010: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020020: 2020 2020 2020 7769 7468 2074 696d 655f        with time_
-00020030: 636f 6465 2873 656c 662e 7469 6d69 6e67  code(self.timing
-00020040: 2c20 2743 616c 6c20 6166 7465 7220 7375  , 'Call after su
-00020050: 6270 726f 626c 656d 2073 6f6c 7665 2729  bproblem solve')
-00020060: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00020070: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00020080: 6e66 6967 2e63 616c 6c5f 6166 7465 725f  nfig.call_after_
-00020090: 7375 6270 726f 626c 656d 5f73 6f6c 7665  subproblem_solve
-000200a0: 2866 6978 6564 5f6e 6c70 290a 0a20 2020  (fixed_nlp)..   
-000200b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000200c0: 2020 2020 2069 6620 7365 6c66 2e61 6c67       if self.alg
-000200d0: 6f72 6974 686d 5f73 686f 756c 645f 7465  orithm_should_te
-000200e0: 726d 696e 6174 6528 6368 6563 6b5f 6379  rminate(check_cy
-000200f0: 636c 696e 673d 4661 6c73 6529 3a0a 2020  cling=False):.  
+0001f840: 2020 2020 6966 2073 656c 662e 6375 7272      if self.curr
+0001f850: 5f69 6e74 5f73 6f6c 206e 6f74 2069 6e20  _int_sol not in 
+0001f860: 7365 7428 7365 6c66 2e69 6e74 6567 6572  set(self.integer
+0001f870: 5f6c 6973 7429 3a0a 2020 2020 2020 2020  _list):.        
+0001f880: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f890: 2320 4361 6c6c 2074 6865 204e 4c50 2070  # Call the NLP p
+0001f8a0: 7265 2d73 6f6c 7665 2063 616c 6c62 6163  re-solve callbac
+0001f8b0: 6b0a 2020 2020 2020 2020 2020 2020 2020  k.              
+0001f8c0: 2020 2020 2020 2020 2020 7769 7468 2074            with t
+0001f8d0: 696d 655f 636f 6465 2873 656c 662e 7469  ime_code(self.ti
+0001f8e0: 6d69 6e67 2c20 2743 616c 6c20 6265 666f  ming, 'Call befo
+0001f8f0: 7265 2073 7562 7072 6f62 6c65 6d20 736f  re subproblem so
+0001f900: 6c76 6527 293a 0a20 2020 2020 2020 2020  lve'):.         
+0001f910: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f920: 2020 2063 6f6e 6669 672e 6361 6c6c 5f62     config.call_b
+0001f930: 6566 6f72 655f 7375 6270 726f 626c 656d  efore_subproblem
+0001f940: 5f73 6f6c 7665 2873 656c 662e 6669 7865  _solve(self.fixe
+0001f950: 645f 6e6c 7029 0a0a 2020 2020 2020 2020  d_nlp)..        
+0001f960: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001f970: 6669 7865 645f 6e6c 702c 2066 6978 6564  fixed_nlp, fixed
+0001f980: 5f6e 6c70 5f72 6573 756c 7420 3d20 7365  _nlp_result = se
+0001f990: 6c66 2e73 6f6c 7665 5f73 7562 7072 6f62  lf.solve_subprob
+0001f9a0: 6c65 6d28 290a 2020 2020 2020 2020 2020  lem().          
+0001f9b0: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001f9c0: 6c66 2e68 616e 646c 655f 6e6c 705f 7375  lf.handle_nlp_su
+0001f9d0: 6270 726f 626c 656d 5f74 6328 6669 7865  bproblem_tc(fixe
+0001f9e0: 645f 6e6c 702c 2066 6978 6564 5f6e 6c70  d_nlp, fixed_nlp
+0001f9f0: 5f72 6573 756c 7429 0a0a 2020 2020 2020  _result)..      
+0001fa00: 2020 2020 2020 6966 2073 656c 662e 616c        if self.al
+0001fa10: 676f 7269 7468 6d5f 7368 6f75 6c64 5f74  gorithm_should_t
+0001fa20: 6572 6d69 6e61 7465 2863 6865 636b 5f63  erminate(check_c
+0001fa30: 7963 6c69 6e67 3d54 7275 6529 3a0a 2020  ycling=True):.  
+0001fa40: 2020 2020 2020 2020 2020 2020 2020 7365                se
+0001fa50: 6c66 2e6c 6173 745f 6974 6572 5f63 7574  lf.last_iter_cut
+0001fa60: 7320 3d20 4661 6c73 650a 2020 2020 2020  s = False.      
+0001fa70: 2020 2020 2020 2020 2020 6272 6561 6b0a            break.
+0001fa80: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0001fa90: 6e6f 7420 636f 6e66 6967 2e73 696e 676c  not config.singl
+0001faa0: 655f 7472 6565 3a20 2023 2069 6620 7765  e_tree:  # if we
+0001fab0: 2064 6f6e 2774 2075 7365 206c 617a 7920   don't use lazy 
+0001fac0: 6361 6c6c 6261 636b 2c20 692e 652e 204c  callback, i.e. L
+0001fad0: 505f 4e4c 500a 2020 2020 2020 2020 2020  P_NLP.          
+0001fae0: 2020 2020 2020 2320 536f 6c76 6520 4e4c        # Solve NL
+0001faf0: 5020 7375 6270 726f 626c 656d 0a20 2020  P subproblem.   
+0001fb00: 2020 2020 2020 2020 2020 2020 2023 2054               # T
+0001fb10: 6865 2063 6f6e 7374 7261 696e 7420 6c69  he constraint li
+0001fb20: 6e65 6172 697a 6174 696f 6e20 6861 7070  nearization happ
+0001fb30: 656e 7320 696e 2074 6865 2068 616e 646c  ens in the handl
+0001fb40: 6572 730a 2020 2020 2020 2020 2020 2020  ers.            
+0001fb50: 2020 2020 6966 206e 6f74 2063 6f6e 6669      if not confi
+0001fb60: 672e 736f 6c75 7469 6f6e 5f70 6f6f 6c3a  g.solution_pool:
+0001fb70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001fb80: 2020 2020 2023 2043 616c 6c20 7468 6520       # Call the 
+0001fb90: 4e4c 5020 7072 652d 736f 6c76 6520 6361  NLP pre-solve ca
+0001fba0: 6c6c 6261 636b 0a20 2020 2020 2020 2020  llback.         
+0001fbb0: 2020 2020 2020 2020 2020 2077 6974 6820             with 
+0001fbc0: 7469 6d65 5f63 6f64 6528 7365 6c66 2e74  time_code(self.t
+0001fbd0: 696d 696e 672c 2027 4361 6c6c 2062 6566  iming, 'Call bef
+0001fbe0: 6f72 6520 7375 6270 726f 626c 656d 2073  ore subproblem s
+0001fbf0: 6f6c 7665 2729 3a0a 2020 2020 2020 2020  olve'):.        
+0001fc00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fc10: 636f 6e66 6967 2e63 616c 6c5f 6265 666f  config.call_befo
+0001fc20: 7265 5f73 7562 7072 6f62 6c65 6d5f 736f  re_subproblem_so
+0001fc30: 6c76 6528 7365 6c66 2e66 6978 6564 5f6e  lve(self.fixed_n
+0001fc40: 6c70 290a 0a20 2020 2020 2020 2020 2020  lp)..           
+0001fc50: 2020 2020 2020 2020 2066 6978 6564 5f6e           fixed_n
+0001fc60: 6c70 2c20 6669 7865 645f 6e6c 705f 7265  lp, fixed_nlp_re
+0001fc70: 7375 6c74 203d 2073 656c 662e 736f 6c76  sult = self.solv
+0001fc80: 655f 7375 6270 726f 626c 656d 2829 0a20  e_subproblem(). 
+0001fc90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fca0: 2020 2073 656c 662e 6861 6e64 6c65 5f6e     self.handle_n
+0001fcb0: 6c70 5f73 7562 7072 6f62 6c65 6d5f 7463  lp_subproblem_tc
+0001fcc0: 2866 6978 6564 5f6e 6c70 2c20 6669 7865  (fixed_nlp, fixe
+0001fcd0: 645f 6e6c 705f 7265 7375 6c74 290a 0a20  d_nlp_result).. 
+0001fce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fcf0: 2020 2023 2043 616c 6c20 7468 6520 4e4c     # Call the NL
+0001fd00: 5020 706f 7374 2d73 6f6c 7665 2063 616c  P post-solve cal
+0001fd10: 6c62 6163 6b0a 2020 2020 2020 2020 2020  lback.          
+0001fd20: 2020 2020 2020 2020 2020 7769 7468 2074            with t
+0001fd30: 696d 655f 636f 6465 2873 656c 662e 7469  ime_code(self.ti
+0001fd40: 6d69 6e67 2c20 2743 616c 6c20 6166 7465  ming, 'Call afte
+0001fd50: 7220 7375 6270 726f 626c 656d 2073 6f6c  r subproblem sol
+0001fd60: 7665 2729 3a0a 2020 2020 2020 2020 2020  ve'):.          
+0001fd70: 2020 2020 2020 2020 2020 2020 2020 636f                co
+0001fd80: 6e66 6967 2e63 616c 6c5f 6166 7465 725f  nfig.call_after_
+0001fd90: 7375 6270 726f 626c 656d 5f73 6f6c 7665  subproblem_solve
+0001fda0: 2866 6978 6564 5f6e 6c70 290a 0a20 2020  (fixed_nlp)..   
+0001fdb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fdc0: 2069 6620 7365 6c66 2e61 6c67 6f72 6974   if self.algorit
+0001fdd0: 686d 5f73 686f 756c 645f 7465 726d 696e  hm_should_termin
+0001fde0: 6174 6528 6368 6563 6b5f 6379 636c 696e  ate(check_cyclin
+0001fdf0: 673d 4661 6c73 6529 3a0a 2020 2020 2020  g=False):.      
+0001fe00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fe10: 2020 7365 6c66 2e6c 6173 745f 6974 6572    self.last_iter
+0001fe20: 5f63 7574 7320 3d20 5472 7565 0a20 2020  _cuts = True.   
+0001fe30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001fe40: 2020 2020 2062 7265 616b 0a20 2020 2020       break.     
+0001fe50: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0001fe60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001fe70: 2020 2020 2073 6f6c 7574 696f 6e5f 6e61       solution_na
+0001fe80: 6d65 5f6f 626a 203d 2073 656c 662e 6765  me_obj = self.ge
+0001fe90: 745f 736f 6c75 7469 6f6e 5f6e 616d 655f  t_solution_name_
+0001fea0: 6f62 6a28 6d61 696e 5f6d 6970 5f72 6573  obj(main_mip_res
+0001feb0: 756c 7473 290a 2020 2020 2020 2020 2020  ults).          
+0001fec0: 2020 2020 2020 2020 2020 666f 7220 696e            for in
+0001fed0: 6465 782c 2028 6e61 6d65 2c20 5f29 2069  dex, (name, _) i
+0001fee0: 6e20 656e 756d 6572 6174 6528 736f 6c75  n enumerate(solu
+0001fef0: 7469 6f6e 5f6e 616d 655f 6f62 6a29 3a0a  tion_name_obj):.
+0001ff00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ff10: 2020 2020 2020 2020 2320 7468 6520 6f70          # the op
+0001ff20: 7469 6d61 6c20 736f 6c75 7469 6f6e 206f  timal solution o
+0001ff30: 6620 7468 6520 6d61 696e 2070 726f 626c  f the main probl
+0001ff40: 656d 2068 6173 2062 6565 6e20 6164 6465  em has been adde
+0001ff50: 6420 746f 2069 6e74 6567 6572 5f6c 6973  d to integer_lis
+0001ff60: 7420 6162 6f76 650a 2020 2020 2020 2020  t above.        
+0001ff70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ff80: 2320 736f 2077 6520 7368 6f75 6c64 2073  # so we should s
+0001ff90: 6b69 7020 6368 6563 6b69 6e67 2063 7963  kip checking cyc
+0001ffa0: 6c69 6e67 2066 6f72 2074 6865 2066 6972  ling for the fir
+0001ffb0: 7374 2073 6f6c 7574 696f 6e20 696e 2074  st solution in t
+0001ffc0: 6865 2073 6f6c 7574 696f 6e20 706f 6f6c  he solution pool
+0001ffd0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001ffe0: 2020 2020 2020 2020 2069 6620 696e 6465           if inde
+0001fff0: 7820 3e20 303a 0a20 2020 2020 2020 2020  x > 0:.         
+00020000: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020010: 2020 2063 6f70 795f 7661 725f 6c69 7374     copy_var_list
+00020020: 5f76 616c 7565 735f 6672 6f6d 5f73 6f6c  _values_from_sol
+00020030: 7574 696f 6e5f 706f 6f6c 280a 2020 2020  ution_pool(.    
+00020040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020050: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00020060: 2e6d 6970 2e4d 696e 6474 5079 5f75 7469  .mip.MindtPy_uti
+00020070: 6c73 2e76 6172 6961 626c 655f 6c69 7374  ls.variable_list
+00020080: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00020090: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000200a0: 2020 7365 6c66 2e66 6978 6564 5f6e 6c70    self.fixed_nlp
+000200b0: 2e4d 696e 6474 5079 5f75 7469 6c73 2e76  .MindtPy_utils.v
+000200c0: 6172 6961 626c 655f 6c69 7374 2c0a 2020  ariable_list,.  
+000200d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000200e0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+000200f0: 6e66 6967 2c0a 2020 2020 2020 2020 2020  nfig,.          
 00020100: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020110: 2020 2020 2020 2020 2020 7365 6c66 2e6c            self.l
-00020120: 6173 745f 6974 6572 5f63 7574 7320 3d20  ast_iter_cuts = 
-00020130: 5472 7565 0a20 2020 2020 2020 2020 2020  True.           
-00020140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020150: 2062 7265 616b 2020 2320 544f 444f 3a20   break  # TODO: 
-00020160: 6272 6561 6b20 7477 6f20 6c6f 6f70 732e  break two loops.
-00020170: 0a0a 2020 2020 2020 2020 2320 6966 2061  ..        # if a
-00020180: 6464 5f6e 6f5f 676f 6f64 5f63 7574 7320  dd_no_good_cuts 
-00020190: 6973 2054 7275 652c 2074 6865 2062 6f75  is True, the bou
-000201a0: 6e64 206f 6274 6169 6e65 6420 696e 2074  nd obtained in t
-000201b0: 6865 206c 6173 7420 6974 6572 6174 696f  he last iteratio
-000201c0: 6e20 6973 206e 6f20 7265 6c69 6162 6c65  n is no reliable
-000201d0: 2e0a 2020 2020 2020 2020 2320 7765 2063  ..        # we c
-000201e0: 6f72 7265 6374 2069 7420 6166 7465 7220  orrect it after 
-000201f0: 7468 6520 6974 6572 6174 696f 6e2e 0a20  the iteration.. 
-00020200: 2020 2020 2020 2023 2054 6865 7265 2069         # There i
-00020210: 7320 6e6f 206e 6565 6420 746f 2066 6978  s no need to fix
-00020220: 2074 6865 2064 7561 6c20 626f 756e 6420   the dual bound 
-00020230: 6966 206e 6f20 6665 6173 6962 6c65 2073  if no feasible s
-00020240: 6f6c 7574 696f 6e20 6861 7320 6265 656e  olution has been
-00020250: 2066 6f75 6e64 2e0a 2020 2020 2020 2020   found..        
-00020260: 6966 2028 0a20 2020 2020 2020 2020 2020  if (.           
-00020270: 2028 636f 6e66 6967 2e61 6464 5f6e 6f5f   (config.add_no_
-00020280: 676f 6f64 5f63 7574 7320 6f72 2063 6f6e  good_cuts or con
-00020290: 6669 672e 7573 655f 7461 6275 5f6c 6973  fig.use_tabu_lis
-000202a0: 7429 0a20 2020 2020 2020 2020 2020 2061  t).            a
-000202b0: 6e64 206e 6f74 2073 656c 662e 7368 6f75  nd not self.shou
-000202c0: 6c64 5f74 6572 6d69 6e61 7465 0a20 2020  ld_terminate.   
-000202d0: 2020 2020 2020 2020 2061 6e64 2063 6f6e           and con
-000202e0: 6669 672e 6164 645f 7265 6775 6c61 7269  fig.add_regulari
-000202f0: 7a61 7469 6f6e 2069 7320 4e6f 6e65 0a20  zation is None. 
-00020300: 2020 2020 2020 2020 2020 2061 6e64 2073             and s
-00020310: 656c 662e 6265 7374 5f73 6f6c 7574 696f  elf.best_solutio
-00020320: 6e5f 666f 756e 6420 6973 206e 6f74 204e  n_found is not N
-00020330: 6f6e 650a 2020 2020 2020 2020 293a 0a20  one.        ):. 
-00020340: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00020350: 6669 785f 6475 616c 5f62 6f75 6e64 2873  fix_dual_bound(s
-00020360: 656c 662e 6c61 7374 5f69 7465 725f 6375  elf.last_iter_cu
-00020370: 7473 290a 2020 2020 2020 2020 636f 6e66  ts).        conf
-00020380: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-00020390: 2020 2020 2020 2020 2020 2020 2720 3d3d              ' ==
-000203a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000203b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000203c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000203d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000203e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000203f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d27 0a20  ============='. 
-00020400: 2020 2020 2020 2029 0a0a 2020 2020 6465         )..    de
-00020410: 6620 6765 745f 736f 6c75 7469 6f6e 5f6e  f get_solution_n
-00020420: 616d 655f 6f62 6a28 7365 6c66 2c20 6d61  ame_obj(self, ma
-00020430: 696e 5f6d 6970 5f72 6573 756c 7473 293a  in_mip_results):
-00020440: 0a20 2020 2020 2020 2069 6620 7365 6c66  .        if self
-00020450: 2e63 6f6e 6669 672e 6d69 705f 736f 6c76  .config.mip_solv
-00020460: 6572 203d 3d20 2763 706c 6578 5f70 6572  er == 'cplex_per
-00020470: 7369 7374 656e 7427 3a0a 2020 2020 2020  sistent':.      
-00020480: 2020 2020 2020 736f 6c75 7469 6f6e 5f70        solution_p
-00020490: 6f6f 6c5f 6e61 6d65 7320 3d20 280a 2020  ool_names = (.  
-000204a0: 2020 2020 2020 2020 2020 2020 2020 6d61                ma
-000204b0: 696e 5f6d 6970 5f72 6573 756c 7473 2e5f  in_mip_results._
-000204c0: 736f 6c76 6572 5f6d 6f64 656c 2e73 6f6c  solver_model.sol
-000204d0: 7574 696f 6e2e 706f 6f6c 2e67 6574 5f6e  ution.pool.get_n
-000204e0: 616d 6573 2829 0a20 2020 2020 2020 2020  ames().         
-000204f0: 2020 2029 0a20 2020 2020 2020 2065 6c69     ).        eli
-00020500: 6620 7365 6c66 2e63 6f6e 6669 672e 6d69  f self.config.mi
-00020510: 705f 736f 6c76 6572 203d 3d20 2767 7572  p_solver == 'gur
-00020520: 6f62 695f 7065 7273 6973 7465 6e74 273a  obi_persistent':
-00020530: 0a20 2020 2020 2020 2020 2020 2073 6f6c  .            sol
-00020540: 7574 696f 6e5f 706f 6f6c 5f6e 616d 6573  ution_pool_names
-00020550: 203d 206c 6973 7428 7261 6e67 6528 6d61   = list(range(ma
-00020560: 696e 5f6d 6970 5f72 6573 756c 7473 2e5f  in_mip_results._
-00020570: 736f 6c76 6572 5f6d 6f64 656c 2e53 6f6c  solver_model.Sol
-00020580: 436f 756e 7429 290a 2020 2020 2020 2020  Count)).        
-00020590: 2320 6c69 7374 2074 6f20 7374 6f72 6520  # list to store 
-000205a0: 7468 6520 6e61 6d65 2061 6e64 206f 626a  the name and obj
-000205b0: 6563 7469 7665 2076 616c 7565 206f 6620  ective value of 
-000205c0: 7468 6520 736f 6c75 7469 6f6e 7320 696e  the solutions in
-000205d0: 2074 6865 2073 6f6c 7574 696f 6e20 706f   the solution po
-000205e0: 6f6c 0a20 2020 2020 2020 2073 6f6c 7574  ol.        solut
-000205f0: 696f 6e5f 6e61 6d65 5f6f 626a 203d 205b  ion_name_obj = [
-00020600: 5d0a 2020 2020 2020 2020 666f 7220 6e61  ].        for na
-00020610: 6d65 2069 6e20 736f 6c75 7469 6f6e 5f70  me in solution_p
-00020620: 6f6f 6c5f 6e61 6d65 733a 0a20 2020 2020  ool_names:.     
-00020630: 2020 2020 2020 2069 6620 7365 6c66 2e63         if self.c
-00020640: 6f6e 6669 672e 6d69 705f 736f 6c76 6572  onfig.mip_solver
-00020650: 203d 3d20 2763 706c 6578 5f70 6572 7369   == 'cplex_persi
-00020660: 7374 656e 7427 3a0a 2020 2020 2020 2020  stent':.        
-00020670: 2020 2020 2020 2020 6f62 6a20 3d20 6d61          obj = ma
-00020680: 696e 5f6d 6970 5f72 6573 756c 7473 2e5f  in_mip_results._
-00020690: 736f 6c76 6572 5f6d 6f64 656c 2e73 6f6c  solver_model.sol
-000206a0: 7574 696f 6e2e 706f 6f6c 2e67 6574 5f6f  ution.pool.get_o
-000206b0: 626a 6563 7469 7665 5f76 616c 7565 280a  bjective_value(.
-000206c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000206d0: 2020 2020 6e61 6d65 0a20 2020 2020 2020      name.       
-000206e0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
-000206f0: 2020 2020 2020 2065 6c69 6620 7365 6c66         elif self
-00020700: 2e63 6f6e 6669 672e 6d69 705f 736f 6c76  .config.mip_solv
-00020710: 6572 203d 3d20 2767 7572 6f62 695f 7065  er == 'gurobi_pe
-00020720: 7273 6973 7465 6e74 273a 0a20 2020 2020  rsistent':.     
-00020730: 2020 2020 2020 2020 2020 206d 6169 6e5f             main_
-00020740: 6d69 705f 7265 7375 6c74 732e 5f73 6f6c  mip_results._sol
-00020750: 7665 725f 6d6f 6465 6c2e 7365 7450 6172  ver_model.setPar
-00020760: 616d 280a 2020 2020 2020 2020 2020 2020  am(.            
-00020770: 2020 2020 2020 2020 6775 726f 6269 7079          gurobipy
-00020780: 2e47 5242 2e50 6172 616d 2e53 6f6c 7574  .GRB.Param.Solut
-00020790: 696f 6e4e 756d 6265 722c 206e 616d 650a  ionNumber, name.
-000207a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000207b0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000207c0: 2020 6f62 6a20 3d20 6d61 696e 5f6d 6970    obj = main_mip
-000207d0: 5f72 6573 756c 7473 2e5f 736f 6c76 6572  _results._solver
-000207e0: 5f6d 6f64 656c 2e50 6f6f 6c4f 626a 5661  _model.PoolObjVa
-000207f0: 6c0a 2020 2020 2020 2020 2020 2020 736f  l.            so
-00020800: 6c75 7469 6f6e 5f6e 616d 655f 6f62 6a2e  lution_name_obj.
-00020810: 6170 7065 6e64 285b 6e61 6d65 2c20 6f62  append([name, ob
-00020820: 6a5d 290a 2020 2020 2020 2020 736f 6c75  j]).        solu
-00020830: 7469 6f6e 5f6e 616d 655f 6f62 6a2e 736f  tion_name_obj.so
-00020840: 7274 280a 2020 2020 2020 2020 2020 2020  rt(.            
-00020850: 6b65 793d 6974 656d 6765 7474 6572 2831  key=itemgetter(1
-00020860: 292c 2072 6576 6572 7365 3d73 656c 662e  ), reverse=self.
-00020870: 6f62 6a65 6374 6976 655f 7365 6e73 6520  objective_sense 
-00020880: 3d3d 206d 6178 696d 697a 650a 2020 2020  == maximize.    
-00020890: 2020 2020 290a 2020 2020 2020 2020 736f      ).        so
-000208a0: 6c75 7469 6f6e 5f6e 616d 655f 6f62 6a20  lution_name_obj 
-000208b0: 3d20 736f 6c75 7469 6f6e 5f6e 616d 655f  = solution_name_
-000208c0: 6f62 6a5b 3a20 7365 6c66 2e63 6f6e 6669  obj[: self.confi
-000208d0: 672e 6e75 6d5f 736f 6c75 7469 6f6e 5f69  g.num_solution_i
-000208e0: 7465 7261 7469 6f6e 5d0a 2020 2020 2020  teration].      
-000208f0: 2020 7265 7475 726e 2073 6f6c 7574 696f    return solutio
-00020900: 6e5f 6e61 6d65 5f6f 626a 0a0a 2020 2020  n_name_obj..    
-00020910: 6465 6620 6164 645f 7265 6775 6c61 7269  def add_regulari
-00020920: 7a61 7469 6f6e 2873 656c 6629 3a0a 2020  zation(self):.  
-00020930: 2020 2020 2020 6966 2073 656c 662e 6265        if self.be
-00020940: 7374 5f73 6f6c 7574 696f 6e5f 666f 756e  st_solution_foun
-00020950: 6420 6973 206e 6f74 204e 6f6e 653a 0a20  d is not None:. 
-00020960: 2020 2020 2020 2020 2020 2023 2054 6865             # The
-00020970: 206d 6169 6e20 7072 6f62 6c65 6d20 6d69   main problem mi
-00020980: 6768 7420 6265 2075 6e62 6f75 6e64 6564  ght be unbounded
-00020990: 2c20 7265 6775 6c61 7269 7a61 7469 6f6e  , regularization
-000209a0: 2069 7320 6163 7469 7661 7465 6420 6f6e   is activated on
-000209b0: 6c79 2077 6865 6e20 6120 7661 6c69 6420  ly when a valid 
-000209c0: 626f 756e 6420 6973 2070 726f 7669 6465  bound is provide
-000209d0: 642e 0a20 2020 2020 2020 2020 2020 2069  d..            i
-000209e0: 6620 7365 6c66 2e64 7561 6c5f 626f 756e  f self.dual_boun
-000209f0: 6420 213d 2073 656c 662e 6475 616c 5f62  d != self.dual_b
-00020a00: 6f75 6e64 5f70 726f 6772 6573 735b 305d  ound_progress[0]
-00020a10: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00020a20: 2020 7769 7468 2074 696d 655f 636f 6465    with time_code
-00020a30: 2873 656c 662e 7469 6d69 6e67 2c20 2772  (self.timing, 'r
-00020a40: 6567 756c 6172 697a 6174 696f 6e20 6d61  egularization ma
-00020a50: 696e 2729 3a0a 2020 2020 2020 2020 2020  in'):.          
-00020a60: 2020 2020 2020 2020 2020 2872 6567 756c            (regul
-00020a70: 6172 697a 6174 696f 6e5f 6d61 696e 5f6d  arization_main_m
-00020a80: 6970 2c20 7265 6775 6c61 7269 7a61 7469  ip, regularizati
-00020a90: 6f6e 5f6d 6169 6e5f 6d69 705f 7265 7375  on_main_mip_resu
-00020aa0: 6c74 7329 203d 2028 0a20 2020 2020 2020  lts) = (.       
-00020ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020ac0: 2073 656c 662e 736f 6c76 655f 7265 6775   self.solve_regu
-00020ad0: 6c61 7269 7a61 7469 6f6e 5f6d 6169 6e28  larization_main(
-00020ae0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00020af0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00020b00: 2020 2020 2020 2020 7365 6c66 2e68 616e          self.han
-00020b10: 646c 655f 7265 6775 6c61 7269 7a61 7469  dle_regularizati
-00020b20: 6f6e 5f6d 6169 6e5f 7463 280a 2020 2020  on_main_tc(.    
-00020b30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020b40: 7265 6775 6c61 7269 7a61 7469 6f6e 5f6d  regularization_m
-00020b50: 6169 6e5f 6d69 702c 2072 6567 756c 6172  ain_mip, regular
-00020b60: 697a 6174 696f 6e5f 6d61 696e 5f6d 6970  ization_main_mip
-00020b70: 5f72 6573 756c 7473 0a20 2020 2020 2020  _results.       
-00020b80: 2020 2020 2020 2020 2029 0a0a 2020 2020           )..    
-00020b90: 6465 6620 626f 756e 6473 5f63 6f6e 7665  def bounds_conve
-00020ba0: 7267 6564 2873 656c 6629 3a0a 2020 2020  rged(self):.    
-00020bb0: 2020 2020 2320 4368 6563 6b20 626f 756e      # Check boun
-00020bc0: 6420 636f 6e76 6572 6765 6e63 650a 2020  d convergence.  
-00020bd0: 2020 2020 2020 6966 2073 656c 662e 6162        if self.ab
-00020be0: 735f 6761 7020 3c3d 2073 656c 662e 636f  s_gap <= self.co
-00020bf0: 6e66 6967 2e61 6273 6f6c 7574 655f 626f  nfig.absolute_bo
-00020c00: 756e 645f 746f 6c65 7261 6e63 653a 0a20  und_tolerance:. 
-00020c10: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00020c20: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
-00020c30: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
-00020c40: 2020 2020 274d 696e 6474 5079 2065 7869      'MindtPy exi
-00020c50: 7469 6e67 206f 6e20 626f 756e 6420 636f  ting on bound co
-00020c60: 6e76 6572 6765 6e63 652e 2027 0a20 2020  nvergence. '.   
-00020c70: 2020 2020 2020 2020 2020 2020 2027 4162               'Ab
-00020c80: 736f 6c75 7465 2067 6170 3a20 7b7d 203c  solute gap: {} <
-00020c90: 3d20 6162 736f 6c75 7465 2074 6f6c 6572  = absolute toler
-00020ca0: 616e 6365 3a20 7b7d 205c 6e27 2e66 6f72  ance: {} \n'.for
-00020cb0: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-00020cc0: 2020 2020 2020 2020 2073 656c 662e 6162           self.ab
-00020cd0: 735f 6761 702c 2073 656c 662e 636f 6e66  s_gap, self.conf
-00020ce0: 6967 2e61 6273 6f6c 7574 655f 626f 756e  ig.absolute_boun
-00020cf0: 645f 746f 6c65 7261 6e63 650a 2020 2020  d_tolerance.    
-00020d00: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00020d10: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00020d20: 2020 2020 2020 2020 7365 6c66 2e72 6573          self.res
-00020d30: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
-00020d40: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
-00020d50: 6e20 3d20 7463 2e6f 7074 696d 616c 0a20  n = tc.optimal. 
-00020d60: 2020 2020 2020 2020 2020 2072 6574 7572             retur
-00020d70: 6e20 5472 7565 0a20 2020 2020 2020 2023  n True.        #
-00020d80: 2043 6865 636b 2072 656c 6174 6976 6520   Check relative 
-00020d90: 626f 756e 6420 636f 6e76 6572 6765 6e63  bound convergenc
-00020da0: 650a 2020 2020 2020 2020 6966 2073 656c  e.        if sel
-00020db0: 662e 6265 7374 5f73 6f6c 7574 696f 6e5f  f.best_solution_
-00020dc0: 666f 756e 6420 6973 206e 6f74 204e 6f6e  found is not Non
-00020dd0: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
-00020de0: 6620 7365 6c66 2e72 656c 5f67 6170 203c  f self.rel_gap <
-00020df0: 3d20 7365 6c66 2e63 6f6e 6669 672e 7265  = self.config.re
-00020e00: 6c61 7469 7665 5f62 6f75 6e64 5f74 6f6c  lative_bound_tol
-00020e10: 6572 616e 6365 3a0a 2020 2020 2020 2020  erance:.        
-00020e20: 2020 2020 2020 2020 7365 6c66 2e63 6f6e          self.con
-00020e30: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
-00020e40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00020e50: 2020 2020 2027 4d69 6e64 7450 7920 6578       'MindtPy ex
-00020e60: 6974 696e 6720 6f6e 2062 6f75 6e64 2063  iting on bound c
-00020e70: 6f6e 7665 7267 656e 6365 2e20 270a 2020  onvergence. '.  
-00020e80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020e90: 2020 2752 656c 6174 6976 6520 6761 7020    'Relative gap 
-00020ea0: 3a20 7b7d 203c 3d20 7265 6c61 7469 7665  : {} <= relative
-00020eb0: 2074 6f6c 6572 616e 6365 3a20 7b7d 205c   tolerance: {} \
-00020ec0: 6e27 2e66 6f72 6d61 7428 0a20 2020 2020  n'.format(.     
-00020ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020ee0: 2020 2073 656c 662e 7265 6c5f 6761 702c     self.rel_gap,
-00020ef0: 2073 656c 662e 636f 6e66 6967 2e72 656c   self.config.rel
-00020f00: 6174 6976 655f 626f 756e 645f 746f 6c65  ative_bound_tole
-00020f10: 7261 6e63 650a 2020 2020 2020 2020 2020  rance.          
-00020f20: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00020f30: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00020f40: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00020f50: 6c66 2e72 6573 756c 7473 2e73 6f6c 7665  lf.results.solve
-00020f60: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-00020f70: 6e64 6974 696f 6e20 3d20 7463 2e6f 7074  ndition = tc.opt
-00020f80: 696d 616c 0a20 2020 2020 2020 2020 2020  imal.           
-00020f90: 2020 2020 2072 6574 7572 6e20 5472 7565       return True
-00020fa0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00020fb0: 4661 6c73 650a 0a20 2020 2064 6566 2072  False..    def r
-00020fc0: 6561 6368 6564 5f69 7465 7261 7469 6f6e  eached_iteration
-00020fd0: 5f6c 696d 6974 2873 656c 6629 3a0a 2020  _limit(self):.  
-00020fe0: 2020 2020 2020 2320 4368 6563 6b20 6974        # Check it
-00020ff0: 6572 6174 696f 6e20 6c69 6d69 740a 2020  eration limit.  
-00021000: 2020 2020 2020 6966 2073 656c 662e 6d69        if self.mi
-00021010: 705f 6974 6572 203e 3d20 7365 6c66 2e63  p_iter >= self.c
-00021020: 6f6e 6669 672e 6974 6572 6174 696f 6e5f  onfig.iteration_
-00021030: 6c69 6d69 743a 0a20 2020 2020 2020 2020  limit:.         
-00021040: 2020 2073 656c 662e 636f 6e66 6967 2e6c     self.config.l
-00021050: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
-00021060: 2020 2020 2020 2020 2020 2020 274d 696e              'Min
-00021070: 6474 5079 2075 6e61 626c 6520 746f 2063  dtPy unable to c
-00021080: 6f6e 7665 7267 6520 626f 756e 6473 2027  onverge bounds '
-00021090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000210a0: 2027 6166 7465 7220 7b7d 206d 6169 6e20   'after {} main 
-000210b0: 6974 6572 6174 696f 6e73 2e27 2e66 6f72  iterations.'.for
-000210c0: 6d61 7428 7365 6c66 2e6d 6970 5f69 7465  mat(self.mip_ite
-000210d0: 7229 0a20 2020 2020 2020 2020 2020 2029  r).            )
-000210e0: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-000210f0: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
-00021100: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-00021110: 2020 2020 2020 2746 696e 616c 2062 6f75        'Final bou
-00021120: 6e64 2076 616c 7565 733a 2050 7269 6d61  nd values: Prima
-00021130: 6c20 426f 756e 643a 207b 7d20 2044 7561  l Bound: {}  Dua
-00021140: 6c20 426f 756e 643a 207b 7d27 2e66 6f72  l Bound: {}'.for
-00021150: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-00021160: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-00021170: 696d 616c 5f62 6f75 6e64 2c20 7365 6c66  imal_bound, self
-00021180: 2e64 7561 6c5f 626f 756e 640a 2020 2020  .dual_bound.    
-00021190: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-000211a0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000211b0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
-000211c0: 636f 6e66 6967 2e73 696e 676c 655f 7472  config.single_tr
-000211d0: 6565 3a0a 2020 2020 2020 2020 2020 2020  ee:.            
-000211e0: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
-000211f0: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-00021200: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
-00021210: 7463 2e66 6561 7369 626c 650a 2020 2020  tc.feasible.    
-00021220: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00021230: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00021240: 6c66 2e72 6573 756c 7473 2e73 6f6c 7665  lf.results.solve
-00021250: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-00021260: 6e64 6974 696f 6e20 3d20 7463 2e6d 6178  ndition = tc.max
-00021270: 4974 6572 6174 696f 6e73 0a20 2020 2020  Iterations.     
-00021280: 2020 2020 2020 2072 6574 7572 6e20 5472         return Tr
-00021290: 7565 0a20 2020 2020 2020 2065 6c73 653a  ue.        else:
-000212a0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-000212b0: 7572 6e20 4661 6c73 650a 0a20 2020 2064  urn False..    d
-000212c0: 6566 2072 6561 6368 6564 5f74 696d 655f  ef reached_time_
-000212d0: 6c69 6d69 7428 7365 6c66 293a 0a20 2020  limit(self):.   
-000212e0: 2020 2020 2069 6620 6765 745f 6d61 696e       if get_main
-000212f0: 5f65 6c61 7073 6564 5f74 696d 6528 7365  _elapsed_time(se
-00021300: 6c66 2e74 696d 696e 6729 203e 3d20 7365  lf.timing) >= se
-00021310: 6c66 2e63 6f6e 6669 672e 7469 6d65 5f6c  lf.config.time_l
-00021320: 696d 6974 3a0a 2020 2020 2020 2020 2020  imit:.          
-00021330: 2020 7365 6c66 2e63 6f6e 6669 672e 6c6f    self.config.lo
-00021340: 6767 6572 2e69 6e66 6f28 0a20 2020 2020  gger.info(.     
-00021350: 2020 2020 2020 2020 2020 2027 4d69 6e64             'Mind
-00021360: 7450 7920 756e 6162 6c65 2074 6f20 636f  tPy unable to co
-00021370: 6e76 6572 6765 2062 6f75 6e64 7320 270a  nverge bounds '.
-00021380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021390: 2762 6566 6f72 6520 7469 6d65 206c 696d  'before time lim
-000213a0: 6974 206f 6620 7b7d 2073 6563 6f6e 6473  it of {} seconds
-000213b0: 2e20 270a 2020 2020 2020 2020 2020 2020  . '.            
-000213c0: 2020 2020 2745 6c61 7073 6564 3a20 7b7d      'Elapsed: {}
-000213d0: 2073 6563 6f6e 6473 272e 666f 726d 6174   seconds'.format
-000213e0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-000213f0: 2020 2020 2020 7365 6c66 2e63 6f6e 6669        self.confi
-00021400: 672e 7469 6d65 5f6c 696d 6974 2c20 6765  g.time_limit, ge
-00021410: 745f 6d61 696e 5f65 6c61 7073 6564 5f74  t_main_elapsed_t
-00021420: 696d 6528 7365 6c66 2e74 696d 696e 6729  ime(self.timing)
-00021430: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021440: 2029 0a20 2020 2020 2020 2020 2020 2029   ).            )
-00021450: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00021460: 662e 636f 6e66 6967 2e6c 6f67 6765 722e  f.config.logger.
-00021470: 696e 666f 280a 2020 2020 2020 2020 2020  info(.          
-00021480: 2020 2020 2020 2746 696e 616c 2062 6f75        'Final bou
-00021490: 6e64 2076 616c 7565 733a 2050 7269 6d61  nd values: Prima
-000214a0: 6c20 426f 756e 643a 207b 7d20 2044 7561  l Bound: {}  Dua
-000214b0: 6c20 426f 756e 643a 207b 7d27 2e66 6f72  l Bound: {}'.for
-000214c0: 6d61 7428 0a20 2020 2020 2020 2020 2020  mat(.           
-000214d0: 2020 2020 2020 2020 2073 656c 662e 7072           self.pr
-000214e0: 696d 616c 5f62 6f75 6e64 2c20 7365 6c66  imal_bound, self
-000214f0: 2e64 7561 6c5f 626f 756e 640a 2020 2020  .dual_bound.    
-00021500: 2020 2020 2020 2020 2020 2020 290a 2020              ).  
-00021510: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-00021520: 2020 2020 2020 2020 7365 6c66 2e72 6573          self.res
-00021530: 756c 7473 2e73 6f6c 7665 722e 7465 726d  ults.solver.term
-00021540: 696e 6174 696f 6e5f 636f 6e64 6974 696f  ination_conditio
-00021550: 6e20 3d20 7463 2e6d 6178 5469 6d65 4c69  n = tc.maxTimeLi
-00021560: 6d69 740a 2020 2020 2020 2020 2020 2020  mit.            
-00021570: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
-00021580: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00021590: 2020 2020 2020 7265 7475 726e 2046 616c        return Fal
-000215a0: 7365 0a0a 2020 2020 6465 6620 7265 6163  se..    def reac
-000215b0: 6865 645f 7374 616c 6c69 6e67 5f6c 696d  hed_stalling_lim
-000215c0: 6974 2873 656c 6629 3a0a 2020 2020 2020  it(self):.      
-000215d0: 2020 636f 6e66 6967 203d 2073 656c 662e    config = self.
-000215e0: 636f 6e66 6967 0a20 2020 2020 2020 2069  config.        i
-000215f0: 6620 6c65 6e28 7365 6c66 2e70 7269 6d61  f len(self.prima
-00021600: 6c5f 626f 756e 645f 7072 6f67 7265 7373  l_bound_progress
-00021610: 2920 3e3d 2063 6f6e 6669 672e 7374 616c  ) >= config.stal
-00021620: 6c69 6e67 5f6c 696d 6974 3a0a 2020 2020  ling_limit:.    
-00021630: 2020 2020 2020 2020 6966 2028 0a20 2020          if (.   
-00021640: 2020 2020 2020 2020 2020 2020 2061 6273               abs
-00021650: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00021660: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
-00021670: 6c5f 626f 756e 645f 7072 6f67 7265 7373  l_bound_progress
-00021680: 5b2d 315d 0a20 2020 2020 2020 2020 2020  [-1].           
-00021690: 2020 2020 2020 2020 202d 2073 656c 662e           - self.
-000216a0: 7072 696d 616c 5f62 6f75 6e64 5f70 726f  primal_bound_pro
-000216b0: 6772 6573 735b 2d63 6f6e 6669 672e 7374  gress[-config.st
-000216c0: 616c 6c69 6e67 5f6c 696d 6974 5d0a 2020  alling_limit].  
-000216d0: 2020 2020 2020 2020 2020 2020 2020 290a                ).
-000216e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000216f0: 3c3d 2063 6f6e 6669 672e 7a65 726f 5f74  <= config.zero_t
-00021700: 6f6c 6572 616e 6365 0a20 2020 2020 2020  olerance.       
-00021710: 2020 2020 2029 3a0a 2020 2020 2020 2020       ):.        
-00021720: 2020 2020 2020 2020 636f 6e66 6967 2e6c          config.l
-00021730: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
-00021740: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021750: 2741 6c67 6f72 6974 686d 2069 7320 6e6f  'Algorithm is no
-00021760: 7420 6d61 6b69 6e67 2065 6e6f 7567 6820  t making enough 
-00021770: 7072 6f67 7265 7373 2e20 270a 2020 2020  progress. '.    
-00021780: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021790: 2745 7869 7469 6e67 2069 7465 7261 7469  'Exiting iterati
-000217a0: 6f6e 206c 6f6f 702e 270a 2020 2020 2020  on loop.'.      
-000217b0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
-000217c0: 2020 2020 2020 2020 2020 2020 636f 6e66              conf
-000217d0: 6967 2e6c 6f67 6765 722e 696e 666f 280a  ig.logger.info(.
-000217e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000217f0: 2020 2020 2746 696e 616c 2062 6f75 6e64      'Final bound
-00021800: 2076 616c 7565 733a 2050 7269 6d61 6c20   values: Primal 
-00021810: 426f 756e 643a 207b 7d20 2044 7561 6c20  Bound: {}  Dual 
-00021820: 426f 756e 643a 207b 7d27 2e66 6f72 6d61  Bound: {}'.forma
-00021830: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-00021840: 2020 2020 2020 2020 2020 2073 656c 662e             self.
-00021850: 7072 696d 616c 5f62 6f75 6e64 2c20 7365  primal_bound, se
-00021860: 6c66 2e64 7561 6c5f 626f 756e 640a 2020  lf.dual_bound.  
-00021870: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021880: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00021890: 2020 2020 290a 2020 2020 2020 2020 2020      ).          
-000218a0: 2020 2020 2020 6966 2073 656c 662e 6265        if self.be
-000218b0: 7374 5f73 6f6c 7574 696f 6e5f 666f 756e  st_solution_foun
-000218c0: 6420 6973 206e 6f74 204e 6f6e 653a 0a20  d is not None:. 
-000218d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000218e0: 2020 2073 656c 662e 7265 7375 6c74 732e     self.results.
-000218f0: 736f 6c76 6572 2e74 6572 6d69 6e61 7469  solver.terminati
-00021900: 6f6e 5f63 6f6e 6469 7469 6f6e 203d 2074  on_condition = t
-00021910: 632e 6665 6173 6962 6c65 0a20 2020 2020  c.feasible.     
-00021920: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00021930: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00021940: 2020 2020 2023 2054 4f44 4f3a 2049 7320       # TODO: Is 
-00021950: 6974 2063 6f72 7265 6374 2074 6f20 7365  it correct to se
-00021960: 7420 7365 6c66 2e77 6f72 6b69 6e67 5f6d  t self.working_m
-00021970: 6f64 656c 2061 7320 7468 6520 6265 7374  odel as the best
-00021980: 5f73 6f6c 7574 696f 6e5f 666f 756e 643f  _solution_found?
-00021990: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000219a0: 2020 2020 2023 2049 6e20 6675 6e63 7469       # In functi
-000219b0: 6f6e 2063 6f70 795f 7661 725f 6c69 7374  on copy_var_list
-000219c0: 5f76 616c 7565 732c 2073 6b69 705f 6669  _values, skip_fi
-000219d0: 7865 6420 6973 2073 6574 2074 6f20 5472  xed is set to Tr
-000219e0: 7565 2069 6e20 6465 6661 756c 742e 0a20  ue in default.. 
-000219f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021a00: 2020 2073 656c 662e 6265 7374 5f73 6f6c     self.best_sol
-00021a10: 7574 696f 6e5f 666f 756e 6420 3d20 7365  ution_found = se
-00021a20: 6c66 2e77 6f72 6b69 6e67 5f6d 6f64 656c  lf.working_model
-00021a30: 2e63 6c6f 6e65 2829 0a20 2020 2020 2020  .clone().       
-00021a40: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
-00021a50: 6669 672e 6c6f 6767 6572 2e77 6172 6e69  fig.logger.warni
-00021a60: 6e67 280a 2020 2020 2020 2020 2020 2020  ng(.            
-00021a70: 2020 2020 2020 2020 2020 2020 2741 6c67              'Alg
-00021a80: 6f72 6974 686d 2064 6964 206e 6f74 2066  orithm did not f
-00021a90: 696e 6420 6120 6665 6173 6962 6c65 2073  ind a feasible s
-00021aa0: 6f6c 7574 696f 6e2e 2027 0a20 2020 2020  olution. '.     
-00021ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ac0: 2020 2027 5265 7475 726e 696e 6720 6265     'Returning be
-00021ad0: 7374 2062 6f75 6e64 2073 6f6c 7574 696f  st bound solutio
-00021ae0: 6e2e 2043 6f6e 7369 6465 7220 696e 6372  n. Consider incr
-00021af0: 6561 7369 6e67 2073 7461 6c6c 696e 675f  easing stalling_
-00021b00: 6c69 6d69 7420 6f72 2061 6273 6f6c 7574  limit or absolut
-00021b10: 655f 626f 756e 645f 746f 6c65 7261 6e63  e_bound_toleranc
-00021b20: 652e 270a 2020 2020 2020 2020 2020 2020  e.'.            
-00021b30: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00021b40: 2020 2020 2020 2020 2020 2020 2020 7365                se
-00021b50: 6c66 2e72 6573 756c 7473 2e73 6f6c 7665  lf.results.solve
-00021b60: 722e 7465 726d 696e 6174 696f 6e5f 636f  r.termination_co
-00021b70: 6e64 6974 696f 6e20 3d20 7463 2e6e 6f53  ndition = tc.noS
-00021b80: 6f6c 7574 696f 6e0a 2020 2020 2020 2020  olution.        
-00021b90: 2020 2020 2020 2020 7265 7475 726e 2054          return T
-00021ba0: 7275 650a 2020 2020 2020 2020 7265 7475  rue.        retu
-00021bb0: 726e 2046 616c 7365 0a0a 2020 2020 6465  rn False..    de
-00021bc0: 6620 6974 6572 6174 696f 6e5f 6379 636c  f iteration_cycl
-00021bd0: 696e 6728 7365 6c66 293a 0a20 2020 2020  ing(self):.     
-00021be0: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
-00021bf0: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
-00021c00: 6966 2063 6f6e 6669 672e 6379 636c 696e  if config.cyclin
-00021c10: 675f 6368 6563 6b20 6f72 2063 6f6e 6669  g_check or confi
-00021c20: 672e 7573 655f 7461 6275 5f6c 6973 743a  g.use_tabu_list:
-00021c30: 0a20 2020 2020 2020 2020 2020 2073 656c  .            sel
-00021c40: 662e 6375 7272 5f69 6e74 5f73 6f6c 203d  f.curr_int_sol =
-00021c50: 2067 6574 5f69 6e74 6567 6572 5f73 6f6c   get_integer_sol
-00021c60: 7574 696f 6e28 7365 6c66 2e6d 6970 290a  ution(self.mip).
-00021c70: 2020 2020 2020 2020 2020 2020 6966 2063              if c
-00021c80: 6f6e 6669 672e 6379 636c 696e 675f 6368  onfig.cycling_ch
-00021c90: 6563 6b20 616e 6420 7365 6c66 2e6d 6970  eck and self.mip
-00021ca0: 5f69 7465 7220 3e3d 2031 3a0a 2020 2020  _iter >= 1:.    
-00021cb0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00021cc0: 656c 662e 6375 7272 5f69 6e74 5f73 6f6c  elf.curr_int_sol
-00021cd0: 2069 6e20 7365 7428 7365 6c66 2e69 6e74   in set(self.int
-00021ce0: 6567 6572 5f6c 6973 7429 3a0a 2020 2020  eger_list):.    
-00021cf0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021d00: 636f 6e66 6967 2e6c 6f67 6765 722e 696e  config.logger.in
-00021d10: 666f 280a 2020 2020 2020 2020 2020 2020  fo(.            
-00021d20: 2020 2020 2020 2020 2020 2020 2743 7963              'Cyc
-00021d30: 6c69 6e67 2068 6170 7065 6e73 2061 6674  ling happens aft
-00021d40: 6572 207b 7d20 6d61 696e 2069 7465 7261  er {} main itera
-00021d50: 7469 6f6e 732e 2027 0a20 2020 2020 2020  tions. '.       
-00021d60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021d70: 2027 5468 6520 7361 6d65 2063 6f6d 6269   'The same combi
-00021d80: 6e61 7469 6f6e 2069 7320 6f62 7461 696e  nation is obtain
-00021d90: 6564 2069 6e20 6974 6572 6174 696f 6e20  ed in iteration 
-00021da0: 7b7d 2027 0a20 2020 2020 2020 2020 2020  {} '.           
-00021db0: 2020 2020 2020 2020 2020 2020 2027 5468               'Th
-00021dc0: 6973 2069 7373 7565 2068 6170 7065 6e73  is issue happens
-00021dd0: 2077 6865 6e20 7468 6520 4e4c 5020 7375   when the NLP su
-00021de0: 6270 726f 626c 656d 2076 696f 6c61 7465  bproblem violate
-00021df0: 7320 636f 6e73 7472 6169 6e74 2071 7561  s constraint qua
-00021e00: 6c69 6669 6361 7469 6f6e 2e20 270a 2020  lification. '.  
-00021e10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021e20: 2020 2020 2020 2743 6f6e 7665 7267 656e        'Convergen
-00021e30: 6365 2074 6f20 6f70 7469 6d61 6c20 736f  ce to optimal so
-00021e40: 6c75 7469 6f6e 2069 7320 6e6f 7420 6775  lution is not gu
-00021e50: 6172 616e 7465 6564 2e27 2e66 6f72 6d61  aranteed.'.forma
-00021e60: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
-00021e70: 2020 2020 2020 2020 2020 2020 2020 2073                 s
-00021e80: 656c 662e 6d69 705f 6974 6572 2c0a 2020  elf.mip_iter,.  
-00021e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ea0: 2020 2020 2020 2020 2020 7365 6c66 2e69            self.i
-00021eb0: 6e74 6567 6572 5f6c 6973 742e 696e 6465  nteger_list.inde
-00021ec0: 7828 7365 6c66 2e63 7572 725f 696e 745f  x(self.curr_int_
-00021ed0: 736f 6c29 202b 2031 2c0a 2020 2020 2020  sol) + 1,.      
-00021ee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021ef0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
-00021f00: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
-00021f10: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00021f20: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
-00021f30: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
-00021f40: 2020 2020 2020 2020 2020 2746 696e 616c            'Final
-00021f50: 2062 6f75 6e64 2076 616c 7565 733a 2050   bound values: P
-00021f60: 7269 6d61 6c20 426f 756e 643a 207b 7d20  rimal Bound: {} 
-00021f70: 2044 7561 6c20 426f 756e 643a 207b 7d27   Dual Bound: {}'
-00021f80: 2e66 6f72 6d61 7428 0a20 2020 2020 2020  .format(.       
-00021f90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021fa0: 2020 2020 2073 656c 662e 7072 696d 616c       self.primal
-00021fb0: 5f62 6f75 6e64 2c20 7365 6c66 2e64 7561  _bound, self.dua
-00021fc0: 6c5f 626f 756e 640a 2020 2020 2020 2020  l_bound.        
-00021fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021fe0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00021ff0: 2020 2020 2020 290a 2020 2020 2020 2020        ).        
-00022000: 2020 2020 2020 2020 2020 2020 2320 544f              # TO
-00022010: 444f 2064 6574 6572 6d69 6e65 2073 656c  DO determine sel
-00022020: 662e 7072 696d 616c 5f62 6f75 6e64 2c20  f.primal_bound, 
-00022030: 7365 6c66 2e64 7561 6c5f 626f 756e 6420  self.dual_bound 
-00022040: 6973 2069 6e66 206f 7220 2d69 6e66 2e0a  is inf or -inf..
-00022050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00022060: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
-00022070: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
-00022080: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
-00022090: 7463 2e66 6561 7369 626c 650a 2020 2020  tc.feasible.    
-000220a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220b0: 7265 7475 726e 2054 7275 650a 2020 2020  return True.    
-000220c0: 2020 2020 2020 2020 7365 6c66 2e69 6e74          self.int
-000220d0: 6567 6572 5f6c 6973 742e 6170 7065 6e64  eger_list.append
-000220e0: 2873 656c 662e 6375 7272 5f69 6e74 5f73  (self.curr_int_s
-000220f0: 6f6c 290a 2020 2020 2020 2020 7265 7475  ol).        retu
-00022100: 726e 2046 616c 7365 0a                   rn False.
+00020110: 2020 2020 2020 736f 6c76 6572 5f6d 6f64        solver_mod
+00020120: 656c 3d6d 6169 6e5f 6d69 705f 7265 7375  el=main_mip_resu
+00020130: 6c74 732e 5f73 6f6c 7665 725f 6d6f 6465  lts._solver_mode
+00020140: 6c2c 0a20 2020 2020 2020 2020 2020 2020  l,.             
+00020150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020160: 2020 2076 6172 5f6d 6170 3d6d 6169 6e5f     var_map=main_
+00020170: 6d69 705f 7265 7375 6c74 732e 5f70 796f  mip_results._pyo
+00020180: 6d6f 5f76 6172 5f74 6f5f 736f 6c76 6572  mo_var_to_solver
+00020190: 5f76 6172 5f6d 6170 2c0a 2020 2020 2020  _var_map,.      
+000201a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000201b0: 2020 2020 2020 2020 2020 736f 6c75 7469            soluti
+000201c0: 6f6e 5f6e 616d 653d 6e61 6d65 2c0a 2020  on_name=name,.  
+000201d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000201e0: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+000201f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020200: 2020 2020 2020 2020 7365 6c66 2e63 7572          self.cur
+00020210: 725f 696e 745f 736f 6c20 3d20 6765 745f  r_int_sol = get_
+00020220: 696e 7465 6765 725f 736f 6c75 7469 6f6e  integer_solution
+00020230: 2873 656c 662e 6669 7865 645f 6e6c 7029  (self.fixed_nlp)
+00020240: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020250: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00020260: 7365 6c66 2e63 7572 725f 696e 745f 736f  self.curr_int_so
+00020270: 6c20 696e 2073 6574 2873 656c 662e 696e  l in set(self.in
+00020280: 7465 6765 725f 6c69 7374 293a 0a20 2020  teger_list):.   
+00020290: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000202a0: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+000202b0: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+000202c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000202d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000202e0: 2020 2020 2027 5468 6520 7361 6d65 2063       'The same c
+000202f0: 6f6d 6269 6e61 7469 6f6e 2068 6173 2062  ombination has b
+00020300: 6565 6e20 6578 706c 6f72 6564 2061 6e64  een explored and
+00020310: 2077 696c 6c20 6265 2073 6b69 7070 6564   will be skipped
+00020320: 2068 6572 652e 270a 2020 2020 2020 2020   here.'.        
+00020330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020340: 2020 2020 2020 2020 290a 2020 2020 2020          ).      
+00020350: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020360: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
+00020370: 7565 0a20 2020 2020 2020 2020 2020 2020  ue.             
+00020380: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00020390: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000203a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000203b0: 2020 2020 2073 656c 662e 696e 7465 6765       self.intege
+000203c0: 725f 6c69 7374 2e61 7070 656e 6428 7365  r_list.append(se
+000203d0: 6c66 2e63 7572 725f 696e 745f 736f 6c29  lf.curr_int_sol)
+000203e0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000203f0: 2020 2020 2020 2020 2020 2320 4361 6c6c            # Call
+00020400: 2074 6865 204e 4c50 2070 7265 2d73 6f6c   the NLP pre-sol
+00020410: 7665 2063 616c 6c62 6163 6b0a 2020 2020  ve callback.    
+00020420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020430: 2020 2020 7769 7468 2074 696d 655f 636f      with time_co
+00020440: 6465 2873 656c 662e 7469 6d69 6e67 2c20  de(self.timing, 
+00020450: 2743 616c 6c20 6265 666f 7265 2073 7562  'Call before sub
+00020460: 7072 6f62 6c65 6d20 736f 6c76 6527 293a  problem solve'):
+00020470: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020480: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00020490: 6669 672e 6361 6c6c 5f62 6566 6f72 655f  fig.call_before_
+000204a0: 7375 6270 726f 626c 656d 5f73 6f6c 7665  subproblem_solve
+000204b0: 2873 656c 662e 6669 7865 645f 6e6c 7029  (self.fixed_nlp)
+000204c0: 0a0a 2020 2020 2020 2020 2020 2020 2020  ..              
+000204d0: 2020 2020 2020 2020 2020 6669 7865 645f            fixed_
+000204e0: 6e6c 702c 2066 6978 6564 5f6e 6c70 5f72  nlp, fixed_nlp_r
+000204f0: 6573 756c 7420 3d20 7365 6c66 2e73 6f6c  esult = self.sol
+00020500: 7665 5f73 7562 7072 6f62 6c65 6d28 290a  ve_subproblem().
+00020510: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020520: 2020 2020 2020 2020 7365 6c66 2e68 616e          self.han
+00020530: 646c 655f 6e6c 705f 7375 6270 726f 626c  dle_nlp_subprobl
+00020540: 656d 5f74 6328 6669 7865 645f 6e6c 702c  em_tc(fixed_nlp,
+00020550: 2066 6978 6564 5f6e 6c70 5f72 6573 756c   fixed_nlp_resul
+00020560: 7429 0a0a 2020 2020 2020 2020 2020 2020  t)..            
+00020570: 2020 2020 2020 2020 2020 2020 2320 4361              # Ca
+00020580: 6c6c 2074 6865 204e 4c50 2070 6f73 742d  ll the NLP post-
+00020590: 736f 6c76 6520 6361 6c6c 6261 636b 0a20  solve callback. 
+000205a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000205b0: 2020 2020 2020 2077 6974 6820 7469 6d65         with time
+000205c0: 5f63 6f64 6528 7365 6c66 2e74 696d 696e  _code(self.timin
+000205d0: 672c 2027 4361 6c6c 2061 6674 6572 2073  g, 'Call after s
+000205e0: 7562 7072 6f62 6c65 6d20 736f 6c76 6527  ubproblem solve'
+000205f0: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
+00020600: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00020610: 6f6e 6669 672e 6361 6c6c 5f61 6674 6572  onfig.call_after
+00020620: 5f73 7562 7072 6f62 6c65 6d5f 736f 6c76  _subproblem_solv
+00020630: 6528 6669 7865 645f 6e6c 7029 0a0a 2020  e(fixed_nlp)..  
+00020640: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00020650: 2020 2020 2020 6966 2073 656c 662e 616c        if self.al
+00020660: 676f 7269 7468 6d5f 7368 6f75 6c64 5f74  gorithm_should_t
+00020670: 6572 6d69 6e61 7465 2863 6865 636b 5f63  erminate(check_c
+00020680: 7963 6c69 6e67 3d46 616c 7365 293a 0a20  ycling=False):. 
+00020690: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000206a0: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+000206b0: 6c61 7374 5f69 7465 725f 6375 7473 203d  last_iter_cuts =
+000206c0: 2054 7275 650a 2020 2020 2020 2020 2020   True.          
+000206d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000206e0: 2020 6272 6561 6b20 2023 2054 4f44 4f3a    break  # TODO:
+000206f0: 2062 7265 616b 2074 776f 206c 6f6f 7073   break two loops
+00020700: 2e0a 0a20 2020 2020 2020 2023 2069 6620  ...        # if 
+00020710: 6164 645f 6e6f 5f67 6f6f 645f 6375 7473  add_no_good_cuts
+00020720: 2069 7320 5472 7565 2c20 7468 6520 626f   is True, the bo
+00020730: 756e 6420 6f62 7461 696e 6564 2069 6e20  und obtained in 
+00020740: 7468 6520 6c61 7374 2069 7465 7261 7469  the last iterati
+00020750: 6f6e 2069 7320 6e6f 2072 656c 6961 626c  on is no reliabl
+00020760: 652e 0a20 2020 2020 2020 2023 2077 6520  e..        # we 
+00020770: 636f 7272 6563 7420 6974 2061 6674 6572  correct it after
+00020780: 2074 6865 2069 7465 7261 7469 6f6e 2e0a   the iteration..
+00020790: 2020 2020 2020 2020 2320 5468 6572 6520          # There 
+000207a0: 6973 206e 6f20 6e65 6564 2074 6f20 6669  is no need to fi
+000207b0: 7820 7468 6520 6475 616c 2062 6f75 6e64  x the dual bound
+000207c0: 2069 6620 6e6f 2066 6561 7369 626c 6520   if no feasible 
+000207d0: 736f 6c75 7469 6f6e 2068 6173 2062 6565  solution has bee
+000207e0: 6e20 666f 756e 642e 0a20 2020 2020 2020  n found..       
+000207f0: 2069 6620 280a 2020 2020 2020 2020 2020   if (.          
+00020800: 2020 2863 6f6e 6669 672e 6164 645f 6e6f    (config.add_no
+00020810: 5f67 6f6f 645f 6375 7473 206f 7220 636f  _good_cuts or co
+00020820: 6e66 6967 2e75 7365 5f74 6162 755f 6c69  nfig.use_tabu_li
+00020830: 7374 290a 2020 2020 2020 2020 2020 2020  st).            
+00020840: 616e 6420 6e6f 7420 7365 6c66 2e73 686f  and not self.sho
+00020850: 756c 645f 7465 726d 696e 6174 650a 2020  uld_terminate.  
+00020860: 2020 2020 2020 2020 2020 616e 6420 636f            and co
+00020870: 6e66 6967 2e61 6464 5f72 6567 756c 6172  nfig.add_regular
+00020880: 697a 6174 696f 6e20 6973 204e 6f6e 650a  ization is None.
+00020890: 2020 2020 2020 2020 2020 2020 616e 6420              and 
+000208a0: 7365 6c66 2e62 6573 745f 736f 6c75 7469  self.best_soluti
+000208b0: 6f6e 5f66 6f75 6e64 2069 7320 6e6f 7420  on_found is not 
+000208c0: 4e6f 6e65 0a20 2020 2020 2020 2029 3a0a  None.        ):.
+000208d0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000208e0: 2e66 6978 5f64 7561 6c5f 626f 756e 6428  .fix_dual_bound(
+000208f0: 7365 6c66 2e6c 6173 745f 6974 6572 5f63  self.last_iter_c
+00020900: 7574 7329 0a20 2020 2020 2020 2063 6f6e  uts).        con
+00020910: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+00020920: 0a20 2020 2020 2020 2020 2020 2027 203d  .            ' =
+00020930: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00020940: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00020950: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00020960: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00020970: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00020980: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 270a  =============='.
+00020990: 2020 2020 2020 2020 290a 0a20 2020 2064          )..    d
+000209a0: 6566 2067 6574 5f73 6f6c 7574 696f 6e5f  ef get_solution_
+000209b0: 6e61 6d65 5f6f 626a 2873 656c 662c 206d  name_obj(self, m
+000209c0: 6169 6e5f 6d69 705f 7265 7375 6c74 7329  ain_mip_results)
+000209d0: 3a0a 2020 2020 2020 2020 6966 2073 656c  :.        if sel
+000209e0: 662e 636f 6e66 6967 2e6d 6970 5f73 6f6c  f.config.mip_sol
+000209f0: 7665 7220 3d3d 2027 6370 6c65 785f 7065  ver == 'cplex_pe
+00020a00: 7273 6973 7465 6e74 273a 0a20 2020 2020  rsistent':.     
+00020a10: 2020 2020 2020 2073 6f6c 7574 696f 6e5f         solution_
+00020a20: 706f 6f6c 5f6e 616d 6573 203d 2028 0a20  pool_names = (. 
+00020a30: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00020a40: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
+00020a50: 5f73 6f6c 7665 725f 6d6f 6465 6c2e 736f  _solver_model.so
+00020a60: 6c75 7469 6f6e 2e70 6f6f 6c2e 6765 745f  lution.pool.get_
+00020a70: 6e61 6d65 7328 290a 2020 2020 2020 2020  names().        
+00020a80: 2020 2020 290a 2020 2020 2020 2020 656c      ).        el
+00020a90: 6966 2073 656c 662e 636f 6e66 6967 2e6d  if self.config.m
+00020aa0: 6970 5f73 6f6c 7665 7220 3d3d 2027 6775  ip_solver == 'gu
+00020ab0: 726f 6269 5f70 6572 7369 7374 656e 7427  robi_persistent'
+00020ac0: 3a0a 2020 2020 2020 2020 2020 2020 736f  :.            so
+00020ad0: 6c75 7469 6f6e 5f70 6f6f 6c5f 6e61 6d65  lution_pool_name
+00020ae0: 7320 3d20 6c69 7374 2872 616e 6765 286d  s = list(range(m
+00020af0: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
+00020b00: 5f73 6f6c 7665 725f 6d6f 6465 6c2e 536f  _solver_model.So
+00020b10: 6c43 6f75 6e74 2929 0a20 2020 2020 2020  lCount)).       
+00020b20: 2023 206c 6973 7420 746f 2073 746f 7265   # list to store
+00020b30: 2074 6865 206e 616d 6520 616e 6420 6f62   the name and ob
+00020b40: 6a65 6374 6976 6520 7661 6c75 6520 6f66  jective value of
+00020b50: 2074 6865 2073 6f6c 7574 696f 6e73 2069   the solutions i
+00020b60: 6e20 7468 6520 736f 6c75 7469 6f6e 2070  n the solution p
+00020b70: 6f6f 6c0a 2020 2020 2020 2020 736f 6c75  ool.        solu
+00020b80: 7469 6f6e 5f6e 616d 655f 6f62 6a20 3d20  tion_name_obj = 
+00020b90: 5b5d 0a20 2020 2020 2020 2066 6f72 206e  [].        for n
+00020ba0: 616d 6520 696e 2073 6f6c 7574 696f 6e5f  ame in solution_
+00020bb0: 706f 6f6c 5f6e 616d 6573 3a0a 2020 2020  pool_names:.    
+00020bc0: 2020 2020 2020 2020 6966 2073 656c 662e          if self.
+00020bd0: 636f 6e66 6967 2e6d 6970 5f73 6f6c 7665  config.mip_solve
+00020be0: 7220 3d3d 2027 6370 6c65 785f 7065 7273  r == 'cplex_pers
+00020bf0: 6973 7465 6e74 273a 0a20 2020 2020 2020  istent':.       
+00020c00: 2020 2020 2020 2020 206f 626a 203d 206d           obj = m
+00020c10: 6169 6e5f 6d69 705f 7265 7375 6c74 732e  ain_mip_results.
+00020c20: 5f73 6f6c 7665 725f 6d6f 6465 6c2e 736f  _solver_model.so
+00020c30: 6c75 7469 6f6e 2e70 6f6f 6c2e 6765 745f  lution.pool.get_
+00020c40: 6f62 6a65 6374 6976 655f 7661 6c75 6528  objective_value(
+00020c50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020c60: 2020 2020 206e 616d 650a 2020 2020 2020       name.      
+00020c70: 2020 2020 2020 2020 2020 290a 2020 2020            ).    
+00020c80: 2020 2020 2020 2020 656c 6966 2073 656c          elif sel
+00020c90: 662e 636f 6e66 6967 2e6d 6970 5f73 6f6c  f.config.mip_sol
+00020ca0: 7665 7220 3d3d 2027 6775 726f 6269 5f70  ver == 'gurobi_p
+00020cb0: 6572 7369 7374 656e 7427 3a0a 2020 2020  ersistent':.    
+00020cc0: 2020 2020 2020 2020 2020 2020 6d61 696e              main
+00020cd0: 5f6d 6970 5f72 6573 756c 7473 2e5f 736f  _mip_results._so
+00020ce0: 6c76 6572 5f6d 6f64 656c 2e73 6574 5061  lver_model.setPa
+00020cf0: 7261 6d28 0a20 2020 2020 2020 2020 2020  ram(.           
+00020d00: 2020 2020 2020 2020 2067 7572 6f62 6970           gurobip
+00020d10: 792e 4752 422e 5061 7261 6d2e 536f 6c75  y.GRB.Param.Solu
+00020d20: 7469 6f6e 4e75 6d62 6572 2c20 6e61 6d65  tionNumber, name
+00020d30: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00020d40: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00020d50: 2020 206f 626a 203d 206d 6169 6e5f 6d69     obj = main_mi
+00020d60: 705f 7265 7375 6c74 732e 5f73 6f6c 7665  p_results._solve
+00020d70: 725f 6d6f 6465 6c2e 506f 6f6c 4f62 6a56  r_model.PoolObjV
+00020d80: 616c 0a20 2020 2020 2020 2020 2020 2073  al.            s
+00020d90: 6f6c 7574 696f 6e5f 6e61 6d65 5f6f 626a  olution_name_obj
+00020da0: 2e61 7070 656e 6428 5b6e 616d 652c 206f  .append([name, o
+00020db0: 626a 5d29 0a20 2020 2020 2020 2073 6f6c  bj]).        sol
+00020dc0: 7574 696f 6e5f 6e61 6d65 5f6f 626a 2e73  ution_name_obj.s
+00020dd0: 6f72 7428 0a20 2020 2020 2020 2020 2020  ort(.           
+00020de0: 206b 6579 3d69 7465 6d67 6574 7465 7228   key=itemgetter(
+00020df0: 3129 2c20 7265 7665 7273 653d 7365 6c66  1), reverse=self
+00020e00: 2e6f 626a 6563 7469 7665 5f73 656e 7365  .objective_sense
+00020e10: 203d 3d20 6d61 7869 6d69 7a65 0a20 2020   == maximize.   
+00020e20: 2020 2020 2029 0a20 2020 2020 2020 2073       ).        s
+00020e30: 6f6c 7574 696f 6e5f 6e61 6d65 5f6f 626a  olution_name_obj
+00020e40: 203d 2073 6f6c 7574 696f 6e5f 6e61 6d65   = solution_name
+00020e50: 5f6f 626a 5b3a 2073 656c 662e 636f 6e66  _obj[: self.conf
+00020e60: 6967 2e6e 756d 5f73 6f6c 7574 696f 6e5f  ig.num_solution_
+00020e70: 6974 6572 6174 696f 6e5d 0a20 2020 2020  iteration].     
+00020e80: 2020 2072 6574 7572 6e20 736f 6c75 7469     return soluti
+00020e90: 6f6e 5f6e 616d 655f 6f62 6a0a 0a20 2020  on_name_obj..   
+00020ea0: 2064 6566 2061 6464 5f72 6567 756c 6172   def add_regular
+00020eb0: 697a 6174 696f 6e28 7365 6c66 293a 0a20  ization(self):. 
+00020ec0: 2020 2020 2020 2069 6620 7365 6c66 2e62         if self.b
+00020ed0: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
+00020ee0: 6e64 2069 7320 6e6f 7420 4e6f 6e65 3a0a  nd is not None:.
+00020ef0: 2020 2020 2020 2020 2020 2020 2320 5468              # Th
+00020f00: 6520 6d61 696e 2070 726f 626c 656d 206d  e main problem m
+00020f10: 6967 6874 2062 6520 756e 626f 756e 6465  ight be unbounde
+00020f20: 642c 2072 6567 756c 6172 697a 6174 696f  d, regularizatio
+00020f30: 6e20 6973 2061 6374 6976 6174 6564 206f  n is activated o
+00020f40: 6e6c 7920 7768 656e 2061 2076 616c 6964  nly when a valid
+00020f50: 2062 6f75 6e64 2069 7320 7072 6f76 6964   bound is provid
+00020f60: 6564 2e0a 2020 2020 2020 2020 2020 2020  ed..            
+00020f70: 6966 2073 656c 662e 6475 616c 5f62 6f75  if self.dual_bou
+00020f80: 6e64 2021 3d20 7365 6c66 2e64 7561 6c5f  nd != self.dual_
+00020f90: 626f 756e 645f 7072 6f67 7265 7373 5b30  bound_progress[0
+00020fa0: 5d3a 0a20 2020 2020 2020 2020 2020 2020  ]:.             
+00020fb0: 2020 2077 6974 6820 7469 6d65 5f63 6f64     with time_cod
+00020fc0: 6528 7365 6c66 2e74 696d 696e 672c 2027  e(self.timing, '
+00020fd0: 7265 6775 6c61 7269 7a61 7469 6f6e 206d  regularization m
+00020fe0: 6169 6e27 293a 0a20 2020 2020 2020 2020  ain'):.         
+00020ff0: 2020 2020 2020 2020 2020 2028 7265 6775             (regu
+00021000: 6c61 7269 7a61 7469 6f6e 5f6d 6169 6e5f  larization_main_
+00021010: 6d69 702c 2072 6567 756c 6172 697a 6174  mip, regularizat
+00021020: 696f 6e5f 6d61 696e 5f6d 6970 5f72 6573  ion_main_mip_res
+00021030: 756c 7473 2920 3d20 280a 2020 2020 2020  ults) = (.      
+00021040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021050: 2020 7365 6c66 2e73 6f6c 7665 5f72 6567    self.solve_reg
+00021060: 756c 6172 697a 6174 696f 6e5f 6d61 696e  ularization_main
+00021070: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00021080: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00021090: 2020 2020 2020 2020 2073 656c 662e 6861           self.ha
+000210a0: 6e64 6c65 5f72 6567 756c 6172 697a 6174  ndle_regularizat
+000210b0: 696f 6e5f 6d61 696e 5f74 6328 0a20 2020  ion_main_tc(.   
+000210c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000210d0: 2072 6567 756c 6172 697a 6174 696f 6e5f   regularization_
+000210e0: 6d61 696e 5f6d 6970 2c20 7265 6775 6c61  main_mip, regula
+000210f0: 7269 7a61 7469 6f6e 5f6d 6169 6e5f 6d69  rization_main_mi
+00021100: 705f 7265 7375 6c74 730a 2020 2020 2020  p_results.      
+00021110: 2020 2020 2020 2020 2020 290a 0a20 2020            )..   
+00021120: 2064 6566 2062 6f75 6e64 735f 636f 6e76   def bounds_conv
+00021130: 6572 6765 6428 7365 6c66 293a 0a20 2020  erged(self):.   
+00021140: 2020 2020 2023 2043 6865 636b 2062 6f75       # Check bou
+00021150: 6e64 2063 6f6e 7665 7267 656e 6365 0a20  nd convergence. 
+00021160: 2020 2020 2020 2069 6620 7365 6c66 2e61         if self.a
+00021170: 6273 5f67 6170 203c 3d20 7365 6c66 2e63  bs_gap <= self.c
+00021180: 6f6e 6669 672e 6162 736f 6c75 7465 5f62  onfig.absolute_b
+00021190: 6f75 6e64 5f74 6f6c 6572 616e 6365 3a0a  ound_tolerance:.
+000211a0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+000211b0: 2e63 6f6e 6669 672e 6c6f 6767 6572 2e69  .config.logger.i
+000211c0: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+000211d0: 2020 2020 2027 4d69 6e64 7450 7920 6578       'MindtPy ex
+000211e0: 6974 696e 6720 6f6e 2062 6f75 6e64 2063  iting on bound c
+000211f0: 6f6e 7665 7267 656e 6365 2e20 270a 2020  onvergence. '.  
+00021200: 2020 2020 2020 2020 2020 2020 2020 2741                'A
+00021210: 6273 6f6c 7574 6520 6761 703a 207b 7d20  bsolute gap: {} 
+00021220: 3c3d 2061 6273 6f6c 7574 6520 746f 6c65  <= absolute tole
+00021230: 7261 6e63 653a 207b 7d20 5c6e 272e 666f  rance: {} \n'.fo
+00021240: 726d 6174 280a 2020 2020 2020 2020 2020  rmat(.          
+00021250: 2020 2020 2020 2020 2020 7365 6c66 2e61            self.a
+00021260: 6273 5f67 6170 2c20 7365 6c66 2e63 6f6e  bs_gap, self.con
+00021270: 6669 672e 6162 736f 6c75 7465 5f62 6f75  fig.absolute_bou
+00021280: 6e64 5f74 6f6c 6572 616e 6365 0a20 2020  nd_tolerance.   
+00021290: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+000212a0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+000212b0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+000212c0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+000212d0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+000212e0: 6f6e 203d 2074 632e 6f70 7469 6d61 6c0a  on = tc.optimal.
+000212f0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00021300: 726e 2054 7275 650a 2020 2020 2020 2020  rn True.        
+00021310: 2320 4368 6563 6b20 7265 6c61 7469 7665  # Check relative
+00021320: 2062 6f75 6e64 2063 6f6e 7665 7267 656e   bound convergen
+00021330: 6365 0a20 2020 2020 2020 2069 6620 7365  ce.        if se
+00021340: 6c66 2e62 6573 745f 736f 6c75 7469 6f6e  lf.best_solution
+00021350: 5f66 6f75 6e64 2069 7320 6e6f 7420 4e6f  _found is not No
+00021360: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+00021370: 6966 2073 656c 662e 7265 6c5f 6761 7020  if self.rel_gap 
+00021380: 3c3d 2073 656c 662e 636f 6e66 6967 2e72  <= self.config.r
+00021390: 656c 6174 6976 655f 626f 756e 645f 746f  elative_bound_to
+000213a0: 6c65 7261 6e63 653a 0a20 2020 2020 2020  lerance:.       
+000213b0: 2020 2020 2020 2020 2073 656c 662e 636f           self.co
+000213c0: 6e66 6967 2e6c 6f67 6765 722e 696e 666f  nfig.logger.info
+000213d0: 280a 2020 2020 2020 2020 2020 2020 2020  (.              
+000213e0: 2020 2020 2020 274d 696e 6474 5079 2065        'MindtPy e
+000213f0: 7869 7469 6e67 206f 6e20 626f 756e 6420  xiting on bound 
+00021400: 636f 6e76 6572 6765 6e63 652e 2027 0a20  convergence. '. 
+00021410: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021420: 2020 2027 5265 6c61 7469 7665 2067 6170     'Relative gap
+00021430: 203a 207b 7d20 3c3d 2072 656c 6174 6976   : {} <= relativ
+00021440: 6520 746f 6c65 7261 6e63 653a 207b 7d20  e tolerance: {} 
+00021450: 5c6e 272e 666f 726d 6174 280a 2020 2020  \n'.format(.    
+00021460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021470: 2020 2020 7365 6c66 2e72 656c 5f67 6170      self.rel_gap
+00021480: 2c20 7365 6c66 2e63 6f6e 6669 672e 7265  , self.config.re
+00021490: 6c61 7469 7665 5f62 6f75 6e64 5f74 6f6c  lative_bound_tol
+000214a0: 6572 616e 6365 0a20 2020 2020 2020 2020  erance.         
+000214b0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+000214c0: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+000214d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000214e0: 656c 662e 7265 7375 6c74 732e 736f 6c76  elf.results.solv
+000214f0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+00021500: 6f6e 6469 7469 6f6e 203d 2074 632e 6f70  ondition = tc.op
+00021510: 7469 6d61 6c0a 2020 2020 2020 2020 2020  timal.          
+00021520: 2020 2020 2020 7265 7475 726e 2054 7275        return Tru
+00021530: 650a 2020 2020 2020 2020 7265 7475 726e  e.        return
+00021540: 2046 616c 7365 0a0a 2020 2020 6465 6620   False..    def 
+00021550: 7265 6163 6865 645f 6974 6572 6174 696f  reached_iteratio
+00021560: 6e5f 6c69 6d69 7428 7365 6c66 293a 0a20  n_limit(self):. 
+00021570: 2020 2020 2020 2023 2043 6865 636b 2069         # Check i
+00021580: 7465 7261 7469 6f6e 206c 696d 6974 0a20  teration limit. 
+00021590: 2020 2020 2020 2069 6620 7365 6c66 2e6d         if self.m
+000215a0: 6970 5f69 7465 7220 3e3d 2073 656c 662e  ip_iter >= self.
+000215b0: 636f 6e66 6967 2e69 7465 7261 7469 6f6e  config.iteration
+000215c0: 5f6c 696d 6974 3a0a 2020 2020 2020 2020  _limit:.        
+000215d0: 2020 2020 7365 6c66 2e63 6f6e 6669 672e      self.config.
+000215e0: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+000215f0: 2020 2020 2020 2020 2020 2020 2027 4d69               'Mi
+00021600: 6e64 7450 7920 756e 6162 6c65 2074 6f20  ndtPy unable to 
+00021610: 636f 6e76 6572 6765 2062 6f75 6e64 7320  converge bounds 
+00021620: 270a 2020 2020 2020 2020 2020 2020 2020  '.              
+00021630: 2020 2761 6674 6572 207b 7d20 6d61 696e    'after {} main
+00021640: 2069 7465 7261 7469 6f6e 732e 272e 666f   iterations.'.fo
+00021650: 726d 6174 2873 656c 662e 6d69 705f 6974  rmat(self.mip_it
+00021660: 6572 290a 2020 2020 2020 2020 2020 2020  er).            
+00021670: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+00021680: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
+00021690: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+000216a0: 2020 2020 2020 2027 4669 6e61 6c20 626f         'Final bo
+000216b0: 756e 6420 7661 6c75 6573 3a20 5072 696d  und values: Prim
+000216c0: 616c 2042 6f75 6e64 3a20 7b7d 2020 4475  al Bound: {}  Du
+000216d0: 616c 2042 6f75 6e64 3a20 7b7d 272e 666f  al Bound: {}'.fo
+000216e0: 726d 6174 280a 2020 2020 2020 2020 2020  rmat(.          
+000216f0: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+00021700: 7269 6d61 6c5f 626f 756e 642c 2073 656c  rimal_bound, sel
+00021710: 662e 6475 616c 5f62 6f75 6e64 0a20 2020  f.dual_bound.   
+00021720: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00021730: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00021740: 2020 2020 2020 2020 2069 6620 7365 6c66           if self
+00021750: 2e63 6f6e 6669 672e 7369 6e67 6c65 5f74  .config.single_t
+00021760: 7265 653a 0a20 2020 2020 2020 2020 2020  ree:.           
+00021770: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
+00021780: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00021790: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 203d  tion_condition =
+000217a0: 2074 632e 6665 6173 6962 6c65 0a20 2020   tc.feasible.   
+000217b0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+000217c0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000217d0: 656c 662e 7265 7375 6c74 732e 736f 6c76  elf.results.solv
+000217e0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+000217f0: 6f6e 6469 7469 6f6e 203d 2074 632e 6d61  ondition = tc.ma
+00021800: 7849 7465 7261 7469 6f6e 730a 2020 2020  xIterations.    
+00021810: 2020 2020 2020 2020 7265 7475 726e 2054          return T
+00021820: 7275 650a 2020 2020 2020 2020 656c 7365  rue.        else
+00021830: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
+00021840: 7475 726e 2046 616c 7365 0a0a 2020 2020  turn False..    
+00021850: 6465 6620 7265 6163 6865 645f 7469 6d65  def reached_time
+00021860: 5f6c 696d 6974 2873 656c 6629 3a0a 2020  _limit(self):.  
+00021870: 2020 2020 2020 6966 2067 6574 5f6d 6169        if get_mai
+00021880: 6e5f 656c 6170 7365 645f 7469 6d65 2873  n_elapsed_time(s
+00021890: 656c 662e 7469 6d69 6e67 2920 3e3d 2073  elf.timing) >= s
+000218a0: 656c 662e 636f 6e66 6967 2e74 696d 655f  elf.config.time_
+000218b0: 6c69 6d69 743a 0a20 2020 2020 2020 2020  limit:.         
+000218c0: 2020 2073 656c 662e 636f 6e66 6967 2e6c     self.config.l
+000218d0: 6f67 6765 722e 696e 666f 280a 2020 2020  ogger.info(.    
+000218e0: 2020 2020 2020 2020 2020 2020 274d 696e              'Min
+000218f0: 6474 5079 2075 6e61 626c 6520 746f 2063  dtPy unable to c
+00021900: 6f6e 7665 7267 6520 626f 756e 6473 2027  onverge bounds '
+00021910: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00021920: 2027 6265 666f 7265 2074 696d 6520 6c69   'before time li
+00021930: 6d69 7420 6f66 207b 7d20 7365 636f 6e64  mit of {} second
+00021940: 732e 2027 0a20 2020 2020 2020 2020 2020  s. '.           
+00021950: 2020 2020 2027 456c 6170 7365 643a 207b       'Elapsed: {
+00021960: 7d20 7365 636f 6e64 7327 2e66 6f72 6d61  } seconds'.forma
+00021970: 7428 0a20 2020 2020 2020 2020 2020 2020  t(.             
+00021980: 2020 2020 2020 2073 656c 662e 636f 6e66         self.conf
+00021990: 6967 2e74 696d 655f 6c69 6d69 742c 2067  ig.time_limit, g
+000219a0: 6574 5f6d 6169 6e5f 656c 6170 7365 645f  et_main_elapsed_
+000219b0: 7469 6d65 2873 656c 662e 7469 6d69 6e67  time(self.timing
+000219c0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000219d0: 2020 290a 2020 2020 2020 2020 2020 2020    ).            
+000219e0: 290a 2020 2020 2020 2020 2020 2020 7365  ).            se
+000219f0: 6c66 2e63 6f6e 6669 672e 6c6f 6767 6572  lf.config.logger
+00021a00: 2e69 6e66 6f28 0a20 2020 2020 2020 2020  .info(.         
+00021a10: 2020 2020 2020 2027 4669 6e61 6c20 626f         'Final bo
+00021a20: 756e 6420 7661 6c75 6573 3a20 5072 696d  und values: Prim
+00021a30: 616c 2042 6f75 6e64 3a20 7b7d 2020 4475  al Bound: {}  Du
+00021a40: 616c 2042 6f75 6e64 3a20 7b7d 272e 666f  al Bound: {}'.fo
+00021a50: 726d 6174 280a 2020 2020 2020 2020 2020  rmat(.          
+00021a60: 2020 2020 2020 2020 2020 7365 6c66 2e70            self.p
+00021a70: 7269 6d61 6c5f 626f 756e 642c 2073 656c  rimal_bound, sel
+00021a80: 662e 6475 616c 5f62 6f75 6e64 0a20 2020  f.dual_bound.   
+00021a90: 2020 2020 2020 2020 2020 2020 2029 0a20               ). 
+00021aa0: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00021ab0: 2020 2020 2020 2020 2073 656c 662e 7265           self.re
+00021ac0: 7375 6c74 732e 736f 6c76 6572 2e74 6572  sults.solver.ter
+00021ad0: 6d69 6e61 7469 6f6e 5f63 6f6e 6469 7469  mination_conditi
+00021ae0: 6f6e 203d 2074 632e 6d61 7854 696d 654c  on = tc.maxTimeL
+00021af0: 696d 6974 0a20 2020 2020 2020 2020 2020  imit.           
+00021b00: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
+00021b10: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00021b20: 2020 2020 2020 2072 6574 7572 6e20 4661         return Fa
+00021b30: 6c73 650a 0a20 2020 2064 6566 2072 6561  lse..    def rea
+00021b40: 6368 6564 5f73 7461 6c6c 696e 675f 6c69  ched_stalling_li
+00021b50: 6d69 7428 7365 6c66 293a 0a20 2020 2020  mit(self):.     
+00021b60: 2020 2063 6f6e 6669 6720 3d20 7365 6c66     config = self
+00021b70: 2e63 6f6e 6669 670a 2020 2020 2020 2020  .config.        
+00021b80: 6966 206c 656e 2873 656c 662e 7072 696d  if len(self.prim
+00021b90: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
+00021ba0: 7329 203e 3d20 636f 6e66 6967 2e73 7461  s) >= config.sta
+00021bb0: 6c6c 696e 675f 6c69 6d69 743a 0a20 2020  lling_limit:.   
+00021bc0: 2020 2020 2020 2020 2069 6620 280a 2020           if (.  
+00021bd0: 2020 2020 2020 2020 2020 2020 2020 6162                ab
+00021be0: 7328 0a20 2020 2020 2020 2020 2020 2020  s(.             
+00021bf0: 2020 2020 2020 2073 656c 662e 7072 696d         self.prim
+00021c00: 616c 5f62 6f75 6e64 5f70 726f 6772 6573  al_bound_progres
+00021c10: 735b 2d31 5d0a 2020 2020 2020 2020 2020  s[-1].          
+00021c20: 2020 2020 2020 2020 2020 2d20 7365 6c66            - self
+00021c30: 2e70 7269 6d61 6c5f 626f 756e 645f 7072  .primal_bound_pr
+00021c40: 6f67 7265 7373 5b2d 636f 6e66 6967 2e73  ogress[-config.s
+00021c50: 7461 6c6c 696e 675f 6c69 6d69 745d 0a20  talling_limit]. 
+00021c60: 2020 2020 2020 2020 2020 2020 2020 2029                 )
+00021c70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00021c80: 203c 3d20 636f 6e66 6967 2e7a 6572 6f5f   <= config.zero_
+00021c90: 746f 6c65 7261 6e63 650a 2020 2020 2020  tolerance.      
+00021ca0: 2020 2020 2020 293a 0a20 2020 2020 2020        ):.       
+00021cb0: 2020 2020 2020 2020 2063 6f6e 6669 672e           config.
+00021cc0: 6c6f 6767 6572 2e69 6e66 6f28 0a20 2020  logger.info(.   
+00021cd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021ce0: 2027 416c 676f 7269 7468 6d20 6973 206e   'Algorithm is n
+00021cf0: 6f74 206d 616b 696e 6720 656e 6f75 6768  ot making enough
+00021d00: 2070 726f 6772 6573 732e 2027 0a20 2020   progress. '.   
+00021d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021d20: 2027 4578 6974 696e 6720 6974 6572 6174   'Exiting iterat
+00021d30: 696f 6e20 6c6f 6f70 2e27 0a20 2020 2020  ion loop.'.     
+00021d40: 2020 2020 2020 2020 2020 2029 0a20 2020             ).   
+00021d50: 2020 2020 2020 2020 2020 2020 2063 6f6e               con
+00021d60: 6669 672e 6c6f 6767 6572 2e69 6e66 6f28  fig.logger.info(
+00021d70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00021d80: 2020 2020 2027 4669 6e61 6c20 626f 756e       'Final boun
+00021d90: 6420 7661 6c75 6573 3a20 5072 696d 616c  d values: Primal
+00021da0: 2042 6f75 6e64 3a20 7b7d 2020 4475 616c   Bound: {}  Dual
+00021db0: 2042 6f75 6e64 3a20 7b7d 272e 666f 726d   Bound: {}'.form
+00021dc0: 6174 280a 2020 2020 2020 2020 2020 2020  at(.            
+00021dd0: 2020 2020 2020 2020 2020 2020 7365 6c66              self
+00021de0: 2e70 7269 6d61 6c5f 626f 756e 642c 2073  .primal_bound, s
+00021df0: 656c 662e 6475 616c 5f62 6f75 6e64 0a20  elf.dual_bound. 
+00021e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021e10: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00021e20: 2020 2020 2029 0a20 2020 2020 2020 2020       ).         
+00021e30: 2020 2020 2020 2069 6620 7365 6c66 2e62         if self.b
+00021e40: 6573 745f 736f 6c75 7469 6f6e 5f66 6f75  est_solution_fou
+00021e50: 6e64 2069 7320 6e6f 7420 4e6f 6e65 3a0a  nd is not None:.
+00021e60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021e70: 2020 2020 7365 6c66 2e72 6573 756c 7473      self.results
+00021e80: 2e73 6f6c 7665 722e 7465 726d 696e 6174  .solver.terminat
+00021e90: 696f 6e5f 636f 6e64 6974 696f 6e20 3d20  ion_condition = 
+00021ea0: 7463 2e66 6561 7369 626c 650a 2020 2020  tc.feasible.    
+00021eb0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00021ec0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00021ed0: 2020 2020 2020 2320 544f 444f 3a20 4973        # TODO: Is
+00021ee0: 2069 7420 636f 7272 6563 7420 746f 2073   it correct to s
+00021ef0: 6574 2073 656c 662e 776f 726b 696e 675f  et self.working_
+00021f00: 6d6f 6465 6c20 6173 2074 6865 2062 6573  model as the bes
+00021f10: 745f 736f 6c75 7469 6f6e 5f66 6f75 6e64  t_solution_found
+00021f20: 3f0a 2020 2020 2020 2020 2020 2020 2020  ?.              
+00021f30: 2020 2020 2020 2320 496e 2066 756e 6374        # In funct
+00021f40: 696f 6e20 636f 7079 5f76 6172 5f6c 6973  ion copy_var_lis
+00021f50: 745f 7661 6c75 6573 2c20 736b 6970 5f66  t_values, skip_f
+00021f60: 6978 6564 2069 7320 7365 7420 746f 2054  ixed is set to T
+00021f70: 7275 6520 696e 2064 6566 6175 6c74 2e0a  rue in default..
+00021f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021f90: 2020 2020 7365 6c66 2e62 6573 745f 736f      self.best_so
+00021fa0: 6c75 7469 6f6e 5f66 6f75 6e64 203d 2073  lution_found = s
+00021fb0: 656c 662e 776f 726b 696e 675f 6d6f 6465  elf.working_mode
+00021fc0: 6c2e 636c 6f6e 6528 290a 2020 2020 2020  l.clone().      
+00021fd0: 2020 2020 2020 2020 2020 2020 2020 636f                co
+00021fe0: 6e66 6967 2e6c 6f67 6765 722e 7761 726e  nfig.logger.warn
+00021ff0: 696e 6728 0a20 2020 2020 2020 2020 2020  ing(.           
+00022000: 2020 2020 2020 2020 2020 2020 2027 416c               'Al
+00022010: 676f 7269 7468 6d20 6469 6420 6e6f 7420  gorithm did not 
+00022020: 6669 6e64 2061 2066 6561 7369 626c 6520  find a feasible 
+00022030: 736f 6c75 7469 6f6e 2e20 270a 2020 2020  solution. '.    
+00022040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022050: 2020 2020 2752 6574 7572 6e69 6e67 2062      'Returning b
+00022060: 6573 7420 626f 756e 6420 736f 6c75 7469  est bound soluti
+00022070: 6f6e 2e20 436f 6e73 6964 6572 2069 6e63  on. Consider inc
+00022080: 7265 6173 696e 6720 7374 616c 6c69 6e67  reasing stalling
+00022090: 5f6c 696d 6974 206f 7220 6162 736f 6c75  _limit or absolu
+000220a0: 7465 5f62 6f75 6e64 5f74 6f6c 6572 616e  te_bound_toleran
+000220b0: 6365 2e27 0a20 2020 2020 2020 2020 2020  ce.'.           
+000220c0: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+000220d0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+000220e0: 656c 662e 7265 7375 6c74 732e 736f 6c76  elf.results.solv
+000220f0: 6572 2e74 6572 6d69 6e61 7469 6f6e 5f63  er.termination_c
+00022100: 6f6e 6469 7469 6f6e 203d 2074 632e 6e6f  ondition = tc.no
+00022110: 536f 6c75 7469 6f6e 0a20 2020 2020 2020  Solution.       
+00022120: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00022130: 5472 7565 0a20 2020 2020 2020 2072 6574  True.        ret
+00022140: 7572 6e20 4661 6c73 650a 0a20 2020 2064  urn False..    d
+00022150: 6566 2069 7465 7261 7469 6f6e 5f63 7963  ef iteration_cyc
+00022160: 6c69 6e67 2873 656c 6629 3a0a 2020 2020  ling(self):.    
+00022170: 2020 2020 636f 6e66 6967 203d 2073 656c      config = sel
+00022180: 662e 636f 6e66 6967 0a20 2020 2020 2020  f.config.       
+00022190: 2069 6620 636f 6e66 6967 2e63 7963 6c69   if config.cycli
+000221a0: 6e67 5f63 6865 636b 206f 7220 636f 6e66  ng_check or conf
+000221b0: 6967 2e75 7365 5f74 6162 755f 6c69 7374  ig.use_tabu_list
+000221c0: 3a0a 2020 2020 2020 2020 2020 2020 7365  :.            se
+000221d0: 6c66 2e63 7572 725f 696e 745f 736f 6c20  lf.curr_int_sol 
+000221e0: 3d20 6765 745f 696e 7465 6765 725f 736f  = get_integer_so
+000221f0: 6c75 7469 6f6e 2873 656c 662e 6d69 7029  lution(self.mip)
+00022200: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00022210: 636f 6e66 6967 2e63 7963 6c69 6e67 5f63  config.cycling_c
+00022220: 6865 636b 2061 6e64 2073 656c 662e 6d69  heck and self.mi
+00022230: 705f 6974 6572 203e 3d20 313a 0a20 2020  p_iter >= 1:.   
+00022240: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+00022250: 7365 6c66 2e63 7572 725f 696e 745f 736f  self.curr_int_so
+00022260: 6c20 696e 2073 6574 2873 656c 662e 696e  l in set(self.in
+00022270: 7465 6765 725f 6c69 7374 293a 0a20 2020  teger_list):.   
+00022280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022290: 2063 6f6e 6669 672e 6c6f 6767 6572 2e69   config.logger.i
+000222a0: 6e66 6f28 0a20 2020 2020 2020 2020 2020  nfo(.           
+000222b0: 2020 2020 2020 2020 2020 2020 2027 4379               'Cy
+000222c0: 636c 696e 6720 6861 7070 656e 7320 6166  cling happens af
+000222d0: 7465 7220 7b7d 206d 6169 6e20 6974 6572  ter {} main iter
+000222e0: 6174 696f 6e73 2e20 270a 2020 2020 2020  ations. '.      
+000222f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022300: 2020 2754 6865 2073 616d 6520 636f 6d62    'The same comb
+00022310: 696e 6174 696f 6e20 6973 206f 6274 6169  ination is obtai
+00022320: 6e65 6420 696e 2069 7465 7261 7469 6f6e  ned in iteration
+00022330: 207b 7d20 270a 2020 2020 2020 2020 2020   {} '.          
+00022340: 2020 2020 2020 2020 2020 2020 2020 2754                'T
+00022350: 6869 7320 6973 7375 6520 6861 7070 656e  his issue happen
+00022360: 7320 7768 656e 2074 6865 204e 4c50 2073  s when the NLP s
+00022370: 7562 7072 6f62 6c65 6d20 7669 6f6c 6174  ubproblem violat
+00022380: 6573 2063 6f6e 7374 7261 696e 7420 7175  es constraint qu
+00022390: 616c 6966 6963 6174 696f 6e2e 2027 0a20  alification. '. 
+000223a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000223b0: 2020 2020 2020 2027 436f 6e76 6572 6765         'Converge
+000223c0: 6e63 6520 746f 206f 7074 696d 616c 2073  nce to optimal s
+000223d0: 6f6c 7574 696f 6e20 6973 206e 6f74 2067  olution is not g
+000223e0: 7561 7261 6e74 6565 642e 272e 666f 726d  uaranteed.'.form
+000223f0: 6174 280a 2020 2020 2020 2020 2020 2020  at(.            
+00022400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022410: 7365 6c66 2e6d 6970 5f69 7465 722c 0a20  self.mip_iter,. 
+00022420: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022430: 2020 2020 2020 2020 2020 2073 656c 662e             self.
+00022440: 696e 7465 6765 725f 6c69 7374 2e69 6e64  integer_list.ind
+00022450: 6578 2873 656c 662e 6375 7272 5f69 6e74  ex(self.curr_int
+00022460: 5f73 6f6c 2920 2b20 312c 0a20 2020 2020  _sol) + 1,.     
+00022470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022480: 2020 2029 0a20 2020 2020 2020 2020 2020     ).           
+00022490: 2020 2020 2020 2020 2029 0a20 2020 2020           ).     
+000224a0: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+000224b0: 6f6e 6669 672e 6c6f 6767 6572 2e69 6e66  onfig.logger.inf
+000224c0: 6f28 0a20 2020 2020 2020 2020 2020 2020  o(.             
+000224d0: 2020 2020 2020 2020 2020 2027 4669 6e61             'Fina
+000224e0: 6c20 626f 756e 6420 7661 6c75 6573 3a20  l bound values: 
+000224f0: 5072 696d 616c 2042 6f75 6e64 3a20 7b7d  Primal Bound: {}
+00022500: 2020 4475 616c 2042 6f75 6e64 3a20 7b7d    Dual Bound: {}
+00022510: 272e 666f 726d 6174 280a 2020 2020 2020  '.format(.      
+00022520: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022530: 2020 2020 2020 7365 6c66 2e70 7269 6d61        self.prima
+00022540: 6c5f 626f 756e 642c 2073 656c 662e 6475  l_bound, self.du
+00022550: 616c 5f62 6f75 6e64 0a20 2020 2020 2020  al_bound.       
+00022560: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022570: 2029 0a20 2020 2020 2020 2020 2020 2020   ).             
+00022580: 2020 2020 2020 2029 0a20 2020 2020 2020         ).       
+00022590: 2020 2020 2020 2020 2020 2020 2023 2054               # T
+000225a0: 4f44 4f20 6465 7465 726d 696e 6520 7365  ODO determine se
+000225b0: 6c66 2e70 7269 6d61 6c5f 626f 756e 642c  lf.primal_bound,
+000225c0: 2073 656c 662e 6475 616c 5f62 6f75 6e64   self.dual_bound
+000225d0: 2069 7320 696e 6620 6f72 202d 696e 662e   is inf or -inf.
+000225e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000225f0: 2020 2020 2073 656c 662e 7265 7375 6c74       self.result
+00022600: 732e 736f 6c76 6572 2e74 6572 6d69 6e61  s.solver.termina
+00022610: 7469 6f6e 5f63 6f6e 6469 7469 6f6e 203d  tion_condition =
+00022620: 2074 632e 6665 6173 6962 6c65 0a20 2020   tc.feasible.   
+00022630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022640: 2072 6574 7572 6e20 5472 7565 0a20 2020   return True.   
+00022650: 2020 2020 2020 2020 2073 656c 662e 696e           self.in
+00022660: 7465 6765 725f 6c69 7374 2e61 7070 656e  teger_list.appen
+00022670: 6428 7365 6c66 2e63 7572 725f 696e 745f  d(self.curr_int_
+00022680: 736f 6c29 0a20 2020 2020 2020 2072 6574  sol).        ret
+00022690: 7572 6e20 4661 6c73 650a                 urn False.
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/config_options.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/config_options.py`

 * *Files 1% similar despite different names*

```diff
@@ -320,14 +320,23 @@
             default=_DoNothing(),
             domain=None,
             description='Function to be executed after every main problem',
             doc='Callback hook after a solution of the main problem.',
         ),
     )
     CONFIG.declare(
+        'call_before_subproblem_solve',
+        ConfigValue(
+            default=_DoNothing(),
+            domain=None,
+            description='Function to be executed before every subproblem',
+            doc='Callback hook before a solution of the nonlinear subproblem.',
+        ),
+    )
+    CONFIG.declare(
         'call_after_subproblem_solve',
         ConfigValue(
             default=_DoNothing(),
             domain=None,
             description='Function to be executed after every subproblem',
             doc='Callback hook after a solution of the nonlinear subproblem.',
         ),
@@ -545,15 +554,15 @@
                     'cbc',
                     'glpk',
                     'gams',
                     'gurobi_persistent',
                     'cplex_persistent',
                     'appsi_cplex',
                     'appsi_gurobi',
-                    # 'appsi_highs', TODO: feasibility pump now fails with appsi_highs #2951
+                    'appsi_highs',
                 ]
             ),
             description='MIP subsolver name',
             doc='Which MIP subsolver is going to be used for solving the mixed-'
             'integer main problems.',
         ),
     )
@@ -627,15 +636,15 @@
                     'cbc',
                     'glpk',
                     'gams',
                     'gurobi_persistent',
                     'cplex_persistent',
                     'appsi_cplex',
                     'appsi_gurobi',
-                    # 'appsi_highs',
+                    'appsi_highs',
                 ]
             ),
             description='MIP subsolver for regularization problem',
             doc='Which MIP subsolver is going to be used for solving the regularization problem.',
         ),
     )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/cut_generation.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/cut_generation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/extended_cutting_plane.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/extended_cutting_plane.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/feasibility_pump.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/feasibility_pump.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/global_outer_approximation.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/global_outer_approximation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/outer_approximation.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/outer_approximation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/single_tree.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/single_tree.py`

 * *Files 1% similar despite different names*

```diff
@@ -769,14 +769,17 @@
                 return
             elif config.strategy == 'OA':
                 return
         else:
             mindtpy_solver.integer_list.append(mindtpy_solver.curr_int_sol)
 
         # solve subproblem
+        # Call the NLP pre-solve callback
+        with time_code(mindtpy_solver.timing, 'Call before subproblem solve'):
+            config.call_before_subproblem_solve(mindtpy_solver.fixed_nlp)
         # The constraint linearization happens in the handlers
         fixed_nlp, fixed_nlp_result = mindtpy_solver.solve_subproblem()
         # add oa cuts
         if fixed_nlp_result.solver.termination_condition in {
             tc.optimal,
             tc.locallyOptimal,
             tc.feasible,
@@ -915,14 +918,17 @@
                 return
         else:
             mindtpy_solver.integer_list.append(mindtpy_solver.curr_int_sol)
             if config.strategy == 'OA':
                 cut_ind = len(mindtpy_solver.mip.MindtPy_utils.cuts.oa_cuts)
 
         # solve subproblem
+        # Call the NLP pre-solve callback
+        with time_code(mindtpy_solver.timing, 'Call before subproblem solve'):
+            config.call_before_subproblem_solve(mindtpy_solver.fixed_nlp)
         # The constraint linearization happens in the handlers
         fixed_nlp, fixed_nlp_result = mindtpy_solver.solve_subproblem()
 
         mindtpy_solver.handle_nlp_subproblem_tc(fixed_nlp, fixed_nlp_result, cb_opt)
         if config.strategy == 'OA':
             # store the cut index corresponding to current integer solution.
             mindtpy_solver.integer_solution_to_cuts_index[
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tabu_list.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tabu_list.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP2_simple.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP2_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP3_simple.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP3_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP4_simple.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP4_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP5_simple.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP5_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP_simple.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/MINLP_simple_grey_box.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/MINLP_simple_grey_box.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/constraint_qualification_example.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/constraint_qualification_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/eight_process_problem.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/eight_process_problem.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/feasibility_pump1.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/feasibility_pump1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/feasibility_pump2.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/feasibility_pump2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/from_proposal.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/from_proposal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex1.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex2.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex3.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex3.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/nonconvex4.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/nonconvex4.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/online_doc_example.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/online_doc_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy.py`

 * *Files 2% similar despite different names*

```diff
@@ -52,15 +52,20 @@
 LP_model = LP_unbounded()
 LP_model._generate_model()
 
 QCP_model = QCP_simple()
 QCP_model._generate_model()
 extreme_model_list = [LP_model.model, QCP_model.model]
 
-required_solvers = ('ipopt', 'glpk')
+if SolverFactory('appsi_highs').available(exception_flag=False) and SolverFactory(
+    'appsi_highs'
+).version() >= (1, 7, 0):
+    required_solvers = ('ipopt', 'appsi_highs')
+else:
+    required_solvers = ('ipopt', 'glpk')
 if all(SolverFactory(s).available(exception_flag=False) for s in required_solvers):
     subsolvers_available = True
 else:
     subsolvers_available = False
 
 
 @unittest.skipIf(
@@ -97,14 +102,38 @@
                     [TerminationCondition.optimal, TerminationCondition.feasible],
                 )
                 self.assertAlmostEqual(
                     value(model.objective.expr), model.optimal_value, places=1
                 )
                 self.check_optimal_solution(model)
 
+    def test_OA_callback(self):
+        """Test the outer approximation decomposition algorithm."""
+        with SolverFactory('mindtpy') as opt:
+
+            def callback(model):
+                model.Y[1].value = 0
+                model.Y[2].value = 0
+                model.Y[3].value = 0
+
+            model = SimpleMINLP2()
+            # The callback function will make the OA method cycling.
+            results = opt.solve(
+                model,
+                strategy='OA',
+                init_strategy='rNLP',
+                mip_solver=required_solvers[1],
+                nlp_solver=required_solvers[0],
+                call_before_subproblem_solve=callback,
+            )
+            self.assertIs(
+                results.solver.termination_condition, TerminationCondition.feasible
+            )
+            self.assertAlmostEqual(value(results.problem.lower_bound), 5, places=1)
+
     def test_OA_extreme_model(self):
         """Test the outer approximation decomposition algorithm."""
         with SolverFactory('mindtpy') as opt:
             for model in extreme_model_list:
                 model = model.clone()
                 results = opt.solve(
                     model,
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_ECP.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_ECP.py`

 * *Files 3% similar despite different names*

```diff
@@ -19,15 +19,21 @@
 from pyomo.contrib.mindtpy.tests.from_proposal import ProposalModel
 from pyomo.contrib.mindtpy.tests.constraint_qualification_example import (
     ConstraintQualificationExample,
 )
 from pyomo.environ import SolverFactory, value
 from pyomo.opt import TerminationCondition
 
-required_solvers = ('ipopt', 'glpk')
+if SolverFactory('appsi_highs').available(exception_flag=False) and SolverFactory(
+    'appsi_highs'
+).version() >= (1, 7, 0):
+    required_solvers = ('ipopt', 'appsi_highs')
+else:
+    required_solvers = ('ipopt', 'glpk')
+
 if all(SolverFactory(s).available(exception_flag=False) for s in required_solvers):
     subsolvers_available = True
 else:
     subsolvers_available = False
 
 model_list = [
     EightProcessFlowsheet(convex=True),
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_feas_pump.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_feas_pump.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,16 +24,21 @@
 from pyomo.environ import SolverFactory, value
 from pyomo.opt import TerminationCondition
 from pyomo.contrib.gdpopt.util import is_feasible
 from pyomo.util.infeasible import log_infeasible_constraints
 from pyomo.contrib.mindtpy.tests.feasibility_pump1 import FeasPump1
 from pyomo.contrib.mindtpy.tests.feasibility_pump2 import FeasPump2
 
-required_solvers = ('ipopt', 'glpk')
-# TODO: 'appsi_highs' will fail here.
+if SolverFactory('appsi_highs').available(exception_flag=False) and SolverFactory(
+    'appsi_highs'
+).version() >= (1, 7, 0):
+    required_solvers = ('ipopt', 'appsi_highs')
+else:
+    required_solvers = ('ipopt', 'glpk')
+
 if all(SolverFactory(s).available(exception_flag=False) for s in required_solvers):
     subsolvers_available = True
 else:
     subsolvers_available = False
 
 model_list = [
     EightProcessFlowsheet(convex=True),
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_global.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_global.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_global_lp_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_global_lp_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_grey_box.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_grey_box.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,15 +14,22 @@
 import pyomo.common.unittest as unittest
 from pyomo.environ import SolverFactory, value, maximize
 from pyomo.opt import TerminationCondition
 from pyomo.common.dependencies import numpy_available, scipy_available
 from pyomo.contrib.mindtpy.tests.MINLP_simple import SimpleMINLP as SimpleMINLP
 
 model_list = [SimpleMINLP(grey_box=True)]
-required_solvers = ('cyipopt', 'glpk')
+
+if SolverFactory('appsi_highs').available(exception_flag=False) and SolverFactory(
+    'appsi_highs'
+).version() >= (1, 7, 0):
+    required_solvers = ('cyipopt', 'appsi_highs')
+else:
+    required_solvers = ('cyipopt', 'glpk')
+
 if all(SolverFactory(s).available(exception_flag=False) for s in required_solvers):
     subsolvers_available = True
 else:
     subsolvers_available = False
 
 
 @unittest.skipIf(model_list[0] is None, 'Unable to generate the Grey Box model.')
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_lp_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_lp_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_regularization.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_regularization.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/test_mindtpy_solution_pool.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/test_mindtpy_solution_pool.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/tests/unit_test.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/tests/unit_test.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mindtpy/util.py` & `Pyomo-6.7.2/pyomo/contrib/mindtpy/util.py`

 * *Files 0% similar despite different names*

```diff
@@ -25,15 +25,14 @@
     TransformationFactory,
     value,
 )
 from pyomo.repn import generate_standard_repn
 from pyomo.contrib.mcpp.pyomo_mcpp import mcpp_available, McCormick
 from pyomo.contrib.fbbt.fbbt import compute_bounds_on_expr
 import pyomo.core.expr as EXPR
-from pyomo.opt import ProblemSense
 from pyomo.contrib.gdpopt.util import get_main_elapsed_time, time_code
 from pyomo.util.model_size import build_model_size_report
 from pyomo.common.dependencies import attempt_import
 from pyomo.solvers.plugins.solvers.gurobi_direct import gurobipy
 from pyomo.solvers.plugins.solvers.gurobi_persistent import GurobiPersistent
 import math
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/convert.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/dynamic_data_base.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/dynamic_data_base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/find_nearest_index.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/find_nearest_index.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/get_cuid.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/get_cuid.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/interval_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/interval_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/scalar_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/scalar_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/series_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/series_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_convert.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_find_nearest_index.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_find_nearest_index.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_get_cuid.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_get_cuid.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_interval_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_interval_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_scalar_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_scalar_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/data/tests/test_series_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/data/tests/test_series_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/model.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/run_mpc.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/run_mpc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/run_openloop.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/run_openloop.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/test_mpc.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/test_mpc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/examples/cstr/tests/test_openloop.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/examples/cstr/tests/test_openloop.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/copy_values.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/copy_values.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/load_data.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/load_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/model_interface.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/model_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/test_interface.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/test_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/tests/test_var_linker.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/tests/test_var_linker.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/interfaces/var_linker.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/interfaces/var_linker.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/constraints.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/constraints.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/cost_expressions.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/cost_expressions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/terminal.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/terminal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_cost_expressions.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_cost_expressions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_input_constraints.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_input_constraints.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/mpc/modeling/tests/test_terminal.py` & `Pyomo-6.7.2/pyomo/contrib/mpc/modeling/tests/test_terminal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/high_conf_stop.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/high_conf_stop.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/multi.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/multi.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/reinit.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/reinit.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/multistart/test_multi.py` & `Pyomo-6.7.2/pyomo/contrib/multistart/test_multi.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reaction_kinetics/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reaction_kinetics/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reaction_kinetics/simple_reaction_parmest_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reaction_kinetics/simple_reaction_parmest_example.py`

 * *Files 25% similar despite different names*

```diff
@@ -14,28 +14,30 @@
 This example shows:
 1. How to define the unknown (to be regressed parameters) with an index
 2. How to call parmest to only estimate some of the parameters (and fix the rest)
 
 Code provided by Paul Akula.
 '''
 
+import pyomo.environ as pyo
 from pyomo.environ import (
     ConcreteModel,
     Param,
     Var,
     PositiveReals,
     Objective,
     Constraint,
     RangeSet,
     Expression,
     minimize,
     exp,
     value,
 )
 import pyomo.contrib.parmest.parmest as parmest
+from pyomo.contrib.parmest.experiment import Experiment
 
 
 def simple_reaction_model(data):
     # Create the concrete model
     model = ConcreteModel()
 
     model.x1 = Param(initialize=float(data['x1']))
@@ -68,15 +70,70 @@
         return m.FirstStageCost + m.SecondStageCost
 
     model.Total_Cost_Objective = Objective(rule=total_cost_rule, sense=minimize)
 
     return model
 
 
+# For this experiment class, data is dictionary
+class SimpleReactionExperiment(Experiment):
+
+    def __init__(self, data):
+        self.data = data
+        self.model = None
+
+    def create_model(self):
+        self.model = simple_reaction_model(self.data)
+
+    def label_model(self):
+
+        m = self.model
+
+        m.experiment_outputs = pyo.Suffix(direction=pyo.Suffix.LOCAL)
+        m.experiment_outputs.update(
+            [(m.x1, self.data['x1']), (m.x2, self.data['x2']), (m.y, self.data['y'])]
+        )
+
+        return m
+
+    def get_labeled_model(self):
+        self.create_model()
+        m = self.label_model()
+
+        return m
+
+
+# k[2] fixed
+class SimpleReactionExperimentK2Fixed(SimpleReactionExperiment):
+
+    def label_model(self):
+
+        m = super().label_model()
+
+        m.unknown_parameters = pyo.Suffix(direction=pyo.Suffix.LOCAL)
+        m.unknown_parameters.update((k, pyo.ComponentUID(k)) for k in [m.k[1]])
+
+        return m
+
+
+# k[2] variable
+class SimpleReactionExperimentK2Variable(SimpleReactionExperiment):
+
+    def label_model(self):
+
+        m = super().label_model()
+
+        m.unknown_parameters = pyo.Suffix(direction=pyo.Suffix.LOCAL)
+        m.unknown_parameters.update((k, pyo.ComponentUID(k)) for k in [m.k[1], m.k[2]])
+
+        return m
+
+
 def main():
+
     # Data from Table 5.2 in  Y. Bard, "Nonlinear Parameter Estimation", (pg. 124)
     data = [
         {'experiment': 1, 'x1': 0.1, 'x2': 100, 'y': 0.98},
         {'experiment': 2, 'x1': 0.2, 'x2': 100, 'y': 0.983},
         {'experiment': 3, 'x1': 0.3, 'x2': 100, 'y': 0.955},
         {'experiment': 4, 'x1': 0.4, 'x2': 100, 'y': 0.979},
         {'experiment': 5, 'x1': 0.5, 'x2': 100, 'y': 0.993},
@@ -88,29 +145,42 @@
         {'experiment': 11, 'x1': 0.02, 'x2': 300, 'y': 0.566},
         {'experiment': 12, 'x1': 0.04, 'x2': 300, 'y': 0.317},
         {'experiment': 13, 'x1': 0.06, 'x2': 300, 'y': 0.034},
         {'experiment': 14, 'x1': 0.08, 'x2': 300, 'y': 0.016},
         {'experiment': 15, 'x1': 0.1, 'x2': 300, 'y': 0.006},
     ]
 
+    # Create an experiment list with k[2] fixed
+    exp_list = []
+    for i in range(len(data)):
+        exp_list.append(SimpleReactionExperimentK2Fixed(data[i]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
+
     # =======================================================================
     # Parameter estimation without covariance estimate
     # Only estimate the parameter k[1]. The parameter k[2] will remain fixed
     # at its initial value
-    theta_names = ['k[1]']
-    pest = parmest.Estimator(simple_reaction_model, data, theta_names)
+
+    pest = parmest.Estimator(exp_list)
     obj, theta = pest.theta_est()
     print(obj)
     print(theta)
     print()
 
+    # Create an experiment list with k[2] variable
+    exp_list = []
+    for i in range(len(data)):
+        exp_list.append(SimpleReactionExperimentK2Variable(data[i]))
+
     # =======================================================================
     # Estimate both k1 and k2 and compute the covariance matrix
-    theta_names = ['k']
-    pest = parmest.Estimator(simple_reaction_model, data, theta_names)
+    pest = parmest.Estimator(exp_list)
     n = 15  # total number of data points used in the objective (y in 15 scenarios)
     obj, theta, cov = pest.theta_est(calc_cov=True, cov_n=n)
     print(obj)
     print(theta)
     print(cov)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/bootstrap_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/confidence_region_example.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,56 +5,47 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import pandas as pd
+import pandas as pd
 from os.path import join, abspath, dirname
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-    reactor_design_model,
+    ReactorDesignExperiment,
 )
 
 
 def main():
-    # Vars to estimate
-    theta_names = ["k1", "k2", "k3"]
 
-    # Data
+    # Read in data
     file_dirname = dirname(abspath(str(__file__)))
     file_name = abspath(join(file_dirname, "reactor_data.csv"))
     data = pd.read_csv(file_name)
 
-    # Sum of squared error function
-    def SSE(model, data):
-        expr = (
-            (float(data.iloc[0]["ca"]) - model.ca) ** 2
-            + (float(data.iloc[0]["cb"]) - model.cb) ** 2
-            + (float(data.iloc[0]["cc"]) - model.cc) ** 2
-            + (float(data.iloc[0]["cd"]) - model.cd) ** 2
-        )
-        return expr
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(ReactorDesignExperiment(data, i))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
 
-    # Create an instance of the parmest estimator
-    pest = parmest.Estimator(reactor_design_model, data, theta_names, SSE)
+    pest = parmest.Estimator(exp_list, obj_function='SSE')
 
     # Parameter estimation
     obj, theta = pest.theta_est()
 
-    # Parameter estimation with bootstrap resampling
-    bootstrap_theta = pest.theta_est_bootstrap(50)
-
-    # Plot results
-    parmest.graphics.pairwise_plot(bootstrap_theta, title="Bootstrap theta")
-    parmest.graphics.pairwise_plot(
-        bootstrap_theta,
-        theta,
-        0.8,
-        ["MVN", "KDE", "Rect"],
-        title="Bootstrap theta with confidence regions",
-    )
+    # Bootstrapping
+    bootstrap_theta = pest.theta_est_bootstrap(10)
+    print(bootstrap_theta)
+
+    # Confidence region test
+    CR = pest.confidence_region_test(bootstrap_theta, "MVN", [0.5, 0.75, 1.0])
+    print(CR)
 
 
 if __name__ == "__main__":
     main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/datarec_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/likelihood_ratio_example.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,94 +6,64 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import numpy as np, pandas as pd
+from itertools import product
 import pyomo.contrib.parmest.parmest as parmest
-from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-    reactor_design_model,
+from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler import (
+    RooneyBieglerExperiment,
 )
 
-np.random.seed(1234)
-
-
-def reactor_design_model_for_datarec(data):
-    # Unfix inlet concentration for data rec
-    model = reactor_design_model(data)
-    model.caf.fixed = False
-
-    return model
-
-
-def generate_data():
-    ### Generate data based on real sv, caf, ca, cb, cc, and cd
-    sv_real = 1.05
-    caf_real = 10000
-    ca_real = 3458.4
-    cb_real = 1060.8
-    cc_real = 1683.9
-    cd_real = 1898.5
-
-    data = pd.DataFrame()
-    ndata = 200
-    # Normal distribution, mean = 3400, std = 500
-    data["ca"] = 500 * np.random.randn(ndata) + 3400
-    # Random distribution between 500 and 1500
-    data["cb"] = np.random.rand(ndata) * 1000 + 500
-    # Lognormal distribution
-    data["cc"] = np.random.lognormal(np.log(1600), 0.25, ndata)
-    # Triangular distribution between 1000 and 2000
-    data["cd"] = np.random.triangular(1000, 1800, 3000, size=ndata)
-
-    data["sv"] = sv_real
-    data["caf"] = caf_real
-
-    return data
-
 
 def main():
-    # Generate data
-    data = generate_data()
-    data_std = data.std()
 
-    # Define sum of squared error objective function for data rec
-    def SSE(model, data):
+    # Data
+    data = pd.DataFrame(
+        data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
+        columns=['hour', 'y'],
+    )
+
+    # Sum of squared error function
+    def SSE(model):
         expr = (
-            ((float(data.iloc[0]["ca"]) - model.ca) / float(data_std["ca"])) ** 2
-            + ((float(data.iloc[0]["cb"]) - model.cb) / float(data_std["cb"])) ** 2
-            + ((float(data.iloc[0]["cc"]) - model.cc) / float(data_std["cc"])) ** 2
-            + ((float(data.iloc[0]["cd"]) - model.cd) / float(data_std["cd"])) ** 2
-        )
+            model.experiment_outputs[model.y]
+            - model.response_function[model.experiment_outputs[model.hour]]
+        ) ** 2
         return expr
 
-    ### Data reconciliation
-    theta_names = []  # no variables to estimate, use initialized values
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(RooneyBieglerExperiment(data.loc[i, :]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
 
-    pest = parmest.Estimator(reactor_design_model_for_datarec, data, theta_names, SSE)
+    # Create an instance of the parmest estimator
+    pest = parmest.Estimator(exp_list, obj_function=SSE)
 
-    obj, theta, data_rec = pest.theta_est(return_values=["ca", "cb", "cc", "cd", "caf"])
-    print(obj)
-    print(theta)
-
-    parmest.graphics.grouped_boxplot(
-        data[["ca", "cb", "cc", "cd"]],
-        data_rec[["ca", "cb", "cc", "cd"]],
-        group_names=["Data", "Data Rec"],
-    )
+    # Parameter estimation
+    obj, theta = pest.theta_est()
 
-    ### Parameter estimation using reconciled data
-    theta_names = ["k1", "k2", "k3"]
-    data_rec["sv"] = data["sv"]
+    # Find the objective value at each theta estimate
+    asym = np.arange(10, 30, 2)
+    rate = np.arange(0, 1.5, 0.1)
+    theta_vals = pd.DataFrame(
+        list(product(asym, rate)), columns=['asymptote', 'rate_constant']
+    )
+    obj_at_theta = pest.objective_at_theta(theta_vals)
 
-    pest = parmest.Estimator(reactor_design_model, data_rec, theta_names, SSE)
-    obj, theta = pest.theta_est()
-    print(obj)
-    print(theta)
+    # Run the likelihood ratio test
+    LR = pest.likelihood_ratio_test(obj_at_theta, obj, [0.8, 0.85, 0.9, 0.95])
 
-    theta_real = {"k1": 5.0 / 6.0, "k2": 5.0 / 3.0, "k3": 1.0 / 6000.0}
-    print(theta_real)
+    # Plot results
+    parmest.graphics.pairwise_plot(
+        LR, theta, 0.8, title='LR results within 80% confidence region'
+    )
 
 
 if __name__ == "__main__":
     main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/leaveNout_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/leaveNout_example.py`

 * *Files 8% similar despite different names*

```diff
@@ -9,46 +9,42 @@
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import numpy as np, pandas as pd
 from os.path import join, abspath, dirname
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-    reactor_design_model,
+    ReactorDesignExperiment,
 )
 
 
 def main():
-    # Vars to estimate
-    theta_names = ["k1", "k2", "k3"]
 
-    # Data
+    # Read in data
     file_dirname = dirname(abspath(str(__file__)))
     file_name = abspath(join(file_dirname, "reactor_data.csv"))
     data = pd.read_csv(file_name)
 
     # Create more data for the example
     N = 50
     df_std = data.std().to_frame().transpose()
     df_rand = pd.DataFrame(np.random.normal(size=N))
     df_sample = data.sample(N, replace=True).reset_index(drop=True)
     data = df_sample + df_rand.dot(df_std) / 10
 
-    # Sum of squared error function
-    def SSE(model, data):
-        expr = (
-            (float(data.iloc[0]["ca"]) - model.ca) ** 2
-            + (float(data.iloc[0]["cb"]) - model.cb) ** 2
-            + (float(data.iloc[0]["cc"]) - model.cc) ** 2
-            + (float(data.iloc[0]["cd"]) - model.cd) ** 2
-        )
-        return expr
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(ReactorDesignExperiment(data, i))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
 
-    # Create an instance of the parmest estimator
-    pest = parmest.Estimator(reactor_design_model, data, theta_names, SSE)
+    pest = parmest.Estimator(exp_list, obj_function='SSE')
 
     # Parameter estimation
     obj, theta = pest.theta_est()
     print(obj)
     print(theta)
 
     ### Parameter estimation with 'leave-N-out'
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/likelihood_ratio_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/likelihood_ratio_example.py`

 * *Files 22% similar despite different names*

```diff
@@ -10,39 +10,35 @@
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import numpy as np, pandas as pd
 from itertools import product
 from os.path import join, abspath, dirname
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-    reactor_design_model,
+    ReactorDesignExperiment,
 )
 
 
 def main():
-    # Vars to estimate
-    theta_names = ["k1", "k2", "k3"]
 
-    # Data
+    # Read in data
     file_dirname = dirname(abspath(str(__file__)))
     file_name = abspath(join(file_dirname, "reactor_data.csv"))
     data = pd.read_csv(file_name)
 
-    # Sum of squared error function
-    def SSE(model, data):
-        expr = (
-            (float(data.iloc[0]["ca"]) - model.ca) ** 2
-            + (float(data.iloc[0]["cb"]) - model.cb) ** 2
-            + (float(data.iloc[0]["cc"]) - model.cc) ** 2
-            + (float(data.iloc[0]["cd"]) - model.cd) ** 2
-        )
-        return expr
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(ReactorDesignExperiment(data, i))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
 
-    # Create an instance of the parmest estimator
-    pest = parmest.Estimator(reactor_design_model, data, theta_names, SSE)
+    pest = parmest.Estimator(exp_list, obj_function='SSE')
 
     # Parameter estimation
     obj, theta = pest.theta_est()
 
     # Find the objective value at each theta estimate
     k1 = [0.8, 0.85, 0.9]
     k2 = [1.6, 1.65, 1.7]
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/reactor_design/timeseries_data_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/reactor_design/bootstrap_example.py`

 * *Files 21% similar despite different names*

```diff
@@ -7,49 +7,50 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import pandas as pd
 from os.path import join, abspath, dirname
-
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-    reactor_design_model,
+    ReactorDesignExperiment,
 )
 
 
 def main():
-    # Parameter estimation using timeseries data
-
-    # Vars to estimate
-    theta_names = ['k1', 'k2', 'k3']
 
-    # Data, includes multiple sensors for ca and cc
+    # Read in data
     file_dirname = dirname(abspath(str(__file__)))
-    file_name = abspath(join(file_dirname, 'reactor_data_timeseries.csv'))
+    file_name = abspath(join(file_dirname, "reactor_data.csv"))
     data = pd.read_csv(file_name)
 
-    # Group time series data into experiments, return the mean value for sv and caf
-    # Returns a list of dictionaries
-    data_ts = parmest.group_data(data, 'experiment', ['sv', 'caf'])
-
-    def SSE_timeseries(model, data):
-        expr = 0
-        for val in data['ca']:
-            expr = expr + ((float(val) - model.ca) ** 2) * (1 / len(data['ca']))
-        for val in data['cb']:
-            expr = expr + ((float(val) - model.cb) ** 2) * (1 / len(data['cb']))
-        for val in data['cc']:
-            expr = expr + ((float(val) - model.cc) ** 2) * (1 / len(data['cc']))
-        for val in data['cd']:
-            expr = expr + ((float(val) - model.cd) ** 2) * (1 / len(data['cd']))
-        return expr
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(ReactorDesignExperiment(data, i))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
+
+    pest = parmest.Estimator(exp_list, obj_function='SSE')
 
-    pest = parmest.Estimator(reactor_design_model, data_ts, theta_names, SSE_timeseries)
+    # Parameter estimation
     obj, theta = pest.theta_est()
-    print(obj)
-    print(theta)
+
+    # Parameter estimation with bootstrap resampling
+    bootstrap_theta = pest.theta_est_bootstrap(50)
+
+    # Plot results
+    parmest.graphics.pairwise_plot(bootstrap_theta, title="Bootstrap theta")
+    parmest.graphics.pairwise_plot(
+        bootstrap_theta,
+        theta,
+        0.8,
+        ["MVN", "KDE", "Rect"],
+        title="Bootstrap theta with confidence regions",
+    )
 
 
 if __name__ == "__main__":
     main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/bootstrap_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/bootstrap_example.py`

 * *Files 27% similar despite different names*

```diff
@@ -8,37 +8,45 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import pandas as pd
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler import (
-    rooney_biegler_model,
+    RooneyBieglerExperiment,
 )
 
 
 def main():
-    # Vars to estimate
-    theta_names = ['asymptote', 'rate_constant']
 
     # Data
     data = pd.DataFrame(
         data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
         columns=['hour', 'y'],
     )
 
     # Sum of squared error function
-    def SSE(model, data):
-        expr = sum(
-            (data.y[i] - model.response_function[data.hour[i]]) ** 2 for i in data.index
-        )
+    def SSE(model):
+        expr = (
+            model.experiment_outputs[model.y]
+            - model.response_function[model.experiment_outputs[model.hour]]
+        ) ** 2
         return expr
 
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(RooneyBieglerExperiment(data.loc[i, :]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
+
     # Create an instance of the parmest estimator
-    pest = parmest.Estimator(rooney_biegler_model, data, theta_names, SSE)
+    pest = parmest.Estimator(exp_list, obj_function=SSE)
 
     # Parameter estimation
     obj, theta = pest.theta_est()
 
     # Parameter estimation with bootstrap resampling
     bootstrap_theta = pest.theta_est_bootstrap(50, seed=4581)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/likelihood_ratio_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/parameter_estimation_example.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,57 +5,64 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import numpy as np, pandas as pd
-from itertools import product
+from pyomo.common.dependencies import pandas as pd
 import pyomo.contrib.parmest.parmest as parmest
 from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler import (
-    rooney_biegler_model,
+    RooneyBieglerExperiment,
 )
 
 
 def main():
-    # Vars to estimate
-    theta_names = ['asymptote', 'rate_constant']
 
     # Data
     data = pd.DataFrame(
         data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
         columns=['hour', 'y'],
     )
 
     # Sum of squared error function
-    def SSE(model, data):
-        expr = sum(
-            (data.y[i] - model.response_function[data.hour[i]]) ** 2 for i in data.index
-        )
+    def SSE(model):
+        expr = (
+            model.experiment_outputs[model.y]
+            - model.response_function[model.experiment_outputs[model.hour]]
+        ) ** 2
         return expr
 
-    # Create an instance of the parmest estimator
-    pest = parmest.Estimator(rooney_biegler_model, data, theta_names, SSE)
-
-    # Parameter estimation
-    obj, theta = pest.theta_est()
+    # Create an experiment list
+    exp_list = []
+    for i in range(data.shape[0]):
+        exp_list.append(RooneyBieglerExperiment(data.loc[i, :]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
 
-    # Find the objective value at each theta estimate
-    asym = np.arange(10, 30, 2)
-    rate = np.arange(0, 1.5, 0.1)
-    theta_vals = pd.DataFrame(
-        list(product(asym, rate)), columns=['asymptote', 'rate_constant']
-    )
-    obj_at_theta = pest.objective_at_theta(theta_vals)
+    # Create an instance of the parmest estimator
+    pest = parmest.Estimator(exp_list, obj_function=SSE)
 
-    # Run the likelihood ratio test
-    LR = pest.likelihood_ratio_test(obj_at_theta, obj, [0.8, 0.85, 0.9, 0.95])
+    # Parameter estimation and covariance
+    n = 6  # total number of data points used in the objective (y in 6 scenarios)
+    obj, theta, cov = pest.theta_est(calc_cov=True, cov_n=n)
 
-    # Plot results
+    # Plot theta estimates using a multivariate Gaussian distribution
     parmest.graphics.pairwise_plot(
-        LR, theta, 0.8, title='LR results within 80% confidence region'
+        (theta, cov, 100),
+        theta_star=theta,
+        alpha=0.8,
+        distributions=['MVN'],
+        title='Theta estimates within 80% confidence region',
     )
 
+    # Assert statements compare parameter estimation (theta) to an expected value
+    relative_error = abs(theta['asymptote'] - 19.1426) / 19.1426
+    assert relative_error < 0.01
+    relative_error = abs(theta['rate_constant'] - 0.5311) / 0.5311
+    assert relative_error < 0.01
+
 
 if __name__ == "__main__":
     main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/parameter_estimation_example.py` & `Pyomo-6.7.2/pyomo/opt/plugins/driver.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,56 +5,80 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import pandas as pd
-import pyomo.contrib.parmest.parmest as parmest
-from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler import (
-    rooney_biegler_model,
-)
+import argparse
+import logging
 
+import pyomo.scripting.pyomo_parser
+
+logger = logging.getLogger('pyomo.solvers')
 
-def main():
-    # Vars to estimate
-    theta_names = ['asymptote', 'rate_constant']
-
-    # Data
-    data = pd.DataFrame(
-        data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
-        columns=['hour', 'y'],
-    )
 
-    # Sum of squared error function
-    def SSE(model, data):
-        expr = sum(
-            (data.y[i] - model.response_function[data.hour[i]]) ** 2 for i in data.index
-        )
-        return expr
-
-    # Create an instance of the parmest estimator
-    pest = parmest.Estimator(rooney_biegler_model, data, theta_names, SSE)
-
-    # Parameter estimation and covariance
-    n = 6  # total number of data points used in the objective (y in 6 scenarios)
-    obj, theta, cov = pest.theta_est(calc_cov=True, cov_n=n)
-
-    # Plot theta estimates using a multivariate Gaussian distribution
-    parmest.graphics.pairwise_plot(
-        (theta, cov, 100),
-        theta_star=theta,
-        alpha=0.8,
-        distributions=['MVN'],
-        title='Theta estimates within 80% confidence region',
+def setup_test_parser(parser):
+    parser.add_argument(
+        '--csv-file',
+        '--csv',
+        action='store',
+        dest='csv',
+        default=None,
+        help='Save test results to this file in a CSV format',
+    )
+    parser.add_argument(
+        "-d",
+        "--debug",
+        action="store_true",
+        dest="debug",
+        default=False,
+        help="Show debugging information and text generated during tests.",
+    )
+    parser.add_argument(
+        "-v",
+        "--verbose",
+        action="store_true",
+        dest="verbose",
+        default=False,
+        help="Show verbose results output.",
     )
+    parser.add_argument(
+        "solver", metavar="SOLVER", default=None, nargs='*', help="a solver name"
+    )
+
+
+def test_exec(options):
+    import pyomo.solvers.tests.testcases
 
-    # Assert statements compare parameter estimation (theta) to an expected value
-    relative_error = abs(theta['asymptote'] - 19.1426) / 19.1426
-    assert relative_error < 0.01
-    relative_error = abs(theta['rate_constant'] - 0.5311) / 0.5311
-    assert relative_error < 0.01
+    pyomo.solvers.tests.testcases.run_test_scenarios(options)
 
 
-if __name__ == "__main__":
-    main()
+#
+# Add a subparser for the pyomo command
+#
+setup_test_parser(
+    pyomo.scripting.pyomo_parser.add_subparser(
+        'test-solvers',
+        func=test_exec,
+        help='Test Pyomo solvers',
+        description='This pyomo subcommand is used to run tests on installed solvers.',
+        epilog="""
+This Pyomo subcommand executes solvers on a variety of test problems that
+are defined in the pyomo.data.pyomo package.  The default behavior is to
+test all available solvers, but the testing can be limited by explicitly
+specifying the solvers that are tested.  For example:
+
+  pyomo test-solvers glpk cplex
+
+will test only the glpk and cplex solvers.
+
+The default summary is a simple table that describes the percentage of
+checks that passed.  The '-v' option can be used to provide a summary
+of all checks that failed, which is generally useful for evaluating
+solvers.  The '-d' option provides additional detail about all checks
+performed (both passed and failed checks).  Additionally, this option
+prints information about the optimization process, such as the pyomo
+command-line that was executed.""",
+        formatter_class=argparse.RawDescriptionHelpFormatter,
+    )
+)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler.py`

 * *Files 24% similar despite different names*

```diff
@@ -13,22 +13,26 @@
 Rooney Biegler model, based on Rooney, W. C. and Biegler, L. T. (2001). Design for 
 model parameter uncertainty using nonlinear confidence regions. AIChE Journal, 
 47(8), 1794-1804.
 """
 
 from pyomo.common.dependencies import pandas as pd
 import pyomo.environ as pyo
+from pyomo.contrib.parmest.experiment import Experiment
 
 
 def rooney_biegler_model(data):
     model = pyo.ConcreteModel()
 
     model.asymptote = pyo.Var(initialize=15)
     model.rate_constant = pyo.Var(initialize=0.5)
 
+    model.hour = pyo.Param(within=pyo.PositiveReals, mutable=True)
+    model.y = pyo.Param(within=pyo.PositiveReals, mutable=True)
+
     def response_rule(m, h):
         expr = m.asymptote * (1 - pyo.exp(-m.rate_constant * h))
         return expr
 
     model.response_function = pyo.Expression(data.hour, rule=response_rule)
 
     def SSE_rule(m):
@@ -37,14 +41,55 @@
         )
 
     model.SSE = pyo.Objective(rule=SSE_rule, sense=pyo.minimize)
 
     return model
 
 
+class RooneyBieglerExperiment(Experiment):
+
+    def __init__(self, data):
+        self.data = data
+        self.model = None
+
+    def create_model(self):
+        # rooney_biegler_model expects a dataframe
+        data_df = self.data.to_frame().transpose()
+        self.model = rooney_biegler_model(data_df)
+
+    def label_model(self):
+
+        m = self.model
+
+        m.experiment_outputs = pyo.Suffix(direction=pyo.Suffix.LOCAL)
+        m.experiment_outputs.update(
+            [(m.hour, self.data['hour']), (m.y, self.data['y'])]
+        )
+
+        m.unknown_parameters = pyo.Suffix(direction=pyo.Suffix.LOCAL)
+        m.unknown_parameters.update(
+            (k, pyo.ComponentUID(k)) for k in [m.asymptote, m.rate_constant]
+        )
+
+    def finalize_model(self):
+
+        m = self.model
+
+        # Experiment output values
+        m.hour = self.data['hour']
+        m.y = self.data['y']
+
+    def get_labeled_model(self):
+        self.create_model()
+        self.label_model()
+        self.finalize_model()
+
+        return self.model
+
+
 def main():
     # These were taken from Table A1.4 in Bates and Watts (1988).
     data = pd.DataFrame(
         data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
         columns=['hour', 'y'],
     )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/rooney_biegler/rooney_biegler_with_constraint.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_preprocess.py`

 * *Files 26% similar despite different names*

```diff
@@ -4,60 +4,49 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
+#
+# Unit Tests for model preprocessing
+#
+
+import os
+from os.path import abspath, dirname
+
+currdir = dirname(abspath(__file__)) + os.sep
+
+import pyomo.common.unittest as unittest
+
+from pyomo.environ import AbstractModel, Set, Param, Var, Objective
+
+
+class TestPreprocess(unittest.TestCase):
+    def Xtest_label1(self):
+        model = AbstractModel()
+        model.A = Set(initialize=[1, 2, 3])
+        model.B = Param(model.A, initialize={1: 100, 2: 200, 3: 300})
+        model.x = Var(model.A)
+        model.y = Var(model.A)
+        instance = model.create_instance()
+        instance.preprocess()
+        self.assertEqual(instance.num_used_variables(), 0)
+
+    def Xtest_label2(self):
+        model = AbstractModel()
+        model.A = Set(initialize=[1, 2, 3])
+        model.B = Param(model.A, initialize={1: 100, 2: 200, 3: 300})
+        model.x = Var(model.A)
+        model.y = Var(model.A)
+        model.obj = Objective(rule=lambda inst: inst.x[1])
+        instance = model.create_instance()
+        instance.preprocess()
+        self.assertEqual(instance.num_used_variables(), 1)
+        self.assertEqual(instance.x[1].label, "x(1)")
+        self.assertEqual(instance.x[2].label, "x(2)")
+        self.assertEqual(instance.y[1].label, "y(1)")
 
-"""
-Rooney Biegler model, based on Rooney, W. C. and Biegler, L. T. (2001). Design for
-model parameter uncertainty using nonlinear confidence regions. AIChE Journal,
-47(8), 1794-1804.
-"""
 
-from pyomo.common.dependencies import pandas as pd
-import pyomo.environ as pyo
-
-
-def rooney_biegler_model_with_constraint(data):
-    model = pyo.ConcreteModel()
-
-    model.asymptote = pyo.Var(initialize=15)
-    model.rate_constant = pyo.Var(initialize=0.5)
-    model.response_function = pyo.Var(data.hour, initialize=0.0)
-
-    # changed from expression to constraint
-    def response_rule(m, h):
-        return m.response_function[h] == m.asymptote * (
-            1 - pyo.exp(-m.rate_constant * h)
-        )
-
-    model.response_function_constraint = pyo.Constraint(data.hour, rule=response_rule)
-
-    def SSE_rule(m):
-        return sum(
-            (data.y[i] - m.response_function[data.hour[i]]) ** 2 for i in data.index
-        )
-
-    model.SSE = pyo.Objective(rule=SSE_rule, sense=pyo.minimize)
-
-    return model
-
-
-def main():
-    # These were taken from Table A1.4 in Bates and Watts (1988).
-    data = pd.DataFrame(
-        data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
-        columns=['hour', 'y'],
-    )
-
-    model = rooney_biegler_model_with_constraint(data)
-    solver = pyo.SolverFactory('ipopt')
-    solver.solve(model)
-
-    print('asymptote = ', model.asymptote())
-    print('rate constant = ', model.rate_constant())
-
-
-if __name__ == '__main__':
-    main()
+if __name__ == "__main__":
+    unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/parallel_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/parallel_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/parameter_estimation_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/parameter_estimation_example.py`

 * *Files 23% similar despite different names*

```diff
@@ -8,34 +8,41 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import json
 from os.path import join, abspath, dirname
 import pyomo.contrib.parmest.parmest as parmest
-from pyomo.contrib.parmest.examples.semibatch.semibatch import generate_model
+from pyomo.contrib.parmest.examples.semibatch.semibatch import SemiBatchExperiment
 
 
 def main():
-    # Vars to estimate
-    theta_names = ['k1', 'k2', 'E1', 'E2']
 
     # Data, list of dictionaries
     data = []
     file_dirname = dirname(abspath(str(__file__)))
     for exp_num in range(10):
         file_name = abspath(join(file_dirname, 'exp' + str(exp_num + 1) + '.out'))
         with open(file_name, 'r') as infile:
             d = json.load(infile)
             data.append(d)
 
+    # Create an experiment list
+    exp_list = []
+    for i in range(len(data)):
+        exp_list.append(SemiBatchExperiment(data[i]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
+
     # Note, the model already includes a 'SecondStageCost' expression
     # for sum of squared error that will be used in parameter estimation
 
-    pest = parmest.Estimator(generate_model, data, theta_names)
+    pest = parmest.Estimator(exp_list)
 
     obj, theta = pest.theta_est()
     print(obj)
     print(theta)
 
 
 if __name__ == '__main__':
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/scenario_example.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/scenario_example.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,32 +8,39 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import json
 from os.path import join, abspath, dirname
 import pyomo.contrib.parmest.parmest as parmest
-from pyomo.contrib.parmest.examples.semibatch.semibatch import generate_model
+from pyomo.contrib.parmest.examples.semibatch.semibatch import SemiBatchExperiment
 import pyomo.contrib.parmest.scenariocreator as sc
 
 
 def main():
-    # Vars to estimate in parmest
-    theta_names = ['k1', 'k2', 'E1', 'E2']
 
     # Data: list of dictionaries
     data = []
     file_dirname = dirname(abspath(str(__file__)))
     for exp_num in range(10):
         fname = join(file_dirname, 'exp' + str(exp_num + 1) + '.out')
         with open(fname, 'r') as infile:
             d = json.load(infile)
             data.append(d)
 
-    pest = parmest.Estimator(generate_model, data, theta_names)
+    # Create an experiment list
+    exp_list = []
+    for i in range(len(data)):
+        exp_list.append(SemiBatchExperiment(data[i]))
+
+    # View one model
+    # exp0_model = exp_list[0].get_labeled_model()
+    # exp0_model.pprint()
+
+    pest = parmest.Estimator(exp_list)
 
     scenmaker = sc.ScenarioCreator(pest, "ipopt")
 
     # Make one scenario per experiment and write to a csv file
     output_file = "scenarios.csv"
     experimentscens = sc.ScenarioSet("Experiments")
     scenmaker.ScenariosFromExperiments(experimentscens)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/examples/semibatch/semibatch.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/examples/semibatch/semibatch.py`

 * *Files 4% similar despite different names*

```diff
@@ -25,16 +25,19 @@
     ConstraintList,
     Expression,
     Objective,
     TransformationFactory,
     SolverFactory,
     exp,
     minimize,
+    Suffix,
+    ComponentUID,
 )
 from pyomo.dae import ContinuousSet, DerivativeVar
+from pyomo.contrib.parmest.experiment import Experiment
 
 
 def generate_model(data):
     # if data is a file name, then load file first
     if isinstance(data, str):
         file_name = data
         try:
@@ -264,14 +267,43 @@
 
     # Discretize model
     disc = TransformationFactory("dae.collocation")
     disc.apply_to(m, nfe=20, ncp=4)
     return m
 
 
+class SemiBatchExperiment(Experiment):
+
+    def __init__(self, data):
+        self.data = data
+        self.model = None
+
+    def create_model(self):
+        self.model = generate_model(self.data)
+
+    def label_model(self):
+
+        m = self.model
+
+        m.unknown_parameters = Suffix(direction=Suffix.LOCAL)
+        m.unknown_parameters.update(
+            (k, ComponentUID(k)) for k in [m.k1, m.k2, m.E1, m.E2]
+        )
+
+    def finalize_model(self):
+        pass
+
+    def get_labeled_model(self):
+        self.create_model()
+        self.label_model()
+        self.finalize_model()
+
+        return self.model
+
+
 def main():
     # Data loaded from files
     file_dirname = dirname(abspath(str(__file__)))
     file_name = abspath(join(file_dirname, "exp2.out"))
     with open(file_name, "r") as infile:
         data = json.load(infile)
     data["experiment"] = 2
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/graphics.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/graphics.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/ipopt_solver_wrapper.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/ipopt_solver_wrapper.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/scenariocreator.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/scenariocreator.py`

 * *Files 16% similar despite different names*

```diff
@@ -10,14 +10,18 @@
 #  ___________________________________________________________________________
 
 # ScenariosCreator.py - Class to create and deliver scenarios using parmest
 # DLW March 2020
 
 import pyomo.environ as pyo
 
+import logging
+
+logger = logging.getLogger(__name__)
+
 
 class ScenarioSet(object):
     """
     Class to hold scenario sets
 
     Args:
     name (str): name of the set (might be "")
@@ -115,52 +119,67 @@
     Args:
         pest (Estimator): the parmest object
         solvername (str): name of the solver (e.g. "ipopt")
 
     """
 
     def __init__(self, pest, solvername):
+
         self.pest = pest
         self.solvername = solvername
 
     def ScenariosFromExperiments(self, addtoSet):
         """Creates new self.Scenarios list using the experiments only.
 
         Args:
             addtoSet (ScenarioSet): the scenarios will be added to this set
         Returns:
             a ScenarioSet
         """
 
         assert isinstance(addtoSet, ScenarioSet)
 
-        scenario_numbers = list(range(len(self.pest.callback_data)))
+        if self.pest.pest_deprecated is not None:
+            scenario_numbers = list(range(len(self.pest.pest_deprecated.callback_data)))
+        else:
+            scenario_numbers = list(range(len(self.pest.exp_list)))
 
         prob = 1.0 / len(scenario_numbers)
         for exp_num in scenario_numbers:
             ##print("Experiment number=", exp_num)
-            model = self.pest._instance_creation_callback(
-                exp_num, self.pest.callback_data
-            )
+            if self.pest.pest_deprecated is not None:
+                model = self.pest.pest_deprecated._instance_creation_callback(
+                    exp_num, self.pest.pest_deprecated.callback_data
+                )
+            else:
+                model = self.pest._instance_creation_callback(exp_num)
             opt = pyo.SolverFactory(self.solvername)
             results = opt.solve(model)  # solves and updates model
             ## pyo.check_termination_optimal(results)
-            ThetaVals = dict()
-            for theta in self.pest.theta_names:
-                tvar = eval('model.' + theta)
-                tval = pyo.value(tvar)
-                ##print("    theta, tval=", tvar, tval)
-                ThetaVals[theta] = tval
+            if self.pest.pest_deprecated is not None:
+                ThetaVals = {
+                    theta: pyo.value(model.find_component(theta))
+                    for theta in self.pest.pest_deprecated.theta_names
+                }
+            else:
+                ThetaVals = {
+                    k.name: pyo.value(k) for k in model.unknown_parameters.keys()
+                }
             addtoSet.addone(ParmestScen("ExpScen" + str(exp_num), ThetaVals, prob))
 
     def ScenariosFromBootstrap(self, addtoSet, numtomake, seed=None):
         """Creates new self.Scenarios list using the experiments only.
 
         Args:
             addtoSet (ScenarioSet): the scenarios will be added to this set
             numtomake (int) : number of scenarios to create
         """
 
         assert isinstance(addtoSet, ScenarioSet)
 
-        bootstrap_thetas = self.pest.theta_est_bootstrap(numtomake, seed=seed)
+        if self.pest.pest_deprecated is not None:
+            bootstrap_thetas = self.pest.pest_deprecated.theta_est_bootstrap(
+                numtomake, seed=seed
+            )
+        else:
+            bootstrap_thetas = self.pest.theta_est_bootstrap(numtomake, seed=seed)
         addtoSet.append_bootstrap(bootstrap_thetas)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_examples.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_examples.py`

 * *Files 2% similar despite different names*

```diff
@@ -177,15 +177,18 @@
     def test_multisensor_data_example(self):
         from pyomo.contrib.parmest.examples.reactor_design import (
             multisensor_data_example,
         )
 
         multisensor_data_example.main()
 
-    @unittest.skipUnless(matplotlib_available, "test requires matplotlib")
+    @unittest.skipUnless(
+        matplotlib_available and seaborn_available,
+        "test requires matplotlib and seaborn",
+    )
     def test_datarec_example(self):
         from pyomo.contrib.parmest.examples.reactor_design import datarec_example
 
         datarec_example.main()
 
 
 if __name__ == "__main__":
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_graphics.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_graphics.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_parmest.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_sens_unit.py`

 * *Files 26% similar despite different names*

```diff
@@ -5,952 +5,886 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import (
-    numpy as np,
-    numpy_available,
-    pandas as pd,
-    pandas_available,
-    scipy,
-    scipy_available,
-    matplotlib,
-    matplotlib_available,
-)
-
-import platform
-
-is_osx = platform.mac_ver()[0] != ""
+# ____________________________________________________________________________
+#
+# Pyomo: Python Optimization Modeling Objects
+# Copyright (c) 2008-2024
+#  National Technology and Engineering Solutions of Sandia, LLC
+# Under the terms of Contract DE-NA0003525 with National Technology and
+# Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
+# rights in this software.
+# This software is distributed under the 3-clause BSD License.
+# ____________________________________________________________________________
+
+"""
+Unit Tests for interfacing with sIPOPT and k_aug
+"""
 
 import pyomo.common.unittest as unittest
-import sys
-import os
-import subprocess
-from itertools import product
-
-import pyomo.contrib.parmest.parmest as parmest
-import pyomo.contrib.parmest.graphics as graphics
-import pyomo.contrib.parmest as parmestbase
-import pyomo.environ as pyo
-import pyomo.dae as dae
+from io import StringIO
+import logging
 
+from pyomo.environ import (
+    ConcreteModel,
+    Objective,
+    Param,
+    Var,
+    Block,
+    Suffix,
+    value,
+    Constraint,
+    inequality,
+    NonNegativeReals,
+    minimize,
+    exp,
+)
+from pyomo.core.base.component import ComponentData
+from pyomo.common.dependencies import scipy_available
+from pyomo.common.log import LoggingIntercept
+from pyomo.common.collections import ComponentMap, ComponentSet
+from pyomo.core.expr.visitor import identify_variables, identify_mutable_parameters
+from pyomo.contrib.sensitivity_toolbox.sens import (
+    SensitivityInterface,
+    _NotAnIndex,
+    get_dsdp,
+    get_dfds_dcds,
+    line_num,
+)
+import pyomo.contrib.sensitivity_toolbox.examples.parameter as param_example
 from pyomo.opt import SolverFactory
 
-ipopt_available = SolverFactory("ipopt").available()
-
-from pyomo.common.fileutils import find_library
-
-pynumero_ASL_available = False if find_library("pynumero_ASL") is None else True
-
-testdir = os.path.dirname(os.path.abspath(__file__))
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
+from pyomo.common.dependencies import (
+    numpy as np,
+    numpy_available,
+    pandas as pd,
+    pandas_available,
 )
-@unittest.skipIf(not ipopt_available, "The 'ipopt' command is not available")
-class TestRooneyBiegler(unittest.TestCase):
-    def setUp(self):
-        from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler import (
-            rooney_biegler_model,
-        )
-
-        # Note, the data used in this test has been corrected to use data.loc[5,'hour'] = 7 (instead of 6)
-        data = pd.DataFrame(
-            data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
-            columns=["hour", "y"],
-        )
+from pyomo.common.dependencies import scipy_available
 
-        theta_names = ["asymptote", "rate_constant"]
-
-        def SSE(model, data):
-            expr = sum(
-                (data.y[i] - model.response_function[data.hour[i]]) ** 2
-                for i in data.index
-            )
-            return expr
-
-        solver_options = {"tol": 1e-8}
-
-        self.data = data
-        self.pest = parmest.Estimator(
-            rooney_biegler_model,
-            data,
-            theta_names,
-            SSE,
-            solver_options=solver_options,
-            tee=True,
-        )
-
-    def test_theta_est(self):
-        objval, thetavals = self.pest.theta_est()
-
-        self.assertAlmostEqual(objval, 4.3317112, places=2)
-        self.assertAlmostEqual(
-            thetavals["asymptote"], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(
-            thetavals["rate_constant"], 0.5311, places=2
-        )  # 0.5311 from the paper
-
-    @unittest.skipIf(
-        not graphics.imports_available, "parmest.graphics imports are unavailable"
+opt_ipopt = SolverFactory('ipopt', solver_io='nl')
+opt_kaug = SolverFactory('k_aug', solver_io='nl')
+opt_dotsens = SolverFactory('dot_sens', solver_io='nl')
+
+
+def make_indexed_model():
+    """
+    Creates the model used in the "parameter.py" example, but with indexed
+    variables, parameters, and constraints.
+    """
+    m = ConcreteModel()
+
+    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
+
+    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
+
+    m.const = Constraint(
+        [1, 2],
+        rule={
+            1: 6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3] - m.eta[1] == 0,
+            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 == 0,
+        },
     )
-    def test_bootstrap(self):
-        objval, thetavals = self.pest.theta_est()
-
-        num_bootstraps = 10
-        theta_est = self.pest.theta_est_bootstrap(num_bootstraps, return_samples=True)
 
-        num_samples = theta_est["samples"].apply(len)
-        self.assertTrue(len(theta_est.index), 10)
-        self.assertTrue(num_samples.equals(pd.Series([6] * 10)))
+    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
 
-        del theta_est["samples"]
+    return m
 
-        # apply confidence region test
-        CR = self.pest.confidence_region_test(theta_est, "MVN", [0.5, 0.75, 1.0])
 
-        self.assertTrue(set(CR.columns) >= set([0.5, 0.75, 1.0]))
-        self.assertTrue(CR[0.5].sum() == 5)
-        self.assertTrue(CR[0.75].sum() == 7)
-        self.assertTrue(CR[1.0].sum() == 10)  # all true
+def make_model_with_inequalities():
+    """
+    Creates a modified version of the model used in the "parameter.py"
+    example, now with simple (one-sided) inequalities.
+    """
+    m = ConcreteModel()
 
-        graphics.pairwise_plot(theta_est)
-        graphics.pairwise_plot(theta_est, thetavals)
-        graphics.pairwise_plot(theta_est, thetavals, 0.8, ["MVN", "KDE", "Rect"])
+    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
 
-    @unittest.skipIf(
-        not graphics.imports_available, "parmest.graphics imports are unavailable"
-    )
-    def test_likelihood_ratio(self):
-        objval, thetavals = self.pest.theta_est()
+    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
 
-        asym = np.arange(10, 30, 2)
-        rate = np.arange(0, 1.5, 0.25)
-        theta_vals = pd.DataFrame(
-            list(product(asym, rate)), columns=self.pest.theta_names
-        )
-
-        obj_at_theta = self.pest.objective_at_theta(theta_vals)
-
-        LR = self.pest.likelihood_ratio_test(obj_at_theta, objval, [0.8, 0.9, 1.0])
-
-        self.assertTrue(set(LR.columns) >= set([0.8, 0.9, 1.0]))
-        self.assertTrue(LR[0.8].sum() == 6)
-        self.assertTrue(LR[0.9].sum() == 10)
-        self.assertTrue(LR[1.0].sum() == 60)  # all true
-
-        graphics.pairwise_plot(LR, thetavals, 0.8)
-
-    def test_leaveNout(self):
-        lNo_theta = self.pest.theta_est_leaveNout(1)
-        self.assertTrue(lNo_theta.shape == (6, 2))
-
-        results = self.pest.leaveNout_bootstrap_test(
-            1, None, 3, "Rect", [0.5, 1.0], seed=5436
-        )
-        self.assertTrue(len(results) == 6)  # 6 lNo samples
-        i = 1
-        samples = results[i][0]  # list of N samples that are left out
-        lno_theta = results[i][1]
-        bootstrap_theta = results[i][2]
-        self.assertTrue(samples == [1])  # sample 1 was left out
-        self.assertTrue(lno_theta.shape[0] == 1)  # lno estimate for sample 1
-        self.assertTrue(set(lno_theta.columns) >= set([0.5, 1.0]))
-        self.assertTrue(lno_theta[1.0].sum() == 1)  # all true
-        self.assertTrue(bootstrap_theta.shape[0] == 3)  # bootstrap for sample 1
-        self.assertTrue(bootstrap_theta[1.0].sum() == 3)  # all true
-
-    def test_diagnostic_mode(self):
-        self.pest.diagnostic_mode = True
-
-        objval, thetavals = self.pest.theta_est()
-
-        asym = np.arange(10, 30, 2)
-        rate = np.arange(0, 1.5, 0.25)
-        theta_vals = pd.DataFrame(
-            list(product(asym, rate)), columns=self.pest.theta_names
-        )
-
-        obj_at_theta = self.pest.objective_at_theta(theta_vals)
-
-        self.pest.diagnostic_mode = False
-
-    @unittest.skip("Presently having trouble with mpiexec on appveyor")
-    def test_parallel_parmest(self):
-        """use mpiexec and mpi4py"""
-        p = str(parmestbase.__path__)
-        l = p.find("'")
-        r = p.find("'", l + 1)
-        parmestpath = p[l + 1 : r]
-        rbpath = (
-            parmestpath
-            + os.sep
-            + "examples"
-            + os.sep
-            + "rooney_biegler"
-            + os.sep
-            + "rooney_biegler_parmest.py"
-        )
-        rbpath = os.path.abspath(rbpath)  # paranoia strikes deep...
-        rlist = ["mpiexec", "--allow-run-as-root", "-n", "2", sys.executable, rbpath]
-        if sys.version_info >= (3, 5):
-            ret = subprocess.run(rlist)
-            retcode = ret.returncode
-        else:
-            retcode = subprocess.call(rlist)
-        assert retcode == 0
-
-    @unittest.skip("Most folks don't have k_aug installed")
-    def test_theta_k_aug_for_Hessian(self):
-        # this will fail if k_aug is not installed
-        objval, thetavals, Hessian = self.pest.theta_est(solver="k_aug")
-        self.assertAlmostEqual(objval, 4.4675, places=2)
-
-    @unittest.skipIf(not pynumero_ASL_available, "pynumero ASL is not available")
-    @unittest.skipIf(
-        not parmest.inverse_reduced_hessian_available,
-        "Cannot test covariance matrix: required ASL dependency is missing",
+    m.const = Constraint(
+        [1, 2],
+        rule={
+            1: 6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3] >= m.eta[1],
+            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 <= 0,
+        },
     )
-    def test_theta_est_cov(self):
-        objval, thetavals, cov = self.pest.theta_est(calc_cov=True, cov_n=6)
 
-        self.assertAlmostEqual(objval, 4.3317112, places=2)
-        self.assertAlmostEqual(
-            thetavals["asymptote"], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(
-            thetavals["rate_constant"], 0.5311, places=2
-        )  # 0.5311 from the paper
-
-        # Covariance matrix
-        self.assertAlmostEqual(
-            cov.iloc[0, 0], 6.30579403, places=2
-        )  # 6.22864 from paper
-        self.assertAlmostEqual(
-            cov.iloc[0, 1], -0.4395341, places=2
-        )  # -0.4322 from paper
-        self.assertAlmostEqual(
-            cov.iloc[1, 0], -0.4395341, places=2
-        )  # -0.4322 from paper
-        self.assertAlmostEqual(cov.iloc[1, 1], 0.04124, places=2)  # 0.04124 from paper
-
-        """ Why does the covariance matrix from parmest not match the paper? Parmest is
-        calculating the exact reduced Hessian. The paper (Rooney and Bielger, 2001) likely
-        employed the first order approximation common for nonlinear regression. The paper
-        values were verified with Scipy, which uses the same first order approximation.
-        The formula used in parmest was verified against equations (7-5-15) and (7-5-16) in
-        "Nonlinear Parameter Estimation", Y. Bard, 1974.
-        """
-
-    def test_cov_scipy_least_squares_comparison(self):
-        """
-        Scipy results differ in the 3rd decimal place from the paper. It is possible
-        the paper used an alternative finite difference approximation for the Jacobian.
-        """
-
-        def model(theta, t):
-            """
-            Model to be fitted y = model(theta, t)
-            Arguments:
-                theta: vector of fitted parameters
-                t: independent variable [hours]
-
-            Returns:
-                y: model predictions [need to check paper for units]
-            """
-            asymptote = theta[0]
-            rate_constant = theta[1]
-
-            return asymptote * (1 - np.exp(-rate_constant * t))
-
-        def residual(theta, t, y):
-            """
-            Calculate residuals
-            Arguments:
-                theta: vector of fitted parameters
-                t: independent variable [hours]
-                y: dependent variable [?]
-            """
-            return y - model(theta, t)
-
-        # define data
-        t = self.data["hour"].to_numpy()
-        y = self.data["y"].to_numpy()
-
-        # define initial guess
-        theta_guess = np.array([15, 0.5])
-
-        ## solve with optimize.least_squares
-        sol = scipy.optimize.least_squares(
-            residual, theta_guess, method="trf", args=(t, y), verbose=2
-        )
-        theta_hat = sol.x
-
-        self.assertAlmostEqual(
-            theta_hat[0], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(theta_hat[1], 0.5311, places=2)  # 0.5311 from the paper
-
-        # calculate residuals
-        r = residual(theta_hat, t, y)
-
-        # calculate variance of the residuals
-        # -2 because there are 2 fitted parameters
-        sigre = np.matmul(r.T, r / (len(y) - 2))
-
-        # approximate covariance
-        # Need to divide by 2 because optimize.least_squares scaled the objective by 1/2
-        cov = sigre * np.linalg.inv(np.matmul(sol.jac.T, sol.jac))
-
-        self.assertAlmostEqual(cov[0, 0], 6.22864, places=2)  # 6.22864 from paper
-        self.assertAlmostEqual(cov[0, 1], -0.4322, places=2)  # -0.4322 from paper
-        self.assertAlmostEqual(cov[1, 0], -0.4322, places=2)  # -0.4322 from paper
-        self.assertAlmostEqual(cov[1, 1], 0.04124, places=2)  # 0.04124 from paper
-
-    def test_cov_scipy_curve_fit_comparison(self):
-        """
-        Scipy results differ in the 3rd decimal place from the paper. It is possible
-        the paper used an alternative finite difference approximation for the Jacobian.
-        """
-
-        ## solve with optimize.curve_fit
-        def model(t, asymptote, rate_constant):
-            return asymptote * (1 - np.exp(-rate_constant * t))
-
-        # define data
-        t = self.data["hour"].to_numpy()
-        y = self.data["y"].to_numpy()
-
-        # define initial guess
-        theta_guess = np.array([15, 0.5])
-
-        theta_hat, cov = scipy.optimize.curve_fit(model, t, y, p0=theta_guess)
-
-        self.assertAlmostEqual(
-            theta_hat[0], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(theta_hat[1], 0.5311, places=2)  # 0.5311 from the paper
-
-        self.assertAlmostEqual(cov[0, 0], 6.22864, places=2)  # 6.22864 from paper
-        self.assertAlmostEqual(cov[0, 1], -0.4322, places=2)  # -0.4322 from paper
-        self.assertAlmostEqual(cov[1, 0], -0.4322, places=2)  # -0.4322 from paper
-        self.assertAlmostEqual(cov[1, 1], 0.04124, places=2)  # 0.04124 from paper
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
-)
-@unittest.skipIf(not ipopt_available, "The 'ipopt' command is not available")
-class TestModelVariants(unittest.TestCase):
-    def setUp(self):
-        self.data = pd.DataFrame(
-            data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
-            columns=["hour", "y"],
-        )
-
-        def rooney_biegler_params(data):
-            model = pyo.ConcreteModel()
-
-            model.asymptote = pyo.Param(initialize=15, mutable=True)
-            model.rate_constant = pyo.Param(initialize=0.5, mutable=True)
-
-            def response_rule(m, h):
-                expr = m.asymptote * (1 - pyo.exp(-m.rate_constant * h))
-                return expr
-
-            model.response_function = pyo.Expression(data.hour, rule=response_rule)
-
-            return model
-
-        def rooney_biegler_indexed_params(data):
-            model = pyo.ConcreteModel()
-
-            model.param_names = pyo.Set(initialize=["asymptote", "rate_constant"])
-            model.theta = pyo.Param(
-                model.param_names,
-                initialize={"asymptote": 15, "rate_constant": 0.5},
-                mutable=True,
-            )
-
-            def response_rule(m, h):
-                expr = m.theta["asymptote"] * (
-                    1 - pyo.exp(-m.theta["rate_constant"] * h)
-                )
-                return expr
-
-            model.response_function = pyo.Expression(data.hour, rule=response_rule)
-
-            return model
-
-        def rooney_biegler_vars(data):
-            model = pyo.ConcreteModel()
-
-            model.asymptote = pyo.Var(initialize=15)
-            model.rate_constant = pyo.Var(initialize=0.5)
-            model.asymptote.fixed = True  # parmest will unfix theta variables
-            model.rate_constant.fixed = True
-
-            def response_rule(m, h):
-                expr = m.asymptote * (1 - pyo.exp(-m.rate_constant * h))
-                return expr
+    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
 
-            model.response_function = pyo.Expression(data.hour, rule=response_rule)
+    return m
 
-            return model
 
-        def rooney_biegler_indexed_vars(data):
-            model = pyo.ConcreteModel()
-
-            model.var_names = pyo.Set(initialize=["asymptote", "rate_constant"])
-            model.theta = pyo.Var(
-                model.var_names, initialize={"asymptote": 15, "rate_constant": 0.5}
-            )
-            model.theta["asymptote"].fixed = (
-                True  # parmest will unfix theta variables, even when they are indexed
-            )
-            model.theta["rate_constant"].fixed = True
-
-            def response_rule(m, h):
-                expr = m.theta["asymptote"] * (
-                    1 - pyo.exp(-m.theta["rate_constant"] * h)
-                )
-                return expr
-
-            model.response_function = pyo.Expression(data.hour, rule=response_rule)
-
-            return model
-
-        def SSE(model, data):
-            expr = sum(
-                (data.y[i] - model.response_function[data.hour[i]]) ** 2
-                for i in data.index
-            )
-            return expr
-
-        self.objective_function = SSE
-
-        theta_vals = pd.DataFrame([20, 1], index=["asymptote", "rate_constant"]).T
-        theta_vals_index = pd.DataFrame(
-            [20, 1], index=["theta['asymptote']", "theta['rate_constant']"]
-        ).T
-
-        self.input = {
-            "param": {
-                "model": rooney_biegler_params,
-                "theta_names": ["asymptote", "rate_constant"],
-                "theta_vals": theta_vals,
-            },
-            "param_index": {
-                "model": rooney_biegler_indexed_params,
-                "theta_names": ["theta"],
-                "theta_vals": theta_vals_index,
-            },
-            "vars": {
-                "model": rooney_biegler_vars,
-                "theta_names": ["asymptote", "rate_constant"],
-                "theta_vals": theta_vals,
-            },
-            "vars_index": {
-                "model": rooney_biegler_indexed_vars,
-                "theta_names": ["theta"],
-                "theta_vals": theta_vals_index,
-            },
-            "vars_quoted_index": {
-                "model": rooney_biegler_indexed_vars,
-                "theta_names": ["theta['asymptote']", "theta['rate_constant']"],
-                "theta_vals": theta_vals_index,
-            },
-            "vars_str_index": {
-                "model": rooney_biegler_indexed_vars,
-                "theta_names": ["theta[asymptote]", "theta[rate_constant]"],
-                "theta_vals": theta_vals_index,
-            },
-        }
-
-    @unittest.skipIf(not pynumero_ASL_available, "pynumero ASL is not available")
-    @unittest.skipIf(
-        not parmest.inverse_reduced_hessian_available,
-        "Cannot test covariance matrix: required ASL dependency is missing",
+def make_model_with_ranged_inequalities():
+    """
+    Creates a modified version of the model used in the "parameter.py"
+    example, now with simple (one-sided) inequalities.
+    """
+    m = ConcreteModel()
+
+    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
+
+    m.p = Param(initialize=10.0, mutable=True)
+
+    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
+
+    m.const = Constraint(
+        [1, 2],
+        rule={
+            1: inequality(
+                lower=-m.eta[1],
+                body=6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3],
+                upper=m.p + m.eta[1],
+            ),
+            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 <= 0,
+        },
     )
-    def test_parmest_basics(self):
-        for model_type, parmest_input in self.input.items():
-            pest = parmest.Estimator(
-                parmest_input["model"],
-                self.data,
-                parmest_input["theta_names"],
-                self.objective_function,
-            )
-
-            objval, thetavals, cov = pest.theta_est(calc_cov=True, cov_n=6)
-
-            self.assertAlmostEqual(objval, 4.3317112, places=2)
-            self.assertAlmostEqual(
-                cov.iloc[0, 0], 6.30579403, places=2
-            )  # 6.22864 from paper
-            self.assertAlmostEqual(
-                cov.iloc[0, 1], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 0], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 1], 0.04193591, places=2
-            )  # 0.04124 from paper
-
-            obj_at_theta = pest.objective_at_theta(parmest_input["theta_vals"])
-            self.assertAlmostEqual(obj_at_theta["obj"][0], 16.531953, places=2)
-
-    def test_parmest_basics_with_initialize_parmest_model_option(self):
-        for model_type, parmest_input in self.input.items():
-            pest = parmest.Estimator(
-                parmest_input["model"],
-                self.data,
-                parmest_input["theta_names"],
-                self.objective_function,
-            )
-
-            objval, thetavals, cov = pest.theta_est(calc_cov=True, cov_n=6)
-
-            self.assertAlmostEqual(objval, 4.3317112, places=2)
-            self.assertAlmostEqual(
-                cov.iloc[0, 0], 6.30579403, places=2
-            )  # 6.22864 from paper
-            self.assertAlmostEqual(
-                cov.iloc[0, 1], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 0], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 1], 0.04193591, places=2
-            )  # 0.04124 from paper
 
-            obj_at_theta = pest.objective_at_theta(
-                parmest_input["theta_vals"], initialize_parmest_model=True
-            )
-
-            self.assertAlmostEqual(obj_at_theta["obj"][0], 16.531953, places=2)
-
-    def test_parmest_basics_with_square_problem_solve(self):
-        for model_type, parmest_input in self.input.items():
-            pest = parmest.Estimator(
-                parmest_input["model"],
-                self.data,
-                parmest_input["theta_names"],
-                self.objective_function,
-            )
-
-            obj_at_theta = pest.objective_at_theta(
-                parmest_input["theta_vals"], initialize_parmest_model=True
-            )
-
-            objval, thetavals, cov = pest.theta_est(calc_cov=True, cov_n=6)
-
-            self.assertAlmostEqual(objval, 4.3317112, places=2)
-            self.assertAlmostEqual(
-                cov.iloc[0, 0], 6.30579403, places=2
-            )  # 6.22864 from paper
-            self.assertAlmostEqual(
-                cov.iloc[0, 1], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 0], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 1], 0.04193591, places=2
-            )  # 0.04124 from paper
-
-            self.assertAlmostEqual(obj_at_theta["obj"][0], 16.531953, places=2)
-
-    def test_parmest_basics_with_square_problem_solve_no_theta_vals(self):
-        for model_type, parmest_input in self.input.items():
-            pest = parmest.Estimator(
-                parmest_input["model"],
-                self.data,
-                parmest_input["theta_names"],
-                self.objective_function,
-            )
-
-            obj_at_theta = pest.objective_at_theta(initialize_parmest_model=True)
-
-            objval, thetavals, cov = pest.theta_est(calc_cov=True, cov_n=6)
-
-            self.assertAlmostEqual(objval, 4.3317112, places=2)
-            self.assertAlmostEqual(
-                cov.iloc[0, 0], 6.30579403, places=2
-            )  # 6.22864 from paper
-            self.assertAlmostEqual(
-                cov.iloc[0, 1], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 0], -0.4395341, places=2
-            )  # -0.4322 from paper
-            self.assertAlmostEqual(
-                cov.iloc[1, 1], 0.04193591, places=2
-            )  # 0.04124 from paper
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
-)
-@unittest.skipIf(not ipopt_available, "The 'ipopt' solver is not available")
-class TestReactorDesign(unittest.TestCase):
-    def setUp(self):
-        from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-            reactor_design_model,
-        )
-
-        # Data from the design
-        data = pd.DataFrame(
-            data=[
-                [1.05, 10000, 3458.4, 1060.8, 1683.9, 1898.5],
-                [1.10, 10000, 3535.1, 1064.8, 1613.3, 1893.4],
-                [1.15, 10000, 3609.1, 1067.8, 1547.5, 1887.8],
-                [1.20, 10000, 3680.7, 1070.0, 1486.1, 1881.6],
-                [1.25, 10000, 3750.0, 1071.4, 1428.6, 1875.0],
-                [1.30, 10000, 3817.1, 1072.2, 1374.6, 1868.0],
-                [1.35, 10000, 3882.2, 1072.4, 1324.0, 1860.7],
-                [1.40, 10000, 3945.4, 1072.1, 1276.3, 1853.1],
-                [1.45, 10000, 4006.7, 1071.3, 1231.4, 1845.3],
-                [1.50, 10000, 4066.4, 1070.1, 1189.0, 1837.3],
-                [1.55, 10000, 4124.4, 1068.5, 1148.9, 1829.1],
-                [1.60, 10000, 4180.9, 1066.5, 1111.0, 1820.8],
-                [1.65, 10000, 4235.9, 1064.3, 1075.0, 1812.4],
-                [1.70, 10000, 4289.5, 1061.8, 1040.9, 1803.9],
-                [1.75, 10000, 4341.8, 1059.0, 1008.5, 1795.3],
-                [1.80, 10000, 4392.8, 1056.0, 977.7, 1786.7],
-                [1.85, 10000, 4442.6, 1052.8, 948.4, 1778.1],
-                [1.90, 10000, 4491.3, 1049.4, 920.5, 1769.4],
-                [1.95, 10000, 4538.8, 1045.8, 893.9, 1760.8],
-            ],
-            columns=["sv", "caf", "ca", "cb", "cc", "cd"],
-        )
-
-        theta_names = ["k1", "k2", "k3"]
-
-        def SSE(model, data):
-            expr = (
-                (float(data.iloc[0]["ca"]) - model.ca) ** 2
-                + (float(data.iloc[0]["cb"]) - model.cb) ** 2
-                + (float(data.iloc[0]["cc"]) - model.cc) ** 2
-                + (float(data.iloc[0]["cd"]) - model.cd) ** 2
-            )
-            return expr
+    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
 
-        solver_options = {"max_iter": 6000}
-
-        self.pest = parmest.Estimator(
-            reactor_design_model, data, theta_names, SSE, solver_options=solver_options
-        )
+    return m
 
-    def test_theta_est(self):
-        # used in data reconciliation
-        objval, thetavals = self.pest.theta_est()
 
-        self.assertAlmostEqual(thetavals["k1"], 5.0 / 6.0, places=4)
-        self.assertAlmostEqual(thetavals["k2"], 5.0 / 3.0, places=4)
-        self.assertAlmostEqual(thetavals["k3"], 1.0 / 6000.0, places=7)
-
-    def test_return_values(self):
-        objval, thetavals, data_rec = self.pest.theta_est(
-            return_values=["ca", "cb", "cc", "cd", "caf"]
-        )
-        self.assertAlmostEqual(data_rec["cc"].loc[18], 893.84924, places=3)
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
-)
-@unittest.skipIf(not ipopt_available, "The 'ipopt' solver is not available")
-class TestReactorDesign_DAE(unittest.TestCase):
-    # Based on a reactor example in `Chemical Reactor Analysis and Design Fundamentals`,
-    # https://sites.engineering.ucsb.edu/~jbraw/chemreacfun/
-    # https://sites.engineering.ucsb.edu/~jbraw/chemreacfun/fig-html/appendix/fig-A-10.html
-
-    def setUp(self):
-        def ABC_model(data):
-            ca_meas = data["ca"]
-            cb_meas = data["cb"]
-            cc_meas = data["cc"]
-
-            if isinstance(data, pd.DataFrame):
-                meas_t = data.index  # time index
-            else:  # dictionary
-                meas_t = list(ca_meas.keys())  # nested dictionary
-
-            ca0 = 1.0
-            cb0 = 0.0
-            cc0 = 0.0
-
-            m = pyo.ConcreteModel()
-
-            m.k1 = pyo.Var(initialize=0.5, bounds=(1e-4, 10))
-            m.k2 = pyo.Var(initialize=3.0, bounds=(1e-4, 10))
-
-            m.time = dae.ContinuousSet(bounds=(0.0, 5.0), initialize=meas_t)
-
-            # initialization and bounds
-            m.ca = pyo.Var(m.time, initialize=ca0, bounds=(-1e-3, ca0 + 1e-3))
-            m.cb = pyo.Var(m.time, initialize=cb0, bounds=(-1e-3, ca0 + 1e-3))
-            m.cc = pyo.Var(m.time, initialize=cc0, bounds=(-1e-3, ca0 + 1e-3))
-
-            m.dca = dae.DerivativeVar(m.ca, wrt=m.time)
-            m.dcb = dae.DerivativeVar(m.cb, wrt=m.time)
-            m.dcc = dae.DerivativeVar(m.cc, wrt=m.time)
-
-            def _dcarate(m, t):
-                if t == 0:
-                    return pyo.Constraint.Skip
-                else:
-                    return m.dca[t] == -m.k1 * m.ca[t]
-
-            m.dcarate = pyo.Constraint(m.time, rule=_dcarate)
-
-            def _dcbrate(m, t):
-                if t == 0:
-                    return pyo.Constraint.Skip
-                else:
-                    return m.dcb[t] == m.k1 * m.ca[t] - m.k2 * m.cb[t]
-
-            m.dcbrate = pyo.Constraint(m.time, rule=_dcbrate)
-
-            def _dccrate(m, t):
-                if t == 0:
-                    return pyo.Constraint.Skip
-                else:
-                    return m.dcc[t] == m.k2 * m.cb[t]
-
-            m.dccrate = pyo.Constraint(m.time, rule=_dccrate)
-
-            def ComputeFirstStageCost_rule(m):
-                return 0
-
-            m.FirstStageCost = pyo.Expression(rule=ComputeFirstStageCost_rule)
-
-            def ComputeSecondStageCost_rule(m):
-                return sum(
-                    (m.ca[t] - ca_meas[t]) ** 2
-                    + (m.cb[t] - cb_meas[t]) ** 2
-                    + (m.cc[t] - cc_meas[t]) ** 2
-                    for t in meas_t
-                )
-
-            m.SecondStageCost = pyo.Expression(rule=ComputeSecondStageCost_rule)
-
-            def total_cost_rule(model):
-                return model.FirstStageCost + model.SecondStageCost
-
-            m.Total_Cost_Objective = pyo.Objective(
-                rule=total_cost_rule, sense=pyo.minimize
-            )
-
-            disc = pyo.TransformationFactory("dae.collocation")
-            disc.apply_to(m, nfe=20, ncp=2)
-
-            return m
-
-        # This example tests data formatted in 3 ways
-        # Each format holds 1 scenario
-        # 1. dataframe with time index
-        # 2. nested dictionary {ca: {t, val pairs}, ... }
-        data = [
-            [0.000, 0.957, -0.031, -0.015],
-            [0.263, 0.557, 0.330, 0.044],
-            [0.526, 0.342, 0.512, 0.156],
-            [0.789, 0.224, 0.499, 0.310],
-            [1.053, 0.123, 0.428, 0.454],
-            [1.316, 0.079, 0.396, 0.556],
-            [1.579, 0.035, 0.303, 0.651],
-            [1.842, 0.029, 0.287, 0.658],
-            [2.105, 0.025, 0.221, 0.750],
-            [2.368, 0.017, 0.148, 0.854],
-            [2.632, -0.002, 0.182, 0.845],
-            [2.895, 0.009, 0.116, 0.893],
-            [3.158, -0.023, 0.079, 0.942],
-            [3.421, 0.006, 0.078, 0.899],
-            [3.684, 0.016, 0.059, 0.942],
-            [3.947, 0.014, 0.036, 0.991],
-            [4.211, -0.009, 0.014, 0.988],
-            [4.474, -0.030, 0.036, 0.941],
-            [4.737, 0.004, 0.036, 0.971],
-            [5.000, -0.024, 0.028, 0.985],
+class TestSensitivityInterface(unittest.TestCase):
+    def assertIsSubset(self, s1, s2):
+        for item in s1:
+            self.assertIn(item, s2)
+
+    def test_get_names(self):
+        block_name = SensitivityInterface.get_default_block_name()
+        self.assertEqual(block_name, "_SENSITIVITY_TOOLBOX_DATA")
+
+        var_name = 'var'
+        sens_var_name = SensitivityInterface.get_default_var_name(var_name)
+        self.assertEqual(sens_var_name, var_name)
+
+        param_name = 'param'
+        sens_param_name = SensitivityInterface.get_default_param_name(param_name)
+        self.assertEqual(sens_param_name, param_name)
+
+    def test_constructor_clone(self):
+        model = param_example.create_model()
+        sens = SensitivityInterface(model)
+        self.assertIs(sens._original_model, model)
+        self.assertIsNot(sens.model_instance, model)
+
+    def test_constructor_no_clone(self):
+        model = param_example.create_model()
+        sens = SensitivityInterface(model, clone_model=False)
+        self.assertIs(sens._original_model, model)
+        self.assertIs(sens.model_instance, model)
+
+    def test_add_data_block(self):
+        model = param_example.create_model()
+        sens = SensitivityInterface(model, clone_model=False)
+
+        block = sens._add_data_block()
+        self.assertIs(sens.block.parent_block(), sens.model_instance)
+        self.assertIs(sens.block.ctype, Block)
+        self.assertEqual(sens.block.local_name, sens.get_default_block_name())
+
+        with self.assertRaises(RuntimeError) as ex:
+            sens._add_data_block()
+        # We just tried adding the same block twice.
+        self.assertIn("Cannot add component", str(ex.exception))
+
+        # Try re-adding the same block, but this time we are prepared
+        # for it to already exist.
+        new_block = sens._add_data_block(existing_block=block)
+        self.assertIsNot(block, new_block)
+
+        new_block._has_replaced_expressions = True
+        with self.assertRaises(RuntimeError) as ex:
+            sens._add_data_block(existing_block=new_block)
+        # Cannot remove and re-add sensitivity block if expressions
+        # were replaced.
+        self.assertIn("Re-using sensitivity interface", str(ex.exception))
+
+    def test_process_param_list(self):
+        model = make_indexed_model()
+        sens = SensitivityInterface(model, clone_model=False)
+
+        param_list = [model.x[1], model.eta]
+        new_param_list = sens._process_param_list(param_list)
+        self.assertIs(param_list, new_param_list)
+
+        sens = SensitivityInterface(model, clone_model=True)
+        new_param_list = sens._process_param_list(param_list)
+        # The new param list contains the "same" variables in the
+        # cloned model.
+        self.assertIs(new_param_list[0], sens.model_instance.x[1])
+        self.assertIs(new_param_list[1], sens.model_instance.eta)
+
+    def test_add_sensitivity_data(self):
+        model = make_indexed_model()
+        sens = SensitivityInterface(model, clone_model=False)
+        sens._add_data_block()
+
+        param_list = [model.x, model.eta]
+        with self.assertRaises(ValueError) as exc:
+            sens._add_sensitivity_data(param_list)
+        self.assertIn("variables must be fixed", str(exc.exception))
+
+        sens.model_instance.x.fix()
+        # NOTE: sending the same component twice probably shouldn't
+        # be supported. It is convenient for testing, however.
+        param_list = [model.x, model.x[1], model.eta, model.eta[1]]
+        sens._add_sensitivity_data(param_list)
+
+        block_param_list = list(sens.block.component_data_objects(Param))
+        block_var_list = list(sens.block.component_data_objects(Var))
+        self.assertEqual(len(block_param_list), 4)
+        self.assertEqual(len(block_var_list), 3)
+        self.assertEqual(len(sens.block._sens_data_list), 7)
+
+        pred_sens_data_list = [
+            (model.x[1], Param, 0, 1),
+            (model.x[2], Param, 0, 2),
+            (model.x[3], Param, 0, 3),
+            (model.x[1], Param, 1, _NotAnIndex),
+            (Var, model.eta[1], 2, 1),
+            (Var, model.eta[2], 2, 2),
+            (Var, model.eta[1], 3, _NotAnIndex),
         ]
-        data = pd.DataFrame(data, columns=["t", "ca", "cb", "cc"])
-        data_df = data.set_index("t")
-        data_dict = {
-            "ca": {k: v for (k, v) in zip(data.t, data.ca)},
-            "cb": {k: v for (k, v) in zip(data.t, data.cb)},
-            "cc": {k: v for (k, v) in zip(data.t, data.cc)},
-        }
-
-        theta_names = ["k1", "k2"]
-
-        self.pest_df = parmest.Estimator(ABC_model, [data_df], theta_names)
-        self.pest_dict = parmest.Estimator(ABC_model, [data_dict], theta_names)
 
-        # Estimator object with multiple scenarios
-        self.pest_df_multiple = parmest.Estimator(
-            ABC_model, [data_df, data_df], theta_names
-        )
-        self.pest_dict_multiple = parmest.Estimator(
-            ABC_model, [data_dict, data_dict], theta_names
-        )
-
-        # Create an instance of the model
-        self.m_df = ABC_model(data_df)
-        self.m_dict = ABC_model(data_dict)
-
-    def test_dataformats(self):
-        obj1, theta1 = self.pest_df.theta_est()
-        obj2, theta2 = self.pest_dict.theta_est()
-
-        self.assertAlmostEqual(obj1, obj2, places=6)
-        self.assertAlmostEqual(theta1["k1"], theta2["k1"], places=6)
-        self.assertAlmostEqual(theta1["k2"], theta2["k2"], places=6)
-
-    def test_return_continuous_set(self):
-        """
-        test if ContinuousSet elements are returned correctly from theta_est()
-        """
-        obj1, theta1, return_vals1 = self.pest_df.theta_est(return_values=["time"])
-        obj2, theta2, return_vals2 = self.pest_dict.theta_est(return_values=["time"])
-        self.assertAlmostEqual(return_vals1["time"].loc[0][18], 2.368, places=3)
-        self.assertAlmostEqual(return_vals2["time"].loc[0][18], 2.368, places=3)
-
-    def test_return_continuous_set_multiple_datasets(self):
-        """
-        test if ContinuousSet elements are returned correctly from theta_est()
-        """
-        obj1, theta1, return_vals1 = self.pest_df_multiple.theta_est(
-            return_values=["time"]
-        )
-        obj2, theta2, return_vals2 = self.pest_dict_multiple.theta_est(
-            return_values=["time"]
-        )
-        self.assertAlmostEqual(return_vals1["time"].loc[1][18], 2.368, places=3)
-        self.assertAlmostEqual(return_vals2["time"].loc[1][18], 2.368, places=3)
-
-    def test_covariance(self):
-        from pyomo.contrib.interior_point.inverse_reduced_hessian import (
-            inv_reduced_hessian_barrier,
-        )
-
-        # Number of datapoints.
-        # 3 data components (ca, cb, cc), 20 timesteps, 1 scenario = 60
-        # In this example, this is the number of data points in data_df, but that's
-        # only because the data is indexed by time and contains no additional information.
-        n = 60
-
-        # Compute covariance using parmest
-        obj, theta, cov = self.pest_df.theta_est(calc_cov=True, cov_n=n)
-
-        # Compute covariance using interior_point
-        vars_list = [self.m_df.k1, self.m_df.k2]
-        solve_result, inv_red_hes = inv_reduced_hessian_barrier(
-            self.m_df, independent_variables=vars_list, tee=True
-        )
-        l = len(vars_list)
-        cov_interior_point = 2 * obj / (n - l) * inv_red_hes
-        cov_interior_point = pd.DataFrame(
-            cov_interior_point, ["k1", "k2"], ["k1", "k2"]
-        )
-
-        cov_diff = (cov - cov_interior_point).abs().sum().sum()
-
-        self.assertTrue(cov.loc["k1", "k1"] > 0)
-        self.assertTrue(cov.loc["k2", "k2"] > 0)
-        self.assertAlmostEqual(cov_diff, 0, places=6)
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
-)
-@unittest.skipIf(not ipopt_available, "The 'ipopt' command is not available")
-class TestSquareInitialization_RooneyBiegler(unittest.TestCase):
-    def setUp(self):
-        from pyomo.contrib.parmest.examples.rooney_biegler.rooney_biegler_with_constraint import (
-            rooney_biegler_model_with_constraint,
-        )
-
-        # Note, the data used in this test has been corrected to use data.loc[5,'hour'] = 7 (instead of 6)
-        data = pd.DataFrame(
-            data=[[1, 8.3], [2, 10.3], [3, 19.0], [4, 16.0], [5, 15.6], [7, 19.8]],
-            columns=["hour", "y"],
-        )
-
-        theta_names = ["asymptote", "rate_constant"]
-
-        def SSE(model, data):
-            expr = sum(
-                (data.y[i] - model.response_function[data.hour[i]]) ** 2
-                for i in data.index
-            )
-            return expr
-
-        solver_options = {"tol": 1e-8}
-
-        self.data = data
-        self.pest = parmest.Estimator(
-            rooney_biegler_model_with_constraint,
-            data,
-            theta_names,
-            SSE,
-            solver_options=solver_options,
-            tee=True,
-        )
-
-    def test_theta_est_with_square_initialization(self):
-        obj_init = self.pest.objective_at_theta(initialize_parmest_model=True)
-        objval, thetavals = self.pest.theta_est()
-
-        self.assertAlmostEqual(objval, 4.3317112, places=2)
-        self.assertAlmostEqual(
-            thetavals["asymptote"], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(
-            thetavals["rate_constant"], 0.5311, places=2
-        )  # 0.5311 from the paper
-
-    def test_theta_est_with_square_initialization_and_custom_init_theta(self):
-        theta_vals_init = pd.DataFrame(
-            data=[[19.0, 0.5]], columns=["asymptote", "rate_constant"]
-        )
-        obj_init = self.pest.objective_at_theta(
-            theta_values=theta_vals_init, initialize_parmest_model=True
-        )
-        objval, thetavals = self.pest.theta_est()
-        self.assertAlmostEqual(objval, 4.3317112, places=2)
-        self.assertAlmostEqual(
-            thetavals["asymptote"], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(
-            thetavals["rate_constant"], 0.5311, places=2
-        )  # 0.5311 from the paper
-
-    def test_theta_est_with_square_initialization_diagnostic_mode_true(self):
-        self.pest.diagnostic_mode = True
-        obj_init = self.pest.objective_at_theta(initialize_parmest_model=True)
-        objval, thetavals = self.pest.theta_est()
-
-        self.assertAlmostEqual(objval, 4.3317112, places=2)
-        self.assertAlmostEqual(
-            thetavals["asymptote"], 19.1426, places=2
-        )  # 19.1426 from the paper
-        self.assertAlmostEqual(
-            thetavals["rate_constant"], 0.5311, places=2
-        )  # 0.5311 from the paper
-
-        self.pest.diagnostic_mode = False
+        for data, pred in zip(sens.block._sens_data_list, pred_sens_data_list):
+            if isinstance(pred[0], ComponentData):
+                self.assertIs(data[0], pred[0])
+                self.assertIs(data[1].ctype, pred[1])
+                name = data[0].parent_component().local_name
+                self.assertTrue(data[1].parent_component().local_name.startswith(name))
+            else:
+                self.assertIs(data[0].ctype, pred[0])
+                self.assertIs(data[1], pred[1])
+                name = data[1].parent_component().local_name
+                self.assertTrue(data[0].parent_component().local_name.startswith(name))
+            self.assertEqual(data[2], pred[2])
+            self.assertEqual(data[3], pred[3])
+
+    def test_expression_replacement_no_replacement(self):
+        model = make_indexed_model()
+        sens = SensitivityInterface(model, clone_model=False)
+        sens._add_data_block()
+        instance = sens.model_instance
+        block = sens.block
+        instance.x.fix()
+        param_list = [instance.x[1], instance.x[2], instance.x[3]]
+        sens._add_sensitivity_data(param_list)
+
+        self.assertEqual(len(block.constList), 0)
+        variable_sub_map = {}
+        sens._replace_parameters_in_constraints(variable_sub_map)
+        self.assertEqual(len(block.constList), 2)
+
+        # Rely on order of constraints here... Fine as long as
+        # component_data_objects iteration is deterministic
+        pred_const_list = [instance.const[1], instance.const[2]]
+        for orig, replaced in zip(pred_const_list, block.constList.values()):
+            self.assertEqual(orig.expr.to_string(), replaced.expr.to_string())
+            self.assertFalse(orig.active)
+            self.assertTrue(replaced.active)
+
+    def test_expression_replacement_equality(self):
+        model = make_indexed_model()
+        sens = SensitivityInterface(model, clone_model=False)
+        sens._add_data_block()
+        instance = sens.model_instance
+        block = sens.block
+        instance.x.fix()
+        param_list = [instance.eta[1], instance.eta[2]]
+        sens._add_sensitivity_data(param_list)
+
+        orig_components = list(
+            instance.component_data_objects(Constraint, active=True)
+        ) + list(instance.component_data_objects(Objective, active=True))
+        orig_expr = [con.expr for con in orig_components]
+
+        # These will be modified to account for expected replacements
+        expected_variables = ComponentMap(
+            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
+        )
+        expected_parameters = ComponentMap(
+            (con, ComponentSet(identify_mutable_parameters(con.expr)))
+            for con in orig_components
+        )
+
+        # As constructed by the `setup_sensitivity` method:
+        variable_sub_map = dict(
+            (id(param), var)
+            for var, param, list_idx, _ in block._sens_data_list
+            if param_list[list_idx].ctype is Param
+        )
+        # Sanity check
+        self.assertEqual(len(variable_sub_map), 2)
+
+        # Map each param to the var that should replace it
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in block._sens_data_list
+        )
+
+        # Remove parameters we expect to replace and add vars
+        # we expect to replace with.
+        for con in orig_components:
+            for param in param_var_map:
+                if param in expected_parameters[con]:
+                    expected_variables[con].add(param_var_map[param])
+                    expected_parameters[con].remove(param)
+
+        # We check that the new components (Constraints and Objectives) contain
+        # the expected parameters and variables.
+        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
+        self.assertEqual(len(block.constList), 2)
+        for con in block.constList.values():
+            self.assertTrue(con.active)
+            param_set = ComponentSet(identify_mutable_parameters(con.expr))
+            var_set = ComponentSet(identify_variables(con.expr))
+            orig_con = replaced[con]
+            self.assertIsNot(orig_con, con)
+            self.assertEqual(param_set, expected_parameters[orig_con])
+            self.assertEqual(var_set, expected_variables[orig_con])
+
+        self.assertIs(block.cost.ctype, Objective)
+        obj = block.cost
+        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
+        var_set = ComponentSet(identify_variables(obj.expr))
+        orig_obj = replaced[obj]
+        self.assertIsNot(orig_obj, obj)
+        self.assertEqual(param_set, expected_parameters[orig_obj])
+        self.assertEqual(var_set, expected_variables[orig_obj])
+
+        # Original components were deactivated but otherwise not altered
+        for con, expr in zip(orig_components, orig_expr):
+            self.assertFalse(con.active)
+            # self.assertIs(con.expr, expr)
+            # ^Why does this fail?
+            self.assertEqual(con.expr.to_string(), expr.to_string())
+
+    def test_expression_replacement_inequality(self):
+        model = make_model_with_inequalities()
+        sens = SensitivityInterface(model, clone_model=False)
+        sens._add_data_block()
+        instance = sens.model_instance
+        block = sens.block
+        instance.x.fix()
+        param_list = [instance.eta[1], instance.eta[2]]
+        sens._add_sensitivity_data(param_list)
+
+        orig_components = list(
+            instance.component_data_objects(Constraint, active=True)
+        ) + list(instance.component_data_objects(Objective, active=True))
+        orig_expr = [con.expr for con in orig_components]
+
+        # These will be modified to account for expected replacements
+        expected_variables = ComponentMap(
+            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
+        )
+        expected_parameters = ComponentMap(
+            (con, ComponentSet(identify_mutable_parameters(con.expr)))
+            for con in orig_components
+        )
+
+        # As constructed by the `setup_sensitivity` method:
+        variable_sub_map = dict(
+            (id(param), var)
+            for var, param, list_idx, _ in block._sens_data_list
+            if param_list[list_idx].ctype is Param
+        )
+        # Sanity check
+        self.assertEqual(len(variable_sub_map), 2)
+
+        # Map each param to the var that should replace it
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in block._sens_data_list
+        )
+
+        # Remove parameters we expect to replace and add vars
+        # we expect to replace with.
+        for con in orig_components:
+            for param in param_var_map:
+                if param in expected_parameters[con]:
+                    expected_variables[con].add(param_var_map[param])
+                    expected_parameters[con].remove(param)
+
+        # We check that the new components (Constraints and Objectives) contain
+        # the expected parameters and variables.
+        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
+        self.assertEqual(len(block.constList), 2)
+        for con in block.constList.values():
+            self.assertTrue(con.active)
+            param_set = ComponentSet(identify_mutable_parameters(con.expr))
+            var_set = ComponentSet(identify_variables(con.expr))
+            orig_con = replaced[con]
+            self.assertIsNot(orig_con, con)
+            self.assertEqual(param_set, expected_parameters[orig_con])
+            self.assertEqual(var_set, expected_variables[orig_con])
+
+        self.assertIs(block.cost.ctype, Objective)
+        obj = block.cost
+        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
+        var_set = ComponentSet(identify_variables(obj.expr))
+        orig_obj = replaced[obj]
+        self.assertIsNot(orig_obj, obj)
+        self.assertEqual(param_set, expected_parameters[orig_obj])
+        self.assertEqual(var_set, expected_variables[orig_obj])
+
+        # Original components were deactivated but otherwise not altered
+        for con, expr in zip(orig_components, orig_expr):
+            self.assertFalse(con.active)
+            # self.assertIs(con.expr, expr)
+            # ^Why does this fail?
+            self.assertEqual(con.expr.to_string(), expr.to_string())
+
+    def test_expression_replacement_ranged_inequality(self):
+        model = make_model_with_ranged_inequalities()
+        sens = SensitivityInterface(model, clone_model=False)
+        sens._add_data_block()
+        instance = sens.model_instance
+        block = sens.block
+        instance.x.fix()
+        param_list = [instance.eta[1], instance.eta[2]]
+        sens._add_sensitivity_data(param_list)
+
+        orig_components = list(
+            instance.component_data_objects(Constraint, active=True)
+        ) + list(instance.component_data_objects(Objective, active=True))
+        orig_expr = [con.expr for con in orig_components]
+
+        # These will be modified to account for expected replacements
+        expected_variables = ComponentMap(
+            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
+        )
+        expected_parameters = ComponentMap(
+            (con, ComponentSet(identify_mutable_parameters(con.expr)))
+            for con in orig_components
+        )
+
+        # As constructed by the `setup_sensitivity` method:
+        variable_sub_map = dict(
+            (id(param), var)
+            for var, param, list_idx, _ in block._sens_data_list
+            if param_list[list_idx].ctype is Param
+        )
+        # Sanity check
+        self.assertEqual(len(variable_sub_map), 2)
+
+        # Map each param to the var that should replace it
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in block._sens_data_list
+        )
+
+        # Remove parameters we expect to replace and add vars
+        # we expect to replace with.
+        for con in orig_components:
+            for param in param_var_map:
+                if param in expected_parameters[con]:
+                    expected_variables[con].add(param_var_map[param])
+                    expected_parameters[con].remove(param)
+
+        # We check that the new components (Constraints and Objectives) contain
+        # the expected parameters and variables.
+        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
+        # With ranged inequalities, we end up with more constraints than we
+        # started with:
+        self.assertEqual(len(block.constList), 3)
+
+        for con in block.constList.values():
+            self.assertTrue(con.active)
+            param_set = ComponentSet(identify_mutable_parameters(con.expr))
+            var_set = ComponentSet(identify_variables(con.expr))
+            orig_con = replaced[con]
+            self.assertIsNot(orig_con, con)
+            # Note that for ranged inequalities, it is not valid to check
+            # that the two sets are equal as a mutable parameter could be
+            # contained in only one "sub-inequality"
+            self.assertIsSubset(param_set, expected_parameters[orig_con])
+            self.assertEqual(var_set, expected_variables[orig_con])
+
+        self.assertIs(block.cost.ctype, Objective)
+        obj = block.cost
+        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
+        var_set = ComponentSet(identify_variables(obj.expr))
+        orig_obj = replaced[obj]
+        self.assertIsNot(orig_obj, obj)
+        self.assertEqual(param_set, expected_parameters[orig_obj])
+        self.assertEqual(var_set, expected_variables[orig_obj])
+
+        # Original components were deactivated but otherwise not altered
+        for con, expr in zip(orig_components, orig_expr):
+            self.assertFalse(con.active)
+            # self.assertIs(con.expr, expr)
+            # ^Why does this fail?
+            self.assertEqual(con.expr.to_string(), expr.to_string())
+
+    def test_param_const(self):
+        model = make_indexed_model()
+        param_list = [model.eta[1], model.eta[2]]
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+
+        block = sens.block
+        param_const = block.paramConst
+        self.assertEqual(len(param_list), len(block.paramConst))
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in block._sens_data_list
+        )
+        var_list = [param_var_map[param] for param in param_list]
+
+        # Here we rely on the order of paramConst
+        for param, var, con in zip(param_list, var_list, param_const.values()):
+            self.assertEqual(con.body.to_string(), (var - param).to_string())
+
+    def test_param_const_indexed(self):
+        model = make_indexed_model()
+        param_list = [model.eta]
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+
+        block = sens.block
+        param_const = block.paramConst
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in block._sens_data_list
+        )
+
+        for con in param_const.values():
+            var_list = list(identify_variables(con.expr))
+            mut_param_list = list(identify_mutable_parameters(con.expr))
+            self.assertEqual(len(var_list), 1)
+            self.assertEqual(len(mut_param_list), 1)
+            self.assertIs(var_list[0], param_var_map[mut_param_list[0]])
+            self.assertEqual(
+                con.body.to_string(), (var_list[0] - mut_param_list[0]).to_string()
+            )
+
+    def test_param_const_vars(self):
+        model = make_indexed_model()
+        model.x.fix()
+        var_list = [model.x[2], model.x[1]]
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(var_list)
+
+        block = sens.block
+        param_const = block.paramConst
+        self.assertEqual(len(var_list), len(block.paramConst))
+
+        var_param_map = ComponentMap(
+            (var, param) for var, param, _, _ in block._sens_data_list
+        )
+        param_list = [var_param_map[var] for var in var_list]
+
+        # Here we rely on the order of paramConst
+        for param, var, con in zip(param_list, var_list, param_const.values()):
+            self.assertEqual(con.body.to_string(), (var - param).to_string())
+
+    def test_suffixes_setup(self):
+        model = make_indexed_model()
+        param_list = [model.eta[2], model.eta[1]]
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+
+        for i, (var, _, _, _) in enumerate(sens.block._sens_data_list):
+            con = sens.block.paramConst[i + 1]
+            self.assertEqual(model.sens_state_0[var], i + 1)
+            self.assertEqual(model.sens_state_1[var], i + 1)
+            self.assertEqual(model.sens_init_constr[con], i + 1)
+            self.assertEqual(model.dcdp[con], i + 1)
+
+        self.assertIs(type(model.sens_sol_state_1_z_L), Suffix)
+        self.assertIs(type(model.sens_sol_state_1_z_U), Suffix)
+        self.assertIs(type(model.ipopt_zL_out), Suffix)
+        self.assertIs(type(model.ipopt_zU_out), Suffix)
+        self.assertIs(type(model.ipopt_zL_in), Suffix)
+        self.assertIs(type(model.ipopt_zU_in), Suffix)
+        self.assertIs(type(model.dual), Suffix)
+        self.assertIs(type(model.DeltaP), Suffix)
+
+    def test_perturb_parameters_unindexed(self):
+        delta = 1.0
+        model = make_indexed_model()
+        param_list = [model.eta[1], model.eta[2]]
+        model.perturbed_eta = Param(
+            [1, 2],
+            mutable=True,
+            initialize={i: p.value + delta for i, p in model.eta.items()},
+        )
+        ptb_list = [model.perturbed_eta[1], model.perturbed_eta[2]]
+
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+        sens.perturb_parameters(ptb_list)
+        instance = sens.model_instance
+        block = sens.block
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in sens.block._sens_data_list
+        )
+        param_con_map = ComponentMap(
+            (param, block.paramConst[i + 1])
+            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
+        )
+        for param, ptb in zip(param_list, ptb_list):
+            var = param_var_map[param]
+            con = param_con_map[param]
+            self.assertEqual(instance.sens_state_value_1[var], ptb.value)
+            self.assertEqual(instance.DeltaP[con], -delta)
+
+    def test_perturb_parameters_scalar(self):
+        delta = 1.0
+        model = make_indexed_model()
+        param_list = [model.eta[1], model.eta[2]]
+        model.perturbed_eta = Param(
+            [1, 2],
+            mutable=True,
+            initialize={i: p.value + delta for i, p in model.eta.items()},
+        )
+        ptb_list = [model.perturbed_eta[1].value, model.perturbed_eta[2].value]
+
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+        sens.perturb_parameters(ptb_list)
+        instance = sens.model_instance
+        block = sens.block
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in sens.block._sens_data_list
+        )
+        param_con_map = ComponentMap(
+            (param, block.paramConst[i + 1])
+            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
+        )
+        for param, ptb in zip(param_list, ptb_list):
+            var = param_var_map[param]
+            con = param_con_map[param]
+            self.assertEqual(instance.sens_state_value_1[var], ptb)
+            self.assertEqual(instance.DeltaP[con], -delta)
+
+    def test_perturb_parameters_indexed(self):
+        delta = 1.0
+        model = make_indexed_model()
+        param_list = [model.eta]
+        model.perturbed_eta = Param(
+            [1, 2],
+            mutable=True,
+            initialize={i: p.value + delta for i, p in model.eta.items()},
+        )
+        ptb_list = [model.perturbed_eta]
+
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+        sens.perturb_parameters(ptb_list)
+        instance = sens.model_instance
+        block = sens.block
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in sens.block._sens_data_list
+        )
+        param_con_map = ComponentMap(
+            (param, block.paramConst[i + 1])
+            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
+        )
+        for param, ptb in zip(param_list, ptb_list):
+            for idx in param:
+                obj = param[idx]
+                ptb_data = ptb[idx]
+                var = param_var_map[obj]
+                con = param_con_map[obj]
+                self.assertEqual(instance.sens_state_value_1[var], ptb_data.value)
+                self.assertEqual(instance.DeltaP[con], -delta)
+
+    def test_perturb_indexed_parameters_with_scalar(self):
+        model = make_indexed_model()
+        param_list = [model.eta]
+        ptb_list = [10.0]
+
+        sens = SensitivityInterface(model, clone_model=False)
+        sens.setup_sensitivity(param_list)
+        sens.perturb_parameters(ptb_list)
+        instance = sens.model_instance
+        block = sens.block
+
+        param_var_map = ComponentMap(
+            (param, var) for var, param, _, _ in sens.block._sens_data_list
+        )
+        param_con_map = ComponentMap(
+            (param, block.paramConst[i + 1])
+            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
+        )
+        for param, ptb in zip(param_list, ptb_list):
+            for idx in param:
+                obj = param[idx]
+                var = param_var_map[obj]
+                con = param_con_map[obj]
+                self.assertEqual(instance.sens_state_value_1[var], ptb)
+                self.assertEqual(instance.DeltaP[con], obj.value - ptb)
+
+    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
+    @unittest.skipIf(not opt_ipopt.available(False), "ipopt is not available")
+    @unittest.skipIf(not scipy_available, "scipy is not available")
+    def test_get_dsdp1(self):
+        '''
+        It tests the function get_dsdp with a simple nonlinear programming example.
+
+        min f: p1*x1+ p2*(x2^2) + p1*p2
+         s.t c1: x1 = p1
+             c2: x2 = p2
+             c3: 10 <= p1 <= 10
+             c4: 5 <= p2 <= 5
+        '''
+        variable_name = ['p1', 'p2']
+
+        m = ConcreteModel()
+        m.x1 = Var(initialize=0)
+        m.x2 = Var(initialize=0)
+        m.p1 = Var(initialize=0)
+        m.p2 = Var(initialize=0)
+        m.obj = Objective(
+            expr=m.x1 * m.p1 + m.x2 * m.x2 * m.p2 + m.p1 * m.p2, sense=minimize
+        )
+        m.c1 = Constraint(expr=m.x1 == m.p1)
+        m.c2 = Constraint(expr=m.x2 == m.p2)
+        theta = {'p1': 10.0, 'p2': 5.0}
+        for v in variable_name:
+            getattr(m, v).setlb(theta[v])
+            getattr(m, v).setub(theta[v])
+        dsdp, col = get_dsdp(m, variable_name, theta)
+        ref = {'x1': [1.0, 0.0], 'x2': [0.0, 1.0], 'p1': [1.0, 0.0], 'p2': [0.0, 1.0]}
+        np.testing.assert_almost_equal(
+            dsdp.toarray(), np.vstack([ref[c] for c in col]).transpose()
+        )
+
+    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
+    @unittest.skipIf(not opt_ipopt.available(False), "ipopt is not available")
+    @unittest.skipIf(not scipy_available, "scipy is not available")
+    def test_get_dsdp2(self):
+        '''
+        It tests the function get_dsdp with rooney & biegler's model.
+        '''
+        variable_name = ['asymptote', 'rate_constant']
+
+        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
+        cov = np.array([[6.30579403, -0.4395341], [-0.4395341, 0.04193591]])
+        model_uncertain = ConcreteModel()
+        model_uncertain.asymptote = Var(initialize=15)
+        model_uncertain.rate_constant = Var(initialize=0.5)
+        model_uncertain.obj = Objective(
+            expr=model_uncertain.asymptote
+            * (1 - exp(-model_uncertain.rate_constant * 10)),
+            sense=minimize,
+        )
+        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
+        for v in variable_name:
+            getattr(model_uncertain, v).setlb(theta[v])
+            getattr(model_uncertain, v).setub(theta[v])
+        dsdp, col = get_dsdp(model_uncertain, variable_name, theta, {})
+        np.testing.assert_almost_equal(dsdp.toarray(), [[1.0, 0.0], [0.0, 1.0]])
+        assert col == ['asymptote', 'rate_constant']
+
+    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
+    @unittest.skipIf(not opt_dotsens.available(False), "dot_sens is not available")
+    @unittest.skipIf(not scipy_available, "scipy is not available")
+    def test_get_dfds_dcds(self):
+        '''
+        It tests the function get_sensitivity with a simple nonlinear programming example.
+
+        min f: p1*x1+ p2*(x2^2) + p1*p2
+         s.t c1: x1 = p1
+             c2: x2 = p2
+             c3: 10 <= p1 <= 10
+             c4: 5 <= p2 <= 5
+        '''
+        variable_name = ['p1', 'p2']
+
+        m = ConcreteModel()
+        m.x1 = Var(initialize=0)
+        m.x2 = Var(initialize=0)
+        m.p1 = Var(initialize=0)
+        m.p2 = Var(initialize=0)
+        m.obj = Objective(
+            expr=m.x1 * m.p1 + m.x2 * m.x2 * m.p2 + m.p1 * m.p2, sense=minimize
+        )
+        m.c1 = Constraint(expr=m.x1 == m.p1)
+        m.c2 = Constraint(expr=m.x2 == m.p2)
+        theta = {'p1': 10.0, 'p2': 5.0}
+        for v in variable_name:
+            getattr(m, v).setlb(theta[v])
+            getattr(m, v).setub(theta[v])
+        gradient_f, gradient_c, col, row, line_dic = get_dfds_dcds(m, variable_name)
+
+        ref_f = {'x1': [10.0], 'x2': [50.0], 'p1': [15.0], 'p2': [35.0]}
+        ref_c = {
+            'x1': [1.0, 0.0],
+            'x2': [0.0, 1.0],
+            'p1': [-1.0, 0.0],
+            'p2': [0.0, -1.0],
+        }
+        np.testing.assert_almost_equal(gradient_f, np.hstack([ref_f[v] for v in col]))
+        np.testing.assert_almost_equal(
+            gradient_c.toarray(), np.vstack([ref_c[v] for v in col]).transpose()
+        )
+
+    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
+    @unittest.skipIf(not opt_dotsens.available(False), "dot_sens is not available")
+    @unittest.skipIf(not scipy_available, "scipy is not available")
+    def test_get_dfds_dcds2(self):
+        '''
+        It tests the function get_sensitivity with rooney & biegler's model.
+        '''
+        variable_name = ['asymptote', 'rate_constant']
+        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
+        cov = np.array([[6.30579403, -0.4395341], [-0.4395341, 0.04193591]])
+        model_uncertain = ConcreteModel()
+        model_uncertain.asymptote = Var(initialize=15)
+        model_uncertain.rate_constant = Var(initialize=0.5)
+        model_uncertain.obj = Objective(
+            expr=model_uncertain.asymptote
+            * (1 - exp(-model_uncertain.rate_constant * 10)),
+            sense=minimize,
+        )
+        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
+        for v in variable_name:
+            getattr(model_uncertain, v).setlb(theta[v])
+            getattr(model_uncertain, v).setub(theta[v])
+        gradient_f, gradient_c, col, row, line_dic = get_dfds_dcds(
+            model_uncertain, variable_name
+        )
+        np.testing.assert_almost_equal(gradient_f, [0.99506259, 0.945148])
+        np.testing.assert_almost_equal(gradient_c, np.array([]))
+        assert col == ['asymptote', 'rate_constant']
+        assert row == ['obj']
+
+    def test_line_num1(self):
+        '''
+        It tests the function line_num
+        '''
+        import os
+
+        file_name = "test_col.col"
+        with open(file_name, "w") as file:
+            file.write("var1\n")
+            file.write("var3\n")
+        i = line_num(file_name, 'var1')
+        j = line_num(file_name, 'var3')
+        self.assertEqual(i, 1)
+        self.assertEqual(j, 2)
+
+    def test_line_num2(self):
+        '''
+        It tests an exception error when file does not include target
+        '''
+        import os
+
+        file_name = "test_col.col"
+        with open(file_name, "w") as file:
+            file.write("var1\n")
+            file.write("var3\n")
+        with self.assertRaises(Exception) as context:
+            i = line_num(file_name, 'var2')
+        self.assertTrue('test_col.col does not include var2' in str(context.exception))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_solver.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/tests/test_solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/tests/test_utils.py` & `Pyomo-6.7.2/pyomo/contrib/incidence_analysis/tests/test_visualize.py`

 * *Files 27% similar despite different names*

```diff
@@ -5,64 +5,43 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.common.dependencies import pandas as pd, pandas_available
-
-import pyomo.environ as pyo
 import pyomo.common.unittest as unittest
-import pyomo.contrib.parmest.parmest as parmest
-from pyomo.opt import SolverFactory
-
-ipopt_available = SolverFactory("ipopt").available()
-
-
-@unittest.skipIf(
-    not parmest.parmest_available,
-    "Cannot test parmest: required dependencies are missing",
+from pyomo.common.dependencies import (
+    matplotlib,
+    matplotlib_available,
+    scipy_available,
+    networkx_available,
+)
+from pyomo.contrib.incidence_analysis.visualize import spy_dulmage_mendelsohn
+from pyomo.contrib.incidence_analysis.tests.models_for_testing import (
+    make_gas_expansion_model,
+    make_dynamic_model,
+    make_degenerate_solid_phase_model,
 )
-@unittest.skipIf(not ipopt_available, "The 'ipopt' solver is not available")
-class TestUtils(unittest.TestCase):
-    @classmethod
-    def setUpClass(self):
-        pass
-
-    @classmethod
-    def tearDownClass(self):
-        pass
-
-    @unittest.pytest.mark.expensive
-    def test_convert_param_to_var(self):
-        from pyomo.contrib.parmest.examples.reactor_design.reactor_design import (
-            reactor_design_model,
-        )
-
-        data = pd.DataFrame(
-            data=[
-                [1.05, 10000, 3458.4, 1060.8, 1683.9, 1898.5],
-                [1.10, 10000, 3535.1, 1064.8, 1613.3, 1893.4],
-                [1.15, 10000, 3609.1, 1067.8, 1547.5, 1887.8],
-            ],
-            columns=["sv", "caf", "ca", "cb", "cc", "cd"],
-        )
-
-        theta_names = ["k1", "k2", "k3"]
-
-        instance = reactor_design_model(data.loc[0])
-        solver = pyo.SolverFactory("ipopt")
-        solver.solve(instance)
 
-        instance_vars = parmest.utils.convert_params_to_vars(
-            instance, theta_names, fix_vars=True
-        )
-        solver.solve(instance_vars)
 
-        assert instance.k1() == instance_vars.k1()
-        assert instance.k2() == instance_vars.k2()
-        assert instance.k3() == instance_vars.k3()
+@unittest.skipUnless(matplotlib_available, "Matplotlib is not available")
+@unittest.skipUnless(scipy_available, "SciPy is not available")
+@unittest.skipUnless(networkx_available, "NetworkX is not available")
+class TestSpy(unittest.TestCase):
+    def test_spy_dulmage_mendelsohn(self):
+        models = [
+            make_gas_expansion_model(),
+            make_dynamic_model(),
+            make_degenerate_solid_phase_model(),
+        ]
+        for m in models:
+            fig, ax = spy_dulmage_mendelsohn(m)
+            # Note that this is a weak test. We just test that we can call the
+            # plot method, it doesn't raise an error, and gives us back the
+            # types we expect. We don't attempt to validate the resulting plot.
+            self.assertTrue(isinstance(fig, matplotlib.pyplot.Figure))
+            self.assertTrue(isinstance(ax, matplotlib.pyplot.Axes))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/create_ef.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/create_ef.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/ipopt_solver_wrapper.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/ipopt_solver_wrapper.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/model_utils.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/model_utils.py`

 * *Files 6% similar despite different names*

```diff
@@ -11,14 +11,15 @@
 
 import logging
 
 import pyomo.environ as pyo
 from pyomo.core.expr import replace_expressions, identify_mutable_parameters
 from pyomo.core.base.var import IndexedVar
 from pyomo.core.base.param import IndexedParam
+from pyomo.common.collections import ComponentMap
 
 from pyomo.environ import ComponentUID
 
 logger = logging.getLogger(__name__)
 
 
 def convert_params_to_vars(model, param_names=None, fix_vars=False):
@@ -45,14 +46,15 @@
     if param_names is None:
         param_names = [param.name for param in model.component_data_objects(pyo.Param)]
 
     indexed_param_names = []
 
     # Convert Params to Vars, unfix Vars, and create a substitution map
     substitution_map = {}
+    comp_map = ComponentMap()
     for i, param_name in enumerate(param_names):
         # Leverage the parser in ComponentUID to locate the component.
         theta_cuid = ComponentUID(param_name)
         theta_object = theta_cuid.find_component_on(model)
 
         # Param
         if theta_object.is_parameter_type():
@@ -61,14 +63,15 @@
             model.del_component(theta_object)
             model.add_component(theta_object.name, pyo.Var(initialize=vals[None]))
 
             # Update substitution map
             theta_var_cuid = ComponentUID(theta_object.name)
             theta_var_object = theta_var_cuid.find_component_on(model)
             substitution_map[id(theta_object)] = theta_var_object
+            comp_map[theta_object] = theta_var_object
 
         # Indexed Param
         elif isinstance(theta_object, IndexedParam):
             # Delete Param, add Var
             # Before deleting the Param, create a list of the indexed param names
             vals = theta_object.extract_values()
             param_theta_objects = []
@@ -86,25 +89,27 @@
             model.add_component(
                 theta_object.name, pyo.Var(index_object, initialize=vals)
             )
 
             # Update substitution map (map each indexed param to indexed var)
             theta_var_cuid = ComponentUID(theta_object.name)
             theta_var_object = theta_var_cuid.find_component_on(model)
+            comp_map[theta_object] = theta_var_object
             var_theta_objects = []
             for theta_obj in theta_var_object:
                 theta_cuid = ComponentUID(
                     theta_var_object.name + '[' + str(theta_obj) + ']'
                 )
                 var_theta_objects.append(theta_cuid.find_component_on(model))
 
             for param_theta_obj, var_theta_obj in zip(
                 param_theta_objects, var_theta_objects
             ):
                 substitution_map[id(param_theta_obj)] = var_theta_obj
+                comp_map[param_theta_obj] = var_theta_obj
 
         # Var or Indexed Var
         elif isinstance(theta_object, IndexedVar) or theta_object.is_variable_type():
             theta_var_object = theta_object
 
         else:
             logger.warning("%s is not a Param or Var on the model", (param_name))
@@ -178,13 +183,22 @@
         if obj.active and any(
             v.name in param_names for v in identify_mutable_parameters(obj)
         ):
             expr = replace_expressions(expr=obj.expr, substitution_map=substitution_map)
             model.del_component(obj)
             model.add_component(obj.name, pyo.Objective(rule=expr, sense=obj.sense))
 
+    # Convert Params to Vars in Suffixes
+    for s in model.component_objects(pyo.Suffix):
+        current_keys = list(s.keys())
+        for c in current_keys:
+            if c in comp_map:
+                s[comp_map[c]] = s.pop(c)
+
+        assert len(current_keys) == len(s.keys())
+
     # print('--- Updated Model ---')
     # model.pprint()
     # solver = pyo.SolverFactory('ipopt')
     # solver.solve(model)
 
     return model
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/mpi_utils.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/mpi_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/parmest/utils/scenario_tree.py` & `Pyomo-6.7.2/pyomo/contrib/parmest/utils/scenario_tree.py`

 * *Files 1% similar despite different names*

```diff
@@ -21,15 +21,15 @@
 """
 
 import pyomo.environ as pyo
 
 
 def build_vardatalist(self, model, varlist=None):
     """
-    Convert a list of pyomo variables to a list of ScalarVar and _GeneralVarData. If varlist is none, builds a
+    Convert a list of pyomo variables to a list of ScalarVar and VarData. If varlist is none, builds a
     list of all variables in the model. The new list is stored in the vars_to_tighten attribute. By CD Laird
 
     Parameters
     ----------
     model: ConcreteModel
     varlist: None or list of pyo.Var
     """
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/__init__.py`

 * *Files 5% similar despite different names*

```diff
@@ -29,7 +29,13 @@
 )
 from pyomo.contrib.piecewise.transform.reduced_inner_representation_gdp import (
     ReducedInnerRepresentationGDPTransformation,
 )
 from pyomo.contrib.piecewise.transform.convex_combination import (
     ConvexCombinationTransformation,
 )
+from pyomo.contrib.piecewise.transform.nested_inner_repn import (
+    NestedInnerRepresentationGDPTransformation,
+)
+from pyomo.contrib.piecewise.transform.disaggregated_logarithmic import (
+    DisaggregatedLogarithmicMIPTransformation,
+)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/piecewise_linear_expression.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/piecewise_linear_expression.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/piecewise_linear_function.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/piecewise_linear_function.py`

 * *Files 0% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 from pyomo.common.collections import ComponentMap
 from pyomo.common.dependencies import numpy as np
 from pyomo.common.dependencies.scipy import spatial
 from pyomo.contrib.piecewise.piecewise_linear_expression import (
     PiecewiseLinearExpression,
 )
 from pyomo.core import Any, NonNegativeIntegers, value, Var
-from pyomo.core.base.block import _BlockData, Block
+from pyomo.core.base.block import BlockData, Block
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.expression import Expression
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.indexed_component import UnindexedComponent_set
 from pyomo.core.base.initializer import Initializer
 import pyomo.core.expr as EXPR
 
@@ -32,19 +32,19 @@
 # enough, but we need to make sure that 'barely negative' values are assumed to
 # be zero.
 ZERO_TOLERANCE = 1e-8
 
 logger = logging.getLogger(__name__)
 
 
-class PiecewiseLinearFunctionData(_BlockData):
+class PiecewiseLinearFunctionData(BlockData):
     _Block_reserved_words = Any
 
     def __init__(self, component=None):
-        _BlockData.__init__(self, component)
+        BlockData.__init__(self, component)
 
         with self._declare_reserved_components():
             self._expressions = Expression(NonNegativeIntegers)
             self._transformed_exprs = ComponentMap()
             self._simplices = None
             # These will always be tuples, even when we only have one dimension.
             self._points = []
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/common_tests.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/common_tests.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/models.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/models.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_inner_repn_gdp.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_nested_inner_repn_gdp.py`

 * *Files 16% similar despite different names*

```diff
@@ -8,171 +8,128 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.common.unittest as unittest
 from pyomo.contrib.piecewise.tests import models
 import pyomo.contrib.piecewise.tests.common_tests as ct
+import pyomo.contrib.piecewise.tests.common_inner_repn_tests as inner_repn_tests
 from pyomo.core.base import TransformationFactory
-from pyomo.core.expr.compare import (
-    assertExpressionsEqual,
-    assertExpressionsStructurallyEqual,
-)
-from pyomo.gdp import Disjunct, Disjunction
-from pyomo.environ import Constraint, SolverFactory, Var
-
-
-class TestTransformPiecewiseModelToInnerRepnGDP(unittest.TestCase):
-    def check_log_disjunct(self, d, pts, f, substitute_var, x):
-        self.assertEqual(len(d.component_map(Constraint)), 3)
-        # lambdas and indicator_var
-        self.assertEqual(len(d.component_map(Var)), 2)
-        self.assertIsInstance(d.lambdas, Var)
-        self.assertEqual(len(d.lambdas), 2)
-        for lamb in d.lambdas.values():
-            self.assertEqual(lamb.lb, 0)
-            self.assertEqual(lamb.ub, 1)
-        self.assertIsInstance(d.convex_combo, Constraint)
-        assertExpressionsEqual(
-            self, d.convex_combo.expr, d.lambdas[0] + d.lambdas[1] == 1
-        )
-        self.assertIsInstance(d.set_substitute, Constraint)
-        assertExpressionsEqual(
-            self, d.set_substitute.expr, substitute_var == f(x), places=7
-        )
-        self.assertIsInstance(d.linear_combo, Constraint)
-        self.assertEqual(len(d.linear_combo), 1)
-        assertExpressionsEqual(
-            self,
-            d.linear_combo[0].expr,
-            x == pts[0] * d.lambdas[0] + pts[1] * d.lambdas[1],
-        )
-
-    def check_paraboloid_disjunct(self, d, pts, f, substitute_var, x1, x2):
-        self.assertEqual(len(d.component_map(Constraint)), 3)
-        # lambdas and indicator_var
-        self.assertEqual(len(d.component_map(Var)), 2)
-        self.assertIsInstance(d.lambdas, Var)
-        self.assertEqual(len(d.lambdas), 3)
-        for lamb in d.lambdas.values():
-            self.assertEqual(lamb.lb, 0)
-            self.assertEqual(lamb.ub, 1)
-        self.assertIsInstance(d.convex_combo, Constraint)
-        assertExpressionsEqual(
-            self, d.convex_combo.expr, d.lambdas[0] + d.lambdas[1] + d.lambdas[2] == 1
-        )
-        self.assertIsInstance(d.set_substitute, Constraint)
-        assertExpressionsEqual(
-            self, d.set_substitute.expr, substitute_var == f(x1, x2), places=7
-        )
-        self.assertIsInstance(d.linear_combo, Constraint)
-        self.assertEqual(len(d.linear_combo), 2)
-        assertExpressionsEqual(
-            self,
-            d.linear_combo[0].expr,
-            x1
-            == pts[0][0] * d.lambdas[0]
-            + pts[1][0] * d.lambdas[1]
-            + pts[2][0] * d.lambdas[2],
-        )
-        assertExpressionsEqual(
-            self,
-            d.linear_combo[1].expr,
-            x2
-            == pts[0][1] * d.lambdas[0]
-            + pts[1][1] * d.lambdas[1]
-            + pts[2][1] * d.lambdas[2],
-        )
+from pyomo.environ import SolverFactory, Var, Constraint
+from pyomo.gdp import Disjunction, Disjunct
+from pyomo.core.expr.compare import assertExpressionsEqual
+
 
+# Test the nested inner repn gdp model using the common_tests code
+class TestTransformPiecewiseModelToNestedInnerRepnGDP(unittest.TestCase):
+    # Check the structure of the log PWLF Block
     def check_pw_log(self, m):
-        ##
-        # Check the transformation of the approximation of log(x)
-        ##
         z = m.pw_log.get_transformation_var(m.log_expr)
         self.assertIsInstance(z, Var)
         # Now we can use those Vars to check on what the transformation created
         log_block = z.parent_block()
-        ct.check_trans_block_structure(self, log_block)
 
-        # Check that all of the Disjuncts have what they should
-        self.assertEqual(len(log_block.disjuncts), 3)
-        disjuncts_dict = {
-            log_block.disjuncts[0]: ((1, 3), m.f1),
-            log_block.disjuncts[1]: ((3, 6), m.f2),
-            log_block.disjuncts[2]: ((6, 10), m.f3),
-        }
-        for d, (pts, f) in disjuncts_dict.items():
-            self.check_log_disjunct(d, pts, f, log_block.substitute_var, m.x)
-
-        # Check the Disjunction
-        self.assertIsInstance(log_block.pick_a_piece, Disjunction)
-        self.assertEqual(len(log_block.pick_a_piece.disjuncts), 3)
-        for i in range(2):
-            self.assertIs(log_block.pick_a_piece.disjuncts[i], log_block.disjuncts[i])
+        # Not using ct.check_trans_block_structure() because these are slightly
+        # different
+        # Two top-level disjuncts
+        self.assertEqual(len(log_block.component_map(Disjunct)), 2)
+        # One disjunction
+        self.assertEqual(len(log_block.component_map(Disjunction)), 1)
+        # The 'z' var (that we will substitute in for the function being
+        # approximated) is here:
+        self.assertEqual(len(log_block.component_map(Var)), 1)
+        self.assertIsInstance(log_block.substitute_var, Var)
+
+        # Check the tree structure, which should be heavier on the right
+        # Parent disjunction
+        self.assertIsInstance(log_block.disj, Disjunction)
+        self.assertEqual(len(log_block.disj.disjuncts), 2)
+
+        # Left disjunct with constraints
+        self.assertIsInstance(log_block.d_l, Disjunct)
+        inner_repn_tests.check_log_disjunct(
+            self, log_block.d_l, (1, 3), m.f1, log_block.substitute_var, m.x
+        )
+
+        # Right disjunct with disjunction
+        self.assertIsInstance(log_block.d_r, Disjunct)
+        self.assertIsInstance(log_block.d_r.inner_disjunction_r, Disjunction)
+        self.assertEqual(len(log_block.d_r.inner_disjunction_r.disjuncts), 2)
+
+        # Left and right child disjuncts with constraints
+        self.assertIsInstance(log_block.d_r.d_l, Disjunct)
+        inner_repn_tests.check_log_disjunct(
+            self, log_block.d_r.d_l, (3, 6), m.f2, log_block.substitute_var, m.x
+        )
+        self.assertIsInstance(log_block.d_r.d_r, Disjunct)
+        inner_repn_tests.check_log_disjunct(
+            self, log_block.d_r.d_r, (6, 10), m.f3, log_block.substitute_var, m.x
+        )
 
-        # And check the substitute Var is in the objective now.
+        # Check that this also became the objective
         self.assertIs(m.obj.expr.expr, log_block.substitute_var)
 
+    # Check the structure of the paraboloid PWLF block
     def check_pw_paraboloid(self, m):
-        ##
-        # Check the approximation of the transformation of the paraboloid
-        ##
         z = m.pw_paraboloid.get_transformation_var(m.paraboloid_expr)
         self.assertIsInstance(z, Var)
         paraboloid_block = z.parent_block()
-        ct.check_trans_block_structure(self, paraboloid_block)
 
-        self.assertEqual(len(paraboloid_block.disjuncts), 4)
+        # Two top-level disjuncts
+        self.assertEqual(len(paraboloid_block.component_map(Disjunct)), 2)
+        # One disjunction
+        self.assertEqual(len(paraboloid_block.component_map(Disjunction)), 1)
+        # The 'z' var (that we will substitute in for the function being
+        # approximated) is here:
+        self.assertEqual(len(paraboloid_block.component_map(Var)), 1)
+        self.assertIsInstance(paraboloid_block.substitute_var, Var)
+
+        # This one should have an even tree with four leaf disjuncts
         disjuncts_dict = {
-            paraboloid_block.disjuncts[0]: ([(0, 1), (0, 4), (3, 4)], m.g1),
-            paraboloid_block.disjuncts[1]: ([(0, 1), (3, 4), (3, 1)], m.g1),
-            paraboloid_block.disjuncts[2]: ([(3, 4), (3, 7), (0, 7)], m.g2),
-            paraboloid_block.disjuncts[3]: ([(0, 7), (0, 4), (3, 4)], m.g2),
+            paraboloid_block.d_l.d_l: ([(0, 1), (0, 4), (3, 4)], m.g1),
+            paraboloid_block.d_l.d_r: ([(0, 1), (3, 4), (3, 1)], m.g1),
+            paraboloid_block.d_r.d_l: ([(3, 4), (3, 7), (0, 7)], m.g2),
+            paraboloid_block.d_r.d_r: ([(0, 7), (0, 4), (3, 4)], m.g2),
         }
         for d, (pts, f) in disjuncts_dict.items():
-            self.check_paraboloid_disjunct(
-                d, pts, f, paraboloid_block.substitute_var, m.x1, m.x2
-            )
-
-        # Check the Disjunction
-        self.assertIsInstance(paraboloid_block.pick_a_piece, Disjunction)
-        self.assertEqual(len(paraboloid_block.pick_a_piece.disjuncts), 4)
-        for i in range(3):
-            self.assertIs(
-                paraboloid_block.pick_a_piece.disjuncts[i],
-                paraboloid_block.disjuncts[i],
+            inner_repn_tests.check_paraboloid_disjunct(
+                self, d, pts, f, paraboloid_block.substitute_var, m.x1, m.x2
             )
 
         # And check the substitute Var is in the objective now.
         self.assertIs(m.indexed_c[0].body.args[0].expr, paraboloid_block.substitute_var)
 
+    # Test methods using the common_tests.py code. Copied in from test_inner_repn_gdp.py.
     def test_transformation_do_not_descend(self):
-        ct.check_transformation_do_not_descend(self, 'contrib.piecewise.inner_repn_gdp')
+        ct.check_transformation_do_not_descend(
+            self, 'contrib.piecewise.nested_inner_repn_gdp'
+        )
 
     def test_transformation_PiecewiseLinearFunction_targets(self):
         ct.check_transformation_PiecewiseLinearFunction_targets(
-            self, 'contrib.piecewise.inner_repn_gdp'
+            self, 'contrib.piecewise.nested_inner_repn_gdp'
         )
 
     def test_descend_into_expressions(self):
-        ct.check_descend_into_expressions(self, 'contrib.piecewise.inner_repn_gdp')
+        ct.check_descend_into_expressions(
+            self, 'contrib.piecewise.nested_inner_repn_gdp'
+        )
 
     def test_descend_into_expressions_constraint_target(self):
         ct.check_descend_into_expressions_constraint_target(
-            self, 'contrib.piecewise.inner_repn_gdp'
+            self, 'contrib.piecewise.nested_inner_repn_gdp'
         )
 
     def test_descend_into_expressions_objective_target(self):
         ct.check_descend_into_expressions_objective_target(
-            self, 'contrib.piecewise.inner_repn_gdp'
+            self, 'contrib.piecewise.nested_inner_repn_gdp'
         )
 
+    # Check the solution of the log(x) model
     @unittest.skipUnless(SolverFactory('gurobi').available(), 'Gurobi is not available')
     @unittest.skipUnless(SolverFactory('gurobi').license_is_valid(), 'No license')
-    def test_solve_disaggregated_convex_combo_model(self):
+    def test_solve_log_model(self):
         m = models.make_log_x_model()
-        TransformationFactory(
-            'contrib.piecewise.disaggregated_convex_combination'
-        ).apply_to(m)
-        SolverFactory('gurobi').solve(m)
-
+        TransformationFactory("contrib.piecewise.nested_inner_repn_gdp").apply_to(m)
+        TransformationFactory("gdp.bigm").apply_to(m)
+        SolverFactory("gurobi").solve(m)
         ct.check_log_x_model_soln(self, m)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_outer_repn_gdp.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_outer_repn_gdp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_piecewise_linear_function.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_piecewise_linear_function.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/tests/test_reduced_inner_repn.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/tests/test_reduced_inner_repn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/convex_combination.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/convex_combination.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/disaggregated_convex_combination.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/disaggregated_convex_combination.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/inner_representation_gdp.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/inner_representation_gdp.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,30 +6,30 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.contrib.fbbt.fbbt import compute_bounds_on_expr
-from pyomo.contrib.piecewise.transform.piecewise_to_gdp_transformation import (
-    PiecewiseLinearToGDP,
+from pyomo.contrib.piecewise.transform.piecewise_linear_transformation_base import (
+    PiecewiseLinearTransformationBase,
 )
 from pyomo.core import Constraint, NonNegativeIntegers, Suffix, Var
 from pyomo.core.base import TransformationFactory
 from pyomo.gdp import Disjunct, Disjunction
 
 
 @TransformationFactory.register(
     'contrib.piecewise.inner_repn_gdp',
     doc="Convert piecewise-linear model to a GDP "
     "using an inner representation of the "
     "simplices that are the domains of the linear "
     "functions.",
 )
-class InnerRepresentationGDPTransformation(PiecewiseLinearToGDP):
+class InnerRepresentationGDPTransformation(PiecewiseLinearTransformationBase):
     """
     Convert a model involving piecewise linear expressions into a GDP by
     representing the piecewise linear functions as Disjunctions where the
     simplices over which the linear functions are defined are represented
     in an "inner" representation--as convex combinations of their extreme
     points. The multipliers defining the convex combination are local to
     each Disjunct, so there is one per extreme point in each simplex.
@@ -45,15 +45,15 @@
            efficient, but will respect hierarchical structure by finding
            uses of PiecewiseLinearFunctions in Constraint and Obective
            expressions and putting their transformed counterparts on the same
            parent Block as the component owning their parent expression. In
            this mode, targets must be Blocks, Constraints, and/or Objectives.
     """
 
-    CONFIG = PiecewiseLinearToGDP.CONFIG()
+    CONFIG = PiecewiseLinearTransformationBase.CONFIG()
     _transformation_name = 'pw_linear_inner_repn'
 
     def _transform_pw_linear_expr(self, pw_expr, pw_linear_func, transformation_block):
         transBlock = transformation_block.transformed_functions[
             len(transformation_block.transformed_functions)
         ]
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/multiple_choice.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/multiple_choice.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/outer_representation_gdp.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/outer_representation_gdp.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,30 +8,30 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.common.dependencies.numpy as np
 from pyomo.common.dependencies.scipy import spatial
 from pyomo.contrib.fbbt.fbbt import compute_bounds_on_expr
-from pyomo.contrib.piecewise.transform.piecewise_to_gdp_transformation import (
-    PiecewiseLinearToGDP,
+from pyomo.contrib.piecewise.transform.piecewise_linear_transformation_base import (
+    PiecewiseLinearTransformationBase,
 )
 from pyomo.core import Constraint, NonNegativeIntegers, Suffix, Var
 from pyomo.core.base import TransformationFactory
 from pyomo.gdp import Disjunct, Disjunction
 
 
 @TransformationFactory.register(
     'contrib.piecewise.outer_repn_gdp',
     doc="Convert piecewise-linear model to a GDP "
     "using an outer (Ax <= b) representation of "
     "the simplices that are the domains of the "
     "linear functions.",
 )
-class OuterRepresentationGDPTransformation(PiecewiseLinearToGDP):
+class OuterRepresentationGDPTransformation(PiecewiseLinearTransformationBase):
     """
     Convert a model involving piecewise linear expressions into a GDP by
     representing the piecewise linear functions as Disjunctions where the
     simplices over which the linear functions are defined are represented
     in an "outer" representation--in sets of constraints of the form Ax <= b.
 
     This transformation can be called in one of two ways:
@@ -45,15 +45,15 @@
            efficient, but will respect hierarchical structure by finding
            uses of PiecewiseLinearFunctions in Constraint and Obective
            expressions and putting their transformed counterparts on the same
            parent Block as the component owning their parent expression. In
            this mode, targets must be Blocks, Constraints, and/or Objectives.
     """
 
-    CONFIG = PiecewiseLinearToGDP.CONFIG()
+    CONFIG = PiecewiseLinearTransformationBase.CONFIG()
     _transformation_name = 'pw_linear_outer_repn'
 
     def _transform_pw_linear_expr(self, pw_expr, pw_linear_func, transformation_block):
         transBlock = transformation_block.transformed_functions[
             len(transformation_block.transformed_functions)
         ]
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/piecewise_to_gdp_transformation.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/piecewise_linear_transformation_base.py`

 * *Files 1% similar despite different names*

```diff
@@ -29,22 +29,22 @@
     RangeSet,
     ExternalFunction,
     Connector,
     SortComponents,
     Any,
 )
 from pyomo.core.base import Transformation
-from pyomo.core.base.block import _BlockData, Block
+from pyomo.core.base.block import Block
 from pyomo.core.util import target_list
 from pyomo.gdp import Disjunct, Disjunction
 from pyomo.gdp.util import is_child_of
 from pyomo.network import Port
 
 
-class PiecewiseLinearToGDP(Transformation):
+class PiecewiseLinearTransformationBase(Transformation):
     """
     Base class for transformations of piecewise-linear models to GDPs
     """
 
     CONFIG = ConfigDict('contrib.piecewise_to_gdp')
     CONFIG.declare(
         'targets',
@@ -143,15 +143,15 @@
                         "Constraints, and Objectives where your "
                         "PiecewiseLinearFunctions have been used in "
                         "expressions."
                     )
                 self._transform_piecewise_linear_function(
                     t, config.descend_into_expressions
                 )
-            elif t.ctype is Block or isinstance(t, _BlockData):
+            elif issubclass(t.ctype, Block):
                 self._transform_block(t, config.descend_into_expressions)
             elif t.ctype is Constraint:
                 if not config.descend_into_expressions:
                     raise ValueError(
                         "Encountered Constraint target '%s':\n%s"
                         % (t.name, not_walking_exprs_msg)
                     )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/piecewise_to_mip_visitor.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/piecewise_to_mip_visitor.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/piecewise/transform/reduced_inner_representation_gdp.py` & `Pyomo-6.7.2/pyomo/contrib/piecewise/transform/reduced_inner_representation_gdp.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,30 +6,30 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.contrib.fbbt.fbbt import compute_bounds_on_expr
-from pyomo.contrib.piecewise.transform.piecewise_to_gdp_transformation import (
-    PiecewiseLinearToGDP,
+from pyomo.contrib.piecewise.transform.piecewise_linear_transformation_base import (
+    PiecewiseLinearTransformationBase,
 )
 from pyomo.core import Constraint, NonNegativeIntegers, Var
 from pyomo.core.base import TransformationFactory
 from pyomo.gdp import Disjunct, Disjunction
 
 
 @TransformationFactory.register(
     'contrib.piecewise.reduced_inner_repn_gdp',
     doc="Convert piecewise-linear model to a GDP "
     "using an inner representation of the "
     "simplices that are the domains of the linear "
     "functions.",
 )
-class ReducedInnerRepresentationGDPTransformation(PiecewiseLinearToGDP):
+class ReducedInnerRepresentationGDPTransformation(PiecewiseLinearTransformationBase):
     """
     Convert a model involving piecewise linear expressions into a GDP by
     representing the piecewise linear functions as Disjunctions where the
     simplices over which the linear functions are defined are represented
     in a reduced "inner" representation--as convex combinations of their extreme
     points. We refer to this as 'reduced' since we create only one multiplier
     for each extreme point in the union of the extreme points over all the
@@ -47,15 +47,15 @@
            efficient, but will respect hierarchical structure by finding
            uses of PiecewiseLinearFunctions in Constraint and Obective
            expressions and putting their transformed counterparts on the same
            parent Block as the component owning their parent expression. In
            this mode, targets must be Blocks, Constraints, and/or Objectives.
     """
 
-    CONFIG = PiecewiseLinearToGDP.CONFIG()
+    CONFIG = PiecewiseLinearTransformationBase.CONFIG()
     _transformation_name = 'pw_linear_reduced_inner_repn'
 
     def _transform_pw_linear_expr(self, pw_expr, pw_linear_func, transformation_block):
         transBlock = transformation_block.transformed_functions[
             len(transformation_block.transformed_functions)
         ]
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/bounds_to_vars.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/bounds_to_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/constraint_tightener.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/constraint_tightener.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/deactivate_trivial_constraints.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/deactivate_trivial_constraints.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/detect_fixed_vars.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/detect_fixed_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/equality_propagate.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/equality_propagate.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/induced_linearity.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/induced_linearity.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/init_vars.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/init_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/int_to_binary.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/int_to_binary.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/remove_zero_terms.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/remove_zero_terms.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/strip_bounds.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/strip_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/var_aggregator.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/var_aggregator.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,22 @@
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 """Transformation to aggregate equal variables."""
 
 
 from pyomo.common.collections import ComponentMap, ComponentSet
-from pyomo.core.base import Block, Constraint, VarList, Objective, TransformationFactory
+from pyomo.core.base import (
+    Block,
+    Constraint,
+    VarList,
+    Objective,
+    Reals,
+    TransformationFactory,
+)
 from pyomo.core.expr import ExpressionReplacementVisitor
 from pyomo.core.expr.numvalue import value
 from pyomo.core.plugins.transform.hierarchy import IsomorphicTransformation
 from pyomo.repn import generate_standard_repn
 import logging
 
 logger = logging.getLogger('pyomo.contrib.preprocessing')
@@ -244,14 +251,20 @@
             z_to_vars[z_agg] = eq_set
             var_to_z.update(ComponentMap((v, z_agg) for v in eq_set))
 
             # Set the bounds of the aggregate variable based on the bounds of
             # the variables in its equality set.
             z_agg.setlb(max_if_not_None(v.lb for v in eq_set if v.has_lb()))
             z_agg.setub(min_if_not_None(v.ub for v in eq_set if v.has_ub()))
+            # Set the domain of the aggregate variable to the intersection of
+            # the domains of the variables in its equality set
+            domain = Reals
+            for v in eq_set:
+                domain = domain & v.domain
+            z_agg.domain = domain
 
             # Set the fixed status of the aggregate var
             fixed_vars = [v for v in eq_set if v.fixed]
             if fixed_vars:
                 # Check to make sure all the fixed values are the same.
                 if any(var.value != fixed_vars[0].value for var in fixed_vars[1:]):
                     raise ValueError(
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/plugins/zero_sum_propagator.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/plugins/zero_sum_propagator.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_bounds_to_vars_xfrm.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_bounds_to_vars_xfrm.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_constraint_tightener.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_constraint_tightener.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_deactivate_trivial_constraints.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_deactivate_trivial_constraints.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_detect_fixed_vars.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_detect_fixed_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_equality_propagate.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_equality_propagate.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_induced_linearity.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_induced_linearity.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_init_vars.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_init_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_int_to_binary.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_int_to_binary.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_strip_bounds.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_strip_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_var_aggregator.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_var_aggregator.py`

 * *Files 7% similar despite different names*

```diff
@@ -15,20 +15,24 @@
 from pyomo.common.collections import ComponentSet
 from pyomo.contrib.preprocessing.plugins.var_aggregator import (
     _build_equality_set,
     _get_equality_linked_variables,
     max_if_not_None,
     min_if_not_None,
 )
+from pyomo.core.expr.compare import assertExpressionsEqual
 from pyomo.environ import (
+    Binary,
     ConcreteModel,
     Constraint,
     ConstraintList,
+    maximize,
     Objective,
     RangeSet,
+    Reals,
     SolverFactory,
     TransformationFactory,
     Var,
 )
 
 
 class TestVarAggregate(unittest.TestCase):
@@ -206,10 +210,40 @@
         self.assertEqual(m.x.value, None)
         self.assertEqual(m.y.value, None)
         TransformationFactory('contrib.aggregate_vars').update_variables(m)
         self.assertEqual(z[1].value, 0)
         self.assertEqual(m.x.value, 0)
         self.assertEqual(m.y.value, 0)
 
+    def test_binary_inequality(self):
+        m = ConcreteModel()
+        m.x = Var(domain=Binary)
+        m.y = Var(domain=Binary)
+        m.c = Constraint(expr=m.x == m.y)
+        m.o = Objective(expr=0.5 * m.x + m.y, sense=maximize)
+        TransformationFactory('contrib.aggregate_vars').apply_to(m)
+        var_to_z = m._var_aggregator_info.var_to_z
+        z = var_to_z[m.x]
+        self.assertIs(var_to_z[m.y], z)
+        self.assertEqual(z.domain, Binary)
+        self.assertEqual(z.lb, 0)
+        self.assertEqual(z.ub, 1)
+        assertExpressionsEqual(self, m.o.expr, 0.5 * z + z)
+
+    def test_equality_different_domains(self):
+        m = ConcreteModel()
+        m.x = Var(domain=Reals, bounds=(1, 2))
+        m.y = Var(domain=Binary)
+        m.c = Constraint(expr=m.x == m.y)
+        m.o = Objective(expr=0.5 * m.x + m.y, sense=maximize)
+        TransformationFactory('contrib.aggregate_vars').apply_to(m)
+        var_to_z = m._var_aggregator_info.var_to_z
+        z = var_to_z[m.x]
+        self.assertIs(var_to_z[m.y], z)
+        self.assertEqual(z.lb, 1)
+        self.assertEqual(z.ub, 1)
+        self.assertEqual(z.domain, Binary)
+        assertExpressionsEqual(self, m.o.expr, 0.5 * z + z)
+
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_zero_sum_propagate.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_zero_sum_propagate.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/tests/test_zero_term_removal.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/tests/test_zero_term_removal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/preprocessing/util.py` & `Pyomo-6.7.2/pyomo/contrib/preprocessing/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/cyipopt_solver.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/cyipopt_solver.py`

 * *Files 8% similar despite different names*

```diff
@@ -20,14 +20,16 @@
 import logging
 import os
 import abc
 
 from pyomo.common.deprecation import relocated_module_attribute
 from pyomo.common.dependencies import attempt_import, numpy as np, numpy_available
 from pyomo.common.tee import redirect_fd, TeeStream
+from pyomo.common.modeling import unique_component_name
+from pyomo.core.base.objective import Objective
 
 # Because pynumero.interfaces requires numpy, we will leverage deferred
 # imports here so that the solver can be registered even when numpy is
 # not available.
 pyomo_nlp = attempt_import("pyomo.contrib.pynumero.interfaces.pyomo_nlp")[0]
 pyomo_grey_box = attempt_import("pyomo.contrib.pynumero.interfaces.pyomo_grey_box_nlp")[
     0
@@ -59,15 +61,15 @@
     "pyomo.contrib.pynumero.interfaces.cyipopt_interface.CyIpoptNLP",
     "6.6.0",
 )
 
 from pyomo.common.config import ConfigBlock, ConfigValue
 from pyomo.common.timing import TicTocTimer
 from pyomo.core.base import Block, Objective, minimize
-from pyomo.opt import SolverStatus, SolverResults, TerminationCondition, ProblemSense
+from pyomo.opt import SolverStatus, SolverResults, TerminationCondition
 from pyomo.opt.results.solution import Solution
 
 logger = logging.getLogger(__name__)
 
 # This maps the cyipopt STATUS_MESSAGES back to string representations
 # of the Ipopt ApplicationReturnStatus enum
 _cyipopt_status_enum = [
@@ -313,34 +315,51 @@
     def available(self, exception_flag=False):
         return bool(numpy_available and cyipopt_interface.cyipopt_available)
 
     def license_is_valid(self):
         return True
 
     def version(self):
-        return tuple(int(_) for _ in cyipopt.__version__.split("."))
+        def _int(x):
+            try:
+                return int(x)
+            except:
+                return x
+
+        return tuple(_int(_) for _ in cyipopt_interface.cyipopt.__version__.split("."))
 
     def solve(self, model, **kwds):
         config = self.config(kwds, preserve_implicit=True)
 
         if not isinstance(model, Block):
             raise ValueError(
                 "PyomoCyIpoptSolver.solve(model): model must be a Pyomo Block"
             )
 
         # If this is a Pyomo model / block, then we need to create
         # the appropriate PyomoNLP, then wrap it in a CyIpoptNLP
         grey_box_blocks = list(
             model.component_data_objects(egb.ExternalGreyBoxBlock, active=True)
         )
-        if grey_box_blocks:
-            # nlp = pyomo_nlp.PyomoGreyBoxNLP(model)
-            nlp = pyomo_grey_box.PyomoNLPWithGreyBoxBlocks(model)
-        else:
-            nlp = pyomo_nlp.PyomoNLP(model)
+        # if there is no objective, add one temporarily so we can construct an NLP
+        objectives = list(model.component_data_objects(Objective, active=True))
+        if not objectives:
+            objname = unique_component_name(model, "_obj")
+            objective = model.add_component(objname, Objective(expr=0.0))
+        try:
+            if grey_box_blocks:
+                # nlp = pyomo_nlp.PyomoGreyBoxNLP(model)
+                nlp = pyomo_grey_box.PyomoNLPWithGreyBoxBlocks(model)
+            else:
+                nlp = pyomo_nlp.PyomoNLP(model)
+        finally:
+            # We only need the objective to construct the NLP, so we delete
+            # it from the model ASAP
+            if not objectives:
+                model.del_component(objective)
 
         problem = cyipopt_interface.CyIpoptNLP(
             nlp,
             intermediate_callback=config.intermediate_callback,
             halt_on_evaluation_error=config.halt_on_evaluation_error,
         )
         ng = len(problem.g_lb())
@@ -424,19 +443,18 @@
             )
             model.solutions.add_symbol_map(sm)
             results._smap_id = id(sm)
             results.solution.insert(soln)
 
         results.problem.name = model.name
         obj = next(model.component_data_objects(Objective, active=True))
+        results.problem.sense = obj.sense
         if obj.sense == minimize:
-            results.problem.sense = ProblemSense.minimize
             results.problem.upper_bound = info["obj_val"]
         else:
-            results.problem.sense = ProblemSense.maximize
             results.problem.lower_bound = info["obj_val"]
         results.problem.number_of_objectives = 1
         results.problem.number_of_constraints = ng
         results.problem.number_of_variables = nx
         results.problem.number_of_binary_variables = 0
         results.problem.number_of_integer_variables = 0
         results.problem.number_of_continuous_variables = nx
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/implicit_functions.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/implicit_functions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/pyomo_ext_cyipopt.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/pyomo_ext_cyipopt.py`

 * *Files 0% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 import abc
 from pyomo.contrib.pynumero.algorithms.solvers.cyipopt_solver import (
     CyIpoptProblemInterface,
 )
 from pyomo.contrib.pynumero.interfaces.pyomo_nlp import PyomoNLP
 from pyomo.contrib.pynumero.sparse.block_vector import BlockVector
 from pyomo.environ import Var, Constraint, value
-from pyomo.core.base.var import _VarData
+from pyomo.core.base.var import VarData
 from pyomo.common.modeling import unique_component_name
 
 """
 This module is used for interfacing a multi-input / multi-output external
 evaluation code with a Pyomo model and then solve the coupled model
 with CyIpopt.
 
@@ -105,20 +105,20 @@
            The ConcreteModel representing the Pyomo part of the problem. This
            model must contain Pyomo variables for the inputs and the outputs.
 
         ex_input_output_model : ExternalInputOutputModel
            An instance of a derived class (from ExternalInputOutputModel) that provides
            the methods to compute the outputs and the derivatives.
 
-        inputs : list of Pyomo variables (_VarData)
+        inputs : list of Pyomo variables (VarData)
            The Pyomo model needs to have variables to represent the inputs to the
            external model. This is the list of those input variables in the order
            that corresponds to the input_values vector provided in the set_inputs call.
 
-        outputs : list of Pyomo variables (_VarData)
+        outputs : list of Pyomo variables (VarData)
           The Pyomo model needs to have variables to represent the outputs from the
           external model. This is the list of those output variables in the order
           that corresponds to the numpy array returned from the evaluate_outputs call.
 
         outputs_eqn_scaling : list or array-like or None
           This sets the value of scaling parameters for the additional
           output equations that are generated. No scaling is done if this
@@ -126,24 +126,24 @@
         """
         self._pyomo_model = pyomo_model
         self._ex_io_model = ex_input_output_model
 
         # verify that the inputs and outputs were passed correctly
         self._inputs = [v for v in inputs]
         for v in self._inputs:
-            if not isinstance(v, _VarData):
+            if not isinstance(v, VarData):
                 raise RuntimeError(
                     'Argument inputs passed to PyomoExternalCyIpoptProblem must be'
                     ' a list of VarData objects. Note: if you have an indexed variable, pass'
                     ' each index as a separate entry in the list (e.g., inputs=[m.x[1], m.x[2]]).'
                 )
 
         self._outputs = [v for v in outputs]
         for v in self._outputs:
-            if not isinstance(v, _VarData):
+            if not isinstance(v, VarData):
                 raise RuntimeError(
                     'Argument outputs passed to PyomoExternalCyIpoptProblem must be'
                     ' a list of VarData objects. Note: if you have an indexed variable, pass'
                     ' each index as a separate entry in the list (e.g., inputs=[m.x[1], m.x[2]]).'
                 )
 
         # we need to add a dummy variable and constraint to the pyomo_nlp
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/scipy_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/scipy_solvers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/square_solver_base.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/square_solver_base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_interfaces.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_interfaces.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_solver.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_cyipopt_solver.py`

 * *Files 1% similar despite different names*

```diff
@@ -312,7 +312,17 @@
     )
     def test_hs071_evalerror_old_cyipopt(self):
         m = make_hs071_model()
         solver = pyo.SolverFactory("cyipopt")
         msg = "Error in AMPL evaluation"
         with self.assertRaisesRegex(PyNumeroEvaluationError, msg):
             res = solver.solve(m, tee=True)
+
+    def test_solve_without_objective(self):
+        m = create_model1()
+        m.o.deactivate()
+        m.x[2].fix(0.0)
+        m.x[3].fix(4.0)
+        solver = pyo.SolverFactory("cyipopt")
+        res = solver.solve(m, tee=True)
+        pyo.assert_optimal_termination(res)
+        self.assertAlmostEqual(m.x[1].value, 9.0)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_implicit_functions.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_implicit_functions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_pyomo_ext_cyipopt.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_pyomo_ext_cyipopt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/algorithms/solvers/tests/test_scipy_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/algorithms/solvers/tests/test_scipy_solvers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/asl.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/asl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/build.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/build.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/dependencies.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/dependencies.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 
 # Note: sparse.BlockVector leverages the __array__ufunc__ interface
 # released in numpy 1.13
 numpy, numpy_available = attempt_import(
     'numpy',
     'Pynumero requires the optional Pyomo dependency "numpy"',
     minimum_version='1.13.0',
-    defer_check=False,
+    defer_import=False,
 )
 
 if not numpy_available:
     numpy.log_import_warning('pyomo.contrib.pynumero')
 
 if not scipy_available:
     scipy.sparse.log_import_warning(
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_callback.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_callback.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_callback_halt.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_callback_halt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/cyipopt_functor_callback.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/cyipopt_functor_callback.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/callback/reactor_design.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/callback/reactor_design.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/generate_data.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/generate_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/models.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/models.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/param_est/perform_estimation.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/param_est/perform_estimation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_outputs.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_outputs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_ratio_residuals.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/maximize_cb_ratio_residuals.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_outputs.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_outputs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_residuals.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/external_grey_box/react_example/reactor_model_residuals.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/feasibility.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/feasibility.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/mumps_example.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/mumps_example.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/nlp_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/nlp_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/nlp_interface_2.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/nlp_interface_2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/parallel_matvec.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/parallel_matvec.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/parallel_vector_ops.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/parallel_vector_ops.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/sensitivity.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/sensitivity.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/sqp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/sqp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_cyipopt_examples.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_cyipopt_examples.py`

 * *Files 8% similar despite different names*

```diff
@@ -31,28 +31,30 @@
     raise unittest.SkipTest("Pynumero needs scipy and numpy to run CyIpopt tests")
 
 pandas, pandas_available = attempt_import(
     'pandas',
     'One of the tests below requires a recent version of pandas for'
     ' comparing with a tolerance.',
     minimum_version='1.1.0',
-    defer_check=False,
+    defer_import=False,
 )
 
 from pyomo.contrib.pynumero.asl import AmplInterface
 
 if not AmplInterface.available():
     raise unittest.SkipTest("Pynumero needs the ASL extension to run CyIpopt tests")
 
 import pyomo.contrib.pynumero.algorithms.solvers.cyipopt_solver as cyipopt_solver
+from pyomo.contrib.pynumero.interfaces.cyipopt_interface import cyipopt_available
 
-if not cyipopt_solver.cyipopt_available:
+if not cyipopt_available:
     raise unittest.SkipTest("PyNumero needs CyIpopt installed to run CyIpopt tests")
 import cyipopt as cyipopt_core
 
+
 example_dir = os.path.join(this_file_dir(), '..')
 
 
 class TestPyomoCyIpoptSolver(unittest.TestCase):
     def test_status_maps(self):
         # verify that all status messages from cyipopy can be cleanly
         # mapped back to a Pyomo TerminationCondition
@@ -262,14 +264,19 @@
         )
         df = ex.main()
         self.assertEqual(df.shape, (7, 5))
         # check one of the residuals
         s = df['ca_bal']
         self.assertAlmostEqual(s.iloc[6], 0, places=3)
 
+    @unittest.skipIf(
+        cyipopt_solver.PyomoCyIpoptSolver().version() == (1, 4, 0),
+        "Terminating Ipopt through a user callback is broken in CyIpopt 1.4.0 "
+        "(see mechmotum/cyipopt#249)",
+    )
     def test_cyipopt_callback_halt(self):
         ex = import_file(
             os.path.join(example_dir, 'callback', 'cyipopt_callback_halt.py')
         )
         status = ex.main()
         self.assertEqual(
             status.solver.termination_condition, TerminationCondition.userInterrupt
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_examples.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/examples/tests/test_mpi_examples.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/examples/tests/test_mpi_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/exceptions.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/exceptions.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/ampl_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/ampl_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/cyipopt_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/cyipopt_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/external_grey_box.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/external_grey_box.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 from scipy.sparse import coo_matrix
 from pyomo.common.dependencies import numpy as np
 
 from pyomo.common.deprecation import RenamedClass
 from pyomo.common.log import is_debug_set
 from pyomo.common.timing import ConstructionTimer
 from pyomo.core.base import Var, Set, Constraint, value
-from pyomo.core.base.block import _BlockData, Block, declare_custom_block
+from pyomo.core.base.block import BlockData, Block, declare_custom_block
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.initializer import Initializer
 from pyomo.core.base.set import UnindexedComponent_set
 from pyomo.core.base.reference import Reference
 
 from ..sparse.block_matrix import BlockMatrix
 
@@ -312,15 +312,15 @@
     # Hessian computations: see documentation in class docstring
     #
     # def evaluate_hessian_equality_constraints(self):
     # def evaluate_hessian_outputs(self):
     #
 
 
-class ExternalGreyBoxBlockData(_BlockData):
+class ExternalGreyBoxBlockData(BlockData):
     def set_external_model(self, external_grey_box_model, inputs=None, outputs=None):
         """
         Parameters
         ----------
         external_grey_box_model: ExternalGreyBoxModel
             The external model that will be interfaced to in this block
         inputs: List of VarData objects
@@ -420,15 +420,15 @@
                 data.set_external_model(self._init_model(block, index))
 
 
 class ScalarExternalGreyBoxBlock(ExternalGreyBoxBlockData, ExternalGreyBoxBlock):
     def __init__(self, *args, **kwds):
         ExternalGreyBoxBlockData.__init__(self, component=self)
         ExternalGreyBoxBlock.__init__(self, *args, **kwds)
-        # The above inherit from Block and _BlockData, so it's not until here
+        # The above inherit from Block and BlockData, so it's not until here
         # that we know it's scalar. So we set the index accordingly.
         self._index = UnindexedComponent_index
 
     # Pick up the display() from Block and not BlockData
     display = ExternalGreyBoxBlock.display
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/external_pyomo_model.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/external_pyomo_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/nlp_projections.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/nlp_projections.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/pyomo_grey_box_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/pyomo_grey_box_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/pyomo_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/pyomo_nlp.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,14 +18,15 @@
 from scipy.sparse import coo_matrix
 from pyomo.common.deprecation import deprecated
 from pyomo.common.tempfiles import TempfileManager
 from pyomo.opt import WriterFactory
 import pyomo.core.base as pyo
 from pyomo.common.collections import ComponentMap
 from pyomo.common.env import CtypesEnviron
+from pyomo.solvers.amplfunc_merge import amplfunc_merge
 from ..sparse.block_matrix import BlockMatrix
 from pyomo.contrib.pynumero.interfaces.ampl_nlp import AslNLP
 from pyomo.contrib.pynumero.interfaces.nlp import NLP
 from .external_grey_box import ExternalGreyBoxBlock
 
 
 # TODO: There are todos in the code below
@@ -88,23 +89,16 @@
                     vdidx[obj] = int(name[1:])
                 elif name[0] == 'c':
                     cdidx[obj] = int(name[1:])
 
             # The NL writer advertises the external function libraries
             # through the PYOMO_AMPLFUNC environment variable; merge it
             # with any preexisting AMPLFUNC definitions
-            amplfunc = "\n".join(
-                filter(
-                    None,
-                    (
-                        os.environ.get('AMPLFUNC', None),
-                        os.environ.get('PYOMO_AMPLFUNC', None),
-                    ),
-                )
-            )
+            amplfunc = amplfunc_merge(os.environ)
+
             with CtypesEnviron(AMPLFUNC=amplfunc):
                 super(PyomoNLP, self).__init__(nl_file)
 
             # keep pyomo model in cache
             self._pyomo_model = pyomo_model
 
             # Create ComponentMap corresponding to equality constraint indices
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/compare_utils.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/compare_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/external_grey_box_models.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/external_grey_box_models.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_cyipopt_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_cyipopt_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_dynamic_model.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_dynamic_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_asl_function.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_asl_function.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_grey_box_model.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_grey_box_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_block.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_block.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_model.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_external_pyomo_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_nlp_projections.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_nlp_projections.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_pyomo_grey_box_nlp.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_pyomo_grey_box_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/tests/test_utils.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/tests/test_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/interfaces/utils.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/interfaces/utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/intrinsic.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/intrinsic.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,17 +7,15 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.dependencies import numpy as np, attempt_import
 
-block_vector = attempt_import(
-    'pyomo.contrib.pynumero.sparse.block_vector', defer_check=True
-)[0]
+block_vector = attempt_import('pyomo.contrib.pynumero.sparse.block_vector')[0]
 
 
 def norm(x, ord=None):
     f = np.linalg.norm
     if isinstance(x, np.ndarray):
         return f(x, ord=ord)
     elif isinstance(x, block_vector.BlockVector):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/base.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma27.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma27.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma27_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma27_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma57.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma57.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/ma57_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/ma57_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/mumps_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/mumps_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/scipy_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/scipy_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_linear_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_linear_solvers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_ma27.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_ma27.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_ma57.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_ma57.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/tests/test_mumps_interface.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/tests/test_mumps_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/linalg/utils.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/linalg/utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/base_block.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/base_block.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/block_matrix.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/block_matrix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/block_vector.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/block_vector.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/mpi_block_matrix.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/mpi_block_matrix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/mpi_block_vector.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/mpi_block_vector.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_block_matrix.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_block_matrix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_block_vector.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_block_vector.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_intrinsics.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_intrinsics.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_matrix.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_matrix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_vector.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/sparse/tests/test_mpi_block_vector.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/AmplInterface.cpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/AmplInterface.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/AmplInterface.hpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/AmplInterface.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/AssertUtils.hpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/AssertUtils.hpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/CMakeLists.txt` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/CMakeLists.txt`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/ma27Interface.cpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/ma27Interface.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/ma57Interface.cpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/ma57Interface.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/simple_nlp.nl` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/simple_nlp.nl`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/src/tests/simple_test.cpp` & `Pyomo-6.7.2/pyomo/contrib/pynumero/src/tests/simple_test.cpp`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pynumero/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pynumero/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/config.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/config.py`

 * *Files 5% similar despite different names*

```diff
@@ -12,98 +12,61 @@
     In,
     IsInstance,
     NonNegativeFloat,
     InEnum,
     Path,
 )
 from pyomo.common.errors import ApplicationError, PyomoException
-from pyomo.core.base import Var, _VarData
-from pyomo.core.base.param import Param, _ParamData
+from pyomo.core.base import Var, VarData
+from pyomo.core.base.param import Param, ParamData
 from pyomo.opt import SolverFactory
 from pyomo.contrib.pyros.util import ObjectiveType, setup_pyros_logger
 from pyomo.contrib.pyros.uncertainty_sets import UncertaintySet
 
 
 default_pyros_solver_logger = setup_pyros_logger()
 
 
-class LoggerType:
+def logger_domain(obj):
     """
-    Domain validator for objects castable to logging.Logger.
+    Domain validator for logger-type arguments.
+
+    This admits any object of type ``logging.Logger``,
+    or which can be cast to ``logging.Logger``.
     """
+    if isinstance(obj, logging.Logger):
+        return obj
+    else:
+        return logging.getLogger(obj)
 
-    def __call__(self, obj):
-        """
-        Cast object to logger.
 
-        Parameters
-        ----------
-        obj : object
-            Object to be cast.
+logger_domain.domain_name = "None, str or logging.Logger"
 
-        Returns
-        -------
-        logging.Logger
-            If `str_or_logger` is of type `logging.Logger`,then
-            `str_or_logger` is returned.
-            Otherwise, ``logging.getLogger(str_or_logger)``
-            is returned.
-        """
-        if isinstance(obj, logging.Logger):
-            return obj
-        else:
-            return logging.getLogger(obj)
 
-    def domain_name(self):
-        """Return str briefly describing domain encompassed by self."""
-        return "None, str or logging.Logger"
-
-
-class PositiveIntOrMinusOne:
+def positive_int_or_minus_one(obj):
     """
-    Domain validator for objects castable to a
-    strictly positive int or -1.
+    Domain validator for objects castable to a strictly
+    positive int or -1.
     """
+    ans = int(obj)
+    if ans != float(obj) or (ans <= 0 and ans != -1):
+        raise ValueError(f"Expected positive int or -1, but received value {obj!r}")
+    return ans
 
-    def __call__(self, obj):
-        """
-        Cast object to positive int or -1.
 
-        Parameters
-        ----------
-        obj : object
-            Object of interest.
-
-        Returns
-        -------
-        int
-            Positive int, or -1.
-
-        Raises
-        ------
-        ValueError
-            If object not castable to positive int, or -1.
-        """
-        ans = int(obj)
-        if ans != float(obj) or (ans <= 0 and ans != -1):
-            raise ValueError(f"Expected positive int or -1, but received value {obj!r}")
-        return ans
-
-    def domain_name(self):
-        """Return str briefly describing domain encompassed by self."""
-        return "positive int or -1"
+positive_int_or_minus_one.domain_name = "positive int or -1"
 
 
 def mutable_param_validator(param_obj):
     """
     Check that Param-like object has attribute `mutable=True`.
 
     Parameters
     ----------
-    param_obj : Param or _ParamData
+    param_obj : Param or ParamData
         Param-like object of interest.
 
     Raises
     ------
     ValueError
         If lengths of the param object and the accompanying
         index set do not match. This may occur if some entry
@@ -131,15 +94,15 @@
 
     Parameters
     ----------
     ctype : type
         Pyomo component type, such as Component, Var or Param.
     cdatatype : type
         Corresponding Pyomo component data type, such as
-        _ComponentData, _VarData, or _ParamData.
+        ComponentData, VarData, or ParamData.
     ctype_validator : callable, optional
         Validator function for objects of type `ctype`.
     cdatatype_validator : callable, optional
         Validator function for objects of type `cdatatype`.
     allow_repeats : bool, optional
         True to allow duplicate component data entries in final
         list to which argument is cast, False otherwise.
@@ -536,43 +499,58 @@
                 """
                 Load final solution(s) found by PyROS to the deterministic
                 model provided.
                 """
             ),
         ),
     )
+    CONFIG.declare(
+        'symbolic_solver_labels',
+        ConfigValue(
+            default=False,
+            domain=bool,
+            description=(
+                """
+                True to ensure the component names given to the
+                subordinate solvers for every subproblem reflect
+                the names of the corresponding Pyomo modeling components,
+                False otherwise.
+                """
+            ),
+        ),
+    )
 
     # ================================================
     # === Required User Inputs
     # ================================================
     CONFIG.declare(
         "first_stage_variables",
         ConfigValue(
             default=[],
-            domain=InputDataStandardizer(Var, _VarData, allow_repeats=False),
+            domain=InputDataStandardizer(Var, VarData, allow_repeats=False),
             description="First-stage (or design) variables.",
             visibility=1,
         ),
     )
     CONFIG.declare(
         "second_stage_variables",
         ConfigValue(
             default=[],
-            domain=InputDataStandardizer(Var, _VarData, allow_repeats=False),
+            domain=InputDataStandardizer(Var, VarData, allow_repeats=False),
             description="Second-stage (or control) variables.",
             visibility=1,
         ),
     )
     CONFIG.declare(
         "uncertain_params",
         ConfigValue(
             default=[],
             domain=InputDataStandardizer(
                 ctype=Param,
-                cdatatype=_ParamData,
+                cdatatype=ParamData,
                 ctype_validator=mutable_param_validator,
                 allow_repeats=False,
             ),
             description=(
                 """
                 Uncertain model parameters.
                 The `mutable` attribute for all uncertain parameter
@@ -717,15 +695,15 @@
             ),
         ),
     )
     CONFIG.declare(
         "max_iter",
         ConfigValue(
             default=-1,
-            domain=PositiveIntOrMinusOne(),
+            domain=positive_int_or_minus_one,
             description=(
                 """
                 Iteration limit. If -1 is provided, then no iteration
                 limit is enforced.
                 """
             ),
         ),
@@ -762,15 +740,15 @@
             ),
         ),
     )
     CONFIG.declare(
         "progress_logger",
         ConfigValue(
             default=default_pyros_solver_logger,
-            domain=LoggerType(),
+            domain=logger_domain,
             doc=(
                 """
                 Logger (or name thereof) used for reporting PyROS solver
                 progress. If `None` or a `str` is provided, then
                 ``progress_logger``
                 is cast to ``logging.getLogger(progress_logger)``.
                 In the default case, `progress_logger` is set to
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/master_problem_methods.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/master_problem_methods.py`

 * *Files 6% similar despite different names*

```diff
@@ -23,14 +23,15 @@
     SortComponents,
 )
 from pyomo.opt import TerminationCondition as tc
 from pyomo.opt import SolverResults
 from pyomo.core.expr import value
 from pyomo.core.base.set_types import NonNegativeIntegers, NonNegativeReals
 from pyomo.contrib.pyros.util import (
+    call_solver,
     selective_clone,
     ObjectiveType,
     pyrosTerminationCondition,
     process_termination_condition_master_problem,
     adjust_solver_time_settings,
     revert_solver_max_time_adjustment,
     get_main_elapsed_time,
@@ -235,39 +236,26 @@
     )
 
     if config.solve_master_globally:
         solver = config.global_solver
     else:
         solver = config.local_solver
 
-    timer = TicTocTimer()
-    orig_setting, custom_setting_present = adjust_solver_time_settings(
-        model_data.timing, solver, config
-    )
-    model_data.timing.start_timer("main.master_feasibility")
-    timer.tic(msg=None)
-    try:
-        results = solver.solve(model, tee=config.tee, load_solutions=False)
-    except ApplicationError:
-        # account for possible external subsolver errors
-        # (such as segmentation faults, function evaluation
-        # errors, etc.)
-        config.progress_logger.error(
+    results = call_solver(
+        model=model,
+        solver=solver,
+        config=config,
+        timing_obj=model_data.timing,
+        timer_name="main.master_feasibility",
+        err_msg=(
             f"Optimizer {repr(solver)} encountered exception "
             "attempting to solve master feasibility problem in iteration "
             f"{model_data.iteration}."
-        )
-        raise
-    else:
-        setattr(results.solver, TIC_TOC_SOLVE_TIME_ATTR, timer.toc(msg=None))
-        model_data.timing.stop_timer("main.master_feasibility")
-    finally:
-        revert_solver_max_time_adjustment(
-            solver, orig_setting, custom_setting_present, config
-        )
+        ),
+    )
 
     feasible_terminations = {
         tc.optimal,
         tc.locallyOptimal,
         tc.globallyOptimal,
         tc.feasible,
     }
@@ -394,18 +382,25 @@
         )
 
         # update list of absolute value cons
         all_lb_cons.append(polishing_absolute_value_lb_cons)
         all_ub_cons.append(polishing_absolute_value_ub_cons)
 
         # get monomials; ensure second-stage variable term excluded
+        #
+        # the dr_eq is a linear sum where the first term is the
+        # second-stage variable: the remainder of the terms will be
+        # either MonomialTermExpressions or bare VarData
         dr_expr_terms = dr_eq.body.args[:-1]
 
         for dr_eq_term in dr_expr_terms:
-            dr_var_in_term = dr_eq_term.args[-1]
+            if dr_eq_term.is_expression_type():
+                dr_var_in_term = dr_eq_term.args[-1]
+            else:
+                dr_var_in_term = dr_eq_term
             dr_var_in_term_idx = dr_var_in_term.index()
 
             # get corresponding polishing variable
             polishing_var = indexed_polishing_var[dr_var_in_term_idx]
 
             # add polishing constraints
             polishing_absolute_value_lb_cons[dr_var_in_term_idx] = (
@@ -471,36 +466,26 @@
     # polishing objective should be consistent with value of sum
     # of absolute values of polynomial DR terms provided
     # auxiliary variables initialized correctly
     polishing_obj = polishing_model.polishing_obj
     config.progress_logger.debug(f" Initial DR norm: {value(polishing_obj)}")
 
     # === Solve the polishing model
-    timer = TicTocTimer()
-    orig_setting, custom_setting_present = adjust_solver_time_settings(
-        model_data.timing, solver, config
-    )
-    model_data.timing.start_timer("main.dr_polishing")
-    timer.tic(msg=None)
-    try:
-        results = solver.solve(polishing_model, tee=config.tee, load_solutions=False)
-    except ApplicationError:
-        config.progress_logger.error(
+    results = call_solver(
+        model=polishing_model,
+        solver=solver,
+        config=config,
+        timing_obj=model_data.timing,
+        timer_name="main.dr_polishing",
+        err_msg=(
             f"Optimizer {repr(solver)} encountered an exception "
             "attempting to solve decision rule polishing problem "
             f"in iteration {model_data.iteration}"
-        )
-        raise
-    else:
-        setattr(results.solver, TIC_TOC_SOLVE_TIME_ATTR, timer.toc(msg=None))
-        model_data.timing.stop_timer("main.dr_polishing")
-    finally:
-        revert_solver_max_time_adjustment(
-            solver, orig_setting, custom_setting_present, config
-        )
+        ),
+    )
 
     # interested in the time and termination status for debugging
     # purposes
     config.progress_logger.debug(" Done solving DR polishing problem")
     config.progress_logger.debug(
         f"  Termination condition: {results.solver.termination_condition} "
     )
@@ -715,51 +700,33 @@
         solvers = [solver] + config.backup_local_solvers
 
     higher_order_decision_rule_efficiency(model_data=model_data, config=config)
 
     solve_mode = "global" if config.solve_master_globally else "local"
     config.progress_logger.debug("Solving master problem")
 
-    timer = TicTocTimer()
     for idx, opt in enumerate(solvers):
         if idx > 0:
             config.progress_logger.warning(
                 f"Invoking backup solver {opt!r} "
                 f"(solver {idx + 1} of {len(solvers)}) for "
                 f"master problem of iteration {model_data.iteration}."
             )
-        orig_setting, custom_setting_present = adjust_solver_time_settings(
-            model_data.timing, opt, config
-        )
-        model_data.timing.start_timer("main.master")
-        timer.tic(msg=None)
-        try:
-            results = opt.solve(
-                nlp_model,
-                tee=config.tee,
-                load_solutions=False,
-                symbolic_solver_labels=True,
-            )
-        except ApplicationError:
-            # account for possible external subsolver errors
-            # (such as segmentation faults, function evaluation
-            # errors, etc.)
-            config.progress_logger.error(
+        results = call_solver(
+            model=nlp_model,
+            solver=opt,
+            config=config,
+            timing_obj=model_data.timing,
+            timer_name="main.master",
+            err_msg=(
                 f"Optimizer {repr(opt)} ({idx + 1} of {len(solvers)}) "
                 "encountered exception attempting to "
                 f"solve master problem in iteration {model_data.iteration}"
-            )
-            raise
-        else:
-            setattr(results.solver, TIC_TOC_SOLVE_TIME_ATTR, timer.toc(msg=None))
-            model_data.timing.stop_timer("main.master")
-        finally:
-            revert_solver_max_time_adjustment(
-                solver, orig_setting, custom_setting_present, config
-            )
+            ),
+        )
 
         optimal_termination = check_optimal_termination(results)
         infeasible = results.solver.termination_condition == tc.infeasible
 
         if optimal_termination:
             nlp_model.solutions.load_from(results)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/pyros.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/pyros.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,23 +8,22 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 # pyros.py: Generalized Robust Cutting-Set Algorithm for Pyomo
 import logging
 from pyomo.common.config import document_kwargs_from_configdict
-from pyomo.common.collections import Bunch
 from pyomo.core.base.block import Block
 from pyomo.core.expr import value
 from pyomo.core.base.var import Var
 from pyomo.core.base.objective import Objective
 from pyomo.contrib.pyros.util import time_code
 from pyomo.common.modeling import unique_component_name
 from pyomo.opt import SolverFactory
-from pyomo.contrib.pyros.config import pyros_config
+from pyomo.contrib.pyros.config import pyros_config, logger_domain
 from pyomo.contrib.pyros.util import (
     recast_to_min_obj,
     add_decision_rule_constraints,
     add_decision_rule_variables,
     load_final_solution,
     pyrosTerminationCondition,
     ObjectiveType,
@@ -40,15 +39,15 @@
 from pyomo.contrib.pyros.solve_data import ROSolveResults
 from pyomo.contrib.pyros.pyros_algorithm_methods import ROSolver_iterative_solve
 from pyomo.core.base import Constraint
 
 from datetime import datetime
 
 
-__version__ = "1.2.10"
+__version__ = "1.2.11"
 
 
 default_pyros_solver_logger = setup_pyros_logger()
 
 
 def _get_pyomo_version_info():
     """
@@ -326,40 +325,49 @@
 
         Returns
         -------
         return_soln : ROSolveResults
             Summary of PyROS termination outcome.
 
         """
-        kwds.update(
-            dict(
-                first_stage_variables=first_stage_variables,
-                second_stage_variables=second_stage_variables,
-                uncertain_params=uncertain_params,
-                uncertainty_set=uncertainty_set,
-                local_solver=local_solver,
-                global_solver=global_solver,
-            )
-        )
-        config, state_vars = self._resolve_and_validate_pyros_args(model, **kwds)
-
-        # === Create data containers
         model_data = ROSolveResults()
-        model_data.timing = Bunch()
-
-        # === Start timer, run the algorithm
         model_data.timing = TimingData()
         with time_code(
             timing_data_obj=model_data.timing,
             code_block_name="main",
             is_main_timer=True,
         ):
-            # output intro and disclaimer
-            self._log_intro(logger=config.progress_logger, level=logging.INFO)
-            self._log_disclaimer(logger=config.progress_logger, level=logging.INFO)
+            kwds.update(
+                dict(
+                    first_stage_variables=first_stage_variables,
+                    second_stage_variables=second_stage_variables,
+                    uncertain_params=uncertain_params,
+                    uncertainty_set=uncertainty_set,
+                    local_solver=local_solver,
+                    global_solver=global_solver,
+                )
+            )
+
+            # we want to log the intro and disclaimer in
+            # advance of assembling the config.
+            # this helps clarify to the user that any
+            # messages logged during assembly of the config
+            # were, in fact, logged after PyROS was initiated
+            progress_logger = logger_domain(
+                kwds.get(
+                    "progress_logger",
+                    kwds.get("options", dict()).get(
+                        "progress_logger", default_pyros_solver_logger
+                    ),
+                )
+            )
+            self._log_intro(logger=progress_logger, level=logging.INFO)
+            self._log_disclaimer(logger=progress_logger, level=logging.INFO)
+
+            config, state_vars = self._resolve_and_validate_pyros_args(model, **kwds)
             self._log_config(
                 logger=config.progress_logger,
                 config=config,
                 exclude_options=None,
                 level=logging.INFO,
             )
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/pyros_algorithm_methods.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/pyros_algorithm_methods.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,16 +22,17 @@
     ObjectiveType,
     get_time_from_solver,
     pyrosTerminationCondition,
     IterationLogRecord,
 )
 from pyomo.contrib.pyros.util import get_main_elapsed_time, coefficient_matching
 from pyomo.core.base import value
+from pyomo.core.expr import MonomialTermExpression
 from pyomo.common.collections import ComponentSet, ComponentMap
-from pyomo.core.base.var import _VarData as VarData
+from pyomo.core.base.var import VarData as VarData
 from itertools import chain
 from pyomo.common.dependencies import numpy as np
 
 
 def update_grcs_solve_data(
     pyros_soln, term_cond, nominal_data, timing_data, separation_data, master_soln, k
 ):
@@ -65,22 +66,25 @@
     Generate mapping from decision rule variables
     to their terms in a model's DR expression.
     """
     var_to_scaled_expr_map = ComponentMap()
     ssv_dr_eq_zip = zip(second_stage_vars, decision_rule_eqns)
     for ssv_idx, (ssv, dr_eq) in enumerate(ssv_dr_eq_zip):
         for term in dr_eq.body.args:
-            is_ssv_term = (
-                isinstance(term.args[0], int)
-                and term.args[0] == -1
-                and isinstance(term.args[1], VarData)
-            )
-            if not is_ssv_term:
-                dr_var = term.args[1]
-                var_to_scaled_expr_map[dr_var] = term
+            if isinstance(term, MonomialTermExpression):
+                is_ssv_term = (
+                    isinstance(term.args[0], int)
+                    and term.args[0] == -1
+                    and isinstance(term.args[1], VarData)
+                )
+                if not is_ssv_term:
+                    dr_var = term.args[1]
+                    var_to_scaled_expr_map[dr_var] = term
+            elif isinstance(term, VarData):
+                var_to_scaled_expr_map[term] = MonomialTermExpression((1, term))
 
     return var_to_scaled_expr_map
 
 
 def evaluate_and_log_component_stats(model_data, separation_model, config):
     """
     Evaluate and log model component statistics.
@@ -801,15 +805,15 @@
             max_sep_con_violation = None
         num_violated_cons = len(separation_results.violated_performance_constraints)
 
         all_sep_problems_solved = (
             len(scaled_violations) == len(separation_model.util.performance_constraints)
             and not separation_results.subsolver_error
             and not separation_results.time_out
-        )
+        ) or separation_results.all_discrete_scenarios_exhausted
 
         iter_log_record = IterationLogRecord(
             iteration=k,
             objective=value(master_data.master_model.obj),
             first_stage_var_shift=first_stage_var_shift,
             second_stage_var_shift=second_stage_var_shift,
             dr_var_shift=dr_var_shift,
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/separation_problem_methods.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/separation_problem_methods.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 """
 
 from pyomo.core.base.constraint import Constraint, ConstraintList
 from pyomo.core.base.objective import Objective, maximize, value
 from pyomo.core.base import Var, Param
 from pyomo.common.collections import ComponentSet, ComponentMap
 from pyomo.common.dependencies import numpy as np
-from pyomo.contrib.pyros.util import ObjectiveType, get_time_from_solver
 from pyomo.contrib.pyros.solve_data import (
     DiscreteSeparationSolveCallResults,
     SeparationSolveCallResults,
     SeparationLoopResults,
     SeparationResults,
 )
 from pyomo.opt import TerminationCondition as tc
@@ -33,17 +32,19 @@
 )
 from pyomo.contrib.pyros.util import get_main_elapsed_time, is_certain_parameter
 from pyomo.contrib.pyros.uncertainty_sets import Geometry
 from pyomo.common.errors import ApplicationError
 from pyomo.contrib.pyros.util import ABS_CON_CHECK_FEAS_TOL
 from pyomo.common.timing import TicTocTimer
 from pyomo.contrib.pyros.util import (
-    TIC_TOC_SOLVE_TIME_ATTR,
     adjust_solver_time_settings,
+    call_solver,
+    ObjectiveType,
     revert_solver_max_time_adjustment,
+    TIC_TOC_SOLVE_TIME_ATTR,
 )
 import os
 from copy import deepcopy
 from itertools import product
 
 
 def add_uncertainty_set_constraints(model, config):
@@ -645,14 +646,15 @@
         if all_scenarios_exhausted:
             # robustness certified: entire uncertainty set already
             # accounted for in master
             return SeparationLoopResults(
                 solver_call_results=ComponentMap(),
                 solved_globally=solve_globally,
                 worst_case_perf_con=None,
+                all_discrete_scenarios_exhausted=True,
             )
 
         perf_con_to_maximize = sorted_priority_groups[
             max(sorted_priority_groups.keys())
         ][0]
 
         # efficiency: evaluate all separation problem solutions in
@@ -1065,61 +1067,43 @@
     solve_mode = "global" if solve_globally else "local"
 
     # === Initialize separation problem; fix first-stage variables
     initialize_separation(perf_con_to_maximize, model_data, config)
 
     separation_obj.activate()
 
+    solve_mode_adverb = "globally" if solve_globally else "locally"
     solve_call_results = SeparationSolveCallResults(
         solved_globally=solve_globally,
         time_out=False,
         results_list=[],
         found_violation=False,
         subsolver_error=False,
     )
-    timer = TicTocTimer()
     for idx, opt in enumerate(solvers):
         if idx > 0:
             config.progress_logger.warning(
                 f"Invoking backup solver {opt!r} "
                 f"(solver {idx + 1} of {len(solvers)}) for {solve_mode} "
                 f"separation of performance constraint {con_name_repr} "
                 f"in iteration {model_data.iteration}."
             )
-        orig_setting, custom_setting_present = adjust_solver_time_settings(
-            model_data.timing, opt, config
-        )
-        model_data.timing.start_timer(f"main.{solve_mode}_separation")
-        timer.tic(msg=None)
-        try:
-            results = opt.solve(
-                nlp_model,
-                tee=config.tee,
-                load_solutions=False,
-                symbolic_solver_labels=True,
-            )
-        except ApplicationError:
-            # account for possible external subsolver errors
-            # (such as segmentation faults, function evaluation
-            # errors, etc.)
-            adverb = "globally" if solve_globally else "locally"
-            config.progress_logger.error(
+        results = call_solver(
+            model=nlp_model,
+            solver=opt,
+            config=config,
+            timing_obj=model_data.timing,
+            timer_name=f"main.{solve_mode}_separation",
+            err_msg=(
                 f"Optimizer {repr(opt)} ({idx + 1} of {len(solvers)}) "
                 f"encountered exception attempting "
-                f"to {adverb} solve separation problem for constraint "
+                f"to {solve_mode_adverb} solve separation problem for constraint "
                 f"{con_name_repr} in iteration {model_data.iteration}."
-            )
-            raise
-        else:
-            setattr(results.solver, TIC_TOC_SOLVE_TIME_ATTR, timer.toc(msg=None))
-            model_data.timing.stop_timer(f"main.{solve_mode}_separation")
-        finally:
-            revert_solver_max_time_adjustment(
-                opt, orig_setting, custom_setting_present, config
-            )
+            ),
+        )
 
         # record termination condition for this particular solver
         solver_status_dict[str(opt)] = results.solver.termination_condition
         solve_call_results.results_list.append(results)
 
         # has PyROS time limit been reached?
         elapsed = get_main_elapsed_time(model_data.timing)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/solve_data.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/solve_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -343,37 +343,51 @@
     ----------
     solved_globally : bool
         True if separation problems were solved to global optimality,
         False otherwise.
     solver_call_results : ComponentMap
         Mapping from performance constraints to corresponding
         ``SeparationSolveCallResults`` objects.
-    worst_case_perf_con : None or int, optional
+    worst_case_perf_con : None or Constraint
         Performance constraint mapped to ``SeparationSolveCallResults``
         object in `self` corresponding to maximally violating
         separation problem solution.
+    all_discrete_scenarios_exhausted : bool, optional
+        For problems with discrete uncertainty sets,
+        True if all scenarios were explicitly accounted for in master
+        (which occurs if there have been
+        as many PyROS iterations as there are scenarios in the set)
+        False otherwise.
 
     Attributes
     ----------
     solver_call_results
     solved_globally
     worst_case_perf_con
+    all_discrete_scenarios_exhausted
     found_violation
     violating_param_realization
     scaled_violations
     violating_separation_variable_values
     subsolver_error
     time_out
     """
 
-    def __init__(self, solved_globally, solver_call_results, worst_case_perf_con):
+    def __init__(
+        self,
+        solved_globally,
+        solver_call_results,
+        worst_case_perf_con,
+        all_discrete_scenarios_exhausted=False,
+    ):
         """Initialize self (see class docstring)."""
         self.solver_call_results = solver_call_results
         self.solved_globally = solved_globally
         self.worst_case_perf_con = worst_case_perf_con
+        self.all_discrete_scenarios_exhausted = all_discrete_scenarios_exhausted
 
     @property
     def found_violation(self):
         """
         bool : True if separation solution for at least one
         ``SeparationSolveCallResults`` object listed in self
         was reported to violate its corresponding performance
@@ -596,14 +610,25 @@
         -------
         object
             Attribute value.
         """
         return getattr(self.main_loop_results, attr_name, None)
 
     @property
+    def all_discrete_scenarios_exhausted(self):
+        """
+        bool : For problems where the uncertainty set is of type
+        DiscreteScenarioSet,
+        True if last master problem solved explicitly
+        accounts for all scenarios in the uncertainty set,
+        False otherwise.
+        """
+        return self.get_violating_attr("all_discrete_scenarios_exhausted")
+
+    @property
     def worst_case_perf_con(self):
         """
         ConstraintData : Performance constraint corresponding to the
         separation solution chosen for the next master problem.
         """
         return self.get_violating_attr("worst_case_perf_con")
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/tests/test_config.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/tests/test_config.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 """
 Test objects for construction of PyROS ConfigDict.
 """
 
 import logging
 import unittest
 
-from pyomo.core.base import ConcreteModel, Var, _VarData
+from pyomo.core.base import ConcreteModel, Var, VarData
 from pyomo.common.log import LoggingIntercept
 from pyomo.common.errors import ApplicationError
-from pyomo.core.base.param import Param, _ParamData
+from pyomo.core.base.param import Param, ParamData
 from pyomo.contrib.pyros.config import (
     InputDataStandardizer,
     mutable_param_validator,
-    LoggerType,
+    logger_domain,
     SolverNotResolvable,
-    PositiveIntOrMinusOne,
+    positive_int_or_minus_one,
     pyros_config,
     SolverIterable,
     SolverResolvable,
 )
 from pyomo.contrib.pyros.util import ObjectiveType
 from pyomo.opt import SolverFactory, SolverResults
 from pyomo.contrib.pyros.uncertainty_sets import BoxSet
@@ -34,15 +34,15 @@
         """
         Test standardizer works for single component
         data-type entry.
         """
         mdl = ConcreteModel()
         mdl.v = Var([0, 1])
 
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         standardizer_input = mdl.v[0]
         standardizer_output = standardizer_func(standardizer_input)
 
         self.assertIsInstance(
             standardizer_output,
             list,
@@ -70,15 +70,15 @@
     def test_standardizer_indexed_component(self):
         """
         Test component standardizer works on indexed component.
         """
         mdl = ConcreteModel()
         mdl.v = Var([0, 1])
 
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         standardizer_input = mdl.v
         standardizer_output = standardizer_func(standardizer_input)
 
         self.assertIsInstance(
             standardizer_output,
             list,
@@ -109,15 +109,15 @@
         """
         Test standardizer works on sequence of components.
         """
         mdl = ConcreteModel()
         mdl.v = Var([0, 1])
         mdl.x = Var(["a", "b"])
 
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         standardizer_input = [mdl.v[0], mdl.x]
         standardizer_output = standardizer_func(standardizer_input)
         expected_standardizer_output = [mdl.v[0], mdl.x["a"], mdl.x["b"]]
 
         self.assertIsInstance(
             standardizer_output,
@@ -150,62 +150,62 @@
         Test standardizer raises exception if input contains duplicates
         and duplicates are not allowed.
         """
         mdl = ConcreteModel()
         mdl.v = Var([0, 1])
         mdl.x = Var(["a", "b"])
 
-        standardizer_func = InputDataStandardizer(Var, _VarData, allow_repeats=False)
+        standardizer_func = InputDataStandardizer(Var, VarData, allow_repeats=False)
 
         exc_str = r"Standardized.*list.*contains duplicate entries\."
         with self.assertRaisesRegex(ValueError, exc_str):
             standardizer_func([mdl.x, mdl.v, mdl.x])
 
     def test_standardizer_invalid_type(self):
         """
         Test standardizer raises exception as expected
         when input is of invalid type.
         """
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         exc_str = r"Input object .*is not of valid component type.*"
         with self.assertRaisesRegex(TypeError, exc_str):
             standardizer_func(2)
 
     def test_standardizer_iterable_with_invalid_type(self):
         """
         Test standardizer raises exception as expected
         when input is an iterable with entries of invalid type.
         """
         mdl = ConcreteModel()
         mdl.v = Var([0, 1])
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         exc_str = r"Input object .*entry of iterable.*is not of valid component type.*"
         with self.assertRaisesRegex(TypeError, exc_str):
             standardizer_func([mdl.v, 2])
 
     def test_standardizer_invalid_str_passed(self):
         """
         Test standardizer raises exception as expected
         when input is of invalid type str.
         """
-        standardizer_func = InputDataStandardizer(Var, _VarData)
+        standardizer_func = InputDataStandardizer(Var, VarData)
 
         exc_str = r"Input object .*is not of valid component type.*"
         with self.assertRaisesRegex(TypeError, exc_str):
             standardizer_func("abcd")
 
     def test_standardizer_invalid_uninitialized_params(self):
         """
         Test standardizer raises exception when Param with
         uninitialized entries passed.
         """
         standardizer_func = InputDataStandardizer(
-            ctype=Param, cdatatype=_ParamData, ctype_validator=mutable_param_validator
+            ctype=Param, cdatatype=ParamData, ctype_validator=mutable_param_validator
         )
 
         mdl = ConcreteModel()
         mdl.p = Param([0, 1])
 
         exc_str = r"Length of .*does not match that of.*index set"
         with self.assertRaisesRegex(ValueError, exc_str):
@@ -213,15 +213,15 @@
 
     def test_standardizer_invalid_immutable_params(self):
         """
         Test standardizer raises exception when immutable
         Param object(s) passed.
         """
         standardizer_func = InputDataStandardizer(
-            ctype=Param, cdatatype=_ParamData, ctype_validator=mutable_param_validator
+            ctype=Param, cdatatype=ParamData, ctype_validator=mutable_param_validator
         )
 
         mdl = ConcreteModel()
         mdl.p = Param([0, 1], initialize=1)
 
         exc_str = r"Param object with name .*immutable"
         with self.assertRaisesRegex(ValueError, exc_str):
@@ -233,15 +233,15 @@
         of valid mutable Param objects.
         """
         mdl = ConcreteModel()
         mdl.p1 = Param([0, 1], initialize=0, mutable=True)
         mdl.p2 = Param(["a", "b"], initialize=1, mutable=True)
 
         standardizer_func = InputDataStandardizer(
-            ctype=Param, cdatatype=_ParamData, ctype_validator=mutable_param_validator
+            ctype=Param, cdatatype=ParamData, ctype_validator=mutable_param_validator
         )
 
         standardizer_input = [mdl.p1[0], mdl.p2]
         standardizer_output = standardizer_func(standardizer_input)
         expected_standardizer_output = [mdl.p1[0], mdl.p2["a"], mdl.p2["b"]]
 
         self.assertIsInstance(
@@ -553,53 +553,66 @@
     Test validator for -1 or positive int works as expected.
     """
 
     def test_positive_int_or_minus_one(self):
         """
         Test positive int or -1 validator works as expected.
         """
-        standardizer_func = PositiveIntOrMinusOne()
-        self.assertIs(
-            standardizer_func(1.0),
+        standardizer_func = positive_int_or_minus_one
+        ans = standardizer_func(1.0)
+        self.assertEqual(
+            ans,
             1,
-            msg=(f"{PositiveIntOrMinusOne.__name__} does not standardize as expected."),
+            msg=f"{positive_int_or_minus_one.__name__} output value not as expected.",
+        )
+        self.assertIs(
+            type(ans),
+            int,
+            msg=f"{positive_int_or_minus_one.__name__} output type not as expected.",
         )
+
+        ans = standardizer_func(-1.0)
         self.assertEqual(
-            standardizer_func(-1.00),
+            ans,
             -1,
-            msg=(f"{PositiveIntOrMinusOne.__name__} does not standardize as expected."),
+            msg=f"{positive_int_or_minus_one.__name__} output value not as expected.",
+        )
+        self.assertIs(
+            type(ans),
+            int,
+            msg=f"{positive_int_or_minus_one.__name__} output type not as expected.",
         )
 
         exc_str = r"Expected positive int or -1, but received value.*"
         with self.assertRaisesRegex(ValueError, exc_str):
             standardizer_func(1.5)
         with self.assertRaisesRegex(ValueError, exc_str):
             standardizer_func(0)
 
 
-class TestLoggerType(unittest.TestCase):
+class TestLoggerDomain(unittest.TestCase):
     """
-    Test logger type validator.
+    Test logger type domain validator.
     """
 
     def test_logger_type(self):
         """
         Test logger type validator.
         """
-        standardizer_func = LoggerType()
+        standardizer_func = logger_domain
         mylogger = logging.getLogger("example")
         self.assertIs(
             standardizer_func(mylogger),
             mylogger,
-            msg=f"{LoggerType.__name__} output not as expected",
+            msg=f"{standardizer_func.__name__} output not as expected",
         )
         self.assertIs(
             standardizer_func(mylogger.name),
             mylogger,
-            msg=f"{LoggerType.__name__} output not as expected",
+            msg=f"{standardizer_func.__name__} output not as expected",
         )
 
         exc_str = r"A logger name must be a string"
         with self.assertRaisesRegex(Exception, exc_str):
             standardizer_func(2)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/tests/test_grcs.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/tests/test_grcs.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,14 +15,15 @@
 '''
 
 import pyomo.common.unittest as unittest
 from pyomo.common.log import LoggingIntercept
 from pyomo.common.collections import ComponentSet, ComponentMap
 from pyomo.common.config import ConfigBlock, ConfigValue
 from pyomo.core.base.set_types import NonNegativeIntegers
+from pyomo.core.base.var import VarData
 from pyomo.core.expr import (
     identify_variables,
     identify_mutable_parameters,
     MonomialTermExpression,
     SumExpression,
 )
 from pyomo.contrib.pyros.util import (
@@ -567,30 +568,38 @@
             # now we check the other terms.
             # these should comprise the DR polynomial expression
             dr_polynomial_terms = dr_eq_terms[:-1]
             dr_polynomial_zip = zip(
                 dr_polynomial_terms, indexed_dr_var.values(), dr_monomial_param_combos
             )
             for idx, (term, dr_var, param_combo) in enumerate(dr_polynomial_zip):
-                # term should be a monomial expression of form
-                # (uncertain parameter product) * (decision rule variable)
-                # so length of expression object should be 2
-                self.assertEqual(
-                    len(term.args),
-                    2,
-                    msg=(
-                        f"Length of `args` attribute of term {str(term)} "
-                        f"of DR equation {dr_eq.name!r} is not as expected. "
-                        f"Args: {term.args}"
-                    ),
-                )
+                # term should be either a monomial expression or scalar variable
+                if isinstance(term, MonomialTermExpression):
+                    # should be of form (uncertain parameter product) *
+                    # (decision rule variable) so length of expression
+                    # object should be 2
+                    self.assertEqual(
+                        len(term.args),
+                        2,
+                        msg=(
+                            f"Length of `args` attribute of term {str(term)} "
+                            f"of DR equation {dr_eq.name!r} is not as expected. "
+                            f"Args: {term.args}"
+                        ),
+                    )
+
+                    # check that uncertain parameters participating in
+                    # the monomial are as expected
+                    param_product_multiplicand = term.args[0]
+                    dr_var_multiplicand = term.args[1]
+                else:
+                    self.assertIsInstance(term, VarData)
+                    param_product_multiplicand = 1
+                    dr_var_multiplicand = term
 
-                # check that uncertain parameters participating in
-                # the monomial are as expected
-                param_product_multiplicand = term.args[0]
                 if idx == 0:
                     # static DR term
                     param_combo_found_in_term = (param_product_multiplicand,)
                     param_names = (str(param) for param in param_combo)
                 elif len(param_combo) == 1:
                     # affine DR terms
                     param_combo_found_in_term = (param_product_multiplicand,)
@@ -608,15 +617,14 @@
                         f"is not the uncertain parameter tuple "
                         f"({', '.join(param_names)})."
                     ),
                 )
 
                 # check that DR variable participating in the monomial
                 # is as expected
-                dr_var_multiplicand = term.args[1]
                 self.assertIs(
                     dr_var_multiplicand,
                     dr_var,
                     msg=(
                         f"Last multiplicand of DR monomial {str(term)} "
                         f"is not the DR variable {dr_var.name!r}."
                     ),
@@ -3783,14 +3791,15 @@
             ),
         )
         config.declare("subproblem_file_directory", ConfigValue(default=None))
         config.declare("time_limit", ConfigValue(default=None))
         config.declare(
             "progress_logger", ConfigValue(default=logging.getLogger(__name__))
         )
+        config.declare("symbolic_solver_labels", ConfigValue(default=False))
 
         with time_code(master_data.timing, "main", is_main_timer=True):
             master_soln = solve_master(master_data, config)
             self.assertEqual(
                 master_soln.termination_condition,
                 TerminationCondition.optimal,
                 msg=(
@@ -4329,22 +4338,24 @@
         self.assertEqual(
             results.pyros_termination_condition,
             pyrosTerminationCondition.time_out,
             msg="Returned termination condition is not return time_out.",
         )
 
     @unittest.skipUnless(
-        SolverFactory('gams').license_is_valid()
-        and SolverFactory('baron').license_is_valid(),
-        "Global NLP solver is not available and licensed.",
+        ipopt_available
+        and SolverFactory('gams').license_is_valid()
+        and SolverFactory('baron').license_is_valid()
+        and SolverFactory("scip").license_is_valid(),
+        "IPOPT not available or one of GAMS/BARON/SCIP not licensed",
     )
-    def test_gams_successful_time_limit(self):
+    def test_pyros_subsolver_time_limit_adjustment(self):
         """
-        Test PyROS time limit status returned in event
-        separation problem times out.
+        Check that PyROS does not ultimately alter state of
+        subordinate solver options due to time limit adjustments.
         """
         m = ConcreteModel()
         m.x1 = Var(initialize=0, bounds=(0, None))
         m.x2 = Var(initialize=0, bounds=(0, None))
         m.x3 = Var(initialize=0, bounds=(None, None))
         m.u = Param(initialize=1.125, mutable=True)
 
@@ -4355,97 +4366,60 @@
 
         # Define the uncertainty set
         interval = BoxSet(bounds=[(0.25, 2)])
 
         # Instantiate the PyROS solver
         pyros_solver = SolverFactory("pyros")
 
-        # Define subsolvers utilized in the algorithm
-        # two GAMS solvers, one of which has reslim set
-        # (overridden when invoked in PyROS)
+        # subordinate solvers to test.
+        # for testing, we pass each as the 'local' solver,
+        # and the BARON solver without custom options
+        # as the 'global' solver
+        baron_no_options = SolverFactory("baron")
         local_subsolvers = [
             SolverFactory("gams:conopt"),
             SolverFactory("gams:conopt"),
             SolverFactory("ipopt"),
+            SolverFactory("ipopt", options={"max_cpu_time": 300}),
+            SolverFactory("scip"),
+            SolverFactory("scip", options={"limits/time": 300}),
+            baron_no_options,
+            SolverFactory("baron", options={"MaxTime": 300}),
         ]
         local_subsolvers[0].options["add_options"] = ["option reslim=100;"]
-        global_subsolver = SolverFactory("baron")
-        global_subsolver.options["MaxTime"] = 300
 
         # Call the PyROS solver
         for idx, opt in enumerate(local_subsolvers):
+            original_solver_options = opt.options.copy()
             results = pyros_solver.solve(
                 model=m,
                 first_stage_variables=[m.x1, m.x2],
                 second_stage_variables=[],
                 uncertain_params=[m.u],
                 uncertainty_set=interval,
                 local_solver=opt,
-                global_solver=global_subsolver,
+                global_solver=baron_no_options,
                 objective_focus=ObjectiveType.worst_case,
                 solve_master_globally=True,
                 time_limit=100,
             )
-
             self.assertEqual(
                 results.pyros_termination_condition,
                 pyrosTerminationCondition.robust_optimal,
                 msg=(
-                    f"Returned termination condition with local "
-                    "subsolver {idx + 1} of 2 is not robust_optimal."
+                    "Returned termination condition with local "
+                    f"subsolver {idx + 1} of 2 is not robust_optimal."
                 ),
             )
-
-        # check first local subsolver settings
-        # remain unchanged after PyROS exit
-        self.assertEqual(
-            len(list(local_subsolvers[0].options["add_options"])),
-            1,
-            msg=(
-                f"Local subsolver {local_subsolvers[0]} options 'add_options'"
-                "were changed by PyROS"
-            ),
-        )
-        self.assertEqual(
-            local_subsolvers[0].options["add_options"][0],
-            "option reslim=100;",
-            msg=(
-                f"Local subsolver {local_subsolvers[0]} setting "
-                "'add_options' was modified "
-                "by PyROS, but changes were not properly undone"
-            ),
-        )
-
-        # check global subsolver settings unchanged
-        self.assertEqual(
-            len(list(global_subsolver.options.keys())),
-            1,
-            msg=(f"Global subsolver {global_subsolver} options were changed by PyROS"),
-        )
-        self.assertEqual(
-            global_subsolver.options["MaxTime"],
-            300,
-            msg=(
-                f"Global subsolver {global_subsolver} setting "
-                "'MaxTime' was modified "
-                "by PyROS, but changes were not properly undone"
-            ),
-        )
-
-        # check other local subsolvers remain unchanged
-        for slvr, key in zip(local_subsolvers[1:], ["add_options", "max_cpu_time"]):
-            # no custom options were added to the `options`
-            # attribute of the optimizer, so any attribute
-            # of `options` should be `None`
-            self.assertIs(
-                getattr(slvr.options, key, None),
-                None,
+            self.assertEqual(
+                opt.options,
+                original_solver_options,
                 msg=(
-                    f"Local subsolver {slvr} setting '{key}' was added "
-                    "by PyROS, but not reverted"
+                    f"Options for subordinate solver {opt} were changed "
+                    "by PyROS, and the changes wee not properly reverted."
                 ),
             )
 
     @unittest.skipUnless(
         baron_license_is_valid, "Global NLP solver is not available and licensed."
     )
     def test_terminate_with_application_error(self):
@@ -6194,14 +6168,15 @@
 
         ans = (
             "Solver options:\n"
             " time_limit=None\n"
             " keepfiles=False\n"
             " tee=False\n"
             " load_solution=True\n"
+            " symbolic_solver_labels=False\n"
             " objective_focus=<ObjectiveType.nominal: 2>\n"
             " nominal_uncertain_param_vals=[0.5]\n"
             " decision_rule_order=0\n"
             " solve_master_globally=False\n"
             " max_iter=-1\n"
             " robust_feasibility_tolerance=0.0001\n"
             " separation_priority_order={}\n"
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/uncertainty_sets.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/uncertainty_sets.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/pyros/util.py` & `Pyomo-6.7.2/pyomo/contrib/pyros/util.py`

 * *Files 3% similar despite different names*

```diff
@@ -12,15 +12,17 @@
 '''
 Utility functions for the PyROS solver
 '''
 
 import copy
 from enum import Enum, auto
 from pyomo.common.collections import ComponentSet, ComponentMap
+from pyomo.common.errors import ApplicationError
 from pyomo.common.modeling import unique_component_name
+from pyomo.common.timing import TicTocTimer
 from pyomo.core.base import (
     Constraint,
     Var,
     ConstraintList,
     Objective,
     minimize,
     Expression,
@@ -226,23 +228,23 @@
 def get_main_elapsed_time(timing_data_obj):
     """Returns the time since entering the main `time_code` context"""
     return timing_data_obj.get_main_elapsed_time()
 
 
 def adjust_solver_time_settings(timing_data_obj, solver, config):
     """
-    Adjust solver max time setting based on current PyROS elapsed
-    time.
+    Adjust maximum time allowed for subordinate solver, based
+    on total PyROS solver elapsed time up to this point.
 
     Parameters
     ----------
     timing_data_obj : Bunch
         PyROS timekeeper.
     solver : solver type
-        Solver for which to adjust the max time setting.
+        Subordinate solver for which to adjust the max time setting.
     config : ConfigDict
         PyROS solver config.
 
     Returns
     -------
     original_max_time_setting : float or None
         If IPOPT or BARON is used, a float is returned.
@@ -256,53 +258,84 @@
         is not None, False otherwise.
         If ``config.time_limit`` is None, then None is returned.
 
     Note
     ----
     (1) Adjustment only supported for GAMS, BARON, and IPOPT
         interfaces. This routine can be generalized to other solvers
-        after a generic interface to the time limit setting
+        after a generic Pyomo interface to the time limit setting
         is introduced.
-    (2) For IPOPT, and probably also BARON, the CPU time limit
-        rather than the wallclock time limit, is adjusted, as
-        no interface to wallclock limit available.
-        For this reason, extra 30s is added to time remaining
-        for subsolver time limit.
-        (The extra 30s is large enough to ensure solver
-        elapsed time is not beneath elapsed time - user time limit,
-        but not so large as to overshoot the user-specified time limit
-        by an inordinate margin.)
-    """
+    (2) For IPOPT and BARON, the CPU time limit,
+        rather than the wallclock time limit, may be adjusted,
+        as there may be no means by which to specify the wall time
+        limit explicitly.
+    (3) For GAMS, we adjust the time limit through the GAMS Reslim
+        option. However, this may be overridden by any user
+        specifications included in a GAMS optfile, which may be
+        difficult to track down.
+    (4) To ensure the time limit is specified to a strictly
+        positive value, the time limit is adjusted to a value of
+        at least 1 second.
+    """
+    # in case there is no time remaining: we set time limit
+    # to a minimum of 1s, as some solvers require a strictly
+    # positive time limit
+    time_limit_buffer = 1
+
     if config.time_limit is not None:
         time_remaining = config.time_limit - get_main_elapsed_time(timing_data_obj)
         if isinstance(solver, type(SolverFactory("gams", solver_io="shell"))):
             original_max_time_setting = solver.options["add_options"]
             custom_setting_present = "add_options" in solver.options
 
-            # adjust GAMS solver time
-            reslim_str = f"option reslim={max(30, 30 + time_remaining)};"
+            # note: our time limit will be overridden by any
+            #       time limits specified by the user through a
+            #       GAMS optfile, but tracking down the optfile
+            #       and/or the GAMS subsolver specific option
+            #       is more difficult
+            reslim_str = "option reslim=" f"{max(time_limit_buffer, time_remaining)};"
             if isinstance(solver.options["add_options"], list):
                 solver.options["add_options"].append(reslim_str)
             else:
                 solver.options["add_options"] = [reslim_str]
         else:
             # determine name of option to adjust
             if isinstance(solver, SolverFactory.get_class("baron")):
                 options_key = "MaxTime"
             elif isinstance(solver, SolverFactory.get_class("ipopt")):
-                options_key = "max_cpu_time"
+                options_key = (
+                    # IPOPT 3.14.0+ added support for specifying
+                    # wall time limit explicitly; this is preferred
+                    # over CPU time limit
+                    "max_wall_time"
+                    if solver.version() >= (3, 14, 0, 0)
+                    else "max_cpu_time"
+                )
+            elif isinstance(solver, SolverFactory.get_class("scip")):
+                options_key = "limits/time"
             else:
                 options_key = None
 
             if options_key is not None:
                 custom_setting_present = options_key in solver.options
                 original_max_time_setting = solver.options[options_key]
 
-                # ensure positive value assigned to avoid application error
-                solver.options[options_key] = max(30, 30 + time_remaining)
+                # account for elapsed time remaining and
+                # original time limit setting.
+                # if no original time limit is set, then we assume
+                # there is no time limit, rather than tracking
+                # down the solver-specific default
+                orig_max_time = (
+                    float("inf")
+                    if original_max_time_setting is None
+                    else original_max_time_setting
+                )
+                solver.options[options_key] = min(
+                    max(time_limit_buffer, time_remaining), orig_max_time
+                )
             else:
                 custom_setting_present = False
                 original_max_time_setting = None
                 config.progress_logger.warning(
                     "Subproblem time limit setting not adjusted for "
                     f"subsolver of type:\n    {type(solver)}.\n"
                     "    PyROS time limit may not be honored "
@@ -341,34 +374,31 @@
         # determine name of option to adjust
         if isinstance(solver, type(SolverFactory("gams", solver_io="shell"))):
             options_key = "add_options"
         elif isinstance(solver, SolverFactory.get_class("baron")):
             options_key = "MaxTime"
         elif isinstance(solver, SolverFactory.get_class("ipopt")):
             options_key = "max_cpu_time"
+        elif isinstance(solver, SolverFactory.get_class("scip")):
+            options_key = "limits/time"
         else:
             options_key = None
 
         if options_key is not None:
             if custom_setting_present:
                 # restore original setting
                 solver.options[options_key] = original_max_time_setting
 
                 # if GAMS solver used, need to remove the last entry
                 # of 'add_options', which contains the max time setting
                 # added by PyROS
                 if isinstance(solver, type(SolverFactory("gams", solver_io="shell"))):
                     solver.options[options_key].pop()
             else:
-                # remove the max time specification introduced.
-                # All lines are needed here to completely remove the option
-                # from access through getattr and dictionary reference.
                 delattr(solver.options, options_key)
-                if options_key in solver.options.keys():
-                    del solver.options[options_key]
 
 
 class PreformattedLogger(logging.Logger):
     """
     A specialized logger object designed to cast log messages
     to Pyomo `Preformatted` objects prior to logging the messages.
     Useful for circumventing the formatters of the standard Pyomo
@@ -828,30 +858,30 @@
 
 
 def get_state_vars(blk, first_stage_variables, second_stage_variables):
     """
     Get state variables of a modeling block.
 
     The state variables with respect to `blk` are the unfixed
-    `_VarData` objects participating in the active objective
+    `VarData` objects participating in the active objective
     or constraints descended from `blk` which are not
     first-stage variables or second-stage variables.
 
     Parameters
     ----------
     blk : ScalarBlock
         Block of interest.
     first_stage_variables : Iterable of VarData
         First-stage variables.
     second_stage_variables : Iterable of VarData
         Second-stage variables.
 
     Yields
     ------
-    _VarData
+    VarData
         State variable.
     """
     dof_var_set = ComponentSet(first_stage_variables) | ComponentSet(
         second_stage_variables
     )
     for var in get_vars_from_component(blk, (Objective, Constraint)):
         is_state_var = not var.fixed and var not in dof_var_set
@@ -950,15 +980,15 @@
     model : ConcreteModel
         Input deterministic model.
     config : ConfigDict
         PyROS solver options.
 
     Returns
     -------
-    list of _VarData
+    list of VarData
         State variables of the model.
 
     Raises
     ------
     ValueError
         If first-stage variables and second-stage variables
         overlap, or there are no first-stage variables
@@ -1727,14 +1757,88 @@
         else:
             raise NotImplementedError(
                 "This solver return termination condition (%s) "
                 "is currently not supported by PyROS." % termination_condition
             )
 
 
+def call_solver(model, solver, config, timing_obj, timer_name, err_msg):
+    """
+    Solve a model with a given optimizer, keeping track of
+    wall time requirements.
+
+    Parameters
+    ----------
+    model : ConcreteModel
+        Model of interest.
+    solver : Pyomo solver type
+        Subordinate optimizer.
+    config : ConfigDict
+        PyROS solver settings.
+    timing_obj : TimingData
+        PyROS solver timing data object.
+    timer_name : str
+        Name of sub timer under the hierarchical timer contained in
+        ``timing_obj`` to start/stop for keeping track of solve
+        time requirements.
+    err_msg : str
+        Message to log through ``config.progress_logger.exception()``
+        in event an ApplicationError is raised while attempting to
+        solve the model.
+
+    Returns
+    -------
+    SolverResults
+        Solve results. Note that ``results.solver`` contains
+        an additional attribute, named after
+        ``TIC_TOC_SOLVE_TIME_ATTR``, of which the value is set to the
+        recorded solver wall time.
+
+    Raises
+    ------
+    ApplicationError
+        If ApplicationError is raised by the solver.
+        In this case, `err_msg` is logged through
+        ``config.progress_logger.exception()`` before
+        the exception is raised.
+    """
+    tt_timer = TicTocTimer()
+
+    orig_setting, custom_setting_present = adjust_solver_time_settings(
+        timing_obj, solver, config
+    )
+    timing_obj.start_timer(timer_name)
+    tt_timer.tic(msg=None)
+
+    try:
+        results = solver.solve(
+            model,
+            tee=config.tee,
+            load_solutions=False,
+            symbolic_solver_labels=config.symbolic_solver_labels,
+        )
+    except ApplicationError:
+        # account for possible external subsolver errors
+        # (such as segmentation faults, function evaluation
+        # errors, etc.)
+        config.progress_logger.error(err_msg)
+        raise
+    else:
+        setattr(
+            results.solver, TIC_TOC_SOLVE_TIME_ATTR, tt_timer.toc(msg=None, delta=True)
+        )
+    finally:
+        timing_obj.stop_timer(timer_name)
+        revert_solver_max_time_adjustment(
+            solver, orig_setting, custom_setting_present, config
+        )
+
+    return results
+
+
 class IterationLogRecord:
     """
     PyROS solver iteration log record.
 
     Parameters
     ----------
     iteration : int or None, optional
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/satsolver/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/satsolver/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/satsolver/satsolver.py` & `Pyomo-6.7.2/pyomo/contrib/satsolver/satsolver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/satsolver/test_satsolver.py` & `Pyomo-6.7.2/pyomo/contrib/satsolver/test_satsolver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/HIV_Transmission.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/HIV_Transmission.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/feedbackController.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/feedbackController.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/parameter.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/parameter.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/parameter_kaug.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/parameter_kaug.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/rangeInequality.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/rangeInequality.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/examples/rooney_biegler.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/examples/rooney_biegler.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/k_aug.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/k_aug.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/sens.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/sens.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/simplification/tests/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,22 +4,7 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
-
-# ___________________________________________________________________________
-#
-# Pyomo: Python Optimization Modeling Objects
-# Copyright (c) 2008-2024
-#  National Technology and Engineering Solutions of Sandia, LLC
-# Under the terms of Contract DE-NA0003525 with National Technology and
-# Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
-# rights in this software.
-# This software is distributed under the 3-clause BSD License.
-# ___________________________________________________________________________
-
-"""
-pyomo.contrib.sensitivity_toolbox tests
-"""
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_k_aug_interface.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_k_aug_interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_sens.py` & `Pyomo-6.7.2/pyomo/contrib/sensitivity_toolbox/tests/test_sens.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/sensitivity_toolbox/tests/test_sens_unit.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_expression.py`

 * *Files 24% similar despite different names*

```diff
@@ -5,886 +5,1043 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-# ____________________________________________________________________________
-#
-# Pyomo: Python Optimization Modeling Objects
-# Copyright (c) 2008-2024
-#  National Technology and Engineering Solutions of Sandia, LLC
-# Under the terms of Contract DE-NA0003525 with National Technology and
-# Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
-# rights in this software.
-# This software is distributed under the 3-clause BSD License.
-# ____________________________________________________________________________
+import copy
+
+from io import StringIO
+from pyomo.core.expr import expr_common
 
-"""
-Unit Tests for interfacing with sIPOPT and k_aug
-"""
 
 import pyomo.common.unittest as unittest
-from io import StringIO
-import logging
+import pyomo.core.expr as EXPR
 
 from pyomo.environ import (
     ConcreteModel,
-    Objective,
-    Param,
+    AbstractModel,
+    Expression,
     Var,
-    Block,
-    Suffix,
+    Set,
+    Param,
+    Objective,
     value,
-    Constraint,
-    inequality,
-    NonNegativeReals,
-    minimize,
-    exp,
-)
-from pyomo.core.base.component import ComponentData
-from pyomo.common.dependencies import scipy_available
-from pyomo.common.log import LoggingIntercept
-from pyomo.common.collections import ComponentMap, ComponentSet
-from pyomo.core.expr.visitor import identify_variables, identify_mutable_parameters
-from pyomo.contrib.sensitivity_toolbox.sens import (
-    SensitivityInterface,
-    _NotAnIndex,
-    get_dsdp,
-    get_dfds_dcds,
-    line_num,
+    sum_product,
 )
-import pyomo.contrib.sensitivity_toolbox.examples.parameter as param_example
-from pyomo.opt import SolverFactory
-
-from pyomo.common.dependencies import (
-    numpy as np,
-    numpy_available,
-    pandas as pd,
-    pandas_available,
-)
-from pyomo.common.dependencies import scipy_available
-
-opt_ipopt = SolverFactory('ipopt', solver_io='nl')
-opt_kaug = SolverFactory('k_aug', solver_io='nl')
-opt_dotsens = SolverFactory('dot_sens', solver_io='nl')
-
-
-def make_indexed_model():
-    """
-    Creates the model used in the "parameter.py" example, but with indexed
-    variables, parameters, and constraints.
-    """
-    m = ConcreteModel()
-
-    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
-
-    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
-
-    m.const = Constraint(
-        [1, 2],
-        rule={
-            1: 6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3] - m.eta[1] == 0,
-            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 == 0,
-        },
-    )
-
-    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
-
-    return m
-
-
-def make_model_with_inequalities():
-    """
-    Creates a modified version of the model used in the "parameter.py"
-    example, now with simple (one-sided) inequalities.
-    """
-    m = ConcreteModel()
-
-    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
-
-    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
-
-    m.const = Constraint(
-        [1, 2],
-        rule={
-            1: 6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3] >= m.eta[1],
-            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 <= 0,
-        },
-    )
-
-    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
-
-    return m
-
-
-def make_model_with_ranged_inequalities():
-    """
-    Creates a modified version of the model used in the "parameter.py"
-    example, now with simple (one-sided) inequalities.
-    """
-    m = ConcreteModel()
-
-    m.x = Var([1, 2, 3], initialize={1: 0.15, 2: 0.15, 3: 0.0}, domain=NonNegativeReals)
-
-    m.p = Param(initialize=10.0, mutable=True)
-
-    m.eta = Param([1, 2], initialize={1: 4.5, 2: 1.0}, mutable=True)
-
-    m.const = Constraint(
-        [1, 2],
-        rule={
-            1: inequality(
-                lower=-m.eta[1],
-                body=6 * m.x[1] + 3 * m.x[2] + 2 * m.x[3],
-                upper=m.p + m.eta[1],
-            ),
-            2: m.eta[2] * m.x[1] + m.x[2] - m.x[3] - 1 <= 0,
-        },
-    )
-
-    m.cost = Objective(expr=m.x[1] ** 2 + m.x[2] ** 2 + m.x[3] ** 2)
-
-    return m
-
-
-class TestSensitivityInterface(unittest.TestCase):
-    def assertIsSubset(self, s1, s2):
-        for item in s1:
-            self.assertIn(item, s2)
-
-    def test_get_names(self):
-        block_name = SensitivityInterface.get_default_block_name()
-        self.assertEqual(block_name, "_SENSITIVITY_TOOLBOX_DATA")
-
-        var_name = 'var'
-        sens_var_name = SensitivityInterface.get_default_var_name(var_name)
-        self.assertEqual(sens_var_name, var_name)
-
-        param_name = 'param'
-        sens_param_name = SensitivityInterface.get_default_param_name(param_name)
-        self.assertEqual(sens_param_name, param_name)
-
-    def test_constructor_clone(self):
-        model = param_example.create_model()
-        sens = SensitivityInterface(model)
-        self.assertIs(sens._original_model, model)
-        self.assertIsNot(sens.model_instance, model)
-
-    def test_constructor_no_clone(self):
-        model = param_example.create_model()
-        sens = SensitivityInterface(model, clone_model=False)
-        self.assertIs(sens._original_model, model)
-        self.assertIs(sens.model_instance, model)
-
-    def test_add_data_block(self):
-        model = param_example.create_model()
-        sens = SensitivityInterface(model, clone_model=False)
-
-        block = sens._add_data_block()
-        self.assertIs(sens.block.parent_block(), sens.model_instance)
-        self.assertIs(sens.block.ctype, Block)
-        self.assertEqual(sens.block.local_name, sens.get_default_block_name())
-
-        with self.assertRaises(RuntimeError) as ex:
-            sens._add_data_block()
-        # We just tried adding the same block twice.
-        self.assertIn("Cannot add component", str(ex.exception))
-
-        # Try re-adding the same block, but this time we are prepared
-        # for it to already exist.
-        new_block = sens._add_data_block(existing_block=block)
-        self.assertIsNot(block, new_block)
-
-        new_block._has_replaced_expressions = True
-        with self.assertRaises(RuntimeError) as ex:
-            sens._add_data_block(existing_block=new_block)
-        # Cannot remove and re-add sensitivity block if expressions
-        # were replaced.
-        self.assertIn("Re-using sensitivity interface", str(ex.exception))
-
-    def test_process_param_list(self):
-        model = make_indexed_model()
-        sens = SensitivityInterface(model, clone_model=False)
-
-        param_list = [model.x[1], model.eta]
-        new_param_list = sens._process_param_list(param_list)
-        self.assertIs(param_list, new_param_list)
-
-        sens = SensitivityInterface(model, clone_model=True)
-        new_param_list = sens._process_param_list(param_list)
-        # The new param list contains the "same" variables in the
-        # cloned model.
-        self.assertIs(new_param_list[0], sens.model_instance.x[1])
-        self.assertIs(new_param_list[1], sens.model_instance.eta)
-
-    def test_add_sensitivity_data(self):
-        model = make_indexed_model()
-        sens = SensitivityInterface(model, clone_model=False)
-        sens._add_data_block()
-
-        param_list = [model.x, model.eta]
-        with self.assertRaises(ValueError) as exc:
-            sens._add_sensitivity_data(param_list)
-        self.assertIn("variables must be fixed", str(exc.exception))
-
-        sens.model_instance.x.fix()
-        # NOTE: sending the same component twice probably shouldn't
-        # be supported. It is convenient for testing, however.
-        param_list = [model.x, model.x[1], model.eta, model.eta[1]]
-        sens._add_sensitivity_data(param_list)
-
-        block_param_list = list(sens.block.component_data_objects(Param))
-        block_var_list = list(sens.block.component_data_objects(Var))
-        self.assertEqual(len(block_param_list), 4)
-        self.assertEqual(len(block_var_list), 3)
-        self.assertEqual(len(sens.block._sens_data_list), 7)
-
-        pred_sens_data_list = [
-            (model.x[1], Param, 0, 1),
-            (model.x[2], Param, 0, 2),
-            (model.x[3], Param, 0, 3),
-            (model.x[1], Param, 1, _NotAnIndex),
-            (Var, model.eta[1], 2, 1),
-            (Var, model.eta[2], 2, 2),
-            (Var, model.eta[1], 3, _NotAnIndex),
-        ]
-
-        for data, pred in zip(sens.block._sens_data_list, pred_sens_data_list):
-            if isinstance(pred[0], ComponentData):
-                self.assertIs(data[0], pred[0])
-                self.assertIs(data[1].ctype, pred[1])
-                name = data[0].parent_component().local_name
-                self.assertTrue(data[1].parent_component().local_name.startswith(name))
+from pyomo.core.base.expression import ExpressionData
+from pyomo.core.expr.compare import compare_expressions, assertExpressionsEqual
+from pyomo.common.tee import capture_output
+
+
+class TestExpressionData(unittest.TestCase):
+    def test_exprdata_get_set(self):
+        model = ConcreteModel()
+        model.e = Expression([1])
+        self.assertEqual(len(model.e), 1)
+        self.assertEqual(model.e[1].expr, None)
+        model.e.add(1, 1)
+        self.assertEqual(model.e[1].expr, 1)
+        model.e[1].expr += 2
+        self.assertEqual(model.e[1].expr, 3)
+
+    def test_exprdata_get_set_value(self):
+        model = ConcreteModel()
+        model.e = Expression([1])
+        self.assertEqual(len(model.e), 1)
+        self.assertEqual(model.e[1].expr, None)
+        model.e.add(1, 1)
+        model.e[1].expr = 1
+        self.assertEqual(model.e[1].expr, 1)
+        model.e[1].expr += 2
+        self.assertEqual(model.e[1].expr, 3)
+
+    # The copy method must be invoked on expression container to obtain
+    # a shallow copy of the class, the underlying expression remains
+    # a reference.
+    def test_copy(self):
+        model = ConcreteModel()
+        model.a = Var(initialize=5)
+        model.b = Var(initialize=10)
+
+        model.expr1 = Expression(initialize=model.a)
+
+        # Do a shallow copy, the same underlying expression is still referenced
+        expr2 = copy.copy(model.expr1)
+        self.assertEqual(model.expr1(), 5)
+        self.assertEqual(expr2(), 5)
+        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
+
+        # Do an in place modification the expression
+        model.expr1.expr.set_value(1)
+        self.assertEqual(model.expr1(), 1)
+        self.assertEqual(expr2(), 1)
+        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
+
+        # Update the expression value on expr1 only
+        model.expr1.set_value(model.b)
+        self.assertEqual(model.expr1(), 10)
+        self.assertEqual(expr2(), 1)
+        self.assertNotEqual(id(model.expr1.expr), id(expr2.expr))
+
+        model.a.set_value(5)
+        model.b.set_value(10)
+        model.del_component('expr1')
+        model.expr1 = Expression(initialize=model.a + model.b)
+
+        # Do a shallow copy, the same underlying expression is still referenced
+        expr2 = copy.copy(model.expr1)
+        self.assertEqual(model.expr1(), 15)
+        self.assertEqual(expr2(), 15)
+        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
+        self.assertEqual(id(model.expr1.expr.arg(0)), id(expr2.expr.arg(0)))
+        self.assertEqual(id(model.expr1.expr.arg(1)), id(expr2.expr.arg(1)))
+
+        # Do an in place modification the expression
+        # This causes cloning due to reference counting
+        model.a.set_value(0)
+        self.assertEqual(model.expr1(), 10)
+        self.assertEqual(expr2(), 10)
+        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
+        self.assertEqual(id(model.expr1.expr.arg(0)), id(expr2.expr.arg(0)))
+        self.assertEqual(id(model.expr1.expr.arg(1)), id(expr2.expr.arg(1)))
+
+        # Do an in place modification the expression
+        # This causes cloning due to reference counting
+        model.expr1.expr += 1
+        self.assertEqual(model.expr1(), 11)
+        self.assertEqual(expr2(), 10)
+        self.assertNotEqual(id(model.expr1.expr), id(expr2.expr))
+
+    # test that an object is properly deepcopied when the model is cloned
+    def test_model_clone(self):
+        model = ConcreteModel()
+        model.x = Var(initialize=2.0)
+        model.y = Var(initialize=0.0)
+        model.ec = Expression(initialize=model.x**2 + 1)
+        model.obj = Objective(expr=model.y + model.ec)
+        self.assertEqual(model.obj.expr(), 5.0)
+        self.assertTrue(id(model.ec) in [id(e) for e in model.obj.expr.args])
+        inst = model.clone()
+        self.assertEqual(inst.obj.expr(), 5.0)
+        if not id(inst.ec) in [id(e) for e in inst.obj.expr.args]:
+            print("BUG?")
+            print(id(inst.ec))
+            print(inst.obj.expr.__class__)
+            print([id(e) for e in inst.obj.expr.args])
+            print([e.__class__ for e in inst.obj.expr.args])
+            print([id(e) for e in model.obj.expr.args])
+            print([e.__class__ for e in model.obj.expr.args])
+        self.assertTrue(id(inst.ec) in [id(e) for e in inst.obj.expr.args])
+        self.assertNotEqual(id(model.ec), id(inst.ec))
+        self.assertFalse(id(inst.ec) in [id(e) for e in model.obj.expr.args])
+
+    def test_is_constant(self):
+        model = ConcreteModel()
+        model.x = Var(initialize=1.0)
+        model.p = Param(initialize=1.0)
+        model.ec = Expression(initialize=model.x)
+        self.assertEqual(model.ec.is_constant(), False)
+        self.assertEqual(model.ec.expr.is_constant(), False)
+        model.ec.set_value(model.p)
+        self.assertEqual(model.ec.is_constant(), False)
+        self.assertEqual(model.ec.expr.is_constant(), True)
+
+    def test_polynomial_degree(self):
+        model = ConcreteModel()
+        model.x = Var(initialize=1.0)
+        model.ec = Expression(initialize=model.x)
+        self.assertEqual(
+            model.ec.polynomial_degree(), model.ec.expr.polynomial_degree()
+        )
+        self.assertEqual(model.ec.polynomial_degree(), 1)
+        model.ec.set_value(model.x**2)
+        self.assertEqual(
+            model.ec.polynomial_degree(), model.ec.expr.polynomial_degree()
+        )
+        self.assertEqual(model.ec.polynomial_degree(), 2)
+
+    def test_init_concrete(self):
+        model = ConcreteModel()
+        model.y = Var(initialize=0.0)
+        model.x = Var(initialize=1.0)
+
+        model.ec = Expression(expr=0)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=model.y)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.y.set_value(-1)
+        model.ec = Expression(initialize=model.y + 1.0)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+    def test_init_abstract(self):
+        model = AbstractModel()
+        model.y = Var(initialize=0.0)
+        model.x = Var(initialize=1.0)
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+
+class TestExpression(unittest.TestCase):
+    def setUp(self):
+        TestExpression._save = expr_common.TO_STRING_VERBOSE
+        # Tests can choose what they want - this just makes sure that
+        # things are restored after the tests run.
+        # expr_common.TO_STRING_VERBOSE = True
+
+    def tearDown(self):
+        expr_common.TO_STRING_VERBOSE = TestExpression._save
+
+    def test_unconstructed_singleton(self):
+        a = Expression()
+        self.assertEqual(a._constructed, False)
+        self.assertEqual(len(a), 0)
+        try:
+            a()
+            self.fail("Component is unconstructed")
+        except ValueError:
+            pass
+        try:
+            a.expr
+            self.fail("Component is unconstructed")
+        except ValueError:
+            pass
+        try:
+            a.is_constant()
+            self.fail("Component is unconstructed")
+        except ValueError:
+            pass
+        try:
+            a.is_fixed()
+            self.fail("Component is unconstructed")
+        except ValueError:
+            pass
+        try:
+            a.set_value(4)
+            self.fail("Component is unconstructed")
+        except ValueError:
+            pass
+        a.construct()
+        self.assertEqual(len(a), 1)
+        self.assertEqual(a(), None)
+        self.assertEqual(a.expr, None)
+        self.assertEqual(a.is_constant(), False)
+        a.set_value(5)
+        self.assertEqual(len(a), 1)
+        self.assertEqual(a(), 5)
+        self.assertEqual(a.expr, 5)
+        self.assertEqual(a.is_constant(), False)
+        self.assertEqual(a.is_fixed(), True)
+
+    def test_display(self):
+        model = ConcreteModel()
+        model.e = Expression()
+        with capture_output() as out:
+            model.e.display()
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+e : Size=1
+    Key  : Value
+    None : Undefined
+        """.strip(),
+        )
+
+        model.e.set_value(1.0)
+        with capture_output() as out:
+            model.e.display()
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+e : Size=1
+    Key  : Value
+    None :   1.0
+        """.strip(),
+        )
+
+        out = StringIO()
+        with capture_output() as no_out:
+            model.e.display(ostream=out)
+        self.assertEqual(no_out.getvalue(), "")
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+e : Size=1
+    Key  : Value
+    None :   1.0
+        """.strip(),
+        )
+
+        model.E = Expression([1, 2])
+        with capture_output() as out:
+            model.E.display()
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+E : Size=2
+    Key : Value
+      1 : Undefined
+      2 : Undefined
+        """.strip(),
+        )
+
+        model.E[1].set_value(1.0)
+        with capture_output() as out:
+            model.E.display()
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+E : Size=2
+    Key : Value
+      1 :       1.0
+      2 : Undefined
+        """.strip(),
+        )
+
+        out = StringIO()
+        with capture_output() as no_out:
+            model.E.display(ostream=out)
+        self.assertEqual(no_out.getvalue(), "")
+        self.assertEqual(
+            out.getvalue().strip(),
+            """
+E : Size=2
+    Key : Value
+      1 :       1.0
+      2 : Undefined
+        """.strip(),
+        )
+
+    def test_extract_values_store_values(self):
+        model = ConcreteModel()
+        model.e = Expression()
+        self.assertEqual(model.e.extract_values(), {None: None})
+        model.e.store_values({None: 1.0})
+        self.assertEqual(model.e.extract_values(), {None: 1.0})
+        with self.assertRaises(KeyError):
+            model.e.store_values({1: 1.0})
+
+        model.E = Expression([1, 2])
+        self.assertEqual(model.E.extract_values(), {1: None, 2: None})
+        model.E.store_values({1: 1.0})
+        self.assertEqual(model.E.extract_values(), {1: 1.0, 2: None})
+        model.E.store_values({1: None, 2: 2.0})
+        self.assertEqual(model.E.extract_values(), {1: None, 2: 2.0})
+        with self.assertRaises(KeyError):
+            model.E.store_values({3: 3.0})
+
+    def test_setitem(self):
+        model = ConcreteModel()
+        model.E = Expression([1])
+        model.E[1] = 1
+        self.assertEqual(value(model.E[1]), 1)
+        with self.assertRaises(KeyError):
+            model.E[2] = 1
+        model.del_component(model.E)
+        model.Index = Set(dimen=3, initialize=[(1, 2, 3)])
+        model.E = Expression(model.Index)
+        model.E[(1, 2, 3)] = 1
+        self.assertEqual(value(model.E[(1, 2, 3)]), 1)
+        # GH: testing this ludicrous behavior simply for
+        #     coverage in expression.py.
+        model.E[(1, (2, 3))] = 1
+        self.assertEqual(value(model.E[(1, 2, 3)]), 1)
+        with self.assertRaises(KeyError):
+            model.E[2] = 1
+
+    def test_nonindexed_construct_rule(self):
+        model = ConcreteModel()
+
+        def _some_rule(model):
+            return 1.0
+
+        model.e = Expression(rule=_some_rule)
+        self.assertEqual(value(model.e), 1.0)
+        model.del_component(model.e)
+        del _some_rule
+
+        def _some_rule(model):
+            return Expression.Skip
+
+        model.e = Expression(rule=_some_rule)
+        self.assertEqual(len(model.e), 0)
+
+    def test_nonindexed_construct_expr(self):
+        model = ConcreteModel()
+        model.e = Expression(expr=Expression.Skip)
+        self.assertEqual(len(model.e), 0)
+        model.del_component(model.e)
+        model.e = Expression()
+        self.assertEqual(model.e.extract_values(), {None: None})
+        model.del_component(model.e)
+        model.e = Expression(expr=1.0)
+        self.assertEqual(model.e.extract_values(), {None: 1.0})
+        model.del_component(model.e)
+        model.e = Expression(expr={None: 1.0})
+        self.assertEqual(model.e.extract_values(), {None: 1.0})
+        # Even though add can be called with any
+        # indexed on indexed Expressions, None must
+        # always be used as the index for non-indexed
+        # Expressions
+        with self.assertRaises(KeyError):
+            model.e.add(2, 2)
+
+    def test_indexed_construct_rule(self):
+        model = ConcreteModel()
+        model.Index = Set(initialize=[1, 2, 3])
+
+        def _some_rule(model, i):
+            if i == 1:
+                return Expression.Skip
             else:
-                self.assertIs(data[0].ctype, pred[0])
-                self.assertIs(data[1], pred[1])
-                name = data[1].parent_component().local_name
-                self.assertTrue(data[0].parent_component().local_name.startswith(name))
-            self.assertEqual(data[2], pred[2])
-            self.assertEqual(data[3], pred[3])
-
-    def test_expression_replacement_no_replacement(self):
-        model = make_indexed_model()
-        sens = SensitivityInterface(model, clone_model=False)
-        sens._add_data_block()
-        instance = sens.model_instance
-        block = sens.block
-        instance.x.fix()
-        param_list = [instance.x[1], instance.x[2], instance.x[3]]
-        sens._add_sensitivity_data(param_list)
-
-        self.assertEqual(len(block.constList), 0)
-        variable_sub_map = {}
-        sens._replace_parameters_in_constraints(variable_sub_map)
-        self.assertEqual(len(block.constList), 2)
-
-        # Rely on order of constraints here... Fine as long as
-        # component_data_objects iteration is deterministic
-        pred_const_list = [instance.const[1], instance.const[2]]
-        for orig, replaced in zip(pred_const_list, block.constList.values()):
-            self.assertEqual(orig.expr.to_string(), replaced.expr.to_string())
-            self.assertFalse(orig.active)
-            self.assertTrue(replaced.active)
-
-    def test_expression_replacement_equality(self):
-        model = make_indexed_model()
-        sens = SensitivityInterface(model, clone_model=False)
-        sens._add_data_block()
-        instance = sens.model_instance
-        block = sens.block
-        instance.x.fix()
-        param_list = [instance.eta[1], instance.eta[2]]
-        sens._add_sensitivity_data(param_list)
-
-        orig_components = list(
-            instance.component_data_objects(Constraint, active=True)
-        ) + list(instance.component_data_objects(Objective, active=True))
-        orig_expr = [con.expr for con in orig_components]
-
-        # These will be modified to account for expected replacements
-        expected_variables = ComponentMap(
-            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
-        )
-        expected_parameters = ComponentMap(
-            (con, ComponentSet(identify_mutable_parameters(con.expr)))
-            for con in orig_components
-        )
-
-        # As constructed by the `setup_sensitivity` method:
-        variable_sub_map = dict(
-            (id(param), var)
-            for var, param, list_idx, _ in block._sens_data_list
-            if param_list[list_idx].ctype is Param
-        )
-        # Sanity check
-        self.assertEqual(len(variable_sub_map), 2)
-
-        # Map each param to the var that should replace it
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in block._sens_data_list
-        )
-
-        # Remove parameters we expect to replace and add vars
-        # we expect to replace with.
-        for con in orig_components:
-            for param in param_var_map:
-                if param in expected_parameters[con]:
-                    expected_variables[con].add(param_var_map[param])
-                    expected_parameters[con].remove(param)
-
-        # We check that the new components (Constraints and Objectives) contain
-        # the expected parameters and variables.
-        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
-        self.assertEqual(len(block.constList), 2)
-        for con in block.constList.values():
-            self.assertTrue(con.active)
-            param_set = ComponentSet(identify_mutable_parameters(con.expr))
-            var_set = ComponentSet(identify_variables(con.expr))
-            orig_con = replaced[con]
-            self.assertIsNot(orig_con, con)
-            self.assertEqual(param_set, expected_parameters[orig_con])
-            self.assertEqual(var_set, expected_variables[orig_con])
-
-        self.assertIs(block.cost.ctype, Objective)
-        obj = block.cost
-        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
-        var_set = ComponentSet(identify_variables(obj.expr))
-        orig_obj = replaced[obj]
-        self.assertIsNot(orig_obj, obj)
-        self.assertEqual(param_set, expected_parameters[orig_obj])
-        self.assertEqual(var_set, expected_variables[orig_obj])
-
-        # Original components were deactivated but otherwise not altered
-        for con, expr in zip(orig_components, orig_expr):
-            self.assertFalse(con.active)
-            # self.assertIs(con.expr, expr)
-            # ^Why does this fail?
-            self.assertEqual(con.expr.to_string(), expr.to_string())
-
-    def test_expression_replacement_inequality(self):
-        model = make_model_with_inequalities()
-        sens = SensitivityInterface(model, clone_model=False)
-        sens._add_data_block()
-        instance = sens.model_instance
-        block = sens.block
-        instance.x.fix()
-        param_list = [instance.eta[1], instance.eta[2]]
-        sens._add_sensitivity_data(param_list)
-
-        orig_components = list(
-            instance.component_data_objects(Constraint, active=True)
-        ) + list(instance.component_data_objects(Objective, active=True))
-        orig_expr = [con.expr for con in orig_components]
-
-        # These will be modified to account for expected replacements
-        expected_variables = ComponentMap(
-            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
-        )
-        expected_parameters = ComponentMap(
-            (con, ComponentSet(identify_mutable_parameters(con.expr)))
-            for con in orig_components
-        )
-
-        # As constructed by the `setup_sensitivity` method:
-        variable_sub_map = dict(
-            (id(param), var)
-            for var, param, list_idx, _ in block._sens_data_list
-            if param_list[list_idx].ctype is Param
-        )
-        # Sanity check
-        self.assertEqual(len(variable_sub_map), 2)
-
-        # Map each param to the var that should replace it
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in block._sens_data_list
-        )
-
-        # Remove parameters we expect to replace and add vars
-        # we expect to replace with.
-        for con in orig_components:
-            for param in param_var_map:
-                if param in expected_parameters[con]:
-                    expected_variables[con].add(param_var_map[param])
-                    expected_parameters[con].remove(param)
-
-        # We check that the new components (Constraints and Objectives) contain
-        # the expected parameters and variables.
-        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
-        self.assertEqual(len(block.constList), 2)
-        for con in block.constList.values():
-            self.assertTrue(con.active)
-            param_set = ComponentSet(identify_mutable_parameters(con.expr))
-            var_set = ComponentSet(identify_variables(con.expr))
-            orig_con = replaced[con]
-            self.assertIsNot(orig_con, con)
-            self.assertEqual(param_set, expected_parameters[orig_con])
-            self.assertEqual(var_set, expected_variables[orig_con])
-
-        self.assertIs(block.cost.ctype, Objective)
-        obj = block.cost
-        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
-        var_set = ComponentSet(identify_variables(obj.expr))
-        orig_obj = replaced[obj]
-        self.assertIsNot(orig_obj, obj)
-        self.assertEqual(param_set, expected_parameters[orig_obj])
-        self.assertEqual(var_set, expected_variables[orig_obj])
-
-        # Original components were deactivated but otherwise not altered
-        for con, expr in zip(orig_components, orig_expr):
-            self.assertFalse(con.active)
-            # self.assertIs(con.expr, expr)
-            # ^Why does this fail?
-            self.assertEqual(con.expr.to_string(), expr.to_string())
-
-    def test_expression_replacement_ranged_inequality(self):
-        model = make_model_with_ranged_inequalities()
-        sens = SensitivityInterface(model, clone_model=False)
-        sens._add_data_block()
-        instance = sens.model_instance
-        block = sens.block
-        instance.x.fix()
-        param_list = [instance.eta[1], instance.eta[2]]
-        sens._add_sensitivity_data(param_list)
-
-        orig_components = list(
-            instance.component_data_objects(Constraint, active=True)
-        ) + list(instance.component_data_objects(Objective, active=True))
-        orig_expr = [con.expr for con in orig_components]
-
-        # These will be modified to account for expected replacements
-        expected_variables = ComponentMap(
-            (con, ComponentSet(identify_variables(con.expr))) for con in orig_components
-        )
-        expected_parameters = ComponentMap(
-            (con, ComponentSet(identify_mutable_parameters(con.expr)))
-            for con in orig_components
-        )
-
-        # As constructed by the `setup_sensitivity` method:
-        variable_sub_map = dict(
-            (id(param), var)
-            for var, param, list_idx, _ in block._sens_data_list
-            if param_list[list_idx].ctype is Param
-        )
-        # Sanity check
-        self.assertEqual(len(variable_sub_map), 2)
-
-        # Map each param to the var that should replace it
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in block._sens_data_list
-        )
-
-        # Remove parameters we expect to replace and add vars
-        # we expect to replace with.
-        for con in orig_components:
-            for param in param_var_map:
-                if param in expected_parameters[con]:
-                    expected_variables[con].add(param_var_map[param])
-                    expected_parameters[con].remove(param)
-
-        # We check that the new components (Constraints and Objectives) contain
-        # the expected parameters and variables.
-        replaced = sens._replace_parameters_in_constraints(variable_sub_map)
-        # With ranged inequalities, we end up with more constraints than we
-        # started with:
-        self.assertEqual(len(block.constList), 3)
-
-        for con in block.constList.values():
-            self.assertTrue(con.active)
-            param_set = ComponentSet(identify_mutable_parameters(con.expr))
-            var_set = ComponentSet(identify_variables(con.expr))
-            orig_con = replaced[con]
-            self.assertIsNot(orig_con, con)
-            # Note that for ranged inequalities, it is not valid to check
-            # that the two sets are equal as a mutable parameter could be
-            # contained in only one "sub-inequality"
-            self.assertIsSubset(param_set, expected_parameters[orig_con])
-            self.assertEqual(var_set, expected_variables[orig_con])
-
-        self.assertIs(block.cost.ctype, Objective)
-        obj = block.cost
-        param_set = ComponentSet(identify_mutable_parameters(obj.expr))
-        var_set = ComponentSet(identify_variables(obj.expr))
-        orig_obj = replaced[obj]
-        self.assertIsNot(orig_obj, obj)
-        self.assertEqual(param_set, expected_parameters[orig_obj])
-        self.assertEqual(var_set, expected_variables[orig_obj])
-
-        # Original components were deactivated but otherwise not altered
-        for con, expr in zip(orig_components, orig_expr):
-            self.assertFalse(con.active)
-            # self.assertIs(con.expr, expr)
-            # ^Why does this fail?
-            self.assertEqual(con.expr.to_string(), expr.to_string())
-
-    def test_param_const(self):
-        model = make_indexed_model()
-        param_list = [model.eta[1], model.eta[2]]
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-
-        block = sens.block
-        param_const = block.paramConst
-        self.assertEqual(len(param_list), len(block.paramConst))
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in block._sens_data_list
-        )
-        var_list = [param_var_map[param] for param in param_list]
-
-        # Here we rely on the order of paramConst
-        for param, var, con in zip(param_list, var_list, param_const.values()):
-            self.assertEqual(con.body.to_string(), (var - param).to_string())
-
-    def test_param_const_indexed(self):
-        model = make_indexed_model()
-        param_list = [model.eta]
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-
-        block = sens.block
-        param_const = block.paramConst
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in block._sens_data_list
-        )
-
-        for con in param_const.values():
-            var_list = list(identify_variables(con.expr))
-            mut_param_list = list(identify_mutable_parameters(con.expr))
-            self.assertEqual(len(var_list), 1)
-            self.assertEqual(len(mut_param_list), 1)
-            self.assertIs(var_list[0], param_var_map[mut_param_list[0]])
-            self.assertEqual(
-                con.body.to_string(), (var_list[0] - mut_param_list[0]).to_string()
-            )
-
-    def test_param_const_vars(self):
-        model = make_indexed_model()
-        model.x.fix()
-        var_list = [model.x[2], model.x[1]]
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(var_list)
-
-        block = sens.block
-        param_const = block.paramConst
-        self.assertEqual(len(var_list), len(block.paramConst))
-
-        var_param_map = ComponentMap(
-            (var, param) for var, param, _, _ in block._sens_data_list
-        )
-        param_list = [var_param_map[var] for var in var_list]
-
-        # Here we rely on the order of paramConst
-        for param, var, con in zip(param_list, var_list, param_const.values()):
-            self.assertEqual(con.body.to_string(), (var - param).to_string())
-
-    def test_suffixes_setup(self):
-        model = make_indexed_model()
-        param_list = [model.eta[2], model.eta[1]]
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-
-        for i, (var, _, _, _) in enumerate(sens.block._sens_data_list):
-            con = sens.block.paramConst[i + 1]
-            self.assertEqual(model.sens_state_0[var], i + 1)
-            self.assertEqual(model.sens_state_1[var], i + 1)
-            self.assertEqual(model.sens_init_constr[con], i + 1)
-            self.assertEqual(model.dcdp[con], i + 1)
-
-        self.assertIs(type(model.sens_sol_state_1_z_L), Suffix)
-        self.assertIs(type(model.sens_sol_state_1_z_U), Suffix)
-        self.assertIs(type(model.ipopt_zL_out), Suffix)
-        self.assertIs(type(model.ipopt_zU_out), Suffix)
-        self.assertIs(type(model.ipopt_zL_in), Suffix)
-        self.assertIs(type(model.ipopt_zU_in), Suffix)
-        self.assertIs(type(model.dual), Suffix)
-        self.assertIs(type(model.DeltaP), Suffix)
-
-    def test_perturb_parameters_unindexed(self):
-        delta = 1.0
-        model = make_indexed_model()
-        param_list = [model.eta[1], model.eta[2]]
-        model.perturbed_eta = Param(
-            [1, 2],
-            mutable=True,
-            initialize={i: p.value + delta for i, p in model.eta.items()},
-        )
-        ptb_list = [model.perturbed_eta[1], model.perturbed_eta[2]]
-
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-        sens.perturb_parameters(ptb_list)
-        instance = sens.model_instance
-        block = sens.block
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in sens.block._sens_data_list
-        )
-        param_con_map = ComponentMap(
-            (param, block.paramConst[i + 1])
-            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
-        )
-        for param, ptb in zip(param_list, ptb_list):
-            var = param_var_map[param]
-            con = param_con_map[param]
-            self.assertEqual(instance.sens_state_value_1[var], ptb.value)
-            self.assertEqual(instance.DeltaP[con], -delta)
-
-    def test_perturb_parameters_scalar(self):
-        delta = 1.0
-        model = make_indexed_model()
-        param_list = [model.eta[1], model.eta[2]]
-        model.perturbed_eta = Param(
-            [1, 2],
-            mutable=True,
-            initialize={i: p.value + delta for i, p in model.eta.items()},
-        )
-        ptb_list = [model.perturbed_eta[1].value, model.perturbed_eta[2].value]
-
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-        sens.perturb_parameters(ptb_list)
-        instance = sens.model_instance
-        block = sens.block
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in sens.block._sens_data_list
-        )
-        param_con_map = ComponentMap(
-            (param, block.paramConst[i + 1])
-            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
-        )
-        for param, ptb in zip(param_list, ptb_list):
-            var = param_var_map[param]
-            con = param_con_map[param]
-            self.assertEqual(instance.sens_state_value_1[var], ptb)
-            self.assertEqual(instance.DeltaP[con], -delta)
-
-    def test_perturb_parameters_indexed(self):
-        delta = 1.0
-        model = make_indexed_model()
-        param_list = [model.eta]
-        model.perturbed_eta = Param(
-            [1, 2],
-            mutable=True,
-            initialize={i: p.value + delta for i, p in model.eta.items()},
-        )
-        ptb_list = [model.perturbed_eta]
-
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-        sens.perturb_parameters(ptb_list)
-        instance = sens.model_instance
-        block = sens.block
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in sens.block._sens_data_list
-        )
-        param_con_map = ComponentMap(
-            (param, block.paramConst[i + 1])
-            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
-        )
-        for param, ptb in zip(param_list, ptb_list):
-            for idx in param:
-                obj = param[idx]
-                ptb_data = ptb[idx]
-                var = param_var_map[obj]
-                con = param_con_map[obj]
-                self.assertEqual(instance.sens_state_value_1[var], ptb_data.value)
-                self.assertEqual(instance.DeltaP[con], -delta)
-
-    def test_perturb_indexed_parameters_with_scalar(self):
-        model = make_indexed_model()
-        param_list = [model.eta]
-        ptb_list = [10.0]
-
-        sens = SensitivityInterface(model, clone_model=False)
-        sens.setup_sensitivity(param_list)
-        sens.perturb_parameters(ptb_list)
-        instance = sens.model_instance
-        block = sens.block
-
-        param_var_map = ComponentMap(
-            (param, var) for var, param, _, _ in sens.block._sens_data_list
-        )
-        param_con_map = ComponentMap(
-            (param, block.paramConst[i + 1])
-            for i, (_, param, _, _) in enumerate(sens.block._sens_data_list)
-        )
-        for param, ptb in zip(param_list, ptb_list):
-            for idx in param:
-                obj = param[idx]
-                var = param_var_map[obj]
-                con = param_con_map[obj]
-                self.assertEqual(instance.sens_state_value_1[var], ptb)
-                self.assertEqual(instance.DeltaP[con], obj.value - ptb)
-
-    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
-    @unittest.skipIf(not opt_ipopt.available(False), "ipopt is not available")
-    @unittest.skipIf(not scipy_available, "scipy is not available")
-    def test_get_dsdp1(self):
-        '''
-        It tests the function get_dsdp with a simple nonlinear programming example.
-
-        min f: p1*x1+ p2*(x2^2) + p1*p2
-         s.t c1: x1 = p1
-             c2: x2 = p2
-             c3: 10 <= p1 <= 10
-             c4: 5 <= p2 <= 5
-        '''
-        variable_name = ['p1', 'p2']
+                return i
 
+        model.E = Expression(model.Index, rule=_some_rule)
+        self.assertEqual(model.E.extract_values(), {2: 2, 3: 3})
+        self.assertEqual(len(model.E), 2)
+
+    def test_implicit_definition(self):
+        model = ConcreteModel()
+        model.idx = Set(initialize=[1, 2, 3])
+        model.E = Expression(model.idx)
+        self.assertEqual(len(model.E), 3)
+        expr = model.E[1]
+        self.assertIs(type(expr), ExpressionData)
+        model.E[1] = None
+        self.assertIs(expr, model.E[1])
+        self.assertIs(type(expr), ExpressionData)
+        self.assertIs(expr.expr, None)
+        model.E[1] = 5
+        self.assertIs(expr, model.E[1])
+        self.assertEqual(model.E.extract_values(), {1: 5, 2: None, 3: None})
+        model.E[2] = 6
+        self.assertIsNot(expr, model.E[2])
+        self.assertEqual(model.E.extract_values(), {1: 5, 2: 6, 3: None})
+
+    def test_explicit_skip_definition(self):
+        model = ConcreteModel()
+        model.idx = Set(initialize=[1, 2, 3])
+        model.E = Expression(model.idx, rule=lambda m, i: Expression.Skip)
+        self.assertEqual(len(model.E), 0)
+        with self.assertRaises(KeyError):
+            expr = model.E[1]
+
+        model.E[1] = None
+        expr = model.E[1]
+        self.assertIs(type(expr), ExpressionData)
+        self.assertIs(expr.expr, None)
+        model.E[1] = 5
+        self.assertIs(expr, model.E[1])
+        self.assertEqual(model.E.extract_values(), {1: 5})
+        model.E[2] = 6
+        self.assertIsNot(expr, model.E[2])
+        self.assertEqual(model.E.extract_values(), {1: 5, 2: 6})
+
+    def test_indexed_construct_expr(self):
+        model = ConcreteModel()
+        model.Index = Set(initialize=[1, 2, 3])
+        model.E = Expression(model.Index, expr=Expression.Skip)
+        self.assertEqual(len(model.E), 0)
+        model.E = Expression(model.Index)
+        self.assertEqual(model.E.extract_values(), {1: None, 2: None, 3: None})
+        model.del_component(model.E)
+        model.E = Expression(model.Index, expr=1.0)
+        self.assertEqual(model.E.extract_values(), {1: 1.0, 2: 1.0, 3: 1.0})
+        model.del_component(model.E)
+        model.E = Expression(
+            model.Index, expr={1: Expression.Skip, 2: Expression.Skip, 3: 1.0}
+        )
+        self.assertEqual(model.E.extract_values(), {3: 1.0})
+
+    def test_bad_init_too_many_keywords(self):
+        model = ConcreteModel()
+
+        def _some_rule(model):
+            return 1.0
+
+        with self.assertRaises(ValueError):
+            model.e = Expression(expr=1.0, rule=_some_rule)
+        del _some_rule
+
+        def _some_indexed_rule(model, i):
+            return 1.0
+
+        with self.assertRaises(ValueError):
+            model.e = Expression([1], expr=1.0, rule=_some_indexed_rule)
+        del _some_indexed_rule
+
+    def test_init_concrete_indexed(self):
+        model = ConcreteModel()
+        model.y = Var(initialize=0.0)
+        model.x = Var([1, 2, 3], initialize=1.0)
+
+        model.ec = Expression([1, 2, 3], initialize=1.0)
+        model.obj = Objective(expr=1.0 + sum_product(model.ec, index=[1, 2, 3]))
+        self.assertEqual(model.obj.expr(), 4.0)
+        model.ec[1].set_value(2.0)
+        self.assertEqual(model.obj.expr(), 5.0)
+
+    def test_init_concrete_nonindexed(self):
+        model = ConcreteModel()
+        model.y = Var(initialize=0.0)
+        model.x = Var(initialize=1.0)
+
+        model.ec = Expression(initialize=0)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=model.y)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.y.set_value(-1)
+        model.ec = Expression(initialize=model.y + 1.0)
+        model.obj = Objective(expr=1.0 + model.ec)
+        self.assertEqual(model.obj.expr(), 1.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e = 1.0
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 2.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        model.ec.set_value(e)
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        e += model.x
+        self.assertEqual(model.obj.expr(), 3.0)
+        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+
+    def test_init_abstract_indexed(self):
+        model = AbstractModel()
+        model.ec = Expression([1, 2, 3], initialize=1.0)
+        model.obj = Objective(rule=lambda m: 1.0 + sum_product(m.ec, index=[1, 2, 3]))
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 4.0)
+        inst.ec[1].set_value(2.0)
+        self.assertEqual(inst.obj.expr(), 5.0)
+
+    def test_init_abstract_nonindexed(self):
+        model = AbstractModel()
+        model.y = Var(initialize=0.0)
+        model.x = Var(initialize=1.0)
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+        model.del_component('obj')
+        model.del_component('ec')
+        model.ec = Expression(initialize=0.0)
+
+        def obj_rule(model):
+            return 1.0 + model.ec
+
+        model.obj = Objective(rule=obj_rule)
+        inst = model.create_instance()
+        self.assertEqual(inst.obj.expr(), 1.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e = 1.0
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 2.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        inst.ec.set_value(e)
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+        e += inst.x
+        self.assertEqual(inst.obj.expr(), 3.0)
+        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
+
+    def test_pprint_oldStyle(self):
+        expr_common.TO_STRING_VERBOSE = True
+
+        model = ConcreteModel()
+        model.x = Var()
+        model.e = Expression(initialize=model.x + 2)
+        model.E = Expression([1, 2], initialize=model.x**2 + 1)
+        expr = model.e * model.x**2 + model.E[1]
+
+        output = """\
+sum(prod(e{sum(x, 2)}, pow(x, 2)), E[1]{sum(pow(x, 2), 1)})
+e : Size=1, Index=None
+    Key  : Expression
+    None : sum(x, 2)
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : sum(pow(x, 2), 1)
+      2 : sum(pow(x, 2), 1)
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+        model.e.set_value(1.0)
+        model.E[1].set_value(2.0)
+        output = """\
+sum(prod(e{1.0}, pow(x, 2)), E[1]{2.0})
+e : Size=1, Index=None
+    Key  : Expression
+    None :        1.0
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : 2.0
+      2 : sum(pow(x, 2), 1)
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+        model.e.set_value(None)
+        model.E[1].set_value(None)
+        output = """\
+sum(prod(e{Undefined}, pow(x, 2)), E[1]{Undefined})
+e : Size=1, Index=None
+    Key  : Expression
+    None :  Undefined
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : Undefined
+      2 : sum(pow(x, 2), 1)
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+    def test_pprint_newStyle(self):
+        expr_common.TO_STRING_VERBOSE = False
+
+        model = ConcreteModel()
+        model.x = Var()
+        model.e = Expression(initialize=model.x + 2)
+        model.E = Expression([1, 2], initialize=model.x**2 + 1)
+        expr = model.e * model.x**2 + model.E[1]
+
+        output = """\
+(x + 2)*x**2 + (x**2 + 1)
+e : Size=1, Index=None
+    Key  : Expression
+    None : x + 2
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : x**2 + 1
+      2 : x**2 + 1
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+        model.e.set_value(1.0)
+        model.E[1].set_value(2.0)
+        #
+        # WEH - the 1.0 seems unnecessary here, but it results from
+        # a fixed variable in a sub-expression.  I can't decide if this
+        # is the expected behavior or not.
+        #
+        output = """\
+x**2 + 2.0
+e : Size=1, Index=None
+    Key  : Expression
+    None :        1.0
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : 2.0
+      2 : x**2 + 1
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+        model.e.set_value(None)
+        model.E[1].set_value(None)
+        output = """\
+e{None}*x**2 + E[1]{None}
+e : Size=1, Index=None
+    Key  : Expression
+    None :  Undefined
+E : Size=2, Index={1, 2}
+    Key : Expression
+      1 : Undefined
+      2 : x**2 + 1
+"""
+        out = StringIO()
+        out.write(str(expr) + "\n")
+        model.e.pprint(ostream=out)
+        # model.E[1].pprint(ostream=out)
+        model.E.pprint(ostream=out)
+        self.assertEqual(output, out.getvalue())
+
+    def test_len(self):
+        model = AbstractModel()
+        model.e = Expression()
+
+        self.assertEqual(len(model.e), 0)
+        inst = model.create_instance()
+        self.assertEqual(len(inst.e), 1)
+
+    def test_None_key(self):
+        model = AbstractModel()
+        model.e = Expression()
+        inst = model.create_instance()
+        self.assertEqual(id(inst.e), id(inst.e[None]))
+
+    def test_singleton_get_set(self):
+        model = ConcreteModel()
+        model.e = Expression()
+        self.assertEqual(len(model.e), 1)
+        self.assertEqual(model.e.expr, None)
+        model.e.expr = 1
+        self.assertEqual(model.e.expr, 1)
+        model.e.expr += 2
+        self.assertEqual(model.e.expr, 3)
+
+    def test_singleton_get_set_value(self):
+        model = ConcreteModel()
+        model.e = Expression()
+        self.assertEqual(len(model.e), 1)
+        self.assertEqual(model.e.expr, None)
+        model.e.expr = 1
+        self.assertEqual(model.e.expr, 1)
+        model.e.expr += 2
+        self.assertEqual(model.e.expr, 3)
+
+    def test_abstract_index(self):
+        model = AbstractModel()
+        model.A = Set()
+        model.B = Set()
+        model.C = model.A | model.B
+        model.x = Expression(model.C)
+
+    def test_iadd(self):
+        # make sure simple for loops that look like they
+        # create a new expression do not modify the named
+        # expression
         m = ConcreteModel()
-        m.x1 = Var(initialize=0)
-        m.x2 = Var(initialize=0)
-        m.p1 = Var(initialize=0)
-        m.p2 = Var(initialize=0)
-        m.obj = Objective(
-            expr=m.x1 * m.p1 + m.x2 * m.x2 * m.p2 + m.p1 * m.p2, sense=minimize
-        )
-        m.c1 = Constraint(expr=m.x1 == m.p1)
-        m.c2 = Constraint(expr=m.x2 == m.p2)
-        theta = {'p1': 10.0, 'p2': 5.0}
-        for v in variable_name:
-            getattr(m, v).setlb(theta[v])
-            getattr(m, v).setub(theta[v])
-        dsdp, col = get_dsdp(m, variable_name, theta)
-        ref = {'x1': [1.0, 0.0], 'x2': [0.0, 1.0], 'p1': [1.0, 0.0], 'p2': [0.0, 1.0]}
-        np.testing.assert_almost_equal(
-            dsdp.toarray(), np.vstack([ref[c] for c in col]).transpose()
-        )
-
-    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
-    @unittest.skipIf(not opt_ipopt.available(False), "ipopt is not available")
-    @unittest.skipIf(not scipy_available, "scipy is not available")
-    def test_get_dsdp2(self):
-        '''
-        It tests the function get_dsdp with rooney & biegler's model.
-        '''
-        variable_name = ['asymptote', 'rate_constant']
-
-        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
-        cov = np.array([[6.30579403, -0.4395341], [-0.4395341, 0.04193591]])
-        model_uncertain = ConcreteModel()
-        model_uncertain.asymptote = Var(initialize=15)
-        model_uncertain.rate_constant = Var(initialize=0.5)
-        model_uncertain.obj = Objective(
-            expr=model_uncertain.asymptote
-            * (1 - exp(-model_uncertain.rate_constant * 10)),
-            sense=minimize,
-        )
-        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
-        for v in variable_name:
-            getattr(model_uncertain, v).setlb(theta[v])
-            getattr(model_uncertain, v).setub(theta[v])
-        dsdp, col = get_dsdp(model_uncertain, variable_name, theta, {})
-        np.testing.assert_almost_equal(dsdp.toarray(), [[1.0, 0.0], [0.0, 1.0]])
-        assert col == ['asymptote', 'rate_constant']
-
-    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
-    @unittest.skipIf(not opt_dotsens.available(False), "dot_sens is not available")
-    @unittest.skipIf(not scipy_available, "scipy is not available")
-    def test_get_dfds_dcds(self):
-        '''
-        It tests the function get_sensitivity with a simple nonlinear programming example.
-
-        min f: p1*x1+ p2*(x2^2) + p1*p2
-         s.t c1: x1 = p1
-             c2: x2 = p2
-             c3: 10 <= p1 <= 10
-             c4: 5 <= p2 <= 5
-        '''
-        variable_name = ['p1', 'p2']
-
+        e = m.e = Expression(expr=1.0)
+        expr = 0.0
+        for v in [1.0, e]:
+            expr += v
+        self.assertEqual(e.expr, 1)
+        self.assertEqual(expr(), 2)
+        expr = 0.0
+        for v in [e, 1.0]:
+            expr += v
+        self.assertEqual(e.expr, 1)
+        self.assertEqual(expr, 2)
+        # Make sure that using in-place operators on named expressions
+        # do not create loops inthe expression tree (test #1890)
+        m.x = Var()
+        m.y = Var()
+        m.e.expr = m.x
+        m.e += m.y
+        assertExpressionsEqual(self, m.e.expr, m.x + m.y)
+
+    def test_isub(self):
+        # make sure simple for loops that look like they
+        # create a new expression do not modify the named
+        # expression
         m = ConcreteModel()
-        m.x1 = Var(initialize=0)
-        m.x2 = Var(initialize=0)
-        m.p1 = Var(initialize=0)
-        m.p2 = Var(initialize=0)
-        m.obj = Objective(
-            expr=m.x1 * m.p1 + m.x2 * m.x2 * m.p2 + m.p1 * m.p2, sense=minimize
-        )
-        m.c1 = Constraint(expr=m.x1 == m.p1)
-        m.c2 = Constraint(expr=m.x2 == m.p2)
-        theta = {'p1': 10.0, 'p2': 5.0}
-        for v in variable_name:
-            getattr(m, v).setlb(theta[v])
-            getattr(m, v).setub(theta[v])
-        gradient_f, gradient_c, col, row, line_dic = get_dfds_dcds(m, variable_name)
-
-        ref_f = {'x1': [10.0], 'x2': [50.0], 'p1': [15.0], 'p2': [35.0]}
-        ref_c = {
-            'x1': [1.0, 0.0],
-            'x2': [0.0, 1.0],
-            'p1': [-1.0, 0.0],
-            'p2': [0.0, -1.0],
-        }
-        np.testing.assert_almost_equal(gradient_f, np.hstack([ref_f[v] for v in col]))
-        np.testing.assert_almost_equal(
-            gradient_c.toarray(), np.vstack([ref_c[v] for v in col]).transpose()
-        )
-
-    @unittest.skipIf(not opt_kaug.available(False), "k_aug is not available")
-    @unittest.skipIf(not opt_dotsens.available(False), "dot_sens is not available")
-    @unittest.skipIf(not scipy_available, "scipy is not available")
-    def test_get_dfds_dcds2(self):
-        '''
-        It tests the function get_sensitivity with rooney & biegler's model.
-        '''
-        variable_name = ['asymptote', 'rate_constant']
-        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
-        cov = np.array([[6.30579403, -0.4395341], [-0.4395341, 0.04193591]])
-        model_uncertain = ConcreteModel()
-        model_uncertain.asymptote = Var(initialize=15)
-        model_uncertain.rate_constant = Var(initialize=0.5)
-        model_uncertain.obj = Objective(
-            expr=model_uncertain.asymptote
-            * (1 - exp(-model_uncertain.rate_constant * 10)),
-            sense=minimize,
-        )
-        theta = {'asymptote': 19.142575284617866, 'rate_constant': 0.53109137696521}
-        for v in variable_name:
-            getattr(model_uncertain, v).setlb(theta[v])
-            getattr(model_uncertain, v).setub(theta[v])
-        gradient_f, gradient_c, col, row, line_dic = get_dfds_dcds(
-            model_uncertain, variable_name
-        )
-        np.testing.assert_almost_equal(gradient_f, [0.99506259, 0.945148])
-        np.testing.assert_almost_equal(gradient_c, np.array([]))
-        assert col == ['asymptote', 'rate_constant']
-        assert row == ['obj']
-
-    def test_line_num1(self):
-        '''
-        It tests the function line_num
-        '''
-        import os
-
-        file_name = "test_col.col"
-        with open(file_name, "w") as file:
-            file.write("var1\n")
-            file.write("var3\n")
-        i = line_num(file_name, 'var1')
-        j = line_num(file_name, 'var3')
-        self.assertEqual(i, 1)
-        self.assertEqual(j, 2)
-
-    def test_line_num2(self):
-        '''
-        It tests an exception error when file does not include target
-        '''
-        import os
-
-        file_name = "test_col.col"
-        with open(file_name, "w") as file:
-            file.write("var1\n")
-            file.write("var3\n")
-        with self.assertRaises(Exception) as context:
-            i = line_num(file_name, 'var2')
-        self.assertTrue('test_col.col does not include var2' in str(context.exception))
+        e = m.e = Expression(expr=1.0)
+        expr = 0.0
+        for v in [1.0, e]:
+            expr -= v
+        self.assertEqual(e.expr, 1)
+        self.assertEqual(expr(), -2)
+        expr = 0.0
+        for v in [e, 1.0]:
+            expr -= v
+        self.assertEqual(e.expr, 1)
+        self.assertEqual(expr(), -2)
+        # Make sure that using in-place operators on named expressions
+        # do not create loops inthe expression tree (test #1890)
+        m.x = Var()
+        m.y = Var()
+        m.e.expr = m.x
+        m.e -= m.y
+        assertExpressionsEqual(
+            self,
+            m.e.expr,
+            EXPR.LinearExpression([m.x, EXPR.MonomialTermExpression((-1, m.y))]),
+        )
+        self.assertTrue(compare_expressions(m.e.expr, m.x - m.y))
+
+    def test_imul(self):
+        # make sure simple for loops that look like they
+        # create a new expression do not modify the named
+        # expression
+        m = ConcreteModel()
+        e = m.e = Expression(expr=3.0)
+        expr = 1.0
+        for v in [2.0, e]:
+            expr *= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr(), 6)
+        expr = 1.0
+        for v in [e, 2.0]:
+            expr *= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 6)
+        # Make sure that using in-place operators on named expressions
+        # do not create loops inthe expression tree (test #1890)
+        m.x = Var()
+        m.y = Var()
+        m.e.expr = m.x
+        m.e *= m.y
+        self.assertTrue(compare_expressions(m.e.expr, m.x * m.y))
+
+    def test_idiv(self):
+        # make sure simple for loops that look like they
+        # create a new expression do not modify the named
+        # expression
+        # floating point division
+        m = ConcreteModel()
+        e = m.e = Expression(expr=3.0)
+        expr = e
+        for v in [2.0, 1.0]:
+            expr /= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 1.5)
+        expr = e
+        for v in [1.0, 2.0]:
+            expr /= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 1.5)
+        # note that integer division does not occur within
+        # Pyomo expressions
+        m = ConcreteModel()
+        e = m.e = Expression(expr=3.0)
+        expr = e
+        for v in [2, 1]:
+            expr /= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 1.5)
+        expr = e
+        for v in [1, 2]:
+            expr /= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 1.5)
+        # Make sure that using in-place operators on named expressions
+        # do not create loops inthe expression tree (test #1890)
+        m.x = Var()
+        m.y = Var()
+        m.e.expr = m.x
+        m.e /= m.y
+        self.assertTrue(compare_expressions(m.e.expr, m.x / m.y))
+
+    def test_ipow(self):
+        # make sure simple for loops that look like they
+        # create a new expression do not modify the named
+        # expression
+        m = ConcreteModel()
+        e = m.e = Expression(expr=3.0)
+        expr = e
+        for v in [2.0, 1.0]:
+            expr **= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 9)
+        expr = e
+        for v in [1.0, 2.0]:
+            expr **= v
+        self.assertEqual(e.expr, 3)
+        self.assertEqual(expr, 9)
+        # Make sure that using in-place operators on named expressions
+        # do not create loops inthe expression tree (test #1890)
+        m.x = Var()
+        m.y = Var()
+        m.e.expr = m.x
+        m.e **= m.y
+        self.assertTrue(compare_expressions(m.e.expr, m.x**m.y))
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/simplemodel/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/simplemodel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/solver/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/base.py` & `Pyomo-6.7.2/pyomo/contrib/solver/base.py`

 * *Files 18% similar despite different names*

```diff
@@ -10,22 +10,23 @@
 #  ___________________________________________________________________________
 
 import abc
 import enum
 from typing import Sequence, Dict, Optional, Mapping, NoReturn, List, Tuple
 import os
 
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.block import _BlockData
-from pyomo.core.base.objective import _GeneralObjectiveData
-from pyomo.common.config import document_kwargs_from_configdict
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.block import BlockData
+from pyomo.core.base.objective import Objective, ObjectiveData
+from pyomo.common.config import document_kwargs_from_configdict, ConfigValue
 from pyomo.common.errors import ApplicationError
 from pyomo.common.deprecation import deprecation_warning
+from pyomo.common.modeling import NOTSET
 from pyomo.opt.results.results_ import SolverResults as LegacySolverResults
 from pyomo.opt.results.solution import Solution as LegacySolution
 from pyomo.core.kernel.objective import minimize
 from pyomo.core.base import SymbolMap
 from pyomo.core.base.label import NumericLabeler
 from pyomo.core.staleflag import StaleFlagManager
 from pyomo.contrib.solver.config import SolverConfig, PersistentSolverConfig
@@ -37,15 +38,16 @@
     legacy_solution_status_map,
 )
 
 
 class SolverBase(abc.ABC):
     """
     This base class defines the methods required for all solvers:
-        - available: Determines whether the solver is able to be run, combining both whether it can be found on the system and if the license is valid.
+        - available: Determines whether the solver is able to be run,
+                     combining both whether it can be found on the system and if the license is valid.
         - solve: The main method of every solver
         - version: The version of the solver
         - is_persistent: Set to false for all non-persistent solvers.
 
     Additionally, solvers should have a :attr:`config<SolverBase.config>` attribute that
     inherits from one of :class:`SolverConfig<pyomo.contrib.solver.config.SolverConfig>`,
     :class:`BranchAndBoundConfig<pyomo.contrib.solver.config.BranchAndBoundConfig>`,
@@ -53,19 +55,21 @@
     :class:`PersistentBranchAndBoundConfig<pyomo.contrib.solver.config.PersistentBranchAndBoundConfig>`.
     """
 
     CONFIG = SolverConfig()
 
     def __init__(self, **kwds) -> None:
         # We allow the user and/or developer to name the solver something else,
-        # if they really desire. Otherwise it defaults to the class name (all lowercase)
+        # if they really desire.
+        # Otherwise it defaults to the name defined when the solver was registered
+        # in the SolverFactory or the class name (all lowercase), whichever is
+        # applicable
         if "name" in kwds:
-            self.name = kwds["name"]
-            kwds.pop('name')
-        else:
+            self.name = kwds.pop('name')
+        elif not hasattr(self, 'name'):
             self.name = type(self).__name__.lower()
         self.config = self.CONFIG(value=kwds)
 
     #
     # Support "with" statements. Forgetting to call deactivate
     # on Plugins is a common source of memory leaks
     #
@@ -102,21 +106,21 @@
             # "mixin" type for standard enums overrides the behavior
             # specified in __format__.  We will override str() here to
             # preserve the previous behavior
             return self.name
 
     @document_kwargs_from_configdict(CONFIG)
     @abc.abstractmethod
-    def solve(self, model: _BlockData, **kwargs) -> Results:
+    def solve(self, model: BlockData, **kwargs) -> Results:
         """
         Solve a Pyomo model.
 
         Parameters
         ----------
-        model: _BlockData
+        model: BlockData
             The Pyomo model to be solved
         **kwargs
             Additional keyword arguments (including solver_options - passthrough
             options; delivered directly to the solver (with no validation))
 
         Returns
         -------
@@ -176,29 +180,27 @@
     for persistent solvers.
 
     Example usage can be seen in the Gurobi interface.
     """
 
     @document_kwargs_from_configdict(PersistentSolverConfig())
     @abc.abstractmethod
-    def solve(self, model: _BlockData, **kwargs) -> Results:
+    def solve(self, model: BlockData, **kwargs) -> Results:
         super().solve(model, kwargs)
 
     def is_persistent(self):
         """
         Returns
         -------
         is_persistent: bool
             True if the solver is a persistent solver.
         """
         return True
 
-    def _load_vars(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> NoReturn:
+    def _load_vars(self, vars_to_load: Optional[Sequence[VarData]] = None) -> NoReturn:
         """
         Load the solution of the primal variables into the value attribute of the variables.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose solution should be loaded. If vars_to_load is None, then the solution
@@ -206,36 +208,36 @@
         """
         for v, val in self._get_primals(vars_to_load=vars_to_load).items():
             v.set_value(val, skip_validation=True)
         StaleFlagManager.mark_all_as_stale(delayed=True)
 
     @abc.abstractmethod
     def _get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Get mapping of variables to primals.
 
         Parameters
         ----------
-        vars_to_load : Optional[Sequence[_GeneralVarData]], optional
+        vars_to_load : Optional[Sequence[VarData]], optional
             Which vars to be populated into the map. The default is None.
 
         Returns
         -------
-        Mapping[_GeneralVarData, float]
+        Mapping[VarData, float]
             A map of variables to primals.
         """
         raise NotImplementedError(
             f'{type(self)} does not support the get_primals method'
         )
 
     def _get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Declare sign convention in docstring here.
 
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose duals should be loaded. If cons_to_load is None, then the duals for all
@@ -245,16 +247,16 @@
         -------
         duals: dict
             Maps constraints to dual values
         """
         raise NotImplementedError(f'{type(self)} does not support the get_duals method')
 
     def _get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose reduced cost should be loaded. If vars_to_load is None, then all reduced costs
             will be loaded.
 
@@ -270,69 +272,69 @@
     @abc.abstractmethod
     def set_instance(self, model):
         """
         Set an instance of the model
         """
 
     @abc.abstractmethod
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         """
         Set current objective for the model
         """
 
     @abc.abstractmethod
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         """
         Add variables to the model
         """
 
     @abc.abstractmethod
-    def add_parameters(self, params: List[_ParamData]):
+    def add_parameters(self, params: List[ParamData]):
         """
         Add parameters to the model
         """
 
     @abc.abstractmethod
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         """
         Add constraints to the model
         """
 
     @abc.abstractmethod
-    def add_block(self, block: _BlockData):
+    def add_block(self, block: BlockData):
         """
         Add a block to the model
         """
 
     @abc.abstractmethod
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         """
         Remove variables from the model
         """
 
     @abc.abstractmethod
-    def remove_parameters(self, params: List[_ParamData]):
+    def remove_parameters(self, params: List[ParamData]):
         """
         Remove parameters from the model
         """
 
     @abc.abstractmethod
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         """
         Remove constraints from the model
         """
 
     @abc.abstractmethod
-    def remove_block(self, block: _BlockData):
+    def remove_block(self, block: BlockData):
         """
         Remove a block from the model
         """
 
     @abc.abstractmethod
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         """
         Update variables on the model
         """
 
     @abc.abstractmethod
     def update_parameters(self):
         """
@@ -342,70 +344,115 @@
 
 class LegacySolverWrapper:
     """
     Class to map the new solver interface features into the legacy solver
     interface. Necessary for backwards compatibility.
     """
 
+    def __init__(self, **kwargs):
+        if 'solver_io' in kwargs:
+            raise NotImplementedError('Still working on this')
+        # There is no reason for a user to be trying to mix both old
+        # and new options. That is silly. So we will yell at them.
+        self.options = kwargs.pop('options', None)
+        if 'solver_options' in kwargs:
+            if self.options is not None:
+                raise ValueError(
+                    "Both 'options' and 'solver_options' were requested. "
+                    "Please use one or the other, not both."
+                )
+            self.options = kwargs.pop('solver_options')
+        super().__init__(**kwargs)
+
     #
     # Support "with" statements
     #
     def __enter__(self):
         return self
 
     def __exit__(self, t, v, traceback):
         """Exit statement - enables `with` statements."""
 
     def _map_config(
         self,
-        tee,
-        load_solutions,
-        symbolic_solver_labels,
-        timelimit,
-        # Report timing is no longer a valid option. We now always return a
-        # timer object that can be inspected.
-        report_timing,
-        raise_exception_on_nonoptimal_result,
-        solver_io,
-        suffixes,
-        logfile,
-        keepfiles,
-        solnfile,
-        options,
+        tee=NOTSET,
+        load_solutions=NOTSET,
+        symbolic_solver_labels=NOTSET,
+        timelimit=NOTSET,
+        report_timing=NOTSET,
+        raise_exception_on_nonoptimal_result=NOTSET,
+        solver_io=NOTSET,
+        suffixes=NOTSET,
+        logfile=NOTSET,
+        keepfiles=NOTSET,
+        solnfile=NOTSET,
+        options=NOTSET,
+        solver_options=NOTSET,
+        writer_config=NOTSET,
     ):
         """Map between legacy and new interface configuration options"""
         self.config = self.config()
-        self.config.tee = tee
-        self.config.load_solutions = load_solutions
-        self.config.symbolic_solver_labels = symbolic_solver_labels
-        self.config.time_limit = timelimit
-        self.config.solver_options.set_value(options)
+        if 'report_timing' not in self.config:
+            self.config.declare(
+                'report_timing', ConfigValue(domain=bool, default=False)
+            )
+        if tee is not NOTSET:
+            self.config.tee = tee
+        if load_solutions is not NOTSET:
+            self.config.load_solutions = load_solutions
+        if symbolic_solver_labels is not NOTSET:
+            self.config.symbolic_solver_labels = symbolic_solver_labels
+        if timelimit is not NOTSET:
+            self.config.time_limit = timelimit
+        if report_timing is not NOTSET:
+            self.config.report_timing = report_timing
+        if self.options is not None:
+            self.config.solver_options.set_value(self.options)
+        if (options is not NOTSET) and (solver_options is not NOTSET):
+            # There is no reason for a user to be trying to mix both old
+            # and new options. That is silly. So we will yell at them.
+            # Example that would raise an error:
+            # solver.solve(model, options={'foo' : 'bar'}, solver_options={'foo' : 'not_bar'})
+            raise ValueError(
+                "Both 'options' and 'solver_options' were requested. "
+                "Please use one or the other, not both."
+            )
+        elif options is not NOTSET:
+            # This block is trying to mimic the existing logic in the legacy
+            # interface that allows users to pass initialized options to
+            # the solver object and override them in the solve call.
+            self.config.solver_options.set_value(options)
+        elif solver_options is not NOTSET:
+            self.config.solver_options.set_value(solver_options)
+        if writer_config is not NOTSET:
+            self.config.writer_config.set_value(writer_config)
         # This is a new flag in the interface. To preserve backwards compatibility,
         # its default is set to "False"
-        self.config.raise_exception_on_nonoptimal_result = (
-            raise_exception_on_nonoptimal_result
-        )
-        if solver_io is not None:
+        if raise_exception_on_nonoptimal_result is not NOTSET:
+            self.config.raise_exception_on_nonoptimal_result = (
+                raise_exception_on_nonoptimal_result
+            )
+        if solver_io is not NOTSET and solver_io is not None:
             raise NotImplementedError('Still working on this')
-        if suffixes is not None:
+        if suffixes is not NOTSET and suffixes is not None:
             raise NotImplementedError('Still working on this')
-        if logfile is not None:
+        if logfile is not NOTSET and logfile is not None:
             raise NotImplementedError('Still working on this')
         if keepfiles or 'keepfiles' in self.config:
             cwd = os.getcwd()
             deprecation_warning(
                 "`keepfiles` has been deprecated in the new solver interface. "
-                "Use `working_dir` instead to designate a directory in which "
-                f"files should be generated and saved. Setting `working_dir` to `{cwd}`.",
+                "Use `working_dir` instead to designate a directory in which files "
+                f"should be generated and saved. Setting `working_dir` to `{cwd}`.",
                 version='6.7.1',
             )
             self.config.working_dir = cwd
         # I believe this currently does nothing; however, it is unclear what
         # our desired behavior is for this.
-        if solnfile is not None:
+        if solnfile is not NOTSET:
             if 'filename' in self.config:
                 filename = os.path.splitext(solnfile)[0]
                 self.config.filename = filename
 
     def _map_results(self, model, results):
         """Map between legacy and new Results objects"""
         legacy_results = LegacySolverResults()
@@ -414,16 +461,25 @@
             results.termination_condition
         ]
         legacy_results.solver.termination_condition = legacy_termination_condition_map[
             results.termination_condition
         ]
         legacy_soln.status = legacy_solution_status_map[results.solution_status]
         legacy_results.solver.termination_message = str(results.termination_condition)
-        obj = get_objective(model)
-        if len(list(obj)) > 0:
+        legacy_results.problem.number_of_constraints = float('nan')
+        legacy_results.problem.number_of_variables = float('nan')
+        number_of_objectives = sum(
+            1
+            for _ in model.component_data_objects(
+                Objective, active=True, descend_into=True
+            )
+        )
+        legacy_results.problem.number_of_objectives = number_of_objectives
+        if number_of_objectives == 1:
+            obj = get_objective(model)
             legacy_results.problem.sense = obj.sense
 
             if obj.sense == minimize:
                 legacy_results.problem.lower_bound = results.objective_bound
                 legacy_results.problem.upper_bound = results.incumbent_objective
             else:
                 legacy_results.problem.upper_bound = results.objective_bound
@@ -439,14 +495,20 @@
 
     def _solution_handler(
         self, load_solutions, model, results, legacy_results, legacy_soln
     ):
         """Method to handle the preferred action for the solution"""
         symbol_map = SymbolMap()
         symbol_map.default_labeler = NumericLabeler('x')
+        if not hasattr(model, 'solutions'):
+            # This logic gets around Issue #2130 in which
+            # solutions is not an attribute on Blocks
+            from pyomo.core.base.PyomoModel import ModelSolutions
+
+            setattr(model, 'solutions', ModelSolutions(model))
         model.solutions.add_symbol_map(symbol_map)
         legacy_results._smap_id = id(symbol_map)
         delete_legacy_soln = True
         if load_solutions:
             if hasattr(model, 'dual') and model.dual.import_enabled():
                 for c, val in results.solution_loader.get_duals().items():
                     model.dual[c] = val
@@ -471,72 +533,86 @@
         legacy_results.timing_info = results.timing_info
         if delete_legacy_soln:
             legacy_results.solution.delete(0)
         return legacy_results
 
     def solve(
         self,
-        model: _BlockData,
+        model: BlockData,
         tee: bool = False,
         load_solutions: bool = True,
         logfile: Optional[str] = None,
         solnfile: Optional[str] = None,
         timelimit: Optional[float] = None,
         report_timing: bool = False,
         solver_io: Optional[str] = None,
         suffixes: Optional[Sequence] = None,
         options: Optional[Dict] = None,
         keepfiles: bool = False,
         symbolic_solver_labels: bool = False,
+        # These are for forward-compatibility
         raise_exception_on_nonoptimal_result: bool = False,
+        solver_options: Optional[Dict] = None,
+        writer_config: Optional[Dict] = None,
     ):
         """
         Solve method: maps new solve method style to backwards compatible version.
 
         Returns
         -------
         legacy_results
             Legacy results object
 
         """
         original_config = self.config
-        self._map_config(
-            tee,
-            load_solutions,
-            symbolic_solver_labels,
-            timelimit,
-            report_timing,
-            raise_exception_on_nonoptimal_result,
-            solver_io,
-            suffixes,
-            logfile,
-            keepfiles,
-            solnfile,
-            options,
+
+        map_args = (
+            'tee',
+            'load_solutions',
+            'symbolic_solver_labels',
+            'timelimit',
+            'report_timing',
+            'raise_exception_on_nonoptimal_result',
+            'solver_io',
+            'suffixes',
+            'logfile',
+            'keepfiles',
+            'solnfile',
+            'options',
+            'solver_options',
+            'writer_config',
         )
+        loc = locals()
+        filtered_args = {k: loc[k] for k in map_args if loc.get(k, None) is not None}
+        self._map_config(**filtered_args)
 
         results: Results = super().solve(model)
         legacy_results, legacy_soln = self._map_results(model, results)
-
         legacy_results = self._solution_handler(
             load_solutions, model, results, legacy_results, legacy_soln
         )
 
+        if self.config.report_timing:
+            print(results.timing_info.timer)
+
         self.config = original_config
 
         return legacy_results
 
     def available(self, exception_flag=True):
         """
         Returns a bool determining whether the requested solver is available
         on the system.
         """
         ans = super().available()
         if exception_flag and not ans:
-            raise ApplicationError(f'Solver {self.__class__} is not available ({ans}).')
+            raise ApplicationError(
+                f'Solver "{self.name}" is not available. '
+                f'The returned status is: {ans}.'
+            )
         return bool(ans)
 
     def license_is_valid(self) -> bool:
         """Test if the solver license is valid on this system.
 
         Note that this method is included for compatibility with the
         legacy SolverFactory interface.  Unlicensed or open source
@@ -546,7 +622,17 @@
         Returns
         -------
         available: bool
             True if the solver license is valid. Otherwise, False.
 
         """
         return bool(self.available())
+
+    def config_block(self, init=False):
+        from pyomo.scripting.solve_config import default_config_block
+
+        return default_config_block(self, init)[0]
+
+    def set_options(self, options):
+        opts = {k: v for k, v in options.value().items() if v is not None}
+        if opts:
+            self._map_config(**opts)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/config.py` & `Pyomo-6.7.2/pyomo/contrib/solver/config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/factory.py` & `Pyomo-6.7.2/pyomo/contrib/solver/factory.py`

 * *Files 7% similar despite different names*

```diff
@@ -23,15 +23,19 @@
         def decorator(cls):
             self._cls[name] = cls
             self._doc[name] = doc
 
             class LegacySolver(LegacySolverWrapper, cls):
                 pass
 
-            LegacySolverFactory.register(legacy_name, doc)(LegacySolver)
+            LegacySolverFactory.register(legacy_name, doc + " (new interface)")(
+                LegacySolver
+            )
 
+            # Preserve the preferred name, as registered in the Factory
+            cls.name = name
             return cls
 
         return decorator
 
 
 SolverFactory = SolverFactoryClass()
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/gurobi.py` & `Pyomo-6.7.2/pyomo/contrib/solver/gurobi.py`

 * *Files 1% similar despite different names*

```diff
@@ -18,18 +18,18 @@
 from pyomo.common.errors import PyomoException
 from pyomo.common.tee import capture_output, TeeStream
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.common.shutdown import python_is_shutting_down
 from pyomo.common.config import ConfigValue
 from pyomo.core.kernel.objective import minimize, maximize
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.sos import _SOSConstraintData
-from pyomo.core.base.param import _ParamData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.sos import SOSConstraintData
+from pyomo.core.base.param import ParamData
 from pyomo.core.expr.numvalue import value, is_constant, is_fixed, native_numeric_types
 from pyomo.repn import generate_standard_repn
 from pyomo.core.expr.numeric_expr import NPV_MaxExpression, NPV_MinExpression
 from pyomo.contrib.solver.base import PersistentSolverBase
 from pyomo.contrib.solver.results import Results, TerminationCondition, SolutionStatus
 from pyomo.contrib.solver.config import PersistentBranchAndBoundConfig
 from pyomo.contrib.solver.persistent import PersistentSolverUtils
@@ -434,15 +434,15 @@
                     else:
                         mutable_bound.var = gurobipy_var
                     self._mutable_bounds[var_id, 'ub'] = (var, mutable_bound)
                 ub = min(value(_ub), ub)
 
         return lb, ub, vtype
 
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         var_names = list()
         vtypes = list()
         lbs = list()
         ubs = list()
         mutable_lbs = dict()
         mutable_ubs = dict()
         for ndx, var in enumerate(variables):
@@ -465,15 +465,15 @@
         for ndx, mutable_bound in mutable_lbs.items():
             mutable_bound.var = gurobi_vars[ndx]
         for ndx, mutable_bound in mutable_ubs.items():
             mutable_bound.var = gurobi_vars[ndx]
         self._vars_added_since_update.update(variables)
         self._needs_updated = True
 
-    def _add_parameters(self, params: List[_ParamData]):
+    def _add_parameters(self, params: List[ParamData]):
         pass
 
     def _reinit(self):
         saved_config = self.config
         saved_tmp_config = self._config
         self.__init__()
         self.config = saved_config
@@ -551,15 +551,15 @@
         return (
             new_expr,
             repn.constant,
             mutable_linear_coefficients,
             mutable_quadratic_coefficients,
         )
 
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         for con in cons:
             conname = self._symbol_map.getSymbol(con, self._labeler)
             (
                 gurobi_expr,
                 repn_constant,
                 mutable_linear_coefficients,
                 mutable_quadratic_coefficients,
@@ -681,15 +681,15 @@
                 )
 
             self._pyomo_con_to_solver_con_map[con] = gurobipy_con
             self._solver_con_to_pyomo_con_map[id(gurobipy_con)] = con
         self._constraints_added_since_update.update(cons)
         self._needs_updated = True
 
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             conname = self._symbol_map.getSymbol(con, self._labeler)
             level = con.level
             if level == 1:
                 sos_type = gurobipy.GRB.SOS_TYPE1
             elif level == 2:
                 sos_type = gurobipy.GRB.SOS_TYPE2
@@ -707,54 +707,54 @@
                 weights.append(w)
 
             gurobipy_con = self._solver_model.addSOS(sos_type, gurobi_vars, weights)
             self._pyomo_sos_to_solver_sos_map[con] = gurobipy_con
         self._constraints_added_since_update.update(cons)
         self._needs_updated = True
 
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         for con in cons:
             if con in self._constraints_added_since_update:
                 self._update_gurobi_model()
             solver_con = self._pyomo_con_to_solver_con_map[con]
             self._solver_model.remove(solver_con)
             self._symbol_map.removeSymbol(con)
             del self._pyomo_con_to_solver_con_map[con]
             del self._solver_con_to_pyomo_con_map[id(solver_con)]
             self._range_constraints.discard(con)
             self._mutable_helpers.pop(con, None)
             self._mutable_quadratic_helpers.pop(con, None)
         self._needs_updated = True
 
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             if con in self._constraints_added_since_update:
                 self._update_gurobi_model()
             solver_sos_con = self._pyomo_sos_to_solver_sos_map[con]
             self._solver_model.remove(solver_sos_con)
             self._symbol_map.removeSymbol(con)
             del self._pyomo_sos_to_solver_sos_map[con]
         self._needs_updated = True
 
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         for var in variables:
             v_id = id(var)
             if var in self._vars_added_since_update:
                 self._update_gurobi_model()
             solver_var = self._pyomo_var_to_solver_var_map[v_id]
             self._solver_model.remove(solver_var)
             self._symbol_map.removeSymbol(var)
             del self._pyomo_var_to_solver_var_map[v_id]
             self._mutable_bounds.pop(v_id, None)
         self._needs_updated = True
 
-    def _remove_parameters(self, params: List[_ParamData]):
+    def _remove_parameters(self, params: List[ParamData]):
         pass
 
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         for var in variables:
             var_id = id(var)
             if var_id not in self._pyomo_var_to_solver_var_map:
                 raise ValueError(
                     'The Var provided to update_var needs to be added first: {0}'.format(
                         var
                     )
@@ -1121,15 +1121,15 @@
 
     def set_linear_constraint_attr(self, con, attr, val):
         """
         Set the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
                 CBasis
                 DStart
                 Lazy
@@ -1147,15 +1147,15 @@
 
     def set_var_attr(self, var, attr, val):
         """
         Set the value of an attribute on a gurobi variable.
 
         Parameters
         ----------
-        var: pyomo.core.base.var._GeneralVarData
+        var: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
                 Start
                 VarHintVal
                 VarHintPri
@@ -1182,15 +1182,15 @@
 
     def get_var_attr(self, var, attr):
         """
         Get the value of an attribute on a gurobi var.
 
         Parameters
         ----------
-        var: pyomo.core.base.var._GeneralVarData
+        var: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be retrieved.
         attr: str
             The attribute to get. See gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1198,15 +1198,15 @@
 
     def get_linear_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1214,15 +1214,15 @@
 
     def get_sos_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi sos constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.sos._SOSConstraintData
+        con: pyomo.core.base.sos.SOSConstraintData
             The pyomo SOS constraint for which the corresponding gurobi SOS constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1230,15 +1230,15 @@
 
     def get_quadratic_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi quadratic constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. See the Gurobi documentation
         """
         if self._needs_updated:
             self._update_gurobi_model()
@@ -1351,15 +1351,15 @@
 
     def cbCut(self, con):
         """
         Add a cut within a callback.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The cut to add
         """
         if not con.active:
             raise ValueError('cbCut expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbCut expected a non-trivial constraint')
@@ -1436,15 +1436,15 @@
         for i, v in enumerate(vars):
             v.set_value(var_values[i], skip_validation=True)
 
     def cbLazy(self, con):
         """
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The lazy constraint to add
         """
         if not con.active:
             raise ValueError('cbLazy expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbLazy expected a non-trivial constraint')
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/ipopt.py` & `Pyomo-6.7.2/pyomo/contrib/solver/ipopt.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,42 +5,44 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+import logging
 import os
 import subprocess
 import datetime
 import io
 from typing import Mapping, Optional, Sequence
 
 from pyomo.common import Executable
 from pyomo.common.config import ConfigValue, document_kwargs_from_configdict, ConfigDict
-from pyomo.common.errors import PyomoException, DeveloperError
+from pyomo.common.errors import (
+    PyomoException,
+    DeveloperError,
+    InfeasibleConstraintException,
+)
 from pyomo.common.tempfiles import TempfileManager
 from pyomo.common.timing import HierarchicalTimer
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.var import VarData
 from pyomo.core.staleflag import StaleFlagManager
 from pyomo.repn.plugins.nl_writer import NLWriter, NLWriterInfo
 from pyomo.contrib.solver.base import SolverBase
 from pyomo.contrib.solver.config import SolverConfig
-from pyomo.contrib.solver.factory import SolverFactory
 from pyomo.contrib.solver.results import Results, TerminationCondition, SolutionStatus
 from pyomo.contrib.solver.sol_reader import parse_sol_file
 from pyomo.contrib.solver.solution import SolSolutionLoader
 from pyomo.common.tee import TeeStream
 from pyomo.core.expr.visitor import replace_expressions
 from pyomo.core.expr.numvalue import value
 from pyomo.core.base.suffix import Suffix
 from pyomo.common.collections import ComponentMap
 
-import logging
-
 logger = logging.getLogger(__name__)
 
 
 class IpoptSolverError(PyomoException):
     """
     General exception to catch solver system errors
     """
@@ -68,26 +70,22 @@
             ConfigValue(
                 default=Executable('ipopt'),
                 description="Preferred executable for ipopt. Defaults to searching the "
                 "``PATH`` for the first available ``ipopt``.",
             ),
         )
         self.writer_config: ConfigDict = self.declare(
-            'writer_config',
-            ConfigValue(
-                default=NLWriter.CONFIG(),
-                description="Configuration that controls options in the NL writer.",
-            ),
+            'writer_config', NLWriter.CONFIG()
         )
 
 
 class IpoptSolutionLoader(SolSolutionLoader):
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._nl_info is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check results.TerminationCondition and/or results.SolutionStatus.'
             )
         if len(self._nl_info.eliminated_vars) > 0:
             raise NotImplementedError(
@@ -194,23 +192,23 @@
     'warm_start_bound_push',
     'warm_start_init_point',
     'warm_start_mult_bound_push',
     'watchdog_shortened_iter_trigger',
 }
 
 
-@SolverFactory.register('ipopt_v2', doc='The ipopt NLP solver (new interface)')
 class Ipopt(SolverBase):
     CONFIG = IpoptConfig()
 
     def __init__(self, **kwds):
         super().__init__(**kwds)
         self._writer = NLWriter()
         self._available_cache = None
         self._version_cache = None
+        self._version_timeout = 2
 
     def available(self, config=None):
         if config is None:
             config = self.config
         pth = config.executable.path()
         if self._available_cache is None or self._available_cache[0] != pth:
             if pth is None:
@@ -225,15 +223,15 @@
         pth = config.executable.path()
         if self._version_cache is None or self._version_cache[0] != pth:
             if pth is None:
                 self._version_cache = (None, None)
             else:
                 results = subprocess.run(
                     [str(pth), '--version'],
-                    timeout=1,
+                    timeout=self._version_timeout,
                     stdout=subprocess.PIPE,
                     stderr=subprocess.STDOUT,
                     universal_newlines=True,
                 )
                 version = results.stdout.splitlines()[0]
                 version = version.split(' ')[1].strip()
                 version = tuple(int(i) for i in version.split('.'))
@@ -305,28 +303,37 @@
             if not os.path.exists(dname):
                 os.mkdir(dname)
             basename = os.path.join(dname, model.name)
             if os.path.exists(basename + '.nl'):
                 raise RuntimeError(
                     f"NL file with the same name {basename + '.nl'} already exists!"
                 )
-            with open(basename + '.nl', 'w') as nl_file, open(
+            # Note: the ASL has an issue where string constants written
+            # to the NL file (e.g. arguments in external functions) MUST
+            # be terminated with '\n' regardless of platform.  We will
+            # disable universal newlines in the NL file to prevent
+            # Python from mapping those '\n' to '\r\n' on Windows.
+            with open(basename + '.nl', 'w', newline='\n') as nl_file, open(
                 basename + '.row', 'w'
             ) as row_file, open(basename + '.col', 'w') as col_file:
                 timer.start('write_nl_file')
                 self._writer.config.set_value(config.writer_config)
-                nl_info = self._writer.write(
-                    model,
-                    nl_file,
-                    row_file,
-                    col_file,
-                    symbolic_solver_labels=config.symbolic_solver_labels,
-                )
+                try:
+                    nl_info = self._writer.write(
+                        model,
+                        nl_file,
+                        row_file,
+                        col_file,
+                        symbolic_solver_labels=config.symbolic_solver_labels,
+                    )
+                    proven_infeasible = False
+                except InfeasibleConstraintException:
+                    proven_infeasible = True
                 timer.stop('write_nl_file')
-            if len(nl_info.variables) > 0:
+            if not proven_infeasible and len(nl_info.variables) > 0:
                 # Get a copy of the environment to pass to the subprocess
                 env = os.environ.copy()
                 if nl_info.external_function_libraries:
                     if env.get('AMPLFUNC'):
                         nl_info.external_function_libraries.append(env.get('AMPLFUNC'))
                     env['AMPLFUNC'] = "\n".join(nl_info.external_function_libraries)
                 # Write the opt_file, if there should be one; return a bool to say
@@ -357,19 +364,25 @@
                         universal_newlines=True,
                         stdout=t.STDOUT,
                         stderr=t.STDERR,
                     )
                     timer.stop('subprocess')
                     # This is the stuff we need to parse to get the iterations
                     # and time
-                    iters, ipopt_time_nofunc, ipopt_time_func, ipopt_total_time = (
+                    (iters, ipopt_time_nofunc, ipopt_time_func, ipopt_total_time) = (
                         self._parse_ipopt_output(ostreams[0])
                     )
 
-            if len(nl_info.variables) == 0:
+            if proven_infeasible:
+                results = Results()
+                results.termination_condition = TerminationCondition.provenInfeasible
+                results.solution_loader = SolSolutionLoader(None, None)
+                results.iteration_count = 0
+                results.timing_info.total_seconds = 0
+            elif len(nl_info.variables) == 0:
                 if len(nl_info.eliminated_vars) == 0:
                     results = Results()
                     results.termination_condition = TerminationCondition.emptyModel
                     results.solution_loader = SolSolutionLoader(None, None)
                 else:
                     results = Results()
                     results.termination_condition = (
@@ -453,15 +466,15 @@
                         },
                         descend_into_named_expressions=True,
                         remove_named_expressions=True,
                     )
                 )
 
         results.solver_configuration = config
-        if len(nl_info.variables) > 0:
+        if not proven_infeasible and len(nl_info.variables) > 0:
             results.solver_log = ostreams[0].getvalue()
 
         # Capture/record end-time / wall-time
         end_timestamp = datetime.datetime.now(datetime.timezone.utc)
         results.timing_info.start_timestamp = start_timestamp
         results.timing_info.wall_time = (
             end_timestamp - start_timestamp
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/persistent.py` & `Pyomo-6.7.2/pyomo/contrib/solver/persistent.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,19 +8,19 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  __________________________________________________________________________
 
 import abc
 from typing import List
 
-from pyomo.core.base.constraint import _GeneralConstraintData, Constraint
-from pyomo.core.base.sos import _SOSConstraintData, SOSConstraint
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.param import _ParamData, Param
-from pyomo.core.base.objective import _GeneralObjectiveData
+from pyomo.core.base.constraint import ConstraintData, Constraint
+from pyomo.core.base.sos import SOSConstraintData, SOSConstraint
+from pyomo.core.base.var import VarData
+from pyomo.core.base.param import ParamData, Param
+from pyomo.core.base.objective import ObjectiveData
 from pyomo.common.collections import ComponentMap
 from pyomo.common.timing import HierarchicalTimer
 from pyomo.core.expr.numvalue import NumericConstant
 from pyomo.contrib.solver.util import collect_vars_and_named_exprs, get_objective
 
 
 class PersistentSolverUtils(abc.ABC):
@@ -50,18 +50,18 @@
         self.config = saved_config
         self._model = model
         self.add_block(model)
         if self._objective is None:
             self.set_objective(None)
 
     @abc.abstractmethod
-    def _add_variables(self, variables: List[_GeneralVarData]):
+    def _add_variables(self, variables: List[VarData]):
         pass
 
-    def add_variables(self, variables: List[_GeneralVarData]):
+    def add_variables(self, variables: List[VarData]):
         for v in variables:
             if id(v) in self._referenced_variables:
                 raise ValueError(
                     'variable {name} has already been added'.format(name=v.name)
                 )
             self._referenced_variables[id(v)] = [{}, {}, None]
             self._vars[id(v)] = (
@@ -71,44 +71,44 @@
                 v.fixed,
                 v.domain.get_interval(),
                 v.value,
             )
         self._add_variables(variables)
 
     @abc.abstractmethod
-    def _add_parameters(self, params: List[_ParamData]):
+    def _add_parameters(self, params: List[ParamData]):
         pass
 
-    def add_parameters(self, params: List[_ParamData]):
+    def add_parameters(self, params: List[ParamData]):
         for p in params:
             self._params[id(p)] = p
         self._add_parameters(params)
 
     @abc.abstractmethod
-    def _add_constraints(self, cons: List[_GeneralConstraintData]):
+    def _add_constraints(self, cons: List[ConstraintData]):
         pass
 
-    def _check_for_new_vars(self, variables: List[_GeneralVarData]):
+    def _check_for_new_vars(self, variables: List[VarData]):
         new_vars = {}
         for v in variables:
             v_id = id(v)
             if v_id not in self._referenced_variables:
                 new_vars[v_id] = v
         self.add_variables(list(new_vars.values()))
 
-    def _check_to_remove_vars(self, variables: List[_GeneralVarData]):
+    def _check_to_remove_vars(self, variables: List[VarData]):
         vars_to_remove = {}
         for v in variables:
             v_id = id(v)
             ref_cons, ref_sos, ref_obj = self._referenced_variables[v_id]
             if len(ref_cons) == 0 and len(ref_sos) == 0 and ref_obj is None:
                 vars_to_remove[v_id] = v
         self.remove_variables(list(vars_to_remove.values()))
 
-    def add_constraints(self, cons: List[_GeneralConstraintData]):
+    def add_constraints(self, cons: List[ConstraintData]):
         all_fixed_vars = {}
         for con in cons:
             if con in self._named_expressions:
                 raise ValueError(
                     'constraint {name} has already been added'.format(name=con.name)
                 )
             self._active_constraints[con] = (con.lower, con.body, con.upper)
@@ -126,18 +126,18 @@
                     v.unfix()
                     all_fixed_vars[id(v)] = v
         self._add_constraints(cons)
         for v in all_fixed_vars.values():
             v.fix()
 
     @abc.abstractmethod
-    def _add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _add_sos_constraints(self, cons: List[SOSConstraintData]):
         pass
 
-    def add_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def add_sos_constraints(self, cons: List[SOSConstraintData]):
         for con in cons:
             if con in self._vars_referenced_by_con:
                 raise ValueError(
                     'constraint {name} has already been added'.format(name=con.name)
                 )
             self._active_constraints[con] = tuple()
             variables = con.get_variables()
@@ -145,18 +145,18 @@
             self._named_expressions[con] = []
             self._vars_referenced_by_con[con] = variables
             for v in variables:
                 self._referenced_variables[id(v)][1][con] = None
         self._add_sos_constraints(cons)
 
     @abc.abstractmethod
-    def _set_objective(self, obj: _GeneralObjectiveData):
+    def _set_objective(self, obj: ObjectiveData):
         pass
 
-    def set_objective(self, obj: _GeneralObjectiveData):
+    def set_objective(self, obj: ObjectiveData):
         if self._objective is not None:
             for v in self._vars_referenced_by_obj:
                 self._referenced_variables[id(v)][2] = None
             self._check_to_remove_vars(self._vars_referenced_by_obj)
             self._external_functions.pop(self._objective, None)
         if obj is not None:
             self._objective = obj
@@ -205,18 +205,18 @@
             )
         )
         obj = get_objective(block)
         if obj is not None:
             self.set_objective(obj)
 
     @abc.abstractmethod
-    def _remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def _remove_constraints(self, cons: List[ConstraintData]):
         pass
 
-    def remove_constraints(self, cons: List[_GeneralConstraintData]):
+    def remove_constraints(self, cons: List[ConstraintData]):
         self._remove_constraints(cons)
         for con in cons:
             if con not in self._named_expressions:
                 raise ValueError(
                     'cannot remove constraint {name} - it was not added'.format(
                         name=con.name
                     )
@@ -226,18 +226,18 @@
             self._check_to_remove_vars(self._vars_referenced_by_con[con])
             del self._active_constraints[con]
             del self._named_expressions[con]
             self._external_functions.pop(con, None)
             del self._vars_referenced_by_con[con]
 
     @abc.abstractmethod
-    def _remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def _remove_sos_constraints(self, cons: List[SOSConstraintData]):
         pass
 
-    def remove_sos_constraints(self, cons: List[_SOSConstraintData]):
+    def remove_sos_constraints(self, cons: List[SOSConstraintData]):
         self._remove_sos_constraints(cons)
         for con in cons:
             if con not in self._vars_referenced_by_con:
                 raise ValueError(
                     'cannot remove constraint {name} - it was not added'.format(
                         name=con.name
                     )
@@ -246,18 +246,18 @@
                 self._referenced_variables[id(v)][1].pop(con)
             self._check_to_remove_vars(self._vars_referenced_by_con[con])
             del self._active_constraints[con]
             del self._named_expressions[con]
             del self._vars_referenced_by_con[con]
 
     @abc.abstractmethod
-    def _remove_variables(self, variables: List[_GeneralVarData]):
+    def _remove_variables(self, variables: List[VarData]):
         pass
 
-    def remove_variables(self, variables: List[_GeneralVarData]):
+    def remove_variables(self, variables: List[VarData]):
         self._remove_variables(variables)
         for v in variables:
             v_id = id(v)
             if v_id not in self._referenced_variables:
                 raise ValueError(
                     'cannot remove variable {name} - it has not been added'.format(
                         name=v.name
@@ -270,18 +270,18 @@
                         name=v.name
                     )
                 )
             del self._referenced_variables[v_id]
             del self._vars[v_id]
 
     @abc.abstractmethod
-    def _remove_parameters(self, params: List[_ParamData]):
+    def _remove_parameters(self, params: List[ParamData]):
         pass
 
-    def remove_parameters(self, params: List[_ParamData]):
+    def remove_parameters(self, params: List[ParamData]):
         self._remove_parameters(params)
         for p in params:
             del self._params[id(p)]
 
     def remove_block(self, block):
         self.remove_constraints(
             list(
@@ -305,18 +305,18 @@
                         ctype=Param, descend_into=True
                     )
                 ).values()
             )
         )
 
     @abc.abstractmethod
-    def _update_variables(self, variables: List[_GeneralVarData]):
+    def _update_variables(self, variables: List[VarData]):
         pass
 
-    def update_variables(self, variables: List[_GeneralVarData]):
+    def update_variables(self, variables: List[VarData]):
         for v in variables:
             self._vars[id(v)] = (
                 v,
                 v._lb,
                 v._ub,
                 v.fixed,
                 v.domain.get_interval(),
@@ -380,20 +380,20 @@
                     new_cons.append(c)
             for c in current_sos_dict.keys():
                 if c not in self._vars_referenced_by_con:
                     new_sos.append(c)
             for c in self._vars_referenced_by_con.keys():
                 if c not in current_cons_dict and c not in current_sos_dict:
                     if (c.ctype is Constraint) or (
-                        c.ctype is None and isinstance(c, _GeneralConstraintData)
+                        c.ctype is None and isinstance(c, ConstraintData)
                     ):
                         old_cons.append(c)
                     else:
                         assert (c.ctype is SOSConstraint) or (
-                            c.ctype is None and isinstance(c, _SOSConstraintData)
+                            c.ctype is None and isinstance(c, SOSConstraintData)
                         )
                         old_sos.append(c)
         self.remove_constraints(old_cons)
         self.remove_sos_constraints(old_sos)
         timer.stop('cons')
         timer.start('params')
         self.remove_parameters(old_params)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/latex_printer/__init__.py`

 * *Files 25% similar despite different names*

```diff
@@ -5,20 +5,18 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+# Recommended just to build all of the appropriate things
+import pyomo.environ
 
-from .factory import SolverFactory
-from .ipopt import Ipopt
-from .gurobi import Gurobi
-
-
-def load():
-    SolverFactory.register(
-        name='ipopt', legacy_name='ipopt_v2', doc='The IPOPT NLP solver (new interface)'
-    )(Ipopt)
-    SolverFactory.register(
-        name='gurobi', legacy_name='gurobi_v2', doc='New interface to Gurobi'
-    )(Gurobi)
+# Remove one layer of .latex_printer
+# import statement is now:
+#   from pyomo.contrib.latex_printer import latex_printer
+try:
+    from pyomo.contrib.latex_printer.latex_printer import latex_printer
+except:
+    pass
+    # in this case, the dependencies are not installed, nothing will work
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/results.py` & `Pyomo-6.7.2/pyomo/contrib/solver/results.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/sol_reader.py` & `Pyomo-6.7.2/pyomo/contrib/solver/sol_reader.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/solution.py` & `Pyomo-6.7.2/pyomo/contrib/solver/solution.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import abc
 from typing import Sequence, Dict, Optional, Mapping, NoReturn
 
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.var import VarData
 from pyomo.core.expr import value
 from pyomo.common.collections import ComponentMap
 from pyomo.common.errors import DeveloperError
 from pyomo.core.staleflag import StaleFlagManager
 from pyomo.contrib.solver.sol_reader import SolFileData
 from pyomo.repn.plugins.nl_writer import NLWriterInfo
 from pyomo.core.expr.visitor import replace_expressions
@@ -26,17 +26,15 @@
 class SolutionLoaderBase(abc.ABC):
     """
     Base class for all future SolutionLoader classes.
 
     Intent of this class and its children is to load the solution back into the model.
     """
 
-    def load_vars(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> NoReturn:
+    def load_vars(self, vars_to_load: Optional[Sequence[VarData]] = None) -> NoReturn:
         """
         Load the solution of the primal variables into the value attribute of the variables.
 
         Parameters
         ----------
         vars_to_load: list
             The minimum set of variables whose solution should be loaded. If vars_to_load is None, then the solution
@@ -45,16 +43,16 @@
         """
         for v, val in self.get_primals(vars_to_load=vars_to_load).items():
             v.set_value(val, skip_validation=True)
         StaleFlagManager.mark_all_as_stale(delayed=True)
 
     @abc.abstractmethod
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Returns a ComponentMap mapping variable to var value.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose solution value should be retrieved. If vars_to_load is None,
@@ -63,16 +61,16 @@
         Returns
         -------
         primals: ComponentMap
             Maps variables to solution values
         """
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         """
         Returns a dictionary mapping constraint to dual value.
 
         Parameters
         ----------
         cons_to_load: list
             A list of the constraints whose duals should be retrieved. If cons_to_load is None, then the duals for all
@@ -82,16 +80,16 @@
         -------
         duals: dict
             Maps constraints to dual values
         """
         raise NotImplementedError(f'{type(self)} does not support the get_duals method')
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         """
         Returns a ComponentMap mapping variable to reduced cost.
 
         Parameters
         ----------
         vars_to_load: list
             A list of the variables whose reduced cost should be retrieved. If vars_to_load is None, then the
@@ -117,37 +115,35 @@
             raise RuntimeError('The results in the solver are no longer valid.')
 
     def get_primals(self, vars_to_load=None):
         self._assert_solution_still_valid()
         return self._solver._get_primals(vars_to_load=vars_to_load)
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         self._assert_solution_still_valid()
         return self._solver._get_duals(cons_to_load=cons_to_load)
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         self._assert_solution_still_valid()
         return self._solver._get_reduced_costs(vars_to_load=vars_to_load)
 
     def invalidate(self):
         self._valid = False
 
 
 class SolSolutionLoader(SolutionLoaderBase):
     def __init__(self, sol_data: SolFileData, nl_info: NLWriterInfo) -> None:
         self._sol_data = sol_data
         self._nl_info = nl_info
 
-    def load_vars(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> NoReturn:
+    def load_vars(self, vars_to_load: Optional[Sequence[VarData]] = None) -> NoReturn:
         if self._nl_info is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check results.TerminationCondition and/or results.SolutionStatus.'
             )
         if self._sol_data is None:
             assert len(self._nl_info.variables) == 0
@@ -165,16 +161,16 @@
 
         for v, v_expr in self._nl_info.eliminated_vars:
             v.value = value(v_expr)
 
         StaleFlagManager.mark_all_as_stale(delayed=True)
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._nl_info is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check results.TerminationCondition and/or results.SolutionStatus.'
             )
         val_map = dict()
         if self._sol_data is None:
@@ -201,16 +197,16 @@
             ]
         for v in vars_to_load:
             res[v] = val_map[id(v)]
 
         return res
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         if self._nl_info is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check results.TerminationCondition and/or results.SolutionStatus.'
             )
         if len(self._nl_info.eliminated_vars) > 0:
             raise NotImplementedError(
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_gurobi_persistent.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_gurobi_persistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_ipopt.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_ipopt.py`

 * *Files 0% similar despite different names*

```diff
@@ -44,14 +44,14 @@
         # Test default initialization
         config = IpoptConfig()
         self.assertTrue(config.load_solutions)
         self.assertIsInstance(config.solver_options, ConfigDict)
         self.assertIsInstance(config.executable, ExecutableData)
 
         # Test custom initialization
-        solver = SolverFactory('ipopt_v2', executable='/path/to/exe')
+        solver = SolverFactory('ipopt', executable='/path/to/exe')
         self.assertFalse(solver.config.tee)
         self.assertTrue(solver.config.executable.startswith('/path'))
 
         # Change value on a solve call
         # model = self.create_model()
         # result = solver.solve(model, tee=True)
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/solvers/test_solvers.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/solvers/test_solvers.py`

 * *Files 0% similar despite different names*

```diff
@@ -17,27 +17,28 @@
 from pyomo import gdp
 from pyomo.common.dependencies import attempt_import
 import pyomo.common.unittest as unittest
 from pyomo.contrib.solver.results import TerminationCondition, SolutionStatus, Results
 from pyomo.contrib.solver.base import SolverBase
 from pyomo.contrib.solver.ipopt import Ipopt
 from pyomo.contrib.solver.gurobi import Gurobi
+from pyomo.contrib.solver.gurobi_direct import GurobiDirect
 from pyomo.core.expr.numeric_expr import LinearExpression
 
 
 np, numpy_available = attempt_import('numpy')
 parameterized, param_available = attempt_import('parameterized')
 parameterized = parameterized.parameterized
 
 
 if not param_available:
     raise unittest.SkipTest('Parameterized is not available.')
 
-all_solvers = [('gurobi', Gurobi), ('ipopt', Ipopt)]
-mip_solvers = [('gurobi', Gurobi)]
+all_solvers = [('gurobi', Gurobi), ('gurobi_direct', GurobiDirect), ('ipopt', Ipopt)]
+mip_solvers = [('gurobi', Gurobi), ('gurobi_direct', GurobiDirect)]
 nlp_solvers = [('ipopt', Ipopt)]
 qcp_solvers = [('gurobi', Gurobi), ('ipopt', Ipopt)]
 miqcqp_solvers = [('gurobi', Gurobi)]
 nl_solvers = [('ipopt', Ipopt)]
 nl_solvers_set = {i[0] for i in nl_solvers}
 
 
@@ -1504,14 +1505,79 @@
 
             m.x.unfix()
             m.x.setlb(-9)
             m.x.setub(9)
             res = opt.solve(m)
             self.assertAlmostEqual(res.incumbent_objective, -18, 5)
 
+    @parameterized.expand(input=_load_tests(nl_solvers))
+    def test_presolve_with_zero_coef(
+        self, name: str, opt_class: Type[SolverBase], use_presolve: bool
+    ):
+        opt: SolverBase = opt_class()
+        if not opt.available():
+            raise unittest.SkipTest(f'Solver {opt.name} not available.')
+        if use_presolve:
+            opt.config.writer_config.linear_presolve = True
+        else:
+            opt.config.writer_config.linear_presolve = False
+
+        """
+        when c2 gets presolved out, c1 becomes 
+        x - y + y = 0 which becomes
+        x - 0*y == 0 which is the zero we are testing for
+        """
+        m = pe.ConcreteModel()
+        m.x = pe.Var()
+        m.y = pe.Var()
+        m.z = pe.Var()
+        m.obj = pe.Objective(expr=m.x**2 + m.y**2 + m.z**2)
+        m.c1 = pe.Constraint(expr=m.x == m.y + m.z + 1.5)
+        m.c2 = pe.Constraint(expr=m.z == -m.y)
+
+        res = opt.solve(m)
+        self.assertAlmostEqual(res.incumbent_objective, 2.25)
+        self.assertAlmostEqual(m.x.value, 1.5)
+        self.assertAlmostEqual(m.y.value, 0)
+        self.assertAlmostEqual(m.z.value, 0)
+
+        m.x.setlb(2)
+        res = opt.solve(
+            m, load_solutions=False, raise_exception_on_nonoptimal_result=False
+        )
+        if use_presolve:
+            exp = TerminationCondition.provenInfeasible
+        else:
+            exp = TerminationCondition.locallyInfeasible
+        self.assertEqual(res.termination_condition, exp)
+
+        m = pe.ConcreteModel()
+        m.w = pe.Var()
+        m.x = pe.Var()
+        m.y = pe.Var()
+        m.z = pe.Var()
+        m.obj = pe.Objective(expr=m.x**2 + m.y**2 + m.z**2 + m.w**2)
+        m.c1 = pe.Constraint(expr=m.x + m.w == m.y + m.z)
+        m.c2 = pe.Constraint(expr=m.z == -m.y)
+        m.c3 = pe.Constraint(expr=m.x == -m.w)
+
+        res = opt.solve(m)
+        self.assertAlmostEqual(res.incumbent_objective, 0)
+        self.assertAlmostEqual(m.w.value, 0)
+        self.assertAlmostEqual(m.x.value, 0)
+        self.assertAlmostEqual(m.y.value, 0)
+        self.assertAlmostEqual(m.z.value, 0)
+
+        del m.c1
+        m.c1 = pe.Constraint(expr=m.x + m.w == m.y + m.z + 1.5)
+        res = opt.solve(
+            m, load_solutions=False, raise_exception_on_nonoptimal_result=False
+        )
+        self.assertEqual(res.termination_condition, exp)
+
     @parameterized.expand(input=_load_tests(all_solvers))
     def test_scaling(self, name: str, opt_class: Type[SolverBase], use_presolve: bool):
         opt: SolverBase = opt_class()
         if not opt.available():
             raise unittest.SkipTest(f'Solver {opt.name} not available.')
         check_duals = True
         if any(name.startswith(i) for i in nl_solvers_set):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/sol_files/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/sol_files/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_base.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_base.py`

 * *Files 22% similar despite different names*

```diff
@@ -174,15 +174,21 @@
             self.assertEqual(self.instance.set_objective(None), None)
             self.assertEqual(self.instance.update_variables(None), None)
             self.assertEqual(self.instance.update_parameters(), None)
 
 
 class TestLegacySolverWrapper(unittest.TestCase):
     def test_class_method_list(self):
-        expected_list = ['available', 'license_is_valid', 'solve']
+        expected_list = [
+            'available',
+            'config_block',
+            'license_is_valid',
+            'set_options',
+            'solve',
+        ]
         method_list = [
             method
             for method in dir(base.LegacySolverWrapper)
             if method.startswith('_') is False
         ]
         self.assertEqual(sorted(expected_list), sorted(method_list))
 
@@ -203,17 +209,15 @@
         instance.config = self.config
         instance._map_config(
             True, False, False, 20, True, False, None, None, None, False, None, None
         )
         self.assertTrue(instance.config.tee)
         self.assertFalse(instance.config.load_solutions)
         self.assertEqual(instance.config.time_limit, 20)
-        # Report timing shouldn't be created because it no longer exists
-        with self.assertRaises(AttributeError):
-            print(instance.config.report_timing)
+        self.assertEqual(instance.config.report_timing, True)
         # Keepfiles should not be created because we did not declare keepfiles on
         # the original config
         with self.assertRaises(AttributeError):
             print(instance.config.keepfiles)
         # We haven't implemented solver_io, suffixes, or logfile
         with self.assertRaises(NotImplementedError):
             instance._map_config(
@@ -264,14 +268,107 @@
         instance._map_config(
             False, False, False, 20, False, False, None, None, None, True, None, None
         )
         self.assertEqual(instance.config.working_dir, os.getcwd())
         with self.assertRaises(AttributeError):
             print(instance.config.keepfiles)
 
+    def test_solver_options_behavior(self):
+        # options can work in multiple ways (set from instantiation, set
+        # after instantiation, set during solve).
+        # Test case 1: Set at instantiation
+        solver = base.LegacySolverWrapper(options={'max_iter': 6})
+        self.assertEqual(solver.options, {'max_iter': 6})
+
+        # Test case 2: Set later
+        solver = base.LegacySolverWrapper()
+        solver.options = {'max_iter': 4, 'foo': 'bar'}
+        self.assertEqual(solver.options, {'max_iter': 4, 'foo': 'bar'})
+
+        # Test case 3: pass some options to the mapping (aka, 'solve' command)
+        solver = base.LegacySolverWrapper()
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        solver._map_config(options={'max_iter': 4})
+        self.assertEqual(solver.config.solver_options, {'max_iter': 4})
+
+        # Test case 4: Set at instantiation and override during 'solve' call
+        solver = base.LegacySolverWrapper(options={'max_iter': 6})
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        solver._map_config(options={'max_iter': 4})
+        self.assertEqual(solver.config.solver_options, {'max_iter': 4})
+        self.assertEqual(solver.options, {'max_iter': 6})
+
+        # solver_options are also supported
+        # Test case 1: set at instantiation
+        solver = base.LegacySolverWrapper(solver_options={'max_iter': 6})
+        self.assertEqual(solver.options, {'max_iter': 6})
+
+        # Test case 2: pass some solver_options to the mapping (aka, 'solve' command)
+        solver = base.LegacySolverWrapper()
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        solver._map_config(solver_options={'max_iter': 4})
+        self.assertEqual(solver.config.solver_options, {'max_iter': 4})
+
+        # Test case 3: Set at instantiation and override during 'solve' call
+        solver = base.LegacySolverWrapper(solver_options={'max_iter': 6})
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        solver._map_config(solver_options={'max_iter': 4})
+        self.assertEqual(solver.config.solver_options, {'max_iter': 4})
+        self.assertEqual(solver.options, {'max_iter': 6})
+
+        # users can mix... sort of
+        # Test case 1: Initialize with options, solve with solver_options
+        solver = base.LegacySolverWrapper(options={'max_iter': 6})
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        solver._map_config(solver_options={'max_iter': 4})
+        self.assertEqual(solver.config.solver_options, {'max_iter': 4})
+
+        # users CANNOT initialize both values at the same time, because how
+        # do we know what to do with it then?
+        # Test case 1: Class instance
+        with self.assertRaises(ValueError):
+            solver = base.LegacySolverWrapper(
+                options={'max_iter': 6}, solver_options={'max_iter': 4}
+            )
+        # Test case 2: Passing to `solve`
+        solver = base.LegacySolverWrapper()
+        config = ConfigDict(implicit=True)
+        config.declare(
+            'solver_options',
+            ConfigDict(implicit=True, description="Options to pass to the solver."),
+        )
+        solver.config = config
+        with self.assertRaises(ValueError):
+            solver._map_config(solver_options={'max_iter': 4}, options={'max_iter': 6})
+
     def test_map_results(self):
         # Unclear how to test this
         pass
 
     def test_solution_handler(self):
         # Unclear how to test this
         pass
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_config.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_ipopt.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_ipopt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_results.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_results.py`

 * *Files 2% similar despite different names*

```diff
@@ -11,16 +11,16 @@
 
 from io import StringIO
 from typing import Sequence, Dict, Optional, Mapping, MutableMapping
 
 
 from pyomo.common import unittest
 from pyomo.common.config import ConfigDict
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.var import VarData
 from pyomo.common.collections import ComponentMap
 from pyomo.contrib.solver import results
 from pyomo.contrib.solver import solution
 import pyomo.environ as pyo
 from pyomo.core.base.var import Var
 
 
@@ -47,32 +47,32 @@
             maps id(Var) to (var, reduced_cost)
         """
         self._primals = primals
         self._duals = duals
         self._reduced_costs = reduced_costs
 
     def get_primals(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._primals is None:
             raise RuntimeError(
                 'Solution loader does not currently have a valid solution. Please '
                 'check the termination condition.'
             )
         if vars_to_load is None:
             return ComponentMap(self._primals.values())
         else:
             primals = ComponentMap()
             for v in vars_to_load:
                 primals[v] = self._primals[id(v)][1]
             return primals
 
     def get_duals(
-        self, cons_to_load: Optional[Sequence[_GeneralConstraintData]] = None
-    ) -> Dict[_GeneralConstraintData, float]:
+        self, cons_to_load: Optional[Sequence[ConstraintData]] = None
+    ) -> Dict[ConstraintData, float]:
         if self._duals is None:
             raise RuntimeError(
                 'Solution loader does not currently have valid duals. Please '
                 'check the termination condition and ensure the solver returns duals '
                 'for the given problem type.'
             )
         if cons_to_load is None:
@@ -80,16 +80,16 @@
         else:
             duals = {}
             for c in cons_to_load:
                 duals[c] = self._duals[c]
         return duals
 
     def get_reduced_costs(
-        self, vars_to_load: Optional[Sequence[_GeneralVarData]] = None
-    ) -> Mapping[_GeneralVarData, float]:
+        self, vars_to_load: Optional[Sequence[VarData]] = None
+    ) -> Mapping[VarData, float]:
         if self._reduced_costs is None:
             raise RuntimeError(
                 'Solution loader does not currently have valid reduced costs. Please '
                 'check the termination condition and ensure the solver returns reduced '
                 'costs for the given problem type.'
             )
         if vars_to_load is None:
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_sol_reader.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_sol_reader.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_solution.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_solution.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/tests/unit/test_util.py` & `Pyomo-6.7.2/pyomo/contrib/solver/tests/unit/test_util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/solver/util.py` & `Pyomo-6.7.2/pyomo/contrib/solver/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/TRF.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/TRF.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/examples/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/examples/example1.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/examples/example1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/examples/example2.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/examples/example2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/filter.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/filter.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/interface.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/plugins.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_TRF.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_TRF.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_examples.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_filter.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_filter.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_interface.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_interface.py`

 * *Files 0% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     Objective,
     Constraint,
     sqrt,
     sin,
     cos,
     SolverFactory,
 )
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.var import VarData
 from pyomo.core.expr.numeric_expr import ExternalFunctionExpression
 from pyomo.core.expr.visitor import identify_variables
 from pyomo.contrib.trustregion.interface import TRFInterface
 from pyomo.contrib.trustregion.TRF import _trf_config
 
 logger = logging.getLogger('pyomo.contrib.trustregion')
 
@@ -154,15 +154,15 @@
             )
         # The truth models should be a mapping from the EF to
         # the replacement
         for i, k in self.interface.data.truth_models.items():
             self.assertIsInstance(k, ExternalFunctionExpression)
             self.assertIn(str(self.interface.model.x[0]), str(k))
             self.assertIn(str(self.interface.model.x[1]), str(k))
-            self.assertIsInstance(i, _GeneralVarData)
+            self.assertIsInstance(i, VarData)
             self.assertEqual(i, self.interface.data.ef_outputs[1])
         for i, k in self.interface.data.basis_expressions.items():
             self.assertEqual(k, 0)
             self.assertEqual(i, self.interface.data.ef_outputs[1])
         self.assertEqual(1, list(self.interface.data.ef_inputs.keys())[0])
         self.assertEqual(
             self.interface.data.ef_inputs[1],
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/tests/test_util.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/tests/test_util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/trustregion/util.py` & `Pyomo-6.7.2/pyomo/contrib/trustregion/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/main.ui` & `Pyomo-6.7.2/pyomo/contrib/viewer/main.ui`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/model_browser.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/model_browser.py`

 * *Files 0% similar despite different names*

```diff
@@ -29,15 +29,15 @@
 import logging
 
 _log = logging.getLogger(__name__)
 
 import pyomo.contrib.viewer.qt as myqt
 from pyomo.contrib.viewer.report import value_no_exception, get_residual
 
-from pyomo.core.base.param import _ParamData
+from pyomo.core.base.param import ParamData
 from pyomo.environ import (
     Block,
     BooleanVar,
     Var,
     Constraint,
     Param,
     Expression,
@@ -239,15 +239,15 @@
     def _get_expr_callback(self):
         if hasattr(self.data, "expr"):
             return str(self.data.expr)
         else:
             return None
 
     def _get_value_callback(self):
-        if isinstance(self.data, _ParamData):
+        if isinstance(self.data, ParamData):
             v = value_no_exception(self.data, div0="divide_by_0")
             # Check the param value for numpy float and int, sometimes numpy
             # values can sneak in especially if you set parameters from data
             # and for whatever reason numpy values don't display
             if isinstance(v, float):  # includes numpy float
                 v = float(v)
             elif isinstance(v, int):  # includes numpy int
@@ -291,15 +291,15 @@
             return get_residual(self.ui_data, self.data)
         else:
             return None
 
     def _get_units_callback(self):
         if isinstance(self.data, (Var, Var._ComponentDataClass)):
             return str(units.get_units(self.data))
-        if isinstance(self.data, (Param, _ParamData)):
+        if isinstance(self.data, (Param, ParamData)):
             return str(units.get_units(self.data))
         return self._cache_units
 
     def _get_domain_callback(self):
         if isinstance(self.data, Var._ComponentDataClass):
             return str(self.data.domain)
         if isinstance(self.data, (BooleanVar, BooleanVar._ComponentDataClass)):
@@ -316,15 +316,15 @@
                 return
         elif isinstance(self.data, (Var, BooleanVar)):
             try:
                 for o in self.data.values():
                     o.value = val
             except:
                 return
-        elif isinstance(self.data, _ParamData):
+        elif isinstance(self.data, ParamData):
             if not self.data.parent_component().mutable:
                 return
             try:
                 self.data.value = val
             except:
                 return
         elif isinstance(self.data, Param):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/model_browser.ui` & `Pyomo-6.7.2/pyomo/contrib/viewer/model_browser.ui`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/model_select.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/model_select.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/model_select.ui` & `Pyomo-6.7.2/pyomo/contrib/viewer/model_select.ui`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/pyomo_viewer.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/pyomo_viewer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/qt.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/qt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/report.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/report.py`

 * *Files 1% similar despite different names*

```diff
@@ -46,15 +46,15 @@
     is always positive.
 
     Args:
         ui_data (UIData): user interface data, includes the cache for calculated
             values of the constraint body. This function uses the cached values
             and will not trigger recalculation. If variable values have changed,
             this may not yield accurate results.
-        c(_ConstraintData): a constraint or constraint data
+        c(ConstraintData): a constraint or constraint data
     Returns:
         (float) residual
     """
     if c.upper is None:
         ub = None  # This is no upper bound
     else:
         ub = value_no_exception(c.upper, "Divide_by_0")
@@ -145,15 +145,15 @@
 
 
 def degrees_of_freedom(blk):
     """
     Return the degrees of freedom.
 
     Args:
-        blk (Block or _BlockData): Block to count degrees of freedom in
+        blk (Block or BlockData): Block to count degrees of freedom in
     Returns:
         (int): Number of degrees of freedom
     """
     return count_free_variables(blk) - count_equality_constraints(blk)
 
 
 def free_variables_in_active_equalities_set(blk):
```

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/residual_table.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/residual_table.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/residual_table.ui` & `Pyomo-6.7.2/pyomo/contrib/viewer/residual_table.ui`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_data_model_item.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_data_model_item.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_data_model_tree.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_data_model_tree.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_qt.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_qt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/tests/test_report.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/tests/test_report.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/ui.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/ui.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/contrib/viewer/ui_data.py` & `Pyomo-6.7.2/pyomo/contrib/viewer/ui_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/__init__.py` & `Pyomo-6.7.2/pyomo/core/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -97,15 +97,15 @@
 )
 from pyomo.core.expr.boolean_value import (
     as_boolean,
     BooleanConstant,
     BooleanValue,
     native_logical_values,
 )
-from pyomo.core.kernel.objective import minimize, maximize
+from pyomo.core.base import minimize, maximize
 from pyomo.core.base.config import PyomoOptions
 
 from pyomo.core.base.expression import Expression
 from pyomo.core.base.label import (
     CuidLabeler,
     CounterLabeler,
     NumericLabeler,
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/PyomoModel.py` & `Pyomo-6.7.2/pyomo/core/base/PyomoModel.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/__init__.py` & `Pyomo-6.7.2/pyomo/core/base/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -8,14 +8,15 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 # TODO: this import is for historical backwards compatibility and should
 # probably be removed
 from pyomo.common.collections import ComponentMap
+from pyomo.common.enums import minimize, maximize
 
 from pyomo.core.expr.symbol_map import SymbolMap
 from pyomo.core.expr.numvalue import (
     nonpyomo_leaf_types,
     native_types,
     native_numeric_types,
     value,
@@ -29,78 +30,96 @@
 )
 from pyomo.core.expr.boolean_value import (
     as_boolean,
     BooleanConstant,
     BooleanValue,
     native_logical_values,
 )
-from pyomo.core.kernel.objective import minimize, maximize
-from pyomo.core.base.config import PyomoOptions
 
-from pyomo.core.base.expression import Expression, _ExpressionData
+from pyomo.core.base.component import name, Component, ModelComponentFactory
+from pyomo.core.base.componentuid import ComponentUID
+from pyomo.core.base.config import PyomoOptions
+from pyomo.core.base.enums import SortComponents, TraversalStrategy
 from pyomo.core.base.label import (
     CuidLabeler,
     CounterLabeler,
     NumericLabeler,
     CNameLabeler,
     TextLabeler,
     AlphaNumericTextLabeler,
     NameLabeler,
     ShortNameLabeler,
 )
+from pyomo.core.base.misc import display
+from pyomo.core.base.reference import Reference
+from pyomo.core.base.symbol_map import symbol_map_from_instance
+from pyomo.core.base.transformation import (
+    Transformation,
+    TransformationFactory,
+    ReverseTransformationToken,
+)
+
+from pyomo.core.base.PyomoModel import (
+    global_option,
+    ModelSolution,
+    ModelSolutions,
+    Model,
+    ConcreteModel,
+    AbstractModel,
+)
 
 #
 # Components
 #
-from pyomo.core.base.component import name, Component, ModelComponentFactory
-from pyomo.core.base.componentuid import ComponentUID
 from pyomo.core.base.action import BuildAction
-from pyomo.core.base.check import BuildCheck
-from pyomo.core.base.set import Set, SetOf, simple_set_rule, RangeSet
-from pyomo.core.base.param import Param
-from pyomo.core.base.var import Var, _VarData, _GeneralVarData, ScalarVar, VarList
+from pyomo.core.base.block import (
+    Block,
+    BlockData,
+    ScalarBlock,
+    active_components,
+    components,
+    active_components_data,
+    components_data,
+)
 from pyomo.core.base.boolean_var import (
     BooleanVar,
-    _BooleanVarData,
-    _GeneralBooleanVarData,
+    BooleanVarData,
     BooleanVarList,
     ScalarBooleanVar,
 )
+from pyomo.core.base.check import BuildCheck
+from pyomo.core.base.connector import Connector, ConnectorData
 from pyomo.core.base.constraint import (
     simple_constraint_rule,
     simple_constraintlist_rule,
     ConstraintList,
     Constraint,
-    _ConstraintData,
+    ConstraintData,
 )
+from pyomo.core.base.expression import Expression, NamedExpressionData, ExpressionData
+from pyomo.core.base.external import ExternalFunction
 from pyomo.core.base.logical_constraint import (
     LogicalConstraint,
     LogicalConstraintList,
-    _LogicalConstraintData,
+    LogicalConstraintData,
 )
 from pyomo.core.base.objective import (
     simple_objective_rule,
     simple_objectivelist_rule,
     Objective,
     ObjectiveList,
-    _ObjectiveData,
-)
-from pyomo.core.base.connector import Connector
-from pyomo.core.base.sos import SOSConstraint
-from pyomo.core.base.piecewise import Piecewise
-from pyomo.core.base.suffix import (
-    active_export_suffix_generator,
-    active_import_suffix_generator,
-    Suffix,
+    ObjectiveData,
 )
-from pyomo.core.base.external import ExternalFunction
-from pyomo.core.base.symbol_map import symbol_map_from_instance
-from pyomo.core.base.reference import Reference
-
+from pyomo.core.base.param import Param, ParamData
+from pyomo.core.base.piecewise import Piecewise, PiecewiseData
 from pyomo.core.base.set import (
+    Set,
+    SetData,
+    SetOf,
+    RangeSet,
     Reals,
     PositiveReals,
     NonPositiveReals,
     NegativeReals,
     NonNegativeReals,
     Integers,
     PositiveIntegers,
@@ -112,47 +131,55 @@
     Any,
     AnyWithNone,
     EmptySet,
     UnitInterval,
     PercentFraction,
     RealInterval,
     IntegerInterval,
+    simple_set_rule,
 )
-from pyomo.core.base.misc import display
-from pyomo.core.base.block import (
-    Block,
-    ScalarBlock,
-    active_components,
-    components,
-    active_components_data,
-    components_data,
-)
-from pyomo.core.base.enums import SortComponents, TraversalStrategy
-from pyomo.core.base.PyomoModel import (
-    global_option,
-    ModelSolution,
-    ModelSolutions,
-    Model,
-    ConcreteModel,
-    AbstractModel,
-)
-from pyomo.core.base.transformation import (
-    Transformation,
-    TransformationFactory,
-    ReverseTransformationToken,
+from pyomo.core.base.sos import SOSConstraint, SOSConstraintData
+from pyomo.core.base.suffix import (
+    active_export_suffix_generator,
+    active_import_suffix_generator,
+    Suffix,
 )
+from pyomo.core.base.var import Var, VarData, ScalarVar, VarList
 
 from pyomo.core.base.instance2dat import instance2dat
 
+#
 # These APIs are deprecated and should be removed in the near future
+#
 from pyomo.core.base.set import set_options, RealSet, IntegerSet, BooleanSet
 
 from pyomo.common.deprecation import relocated_module_attribute
 
 relocated_module_attribute(
     'SimpleBlock', 'pyomo.core.base.block.SimpleBlock', version='6.0'
 )
 relocated_module_attribute('SimpleVar', 'pyomo.core.base.var.SimpleVar', version='6.0')
 relocated_module_attribute(
     'SimpleBooleanVar', 'pyomo.core.base.boolean_var.SimpleBooleanVar', version='6.0'
 )
+# Historically, only a subset of "private" component data classes were imported here
+relocated_module_attribute(
+    f'_GeneralVarData', f'pyomo.core.base.VarData', version='6.7.2'
+)
+relocated_module_attribute(
+    f'_GeneralBooleanVarData', f'pyomo.core.base.BooleanVarData', version='6.7.2'
+)
+relocated_module_attribute(
+    f'_ExpressionData', f'pyomo.core.base.NamedExpressionData', version='6.7.2'
+)
+for _cdata in (
+    'ConstraintData',
+    'LogicalConstraintData',
+    'VarData',
+    'BooleanVarData',
+    'ObjectiveData',
+):
+    relocated_module_attribute(
+        f'_{_cdata}', f'pyomo.core.base.{_cdata}', version='6.7.2'
+    )
+del _cdata
 del relocated_module_attribute
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/action.py` & `Pyomo-6.7.2/pyomo/core/base/action.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/block.py` & `Pyomo-6.7.2/pyomo/core/base/block.py`

 * *Files 5% similar despite different names*

```diff
@@ -5,26 +5,28 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from __future__ import annotations
 import copy
 import logging
 import sys
 import weakref
 import textwrap
 
 from collections import defaultdict
 from contextlib import contextmanager
 from inspect import isclass, currentframe
 from io import StringIO
 from itertools import filterfalse, chain
 from operator import itemgetter, attrgetter
+from typing import Union, Any, Type
 
 from pyomo.common.autoslots import AutoSlots
 from pyomo.common.collections import Mapping
 from pyomo.common.deprecation import deprecated, deprecation_warning, RenamedClass
 from pyomo.common.formatting import StreamIndenter
 from pyomo.common.gc_manager import PauseGC
 from pyomo.common.log import is_debug_set
@@ -40,14 +42,15 @@
 from pyomo.core.base.componentuid import ComponentUID
 from pyomo.core.base.set import Any
 from pyomo.core.base.var import Var
 from pyomo.core.base.initializer import Initializer
 from pyomo.core.base.indexed_component import (
     ActiveIndexedComponent,
     UnindexedComponent_set,
+    IndexedComponent,
 )
 
 from pyomo.opt.base import ProblemFormat, guess_format
 from pyomo.opt import WriterFactory
 
 logger = logging.getLogger('pyomo.core')
 
@@ -153,31 +156,31 @@
 
     def __init__(self):
         self.seen_components = set()
         self.seen_comp_thru_reference = set()
         self.seen_data = set()
 
     def unique(self, comp, items, are_values):
-        """Returns generator that filters duplicate _ComponentData objects from items
+        """Returns generator that filters duplicate ComponentData objects from items
 
         Parameters
         ----------
         comp: ComponentBase
            The Component (indexed or scalar) that contains all
-           _ComponentData returned by the `items` generator.  `comp` may
+           ComponentData returned by the `items` generator.  `comp` may
            be an IndexedComponent generated by :py:func:`Reference` (and
            hence may not own the component datas in `items`)
 
         items: generator
             Generator yielding either the values or the items from the
             `comp` Component.
 
         are_values: bool
-            If `True`, `items` yields _ComponentData objects, otherwise,
-            `items` yields `(index, _ComponentData)` tuples.
+            If `True`, `items` yields ComponentData objects, otherwise,
+            `items` yields `(index, ComponentData)` tuples.
 
         """
         if comp.is_reference():
             seen_components_contains = self.seen_components.__contains__
             seen_comp_thru_reference_contains = (
                 self.seen_comp_thru_reference.__contains__
             )
@@ -247,15 +250,15 @@
 
     data = {}
 
 
 class PseudoMap(AutoSlots.Mixin):
     """
     This class presents a "mock" dict interface to the internal
-    _BlockData data structures.  We return this object to the
+    BlockData data structures.  We return this object to the
     user to preserve the historical "{ctype : {name : obj}}"
     interface without actually regenerating that dict-of-dicts data
     structure.
 
     We now support {ctype : PseudoMap()}
     """
 
@@ -480,15 +483,15 @@
         """
         Generator returning (name, component) tuples for components
         defined on the Block
         """
         return self.items()
 
 
-class _BlockData(ActiveComponentData):
+class BlockData(ActiveComponentData):
     """
     This class holds the fundamental block data.
     """
 
     _Block_reserved_words = set()
 
     # If a writer cached a repn on this block, remove it when cloning
@@ -530,29 +533,29 @@
         # as opposed to maintaining the list without any holes).
         #
         ActiveComponentData.__init__(self, component)
         # Note: call super() here to bypass the Block __setattr__
         #   _ctypes:      { ctype -> [1st idx, last idx, count] }
         #   _decl:        { name -> idx }
         #   _decl_order:  list( tuples( obj, next_type_idx ) )
-        super(_BlockData, self).__setattr__('_ctypes', {})
-        super(_BlockData, self).__setattr__('_decl', {})
-        super(_BlockData, self).__setattr__('_decl_order', [])
+        super(BlockData, self).__setattr__('_ctypes', {})
+        super(BlockData, self).__setattr__('_decl', {})
+        super(BlockData, self).__setattr__('_decl_order', [])
         self._private_data = None
 
-    def __getattr__(self, val):
+    def __getattr__(self, val) -> Union[Component, IndexedComponent, Any]:
         if val in ModelComponentFactory:
             return _component_decorator(self, ModelComponentFactory.get_class(val))
         # Since the base classes don't support getattr, we can just
         # throw the "normal" AttributeError
         raise AttributeError(
             "'%s' object has no attribute '%s'" % (self.__class__.__name__, val)
         )
 
-    def __setattr__(self, name, val):
+    def __setattr__(self, name: str, val: Union[Component, IndexedComponent, Any]):
         """
         Set an attribute of a block data object.
         """
         #
         # In general, the most common case for this is setting a *new*
         # attribute.  After that, there is updating an existing
         # Component value, with the least common case being resetting an
@@ -567,15 +570,15 @@
                 #
                 self.add_component(name, val)
             else:
                 #
                 # Other Python objects are added with the standard __setattr__
                 # method.
                 #
-                super(_BlockData, self).__setattr__(name, val)
+                super(BlockData, self).__setattr__(name, val)
         #
         # Case 2.  The attribute exists and it is a component in the
         #          list of declarations in this block.  We will use the
         #          val to update the value of that [scalar] component
         #          through its set_value() method.
         #
         elif name in self._decl:
@@ -621,50 +624,50 @@
                 #
                 _set_value(val)
         #
         # Case 3. Handle setting non-Component attributes
         #
         else:
             #
-            # NB: This is important: the _BlockData is either a scalar
+            # NB: This is important: the BlockData is either a scalar
             # Block (where _parent and _component are defined) or a
             # single block within an Indexed Block (where only
             # _component is defined).  Regardless, the
-            # _BlockData.__init__() method declares these methods and
+            # BlockData.__init__() method declares these methods and
             # sets them either to None or a weakref.  Thus, we will
             # never have a problem converting these objects from
             # weakrefs into Blocks and back (when pickling); the
             # attribute is already in __dict__, we will not hit the
             # add_component / del_component branches above.  It also
             # means that any error checking we want to do when assigning
             # these attributes should be done here.
             #
             # NB: isintance() can be slow and we generally avoid it in
             # core methods.  However, it is only slow when it returns
             # False.  Since the common paths on this branch should
             # return True, this shouldn't be too inefficient.
             #
             if name == '_parent':
-                if val is not None and not isinstance(val(), _BlockData):
+                if val is not None and not isinstance(val(), BlockData):
                     raise ValueError(
                         "Cannot set the '_parent' attribute of Block '%s' "
                         "to a non-Block object (with type=%s); Did you "
                         "try to create a model component named '_parent'?"
                         % (self.name, type(val))
                     )
-                super(_BlockData, self).__setattr__(name, val)
+                super(BlockData, self).__setattr__(name, val)
             elif name == '_component':
-                if val is not None and not isinstance(val(), _BlockData):
+                if val is not None and not isinstance(val(), BlockData):
                     raise ValueError(
                         "Cannot set the '_component' attribute of Block '%s' "
                         "to a non-Block object (with type=%s); Did you "
                         "try to create a model component named '_component'?"
                         % (self.name, type(val))
                     )
-                super(_BlockData, self).__setattr__(name, val)
+                super(BlockData, self).__setattr__(name, val)
             #
             # At this point, we should only be seeing non-component data
             # the user is hanging on the blocks (uncommon) or the
             # initial setup of the object data (in __init__).
             #
             elif isinstance(val, Component):
                 logger.warning(
@@ -673,15 +676,15 @@
                     "This is usually indicative of a modelling error.\n"
                     "To avoid this warning, explicitly delete the attribute:\n"
                     "    del %s.%s" % (name, self.name, type(val), self.name, name)
                 )
                 delattr(self, name)
                 self.add_component(name, val)
             else:
-                super(_BlockData, self).__setattr__(name, val)
+                super(BlockData, self).__setattr__(name, val)
 
     def __delattr__(self, name):
         """
         Delete an attribute on this Block.
         """
         #
         # It is important that we call del_component() whenever a
@@ -696,15 +699,15 @@
             #
             self.del_component(name)
         else:
             #
             # Other Python objects are removed with the standard __detattr__
             # method.
             #
-            super(_BlockData, self).__delattr__(name)
+            super(BlockData, self).__delattr__(name)
 
     def _compact_decl_storage(self):
         idxMap = {}
         _new_decl_order = []
         j = 0
         # Squeeze out the None entries
         for i, entry in enumerate(self._decl_order):
@@ -768,28 +771,28 @@
         incoming attribute is passed to the local Component's
         `set_value()` method.  Attribute names appearing in this block's
         `_Block_reserved_words` set will not be transferred (although
         Components will be).
 
         Parameters
         ----------
-        src: _BlockData or dict
+        src: BlockData or dict
             The Block or mapping that contains the new attributes to
             assign to this block.
         """
-        if isinstance(src, _BlockData):
+        if isinstance(src, BlockData):
             # There is a special case where assigning a parent block to
             # this block creates a circular hierarchy
             if src is self:
                 return
             p_block = self.parent_block()
             while p_block is not None:
                 if p_block is src:
                     raise ValueError(
-                        "_BlockData.transfer_attributes_from(): Cannot set a "
+                        "BlockData.transfer_attributes_from(): Cannot set a "
                         "sub-block (%s) to a parent block (%s): creates a "
                         "circular hierarchy" % (self, src)
                     )
                 p_block = p_block.parent_block()
             # record the components and the non-component objects added
             # to the block
             src_comp_map = dict(src.component_map().items())
@@ -797,15 +800,15 @@
             del_src_comp = src.del_component
         elif isinstance(src, Mapping):
             src_comp_map = {k: v for k, v in src.items() if isinstance(v, Component)}
             src_raw_dict = src
             del_src_comp = lambda x: None
         else:
             raise ValueError(
-                "_BlockData.transfer_attributes_from(): expected a "
+                "BlockData.transfer_attributes_from(): expected a "
                 "Block or dict; received %s" % (type(src).__name__,)
             )
 
         if src_comp_map:
             # Filter out any components from src
             src_raw_dict = {
                 k: v for k, v in src_raw_dict.items() if k not in src_comp_map
@@ -871,15 +874,15 @@
                         # one active data member
                         ctypes.add(ctype)
                         break
         return ctypes
 
     def model(self):
         #
-        # Special case: the "Model" is always the top-level _BlockData,
+        # Special case: the "Model" is always the top-level BlockData,
         # so if this is the top-level block, it must be the model
         #
         # Also note the interesting and intentional characteristic for
         # an IndexedBlock that is not attached to anything:
         #   b = Block([1,2,3])
         #   b.model() is None
         #   b[1].model() is b[1]
@@ -1028,15 +1031,15 @@
         # Add the component as an attribute.  Note that
         #
         #     self.__dict__[name]=val
         #
         # is inappropriate here.  The correct way to add the attribute
         # is to delegate the work to the next class up the MRO.
         #
-        super(_BlockData, self).__setattr__(name, val)
+        super(BlockData, self).__setattr__(name, val)
         #
         # Update the ctype linked lists
         #
         if _type in self._ctypes:
             idx_info = self._ctypes[_type]
             tmp = idx_info[1]
             self._decl_order[tmp] = (self._decl_order[tmp][0], _new_idx)
@@ -1050,34 +1053,21 @@
         #
         if _type is Block:
             val._suppress_ctypes |= _component._suppress_ctypes
         #
         # Error, for disabled support implicit rule names
         #
         if '_rule' in val.__dict__ and val._rule is None:
-            _found = False
             try:
                 _test = val.local_name + '_rule'
                 for i in (1, 2):
                     frame = sys._getframe(i)
-                    _found |= _test in frame.f_locals
             except:
                 pass
-            if _found:
-                # JDS: Do not blindly reformat this message.  The
-                # formatter inserts arbitrarily-long names(), which can
-                # cause the resulting logged message to be very poorly
-                # formatted due to long lines.
-                logger.warning(
-                    """As of Pyomo 4.0, Pyomo components no longer support implicit rules.
-You defined a component (%s) that appears
-to rely on an implicit rule (%s).
-Components must now specify their rules explicitly using 'rule=' keywords."""
-                    % (val.name, _test)
-                )
+
         #
         # Don't reconstruct if this component has already been constructed.
         # This allows a user to move a component from one block to
         # another.
         #
         if val._constructed is True:
             return
@@ -1099,15 +1089,15 @@
             else:
                 data = None
             generate_debug_messages = is_debug_set(logger)
             if generate_debug_messages:
                 # This is tricky: If we are in the middle of
                 # constructing an indexed block, the block component
                 # already has _constructed=True.  Now, if the
-                # _BlockData.__init__() defines any local variables
+                # BlockData.__init__() defines any local variables
                 # (like pyomo.gdp.Disjunct's indicator_var), name(True)
                 # will fail: this block data exists and has a parent(),
                 # but it has not yet been added to the parent's _data
                 # (so the idx lookup will fail in name).
                 if self.parent_block() is None:
                     _blockName = "[Model]"
                 else:
@@ -1187,15 +1177,15 @@
         # delattr as usual.
         #
         # del self.__dict__[name]
         #
         # Note: 'del self.__dict__[name]' is inappropriate here.  The
         # correct way to add the attribute is to delegate the work to
         # the next class up the MRO.
-        super(_BlockData, self).__delattr__(name)
+        super(BlockData, self).__delattr__(name)
 
     def reclassify_component_type(
         self, name_or_object, new_ctype, preserve_declaration_order=True
     ):
         """
         TODO
         """
@@ -1392,15 +1382,15 @@
             return PseudoMap(self, ctype, active, sort)
 
     def _component_data_iteritems(self, ctype, active, sort, dedup):
         """return the name, index, and component data for matching ctypes
 
         Generator that returns a nested 2-tuple of
 
-            ((component name, index value), _ComponentData)
+            ((component name, index value), ComponentData)
 
         for every component data in the block matching the specified
         ctype(s).
 
         Parameters
         ----------
         ctype:  None or type or iterable
@@ -1409,15 +1399,15 @@
         active: None or bool
             Filter components by the active flag
 
         sort: None or bool or SortComponents
             Iterate over the components in a specified sorted order
 
         dedup: _DeduplicateInfo
-            Deduplicator to prevent returning the same _ComponentData twice
+            Deduplicator to prevent returning the same ComponentData twice
         """
         for name, comp in PseudoMap(self, ctype, active, sort).items():
             # NOTE: Suffix has a dict interface (something other derived
             #   non-indexed Components may do as well), so we don't want
             #   to test the existence of iteritems as a check for
             #   component datas. We will rely on is_indexed() to catch
             #   all the indexed components.  Then we will do special
@@ -1445,30 +1435,30 @@
                     for idx, compData in _items
                     if compData.active == active
                 )
 
             yield from dedup.unique(comp, _items, False)
 
     def _component_data_itervalues(self, ctype, active, sort, dedup):
-        """Generator that returns the _ComponentData for every component data
+        """Generator that returns the ComponentData for every component data
         in the block.
 
         Parameters
         ----------
         ctype:  None or type or iterable
             Specifies the component types (`ctypes`) to include
 
         active: None or bool
             Filter components by the active flag
 
         sort: None or bool or SortComponents
             Iterate over the components in a specified sorted order
 
         dedup: _DeduplicateInfo
-            Deduplicator to prevent returning the same _ComponentData twice
+            Deduplicator to prevent returning the same ComponentData twice
         """
         for comp in PseudoMap(self, ctype, active, sort).values():
             # NOTE: Suffix has a dict interface (something other derived
             #   non-indexed Components may do as well), so we don't want
             #   to test the existence of iteritems as a check for
             #   component datas. We will rely on is_indexed() to catch
             #   all the indexed components.  Then we will do special
@@ -1566,15 +1556,15 @@
     ):
         """
         Return a generator that returns a tuple for each
         component data object in a block.  By default, this
         generator recursively descends into sub-blocks.  The
         tuple is
 
-            ((component name, index value), _ComponentData)
+            ((component name, index value), ComponentData)
 
         """
         dedup = _DeduplicateInfo()
         for _block in self.block_data_objects(
             active, sort, descend_into, descent_order
         ):
             yield from _block._component_data_iteritems(ctype, active, sort, dedup)
@@ -1987,30 +1977,46 @@
         if self._private_data is None:
             self._private_data = {}
         if scope not in self._private_data:
             self._private_data[scope] = Block._private_data_initializers[scope]()
         return self._private_data[scope]
 
 
+class _BlockData(metaclass=RenamedClass):
+    __renamed__new_class__ = BlockData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register(
     "A component that contains one or more model components."
 )
 class Block(ActiveIndexedComponent):
     """
     Blocks are indexed components that contain other components
     (including blocks).  Blocks have a global attribute that defines
     whether construction is deferred.  This applies to all components
     that they contain except blocks.  Blocks contained by other
     blocks use their local attribute to determine whether construction
     is deferred.
     """
 
-    _ComponentDataClass = _BlockData
+    _ComponentDataClass = BlockData
     _private_data_initializers = defaultdict(lambda: dict)
 
+    @overload
+    def __new__(
+        cls: Type[Block], *args, **kwds
+    ) -> Union[ScalarBlock, IndexedBlock]: ...
+
+    @overload
+    def __new__(cls: Type[ScalarBlock], *args, **kwds) -> ScalarBlock: ...
+
+    @overload
+    def __new__(cls: Type[IndexedBlock], *args, **kwds) -> IndexedBlock: ...
+
     def __new__(cls, *args, **kwds):
         if cls != Block:
             return super(Block, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return ScalarBlock.__new__(ScalarBlock)
         else:
             return IndexedBlock.__new__(IndexedBlock)
@@ -2082,15 +2088,15 @@
             obj = self._rule(_block, idx)
             # If the user returns a block, transfer over everything
             # they defined into the empty one we created.  We do
             # this inside the try block so that any abstract
             # components declared by the rule have the opportunity
             # to be initialized with data from
             # _BlockConstruction.data as they are transferred over.
-            if obj is not _block and isinstance(obj, _BlockData):
+            if obj is not _block and isinstance(obj, BlockData):
                 _block.transfer_attributes_from(obj)
         finally:
             if data is not None and _block is not self:
                 del _BlockConstruction.data[id(_block)]
 
         # TBD: Should we allow skipping Blocks???
         # if obj is Block.Skip and idx is not None:
@@ -2203,15 +2209,15 @@
             self.display(ostream=OUTPUT, prefix=prefix)
             OUTPUT.close()
             return
         if ostream is None:
             ostream = sys.stdout
 
         for key in sorted(self):
-            _BlockData.display(self[key], filename, ostream, prefix)
+            BlockData.display(self[key], filename, ostream, prefix)
 
     @staticmethod
     def register_private_data_initializer(initializer, scope=None):
         mod = currentframe().f_back.f_globals['__name__']
         if scope is None:
             scope = mod
         elif not mod.startswith(scope):
@@ -2223,17 +2229,17 @@
             raise RuntimeError(
                 "Duplicate initializer registration for 'private_data' dictionary "
                 f"(scope={scope})"
             )
         Block._private_data_initializers[scope] = initializer
 
 
-class ScalarBlock(_BlockData, Block):
+class ScalarBlock(BlockData, Block):
     def __init__(self, *args, **kwds):
-        _BlockData.__init__(self, component=self)
+        BlockData.__init__(self, component=self)
         Block.__init__(self, *args, **kwds)
         # Initialize the data dict so that (abstract) attribute
         # assignment will work.  Note that we do not trigger
         # get/setitem_when_not_present so that we do not (implicitly)
         # trigger the Block rule
         self._data[None] = self
         self._index = UnindexedComponent_index
@@ -2247,14 +2253,19 @@
     __renamed__version__ = '6.0'
 
 
 class IndexedBlock(Block):
     def __init__(self, *args, **kwds):
         Block.__init__(self, *args, **kwds)
 
+    @overload
+    def __getitem__(self, index) -> BlockData: ...
+
+    __getitem__ = IndexedComponent.__getitem__  # type: ignore
+
 
 #
 # Deprecated functions.
 #
 @deprecated(
     "generate_cuid_names() is deprecated. "
     "Use the ComponentUID.generate_cuid_string_map() static method",
@@ -2302,105 +2313,124 @@
     return block.component_data_objects(ctype=ctype, active=False, sort=sort)
 
 
 #
 # Create a Block and record all the default attributes, methods, etc.
 # These will be assumed to be the set of illegal component names.
 #
-_BlockData._Block_reserved_words = set(dir(Block()))
-
-
-class _IndexedCustomBlockMeta(type):
-    """Metaclass for creating an indexed custom block."""
+BlockData._Block_reserved_words = set(dir(Block()))
 
-    pass
 
-
-class _ScalarCustomBlockMeta(type):
-    """Metaclass for creating a scalar custom block."""
-
-    def __new__(meta, name, bases, dct):
-        def __init__(self, *args, **kwargs):
-            # bases[0] is the custom block data object
-            bases[0].__init__(self, component=self)
-            # bases[1] is the custom block object that
-            # is used for declaration
-            bases[1].__init__(self, *args, **kwargs)
-
-        dct["__init__"] = __init__
-        return type.__new__(meta, name, bases, dct)
+class ScalarCustomBlockMixin(object):
+    def __init__(self, *args, **kwargs):
+        # __bases__ for the ScalarCustomBlock is
+        #
+        #    (ScalarCustomBlockMixin, {custom_data}, {custom_block})
+        #
+        # Unfortunately, we cannot guarantee that this is being called
+        # from the ScalarCustomBlock (someone could have inherited from
+        # that class to make another scalar class).  We will walk up the
+        # MRO to find the Scalar class (which should be the only class
+        # that has this Mixin as the first base class)
+        for cls in self.__class__.__mro__:
+            if cls.__bases__[0] is ScalarCustomBlockMixin:
+                _mixin, _data, _block = cls.__bases__
+                _data.__init__(self, component=self)
+                _block.__init__(self, *args, **kwargs)
+                break
 
 
 class CustomBlock(Block):
     """The base class used by instances of custom block components"""
 
-    def __init__(self, *args, **kwds):
+    def __init__(self, *args, **kwargs):
         if self._default_ctype is not None:
-            kwds.setdefault('ctype', self._default_ctype)
-        Block.__init__(self, *args, **kwds)
+            kwargs.setdefault('ctype', self._default_ctype)
+        Block.__init__(self, *args, **kwargs)
 
-    def __new__(cls, *args, **kwds):
-        if cls.__name__.startswith('_Indexed') or cls.__name__.startswith('_Scalar'):
-            # we are entering here the second time (recursive)
-            # therefore, we need to create what we have
-            return super(CustomBlock, cls).__new__(cls)
+    def __new__(cls, *args, **kwargs):
+        if cls.__bases__[0] is not CustomBlock:
+            # we are creating a class other than the "generic" derived
+            # custom block class.  We can assume that the routing of the
+            # generic block class to the specific Scalar or Indexed
+            # subclass has already occurred and we can pass control up
+            # to (toward) object.__new__()
+            return super().__new__(cls, *args, **kwargs)
+        # If the first base class is this CustomBlock class, then the
+        # user is attempting to create the "generic" block class.
+        # Depending on the arguments, we need to map this to either the
+        # Scalar or Indexed block subclass.
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
-            n = _ScalarCustomBlockMeta(
-                "_Scalar%s" % (cls.__name__,), (cls._ComponentDataClass, cls), {}
-            )
-            return n.__new__(n)
+            return super().__new__(cls._scalar_custom_block, *args, **kwargs)
         else:
-            n = _IndexedCustomBlockMeta("_Indexed%s" % (cls.__name__,), (cls,), {})
-            return n.__new__(n)
+            return super().__new__(cls._indexed_custom_block, *args, **kwargs)
 
 
 def declare_custom_block(name, new_ctype=None):
     """Decorator to declare components for a custom block data class
 
-    >>> @declare_custom_block(name=FooBlock)
-    ... class FooBlockData(_BlockData):
+    >>> @declare_custom_block(name="FooBlock")
+    ... class FooBlockData(BlockData):
     ...    # custom block data class
     ...    pass
     """
 
-    def proc_dec(cls):
-        # this is the decorator function that
-        # creates the block component class
-
-        # Default (derived) Block attributes
-        clsbody = {
-            "__module__": cls.__module__,  # magic to fix the module
-            # Default IndexedComponent data object is the decorated class:
-            "_ComponentDataClass": cls,
-            # By default this new block does not declare a new ctype
-            "_default_ctype": None,
-        }
-
-        c = type(
+    def block_data_decorator(block_data):
+        # this is the decorator function that creates the block
+        # component classes
+
+        # Declare the new Block component (derived from CustomBlock)
+        # corresponding to the BlockData that we are decorating
+        #
+        # Note the use of `type(CustomBlock)` to pick up the metaclass
+        # that was used to create the CustomBlock (in general, it should
+        # be `type`)
+        comp = type(CustomBlock)(
             name,  # name of new class
             (CustomBlock,),  # base classes
-            clsbody,  # class body definitions (will populate __dict__)
+            # class body definitions (populate the new class' __dict__)
+            {
+                # ensure the created class is associated with the calling module
+                "__module__": block_data.__module__,
+                # Default IndexedComponent data object is the decorated class:
+                "_ComponentDataClass": block_data,
+                # By default this new block does not declare a new ctype
+                "_default_ctype": None,
+            },
         )
 
         if new_ctype is not None:
             if new_ctype is True:
-                c._default_ctype = c
-            elif type(new_ctype) is type:
-                c._default_ctype = new_ctype
+                comp._default_ctype = comp
+            elif isinstance(new_ctype, type):
+                comp._default_ctype = new_ctype
             else:
                 raise ValueError(
                     "Expected new_ctype to be either type "
                     "or 'True'; received: %s" % (new_ctype,)
                 )
 
-        # Register the new Block type in the same module as the BlockData
-        setattr(sys.modules[cls.__module__], name, c)
-        # TODO: can we also register concrete Indexed* and Scalar*
-        # classes into the original BlockData module (instead of relying
-        # on metaclasses)?
-
-        # are these necessary?
-        setattr(cls, '_orig_name', name)
-        setattr(cls, '_orig_module', cls.__module__)
-        return cls
+        # Declare Indexed and Scalar versions of the custom block.  We
+        # will register them both with the calling module scope, and
+        # with the CustomBlock (so that CustomBlock.__new__ can route
+        # the object creation to the correct class)
+        comp._indexed_custom_block = type(comp)(
+            "Indexed" + name,
+            (comp,),
+            {  # ensure the created class is associated with the calling module
+                "__module__": block_data.__module__
+            },
+        )
+        comp._scalar_custom_block = type(comp)(
+            "Scalar" + name,
+            (ScalarCustomBlockMixin, block_data, comp),
+            {  # ensure the created class is associated with the calling module
+                "__module__": block_data.__module__
+            },
+        )
+
+        # Register the new Block types in the same module as the BlockData
+        for _cls in (comp, comp._indexed_custom_block, comp._scalar_custom_block):
+            setattr(sys.modules[block_data.__module__], _cls.__name__, _cls)
+        return block_data
 
-    return proc_dec
+    return block_data_decorator
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/blockutil.py` & `Pyomo-6.7.2/pyomo/core/base/blockutil.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/boolean_var.py` & `Pyomo-6.7.2/pyomo/core/base/boolean_var.py`

 * *Files 5% similar despite different names*

```diff
@@ -64,35 +64,73 @@
     def __getstate__(self):
         return self._boolvar()
 
     def __setstate__(self, state):
         self._boolvar = weakref_ref(state)
 
 
-class _BooleanVarData(ComponentData, BooleanValue):
-    """
-    This class defines the data for a single variable.
+def _associated_binary_mapper(encode, val):
+    if val is None:
+        return None
+    if encode:
+        if val.__class__ is not _DeprecatedImplicitAssociatedBinaryVariable:
+            return val()
+    else:
+        if val.__class__ is not _DeprecatedImplicitAssociatedBinaryVariable:
+            return weakref_ref(val)
+    return val
+
+
+class BooleanVarData(ComponentData, BooleanValue):
+    """This class defines the data for a single Boolean variable.
 
-    Constructor Arguments:
-        component   The BooleanVar object that owns this data.
-    Public Class Attributes:
-        fixed       If True, then this variable is treated as a
-                        fixed constant in the model.
-        stale       A Boolean indicating whether the value of this variable is
-                        legitimate.  This value is true if the value should
-                        be considered legitimate for purposes of reporting or
-                        other interrogation.
-        value       The numeric value of this variable.
+    Parameters
+    ----------
+    component: Component
+        The BooleanVar object that owns this data.
+
+    Attributes
+    ----------
+    domain: SetData
+        The domain of this variable.
+
+    fixed: bool
+        If True, then this variable is treated as a fixed constant in
+        the model.
+
+    stale: bool
+        A Boolean indicating whether the value of this variable is
+        Consistent with the most recent solve.  `True` indicates that
+        this variable's value was set prior to the most recent solve and
+        was not updated by the results returned by the solve.
+
+    value: bool
+        The value of this variable.
     """
 
-    __slots__ = ()
+    __slots__ = ('_value', 'fixed', '_stale', '_associated_binary')
+    __autoslot_mappers__ = {
+        '_associated_binary': _associated_binary_mapper,
+        '_stale': StaleFlagManager.stale_mapper,
+    }
 
     def __init__(self, component=None):
+        #
+        # These lines represent in-lining of the
+        # following constructors:
+        #   - BooleanVarData
+        #   - ComponentData
+        #   - BooleanValue
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
+        self._value = None
+        self.fixed = False
+        self._stale = 0  # True
+
+        self._associated_binary = None
 
     def is_fixed(self):
         """Returns True if this variable is fixed, otherwise returns False."""
         return self.fixed
 
     def is_constant(self):
         """Returns False because this is not a constant in an expression."""
@@ -130,121 +168,14 @@
 
     def __call__(self, exception=True):
         """Compute the value of this variable."""
         return self.value
 
     @property
     def value(self):
-        """Return the value for this variable."""
-        raise NotImplementedError
-
-    @property
-    def domain(self):
-        """Return the domain for this variable."""
-        raise NotImplementedError
-
-    @property
-    def fixed(self):
-        """Return the fixed indicator for this variable."""
-        raise NotImplementedError
-
-    @property
-    def stale(self):
-        """Return the stale indicator for this variable."""
-        raise NotImplementedError
-
-    def fix(self, value=NOTSET, skip_validation=False):
-        """Fix the value of this variable (treat as nonvariable)
-
-        This sets the `fixed` indicator to True.  If ``value`` is
-        provided, the value (and the ``skip_validation`` flag) are first
-        passed to :py:meth:`set_value()`.
-
-        """
-        self.fixed = True
-        if value is not NOTSET:
-            self.set_value(value, skip_validation)
-
-    def unfix(self):
-        """Unfix this variable (treat as variable)
-
-        This sets the `fixed` indicator to False.
-
-        """
-        self.fixed = False
-
-    def free(self):
-        """Alias for :py:meth:`unfix`"""
-        return self.unfix()
-
-
-def _associated_binary_mapper(encode, val):
-    if val is None:
-        return None
-    if encode:
-        if val.__class__ is not _DeprecatedImplicitAssociatedBinaryVariable:
-            return val()
-    else:
-        if val.__class__ is not _DeprecatedImplicitAssociatedBinaryVariable:
-            return weakref_ref(val)
-    return val
-
-
-class _GeneralBooleanVarData(_BooleanVarData):
-    """
-    This class defines the data for a single Boolean variable.
-
-    Constructor Arguments:
-        component   The BooleanVar object that owns this data.
-
-    Public Class Attributes:
-        domain      The domain of this variable.
-        fixed       If True, then this variable is treated as a
-                        fixed constant in the model.
-        stale       A Boolean indicating whether the value of this variable is
-                        legitimiate.  This value is true if the value should
-                        be considered legitimate for purposes of reporting or
-                        other interrogation.
-        value       The numeric value of this variable.
-
-    The domain attribute is a property because it is
-    too widely accessed directly to enforce explicit getter/setter
-    methods and we need to deter directly modifying or accessing
-    these attributes in certain cases.
-    """
-
-    __slots__ = ('_value', 'fixed', '_stale', '_associated_binary')
-    __autoslot_mappers__ = {
-        '_associated_binary': _associated_binary_mapper,
-        '_stale': StaleFlagManager.stale_mapper,
-    }
-
-    def __init__(self, component=None):
-        #
-        # These lines represent in-lining of the
-        # following constructors:
-        #   - _BooleanVarData
-        #   - ComponentData
-        #   - BooleanValue
-        self._component = weakref_ref(component) if (component is not None) else None
-        self._index = NOTSET
-        self._value = None
-        self.fixed = False
-        self._stale = 0  # True
-
-        self._associated_binary = None
-
-    #
-    # Abstract Interface
-    #
-
-    # value is an attribute
-
-    @property
-    def value(self):
         """Return (or set) the value for this variable."""
         return self._value
 
     @value.setter
     def value(self, val):
         self.set_value(val)
 
@@ -261,22 +192,22 @@
     def stale(self, val):
         if val:
             self._stale = 0
         else:
             self._stale = StaleFlagManager.get_flag(0)
 
     def get_associated_binary(self):
-        """Get the binary _VarData associated with this
-        _GeneralBooleanVarData"""
+        """Get the binary VarData associated with this
+        BooleanVarData"""
         return (
             self._associated_binary() if self._associated_binary is not None else None
         )
 
     def associate_binary_var(self, binary_var):
-        """Associate a binary _VarData to this _GeneralBooleanVarData"""
+        """Associate a binary VarData to this BooleanVarData"""
         if (
             self._associated_binary is not None
             and type(self._associated_binary)
             is not _DeprecatedImplicitAssociatedBinaryVariable
         ):
             raise RuntimeError(
                 "Reassociating BooleanVar '%s' (currently associated "
@@ -290,14 +221,48 @@
                     ),
                     binary_var.name if binary_var is not None else None,
                 )
             )
         if binary_var is not None:
             self._associated_binary = weakref_ref(binary_var)
 
+    def fix(self, value=NOTSET, skip_validation=False):
+        """Fix the value of this variable (treat as nonvariable)
+
+        This sets the `fixed` indicator to True.  If ``value`` is
+        provided, the value (and the ``skip_validation`` flag) are first
+        passed to :py:meth:`set_value()`.
+
+        """
+        self.fixed = True
+        if value is not NOTSET:
+            self.set_value(value, skip_validation)
+
+    def unfix(self):
+        """Unfix this variable (treat as variable)
+
+        This sets the `fixed` indicator to False.
+
+        """
+        self.fixed = False
+
+    def free(self):
+        """Alias for :py:meth:`unfix`"""
+        return self.unfix()
+
+
+class _BooleanVarData(metaclass=RenamedClass):
+    __renamed__new_class__ = BooleanVarData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralBooleanVarData(metaclass=RenamedClass):
+    __renamed__new_class__ = BooleanVarData
+    __renamed__version__ = '6.7.2'
+
 
 @ModelComponentFactory.register("Logical decision variables.")
 class BooleanVar(IndexedComponent):
     """A logical variable, which may be defined over an index.
 
     Args:
         initialize (float or function, optional): The initial value for
@@ -305,15 +270,15 @@
         rule (float or function, optional): An alias for `initialize`.
         dense (bool, optional): Instantiate all elements from
             `index_set()` when constructing the Var (True) or just the
             variables returned by `initialize`/`rule` (False).  Defaults
             to True.
     """
 
-    _ComponentDataClass = _GeneralBooleanVarData
+    _ComponentDataClass = BooleanVarData
 
     def __new__(cls, *args, **kwds):
         if cls != BooleanVar:
             return super(BooleanVar, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return ScalarBooleanVar.__new__(ScalarBooleanVar)
         else:
@@ -386,15 +351,15 @@
         self._constructed = True
 
         if self._anonymous_sets is not None:
             for _set in self._anonymous_sets:
                 _set.construct()
 
         #
-        # Construct _BooleanVarData objects for all index values
+        # Construct BooleanVarData objects for all index values
         #
         if not self.is_indexed():
             self._data[None] = self
             self._initialize_members((None,))
         elif self._dense:
             # This loop is optimized for speed with pypy.
             # Calling dict.update((...) for ...) is roughly
@@ -497,19 +462,19 @@
             ],
             self._data.items(),
             ("Value", "Fixed", "Stale"),
             lambda k, v: [v.value, v.fixed, v.stale],
         )
 
 
-class ScalarBooleanVar(_GeneralBooleanVarData, BooleanVar):
+class ScalarBooleanVar(BooleanVarData, BooleanVar):
     """A single variable."""
 
     def __init__(self, *args, **kwd):
-        _GeneralBooleanVarData.__init__(self, component=self)
+        BooleanVarData.__init__(self, component=self)
         BooleanVar.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
     #
     # Override abstract interface methods to first check for
     # construction
     #
@@ -517,53 +482,53 @@
     # NOTE: that we can't provide these errors for
     # fixed and stale because they are attributes
 
     @property
     def value(self):
         """Return the value for this variable."""
         if self._constructed:
-            return _GeneralBooleanVarData.value.fget(self)
+            return BooleanVarData.value.fget(self)
         raise ValueError(
             "Accessing the value of variable '%s' "
             "before the Var has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     @value.setter
     def value(self, val):
         """Set the value for this variable."""
         if self._constructed:
-            return _GeneralBooleanVarData.value.fset(self, val)
+            return BooleanVarData.value.fset(self, val)
         raise ValueError(
             "Setting the value of variable '%s' "
             "before the Var has been constructed (there "
             "is currently nothing to set." % (self.name)
         )
 
     @property
     def domain(self):
-        return _GeneralBooleanVarData.domain.fget(self)
+        return BooleanVarData.domain.fget(self)
 
     def fix(self, value=NOTSET, skip_validation=False):
         """
         Set the fixed indicator to True. Value argument is optional,
         indicating the variable should be fixed at its current value.
         """
         if self._constructed:
-            return _GeneralBooleanVarData.fix(self, value, skip_validation)
+            return BooleanVarData.fix(self, value, skip_validation)
         raise ValueError(
             "Fixing variable '%s' "
             "before the Var has been constructed (there "
             "is currently nothing to set)." % (self.name)
         )
 
     def unfix(self):
         """Sets the fixed indicator to False."""
         if self._constructed:
-            return _GeneralBooleanVarData.unfix(self)
+            return BooleanVarData.unfix(self)
         raise ValueError(
             "Freeing variable '%s' "
             "before the Var has been constructed (there "
             "is currently nothing to set)." % (self.name)
         )
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/check.py` & `Pyomo-6.7.2/pyomo/core/base/check.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/component.py` & `Pyomo-6.7.2/pyomo/core/base/component.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from weakref import ref as weakref_ref
 
 import pyomo.common
 from pyomo.common import DeveloperError
 from pyomo.common.autoslots import AutoSlots, fast_deepcopy
 from pyomo.common.collections import OrderedDict
 from pyomo.common.deprecation import (
+    RenamedClass,
     deprecated,
     deprecation_warning,
     relocated_module_attribute,
 )
 from pyomo.common.factory import Factory
 from pyomo.common.formatting import tabular_writer, StreamIndenter
 from pyomo.common.modeling import NOTSET
@@ -75,15 +76,15 @@
     return name(*args, **kwds)
 
 
 class CloneError(pyomo.common.errors.PyomoException):
     pass
 
 
-class _ComponentBase(PyomoObject):
+class ComponentBase(PyomoObject):
     """A base class for Component and ComponentData
 
     This class defines some fundamental methods and properties that are
     expected for all Component-like objects.  They are centralized here
     to avoid repeated code in the Component and ComponentData classes.
     """
 
@@ -364,15 +365,15 @@
             _data,
             _header,
             _fcn,
         )
 
     @property
     def name(self):
-        """Get the fully qualifed component name."""
+        """Get the fully qualified component name."""
         return self.getname(fully_qualified=True)
 
     # Adding a setter here to help users adapt to the new
     # setting. The .name attribute is now ._name. It should
     # never be assigned to by user code.
     @name.setter
     def name(self, val):
@@ -470,15 +471,20 @@
             _data_dict = dict(_data)
             for _key in sorted_robust(_data_dict):
                 _fcn(ostream, _key, _data_dict[_key])
         elif _data is not None:
             ostream.write(_data)
 
 
-class Component(_ComponentBase):
+class _ComponentBase(metaclass=RenamedClass):
+    __renamed__new_class__ = ComponentBase
+    __renamed__version__ = '6.7.2'
+
+
+class Component(ComponentBase):
     """
     This is the base class for all Pyomo modeling components.
 
     Constructor arguments:
         ctype           The class type for the derived subclass
         doc             A text string describing this component
         name            A name for this component
@@ -653,22 +659,22 @@
             deprecation_warning(
                 "The 'name_buffer' argument to getname is deprecated. "
                 "The functionality is no longer necessary since getting names "
                 "is no longer a quadratic operation. Additionally, note that "
                 "use of this argument poses risks if the buffer contains "
                 "names relative to different Blocks in the model hierarchy or "
                 "a mixture of local and fully_qualified names.",
-                version='TODO',
+                version='6.4.1',
             )
             name_buffer[id(self)] = ans
         return ans
 
     @property
     def name(self):
-        """Get the fully qualifed component name."""
+        """Get the fully qualified component name."""
         return self.getname(fully_qualified=True)
 
     # Allow setting a component's name if it is not owned by a parent
     # block (this supports, e.g., naming a model)
     @name.setter
     def name(self, val):
         if self.parent_block() is None:
@@ -775,15 +781,15 @@
         self._active = True
 
     def deactivate(self):
         """Set the active attribute to False"""
         self._active = False
 
 
-class ComponentData(_ComponentBase):
+class ComponentData(ComponentBase):
     """
     This is the base class for the component data used
     in Pyomo modeling components.  Subclasses of ComponentData are
     used in indexed components, and this class assumes that indexed
     components are subclasses of IndexedComponent.  Note that
     ComponentData instances do not store their index.  This makes
     some operations significantly more expensive, but these are (a)
@@ -798,19 +804,19 @@
         _index          The index of this data object
     """
 
     __slots__ = ('_component', '_index', '__weakref__')
     __autoslot_mappers__ = {'_component': AutoSlots.weakref_mapper}
 
     # NOTE: This constructor is in-lined in the constructors for the following
-    # classes: _BooleanVarData, _ConnectorData, _ConstraintData,
-    # _GeneralExpressionData, _LogicalConstraintData,
-    # _GeneralLogicalConstraintData, _GeneralObjectiveData,
-    # _ParamData,_GeneralVarData, _GeneralBooleanVarData, _DisjunctionData,
-    # _ArcData, _PortData, _LinearConstraintData, and
+    # classes: BooleanVarData, ConnectorData, ConstraintData,
+    # ExpressionData, LogicalConstraintData,
+    # LogicalConstraintData, ObjectiveData,
+    # ParamData,VarData, BooleanVarData, DisjunctionData,
+    # ArcData, PortData, _LinearConstraintData, and
     # _LinearMatrixConstraintData. Changes made here need to be made in those
     # constructors as well!
     def __init__(self, component):
         #
         # ComponentData objects are typically *private* objects for
         # indexed / sparse indexed components.  As such, the (derived)
         # class needs to make sure that the owning component is *always*
@@ -912,15 +918,15 @@
             deprecation_warning(
                 "The 'name_buffer' argument to getname is deprecated. "
                 "The functionality is no longer necessary since getting names "
                 "is no longer a quadratic operation. Additionally, note that "
                 "use of this argument poses risks if the buffer contains "
                 "names relative to different Blocks in the model hierarchy or "
                 "a mixture of local and fully_qualified names.",
-                version='TODO',
+                version='6.4.1',
             )
             if id(self) in name_buffer:
                 # Return the name if it is in the buffer
                 return name_buffer[id(self)]
 
         c = self.parent_component()
         if c is self:
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/component_namer.py` & `Pyomo-6.7.2/pyomo/core/base/component_namer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/component_order.py` & `Pyomo-6.7.2/pyomo/core/base/component_order.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/componentuid.py` & `Pyomo-6.7.2/pyomo/core/base/componentuid.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/config.py` & `Pyomo-6.7.2/pyomo/core/base/config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/connector.py` & `Pyomo-6.7.2/pyomo/core/base/connector.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.indexed_component import IndexedComponent
 from pyomo.core.base.misc import apply_indexed_rule
 
 logger = logging.getLogger('pyomo.core')
 
 
-class _ConnectorData(ComponentData, NumericValue):
+class ConnectorData(ComponentData, NumericValue):
     """Holds the actual connector information"""
 
     __slots__ = ('vars', 'aggregators')
 
     def __init__(self, component=None):
         """Constructor"""
         #
@@ -101,14 +101,19 @@
             if not hasattr(var, 'is_indexed') or not var.is_indexed():
                 yield var
             else:
                 for v in var.values():
                     yield v
 
 
+class _ConnectorData(metaclass=RenamedClass):
+    __renamed__new_class__ = ConnectorData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register(
     "A bundle of variables that can be manipulated together."
 )
 @deprecated(
     "Use of pyomo.connectors is deprecated. "
     "Its functionality has been replaced by pyomo.network.",
     version='5.6.9',
@@ -153,28 +158,28 @@
         self._conval = {}
 
     #
     # This method must be defined on subclasses of
     # IndexedComponent
     #
     def _getitem_when_not_present(self, idx):
-        _conval = self._data[idx] = _ConnectorData(component=self)
+        _conval = self._data[idx] = ConnectorData(component=self)
         return _conval
 
     def construct(self, data=None):
         if is_debug_set(logger):  # pragma:nocover
             logger.debug(
                 "Constructing Connector, name=%s, from data=%s" % (self.name, data)
             )
         if self._constructed:
             return
         timer = ConstructionTimer(self)
         self._constructed = True
         #
-        # Construct _ConnectorData objects for all index values
+        # Construct ConnectorData objects for all index values
         #
         if self.is_indexed():
             self._initialize_members(self._index_set)
         else:
             self._data[None] = self
             self._initialize_members([None])
         timer.report()
@@ -254,17 +259,17 @@
             prefix + tab,
             ((k, v) for k, v in self._data.items()),
             ("Name", "Value"),
             _line_generator,
         )
 
 
-class ScalarConnector(Connector, _ConnectorData):
+class ScalarConnector(Connector, ConnectorData):
     def __init__(self, *args, **kwd):
-        _ConnectorData.__init__(self, component=self)
+        ConnectorData.__init__(self, component=self)
         Connector.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
 
 class SimpleConnector(metaclass=RenamedClass):
     __renamed__new_class__ = ScalarConnector
     __renamed__version__ = '6.0'
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/constraint.py` & `Pyomo-6.7.2/pyomo/core/base/constraint.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,18 +5,20 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from __future__ import annotations
 import sys
 import logging
 from weakref import ref as weakref_ref
 from pyomo.common.pyomo_typing import overload
+from typing import Union, Type
 
 from pyomo.common.deprecation import RenamedClass
 from pyomo.common.errors import DeveloperError
 from pyomo.common.formatting import tabular_writer
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import NOTSET
 from pyomo.common.timing import ConstructionTimer
@@ -38,14 +40,15 @@
 )
 from pyomo.core.base.component import ActiveComponentData, ModelComponentFactory
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.indexed_component import (
     ActiveIndexedComponent,
     UnindexedComponent_set,
     rule_wrapper,
+    IndexedComponent,
 )
 from pyomo.core.base.set import Set
 from pyomo.core.base.disable_methods import disable_methods
 from pyomo.core.base.initializer import (
     Initializer,
     IndexedCallInitializer,
     CountedCallInitializer,
@@ -118,25 +121,21 @@
         result_map[l_type(False)] = Constraint.Infeasible
     # Note: some logical types hash the same as bool (e.g., np.bool_), so
     # we will pass the set of all logical types in addition to the
     # result_map
     return rule_wrapper(rule, result_map, map_types=map_types)
 
 
-#
-# This class is a pure interface
-#
-
-
-class _ConstraintData(ActiveComponentData):
+class ConstraintData(ActiveComponentData):
     """
-    This class defines the data for a single constraint.
+    This class defines the data for a single algebraic constraint.
 
     Constructor arguments:
         component       The Constraint object that owns this data.
+        expr            The Pyomo expression stored in this constraint.
 
     Public class attributes:
         active          A boolean that is true if this constraint is
                             active in the model.
         body            The Pyomo expression for this constraint
         lower           The Pyomo expression for the lower bound
         upper           The Pyomo expression for the upper bound
@@ -148,187 +147,40 @@
                             constraint uses a strict upper bound
 
     Private class attributes:
         _component      The objective component.
         _active         A boolean that indicates whether this data is active
     """
 
-    __slots__ = ()
+    __slots__ = ('_body', '_lower', '_upper', '_expr')
 
     # Set to true when a constraint class stores its expression
     # in linear canonical form
     _linear_canonical_form = False
 
-    def __init__(self, component=None):
-        #
-        # These lines represent in-lining of the
-        # following constructors:
-        #   - _ConstraintData,
-        #   - ActiveComponentData
-        #   - ComponentData
-        self._component = weakref_ref(component) if (component is not None) else None
-        self._index = NOTSET
-        self._active = True
-
-    #
-    # Interface
-    #
-
-    def __call__(self, exception=True):
-        """Compute the value of the body of this constraint."""
-        return value(self.body, exception=exception)
-
-    def has_lb(self):
-        """Returns :const:`False` when the lower bound is
-        :const:`None` or negative infinity"""
-        return self.lb is not None
-
-    def has_ub(self):
-        """Returns :const:`False` when the upper bound is
-        :const:`None` or positive infinity"""
-        return self.ub is not None
-
-    def lslack(self):
-        """
-        Returns the value of f(x)-L for constraints of the form:
-            L <= f(x) (<= U)
-            (U >=) f(x) >= L
-        """
-        lb = self.lb
-        if lb is None:
-            return _inf
-        else:
-            return value(self.body) - lb
-
-    def uslack(self):
-        """
-        Returns the value of U-f(x) for constraints of the form:
-            (L <=) f(x) <= U
-            U >= f(x) (>= L)
-        """
-        ub = self.ub
-        if ub is None:
-            return _inf
-        else:
-            return ub - value(self.body)
-
-    def slack(self):
-        """
-        Returns the smaller of lslack and uslack values
-        """
-        lb = self.lb
-        ub = self.ub
-        body = value(self.body)
-        if lb is None:
-            return ub - body
-        elif ub is None:
-            return body - lb
-        return min(ub - body, body - lb)
-
-    #
-    # Abstract Interface
-    #
-
-    @property
-    def body(self):
-        """Access the body of a constraint expression."""
-        raise NotImplementedError
-
-    @property
-    def lower(self):
-        """Access the lower bound of a constraint expression."""
-        raise NotImplementedError
-
-    @property
-    def upper(self):
-        """Access the upper bound of a constraint expression."""
-        raise NotImplementedError
-
-    @property
-    def lb(self):
-        """Access the value of the lower bound of a constraint expression."""
-        raise NotImplementedError
-
-    @property
-    def ub(self):
-        """Access the value of the upper bound of a constraint expression."""
-        raise NotImplementedError
-
-    @property
-    def equality(self):
-        """A boolean indicating whether this is an equality constraint."""
-        raise NotImplementedError
-
-    @property
-    def strict_lower(self):
-        """True if this constraint has a strict lower bound."""
-        raise NotImplementedError
-
-    @property
-    def strict_upper(self):
-        """True if this constraint has a strict upper bound."""
-        raise NotImplementedError
-
-    def set_value(self, expr):
-        """Set the expression on this constraint."""
-        raise NotImplementedError
-
-    def get_value(self):
-        """Get the expression on this constraint."""
-        raise NotImplementedError
-
-
-class _GeneralConstraintData(_ConstraintData):
-    """
-    This class defines the data for a single general constraint.
-
-    Constructor arguments:
-        component       The Constraint object that owns this data.
-        expr            The Pyomo expression stored in this constraint.
-
-    Public class attributes:
-        active          A boolean that is true if this constraint is
-                            active in the model.
-        body            The Pyomo expression for this constraint
-        lower           The Pyomo expression for the lower bound
-        upper           The Pyomo expression for the upper bound
-        equality        A boolean that indicates whether this is an
-                            equality constraint
-        strict_lower    A boolean that indicates whether this
-                            constraint uses a strict lower bound
-        strict_upper    A boolean that indicates whether this
-                            constraint uses a strict upper bound
-
-    Private class attributes:
-        _component      The objective component.
-        _active         A boolean that indicates whether this data is active
-    """
-
-    __slots__ = ('_body', '_lower', '_upper', '_expr')
-
     def __init__(self, expr=None, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _ConstraintData,
+        #   - ConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = weakref_ref(component) if (component is not None) else None
         self._active = True
 
         self._body = None
         self._lower = None
         self._upper = None
         self._expr = None
         if expr is not None:
             self.set_value(expr)
 
-    #
-    # Abstract Interface
-    #
+    def __call__(self, exception=True):
+        """Compute the value of the body of this constraint."""
+        return value(self.body, exception=exception)
 
     @property
     def body(self):
         """Access the body of a constraint expression."""
         if self._body is not None:
             return self._body
         # The incoming RangedInequality had a potentially variable
@@ -444,14 +296,24 @@
         return False
 
     @property
     def strict_upper(self):
         """True if this constraint has a strict upper bound."""
         return False
 
+    def has_lb(self):
+        """Returns :const:`False` when the lower bound is
+        :const:`None` or negative infinity"""
+        return self.lb is not None
+
+    def has_ub(self):
+        """Returns :const:`False` when the upper bound is
+        :const:`None` or positive infinity"""
+        return self.ub is not None
+
     @property
     def expr(self):
         """Return the expression associated with this constraint."""
         return self._expr
 
     def get_value(self):
         """Get the expression on this constraint."""
@@ -671,14 +533,61 @@
                     self._upper = None
                 else:
                     raise ValueError(
                         "Constraint '%s' created with an invalid non-finite "
                         "upper bound (%s)." % (self.name, self._upper)
                     )
 
+    def lslack(self):
+        """
+        Returns the value of f(x)-L for constraints of the form:
+            L <= f(x) (<= U)
+            (U >=) f(x) >= L
+        """
+        lb = self.lb
+        if lb is None:
+            return _inf
+        else:
+            return value(self.body) - lb
+
+    def uslack(self):
+        """
+        Returns the value of U-f(x) for constraints of the form:
+            (L <=) f(x) <= U
+            U >= f(x) (>= L)
+        """
+        ub = self.ub
+        if ub is None:
+            return _inf
+        else:
+            return ub - value(self.body)
+
+    def slack(self):
+        """
+        Returns the smaller of lslack and uslack values
+        """
+        lb = self.lb
+        ub = self.ub
+        body = value(self.body)
+        if lb is None:
+            return ub - body
+        elif ub is None:
+            return body - lb
+        return min(ub - body, body - lb)
+
+
+class _ConstraintData(metaclass=RenamedClass):
+    __renamed__new_class__ = ConstraintData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralConstraintData(metaclass=RenamedClass):
+    __renamed__new_class__ = ConstraintData
+    __renamed__version__ = '6.7.2'
+
 
 @ModelComponentFactory.register("General constraint expressions.")
 class Constraint(ActiveIndexedComponent):
     """
     This modeling component defines a constraint expression using a
     rule function.
 
@@ -714,24 +623,35 @@
             A weakref to the model that owns this component
         _parent
             A weakref to the parent block that owns this component
         _type
             The class type for the derived subclass
     """
 
-    _ComponentDataClass = _GeneralConstraintData
+    _ComponentDataClass = ConstraintData
 
     class Infeasible(object):
         pass
 
     Feasible = ActiveIndexedComponent.Skip
     NoConstraint = ActiveIndexedComponent.Skip
     Violated = Infeasible
     Satisfied = Feasible
 
+    @overload
+    def __new__(
+        cls: Type[Constraint], *args, **kwds
+    ) -> Union[ScalarConstraint, IndexedConstraint]: ...
+
+    @overload
+    def __new__(cls: Type[ScalarConstraint], *args, **kwds) -> ScalarConstraint: ...
+
+    @overload
+    def __new__(cls: Type[IndexedConstraint], *args, **kwds) -> IndexedConstraint: ...
+
     def __new__(cls, *args, **kwds):
         if cls != Constraint:
             return super(Constraint, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return super(Constraint, cls).__new__(AbstractScalarConstraint)
         else:
             return super(Constraint, cls).__new__(IndexedConstraint)
@@ -861,106 +781,106 @@
                 value(v.lower, exception=False),
                 value(v.body, exception=False),
                 value(v.upper, exception=False),
             ],
         )
 
 
-class ScalarConstraint(_GeneralConstraintData, Constraint):
+class ScalarConstraint(ConstraintData, Constraint):
     """
     ScalarConstraint is the implementation representing a single,
     non-indexed constraint.
     """
 
     def __init__(self, *args, **kwds):
-        _GeneralConstraintData.__init__(self, component=self, expr=None)
+        ConstraintData.__init__(self, component=self, expr=None)
         Constraint.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     #
     # Singleton constraints are strange in that we want them to be
     # both be constructed but have len() == 0 when not initialized with
     # anything (at least according to the unit tests that are
     # currently in place). So during initialization only, we will
     # treat them as "indexed" objects where things like
     # Constraint.Skip are managed. But after that they will behave
-    # like _ConstraintData objects where set_value does not handle
+    # like ConstraintData objects where set_value does not handle
     # Constraint.Skip but expects a valid expression or None.
     #
     @property
     def body(self):
         """Access the body of a constraint expression."""
         if not self._data:
             raise ValueError(
                 "Accessing the body of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.body.fget(self)
+        return ConstraintData.body.fget(self)
 
     @property
     def lower(self):
         """Access the lower bound of a constraint expression."""
         if not self._data:
             raise ValueError(
                 "Accessing the lower bound of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.lower.fget(self)
+        return ConstraintData.lower.fget(self)
 
     @property
     def upper(self):
         """Access the upper bound of a constraint expression."""
         if not self._data:
             raise ValueError(
                 "Accessing the upper bound of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.upper.fget(self)
+        return ConstraintData.upper.fget(self)
 
     @property
     def equality(self):
         """A boolean indicating whether this is an equality constraint."""
         if not self._data:
             raise ValueError(
                 "Accessing the equality flag of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.equality.fget(self)
+        return ConstraintData.equality.fget(self)
 
     @property
     def strict_lower(self):
         """A boolean indicating whether this constraint has a strict lower bound."""
         if not self._data:
             raise ValueError(
                 "Accessing the strict_lower flag of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.strict_lower.fget(self)
+        return ConstraintData.strict_lower.fget(self)
 
     @property
     def strict_upper(self):
         """A boolean indicating whether this constraint has a strict upper bound."""
         if not self._data:
             raise ValueError(
                 "Accessing the strict_upper flag of ScalarConstraint "
                 "'%s' before the Constraint has been assigned "
                 "an expression. There is currently "
                 "nothing to access." % (self.name)
             )
-        return _GeneralConstraintData.strict_upper.fget(self)
+        return ConstraintData.strict_upper.fget(self)
 
     def clear(self):
         self._data = {}
 
     def set_value(self, expr):
         """Set the expression on this constraint."""
         if not self._data:
@@ -1016,14 +936,19 @@
     # the index is in the underlying index set (through 5.2 the index
     # was not checked).
     #
     def add(self, index, expr):
         """Add a constraint with a given index."""
         return self.__setitem__(index, expr)
 
+    @overload
+    def __getitem__(self, index) -> ConstraintData: ...
+
+    __getitem__ = IndexedComponent.__getitem__  # type: ignore
+
 
 @ModelComponentFactory.register("A list of constraint expressions.")
 class ConstraintList(IndexedConstraint):
     """
     A constraint component that represents a list of constraints.
     Constraints can be indexed by their index, but when they are
     added an index value is not specified.
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/disable_methods.py` & `Pyomo-6.7.2/pyomo/core/base/disable_methods.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/enums.py` & `Pyomo-6.7.2/pyomo/core/base/enums.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/expression.py` & `Pyomo-6.7.2/pyomo/core/base/expression.py`

 * *Files 4% similar despite different names*

```diff
@@ -32,40 +32,52 @@
 from pyomo.core.base.indexed_component import IndexedComponent, UnindexedComponent_set
 from pyomo.core.expr.numvalue import as_numeric
 from pyomo.core.base.initializer import Initializer
 
 logger = logging.getLogger('pyomo.core')
 
 
-class _ExpressionData(numeric_expr.NumericValue):
-    """
-    An object that defines a named expression.
+class NamedExpressionData(numeric_expr.NumericValue):
+    """An object that defines a generic "named expression".
+
+    This is the base class for both :py:class:`ExpressionData` and
+    :py:class:`ObjectiveData`.
 
     Public Class Attributes
         expr       The expression owned by this data.
+
     """
 
+    # Note: derived classes are expected to declare the _args_ slot
     __slots__ = ()
 
     EXPRESSION_SYSTEM = EXPR.ExpressionType.NUMERIC
     PRECEDENCE = 0
     ASSOCIATIVITY = EXPR.OperatorAssociativity.NON_ASSOCIATIVE
 
-    #
-    # Interface
-    #
-
     def __call__(self, exception=True):
         """Compute the value of this expression."""
         (arg,) = self._args_
         if arg.__class__ in native_types:
             # Note: native_types includes NoneType
             return arg
         return arg(exception=exception)
 
+    def create_node_with_local_data(self, values):
+        """
+        Construct a simple expression after constructing the
+        contained expression.
+
+        This class provides a consistent interface for constructing a
+        node, which is used in tree visitor scripts.
+        """
+        obj = self.__class__()
+        obj._args_ = values
+        return obj
+
     def is_named_expression_type(self):
         """A boolean indicating whether this in a named expression."""
         return True
 
     def is_expression_type(self, expression_system=None):
         """A boolean indicating whether this in an expression."""
         return expression_system is None or expression_system == self.EXPRESSION_SYSTEM
@@ -106,83 +118,32 @@
 
     def _compute_polynomial_degree(self, result):
         return result[0]
 
     def _is_fixed(self, values):
         return values[0]
 
-    #
-    # Abstract Interface
-    #
+    # NamedExpressionData should never return False because
+    # they can store subexpressions that contain variables
+    def is_potentially_variable(self):
+        return True
 
     @property
     def expr(self):
         (arg,) = self._args_
         if arg is None:
             return None
         return as_numeric(arg)
 
     @expr.setter
     def expr(self, value):
         self.set_value(value)
 
     def set_value(self, expr):
         """Set the expression on this expression."""
-        raise NotImplementedError
-
-    def is_constant(self):
-        """A boolean indicating whether this expression is constant."""
-        raise NotImplementedError
-
-    def is_fixed(self):
-        """A boolean indicating whether this expression is fixed."""
-        raise NotImplementedError
-
-    # _ExpressionData should never return False because
-    # they can store subexpressions that contain variables
-    def is_potentially_variable(self):
-        return True
-
-
-class _GeneralExpressionDataImpl(_ExpressionData):
-    """
-    An object that defines an expression that is never cloned
-
-    Constructor Arguments
-        expr        The Pyomo expression stored in this expression.
-        component   The Expression object that owns this data.
-
-    Public Class Attributes
-        expr       The expression owned by this data.
-    """
-
-    __slots__ = ()
-
-    def __init__(self, expr=None):
-        self._args_ = (expr,)
-
-    def create_node_with_local_data(self, values):
-        """
-        Construct a simple expression after constructing the
-        contained expression.
-
-        This class provides a consistent interface for constructing a
-        node, which is used in tree visitor scripts.
-        """
-        obj = ScalarExpression()
-        obj.construct()
-        obj._args_ = values
-        return obj
-
-    #
-    # Abstract Interface
-    #
-
-    def set_value(self, expr):
-        """Set the expression on this expression."""
         if expr is None or expr.__class__ in native_numeric_types:
             self._args_ = (expr,)
             return
         try:
             if expr.is_numeric_type():
                 self._args_ = (expr,)
                 return
@@ -231,15 +192,25 @@
         return numeric_expr._div_dispatcher[e.__class__, other.__class__](e, other)
 
     def __ipow__(self, other):
         (e,) = self._args_
         return numeric_expr._pow_dispatcher[e.__class__, other.__class__](e, other)
 
 
-class _GeneralExpressionData(_GeneralExpressionDataImpl, ComponentData):
+class _ExpressionData(metaclass=RenamedClass):
+    __renamed__new_class__ = NamedExpressionData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralExpressionDataImpl(metaclass=RenamedClass):
+    __renamed__new_class__ = NamedExpressionData
+    __renamed__version__ = '6.7.2'
+
+
+class ExpressionData(NamedExpressionData, ComponentData):
     """
     An object that defines an expression that is never cloned
 
     Constructor Arguments
         expr        The Pyomo expression stored in this expression.
         component   The Expression object that owns this data.
 
@@ -249,20 +220,24 @@
     Private class attributes:
         _component  The expression component.
     """
 
     __slots__ = ('_args_',)
 
     def __init__(self, expr=None, component=None):
-        _GeneralExpressionDataImpl.__init__(self, expr)
-        # Inlining ComponentData.__init__
+        self._args_ = (expr,)
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
 
 
+class _GeneralExpressionData(metaclass=RenamedClass):
+    __renamed__new_class__ = ExpressionData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register(
     "Named expressions that can be used in other expressions."
 )
 class Expression(IndexedComponent):
     """
     A shared expression container, which may be defined over a index.
 
@@ -271,15 +246,15 @@
                         used to initialize this object.
         expr        A synonym for initialize.
         rule        A rule function used to initialize this object.
         name        Name for this component.
         doc         Text describing this component.
     """
 
-    _ComponentDataClass = _GeneralExpressionData
+    _ComponentDataClass = ExpressionData
     # This seems like a copy-paste error, and should be renamed/removed
     NoConstraint = IndexedComponent.Skip
 
     def __new__(cls, *args, **kwds):
         if cls != Expression:
             return super(Expression, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
@@ -398,17 +373,17 @@
             # We do not (currently) accept data for constructing Constraints
             assert data is None
             self._construct_from_rule_using_setitem()
         finally:
             timer.report()
 
 
-class ScalarExpression(_GeneralExpressionData, Expression):
+class ScalarExpression(ExpressionData, Expression):
     def __init__(self, *args, **kwds):
-        _GeneralExpressionData.__init__(self, expr=None, component=self)
+        ExpressionData.__init__(self, expr=None, component=self)
         Expression.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     #
     # Override abstract interface methods to first check for
     # construction
     #
@@ -423,15 +398,15 @@
             "is currently no value to return)." % (self.name)
         )
 
     @property
     def expr(self):
         """Return expression on this expression."""
         if self._constructed:
-            return _GeneralExpressionData.expr.fget(self)
+            return ExpressionData.expr.fget(self)
         raise ValueError(
             "Accessing the expression of Expression '%s' "
             "before the Expression has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     @expr.setter
@@ -441,35 +416,35 @@
 
     def clear(self):
         self._data = {}
 
     def set_value(self, expr):
         """Set the expression on this expression."""
         if self._constructed:
-            return _GeneralExpressionData.set_value(self, expr)
+            return ExpressionData.set_value(self, expr)
         raise ValueError(
             "Setting the expression of Expression '%s' "
             "before the Expression has been constructed (there "
             "is currently no object to set)." % (self.name)
         )
 
     def is_constant(self):
         """A boolean indicating whether this expression is constant."""
         if self._constructed:
-            return _GeneralExpressionData.is_constant(self)
+            return ExpressionData.is_constant(self)
         raise ValueError(
             "Accessing the is_constant flag of Expression '%s' "
             "before the Expression has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     def is_fixed(self):
         """A boolean indicating whether this expression is fixed."""
         if self._constructed:
-            return _GeneralExpressionData.is_fixed(self)
+            return ExpressionData.is_fixed(self)
         raise ValueError(
             "Accessing the is_fixed flag of Expression '%s' "
             "before the Expression has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     #
@@ -505,10 +480,10 @@
     #       any reason to maintain a reference to a separate
     #       index set if we allow this.
     #
     def add(self, index, expr):
         """Add an expression with a given index."""
         if (type(expr) is tuple) and (expr == Expression.Skip):
             return None
-        cdata = _GeneralExpressionData(expr, component=self)
+        cdata = ExpressionData(expr, component=self)
         self._data[index] = cdata
         return cdata
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/external.py` & `Pyomo-6.7.2/pyomo/core/base/external.py`

 * *Files 2% similar despite different names*

```diff
@@ -27,22 +27,22 @@
     c_byte,
     c_char_p,
     c_void_p,
 )
 
 from pyomo.common.autoslots import AutoSlots
 from pyomo.common.fileutils import find_library
-from pyomo.core.expr.numvalue import (
+from pyomo.common.numeric_types import (
+    check_if_native_type,
     native_types,
     native_numeric_types,
-    pyomo_constant_types,
-    NonNumericValue,
-    NumericConstant,
     value,
+    _pyomo_constant_types,
 )
+from pyomo.core.expr.numvalue import NonNumericValue, NumericConstant
 import pyomo.core.expr as EXPR
 from pyomo.core.base.component import Component
 from pyomo.core.base.units_container import units
 
 logger = logging.getLogger('pyomo.core')
 nan = float('nan')
 
@@ -193,22 +193,23 @@
         # Loop and do two thing:
         #   1. Wrap non-numeric arguments
         #   2. See if we have a potentially variable argument
         #
         pv = False
         for i, arg in enumerate(args_):
             try:
-                # Q: Is there a better way to test if a value is an object
-                #    not in native_types and not a standard expression type?
                 if arg.__class__ in native_types:
                     continue
                 if arg.is_potentially_variable():
                     pv = True
+                continue
             except AttributeError:
-                args_[i] = NonNumericValue(arg)
+                if check_if_native_type(arg):
+                    continue
+            args_[i] = NonNumericValue(arg)
         #
         if pv:
             return EXPR.ExternalFunctionExpression(args_, self)
         return EXPR.NPV_ExternalFunctionExpression(args_, self)
 
     def evaluate(self, args):
         """Return the value of the function given the specified arguments
@@ -487,15 +488,15 @@
     __autoslot_mappers__ = {'value': _python_callback_fid_mapper}
 
     def is_constant(self):
         # Return False so this object is not simplified out of expressions
         return False
 
 
-pyomo_constant_types.add(_PythonCallbackFunctionID)
+_pyomo_constant_types.add(_PythonCallbackFunctionID)
 
 
 class PythonCallbackFunction(ExternalFunction):
     __autoslot_mappers__ = {'_fcn_id': _python_callback_fid_mapper}
 
     global_registry = []
     global_id_to_fid = {}
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/global_set.py` & `Pyomo-6.7.2/pyomo/core/base/global_set.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/indexed_component.py` & `Pyomo-6.7.2/pyomo/core/base/indexed_component.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 import sys
 import textwrap
 
 import pyomo.core.expr as EXPR
 import pyomo.core.base as BASE
 from pyomo.core.base.indexed_component_slice import IndexedComponent_slice
 from pyomo.core.base.initializer import Initializer
-from pyomo.core.base.component import Component, ActiveComponent
+from pyomo.core.base.component import Component, ActiveComponent, ComponentData
 from pyomo.core.base.config import PyomoOptions
 from pyomo.core.base.enums import SortComponents
 from pyomo.core.base.global_set import UnindexedComponent_set
 from pyomo.core.expr.numeric_expr import _ndarray
 from pyomo.core.pyomoobject import PyomoObject
 from pyomo.common import DeveloperError
 from pyomo.common.autoslots import fast_deepcopy
@@ -602,15 +602,15 @@
         return self.values()
 
     @deprecated('The iteritems method is deprecated. Use dict.items().', version='6.0')
     def iteritems(self):
         """Return a list (index,data) tuples from the dictionary"""
         return self.items()
 
-    def __getitem__(self, index):
+    def __getitem__(self, index) -> ComponentData:
         """
         This method returns the data corresponding to the given index.
         """
         if self._constructed is False:
             self._not_constructed_error(index)
 
         try:
@@ -727,15 +727,15 @@
 
         if obj is _NotFound:
             if index.__class__ is not IndexedComponent_slice:
                 index = self._validate_index(index)
 
         # this supports "del m.x[:,1]" through a simple recursive call
         if index.__class__ is IndexedComponent_slice:
-            # Assert that this slice ws just generated
+            # Assert that this slice was just generated
             assert len(index._call_stack) == 1
             # Make a copy of the slicer items *before* we start
             # iterating over it (since we will be removing items!).
             for idx in list(index.expanded_keys()):
                 del self[idx]
         else:
             # Handle the normal deletion operation
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/indexed_component_slice.py` & `Pyomo-6.7.2/pyomo/core/base/indexed_component_slice.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/initializer.py` & `Pyomo-6.7.2/pyomo/core/base/initializer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/instance2dat.py` & `Pyomo-6.7.2/pyomo/core/base/instance2dat.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/label.py` & `Pyomo-6.7.2/pyomo/core/base/label.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/logical_constraint.py` & `Pyomo-6.7.2/pyomo/core/base/logical_constraint.py`

 * *Files 6% similar despite different names*

```diff
@@ -38,72 +38,15 @@
 
 logical constraint rules must return a valid logical proposition.
 The most common cause of this error is
 forgetting to include the "return" statement at the end of your rule.
 """
 
 
-class _LogicalConstraintData(ActiveComponentData):
-    """
-    This class defines the data for a single logical constraint.
-
-    It functions as a pure interface.
-
-    Constructor arguments:
-        component       The LogicalConstraint object that owns this data.
-
-    Public class attributes:
-        active          A boolean that is true if this statement is
-                            active in the model.
-        body            The Pyomo logical expression for this statement
-
-    Private class attributes:
-        _component      The statement component.
-        _active         A boolean that indicates whether this data is active
-    """
-
-    __slots__ = ()
-
-    def __init__(self, component=None):
-        #
-        # These lines represent in-lining of the
-        # following constructors:
-        #   - ActiveComponentData
-        #   - ComponentData
-        self._component = weakref_ref(component) if (component is not None) else None
-        self._index = NOTSET
-        self._active = True
-
-    #
-    # Interface
-    #
-    def __call__(self, exception=True):
-        """Compute the value of the body of this logical constraint."""
-        if self.body is None:
-            return None
-        return self.body(exception=exception)
-
-    #
-    # Abstract Interface
-    #
-    @property
-    def expr(self):
-        """Get the expression on this logical constraint."""
-        raise NotImplementedError
-
-    def set_value(self, expr):
-        """Set the expression on this logical constraint."""
-        raise NotImplementedError
-
-    def get_value(self):
-        """Get the expression on this logical constraint."""
-        raise NotImplementedError
-
-
-class _GeneralLogicalConstraintData(_LogicalConstraintData):
+class LogicalConstraintData(ActiveComponentData):
     """
     This class defines the data for a single general logical constraint.
 
     Constructor arguments:
         component       The LogicalStatement object that owns this data.
         expr            The Pyomo expression stored in this logical constraint.
 
@@ -119,25 +62,31 @@
 
     __slots__ = ('_expr',)
 
     def __init__(self, expr=None, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _LogicalConstraintData,
+        #   - LogicalConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
         self._active = True
 
         self._expr = None
         if expr is not None:
             self.set_value(expr)
 
+    def __call__(self, exception=True):
+        """Compute the value of the body of this logical constraint."""
+        if self.body is None:
+            return None
+        return self.body(exception=exception)
+
     #
     # Abstract Interface
     #
 
     @property
     def body(self):
         """Access the body of a logical constraint expression."""
@@ -169,14 +118,24 @@
         self._expr = as_boolean(expr)
 
     def get_value(self):
         """Get the expression on this logical constraint."""
         return self._expr
 
 
+class _LogicalConstraintData(metaclass=RenamedClass):
+    __renamed__new_class__ = LogicalConstraintData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralLogicalConstraintData(metaclass=RenamedClass):
+    __renamed__new_class__ = LogicalConstraintData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("General logical constraints.")
 class LogicalConstraint(ActiveIndexedComponent):
     """
     This modeling component defines a logical constraint using a
     rule function.
 
     Constructor arguments:
@@ -211,15 +170,15 @@
             A weakref to the model that owns this component
         _parent
             A weakref to the parent block that owns this component
         _type
             The class type for the derived subclass
     """
 
-    _ComponentDataClass = _GeneralLogicalConstraintData
+    _ComponentDataClass = LogicalConstraintData
 
     class Infeasible(object):
         pass
 
     Feasible = ActiveIndexedComponent.Skip
     NoConstraint = ActiveIndexedComponent.Skip
     Violated = Infeasible
@@ -369,15 +328,15 @@
             ((k, v) for k, v in self._data.items() if v.active),
             ("Body",),
             lambda k, v: [v.body()],
         )
 
     #
     # Checks flags like Constraint.Skip, etc. before actually creating a
-    # constraint object. Returns the _ConstraintData object when it should be
+    # constraint object. Returns the ConstraintData object when it should be
     #  added to the _data dict; otherwise, None is returned or an exception
     # is raised.
     #
     def _check_skip_add(self, index, expr):
         _expr_type = expr.__class__
         if expr is None:
             raise ValueError(
@@ -405,22 +364,22 @@
                     "LogicalConstraint '%s' cannot be passed 'Infeasible' as a value."
                     % (_get_indexed_component_data_name(self, index),)
                 )
 
         return expr
 
 
-class ScalarLogicalConstraint(_GeneralLogicalConstraintData, LogicalConstraint):
+class ScalarLogicalConstraint(LogicalConstraintData, LogicalConstraint):
     """
     ScalarLogicalConstraint is the implementation representing a single,
     non-indexed logical constraint.
     """
 
     def __init__(self, *args, **kwds):
-        _GeneralLogicalConstraintData.__init__(self, component=self, expr=None)
+        LogicalConstraintData.__init__(self, component=self, expr=None)
         LogicalConstraint.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     #
     # Override abstract interface methods to first check for
     # construction
     #
@@ -432,29 +391,29 @@
             if len(self._data) == 0:
                 raise ValueError(
                     "Accessing the body of ScalarLogicalConstraint "
                     "'%s' before the LogicalConstraint has been assigned "
                     "an expression. There is currently "
                     "nothing to access." % self.name
                 )
-            return _GeneralLogicalConstraintData.body.fget(self)
+            return LogicalConstraintData.body.fget(self)
         raise ValueError(
             "Accessing the body of logical constraint '%s' "
             "before the LogicalConstraint has been constructed (there "
             "is currently no value to return)." % self.name
         )
 
     #
     # Singleton logical constraints are strange in that we want them to be
     # both be constructed but have len() == 0 when not initialized with
     # anything (at least according to the unit tests that are
     # currently in place). So during initialization only, we will
     # treat them as "indexed" objects where things like
     # True are managed. But after that they will behave
-    # like _LogicalConstraintData objects where set_value expects
+    # like LogicalConstraintData objects where set_value expects
     # a valid expression or None.
     #
 
     def set_value(self, expr):
         """Set the expression on this logical constraint."""
         if not self._constructed:
             raise ValueError(
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/matrix_constraint.py` & `Pyomo-6.7.2/pyomo/core/base/matrix_constraint.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,24 +15,24 @@
 
 from pyomo.common.gc_manager import PauseGC
 from pyomo.common.log import is_debug_set
 from pyomo.core.base.set_types import Any
 from pyomo.core.expr.numvalue import value
 from pyomo.core.expr.numeric_expr import LinearExpression
 from pyomo.core.base.component import ModelComponentFactory
-from pyomo.core.base.constraint import IndexedConstraint, _ConstraintData
+from pyomo.core.base.constraint import IndexedConstraint, ConstraintData
 from pyomo.repn.standard_repn import StandardRepn
 
 from collections.abc import Mapping
 
 
 logger = logging.getLogger('pyomo.core')
 
 
-class _MatrixConstraintData(_ConstraintData):
+class _MatrixConstraintData(ConstraintData):
     """
     This class defines the data for a single linear constraint
         derived from a canonical form Ax=b constraint.
 
     Constructor arguments:
         index           The index of this component within the container.
         component       The Constraint object that owns this data.
@@ -100,15 +100,15 @@
         repn.constant = constant
         return repn
 
     def __init__(self, index, component_ref):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _ConstraintData,
+        #   - ConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = component_ref
         self._active = True
 
         # row index into the sparse matrix stored on the parent
         assert index >= 0
@@ -205,15 +205,15 @@
     # Override some default implementations on ComponentData
     #
 
     def index(self):
         return self._index
 
     #
-    # Abstract Interface (_ConstraintData)
+    # Abstract Interface (ConstraintData)
     #
 
     @property
     def body(self):
         """Access the body of a constraint expression."""
         comp = self.parent_component()
         index = self._index
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/misc.py` & `Pyomo-6.7.2/pyomo/core/base/misc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/numvalue.py` & `Pyomo-6.7.2/pyomo/core/base/numvalue.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/objective.py` & `Pyomo-6.7.2/pyomo/core/base/objective.py`

 * *Files 7% similar despite different names*

```diff
@@ -11,35 +11,35 @@
 
 import sys
 import logging
 from weakref import ref as weakref_ref
 from pyomo.common.pyomo_typing import overload
 
 from pyomo.common.deprecation import RenamedClass
+from pyomo.common.enums import ObjectiveSense, minimize, maximize
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import NOTSET
 from pyomo.common.formatting import tabular_writer
 from pyomo.common.timing import ConstructionTimer
 
 from pyomo.core.expr.numvalue import value
 from pyomo.core.base.component import ActiveComponentData, ModelComponentFactory
 from pyomo.core.base.global_set import UnindexedComponent_index
 from pyomo.core.base.indexed_component import (
     ActiveIndexedComponent,
     UnindexedComponent_set,
     rule_wrapper,
 )
-from pyomo.core.base.expression import _ExpressionData, _GeneralExpressionDataImpl
+from pyomo.core.base.expression import NamedExpressionData
 from pyomo.core.base.set import Set
 from pyomo.core.base.initializer import (
     Initializer,
     IndexedCallInitializer,
     CountedCallInitializer,
 )
-from pyomo.core.base import minimize, maximize
 
 logger = logging.getLogger('pyomo.core')
 
 _rule_returned_none_error = """Objective '%s': rule returned None.
 
 Objective rules must return either a valid expression, numeric value, or
 Objective.Skip.  The most common cause of this error is forgetting to
@@ -77,55 +77,15 @@
         ...
 
     model.o = ObjectiveList(expr=simple_objectivelist_rule(...))
     """
     return rule_wrapper(rule, {None: ObjectiveList.End})
 
 
-#
-# This class is a pure interface
-#
-
-
-class _ObjectiveData(_ExpressionData):
-    """
-    This class defines the data for a single objective.
-
-    Public class attributes:
-        expr            The Pyomo expression for this objective
-        sense           The direction for this objective.
-    """
-
-    __slots__ = ()
-
-    #
-    # Interface
-    #
-
-    def is_minimizing(self):
-        """Return True if this is a minimization objective."""
-        return self.sense == minimize
-
-    #
-    # Abstract Interface
-    #
-
-    @property
-    def sense(self):
-        """Access sense (direction) of this objective."""
-        raise NotImplementedError
-
-    def set_sense(self, sense):
-        """Set the sense (direction) of this objective."""
-        raise NotImplementedError
-
-
-class _GeneralObjectiveData(
-    _GeneralExpressionDataImpl, _ObjectiveData, ActiveComponentData
-):
+class ObjectiveData(NamedExpressionData, ActiveComponentData):
     """
     This class defines the data for a single objective.
 
     Note that this is a subclass of NumericValue to allow
     objectives to be used as part of expressions.
 
     Constructor arguments:
@@ -140,30 +100,28 @@
         sense           The direction for this objective.
 
     Private class attributes:
         _component      The objective component.
         _active         A boolean that indicates whether this data is active
     """
 
-    __slots__ = ("_sense", "_args_")
+    __slots__ = ("_args_", "_sense")
 
     def __init__(self, expr=None, sense=minimize, component=None):
-        _GeneralExpressionDataImpl.__init__(self, expr)
+        # Inlining NamedExpressionData.__init__
+        self._args_ = (expr,)
         # Inlining ActiveComponentData.__init__
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
         self._active = True
-        self._sense = sense
+        self._sense = ObjectiveSense(sense)
 
-        if (self._sense != minimize) and (self._sense != maximize):
-            raise ValueError(
-                "Objective sense must be set to one of "
-                "'minimize' (%s) or 'maximize' (%s). Invalid "
-                "value: %s'" % (minimize, maximize, sense)
-            )
+    def is_minimizing(self):
+        """Return True if this is a minimization objective."""
+        return self.sense == minimize
 
     def set_value(self, expr):
         if expr is None:
             raise ValueError(_rule_returned_none_error % (self.name,))
         return super().set_value(expr)
 
     #
@@ -178,22 +136,25 @@
     @sense.setter
     def sense(self, sense):
         """Set the sense (direction) of this objective."""
         self.set_sense(sense)
 
     def set_sense(self, sense):
         """Set the sense (direction) of this objective."""
-        if sense in {minimize, maximize}:
-            self._sense = sense
-        else:
-            raise ValueError(
-                "Objective sense must be set to one of "
-                "'minimize' (%s) or 'maximize' (%s). Invalid "
-                "value: %s'" % (minimize, maximize, sense)
-            )
+        self._sense = ObjectiveSense(sense)
+
+
+class _ObjectiveData(metaclass=RenamedClass):
+    __renamed__new_class__ = ObjectiveData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralObjectiveData(metaclass=RenamedClass):
+    __renamed__new_class__ = ObjectiveData
+    __renamed__version__ = '6.7.2'
 
 
 @ModelComponentFactory.register("Expressions that are minimized or maximized.")
 class Objective(ActiveIndexedComponent):
     """
     This modeling component defines an objective expression.
 
@@ -236,15 +197,15 @@
             A weakref to the model that owns this component
         _parent
             A weakref to the parent block that owns this component
         _type
             The class type for the derived subclass
     """
 
-    _ComponentDataClass = _GeneralObjectiveData
+    _ComponentDataClass = ObjectiveData
     NoObjective = ActiveIndexedComponent.Skip
 
     def __new__(cls, *args, **kwds):
         if cls != Objective:
             return super(Objective, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return ScalarObjective.__new__(ScalarObjective)
@@ -349,19 +310,15 @@
             [
                 ("Size", len(self)),
                 ("Index", self._index_set if self.is_indexed() else None),
                 ("Active", self.active),
             ],
             self._data.items(),
             ("Active", "Sense", "Expression"),
-            lambda k, v: [
-                v.active,
-                ("minimize" if (v.sense == minimize) else "maximize"),
-                v.expr,
-            ],
+            lambda k, v: [v.active, v.sense, v.expr],
         )
 
     def display(self, prefix="", ostream=None):
         """Provide a verbose display of this object"""
         if not self.active:
             return
         tab = "    "
@@ -385,22 +342,22 @@
             prefix + tab,
             ((k, v) for k, v in self._data.items() if v.active),
             ("Active", "Value"),
             lambda k, v: [v.active, value(v)],
         )
 
 
-class ScalarObjective(_GeneralObjectiveData, Objective):
+class ScalarObjective(ObjectiveData, Objective):
     """
     ScalarObjective is the implementation representing a single,
     non-indexed objective.
     """
 
     def __init__(self, *args, **kwd):
-        _GeneralObjectiveData.__init__(self, expr=None, component=self)
+        ObjectiveData.__init__(self, expr=None, component=self)
         Objective.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
     #
     # Override abstract interface methods to first check for
     # construction
     #
@@ -428,15 +385,15 @@
             if len(self._data) == 0:
                 raise ValueError(
                     "Accessing the expression of ScalarObjective "
                     "'%s' before the Objective has been assigned "
                     "a sense or expression (there is currently "
                     "no value to return)." % (self.name)
                 )
-            return _GeneralObjectiveData.expr.fget(self)
+            return ObjectiveData.expr.fget(self)
         raise ValueError(
             "Accessing the expression of objective '%s' "
             "before the Objective has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     @expr.setter
@@ -451,15 +408,15 @@
             if len(self._data) == 0:
                 raise ValueError(
                     "Accessing the sense of ScalarObjective "
                     "'%s' before the Objective has been assigned "
                     "a sense or expression (there is currently "
                     "no value to return)." % (self.name)
                 )
-            return _GeneralObjectiveData.sense.fget(self)
+            return ObjectiveData.sense.fget(self)
         raise ValueError(
             "Accessing the sense of objective '%s' "
             "before the Objective has been constructed (there "
             "is currently no value to return)." % (self.name)
         )
 
     @sense.setter
@@ -470,15 +427,15 @@
     #
     # Singleton objectives are strange in that we want them to be
     # both be constructed but have len() == 0 when not initialized with
     # anything (at least according to the unit tests that are
     # currently in place). So during initialization only, we will
     # treat them as "indexed" objects where things like
     # Objective.Skip are managed. But after that they will behave
-    # like _ObjectiveData objects where set_value does not handle
+    # like ObjectiveData objects where set_value does not handle
     # Objective.Skip but expects a valid expression or None
     #
 
     def clear(self):
         self._data = {}
 
     def set_value(self, expr):
@@ -494,15 +451,15 @@
         return super().set_value(expr)
 
     def set_sense(self, sense):
         """Set the sense (direction) of this objective."""
         if self._constructed:
             if len(self._data) == 0:
                 self._data[None] = self
-            return _GeneralObjectiveData.set_sense(self, sense)
+            return ObjectiveData.set_sense(self, sense)
         raise ValueError(
             "Setting the sense of objective '%s' "
             "before the Objective has been constructed (there "
             "is currently no object to set)." % (self.name)
         )
 
     #
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/param.py` & `Pyomo-6.7.2/pyomo/core/base/param.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,19 +5,21 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from __future__ import annotations
 import sys
 import types
 import logging
 from weakref import ref as weakref_ref
 from pyomo.common.pyomo_typing import overload
+from typing import Union, Type
 
 from pyomo.common.autoslots import AutoSlots
 from pyomo.common.deprecation import deprecation_warning, RenamedClass
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import NOTSET
 from pyomo.common.numeric_types import native_types, value as expr_value
 from pyomo.common.timing import ConstructionTimer
@@ -112,15 +114,15 @@
     # This is not settable.  However the base classes assume that it is,
     # so we need to define the setter and just ignore the incoming value
     @_parent.setter
     def _parent(self, val):
         pass
 
 
-class _ParamData(ComponentData, NumericValue):
+class ParamData(ComponentData, NumericValue):
     """
     This class defines the data for a mutable parameter.
 
     Constructor Arguments:
         owner       The Param object that owns this data.
         value       The value of this parameter.
 
@@ -246,14 +248,19 @@
     def _compute_polynomial_degree(self, result):
         """
         Returns 0 because this object can never reference variables.
         """
         return 0
 
 
+class _ParamData(metaclass=RenamedClass):
+    __renamed__new_class__ = ParamData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register(
     "Parameter data that is used to define a model instance."
 )
 class Param(IndexedComponent, IndexedComponent_NDArrayMixin):
     """
     A parameter value, which may be defined over an index.
 
@@ -279,22 +286,33 @@
         name
             Name for this component.
         doc
             Text describing this component.
     """
 
     DefaultMutable = False
-    _ComponentDataClass = _ParamData
+    _ComponentDataClass = ParamData
 
     class NoValue(object):
         """A dummy type that is pickle-safe that we can use as the default
         value for Params to indicate that no valid value is present."""
 
         pass
 
+    @overload
+    def __new__(
+        cls: Type[Param], *args, **kwds
+    ) -> Union[ScalarParam, IndexedParam]: ...
+
+    @overload
+    def __new__(cls: Type[ScalarParam], *args, **kwds) -> ScalarParam: ...
+
+    @overload
+    def __new__(cls: Type[IndexedParam], *args, **kwds) -> IndexedParam: ...
+
     def __new__(cls, *args, **kwds):
         if cls != Param:
             return super(Param, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return super(Param, cls).__new__(ScalarParam)
         else:
             return super(Param, cls).__new__(IndexedParam)
@@ -506,30 +524,30 @@
             if _isDict:
                 # It is possible that the Param is sparse and that the
                 # index is not already in the _data dict.  As these
                 # cases are rare, we will recover from the exception
                 # instead of incurring the penalty of checking.
                 for index, new_value in new_values.items():
                     if index not in self._data:
-                        self._data[index] = _ParamData(self)
+                        self._data[index] = ParamData(self)
                     self._data[index]._value = new_value
             else:
                 # For scalars, we will choose an approach based on
                 # how "dense" the Param is
                 if not self._data:  # empty
                     for index in self._index_set:
-                        p = self._data[index] = _ParamData(self)
+                        p = self._data[index] = ParamData(self)
                         p._value = new_values
                 elif len(self._data) == len(self._index_set):
                     for index in self._index_set:
                         self._data[index]._value = new_values
                 else:
                     for index in self._index_set:
                         if index not in self._data:
-                            self._data[index] = _ParamData(self)
+                            self._data[index] = ParamData(self)
                         self._data[index]._value = new_values
         else:
             #
             # Initialize a scalar
             #
             if _isDict:
                 if None not in new_values:
@@ -584,17 +602,17 @@
         #
         val = self._default_val
         if val is Param.NoValue:
             # We should allow the creation of mutable params without
             # a default value, as long as *solving* a model without
             # reasonable values produces an informative error.
             if self._mutable:
-                # Note: _ParamData defaults to Param.NoValue
+                # Note: ParamData defaults to Param.NoValue
                 if self.is_indexed():
-                    ans = self._data[index] = _ParamData(self)
+                    ans = self._data[index] = ParamData(self)
                 else:
                     ans = self._data[index] = self
                 ans._index = index
                 return ans
             if self.is_indexed():
                 idx_str = '%s[%s]' % (self.name, index)
             else:
@@ -681,16 +699,16 @@
         # Set the value depending on the type of param value.
         #
         if self._mutable:
             obj.set_value(value, index)
             return obj
         else:
             old_value, self._data[index] = self._data[index], value
-            # Because we do not have a _ParamData, we cannot rely on the
-            # validation that occurs in _ParamData.set_value()
+            # Because we do not have a ParamData, we cannot rely on the
+            # validation that occurs in ParamData.set_value()
             try:
                 self._validate_value(index, value)
                 return value
             except:
                 self._data[index] = old_value
                 raise
 
@@ -719,22 +737,22 @@
         try:
             if index is None and not self.is_indexed():
                 self._data[None] = self
                 self.set_value(value, index)
                 self._index = UnindexedComponent_index
                 return self
             elif self._mutable:
-                obj = self._data[index] = _ParamData(self)
+                obj = self._data[index] = ParamData(self)
                 obj.set_value(value, index)
                 obj._index = index
                 return obj
             else:
                 self._data[index] = value
-                # Because we do not have a _ParamData, we cannot rely on the
-                # validation that occurs in _ParamData.set_value()
+                # Because we do not have a ParamData, we cannot rely on the
+                # validation that occurs in ParamData.set_value()
                 self._validate_value(index, value, _check_domain)
                 return value
         except:
             del self._data[index]
             raise
 
     def _validate_value(self, index, value, validate_domain=True, data=None):
@@ -884,17 +902,17 @@
             ("Mutable", self._mutable),
         ]
         if self._units is not None:
             headers.append(('Units', str(self._units)))
         return (headers, self.sparse_iteritems(), ("Value",), dataGen)
 
 
-class ScalarParam(_ParamData, Param):
+class ScalarParam(ParamData, Param):
     def __init__(self, *args, **kwds):
-        _ParamData.__init__(self, component=self)
+        ParamData.__init__(self, component=self)
         Param.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     #
     # Since this class derives from Component and Component.__getstate__
     # just packs up the entire __dict__ into the state dict, there s
     # nothng special that we need to do here.  We will just defer to the
@@ -979,15 +997,15 @@
     # GetItemExpression.
     #
     # FIXME: We should integrate this logic into the base implementation
     # of `__getitem__()`, including the recognition / differentiation
     # between potentially variable GetItemExpression objects and
     # "constant" GetItemExpression objects.  That will need to wait for
     # the expression rework [JDS; Nov 22].
-    def __getitem__(self, args):
+    def __getitem__(self, args) -> ParamData:
         try:
             return super().__getitem__(args)
         except:
             tmp = args if args.__class__ is tuple else (args,)
             if any(
                 hasattr(arg, 'is_potentially_variable')
                 and arg.is_potentially_variable()
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/piecewise.py` & `Pyomo-6.7.2/pyomo/core/base/piecewise.py`

 * *Files 0% similar despite different names*

```diff
@@ -36,22 +36,22 @@
 import math
 import itertools
 import operator
 import types
 import enum
 
 from pyomo.common.log import is_debug_set
-from pyomo.common.deprecation import deprecation_warning
+from pyomo.common.deprecation import RenamedClass, deprecation_warning
 from pyomo.common.numeric_types import value
 from pyomo.common.timing import ConstructionTimer
-from pyomo.core.base.block import Block, _BlockData
+from pyomo.core.base.block import Block, BlockData
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.constraint import Constraint, ConstraintList
 from pyomo.core.base.sos import SOSConstraint
-from pyomo.core.base.var import Var, _VarData, IndexedVar
+from pyomo.core.base.var import Var, VarData, IndexedVar
 from pyomo.core.base.set_types import PositiveReals, NonNegativeReals, Binary
 from pyomo.core.base.util import flatten_tuple
 
 logger = logging.getLogger('pyomo.core')
 
 
 class PWRepn(str, enum.Enum):
@@ -210,22 +210,22 @@
         return 1, values, False
     if _isNonIncreasing(slopes):
         # concave
         return -1, values, False
     return 0, values, False
 
 
-class _PiecewiseData(_BlockData):
+class PiecewiseData(BlockData):
     """
     This class defines the base class for all linearization
     and piecewise constraint generators..
     """
 
     def __init__(self, parent):
-        _BlockData.__init__(self, parent)
+        BlockData.__init__(self, parent)
         self._constructed = True
         self._bound_type = None
         self._domain_pts = None
         self._range_pts = None
         self._x = None
         self._y = None
 
@@ -268,14 +268,19 @@
             "The point %s is outside the list of domain "
             "points for Piecewise component %s. The valid "
             "point range is [%s,%s]."
             % (x, self.name, min(self._domain_pts), max(self._domain_pts))
         )
 
 
+class _PiecewiseData(metaclass=RenamedClass):
+    __renamed__new_class__ = PiecewiseData
+    __renamed__version__ = '6.7.2'
+
+
 class _SimpleSinglePiecewise(object):
     """
     Called when the piecewise points list has only two points
     """
 
     def construct(self, pblock, x_var, y_var):
         x_pts = pblock._domain_pts
@@ -1121,15 +1126,15 @@
               **NOTE: This does not imply unbounded piecewise segments
                       will be constructed. The outermost piecewise
                       breakpoints will bound the domain variable at each
                       index. However, the Var attributes .lb and .ub will
                       not be modified.
     """
 
-    _ComponentDataClass = _PiecewiseData
+    _ComponentDataClass = PiecewiseData
 
     def __new__(cls, *args, **kwds):
         if cls != Piecewise:
             return super(Piecewise, cls).__new__(cls)
         if len(args) == 2:
             return SimplePiecewise.__new__(SimplePiecewise)
         else:
@@ -1231,24 +1236,24 @@
         #       blocks as simply Blocks.
         #
         # kwds.setdefault('ctype', Piecewise)
         Block.__init__(self, *args, **kwds)
 
         # Check that the variables args are actually Pyomo Vars
         if not (
-            isinstance(self._domain_var, _VarData)
+            isinstance(self._domain_var, VarData)
             or isinstance(self._domain_var, IndexedVar)
         ):
             msg = (
                 "Piecewise component has invalid "
                 "argument type for domain variable, %s"
             )
             raise TypeError(msg % (repr(self._domain_var),))
         if not (
-            isinstance(self._range_var, _VarData)
+            isinstance(self._range_var, VarData)
             or isinstance(self._range_var, IndexedVar)
         ):
             msg = (
                 "Piecewise component has invalid "
                 "argument type for range variable, %s"
             )
             raise TypeError(msg % (repr(self._range_var),))
@@ -1350,30 +1355,30 @@
             _is_indexed = self.is_indexed()
 
         _self_parent = self._parent()
         _self_xvar = None
         _self_yvar = None
         _self_domain_pts_index = None
         if not _is_indexed:
-            # allows one to mix Var and _VarData as input to
+            # allows one to mix Var and VarData as input to
             # non-indexed Piecewise, index would be None in this case
-            # so for Var elements Var[None] is Var, but _VarData[None] would fail
+            # so for Var elements Var[None] is Var, but VarData[None] would fail
             _self_xvar = self._domain_var
             _self_yvar = self._range_var
             _self_domain_pts_index = self._domain_points[index]
         else:
-            # The following allows one to specify a Var or _VarData
+            # The following allows one to specify a Var or VarData
             # object even with an indexed Piecewise component.
             # The most common situation will most likely be a VarArray,
             # so we try this first.
-            if not isinstance(self._domain_var, _VarData):
+            if not isinstance(self._domain_var, VarData):
                 _self_xvar = self._domain_var[index]
             else:
                 _self_xvar = self._domain_var
-            if not isinstance(self._range_var, _VarData):
+            if not isinstance(self._range_var, VarData):
                 _self_yvar = self._range_var[index]
             else:
                 _self_yvar = self._range_var
             try:
                 _self_domain_pts_index = self._domain_points[index]
             except KeyError:
                 # This hack was set up in __init__ for using a single list or tuple
@@ -1537,27 +1542,27 @@
                     msg = (
                         "Piecewise '%s[%s]' does not have a valid "
                         "piecewise representation: '%s'"
                     )
                     raise ValueError(msg % (self.name, index, self._pw_rep))
 
         if _is_indexed:
-            comp = _PiecewiseData(self)
+            comp = PiecewiseData(self)
         else:
             comp = self
         self._data[index] = comp
         comp._index = index
         comp.updateBoundType(self._bound_type)
         comp.updatePoints(_self_domain_pts_index, range_pts)
         comp.build_constraints(func, _self_xvar, _self_yvar)
 
 
-class SimplePiecewise(_PiecewiseData, Piecewise):
+class SimplePiecewise(PiecewiseData, Piecewise):
     def __init__(self, *args, **kwds):
-        _PiecewiseData.__init__(self, self)
+        PiecewiseData.__init__(self, self)
         Piecewise.__init__(self, *args, **kwds)
 
 
 class IndexedPiecewise(Piecewise):
     def __init__(self, *args, **kwds):
         Piecewise.__init__(self, *args, **kwds)
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/plugin.py` & `Pyomo-6.7.2/pyomo/core/base/plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/range.py` & `Pyomo-6.7.2/pyomo/core/base/range.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/rangeset.py` & `Pyomo-6.7.2/pyomo/core/base/rangeset.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/reference.py` & `Pyomo-6.7.2/pyomo/core/base/reference.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
     UserDict,
     Mapping,
     MutableMapping,
     Set as collections_Set,
     Sequence,
 )
 from pyomo.common.modeling import NOTSET
-from pyomo.core.base.set import DeclareGlobalSet, Set, SetOf, OrderedSetOf, _SetDataBase
+from pyomo.core.base.set import DeclareGlobalSet, Set, SetOf, OrderedSetOf, SetData
 from pyomo.core.base.component import Component, ComponentData
 from pyomo.core.base.global_set import UnindexedComponent_set
 from pyomo.core.base.enums import SortComponents
 from pyomo.core.base.indexed_component import IndexedComponent, normalize_index
 from pyomo.core.base.indexed_component_slice import (
     IndexedComponent_slice,
     _IndexedComponent_slice_iter,
@@ -575,15 +575,15 @@
     identified by the slice (at construction time) share a common
     :py:meth:`Component.type`, then that type is assumed.  If either the
     ctype parameter is ``None`` or the data has more than one ctype, the
     resulting indexed component will have a ctype of
     :py:class:`IndexedComponent`.
 
     If the indices associated with wildcards in the component slice all
-    refer to the same :py:class:`Set` objects for all data identifed by
+    refer to the same :py:class:`Set` objects for all data identified by
     the slice, then the resulting indexed component will be indexed by
     the product of those sets.  However, if all data do not share common
     set objects, or only a subset of indices in a multidimentional set
     appear as wildcards, then the resulting indexed component will be
     indexed by a :py:class:`SetOf` containing a
     :py:class:`_ReferenceSet` for the slice.
 
@@ -770,18 +770,18 @@
             wildcards = sum(
                 (sorted(lvl.items()) for lvl in slice_idx if lvl is not None), []
             )
             # Wildcards is a list of (coordinate, set) tuples.  Coordinate
             # is that within the subsets list, and set is a wildcard set.
             index = wildcards[0][1]
             # index is the first wildcard set.
-            if not isinstance(index, _SetDataBase):
+            if not isinstance(index, SetData):
                 index = SetOf(index)
             for lvl, idx in wildcards[1:]:
-                if not isinstance(idx, _SetDataBase):
+                if not isinstance(idx, SetData):
                     idx = SetOf(idx)
                 index = index * idx
             # index is now either a single Set, or a SetProduct of the
             # wildcard sets.
     if ctype is NOTSET:
         if len(ctypes) == 1:
             # If ctype is not set and only one ctype was identified above,
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/set.py` & `Pyomo-6.7.2/pyomo/core/base/set.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,21 +5,24 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from __future__ import annotations
 import inspect
 import itertools
 import logging
 import math
 import sys
 import weakref
 from pyomo.common.pyomo_typing import overload
+from typing import Union, Type, Any as typingAny
+from collections.abc import Iterator
 
 from pyomo.common.collections import ComponentSet
 from pyomo.common.deprecation import deprecated, deprecation_warning, RenamedClass
 from pyomo.common.errors import DeveloperError, PyomoException
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import NOTSET
 from pyomo.common.sorting import sorted_robust
@@ -43,15 +46,15 @@
     NumericRange,
     NonNumericRange,
     AnyRange,
     RangeProduct,
     RangeDifferenceError,
 )
 from pyomo.core.base.component import (
-    _ComponentBase,
+    ComponentBase,
     Component,
     ComponentData,
     ModelComponentFactory,
 )
 from pyomo.core.base.indexed_component import (
     IndexedComponent,
     UnindexedComponent_set,
@@ -77,33 +80,30 @@
 
 Pyomo `Set` objects are designed to be "API-compatible" with Python
 `set` objects.  However, not all Set objects implement the full `set`
 API (e.g., only finite discrete Sets support `add()`).
 
 All Sets implement one of the following APIs:
 
-0. `class _SetDataBase(ComponentData)`
-   *(pure virtual interface)*
-
-1. `class _SetData(_SetDataBase)`
+1. `class SetData(ComponentData)`
    *(base class for all AML Sets)*
 
 2. `class _FiniteSetMixin(object)`
    *(pure virtual interface, adds support for discrete/iterable sets)*
 
 4. `class _OrderedSetMixin(object)`
    *(pure virtual interface, adds support for ordered Sets)*
 
 This is a bit of a change from python set objects.  First, the
 lowest-level (non-abstract) Data object supports infinite sets; that is,
 sets that contain an infinite number of values (this includes both
 bounded continuous ranges as well as unbounded discrete ranges).  As
 there are an infinite number of values, iteration is *not*
 supported. The base class also implements all Python set operations.
-Note that `_SetData` does *not* implement `len()`, as Python requires
+Note that `SetData` does *not* implement `len()`, as Python requires
 `len()` to return a positive integer.
 
 Finite sets add iteration and support for `len()`.  In addition, they
 support access to members through three methods: `data()` returns the
 members as a tuple (in the internal storage order), and may not be
 deterministic.  `ordered_data()` returns the members, and is guaranteed
 to be in a deterministic order (in the case of insertion order sets, up
@@ -121,27 +121,27 @@
 
 Note that the base APIs are all declared (and to the extent possible,
 implemented) through Mixin classes.
 """
 
 
 def process_setarg(arg):
-    if isinstance(arg, _SetDataBase):
+    if isinstance(arg, SetData):
         if (
             getattr(arg, '_parent', None) is not None
             or getattr(arg, '_anonymous_sets', None) is GlobalSetBase
             or arg.parent_component()._parent is not None
         ):
             return arg, None
         _anonymous = ComponentSet((arg,))
         if getattr(arg, '_anonymous_sets', None) is not None:
             _anonymous.update(arg._anonymous_sets)
         return arg, _anonymous
 
-    elif isinstance(arg, _ComponentBase):
+    elif isinstance(arg, ComponentBase):
         if isinstance(arg, IndexedComponent) and arg.is_indexed():
             raise TypeError(
                 "Cannot apply a Set operator to an "
                 "indexed %s component (%s)" % (arg.ctype.__name__, arg.name)
             )
         if isinstance(arg, Component):
             raise TypeError(
@@ -505,43 +505,35 @@
 
 
 class _NotFound(object):
     "Internal type flag used to indicate if an object is not found in a set"
     pass
 
 
-# A trivial class that we can use to test if an object is a "legitimate"
-# set (either ScalarSet, or a member of an IndexedSet)
-class _SetDataBase(ComponentData):
-    """The base for all objects that can be used as a component indexing set."""
-
-    __slots__ = ()
-
-
-class _SetData(_SetDataBase):
-    """The base for all Pyomo AML objects that can be used as a component
+class SetData(ComponentData):
+    """The base for all Pyomo objects that can be used as a component
     indexing set.
 
     Derived versions of this class can be used as the Index for any
     IndexedComponent (including IndexedSet)."""
 
     __slots__ = ()
 
     def __contains__(self, value):
         try:
             ans = self.get(value, _NotFound)
         except TypeError:
             # In Python 3.x, Sets are unhashable
-            if isinstance(value, _SetData):
+            if isinstance(value, SetData):
                 ans = _NotFound
             else:
                 raise
 
         if ans is _NotFound:
-            if isinstance(value, _SetData):
+            if isinstance(value, SetData):
                 deprecation_warning(
                     "Testing for set subsets with 'a in b' is deprecated.  "
                     "Use 'a.issubset(b)'.",
                     version='5.7',
                 )
                 return value.issubset(self)
             else:
@@ -565,15 +557,15 @@
     def isordered(self):
         """Returns True if this is an ordered finite discrete (iterable) Set"""
         return False
 
     def subsets(self, expand_all_set_operators=None):
         return iter((self,))
 
-    def __iter__(self):
+    def __iter__(self) -> Iterator[typingAny]:
         """Iterate over the set members
 
         Raises AttributeError for non-finite sets.  This must be
         declared for non-finite sets because scalar sets inherit from
         IndexedComponent, which provides an iterator (over the
         underlying indexing set).
         """
@@ -887,15 +879,15 @@
         if end == _inf:
             end = None
         return (start, end, interval.step)
 
     @property
     @deprecated("The 'virtual' attribute is no longer supported", version='5.7')
     def virtual(self):
-        return isinstance(self, (_AnySet, SetOperator, _InfiniteRangeSetData))
+        return isinstance(self, (_AnySet, SetOperator, InfiniteRangeSetData))
 
     @virtual.setter
     def virtual(self, value):
         if value != self.virtual:
             raise ValueError(
                 "Attempting to set the (deprecated) 'virtual' attribute on %s "
                 "to an invalid value (%s)" % (self.name, value)
@@ -1181,14 +1173,24 @@
     def __gt__(self, other):
         """
         Return True if the set is a strict superset of 'other'
         """
         return self >= other and not self == other
 
 
+class _SetData(metaclass=RenamedClass):
+    __renamed__new_class__ = SetData
+    __renamed__version__ = '6.7.2'
+
+
+class _SetDataBase(metaclass=RenamedClass):
+    __renamed__new_class__ = SetData
+    __renamed__version__ = '6.7.2'
+
+
 class _FiniteSetMixin(object):
     __slots__ = ()
 
     def __len__(self):
         raise DeveloperError(
             "Derived finite set class (%s) failed to "
             "implement __len__" % (type(self).__name__,)
@@ -1287,22 +1289,22 @@
                 try:
                     as_numeric(i)
                     yield NumericRange(i, i, 0)
                 except:
                     yield NonNumericRange(i)
 
 
-class _FiniteSetData(_FiniteSetMixin, _SetData):
+class FiniteSetData(_FiniteSetMixin, SetData):
     """A general unordered iterable Set"""
 
     __slots__ = ('_values', '_domain', '_validate', '_filter', '_dimen')
 
     def __init__(self, component):
-        _SetData.__init__(self, component=component)
-        # Derived classes (like _OrderedSetData) may want to change the
+        SetData.__init__(self, component=component)
+        # Derived classes (like OrderedSetData) may want to change the
         # storage
         if not hasattr(self, '_values'):
             self._values = set()
         self._domain = Any
         self._validate = None
         self._filter = None
         self._dimen = UnknownSetDimen
@@ -1463,14 +1465,19 @@
             if v not in self:
                 self.add(v)
 
     def pop(self):
         return self._values.pop()
 
 
+class _FiniteSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = FiniteSetData
+    __renamed__version__ = '6.7.2'
+
+
 class _ScalarOrderedSetMixin(object):
     # This mixin is required because scalar ordered sets implement
     # __getitem__() as an alias of at()
     __slots__ = ()
 
     def values(self):
         """Return an iterator of the component data objects in the dictionary"""
@@ -1623,37 +1630,37 @@
         else:
             raise IndexError(
                 "Accessing Pyomo Sets by position is 1-based: valid Set positional "
                 "index values are [1 .. len(Set)] or [-1 .. -len(Set)]"
             )
 
 
-class _OrderedSetData(_OrderedSetMixin, _FiniteSetData):
+class OrderedSetData(_OrderedSetMixin, FiniteSetData):
     """
     This class defines the base class for an ordered set of concrete data.
 
     In older Pyomo terms, this defines a "concrete" ordered set - that is,
     a set that "owns" the list of set members.  While this class actually
     implements a set ordered by insertion order, we make the "official"
-    _InsertionOrderSetData an empty derivative class, so that
+    InsertionOrderSetData an empty derivative class, so that
 
-         issubclass(_SortedSetData, _InsertionOrderSetData) == False
+         issubclass(SortedSetData, InsertionOrderSetData) == False
 
     Constructor Arguments:
         component   The Set object that owns this data.
 
     Public Class Attributes:
     """
 
     __slots__ = ('_ordered_values',)
 
     def __init__(self, component):
         self._values = {}
         self._ordered_values = []
-        _FiniteSetData.__init__(self, component=component)
+        FiniteSetData.__init__(self, component=component)
 
     def _iter_impl(self):
         """
         Return an iterator for the set.
         """
         return iter(self._ordered_values)
 
@@ -1723,15 +1730,20 @@
                 raise ValueError("%s.ord(x): x not in %s" % (self.name, self.name))
         try:
             return self._values[item[0]] + 1
         except KeyError:
             raise ValueError("%s.ord(x): x not in %s" % (self.name, self.name))
 
 
-class _InsertionOrderSetData(_OrderedSetData):
+class _OrderedSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = OrderedSetData
+    __renamed__version__ = '6.7.2'
+
+
+class InsertionOrderSetData(OrderedSetData):
     """
     This class defines the data for a ordered set where the items are ordered
     in insertion order (similar to Python's OrderedSet.
 
     Constructor Arguments:
         component   The Set object that owns this data.
 
@@ -1744,118 +1756,128 @@
         if type(val) in Set._UnorderedInitializers:
             logger.warning(
                 "Calling set_value() on an insertion order Set with "
                 "a fundamentally unordered data source (type: %s).  "
                 "This WILL potentially lead to nondeterministic behavior "
                 "in Pyomo" % (type(val).__name__,)
             )
-        super(_InsertionOrderSetData, self).set_value(val)
+        super(InsertionOrderSetData, self).set_value(val)
 
     def update(self, values):
         if type(values) in Set._UnorderedInitializers:
             logger.warning(
                 "Calling update() on an insertion order Set with "
                 "a fundamentally unordered data source (type: %s).  "
                 "This WILL potentially lead to nondeterministic behavior "
                 "in Pyomo" % (type(values).__name__,)
             )
-        super(_InsertionOrderSetData, self).update(values)
+        super(InsertionOrderSetData, self).update(values)
+
+
+class _InsertionOrderSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = InsertionOrderSetData
+    __renamed__version__ = '6.7.2'
 
 
 class _SortedSetMixin(object):
     """"""
 
     __slots__ = ()
 
     def ordered_iter(self):
         return iter(self)
 
     def sorted_iter(self):
         return iter(self)
 
 
-class _SortedSetData(_SortedSetMixin, _OrderedSetData):
+class SortedSetData(_SortedSetMixin, OrderedSetData):
     """
     This class defines the data for a sorted set.
 
     Constructor Arguments:
         component   The Set object that owns this data.
 
     Public Class Attributes:
     """
 
     __slots__ = ('_is_sorted',)
 
     def __init__(self, component):
         # An empty set is sorted...
         self._is_sorted = True
-        _OrderedSetData.__init__(self, component=component)
+        OrderedSetData.__init__(self, component=component)
 
     def _iter_impl(self):
         """
         Return an iterator for the set.
         """
         if not self._is_sorted:
             self._sort()
-        return super(_SortedSetData, self)._iter_impl()
+        return super(SortedSetData, self)._iter_impl()
 
     def __reversed__(self):
         if not self._is_sorted:
             self._sort()
-        return super(_SortedSetData, self).__reversed__()
+        return super(SortedSetData, self).__reversed__()
 
     def _add_impl(self, value):
         # Note that the sorted status has no bearing on insertion,
         # so there is no reason to check if the data is correctly sorted
         self._values[value] = len(self._values)
         self._ordered_values.append(value)
         self._is_sorted = False
 
     # Note: removing data does not affect the sorted flag
     # def remove(self, val):
     # def discard(self, val):
 
     def clear(self):
-        super(_SortedSetData, self).clear()
+        super(SortedSetData, self).clear()
         self._is_sorted = True
 
     def at(self, index):
         """
         Return the specified member of the set.
 
         The public Set API is 1-based, even though the
         internal _lookup and _values are (pythonically) 0-based.
         """
         if not self._is_sorted:
             self._sort()
-        return super(_SortedSetData, self).at(index)
+        return super(SortedSetData, self).at(index)
 
     def ord(self, item):
         """
         Return the position index of the input value.
 
         Note that Pyomo Set objects have positions starting at 1 (not 0).
 
         If the search item is not in the Set, then an IndexError is raised.
         """
         if not self._is_sorted:
             self._sort()
-        return super(_SortedSetData, self).ord(item)
+        return super(SortedSetData, self).ord(item)
 
     def sorted_data(self):
         return self.data()
 
     def _sort(self):
         self._ordered_values = list(
             self.parent_component()._sort_fcn(self._ordered_values)
         )
         self._values = {j: i for i, j in enumerate(self._ordered_values)}
         self._is_sorted = True
 
 
+class _SortedSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = SortedSetData
+    __renamed__version__ = '6.7.2'
+
+
 ############################################################################
 
 _SET_API = (('__contains__', 'test membership in'), 'get', 'ranges', 'bounds')
 _FINITESET_API = _SET_API + (
     ('__iter__', 'iterate over'),
     '__reversed__',
     '__len__',
@@ -1963,24 +1985,30 @@
 
     class SortedOrder(object):
         pass
 
     _ValidOrderedAuguments = {True, False, InsertionOrder, SortedOrder}
     _UnorderedInitializers = {set}
 
+    @overload
+    def __new__(cls: Type[Set], *args, **kwds) -> Union[SetData, IndexedSet]: ...
+
+    @overload
+    def __new__(cls: Type[OrderedScalarSet], *args, **kwds) -> OrderedScalarSet: ...
+
     def __new__(cls, *args, **kwds):
         if cls is not Set:
             return super(Set, cls).__new__(cls)
 
         # TBD: Should ordered be allowed to vary across an IndexedSet?
         #
         # Many things are easier by forcing it to be consistent across
         # the set (namely, the _ComponentDataClass is constant).
         # However, it is a bit off that 'ordered' it the only arg NOT
-        # processed by Initializer.  We can mock up a _SortedSetData
+        # processed by Initializer.  We can mock up a SortedSetData
         # sort function that preserves Insertion Order (lambda x: x), but
         # the unsorted is harder (it would effectively be insertion
         # order, but ordered() may not be deterministic based on how the
         # set was populated - and we could not issue a warning?)
         #
         # JDS [5/2019]: Until someone demands otherwise, I think we
         # should leave it constant across an IndexedSet
@@ -2017,19 +2045,19 @@
             elif ordered is Set.SortedOrder:
                 return super(Set, cls).__new__(AbstractSortedScalarSet)
             else:
                 return super(Set, cls).__new__(AbstractFiniteScalarSet)
         else:
             newObj = super(Set, cls).__new__(IndexedSet)
             if ordered is Set.InsertionOrder:
-                newObj._ComponentDataClass = _InsertionOrderSetData
+                newObj._ComponentDataClass = InsertionOrderSetData
             elif ordered is Set.SortedOrder:
-                newObj._ComponentDataClass = _SortedSetData
+                newObj._ComponentDataClass = SortedSetData
             else:
-                newObj._ComponentDataClass = _FiniteSetData
+                newObj._ComponentDataClass = FiniteSetData
             return newObj
 
     @overload
     def __init__(
         self,
         *indexes,
         initialize=None,
@@ -2165,15 +2193,15 @@
     # This method must be defined on subclasses of
     # IndexedComponent that support implicit definition
     #
     def _getitem_when_not_present(self, index):
         """Returns the default component data value."""
         # Because we allow sets within an IndexedSet to have different
         # dimen, we have moved the tuplization logic from PyomoModel
-        # into Set (because we cannot know the dimen of a _SetData until
+        # into Set (because we cannot know the dimen of a SetData until
         # we are actually constructing that index).  This also means
         # that we need to potentially communicate the dimen to the
         # (wrapped) value initializer.  So, we will get the dimen first,
         # then get the values.  Only then will we know that this index
         # will actually be constructed (and not Skipped).
         _block = self.parent_block()
 
@@ -2325,15 +2353,15 @@
         #     def members(x):
         #         ans = x.ordered_data()
         #         if len(x) > MAX_MEMBERES:
         #             return '{' + str(ans[:MAX_MEMBERES])[1:-1] + ', ...}'
         #         else:
         #             return '{' + str(ans)[1:-1] + "}"
 
-        # TBD: In the current design, we force all _SetData within an
+        # TBD: In the current design, we force all SetData within an
         # indexed Set to have the same isordered value, so we will only
         # print it once in the header.  Is this a good design?
         try:
             _ordered = self.isordered()
             _refClass = type(self)
         except:
             _ordered = issubclass(self._ComponentDataClass, _OrderedSetMixin)
@@ -2345,15 +2373,15 @@
             # However, we do not preserve that flag any more, so we
             # will infer it from the class hierarchy
             if issubclass(_refClass, _SortedSetMixin):
                 if self.parent_component()._sort_fcn is sorted_robust:
                     _ordered = "Sorted"
                 else:
                     _ordered = "{user}"
-            elif issubclass(_refClass, _InsertionOrderSetData):
+            elif issubclass(_refClass, InsertionOrderSetData):
                 _ordered = "Insertion"
         return (
             [
                 ("Size", len(self._data)),
                 ("Index", self._index_set if self.is_indexed() else None),
                 ("Ordered", _ordered),
             ],
@@ -2369,49 +2397,54 @@
 
 
 class IndexedSet(Set):
     def data(self):
         "Return a dict containing the data() of each Set in this IndexedSet"
         return {k: v.data() for k, v in self.items()}
 
+    @overload
+    def __getitem__(self, index) -> SetData: ...
+
+    __getitem__ = IndexedComponent.__getitem__  # type: ignore
 
-class FiniteScalarSet(_FiniteSetData, Set):
+
+class FiniteScalarSet(FiniteSetData, Set):
     def __init__(self, **kwds):
-        _FiniteSetData.__init__(self, component=self)
+        FiniteSetData.__init__(self, component=self)
         Set.__init__(self, **kwds)
         self._index = UnindexedComponent_index
 
 
 class FiniteSimpleSet(metaclass=RenamedClass):
     __renamed__new_class__ = FiniteScalarSet
     __renamed__version__ = '6.0'
 
 
-class OrderedScalarSet(_ScalarOrderedSetMixin, _InsertionOrderSetData, Set):
+class OrderedScalarSet(_ScalarOrderedSetMixin, InsertionOrderSetData, Set):
     def __init__(self, **kwds):
         # In case someone inherits from us, we will provide a rational
         # default for the "ordered" flag
         kwds.setdefault('ordered', Set.InsertionOrder)
 
-        _InsertionOrderSetData.__init__(self, component=self)
+        InsertionOrderSetData.__init__(self, component=self)
         Set.__init__(self, **kwds)
 
 
 class OrderedSimpleSet(metaclass=RenamedClass):
     __renamed__new_class__ = OrderedScalarSet
     __renamed__version__ = '6.0'
 
 
-class SortedScalarSet(_ScalarOrderedSetMixin, _SortedSetData, Set):
+class SortedScalarSet(_ScalarOrderedSetMixin, SortedSetData, Set):
     def __init__(self, **kwds):
         # In case someone inherits from us, we will provide a rational
         # default for the "ordered" flag
         kwds.setdefault('ordered', Set.SortedOrder)
 
-        _SortedSetData.__init__(self, component=self)
+        SortedSetData.__init__(self, component=self)
         Set.__init__(self, **kwds)
         self._index = UnindexedComponent_index
 
 
 class SortedSimpleSet(metaclass=RenamedClass):
     __renamed__new_class__ = SortedScalarSet
     __renamed__version__ = '6.0'
@@ -2446,36 +2479,36 @@
     __renamed__new_class__ = AbstractSortedScalarSet
     __renamed__version__ = '6.0'
 
 
 ############################################################################
 
 
-class SetOf(_SetData, Component):
+class SetOf(SetData, Component):
     """"""
 
     def __new__(cls, *args, **kwds):
         if cls is not SetOf:
             return super(SetOf, cls).__new__(cls)
         (reference,) = args
-        if isinstance(reference, (_SetData, GlobalSetBase)):
+        if isinstance(reference, (SetData, GlobalSetBase)):
             if reference.isfinite():
                 if reference.isordered():
                     return super(SetOf, cls).__new__(OrderedSetOf)
                 else:
                     return super(SetOf, cls).__new__(FiniteSetOf)
             else:
                 return super(SetOf, cls).__new__(InfiniteSetOf)
         if isinstance(reference, Sequence):
             return super(SetOf, cls).__new__(OrderedSetOf)
         else:
             return super(SetOf, cls).__new__(FiniteSetOf)
 
     def __init__(self, reference, **kwds):
-        _SetData.__init__(self, component=self)
+        SetData.__init__(self, component=self)
         kwds.setdefault('ctype', SetOf)
         Component.__init__(self, **kwds)
         self._ref = reference
         self.construct()
 
     def __str__(self):
         if self._name is not None:
@@ -2490,15 +2523,15 @@
         timer = ConstructionTimer(self)
         if is_debug_set(logger):
             logger.debug("Constructing SetOf, name=%s, from data=%r" % (self, data))
         timer.report()
 
     @property
     def dimen(self):
-        if isinstance(self._ref, _SetData):
+        if isinstance(self._ref, SetData):
             return self._ref.dimen
         _iter = iter(self)
         try:
             x = next(_iter)
             if type(x) is tuple:
                 ans = len(x)
             else:
@@ -2585,27 +2618,27 @@
                 raise
         return self._ref.index(item[0]) + 1
 
 
 ############################################################################
 
 
-class _InfiniteRangeSetData(_SetData):
+class InfiniteRangeSetData(SetData):
     """Data class for a infinite set.
 
     This Set implements an interface to an *infinite set* defined by one
     or more NumericRange objects.  As there are an infinite
     number of members, Infinite Range Sets are not iterable.
 
     """
 
     __slots__ = ('_ranges',)
 
     def __init__(self, component):
-        _SetData.__init__(self, component=component)
+        SetData.__init__(self, component=component)
         self._ranges = None
 
     def get(self, value, default=None):
         # The bulk of single-value set members were stored as scalars.
         # Check that first.
         if value.__class__ is tuple and len(value) == 1:
             v = value[0]
@@ -2630,16 +2663,21 @@
     def clear(self):
         self._ranges = ()
 
     def ranges(self):
         return iter(self._ranges)
 
 
-class _FiniteRangeSetData(
-    _SortedSetMixin, _OrderedSetMixin, _FiniteSetMixin, _InfiniteRangeSetData
+class _InfiniteRangeSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = InfiniteRangeSetData
+    __renamed__version__ = '6.7.2'
+
+
+class FiniteRangeSetData(
+    _SortedSetMixin, _OrderedSetMixin, _FiniteSetMixin, InfiniteRangeSetData
 ):
     __slots__ = ()
 
     @staticmethod
     def _range_gen(r):
         start, end = (r.start, r.end) if r.step > 0 else (r.end, r.start)
         step = abs(r.step)
@@ -2654,26 +2692,26 @@
                 n = start + i * step
 
     def _iter_impl(self):
         # If there is only a single underlying range, then we will
         # iterate over it
         nIters = len(self._ranges) - 1
         if not nIters:
-            yield from _FiniteRangeSetData._range_gen(self._ranges[0])
+            yield from FiniteRangeSetData._range_gen(self._ranges[0])
             return
 
         # The trick here is that we need to remove any duplicates from
         # the multiple ranges.  We will set up iterators for each range,
         # pull the first element from each iterator, sort and yield the
         # lowest value.
         iters = []
         for r in self._ranges:
             # Note: there should always be at least 1 member in each
             # NumericRange
-            i = _FiniteRangeSetData._range_gen(r)
+            i = FiniteRangeSetData._range_gen(r)
             iters.append([next(i), i])
 
         iters.sort(reverse=True, key=lambda x: x[0])
         n = None
         while iters:
             if n != iters[-1][0]:
                 n = iters[-1][0]
@@ -2731,19 +2769,24 @@
                 ans += 1
         raise ValueError(
             "Cannot identify position of %s in Set %s: item not in Set"
             % (item, self.name)
         )
 
     # We must redefine ranges(), bounds(), and domain so that we get the
-    # _InfiniteRangeSetData version and not the one from
+    # InfiniteRangeSetData version and not the one from
     # _FiniteSetMixin.
-    bounds = _InfiniteRangeSetData.bounds
-    ranges = _InfiniteRangeSetData.ranges
-    domain = _InfiniteRangeSetData.domain
+    bounds = InfiniteRangeSetData.bounds
+    ranges = InfiniteRangeSetData.ranges
+    domain = InfiniteRangeSetData.domain
+
+
+class _FiniteRangeSetData(metaclass=RenamedClass):
+    __renamed__new_class__ = FiniteRangeSetData
+    __renamed__version__ = '6.7.2'
 
 
 @ModelComponentFactory.register(
     "A sequence of numeric values.  RangeSet(start,end,step) is a sequence "
     "starting a value 'start', and increasing in values by 'step' until a "
     "value greater than or equal to 'end' is reached."
 )
@@ -3102,15 +3145,15 @@
             # all the ranges.  This allows pprint and len to be correct,
             # without special handling
             new_ranges = []
             old_ranges = list(self.ranges())
             old_ranges.reverse()
             while old_ranges:
                 r = old_ranges.pop()
-                for i, val in enumerate(_FiniteRangeSetData._range_gen(r)):
+                for i, val in enumerate(FiniteRangeSetData._range_gen(r)):
                     if not _filter(_block, val):
                         split_r = r.range_difference((NumericRange(val, val, 0),))
                         if len(split_r) == 2:
                             new_ranges.append(split_r[0])
                             old_ranges.append(split_r[1])
                         elif len(split_r) == 1:
                             if i == 0:
@@ -3200,32 +3243,32 @@
             lambda k, v: [
                 v.isfinite(),  # isinstance(v, _FiniteSetMixin),
                 ', '.join(str(r) for r in self.ranges()) or '[]',
             ],
         )
 
 
-class InfiniteScalarRangeSet(_InfiniteRangeSetData, RangeSet):
+class InfiniteScalarRangeSet(InfiniteRangeSetData, RangeSet):
     def __init__(self, *args, **kwds):
-        _InfiniteRangeSetData.__init__(self, component=self)
+        InfiniteRangeSetData.__init__(self, component=self)
         RangeSet.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     # We want the RangeSet.__str__ to override the one in _FiniteSetMixin
     __str__ = RangeSet.__str__
 
 
 class InfiniteSimpleRangeSet(metaclass=RenamedClass):
     __renamed__new_class__ = InfiniteScalarRangeSet
     __renamed__version__ = '6.0'
 
 
-class FiniteScalarRangeSet(_ScalarOrderedSetMixin, _FiniteRangeSetData, RangeSet):
+class FiniteScalarRangeSet(_ScalarOrderedSetMixin, FiniteRangeSetData, RangeSet):
     def __init__(self, *args, **kwds):
-        _FiniteRangeSetData.__init__(self, component=self)
+        FiniteRangeSetData.__init__(self, component=self)
         RangeSet.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     # We want the RangeSet.__str__ to override the one in _FiniteSetMixin
     __str__ = RangeSet.__str__
 
 
@@ -3255,19 +3298,19 @@
 
 
 ############################################################################
 # Set Operators
 ############################################################################
 
 
-class SetOperator(_SetData, Set):
+class SetOperator(SetData, Set):
     __slots__ = ('_sets',)
 
     def __init__(self, *args, **kwds):
-        _SetData.__init__(self, component=self)
+        SetData.__init__(self, component=self)
         Set.__init__(self, **kwds)
         self._sets, _anonymous = zip(*(process_setarg(_set) for _set in args))
         _anonymous = tuple(filter(None, _anonymous))
         if _anonymous:
             self._anonymous_sets = ComponentSet()
             for _set in _anonymous:
                 self._anonymous_sets.update(_set)
@@ -3443,15 +3486,15 @@
                 "Setting the domain of a Set Operator is not allowed: %s" % val
             )
 
     @staticmethod
     def _checkArgs(*sets):
         ans = []
         for s in sets:
-            if isinstance(s, _SetDataBase):
+            if isinstance(s, SetData):
                 ans.append((s.isordered(), s.isfinite()))
             elif type(s) in {tuple, list}:
                 ans.append((True, True))
             else:
                 ans.append((False, True))
         return ans
 
@@ -4199,17 +4242,17 @@
             ans *= n
         return ans + 1
 
 
 ############################################################################
 
 
-class _AnySet(_SetData, Set):
+class _AnySet(SetData, Set):
     def __init__(self, **kwds):
-        _SetData.__init__(self, component=self)
+        SetData.__init__(self, component=self)
         # There is a chicken-and-egg game here: the SetInitializer uses
         # Any as part of the processing of the domain/within/bounds
         # domain restrictions.  However, Any has not been declared when
         # constructing Any, so we need to bypass that logic.  This
         # works, but requires us to declare a special domain setter to
         # accept (and ignore) this value.
         kwds.setdefault('domain', self)
@@ -4255,17 +4298,17 @@
         "The AnyWithNone set is deprecated.  Use Any, which includes None",
         version='5.7',
     )
     def get(self, val, default=None):
         return super(_AnyWithNoneSet, self).get(val, default)
 
 
-class _EmptySet(_FiniteSetMixin, _SetData, Set):
+class _EmptySet(_FiniteSetMixin, SetData, Set):
     def __init__(self, **kwds):
-        _SetData.__init__(self, component=self)
+        SetData.__init__(self, component=self)
         Set.__init__(self, **kwds)
         self.construct()
 
     def get(self, val, default=None):
         return default
 
     # We need to implement this to override clear from IndexedComponent
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/set_types.py` & `Pyomo-6.7.2/pyomo/core/base/set_types.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/sets.py` & `Pyomo-6.7.2/pyomo/core/base/sets.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 # . confirm that filtering is efficient
 
 from .set import (
     process_setarg,
     set_options,
     simple_set_rule,
     _SetDataBase,
-    _SetData,
+    SetData,
     Set,
     SetOf,
     IndexedSet,
 )
 
 from pyomo.common.deprecation import deprecation_warning
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/sos.py` & `Pyomo-6.7.2/pyomo/core/base/sos.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,15 +24,15 @@
     UnindexedComponent_set,
 )
 from pyomo.core.base.set_types import PositiveIntegers
 
 logger = logging.getLogger('pyomo.core')
 
 
-class _SOSConstraintData(ActiveComponentData):
+class SOSConstraintData(ActiveComponentData):
     """
     This class defines the data for a single special ordered set.
 
     Constructor arguments:
         owner           The Constraint object that owns this data.
 
     Public class attributes:
@@ -97,14 +97,19 @@
             if w < 0.0:
                 raise ValueError(
                     "Cannot set negative weight %f for variable %s" % (w, v.name)
                 )
             self._weights.append(w)
 
 
+class _SOSConstraintData(metaclass=RenamedClass):
+    __renamed__new_class__ = SOSConstraintData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("SOS constraint expressions.")
 class SOSConstraint(ActiveIndexedComponent):
     """
     Implements constraints for special ordered sets (SOS).
 
     Parameters
     ----------
@@ -508,18 +513,18 @@
         timer.report()
 
     def add(self, index, variables, weights=None):
         """
         Add a component data for the specified index.
         """
         if index is None:
-            # because ScalarSOSConstraint already makes an _SOSConstraintData instance
+            # because ScalarSOSConstraint already makes an SOSConstraintData instance
             soscondata = self
         else:
-            soscondata = _SOSConstraintData(self)
+            soscondata = SOSConstraintData(self)
         self._data[index] = soscondata
         soscondata._index = index
 
         soscondata.level = self._sosLevel
 
         if weights is None:
             soscondata.set_items(variables, list(range(1, len(variables) + 1)))
@@ -545,17 +550,17 @@
                 ostream.write("\t" + str(val) + '\n')
             ostream.write("\t\tType=" + str(self._data[val].level) + '\n')
             ostream.write("\t\tWeight : Variable\n")
             for var, weight in self._data[val].get_items():
                 ostream.write("\t\t" + str(weight) + ' : ' + var.name + '\n')
 
 
-class ScalarSOSConstraint(SOSConstraint, _SOSConstraintData):
+class ScalarSOSConstraint(SOSConstraint, SOSConstraintData):
     def __init__(self, *args, **kwd):
-        _SOSConstraintData.__init__(self, self)
+        SOSConstraintData.__init__(self, self)
         SOSConstraint.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
 
 class SimpleSOSConstraint(metaclass=RenamedClass):
     __renamed__new_class__ = ScalarSOSConstraint
     __renamed__version__ = '6.0'
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/suffix.py` & `Pyomo-6.7.2/pyomo/core/base/suffix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/symbol_map.py` & `Pyomo-6.7.2/pyomo/core/base/symbol_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/symbolic.py` & `Pyomo-6.7.2/pyomo/core/base/symbolic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/template_expr.py` & `Pyomo-6.7.2/pyomo/core/base/template_expr.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/transformation.py` & `Pyomo-6.7.2/pyomo/core/base/transformation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/units_container.py` & `Pyomo-6.7.2/pyomo/core/base/units_container.py`

 * *Files 1% similar despite different names*

```diff
@@ -115,23 +115,21 @@
 from pyomo.common.modeling import NOTSET
 from pyomo.core.expr.numvalue import (
     NumericValue,
     nonpyomo_leaf_types,
     value,
     native_types,
     native_numeric_types,
-    pyomo_constant_types,
 )
 from pyomo.core.expr.template_expr import IndexTemplate
 from pyomo.core.expr.visitor import ExpressionValueVisitor
 import pyomo.core.expr as EXPR
 
 pint_module, pint_available = attempt_import(
     'pint',
-    defer_check=True,
     error_message=(
         'The "pint" package failed to import. '
         'This package is necessary to use Pyomo units.'
     ),
 )
 
 logger = logging.getLogger(__name__)
@@ -898,30 +896,30 @@
         walk, result = self.beforeChild(None, expr, 0)
         if not walk:
             result = self.finalizeResult(result)
         return walk, result
 
     def beforeChild(self, node, child, child_idx):
         ctype = child.__class__
-        if ctype in native_types or ctype in pyomo_constant_types:
+        if ctype in native_types:
             return False, self._pint_dimensionless
 
         if child.is_expression_type():
             return True, None
 
         # this is a leaf, but not a native type
         if ctype is _PyomoUnit:
             return False, child._get_pint_unit()
         elif hasattr(child, 'get_units'):
             # might want to add other common types here
             pyomo_unit = child.get_units()
             pint_unit = self._pyomo_units_container._get_pint_units(pyomo_unit)
             return False, pint_unit
 
-        return True, None
+        return False, self._pint_dimensionless
 
     def exitNode(self, node, data):
         """Visitor callback when moving up the expression tree.
 
         Callback for
         :class:`pyomo.core.current.StreamBasedExpressionVisitor`. This
         method is called when moving back up the tree in a depth first
```

### Comparing `Pyomo-6.7.1/pyomo/core/base/util.py` & `Pyomo-6.7.2/pyomo/core/base/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/base/var.py` & `Pyomo-6.7.2/pyomo/core/base/var.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,18 +5,20 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from __future__ import annotations
 import logging
 import sys
 from pyomo.common.pyomo_typing import overload
 from weakref import ref as weakref_ref
+from typing import Union, Type
 
 from pyomo.common.deprecation import RenamedClass
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import NOTSET
 from pyomo.common.timing import ConstructionTimer
 
 from pyomo.core.staleflag import StaleFlagManager
@@ -79,259 +81,29 @@
     'fix',
     'unfix',
     'free',
     'set_value',
     'value',
     'stale',
     'fixed',
+    ('__call__', "access property 'value' on"),
 )
 
 
-class _VarData(ComponentData, NumericValue):
-    """This class defines the abstract interface for a single variable.
-
-    Note that this "abstract" class is not intended to be directly
-    instantiated.
-
-    """
-
-    __slots__ = ()
-
-    #
-    # Interface
-    #
-
-    def has_lb(self):
-        """Returns :const:`False` when the lower bound is
-        :const:`None` or negative infinity"""
-        return self.lb is not None
-
-    def has_ub(self):
-        """Returns :const:`False` when the upper bound is
-        :const:`None` or positive infinity"""
-        return self.ub is not None
-
-    # TODO: deprecate this?  Properties are generally preferred over "set*()"
-    def setlb(self, val):
-        """
-        Set the lower bound for this variable after validating that
-        the value is fixed (or None).
-        """
-        self.lower = val
-
-    # TODO: deprecate this?  Properties are generally preferred over "set*()"
-    def setub(self, val):
-        """
-        Set the upper bound for this variable after validating that
-        the value is fixed (or None).
-        """
-        self.upper = val
-
-    @property
-    def bounds(self):
-        """Returns (or set) the tuple (lower bound, upper bound).
-
-        This returns the current (numeric) values of the lower and upper
-        bounds as a tuple.  If there is no bound, returns None (and not
-        +/-inf)
-
-        """
-        return self.lb, self.ub
-
-    @bounds.setter
-    def bounds(self, val):
-        self.lower, self.upper = val
-
-    @property
-    def lb(self):
-        """Return (or set) the numeric value of the variable lower bound."""
-        lb = value(self.lower)
-        return None if lb == _ninf else lb
-
-    @lb.setter
-    def lb(self, val):
-        self.lower = val
-
-    @property
-    def ub(self):
-        """Return (or set) the numeric value of the variable upper bound."""
-        ub = value(self.upper)
-        return None if ub == _inf else ub
-
-    @ub.setter
-    def ub(self, val):
-        self.upper = val
-
-    def is_integer(self):
-        """Returns True when the domain is a contiguous integer range."""
-        _id = id(self.domain)
-        if _id in _known_global_real_domains:
-            return not _known_global_real_domains[_id]
-        _interval = self.domain.get_interval()
-        if _interval is None:
-            return False
-        # Note: it is not sufficient to just check the step: the
-        # starting / ending points must be integers (or not specified)
-        start, stop, step = _interval
-        return (
-            step == 1
-            and (start is None or int(start) == start)
-            and (stop is None or int(stop) == stop)
-        )
-
-    def is_binary(self):
-        """Returns True when the domain is restricted to Binary values."""
-        domain = self.domain
-        if domain is Binary:
-            return True
-        if id(domain) in _known_global_real_domains:
-            return False
-        return domain.get_interval() == (0, 1, 1)
-
-    def is_continuous(self):
-        """Returns True when the domain is a continuous real range"""
-        _id = id(self.domain)
-        if _id in _known_global_real_domains:
-            return _known_global_real_domains[_id]
-        _interval = self.domain.get_interval()
-        return _interval is not None and _interval[2] == 0
-
-    def is_fixed(self):
-        """Returns True if this variable is fixed, otherwise returns False."""
-        return self.fixed
-
-    def is_constant(self):
-        """Returns False because this is not a constant in an expression."""
-        return False
-
-    def is_variable_type(self):
-        """Returns True because this is a variable."""
-        return True
-
-    def is_potentially_variable(self):
-        """Returns True because this is a variable."""
-        return True
-
-    def _compute_polynomial_degree(self, result):
-        """
-        If the variable is fixed, it represents a constant
-        is a polynomial with degree 0. Otherwise, it has
-        degree 1. This method is used in expressions to
-        compute polynomial degree.
-        """
-        if self.fixed:
-            return 0
-        return 1
-
-    def clear(self):
-        self.value = None
-
-    def __call__(self, exception=True):
-        """Compute the value of this variable."""
-        return self.value
-
-    #
-    # Abstract Interface
-    #
-
-    def set_value(self, val, skip_validation=False):
-        """Set the current variable value."""
-        raise NotImplementedError
-
-    @property
-    def value(self):
-        """Return (or set) the value for this variable."""
-        raise NotImplementedError
-
-    @property
-    def domain(self):
-        """Return (or set) the domain for this variable."""
-        raise NotImplementedError
-
-    @property
-    def lower(self):
-        """Return (or set) an expression for the variable lower bound."""
-        raise NotImplementedError
-
-    @property
-    def upper(self):
-        """Return (or set) an expression for the variable upper bound."""
-        raise NotImplementedError
-
-    @property
-    def fixed(self):
-        """Return (or set) the fixed indicator for this variable.
-
-        Alias for :meth:`is_fixed` / :meth:`fix` / :meth:`unfix`.
-
-        """
-        raise NotImplementedError
-
-    @property
-    def stale(self):
-        """The stale status for this variable.
-
-        Variables are "stale" if their current value was not updated as
-        part of the most recent model update.  A "model update" can be
-        one of several things: a solver invocation, loading a previous
-        solution, or manually updating a non-stale :class:`Var` value.
-
-        Returns
-        -------
-        bool
-
-        Notes
-        -----
-        Fixed :class:`Var` objects will be stale after invoking a solver
-        (as their value was not updated by the solver).
-
-        Updating a stale :class:`Var` value will not cause other
-        variable values to be come stale.  However, updating the first
-        non-stale :class:`Var` value after a solve or solution load
-        *will* cause all other variables to be marked as stale
-
-        """
-        raise NotImplementedError
-
-    def fix(self, value=NOTSET, skip_validation=False):
-        """Fix the value of this variable (treat as nonvariable)
-
-        This sets the :attr:`fixed` indicator to True.  If ``value`` is
-        provided, the value (and the ``skip_validation`` flag) are first
-        passed to :meth:`set_value()`.
-
-        """
-        self.fixed = True
-        if value is not NOTSET:
-            self.set_value(value, skip_validation)
-
-    def unfix(self):
-        """Unfix this variable (treat as variable in solver interfaces)
-
-        This sets the :attr:`fixed` indicator to False.
-
-        """
-        self.fixed = False
-
-    def free(self):
-        """Alias for :meth:`unfix`"""
-        return self.unfix()
-
-
-class _GeneralVarData(_VarData):
+class VarData(ComponentData, NumericValue):
     """This class defines the data for a single variable."""
 
     __slots__ = ('_value', '_lb', '_ub', '_domain', '_fixed', '_stale')
     __autoslot_mappers__ = {'_stale': StaleFlagManager.stale_mapper}
 
     def __init__(self, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _VarData
+        #   - VarData
         #   - ComponentData
         #   - NumericValue
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
         self._value = None
         #
         # The type of the lower and upper bound attributes can either be
@@ -354,18 +126,14 @@
         self._ub = src._ub
         self._domain = src._domain
         self._fixed = src._fixed
         self._stale = src._stale
         self._index = src._index
         return self
 
-    #
-    # Abstract Interface
-    #
-
     def set_value(self, val, skip_validation=False):
         """Set the current variable value.
 
         Set the value of this variable.  The incoming value is converted
         to a numeric value (i.e., expressions are evaluated).  If the
         variable has units, the incoming value is converted to the
         correct units before storing the value.  The final value is
@@ -418,22 +186,28 @@
                 )
 
         self._value = val
         self._stale = StaleFlagManager.get_flag(self._stale)
 
     @property
     def value(self):
+        """Return (or set) the value for this variable."""
         return self._value
 
     @value.setter
     def value(self, val):
         self.set_value(val)
 
+    def __call__(self, exception=True):
+        """Compute the value of this variable."""
+        return self._value
+
     @property
     def domain(self):
+        """Return (or set) the domain for this variable."""
         return self._domain
 
     @domain.setter
     def domain(self, domain):
         try:
             self._domain = SetInitializer(domain)(
                 self.parent_block(), self.index(), self
@@ -442,17 +216,50 @@
             logger.error(
                 "%s is not a valid domain. Variable domains must be an "
                 "instance of a Pyomo Set or convertible to a Pyomo Set." % (domain,),
                 extra={'id': 'E2001'},
             )
             raise
 
-    @_VarData.bounds.getter
+    def has_lb(self):
+        """Returns :const:`False` when the lower bound is
+        :const:`None` or negative infinity"""
+        return self.lb is not None
+
+    def has_ub(self):
+        """Returns :const:`False` when the upper bound is
+        :const:`None` or positive infinity"""
+        return self.ub is not None
+
+    # TODO: deprecate this?  Properties are generally preferred over "set*()"
+    def setlb(self, val):
+        """
+        Set the lower bound for this variable after validating that
+        the value is fixed (or None).
+        """
+        self.lower = val
+
+    # TODO: deprecate this?  Properties are generally preferred over "set*()"
+    def setub(self, val):
+        """
+        Set the upper bound for this variable after validating that
+        the value is fixed (or None).
+        """
+        self.upper = val
+
+    @property
     def bounds(self):
-        # Custom implementation of _VarData.bounds to avoid unnecessary
+        """Returns (or set) the tuple (lower bound, upper bound).
+
+        This returns the current (numeric) values of the lower and upper
+        bounds as a tuple.  If there is no bound, returns None (and not
+        +/-inf)
+
+        """
+        # Custom implementation of lb / ub to avoid unnecessary
         # expression generation and duplicate calls to domain.bounds()
         domain_lb, domain_ub = self.domain.bounds()
         # lb is the tighter of the domain and bounds
         lb = self._lb
         if lb.__class__ not in native_numeric_types:
             if lb is not None:
                 lb = float(value(lb))
@@ -485,18 +292,22 @@
         if domain_ub is not None:
             if ub is None:
                 ub = domain_ub
             else:
                 ub = min(ub, domain_ub)
         return lb, ub
 
-    @_VarData.lb.getter
+    @bounds.setter
+    def bounds(self, val):
+        self.lower, self.upper = val
+
+    @property
     def lb(self):
-        # Custom implementation of _VarData.lb to avoid unnecessary
-        # expression generation
+        """Return (or set) the numeric value of the variable lower bound."""
+        # Note: Implementation avoids unnecessary expression generation
         domain_lb, domain_ub = self.domain.bounds()
         # lb is the tighter of the domain and bounds
         lb = self._lb
         if lb.__class__ not in native_numeric_types:
             if lb is not None:
                 lb = float(value(lb))
         if lb in _nonfinite_values or lb != lb:
@@ -510,18 +321,22 @@
         if domain_lb is not None:
             if lb is None:
                 lb = domain_lb
             else:
                 lb = max(lb, domain_lb)
         return lb
 
-    @_VarData.ub.getter
+    @lb.setter
+    def lb(self, val):
+        self.lower = val
+
+    @property
     def ub(self):
-        # Custom implementation of _VarData.ub to avoid unnecessary
-        # expression generation
+        """Return (or set) the numeric value of the variable upper bound."""
+        # Note: implementation avoids unnecessary expression generation
         domain_lb, domain_ub = self.domain.bounds()
         # ub is the tighter of the domain and bounds
         ub = self._ub
         if ub.__class__ not in native_numeric_types:
             if ub is not None:
                 ub = float(value(ub))
         if ub in _nonfinite_values or ub != ub:
@@ -535,14 +350,18 @@
         if domain_ub is not None:
             if ub is None:
                 ub = domain_ub
             else:
                 ub = min(ub, domain_ub)
         return ub
 
+    @ub.setter
+    def ub(self, val):
+        self.upper = val
+
     @property
     def lower(self):
         """Return (or set) an expression for the variable lower bound.
 
         This returns a (not potentially variable) expression for the
         variable lower bound.  This represents the tighter of the
         current domain and the constant or expression assigned to
@@ -591,38 +410,148 @@
 
     def get_units(self):
         """Return the units for this variable entry."""
         # parent_component() returns self if this is scalar, or the owning
         # component if not scalar
         return self.parent_component()._units
 
+    def fix(self, value=NOTSET, skip_validation=False):
+        """Fix the value of this variable (treat as nonvariable)
+
+        This sets the :attr:`fixed` indicator to True.  If ``value`` is
+        provided, the value (and the ``skip_validation`` flag) are first
+        passed to :meth:`set_value()`.
+
+        """
+        self.fixed = True
+        if value is not NOTSET:
+            self.set_value(value, skip_validation)
+
+    def unfix(self):
+        """Unfix this variable (treat as variable in solver interfaces)
+
+        This sets the :attr:`fixed` indicator to False.
+
+        """
+        self.fixed = False
+
+    def free(self):
+        """Alias for :meth:`unfix`"""
+        return self.unfix()
+
     @property
     def fixed(self):
+        """Return (or set) the fixed indicator for this variable.
+
+        Alias for :meth:`is_fixed` / :meth:`fix` / :meth:`unfix`.
+
+        """
         return self._fixed
 
     @fixed.setter
     def fixed(self, val):
         self._fixed = bool(val)
 
     @property
     def stale(self):
+        """The stale status for this variable.
+
+        Variables are "stale" if their current value was not updated as
+        part of the most recent model update.  A "model update" can be
+        one of several things: a solver invocation, loading a previous
+        solution, or manually updating a non-stale :class:`Var` value.
+
+        Returns
+        -------
+        bool
+
+        Notes
+        -----
+        Fixed :class:`Var` objects will be stale after invoking a solver
+        (as their value was not updated by the solver).
+
+        Updating a stale :class:`Var` value will not cause other
+        variable values to be come stale.  However, updating the first
+        non-stale :class:`Var` value after a solve or solution load
+        *will* cause all other variables to be marked as stale
+
+        """
         return StaleFlagManager.is_stale(self._stale)
 
     @stale.setter
     def stale(self, val):
         if val:
             self._stale = 0  # True
         else:
             self._stale = StaleFlagManager.get_flag(0)
 
-    # Note: override the base class definition to avoid a call through a
-    # property
+    def is_integer(self):
+        """Returns True when the domain is a contiguous integer range."""
+        _id = id(self.domain)
+        if _id in _known_global_real_domains:
+            return not _known_global_real_domains[_id]
+        _interval = self.domain.get_interval()
+        if _interval is None:
+            return False
+        # Note: it is not sufficient to just check the step: the
+        # starting / ending points must be integers (or not specified)
+        start, stop, step = _interval
+        return (
+            step == 1
+            and (start is None or int(start) == start)
+            and (stop is None or int(stop) == stop)
+        )
+
+    def is_binary(self):
+        """Returns True when the domain is restricted to Binary values."""
+        domain = self.domain
+        if domain is Binary:
+            return True
+        if id(domain) in _known_global_real_domains:
+            return False
+        return domain.get_interval() == (0, 1, 1)
+
+    def is_continuous(self):
+        """Returns True when the domain is a continuous real range"""
+        _id = id(self.domain)
+        if _id in _known_global_real_domains:
+            return _known_global_real_domains[_id]
+        _interval = self.domain.get_interval()
+        return _interval is not None and _interval[2] == 0
+
     def is_fixed(self):
+        """Returns True if this variable is fixed, otherwise returns False."""
         return self._fixed
 
+    def is_constant(self):
+        """Returns False because this is not a constant in an expression."""
+        return False
+
+    def is_variable_type(self):
+        """Returns True because this is a variable."""
+        return True
+
+    def is_potentially_variable(self):
+        """Returns True because this is a variable."""
+        return True
+
+    def clear(self):
+        self.value = None
+
+    def _compute_polynomial_degree(self, result):
+        """
+        If the variable is fixed, it represents a constant
+        is a polynomial with degree 0. Otherwise, it has
+        degree 1. This method is used in expressions to
+        compute polynomial degree.
+        """
+        if self._fixed:
+            return 0
+        return 1
+
     def _process_bound(self, val, bound_type):
         if type(val) in native_numeric_types or val is None:
             # TODO: warn/error: check if this Var has units: assigning
             # a dimensionless value to a united variable should be an error
             pass
         elif is_potentially_variable(val):
             raise ValueError(
@@ -637,14 +566,24 @@
             # expected.
             _units = self.parent_component()._units
             if _units is not None:
                 val = units.convert(val, to_units=_units)
         return val
 
 
+class _VarData(metaclass=RenamedClass):
+    __renamed__new_class__ = VarData
+    __renamed__version__ = '6.7.2'
+
+
+class _GeneralVarData(metaclass=RenamedClass):
+    __renamed__new_class__ = VarData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("Decision variables.")
 class Var(IndexedComponent, IndexedComponent_NDArrayMixin):
     """A numeric variable, which may be defined over an index.
 
     Args:
         domain (Set or function, optional): A Set that defines valid
             values for the variable (e.g., ``Reals``, ``NonNegativeReals``,
@@ -662,15 +601,24 @@
             to ``True``.
         units (pyomo units expression, optional): Set the units corresponding
             to the entries in this variable.
         name (str, optional): Name for this component.
         doc (str, optional): Text describing this component.
     """
 
-    _ComponentDataClass = _GeneralVarData
+    _ComponentDataClass = VarData
+
+    @overload
+    def __new__(cls: Type[Var], *args, **kwargs) -> Union[ScalarVar, IndexedVar]: ...
+
+    @overload
+    def __new__(cls: Type[ScalarVar], *args, **kwargs) -> ScalarVar: ...
+
+    @overload
+    def __new__(cls: Type[IndexedVar], *args, **kwargs) -> IndexedVar: ...
 
     def __new__(cls, *args, **kwargs):
         if cls is not Var:
             return super(Var, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return super(Var, cls).__new__(AbstractScalarVar)
         else:
@@ -684,15 +632,15 @@
         within=Reals,
         bounds=None,
         initialize=None,
         rule=None,
         dense=True,
         units=None,
         name=None,
-        doc=None
+        doc=None,
     ): ...
 
     def __init__(self, *args, **kwargs):
         #
         # Default keyword values
         #
         self._rule_init = Initializer(
@@ -760,15 +708,15 @@
     # TODO: deprecate this?  __getitem__ is generally preferable"
     def add(self, index):
         """Add a variable with a particular index."""
         return self[index]
 
     def construct(self, data=None):
         """
-        Construct the _VarData objects for this variable
+        Construct the VarData objects for this variable
         """
         if self._constructed:
             return
         self._constructed = True
 
         timer = ConstructionTimer(self)
         if is_debug_set(logger):
@@ -819,15 +767,15 @@
                 # so and bypass all special-case testing below
                 self._getitem_when_not_present(None)
             elif self._dense:
                 # Special case: initialize every VarData.  For the
                 # initializers that are constant, we can avoid
                 # re-calling (and re-validating) the inputs in certain
                 # cases.  To support this, we will create the first
-                # _VarData and then use it as a template to initialize
+                # VarData and then use it as a template to initialize
                 # (constant portions of) every VarData so as to not
                 # repeat all the domain/bounds validation.
                 try:
                     ref = self._getitem_when_not_present(next(iter(self.index_set())))
                 except StopIteration:
                     # Empty index!
                     return
@@ -937,19 +885,19 @@
                 v.fixed,
                 v.stale,
                 v.domain,
             ],
         )
 
 
-class ScalarVar(_GeneralVarData, Var):
+class ScalarVar(VarData, Var):
     """A single variable."""
 
     def __init__(self, *args, **kwd):
-        _GeneralVarData.__init__(self, component=self)
+        VarData.__init__(self, component=self)
         Var.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
 
 @disable_methods(_VARDATA_API)
 class AbstractScalarVar(ScalarVar):
     pass
@@ -988,15 +936,15 @@
         """
         for vardata in self.values():
             vardata.fix(value, skip_validation)
 
     def unfix(self):
         """Unfix all variables in this :class:`IndexedVar` (treat as variable)
 
-        This sets the :attr:`_VarData.fixed` indicator to False for
+        This sets the :attr:`VarData.fixed` indicator to False for
         every variable in this :class:`IndexedVar`.
 
         """
         for vardata in self.values():
             vardata.unfix()
 
     def free(self):
@@ -1042,15 +990,15 @@
     # GetItemExpression.
     #
     # FIXME: We should integrate this logic into the base implementation
     # of `__getitem__()`, including the recognition / differentiation
     # between potentially variable GetItemExpression objects and
     # "constant" GetItemExpression objects.  That will need to wait for
     # the expression rework [JDS; Nov 22].
-    def __getitem__(self, args):
+    def __getitem__(self, args) -> VarData:
         try:
             return super().__getitem__(args)
         except RuntimeError:
             tmp = args if args.__class__ is tuple else (args,)
             if any(
                 hasattr(arg, 'is_potentially_variable')
                 and arg.is_potentially_variable()
```

### Comparing `Pyomo-6.7.1/pyomo/core/beta/__init__.py` & `Pyomo-6.7.2/pyomo/core/beta/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/beta/dict_objects.py` & `Pyomo-6.7.2/pyomo/core/beta/dict_objects.py`

 * *Files 4% similar despite different names*

```diff
@@ -10,18 +10,18 @@
 #  ___________________________________________________________________________
 
 import logging
 from weakref import ref as weakref_ref
 
 from pyomo.common.log import is_debug_set
 from pyomo.core.base.set_types import Any
-from pyomo.core.base.var import IndexedVar, _VarData
-from pyomo.core.base.constraint import IndexedConstraint, _ConstraintData
-from pyomo.core.base.objective import IndexedObjective, _ObjectiveData
-from pyomo.core.base.expression import IndexedExpression, _ExpressionData
+from pyomo.core.base.var import IndexedVar, VarData
+from pyomo.core.base.constraint import IndexedConstraint, ConstraintData
+from pyomo.core.base.objective import IndexedObjective, ObjectiveData
+from pyomo.core.base.expression import IndexedExpression, ExpressionData
 
 from collections.abc import MutableMapping
 from collections.abc import Mapping
 
 logger = logging.getLogger('pyomo.core')
 
 #
@@ -180,35 +180,35 @@
 
 class VarDict(ComponentDict, IndexedVar):
     def __init__(self, *args, **kwds):
         IndexedVar.__init__(self, Any, **kwds)
         # Constructor for ComponentDict needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentDict.__init__(self, _VarData, *args, **kwds)
+        ComponentDict.__init__(self, VarData, *args, **kwds)
 
 
 class ConstraintDict(ComponentDict, IndexedConstraint):
     def __init__(self, *args, **kwds):
         IndexedConstraint.__init__(self, Any, **kwds)
         # Constructor for ComponentDict needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentDict.__init__(self, _ConstraintData, *args, **kwds)
+        ComponentDict.__init__(self, ConstraintData, *args, **kwds)
 
 
 class ObjectiveDict(ComponentDict, IndexedObjective):
     def __init__(self, *args, **kwds):
         IndexedObjective.__init__(self, Any, **kwds)
         # Constructor for ComponentDict needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentDict.__init__(self, _ObjectiveData, *args, **kwds)
+        ComponentDict.__init__(self, ObjectiveData, *args, **kwds)
 
 
 class ExpressionDict(ComponentDict, IndexedExpression):
     def __init__(self, *args, **kwds):
         IndexedExpression.__init__(self, Any, **kwds)
         # Constructor for ComponentDict needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentDict.__init__(self, _ExpressionData, *args, **kwds)
+        ComponentDict.__init__(self, ExpressionData, *args, **kwds)
```

### Comparing `Pyomo-6.7.1/pyomo/core/beta/list_objects.py` & `Pyomo-6.7.2/pyomo/core/beta/list_objects.py`

 * *Files 6% similar despite different names*

```diff
@@ -10,18 +10,18 @@
 #  ___________________________________________________________________________
 
 import logging
 from weakref import ref as weakref_ref
 
 from pyomo.common.log import is_debug_set
 from pyomo.core.base.set_types import Any
-from pyomo.core.base.var import IndexedVar, _VarData
-from pyomo.core.base.constraint import IndexedConstraint, _ConstraintData
-from pyomo.core.base.objective import IndexedObjective, _ObjectiveData
-from pyomo.core.base.expression import IndexedExpression, _ExpressionData
+from pyomo.core.base.var import IndexedVar, VarData
+from pyomo.core.base.constraint import IndexedConstraint, ConstraintData
+from pyomo.core.base.objective import IndexedObjective, ObjectiveData
+from pyomo.core.base.expression import IndexedExpression, ExpressionData
 
 from collections.abc import MutableSequence
 
 logger = logging.getLogger('pyomo.core')
 
 #
 # In the future I think ComponentDict and ComponentList should inherit
@@ -228,35 +228,35 @@
 
 class XVarList(ComponentList, IndexedVar):
     def __init__(self, *args, **kwds):
         IndexedVar.__init__(self, Any, **kwds)
         # Constructor for ComponentList needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentList.__init__(self, _VarData, *args, **kwds)
+        ComponentList.__init__(self, VarData, *args, **kwds)
 
 
 class XConstraintList(ComponentList, IndexedConstraint):
     def __init__(self, *args, **kwds):
         IndexedConstraint.__init__(self, Any, **kwds)
         # Constructor for ComponentList needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentList.__init__(self, _ConstraintData, *args, **kwds)
+        ComponentList.__init__(self, ConstraintData, *args, **kwds)
 
 
 class XObjectiveList(ComponentList, IndexedObjective):
     def __init__(self, *args, **kwds):
         IndexedObjective.__init__(self, Any, **kwds)
         # Constructor for ComponentList needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentList.__init__(self, _ObjectiveData, *args, **kwds)
+        ComponentList.__init__(self, ObjectiveData, *args, **kwds)
 
 
 class XExpressionList(ComponentList, IndexedExpression):
     def __init__(self, *args, **kwds):
         IndexedExpression.__init__(self, Any, **kwds)
         # Constructor for ComponentList needs to
         # go last in order to handle any initialization
         # iterable as an argument
-        ComponentList.__init__(self, _ExpressionData, *args, **kwds)
+        ComponentList.__init__(self, ExpressionData, *args, **kwds)
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/__init__.py` & `Pyomo-6.7.2/pyomo/core/expr/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/base.py` & `Pyomo-6.7.2/pyomo/core/expr/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -356,15 +356,15 @@
 
         Returns:
             A nonnegative integer that is the number of interior and leaf
             nodes in the expression tree.
         """
         return visitor.sizeof_expression(self)
 
-    def _apply_operation(self, result):  # pragma: no cover
+    def _apply_operation(self, result):
         """
         Compute the values of this node given the values of its children.
 
         This method is called by the :class:`_EvaluationVisitor
         <pyomo.core.expr.current._EvaluationVisitor>` class.  It must
         be over-written by expression classes to customize this logic.
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/boolean_value.py` & `Pyomo-6.7.2/pyomo/core/expr/boolean_value.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/calculus/__init__.py` & `Pyomo-6.7.2/pyomo/core/expr/calculus/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/calculus/derivatives.py` & `Pyomo-6.7.2/pyomo/core/expr/calculus/derivatives.py`

 * *Files 2% similar despite different names*

```diff
@@ -35,19 +35,19 @@
     more variables.  The type of the return value depends on the
     arguments wrt, wrt_list, and mode. See below for details.
 
     Parameters
     ----------
     expr: pyomo.core.expr.numeric_expr.NumericExpression
         The expression to differentiate
-    wrt: pyomo.core.base.var._GeneralVarData
+    wrt: pyomo.core.base.var.VarData
         If specified, this function will return the derivative with
-        respect to wrt. wrt is normally a _GeneralVarData, but could
-        also be a _ParamData. wrt and wrt_list cannot both be specified.
-    wrt_list: list of pyomo.core.base.var._GeneralVarData
+        respect to wrt. wrt is normally a VarData, but could
+        also be a ParamData. wrt and wrt_list cannot both be specified.
+    wrt_list: list of pyomo.core.base.var.VarData
         If specified, this function will return the derivative with
         respect to each element in wrt_list.  A list will be returned
         where the values are the derivatives with respect to the
         corresponding entry in wrt_list.
     mode: pyomo.core.expr.calculus.derivatives.Modes
         Specifies the method to use for differentiation. Should be one
         of the members of the Modes enum:
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/calculus/diff_with_pyomo.py` & `Pyomo-6.7.2/pyomo/core/expr/calculus/diff_with_pyomo.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/calculus/diff_with_sympy.py` & `Pyomo-6.7.2/pyomo/core/expr/calculus/diff_with_sympy.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/cnf_walker.py` & `Pyomo-6.7.2/pyomo/core/expr/cnf_walker.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/compare.py` & `Pyomo-6.7.2/pyomo/core/expr/compare.py`

 * *Files 0% similar despite different names*

```diff
@@ -192,15 +192,15 @@
         expr1, include_named_exprs=include_named_exprs
     )
     pn2 = convert_expression_to_prefix_notation(
         expr2, include_named_exprs=include_named_exprs
     )
     try:
         res = pn1 == pn2
-    except PyomoException:
+    except (PyomoException, AttributeError):
         res = False
     return res
 
 
 def assertExpressionsEqual(test, a, b, include_named_exprs=True, places=None):
     """unittest-based assertion for comparing expressions
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/current.py` & `Pyomo-6.7.2/pyomo/core/expr/current.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/expr_common.py` & `Pyomo-6.7.2/pyomo/core/expr/expr_common.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/expr_errors.py` & `Pyomo-6.7.2/pyomo/core/expr/expr_errors.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/logical_expr.py` & `Pyomo-6.7.2/pyomo/core/expr/logical_expr.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/ndarray.py` & `Pyomo-6.7.2/pyomo/core/expr/ndarray.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/numeric_expr.py` & `Pyomo-6.7.2/pyomo/core/expr/numeric_expr.py`

 * *Files 0% similar despite different names*

```diff
@@ -718,15 +718,15 @@
             tree immutability.
         """
         return self._args_
 
     @deprecated(
         'The implicit recasting of a "not potentially variable" '
         'expression node to a potentially variable one is no '
-        'longer supported (this violates that immutability '
+        'longer supported (this violates the immutability '
         'promise for Pyomo5 expression trees).',
         version='6.4.3',
     )
     def create_potentially_variable_object(self):
         """
         Create a potentially variable version of this object.
 
@@ -1230,17 +1230,19 @@
 SumExpressionBase = SumExpression
 
 
 class LinearExpression(SumExpression):
     """An expression object for linear polynomials.
 
     This is a derived :py:class`SumExpression` that guarantees all
-    arguments are either not potentially variable (e.g., native types,
-    Params, or NPV expressions) OR :py:class:`MonomialTermExpression`
-    objects.
+    arguments are one of the following types:
+
+      - not potentially variable (e.g., native types, Params, or NPV expressions)
+      - :py:class:`MonomialTermExpression`
+      - :py:class:`VarData`
 
     Args:
         args (tuple): Children nodes
 
     """
 
     __slots__ = ()
@@ -1249,15 +1251,15 @@
     _cache = (None, None, None, None)
 
     def __init__(self, args=None, constant=None, linear_coefs=None, linear_vars=None):
         """A linear expression of the form `const + sum_i(c_i*x_i)`.
 
         You can specify `args` OR (`constant`, `linear_coefs`, and
         `linear_vars`).  If `args` is provided, it should be a list that
-        contains only constants, NPV objects/expressions, or
+        contains only constants, NPV objects/expressions, variables, or
         :py:class:`MonomialTermExpression` objects.  Alternatively, you
         can specify the constant, the list of linear_coefs and the list
         of linear_vars separately.  Note that these lists are NOT
         preserved.
 
         """
         # I am not sure why LinearExpression allows omitting args, but
@@ -1294,16 +1296,22 @@
         const = 0
         coef = []
         var = []
         for arg in self.args:
             if arg.__class__ is MonomialTermExpression:
                 coef.append(arg._args_[0])
                 var.append(arg._args_[1])
-            else:
+            elif arg.__class__ in native_numeric_types:
+                const += arg
+            elif not arg.is_potentially_variable():
                 const += arg
+            else:
+                assert arg.is_potentially_variable()
+                coef.append(1)
+                var.append(arg)
         LinearExpression._cache = (self, const, coef, var)
 
     @property
     def constant(self):
         if LinearExpression._cache[0] is not self:
             self._build_cache()
         return LinearExpression._cache[1]
@@ -1321,27 +1329,26 @@
         return LinearExpression._cache[3]
 
     def create_node_with_local_data(self, args, classtype=None):
         if classtype is None:
             classtype = self.__class__
         if type(args) is not list:
             args = list(args)
-        for i, arg in enumerate(args):
+        for arg in args:
             if arg.__class__ in self._allowable_linear_expr_arg_types:
                 # 99% of the time, the arg type hasn't changed
                 continue
             elif arg.__class__ in native_numeric_types:
                 # native numbers are OK (that's part of the constant)
                 pass
             elif not arg.is_potentially_variable():
                 # NPV expressions are OK
                 pass
             elif arg.is_variable_type():
-                # vars are OK, but need to be mapped to monomial terms
-                args[i] = MonomialTermExpression((1, arg))
+                # vars are OK
                 continue
             else:
                 # For anything else, convert this to a general sum
                 classtype = SumExpression
                 break
             # We get here for new types (likely NPV types) --
             # remember them for when they show up again
@@ -1816,15 +1823,15 @@
         return b
     return NPV_SumExpression([a, b])
 
 
 def _add_native_var(a, b):
     if not a:
         return b
-    return LinearExpression([a, MonomialTermExpression((1, b))])
+    return LinearExpression([a, b])
 
 
 def _add_native_monomial(a, b):
     if not a:
         return b
     return LinearExpression([a, b])
 
@@ -1867,15 +1874,15 @@
         b = b.value
         if not b:
             return a
     return NPV_SumExpression([a, b])
 
 
 def _add_npv_var(a, b):
-    return LinearExpression([a, MonomialTermExpression((1, b))])
+    return LinearExpression([a, b])
 
 
 def _add_npv_monomial(a, b):
     return LinearExpression([a, b])
 
 
 def _add_npv_linear(a, b):
@@ -1925,15 +1932,15 @@
 
 
 def _add_param_var(a, b):
     if a.is_constant():
         a = a.value
         if not a:
             return b
-    return LinearExpression([a, MonomialTermExpression((1, b))])
+    return LinearExpression([a, b])
 
 
 def _add_param_monomial(a, b):
     if a.is_constant():
         a = a.value
         if not a:
             return b
@@ -1968,41 +1975,39 @@
 # ADD: VAR handlers
 #
 
 
 def _add_var_native(a, b):
     if not b:
         return a
-    return LinearExpression([MonomialTermExpression((1, a)), b])
+    return LinearExpression([a, b])
 
 
 def _add_var_npv(a, b):
-    return LinearExpression([MonomialTermExpression((1, a)), b])
+    return LinearExpression([a, b])
 
 
 def _add_var_param(a, b):
     if b.is_constant():
         b = b.value
         if not b:
             return a
-    return LinearExpression([MonomialTermExpression((1, a)), b])
+    return LinearExpression([a, b])
 
 
 def _add_var_var(a, b):
-    return LinearExpression(
-        [MonomialTermExpression((1, a)), MonomialTermExpression((1, b))]
-    )
+    return LinearExpression([a, b])
 
 
 def _add_var_monomial(a, b):
-    return LinearExpression([MonomialTermExpression((1, a)), b])
+    return LinearExpression([a, b])
 
 
 def _add_var_linear(a, b):
-    return b._trunc_append(MonomialTermExpression((1, a)))
+    return b._trunc_append(a)
 
 
 def _add_var_sum(a, b):
     return b._trunc_append(a)
 
 
 def _add_var_other(a, b):
@@ -2029,15 +2034,15 @@
         b = b.value
         if not b:
             return a
     return LinearExpression([a, b])
 
 
 def _add_monomial_var(a, b):
-    return LinearExpression([a, MonomialTermExpression((1, b))])
+    return LinearExpression([a, b])
 
 
 def _add_monomial_monomial(a, b):
     return LinearExpression([a, b])
 
 
 def _add_monomial_linear(a, b):
@@ -2072,15 +2077,15 @@
         b = b.value
         if not b:
             return a
     return a._trunc_append(b)
 
 
 def _add_linear_var(a, b):
-    return a._trunc_append(MonomialTermExpression((1, b)))
+    return a._trunc_append(b)
 
 
 def _add_linear_monomial(a, b):
     return a._trunc_append(b)
 
 
 def _add_linear_linear(a, b):
@@ -2279,30 +2284,31 @@
     b = _recast_mutable(b)
     return _iadd_mutablenpvsum_dispatcher[b.__class__](a, b)
 
 
 def _iadd_mutablenpvsum_native(a, b):
     if not b:
         return a
-    a._args_.append(b)
-    a._nargs += 1
+    if a._args_ and a._args_[-1].__class__ in native_numeric_types:
+        a._args_[-1] += b
+    else:
+        a._args_.append(b)
+        a._nargs += 1
     return a
 
 
 def _iadd_mutablenpvsum_npv(a, b):
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablenpvsum_param(a, b):
     if b.is_constant():
-        b = b.value
-        if not b:
-            return a
+        return _iadd_mutablesum_native(a, b.value)
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablenpvsum_var(a, b):
     a.__class__ = _MutableLinearExpression
@@ -2375,37 +2381,38 @@
     b = _recast_mutable(b)
     return _iadd_mutablelinear_dispatcher[b.__class__](a, b)
 
 
 def _iadd_mutablelinear_native(a, b):
     if not b:
         return a
-    a._args_.append(b)
-    a._nargs += 1
+    if a._args_ and a._args_[-1].__class__ in native_numeric_types:
+        a._args_[-1] += b
+    else:
+        a._args_.append(b)
+        a._nargs += 1
     return a
 
 
 def _iadd_mutablelinear_npv(a, b):
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablelinear_param(a, b):
     if b.is_constant():
-        b = b.value
-        if not b:
-            return a
+        return _iadd_mutablesum_native(a, b.value)
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablelinear_var(a, b):
-    a._args_.append(MonomialTermExpression((1, b)))
+    a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablelinear_monomial(a, b):
     a._args_.append(b)
     a._nargs += 1
@@ -2474,30 +2481,31 @@
     b = _recast_mutable(b)
     return _iadd_mutablesum_dispatcher[b.__class__](a, b)
 
 
 def _iadd_mutablesum_native(a, b):
     if not b:
         return a
-    a._args_.append(b)
-    a._nargs += 1
+    if a._args_ and a._args_[-1].__class__ in native_numeric_types:
+        a._args_[-1] += b
+    else:
+        a._args_.append(b)
+        a._nargs += 1
     return a
 
 
 def _iadd_mutablesum_npv(a, b):
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablesum_param(a, b):
     if b.is_constant():
-        b = b.value
-        if not b:
-            return a
+        return _iadd_mutablesum_native(a, b.value)
     a._args_.append(b)
     a._nargs += 1
     return a
 
 
 def _iadd_mutablesum_var(a, b):
     a._args_.append(b)
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/numvalue.py` & `Pyomo-6.7.2/pyomo/core/expr/numvalue.py`

 * *Files 2% similar despite different names*

```diff
@@ -24,15 +24,15 @@
 #   (and not from here)
 from pyomo.common.numeric_types import (
     nonpyomo_leaf_types,
     native_types,
     native_numeric_types,
     native_integer_types,
     native_logical_types,
-    pyomo_constant_types,
+    _pyomo_constant_types,
     check_if_numeric_type,
     value,
 )
 from pyomo.core.pyomoobject import PyomoObject
 
 relocated_module_attribute(
     'native_boolean_types',
@@ -41,14 +41,24 @@
     f_globals=globals(),
     msg="The native_boolean_types set will be removed in the future: the set "
     "contains types that were convertible to bool, and not types that should "
     "be treated as if they were bool (as was the case for the other "
     "native_*_types sets).  Users likely should use native_logical_types.",
 )
 relocated_module_attribute(
+    'pyomo_constant_types',
+    'pyomo.common.numeric_types._pyomo_constant_types',
+    version='6.7.2',
+    f_globals=globals(),
+    msg="The pyomo_constant_types set will be removed in the future: the set "
+    "contained only NumericConstant and _PythonCallbackFunctionID, and provided "
+    "no meaningful value to clients or walkers.  Users should likely handle "
+    "these types in the same manner as immutable Params.",
+)
+relocated_module_attribute(
     'RegisterNumericType',
     'pyomo.common.numeric_types.RegisterNumericType',
     version='6.6.0',
     f_globals=globals(),
 )
 relocated_module_attribute(
     'RegisterIntegerType',
@@ -81,29 +91,32 @@
 ##------------------------------------------------------------------------
 ##
 ## Standard types of expressions
 ##
 ##------------------------------------------------------------------------
 
 
-class NonNumericValue(object):
+class NonNumericValue(PyomoObject):
     """An object that contains a non-numeric value
 
     Constructor Arguments:
         value           The initial value.
     """
 
     __slots__ = ('value',)
 
     def __init__(self, value):
         self.value = value
 
     def __str__(self):
         return str(self.value)
 
+    def __call__(self, exception=None):
+        return self.value
+
 
 nonpyomo_leaf_types.add(NonNumericValue)
 
 
 def is_constant(obj):
     """
     A utility function that returns a boolean that indicates
@@ -406,11 +419,11 @@
 
     def pprint(self, ostream=None, verbose=False):
         if ostream is None:  # pragma:nocover
             ostream = sys.stdout
         ostream.write(str(self))
 
 
-pyomo_constant_types.add(NumericConstant)
+_pyomo_constant_types.add(NumericConstant)
 
 # We use as_numeric() so that the constant is also in the cache
 ZeroConstant = as_numeric(0)
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/relational_expr.py` & `Pyomo-6.7.2/pyomo/core/expr/relational_expr.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/symbol_map.py` & `Pyomo-6.7.2/pyomo/core/expr/symbol_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/sympy_tools.py` & `Pyomo-6.7.2/pyomo/core/expr/sympy_tools.py`

 * *Files 10% similar despite different names*

```diff
@@ -171,18 +171,19 @@
 
 # =====================================================
 # sympyify_expression
 # =====================================================
 
 
 class Pyomo2SympyVisitor(EXPR.StreamBasedExpressionVisitor):
-    def __init__(self, object_map):
+    def __init__(self, object_map, keep_mutable_parameters=False):
         sympy.Add  # this ensures _configure_sympy gets run
         super(Pyomo2SympyVisitor, self).__init__()
         self.object_map = object_map
+        self.keep_mutable_parameters = keep_mutable_parameters
 
     def initializeWalker(self, expr):
         return self.beforeChild(None, expr, None)
 
     def exitNode(self, node, values):
         if node.__class__ is EXPR.UnaryFunctionExpression:
             return _functionMap[node._name](values[0])
@@ -208,14 +209,16 @@
             if child.is_expression_type():
                 return True, None
             else:
                 return False, self.object_map.getSympySymbol(child)
         #
         # Everything else is a constant...
         #
+        if self.keep_mutable_parameters and child.is_parameter_type() and child.mutable:
+            return False, self.object_map.getSympySymbol(child)
         return False, value(child)
 
 
 class Sympy2PyomoVisitor(EXPR.StreamBasedExpressionVisitor):
     def __init__(self, object_map):
         sympy.Add  # this ensures _configure_sympy gets run
         super(Sympy2PyomoVisitor, self).__init__()
@@ -241,20 +244,22 @@
             item = self.object_map.getPyomoSymbol(child, None)
             if item is None:
                 item = float(child.evalf())
             return False, item
         return True, None
 
 
-def sympyify_expression(expr):
+def sympyify_expression(expr, keep_mutable_parameters=False):
     """Convert a Pyomo expression to a Sympy expression"""
     #
     # Create the visitor and call it.
     #
     object_map = PyomoSympyBimap()
-    visitor = Pyomo2SympyVisitor(object_map)
+    visitor = Pyomo2SympyVisitor(
+        object_map, keep_mutable_parameters=keep_mutable_parameters
+    )
     return object_map, visitor.walk_expression(expr)
 
 
 def sympy2pyomo_expression(expr, object_map):
     visitor = Sympy2PyomoVisitor(object_map)
     return visitor.walk_expression(expr)
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/taylor_series.py` & `Pyomo-6.7.2/pyomo/core/expr/taylor_series.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/expr/template_expr.py` & `Pyomo-6.7.2/pyomo/core/expr/template_expr.py`

 * *Files 1% similar despite different names*

```diff
@@ -15,19 +15,20 @@
 import builtins
 from contextlib import nullcontext
 
 from pyomo.common.errors import TemplateExpressionError
 from pyomo.core.expr.base import ExpressionBase, ExpressionArgs_Mixin, NPV_Mixin
 from pyomo.core.expr.logical_expr import BooleanExpression
 from pyomo.core.expr.numeric_expr import (
+    ARG_TYPE,
     NumericExpression,
-    SumExpression,
     Numeric_NPV_Mixin,
+    SumExpression,
+    mutable_expression,
     register_arg_type,
-    ARG_TYPE,
     _balanced_parens,
 )
 from pyomo.core.expr.numvalue import (
     NumericValue,
     native_types,
     nonpyomo_leaf_types,
     as_numeric,
@@ -112,26 +113,18 @@
     def _to_string(self, values, verbose, smap):
         values = tuple(_[1:-1] if _[0] == '(' and _[-1] == ')' else _ for _ in values)
         if verbose:
             return "getitem(%s, %s)" % (values[0], ', '.join(values[1:]))
         return "%s[%s]" % (values[0], ','.join(values[1:]))
 
     def _resolve_template(self, args):
-        return args[0].__getitem__(tuple(args[1:]))
+        return args[0].__getitem__(args[1:])
 
     def _apply_operation(self, result):
-        args = tuple(
-            (
-                arg
-                if arg.__class__ in native_types or not arg.is_numeric_type()
-                else value(arg)
-            )
-            for arg in result[1:]
-        )
-        return result[0].__getitem__(tuple(result[1:]))
+        return result[0].__getitem__(result[1:])
 
 
 class Numeric_GetItemExpression(GetItemExpression, NumericExpression):
     __slots__ = ()
 
     def nargs(self):
         return len(self._args_)
@@ -254,30 +247,30 @@
     def getname(self, *args, **kwds):
         return 'getattr'
 
     def nargs(self):
         return 2
 
     def _apply_operation(self, result):
-        assert len(result) == 2
-        return getattr(result[0], result[1])
+        obj, attr = result
+        return getattr(obj, attr)
 
     def _to_string(self, values, verbose, smap):
         assert len(values) == 2
         if verbose:
             return "getattr(%s, %s)" % tuple(values)
         # Note that the string argument for getattr comes quoted, so we
         # need to remove the quotes.
         attr = values[1]
         if attr[0] in '\"\'' and attr[0] == attr[-1]:
             attr = attr[1:-1]
         return "%s.%s" % (values[0], attr)
 
     def _resolve_template(self, args):
-        return getattr(*tuple(args))
+        return getattr(*args)
 
 
 class Numeric_GetAttrExpression(GetAttrExpression, NumericExpression):
     __slots__ = ()
 
     def _compute_polynomial_degree(self, result):
         if result[1] != 0:
@@ -517,15 +510,23 @@
             iterStr = ', '.join('iter(%s, %s)' % x for x in iterStrGenerator)
             return 'templatesum(%s, %s)' % (val, iterStr)
         else:
             iterStr = ' '.join('for %s in %s' % x for x in iterStrGenerator)
             return 'SUM(%s %s)' % (val, iterStr)
 
     def _resolve_template(self, args):
-        return SumExpression(args)
+        with mutable_expression() as e:
+            for arg in args:
+                e += arg
+        if e.nargs() > 1:
+            return e
+        elif not e.nargs():
+            return 0
+        else:
+            return e.arg(0)
 
 
 class IndexTemplate(NumericValue):
     """A "placeholder" for an index value in template expressions.
 
     This class is a placeholder for an index value within a template
     expression.  That is, given the expression template for "m.x[i]",
```

### Comparing `Pyomo-6.7.1/pyomo/core/expr/visitor.py` & `Pyomo-6.7.2/pyomo/core/expr/visitor.py`

 * *Files 10% similar despite different names*

```diff
@@ -1369,59 +1369,153 @@
 
 
 # =====================================================
 #  identify_variables
 # =====================================================
 
 
-class _VariableVisitor(SimpleExpressionVisitor):
-    def __init__(self):
-        self.seen = set()
-
-    def visit(self, node):
-        if node.__class__ in nonpyomo_leaf_types:
-            return
-
-        if node.is_variable_type():
-            if id(node) in self.seen:
-                return
-            self.seen.add(id(node))
-            return node
+class _VariableVisitor(StreamBasedExpressionVisitor):
+    def __init__(self, include_fixed=False, named_expression_cache=None):
+        """Visitor that collects all unique variables participating in an
+        expression
+
+        Args:
+            include_fixed (bool): Whether to include fixed variables
+            named_expression_cache (optional, dict): Dict mapping ids of named
+                expressions to a tuple of the list of all variables and the
+                set of all variable ids contained in the named expression.
+
+        """
+        super().__init__()
+        self._include_fixed = include_fixed
+        if named_expression_cache is None:
+            # This cache will map named expression ids to the
+            # tuple: ([variables], {variable ids})
+            named_expression_cache = {}
+        self._named_expression_cache = named_expression_cache
+        # Stack of active named expressions. This holds the id of
+        # expressions we are currently in.
+        self._active_named_expressions = []
+
+    def initializeWalker(self, expr):
+        if expr.__class__ in native_types:
+            return False, []
+        elif expr.is_named_expression_type():
+            eid = id(expr)
+            if eid in self._named_expression_cache:
+                # If we were given a named expression that is already cached,
+                # just do nothing and return the expression's variables
+                variables, var_set = self._named_expression_cache[eid]
+                return False, variables
+            else:
+                # We were given a named expression that is not cached.
+                # Initialize data structures and add this expression to the
+                # stack. This expression will get popped in exitNode.
+                self._variables = []
+                self._seen = set()
+                self._named_expression_cache[eid] = [], set()
+                self._active_named_expressions.append(eid)
+                return True, expr
+        elif expr.is_variable_type():
+            return False, [expr]
+        else:
+            self._variables = []
+            self._seen = set()
+            return True, expr
+
+    def beforeChild(self, parent, child, index):
+        if child.__class__ in native_types:
+            return False, None
+        elif child.is_named_expression_type():
+            eid = id(child)
+            if eid in self._named_expression_cache:
+                # We have already encountered this named expression. We just add
+                # the cached variables to our list and don't descend.
+                if self._active_named_expressions:
+                    # If we are in another named expression, we update the
+                    # parent expression's cache. We don't need to update the
+                    # global list as we will do this when we exit the active
+                    # named expression.
+                    parent_eid = self._active_named_expressions[-1]
+                    variables, var_set = self._named_expression_cache[parent_eid]
+                else:
+                    # If we are not in a named expression, we update the global
+                    # list.
+                    variables = self._variables
+                    var_set = self._seen
+                for var in self._named_expression_cache[eid][0]:
+                    if id(var) not in var_set:
+                        var_set.add(id(var))
+                        variables.append(var)
+                return False, None
+            else:
+                # If we are descending into a new named expression, initialize
+                # a cache to store the expression's local variables.
+                self._named_expression_cache[id(child)] = ([], set())
+                self._active_named_expressions.append(id(child))
+                return True, None
+        elif child.is_variable_type() and (self._include_fixed or not child.fixed):
+            if self._active_named_expressions:
+                # If we are in a named expression, add new variables to the cache.
+                eid = self._active_named_expressions[-1]
+                variables, var_set = self._named_expression_cache[eid]
+            else:
+                variables = self._variables
+                var_set = self._seen
+            if id(child) not in var_set:
+                var_set.add(id(child))
+                variables.append(child)
+            return False, None
+        else:
+            return True, None
+
+    def exitNode(self, node, data):
+        if node.is_named_expression_type():
+            # If we are returning from a named expression, we have at least one
+            # active named expression. We must make sure that we properly
+            # handle the variables for the named expression we just exited.
+            eid = self._active_named_expressions.pop()
+            if self._active_named_expressions:
+                # If we still are in a named expression, we update that expression's
+                # cache with any new variables encountered.
+                parent_eid = self._active_named_expressions[-1]
+                variables, var_set = self._named_expression_cache[parent_eid]
+            else:
+                variables = self._variables
+                var_set = self._seen
+            for var in self._named_expression_cache[eid][0]:
+                if id(var) not in var_set:
+                    var_set.add(id(var))
+                    variables.append(var)
 
+    def finalizeResult(self, result):
+        return self._variables
 
-def identify_variables(expr, include_fixed=True):
+
+def identify_variables(expr, include_fixed=True, named_expression_cache=None):
     """
     A generator that yields a sequence of variables
     in an expression tree.
 
     Args:
         expr: The root node of an expression tree.
         include_fixed (bool): If :const:`True`, then
             this generator will yield variables whose
             value is fixed.  Defaults to :const:`True`.
 
     Yields:
         Each variable that is found.
     """
-    visitor = _VariableVisitor()
-    if include_fixed:
-        for v in visitor.xbfs_yield_leaves(expr):
-            if isinstance(v, tuple):
-                yield from v
-            else:
-                yield v
-    else:
-        for v in visitor.xbfs_yield_leaves(expr):
-            if isinstance(v, tuple):
-                for v_i in v:
-                    if not v_i.is_fixed():
-                        yield v_i
-            else:
-                if not v.is_fixed():
-                    yield v
+    if named_expression_cache is None:
+        named_expression_cache = {}
+    visitor = _VariableVisitor(
+        named_expression_cache=named_expression_cache, include_fixed=include_fixed
+    )
+    variables = visitor.walk_expression(expr)
+    yield from variables
 
 
 # =====================================================
 #  identify_mutable_parameters
 # =====================================================
```

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/__init__.py` & `Pyomo-6.7.2/pyomo/core/kernel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/base.py` & `Pyomo-6.7.2/pyomo/core/kernel/base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/block.py` & `Pyomo-6.7.2/pyomo/core/kernel/block.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/component_map.py` & `Pyomo-6.7.2/pyomo/core/kernel/component_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/conic.py` & `Pyomo-6.7.2/pyomo/core/kernel/conic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/constraint.py` & `Pyomo-6.7.2/pyomo/core/kernel/constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/container_utils.py` & `Pyomo-6.7.2/pyomo/core/kernel/container_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/dict_container.py` & `Pyomo-6.7.2/pyomo/core/kernel/dict_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/expression.py` & `Pyomo-6.7.2/pyomo/core/kernel/expression.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/heterogeneous_container.py` & `Pyomo-6.7.2/pyomo/core/kernel/heterogeneous_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/homogeneous_container.py` & `Pyomo-6.7.2/pyomo/core/kernel/homogeneous_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/list_container.py` & `Pyomo-6.7.2/pyomo/core/kernel/list_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/matrix_constraint.py` & `Pyomo-6.7.2/pyomo/core/kernel/matrix_constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/objective.py` & `Pyomo-6.7.2/pyomo/core/kernel/objective.py`

 * *Files 25% similar despite different names*

```diff
@@ -5,23 +5,20 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
+from pyomo.common.enums import ObjectiveSense, minimize, maximize
 from pyomo.core.expr.numvalue import as_numeric
 from pyomo.core.kernel.base import _abstract_readwrite_property
 from pyomo.core.kernel.container_utils import define_simple_containers
 from pyomo.core.kernel.expression import IExpression
 
-# Constants used to define the optimization sense
-minimize = 1
-maximize = -1
-
 
 class IObjective(IExpression):
     """
     The interface for optimization objectives.
     """
 
     __slots__ = ()
@@ -80,20 +77,13 @@
     @property
     def sense(self):
         return self._sense
 
     @sense.setter
     def sense(self, sense):
         """Set the sense (direction) of this objective."""
-        if (sense == minimize) or (sense == maximize):
-            self._sense = sense
-        else:
-            raise ValueError(
-                "Objective sense must be set to one of: "
-                "[minimize (%s), maximize (%s)]. Invalid "
-                "value: %s'" % (minimize, maximize, sense)
-            )
+        self._sense = ObjectiveSense(sense)
 
 
 # inserts class definitions for simple _tuple, _list, and
 # _dict containers into this module
 define_simple_containers(globals(), "objective", IObjective)
```

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/parameter.py` & `Pyomo-6.7.2/pyomo/core/kernel/parameter.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/__init__.py` & `Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/transforms.py` & `Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/transforms.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/transforms_nd.py` & `Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/transforms_nd.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/piecewise_library/util.py` & `Pyomo-6.7.2/pyomo/core/kernel/piecewise_library/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/register_numpy_types.py` & `Pyomo-6.7.2/pyomo/core/kernel/register_numpy_types.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/set_types.py` & `Pyomo-6.7.2/pyomo/core/kernel/set_types.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/sos.py` & `Pyomo-6.7.2/pyomo/core/kernel/sos.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/suffix.py` & `Pyomo-6.7.2/pyomo/core/kernel/suffix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/tuple_container.py` & `Pyomo-6.7.2/pyomo/core/kernel/tuple_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/kernel/variable.py` & `Pyomo-6.7.2/pyomo/core/kernel/variable.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/core/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/__init__.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/add_slack_vars.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/add_slack_vars.py`

 * *Files 6% similar despite different names*

```diff
@@ -19,15 +19,14 @@
     value,
 )
 
 from pyomo.common.modeling import unique_component_name
 from pyomo.core.plugins.transform.hierarchy import NonIsomorphicTransformation
 from pyomo.common.config import ConfigBlock, ConfigValue
 from pyomo.core.base import ComponentUID
-from pyomo.core.base.constraint import _ConstraintData
 from pyomo.common.deprecation import deprecation_warning
 
 
 def target_list(x):
     deprecation_msg = (
         "In future releases ComponentUID targets will no "
         "longer be supported in the core.add_slack_variables "
@@ -38,26 +37,26 @@
         if deprecation_msg:
             deprecation_warning(deprecation_msg, version='5.7.1')
             # only emit the message once
             deprecation_msg = None
         # [ESJ 07/15/2020] We have to just pass it through because we need the
         # instance in order to be able to do anything about it...
         return [x]
-    elif isinstance(x, (Constraint, _ConstraintData)):
+    elif getattr(x, 'ctype', None) is Constraint:
         return [x]
     elif hasattr(x, '__iter__'):
         ans = []
         for i in x:
             if isinstance(i, ComponentUID):
                 if deprecation_msg:
                     deprecation_warning(deprecation_msg, version='5.7.1')
                     deprecation_msg = None
                 # same as above...
                 ans.append(i)
-            elif isinstance(i, (Constraint, _ConstraintData)):
+            elif getattr(i, 'ctype', None) is Constraint:
                 ans.append(i)
             else:
                 raise ValueError(
                     "Expected Constraint or list of Constraints."
                     "\n\tReceived %s" % (type(i),)
                 )
         return ans
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/discrete_vars.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/discrete_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/eliminate_fixed_vars.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/eliminate_fixed_vars.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.core.expr import ExpressionBase, as_numeric
 from pyomo.core import Constraint, Objective, TransformationFactory
-from pyomo.core.base.var import Var, _VarData
+from pyomo.core.base.var import Var, VarData
 from pyomo.core.util import sequence
 from pyomo.core.plugins.transform.hierarchy import IsomorphicTransformation
 
 
 @TransformationFactory.register(
     'core.remove_fixed_vars',
     doc="Create an equivalent model that omits all fixed variables.",
@@ -73,15 +73,15 @@
         if expr._args is None:
             return expr
         _args = []
         for i in range(len(expr._args)):
             if isinstance(expr._args[i], ExpressionBase):
                 _args.append(self._fix_vars(expr._args[i], model))
             elif (
-                isinstance(expr._args[i], Var) or isinstance(expr._args[i], _VarData)
+                isinstance(expr._args[i], Var) or isinstance(expr._args[i], VarData)
             ) and expr._args[i].fixed:
                 if expr._args[i].value != 0.0:
                     _args.append(as_numeric(expr._args[i].value))
             else:
                 _args.append(expr._args[i])
         expr._args = _args
         return expr
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/equality_transform.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/equality_transform.py`

 * *Files 4% similar despite different names*

```diff
@@ -62,15 +62,15 @@
         #
         # Fix all Constraint objects
         #
         for con_name in components["Constraint"]:
             con = equality.__getattribute__(con_name)
 
             #
-            # Get all _ConstraintData objects
+            # Get all ConstraintData objects
             #
             # We need to get the keys ahead of time because we are modifying
             # con._data on-the-fly.
             #
             indices = con._data.keys()
             for ndx, cdata in [(ndx, con._data[ndx]) for ndx in indices]:
                 qualified_con_name = create_name(con_name, ndx)
@@ -100,11 +100,11 @@
                     # Make a new upper bound constraint
                     ub_name = "%s_%s" % (create_name("", ndx), ub_suffix)
                     slack = equality.__getattribute__(slack_name)
                     new_expr = cdata.upper == cdata.body + slack
                     con.add(ub_name, new_expr)
 
                 # Since we explicitly `continue` for equality constraints, we
-                # can safely remove the old _ConstraintData object
+                # can safely remove the old ConstraintData object
                 del con._data[ndx]
 
         return equality.create()
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/expand_connectors.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/expand_connectors.py`

 * *Files 0% similar despite different names*

```diff
@@ -21,15 +21,15 @@
     TransformationFactory,
     Connector,
     Constraint,
     ConstraintList,
     Var,
     SortComponents,
 )
-from pyomo.core.base.connector import _ConnectorData, ScalarConnector
+from pyomo.core.base.connector import ConnectorData, ScalarConnector
 
 
 @TransformationFactory.register(
     'core.expand_connectors',
     doc="Expand all connectors in the model to simple constraints",
 )
 class ExpandConnectors(Transformation):
@@ -65,15 +65,15 @@
         # If you sort by the groupID, then this will be deterministic.
         connector_groups = dict()
         # map of connector to the set of connectors that must match it
         matched_connectors = ComponentMap()
         # The set of connectors found in the current constraint
         found = ComponentSet()
 
-        connector_types = set([ScalarConnector, _ConnectorData])
+        connector_types = set([ScalarConnector, ConnectorData])
         for constraint in instance.component_data_objects(
             Constraint, sort=SortComponents.deterministic
         ):
             ref = None
             for c in EXPR.identify_components(constraint.body, connector_types):
                 found.add(c)
                 if c in matched_connectors:
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/hierarchy.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/hierarchy.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/logical_to_linear.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/logical_to_linear.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,15 +25,15 @@
     LogicalConstraint,
     Block,
     ConstraintList,
     native_types,
     BooleanVarList,
     SortComponents,
 )
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base.boolean_var import _DeprecatedImplicitAssociatedBinaryVariable
 from pyomo.core.expr.cnf_walker import to_cnf
 from pyomo.core.expr import (
     AndExpression,
     OrExpression,
     NotExpression,
     AtLeastExpression,
@@ -96,15 +96,15 @@
             # transformation is a promise only to transform LogicalConstraints
             # and the relevant BooleanVars, not to create an algebraic
             # model. (We are making this decision largely because having this
             # transformation do anything to GDP stuff is an assumption on how
             # the GDP will be solved, and it would be wrong to assume that a GDP
             # will *necessarily* be solved as an algebraic model. The star
             # example of not doing so being GDPopt.)
-            if t.ctype is Block or isinstance(t, _BlockData):
+            if t.ctype is Block or isinstance(t, BlockData):
                 self._transform_block(t, model, new_var_lists, transBlocks)
             elif t.ctype is LogicalConstraint:
                 if t.is_indexed():
                     self._transform_constraint(t, new_var_lists, transBlocks)
                 else:
                     self._transform_constraintData(t, new_var_lists, transBlocks)
             else:
@@ -281,15 +281,15 @@
 _numeric_relational_types = {InequalityExpression, EqualityExpression, RangedExpression}
 
 
 class CnfToLinearVisitor(StreamBasedExpressionVisitor):
     """Convert CNF logical constraint to linear constraints.
 
     Expected expression node types: AndExpression, OrExpression, NotExpression,
-    AtLeastExpression, AtMostExpression, ExactlyExpression, _BooleanVarData
+    AtLeastExpression, AtMostExpression, ExactlyExpression, BooleanVarData
 
     """
 
     def __init__(self, indicator_var, binary_varlist):
         super(CnfToLinearVisitor, self).__init__()
         self._indicator = indicator_var
         self._binary_varlist = binary_varlist
@@ -368,15 +368,15 @@
             return False, int(child)
         if type(child) in native_types:
             return False, child
 
         if child.is_expression_type():
             return True, None
 
-        # Only thing left should be _BooleanVarData
+        # Only thing left should be BooleanVarData
         #
         # TODO: After the expr_multiple_dispatch is merged, this should
         # be switched to using as_numeric.
         if hasattr(child, 'get_associated_binary'):
             return False, child.get_associated_binary()
         else:
             return False, child
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/model.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/model.py`

 * *Files 1% similar despite different names*

```diff
@@ -51,16 +51,16 @@
 
     # First we go through the constraints and introduce slack and excess
     # variables to eliminate inequality constraints
     #
     # N.B. Structure hierarchy:
     #
     # active_components: {class: {attr_name: object}}
-    # object -> Constraint: ._data: {ndx: _ConstraintData}
-    # _ConstraintData: .lower, .body, .upper
+    # object -> Constraint: ._data: {ndx: ConstraintData}
+    # ConstraintData: .lower, .body, .upper
     #
     # So, altogether, we access a lower bound via
     #
     # model.component_map(active=True)[Constraint]['con_name']['index'].lower
     #
     # {le,ge,eq}Constraints are
     # {constraint_name: {index: {variable_or_none: coefficient}} objects
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/nonnegative_transform.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/nonnegative_transform.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/radix_linearization.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/radix_linearization.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     TransformationFactory,
     Var,
     Constraint,
     ConstraintList,
     Block,
     RangeSet,
 )
-from pyomo.core.base.var import _VarData
+from pyomo.core.base.var import VarData
 
 import logging
 
 logger = logging.getLogger(__name__)
 
 
 @TransformationFactory.register(
@@ -264,16 +264,16 @@
             return
         if type(expr) is ProductExpression:
             if len(expr._numerator) != 2:
                 for e in expr._numerator:
                     self._collect_bilinear(e, bilin, quad)
                 # No need to check denominator, as this is poly_degree==2
                 return
-            if not isinstance(expr._numerator[0], _VarData) or not isinstance(
-                expr._numerator[1], _VarData
+            if not isinstance(expr._numerator[0], VarData) or not isinstance(
+                expr._numerator[1], VarData
             ):
                 raise RuntimeError("Cannot yet handle complex subexpressions")
             if expr._numerator[0] is expr._numerator[1]:
                 quad.append((expr, expr._numerator[0]))
             else:
                 bilin.append((expr, expr._numerator[0], expr._numerator[1]))
             return
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/relax_integrality.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/relax_integrality.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/scaling.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/scaling.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,24 +6,15 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.collections import ComponentMap
-from pyomo.core.base import (
-    Block,
-    Var,
-    Constraint,
-    Objective,
-    _ConstraintData,
-    _ObjectiveData,
-    Suffix,
-    value,
-)
+from pyomo.core.base import Block, Var, Constraint, Objective, Suffix, value
 from pyomo.core.plugins.transform.hierarchy import Transformation
 from pyomo.core.base import TransformationFactory
 from pyomo.core.base.suffix import SuffixFinder
 from pyomo.core.expr import replace_expressions
 from pyomo.util.components import rename_components
 
 
@@ -193,15 +184,15 @@
             for k in component:
                 c = component[k]
                 if id(c) in already_scaled:
                     continue
                 already_scaled.add(id(c))
                 # perform the constraint/objective scaling and variable sub
                 scaling_factor = component_scaling_factor_map[c]
-                if isinstance(c, _ConstraintData):
+                if c.ctype is Constraint:
                     body = scaling_factor * replace_expressions(
                         expr=c.body,
                         substitution_map=variable_substitution_dict,
                         descend_into_named_expressions=True,
                         remove_named_expressions=True,
                     )
 
@@ -222,15 +213,15 @@
                             model.dual[c] = dual_value / scaling_factor
 
                     if c.equality:
                         c.set_value((lower, body))
                     else:
                         c.set_value((lower, body, upper))
 
-                elif isinstance(c, _ObjectiveData):
+                elif c.ctype is Objective:
                     c.expr = scaling_factor * replace_expressions(
                         expr=c.expr,
                         substitution_map=variable_substitution_dict,
                         descend_into_named_expressions=True,
                         remove_named_expressions=True,
                     )
                 else:
```

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/standard_form.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/standard_form.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/plugins/transform/util.py` & `Pyomo-6.7.2/pyomo/core/plugins/transform/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/pyomoobject.py` & `Pyomo-6.7.2/pyomo/core/pyomoobject.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/staleflag.py` & `Pyomo-6.7.2/pyomo/core/staleflag.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/data/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/data/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/data/test_odbc_ini.py` & `Pyomo-6.7.2/pyomo/core/tests/data/test_odbc_ini.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/diet/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/diet/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/diet/test_diet.py` & `Pyomo-6.7.2/pyomo/core/tests/diet/test_diet.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/pmedian.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/pmedian.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/pmedian1.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/pmedian1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/pmedian2.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/pmedian2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/pmedian4.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/pmedian4.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/test_amplbook2.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/test_amplbook2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/test_kernel_examples.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/test_kernel_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/test_pyomo.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/test_pyomo.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/examples/test_tutorials.py` & `Pyomo-6.7.2/pyomo/core/tests/examples/test_tutorials.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/transform/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/transform/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/transform/test_add_slacks.py` & `Pyomo-6.7.2/pyomo/core/tests/transform/test_add_slacks.py`

 * *Files 10% similar despite different names*

```diff
@@ -98,38 +98,28 @@
 
         self.assertIsNone(cons.lower)
         self.assertEqual(cons.upper, 5)
         assertExpressionsEqual(
             self,
             cons.body,
             EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, m.x)),
-                    EXPR.MonomialTermExpression((-1, transBlock._slack_minus_rule1)),
-                ]
+                [m.x, EXPR.MonomialTermExpression((-1, transBlock._slack_minus_rule1))]
             ),
         )
 
     def checkRule3(self, m):
         # check all original variables still there:
         cons = m.rule3
         transBlock = m.component("_core_add_slack_variables")
 
         self.assertIsNone(cons.upper)
         self.assertEqual(cons.lower, 0.1)
 
         assertExpressionsEqual(
-            self,
-            cons.body,
-            EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, m.x)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule3)),
-                ]
-            ),
+            self, cons.body, EXPR.LinearExpression([m.x, transBlock._slack_plus_rule3])
         )
 
     def test_ub_constraint_modified(self):
         m = self.makeModel()
         TransformationFactory('core.add_slack_variables').apply_to(m)
         self.checkRule1(m)
 
@@ -150,16 +140,16 @@
         self.assertEqual(cons.upper, 3)
 
         assertExpressionsEqual(
             self,
             cons.body,
             EXPR.LinearExpression(
                 [
-                    EXPR.MonomialTermExpression((1, m.y)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule2)),
+                    m.y,
+                    transBlock._slack_plus_rule2,
                     EXPR.MonomialTermExpression((-1, transBlock._slack_minus_rule2)),
                 ]
             ),
         )
 
     def test_obj_deactivated(self):
         m = self.makeModel()
@@ -180,18 +170,18 @@
         self.assertTrue(obj.active)
 
         assertExpressionsEqual(
             self,
             obj.expr,
             EXPR.LinearExpression(
                 [
-                    EXPR.MonomialTermExpression((1, transBlock._slack_minus_rule1)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule2)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_minus_rule2)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule3)),
+                    transBlock._slack_minus_rule1,
+                    transBlock._slack_plus_rule2,
+                    transBlock._slack_minus_rule2,
+                    transBlock._slack_plus_rule3,
                 ]
             ),
         )
 
     def test_badModel_err(self):
         model = ConcreteModel()
         model.x = Var(within=NonNegativeReals)
@@ -298,18 +288,15 @@
     def checkTargetsObj(self, m):
         transBlock = m._core_add_slack_variables
         obj = transBlock.component("_slack_objective")
         assertExpressionsEqual(
             self,
             obj.expr,
             EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, transBlock._slack_minus_rule1)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule3)),
-                ]
+                [transBlock._slack_minus_rule1, transBlock._slack_plus_rule3]
             ),
         )
 
     def test_target_objective(self):
         m = self.makeModel()
         TransformationFactory('core.add_slack_variables').apply_to(
             m, targets=[m.rule1, m.rule3]
@@ -339,15 +326,15 @@
 
     def test_error_for_non_constraint_noniterable_target(self):
         m = self.makeModel()
         m.indexedVar = Var([1, 2])
         self.assertRaisesRegex(
             ValueError,
             "Expected Constraint or list of Constraints.\n\tReceived "
-            "<class 'pyomo.core.base.var._GeneralVarData'>",
+            "<class 'pyomo.core.base.var.VarData'>",
             TransformationFactory('core.add_slack_variables').apply_to,
             m,
             targets=m.indexedVar[1],
         )
 
     def test_error_for_non_constraint_target_in_list(self):
         m = self.makeModel()
@@ -419,17 +406,17 @@
         self.assertEqual(c.upper, 9)
 
         assertExpressionsEqual(
             self,
             c.body,
             EXPR.LinearExpression(
                 [
-                    EXPR.MonomialTermExpression((1, m.x)),
+                    m.x,
                     EXPR.MonomialTermExpression((-2, m.y)),
-                    EXPR.MonomialTermExpression((1, transBlock._slack_plus_rule4)),
+                    transBlock._slack_plus_rule4,
                     EXPR.MonomialTermExpression((-1, transBlock._slack_minus_rule4)),
                 ]
             ),
         )
 
     def test_transformed_constraint_scalar_body(self):
         m = self.makeModel()
@@ -514,23 +501,17 @@
         obj = transBlock.component("_slack_objective")
         self.assertIsInstance(obj, Objective)
         assertExpressionsEqual(
             self,
             obj.expr,
             EXPR.LinearExpression(
                 [
-                    EXPR.MonomialTermExpression(
-                        (1, transBlock.component("_slack_plus_rule1[1]"))
-                    ),
-                    EXPR.MonomialTermExpression(
-                        (1, transBlock.component("_slack_plus_rule1[2]"))
-                    ),
-                    EXPR.MonomialTermExpression(
-                        (1, transBlock.component("_slack_plus_rule1[3]"))
-                    ),
+                    transBlock.component("_slack_plus_rule1[1]"),
+                    transBlock.component("_slack_plus_rule1[2]"),
+                    transBlock.component("_slack_plus_rule1[3]"),
                 ]
             ),
         )
 
     def test_indexedtarget_objective(self):
         m = self.makeModel()
         TransformationFactory('core.add_slack_variables').apply_to(m, targets=[m.rule1])
@@ -554,22 +535,15 @@
 
         assertExpressionsEqual(
             self,
             c.body,
             EXPR.LinearExpression(
                 [
                     EXPR.MonomialTermExpression((2, m.x[i])),
-                    EXPR.MonomialTermExpression(
-                        (
-                            1,
-                            m._core_add_slack_variables.component(
-                                "_slack_plus_rule1[%s]" % i
-                            ),
-                        )
-                    ),
+                    m._core_add_slack_variables.component("_slack_plus_rule1[%s]" % i),
                 ]
             ),
         )
 
     def test_indexedtarget_targets_transformed(self):
         m = self.makeModel()
         TransformationFactory('core.add_slack_variables').apply_to(m, targets=[m.rule1])
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/transform/test_scaling.py` & `Pyomo-6.7.2/pyomo/core/tests/transform/test_scaling.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/transform/test_transform.py` & `Pyomo-6.7.2/pyomo/core/tests/transform/test_transform.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/__init__.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_block.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_block.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_component_map.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_component_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_component_set.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_component_set.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_conic.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_conic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_constraint.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_dict_container.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_dict_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_expression.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_expression.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_kernel.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_kernel.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_list_container.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_list_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_matrix_constraint.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_matrix_constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_objective.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_objective.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_parameter.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_labelers.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,321 +5,240 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-import pickle
 
 import pyomo.common.unittest as unittest
-
-from pyomo.common.dependencies import dill, dill_available as has_dill
-from pyomo.core.expr.numvalue import (
-    NumericValue,
-    is_fixed,
-    is_constant,
-    is_potentially_variable,
-)
-from pyomo.kernel import pprint
-from pyomo.core.tests.unit.kernel.test_dict_container import (
-    _TestActiveDictContainerBase,
-)
-from pyomo.core.tests.unit.kernel.test_tuple_container import (
-    _TestActiveTupleContainerBase,
-)
-from pyomo.core.tests.unit.kernel.test_list_container import (
-    _TestActiveListContainerBase,
+from pyomo.environ import (
+    ConcreteModel,
+    Var,
+    RangeSet,
+    Block,
+    Constraint,
+    CounterLabeler,
+    NumericLabeler,
+    TextLabeler,
+    ComponentUID,
+    ShortNameLabeler,
+    CNameLabeler,
+    CuidLabeler,
+    AlphaNumericTextLabeler,
+    NameLabeler,
 )
-from pyomo.core.kernel.base import ICategorizedObject
-from pyomo.core.kernel.parameter import (
-    IParameter,
-    parameter,
-    functional_value,
-    parameter_dict,
-    parameter_tuple,
-    parameter_list,
-)
-from pyomo.core.kernel.variable import variable
-from pyomo.core.kernel.block import block
 
 
-class Test_parameter(unittest.TestCase):
-    def test_pprint(self):
-        # Not really testing what the output is, just that
-        # an error does not occur. The pprint functionality
-        # is still in the early stages.
-        p = parameter()
-        pprint(p)
-        b = block()
-        b.p = p
-        pprint(p)
-        pprint(b)
-        m = block()
-        m.b = b
-        pprint(p)
-        pprint(b)
-        pprint(m)
-
-    def test_ctype(self):
-        p = parameter()
-        self.assertIs(p.ctype, IParameter)
-        self.assertIs(type(p), parameter)
-        self.assertIs(type(p)._ctype, IParameter)
-
-    def test_pickle(self):
-        p = parameter(value=1.0)
-        self.assertEqual(p.value, 1.0)
-        self.assertIs(p.parent, None)
-        pup = pickle.loads(pickle.dumps(p))
-        self.assertEqual(pup.value, 1.0)
-        self.assertIs(pup.parent, None)
-        b = block()
-        b.p = p
-        self.assertIs(p.parent, b)
-        bup = pickle.loads(pickle.dumps(b))
-        pup = bup.p
-        self.assertEqual(pup.value, 1.0)
-        self.assertIs(pup.parent, bup)
-
-    def test_init(self):
-        p = parameter()
-        self.assertTrue(p.parent is None)
-        self.assertEqual(p.ctype, IParameter)
-        self.assertEqual(p.value, None)
-        self.assertEqual(p(), None)
-        p.value = 1
-        self.assertEqual(p.value, 1)
-        self.assertEqual(p(), 1)
-
-    def test_type(self):
-        p = parameter()
-        self.assertTrue(isinstance(p, ICategorizedObject))
-        self.assertTrue(isinstance(p, IParameter))
-        self.assertTrue(isinstance(p, NumericValue))
-
-    def test_is_constant(self):
-        p = parameter()
-        self.assertEqual(p.is_constant(), False)
-        self.assertEqual(is_constant(p), False)
-        p.value = 1.0
-        self.assertEqual(p.is_constant(), False)
-        self.assertEqual(is_constant(p), False)
-
-    def test_is_fixed(self):
-        p = parameter()
-        self.assertEqual(p.is_fixed(), True)
-        self.assertEqual(is_fixed(p), True)
-        p.value = 1.0
-        self.assertEqual(p.is_fixed(), True)
-        self.assertEqual(is_fixed(p), True)
-
-    def test_potentially_variable(self):
-        p = parameter()
-        self.assertEqual(p.is_potentially_variable(), False)
-        self.assertEqual(is_potentially_variable(p), False)
-        p.value = 1.0
-        self.assertEqual(p.is_potentially_variable(), False)
-        self.assertEqual(is_potentially_variable(p), False)
-
-    def test_polynomial_degree(self):
-        p = parameter()
-        self.assertEqual(p.polynomial_degree(), 0)
-        self.assertEqual((p**2).polynomial_degree(), 0)
-        self.assertEqual(p.value, None)
-        with self.assertRaises(ValueError):
-            (p**2)()
-        p.value = 1.0
-        self.assertEqual(p.polynomial_degree(), 0)
-        self.assertEqual((p**2).polynomial_degree(), 0)
-        self.assertEqual(p.value, 1.0)
-        self.assertEqual((p**2)(), 1.0)
-
-    def test_is_expression_type(self):
-        p = parameter()
-        self.assertEqual(p.is_expression_type(), False)
-
-    def test_is_parameter_type(self):
-        p = parameter()
-        # GH: apparently is_parameter_type has something
-        #     to do with mutability...
-        self.assertEqual(p.is_parameter_type(), False)
-
-
-class Test_functional_value(unittest.TestCase):
-    def test_pprint(self):
-        # Not really testing what the output is, just that
-        # an error does not occur. The pprint functionality
-        # is still in the early stages.
-        f = functional_value()
-        pprint(f)
-        b = block()
-        b.f = f
-        pprint(f)
-        pprint(b)
-        m = block()
-        m.b = b
-        pprint(f)
-        pprint(b)
-        pprint(m)
-
-    def test_ctype(self):
-        f = functional_value()
-        self.assertIs(f.ctype, IParameter)
-        self.assertIs(type(f), functional_value)
-        self.assertIs(type(f)._ctype, IParameter)
-
-    def test_pickle(self):
-        f = functional_value()
-        self.assertIs(f.fn, None)
-        self.assertIs(f.parent, None)
-        fup = pickle.loads(pickle.dumps(f))
-        self.assertIs(fup.fn, None)
-        self.assertIs(fup.parent, None)
-        b = block()
-        b.f = f
-        self.assertIs(f.parent, b)
-        bup = pickle.loads(pickle.dumps(b))
-        fup = bup.f
-        self.assertIs(fup.fn, None)
-        self.assertIs(fup.parent, bup)
-
-    @unittest.skipIf(not has_dill, "The dill module is not available")
-    def test_dill(self):
-        p = parameter(1)
-        f = functional_value(lambda: p())
-        self.assertEqual(f(), 1)
-        fup = dill.loads(dill.dumps(f))
-        p.value = 2
-        self.assertEqual(f(), 2)
-        self.assertEqual(fup(), 1)
-        b = block()
-        b.p = p
-        b.f = f
-        self.assertEqual(b.f(), 2)
-        bup = dill.loads(dill.dumps(b))
-        fup = bup.f
-        b.p.value = 4
-        self.assertEqual(b.f(), 4)
-        self.assertEqual(bup.f(), 2)
-        bup.p.value = 4
-        self.assertEqual(bup.f(), 4)
-
-    def test_call(self):
-        f = functional_value()
-        self.assertEqual(f(), None)
-        self.assertIs(f.fn, None)
-        f.fn = lambda: variable(value=1)
-        self.assertIsNot(f.fn, None)
-        # the function did not return numeric data
-        # (always causes an exception)
-        with self.assertRaises(TypeError):
-            f(exception=False)
-        with self.assertRaises(TypeError):
-            f(exception=True)
-        with self.assertRaises(TypeError):
-            f()
-        f.fn = lambda: None
-        self.assertIsNot(f.fn, None)
-        # the function did not return numeric data
-        # (always causes an exception)
-        with self.assertRaises(TypeError):
-            f(exception=False)
-        with self.assertRaises(TypeError):
-            f(exception=True)
-        with self.assertRaises(TypeError):
-            f()
-
-        def value_error():
-            raise ValueError()
-
-        f.fn = value_error
-        self.assertIsNot(f.fn, None)
-        self.assertEqual(f(exception=False), None)
-        with self.assertRaises(ValueError):
-            f(exception=True)
-        with self.assertRaises(ValueError):
-            f()
-
-    def test_init(self):
-        f = functional_value()
-        self.assertTrue(f.parent is None)
-        self.assertEqual(f.ctype, IParameter)
-        self.assertEqual(f.fn, None)
-        self.assertEqual(f(), None)
-        x = [1, 2]
-        f.fn = lambda: max(x)
-        self.assertEqual(f(), 2)
-        x[0] = 3
-        self.assertEqual(f(), 3)
-
-    def test_type(self):
-        f = functional_value()
-        self.assertTrue(isinstance(f, ICategorizedObject))
-        self.assertTrue(isinstance(f, IParameter))
-        self.assertTrue(isinstance(f, NumericValue))
-
-    def test_is_constant(self):
-        f = functional_value()
-        self.assertEqual(f.is_constant(), False)
-        self.assertEqual(is_constant(f), False)
-        f.fn = lambda: 2
-        self.assertEqual(f.is_constant(), False)
-        self.assertEqual(is_constant(f), False)
-
-    def test_is_fixed(self):
-        f = functional_value()
-        self.assertEqual(f.is_fixed(), True)
-        self.assertEqual(is_fixed(f), True)
-        f.fn = lambda: 2
-        self.assertEqual(f.is_fixed(), True)
-        self.assertEqual(is_fixed(f), True)
-
-    def test_potentially_variable(self):
-        f = functional_value()
-        self.assertEqual(f.is_potentially_variable(), False)
-        self.assertEqual(is_potentially_variable(f), False)
-        f.fn = lambda: 2
-        self.assertEqual(f.is_potentially_variable(), False)
-        self.assertEqual(is_potentially_variable(f), False)
-
-    def test_polynomial_degree(self):
-        f = functional_value()
-        self.assertEqual(f.polynomial_degree(), 0)
-        self.assertEqual((f**2).polynomial_degree(), 0)
-        self.assertIs(f.fn, None)
-        with self.assertRaises(ValueError):
-            (f**2)()
-        f.fn = lambda: 2
-        self.assertEqual(f.polynomial_degree(), 0)
-        self.assertEqual((f**2).polynomial_degree(), 0)
-        self.assertEqual(f(), 2)
-        self.assertEqual((f**2)(), 4)
-
-    def test_is_expression_type(self):
-        f = functional_value()
-        self.assertEqual(f.is_expression_type(), False)
-
-    def test_is_parameter_type(self):
-        f = functional_value()
-        # GH: apparently is_parameter_type has something
-        #     to do with mutability...
-        self.assertEqual(f.is_parameter_type(), False)
-
-
-class Test_parameter_dict(_TestActiveDictContainerBase, unittest.TestCase):
-    _container_type = parameter_dict
-    _ctype_factory = lambda self: parameter()
-
-
-class Test_parameter_tuple(_TestActiveTupleContainerBase, unittest.TestCase):
-    _container_type = parameter_tuple
-    _ctype_factory = lambda self: parameter()
-
-
-class Test_parameter_list(_TestActiveListContainerBase, unittest.TestCase):
-    _container_type = parameter_list
-    _ctype_factory = lambda self: parameter()
+class LabelerTests(unittest.TestCase):
+    def setUp(self):
+        m = ConcreteModel()
+        m.mycomp = Var()
+        m.MyComp = Var()
+        m.that = Var()
+        self.long1 = m.myverylongcomponentname = Var()
+        self.long2 = m.myverylongcomponentnamerighthere = Var()
+        self.long3 = m.anotherlongonebutdifferent = Var()
+        self.long4 = m.anotherlongonebutdifferentlongcomponentname = Var()
+        self.long5 = m.longcomponentname_1_ = Var()
+        m.s = RangeSet(10)
+        m.ind = Var(m.s)
+        m.myblock = Block()
+        m.myblock.mystreet = Constraint()
+        m.add_component("myblock.mystreet", Var())
+        self.thecopy = m.__getattribute__("myblock.mystreet")
+        self.m = m
+
+    def test_counterlabeler(self):
+        m = self.m
+        lbl = CounterLabeler()
+        self.assertEqual(lbl(m.mycomp), 1)
+        self.assertEqual(lbl(m.mycomp), 2)
+        self.assertEqual(lbl(m.that), 3)
+        self.assertEqual(lbl(self.long1), 4)
+        self.assertEqual(lbl(m.myblock), 5)
+        self.assertEqual(lbl(m.myblock.mystreet), 6)
+        self.assertEqual(lbl(self.thecopy), 7)
+
+    def test_numericlabeler(self):
+        m = self.m
+        lbl = NumericLabeler('x')
+        self.assertEqual(lbl(m.mycomp), 'x1')
+        self.assertEqual(lbl(m.mycomp), 'x2')
+        self.assertEqual(lbl(m.that), 'x3')
+        self.assertEqual(lbl(self.long1), 'x4')
+        self.assertEqual(lbl(m.myblock), 'x5')
+        self.assertEqual(lbl(m.myblock.mystreet), 'x6')
+        self.assertEqual(lbl(self.thecopy), 'x7')
+
+        lbl = NumericLabeler('xyz')
+        self.assertEqual(lbl(m.mycomp), 'xyz1')
+        self.assertEqual(lbl(m.mycomp), 'xyz2')
+        self.assertEqual(lbl(m.that), 'xyz3')
+        self.assertEqual(lbl(self.long1), 'xyz4')
+        self.assertEqual(lbl(m.myblock), 'xyz5')
+        self.assertEqual(lbl(m.myblock.mystreet), 'xyz6')
+        self.assertEqual(lbl(self.thecopy), 'xyz7')
+
+    def test_cnamelabeler(self):
+        m = self.m
+        lbl = CNameLabeler()
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'myverylongcomponentname')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock.mystreet')
+        self.assertEqual(lbl(self.thecopy), "'myblock.mystreet'")
+        self.assertEqual(lbl(m.ind[3]), 'ind[3]')
+        self.assertEqual(lbl(m.ind[10]), 'ind[10]')
+        self.assertEqual(lbl(m.ind[1]), 'ind[1]')
+
+    def test_textlabeler(self):
+        m = self.m
+        lbl = TextLabeler()
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'myverylongcomponentname')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock_mystreet')
+        self.assertEqual(lbl(self.thecopy), '_myblock_mystreet_')
+        self.assertEqual(lbl(m.ind[3]), 'ind(3)')
+        self.assertEqual(lbl(m.ind[10]), 'ind(10)')
+        self.assertEqual(lbl(m.ind[1]), 'ind(1)')
+
+    def test_alphanumerictextlabeler(self):
+        m = self.m
+        lbl = AlphaNumericTextLabeler()
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'myverylongcomponentname')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock_mystreet')
+        self.assertEqual(lbl(self.thecopy), '_myblock_mystreet_')
+        self.assertEqual(lbl(m.ind[3]), 'ind_3_')
+        self.assertEqual(lbl(m.ind[10]), 'ind_10_')
+        self.assertEqual(lbl(m.ind[1]), 'ind_1_')
+
+    def test_namelabeler(self):
+        m = self.m
+        lbl = NameLabeler()
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'myverylongcomponentname')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock.mystreet')
+        self.assertEqual(lbl(self.thecopy), "'myblock.mystreet'")
+        self.assertEqual(lbl(m.ind[3]), 'ind[3]')
+        self.assertEqual(lbl(m.ind[10]), 'ind[10]')
+        self.assertEqual(lbl(m.ind[1]), 'ind[1]')
+
+    def test_cuidlabeler(self):
+        m = self.m
+        lbl = CuidLabeler()
+        self.assertEqual(lbl(m.mycomp), ComponentUID(m.mycomp))
+        self.assertEqual(lbl(m.mycomp), ComponentUID(m.mycomp))
+        self.assertEqual(lbl(m.that), ComponentUID(m.that))
+        self.assertEqual(lbl(self.long1), ComponentUID(self.long1))
+        self.assertEqual(lbl(m.myblock), ComponentUID(m.myblock))
+        self.assertEqual(lbl(m.myblock.mystreet), ComponentUID(m.myblock.mystreet))
+        self.assertEqual(lbl(self.thecopy), ComponentUID(self.thecopy))
+        self.assertEqual(lbl(m.ind[3]), ComponentUID(m.ind[3]))
+        self.assertEqual(lbl(m.ind[10]), ComponentUID(m.ind[10]))
+        self.assertEqual(lbl(m.ind[1]), ComponentUID(m.ind[1]))
+
+    def test_case_insensitive_shortnamelabeler(self):
+        m = self.m
+        lbl = ShortNameLabeler(20, '_', caseInsensitive=True)
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'longcomponentname_1_')
+        self.assertEqual(lbl(self.long2), 'nentnamerighthere_2_')
+        self.assertEqual(lbl(self.long3), 'ngonebutdifferent_3_')
+        self.assertEqual(lbl(self.long4), 'longcomponentname_4_')
+        self.assertEqual(lbl(self.long5), 'gcomponentname_1__5_')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock_mystreet')
+        self.assertEqual(lbl(m.ind[3]), 'ind_3_')
+        self.assertEqual(lbl(m.ind[10]), 'ind_10_')
+        self.assertEqual(lbl(m.ind[1]), 'ind_1_')
+        self.assertEqual(lbl(self.thecopy), '_myblock_mystreet_')
+
+        # Test name collision
+        m._myblock = Block()
+        m._myblock.mystreet_ = Var()
+        self.assertEqual(lbl(m.mycomp), 'mycomp_6_')
+        self.assertEqual(lbl(m._myblock.mystreet_), 'myblock_mystreet__7_')
+        self.assertEqual(lbl(m.MyComp), 'MyComp_8_')
+
+    def test_shortnamelabeler_prefix(self):
+        m = self.m
+        lbl = ShortNameLabeler(20, '_', prefix='s_', caseInsensitive=True)
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 's_ngcomponentname_1_')
+        self.assertEqual(lbl(self.long2), 's_ntnamerighthere_2_')
+        self.assertEqual(lbl(self.long3), 's_onebutdifferent_3_')
+        self.assertEqual(lbl(self.long4), 's_ngcomponentname_4_')
+        self.assertEqual(lbl(self.long5), 'longcomponentname_1_')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock_mystreet')
+        self.assertEqual(lbl(m.ind[3]), 'ind_3_')
+        self.assertEqual(lbl(m.ind[10]), 'ind_10_')
+        self.assertEqual(lbl(m.ind[1]), 'ind_1_')
+        self.assertEqual(lbl(self.thecopy), '_myblock_mystreet_')
+
+        # Test name collision
+        m._myblock = Block()
+        m._myblock.mystreet_ = Var()
+        self.assertEqual(lbl(m.mycomp), 's_mycomp_5_')
+        self.assertEqual(lbl(m._myblock.mystreet_), 's_block_mystreet__6_')
+        self.assertEqual(lbl(m.MyComp), 's_MyComp_7_')
+
+    def test_case_sensitive_shortnamelabeler(self):
+        m = self.m
+        lbl = ShortNameLabeler(20, '_')
+        self.assertEqual(lbl(m.mycomp), 'mycomp')
+        self.assertEqual(lbl(m.that), 'that')
+        self.assertEqual(lbl(self.long1), 'longcomponentname_1_')
+        self.assertEqual(lbl(self.long2), 'nentnamerighthere_2_')
+        self.assertEqual(lbl(self.long3), 'ngonebutdifferent_3_')
+        self.assertEqual(lbl(self.long4), 'longcomponentname_4_')
+        self.assertEqual(lbl(self.long5), 'gcomponentname_1__5_')
+        self.assertEqual(lbl(m.myblock), 'myblock')
+        self.assertEqual(lbl(m.myblock.mystreet), 'myblock_mystreet')
+        self.assertEqual(lbl(m.ind[3]), 'ind_3_')
+        self.assertEqual(lbl(m.ind[10]), 'ind_10_')
+        self.assertEqual(lbl(m.ind[1]), 'ind_1_')
+        self.assertEqual(lbl(self.thecopy), '_myblock_mystreet_')
+
+        # Test name collision
+        m._myblock = Block()
+        m._myblock.mystreet_ = Var()
+        self.assertEqual(lbl(m.mycomp), 'mycomp_6_')
+        self.assertEqual(lbl(m._myblock.mystreet_), 'myblock_mystreet__7_')
+        self.assertEqual(lbl(m.MyComp), 'MyComp')
+
+    def test_case_shortnamelabeler_overflow(self):
+        m = self.m
+        lbl = ShortNameLabeler(4, '_', caseInsensitive=True)
+        for i in range(9):
+            self.assertEqual(lbl(m.mycomp), 'p_%d_' % (i + 1))
+        with self.assertRaisesRegex(RuntimeError, "Too many identifiers"):
+            lbl(m.mycomp)
+
+    def test_shortnamelabeler_legal_regex(self):
+        m = ConcreteModel()
+        lbl = ShortNameLabeler(60, suffix='_', prefix='s_', legalRegex='^[a-zA-Z]')
+
+        m.legal_var = Var()
+        self.assertEqual(lbl(m.legal_var), 'legal_var')
+
+        m._illegal_var = Var()
+        self.assertEqual(lbl(m._illegal_var), 's__illegal_var_1_')
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_piecewise.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_piecewise.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_sos.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_sos.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_suffix.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_suffix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_tuple_container.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_tuple_container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/kernel/test_variable.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/kernel/test_variable.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_action.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_action.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_block.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_block.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
 # Unit Tests for Elements of a Block
 #
 
 from io import StringIO
+import logging
 import os
 import sys
 import types
 import json
 
 from copy import deepcopy
 from os.path import abspath, dirname, join
@@ -50,15 +51,15 @@
     Any,
 )
 from pyomo.common.log import LoggingIntercept
 from pyomo.common.tempfiles import TempfileManager
 from pyomo.core.base.block import (
     ScalarBlock,
     SubclassOf,
-    _BlockData,
+    BlockData,
     declare_custom_block,
 )
 import pyomo.core.expr as EXPR
 from pyomo.opt import check_available_solvers
 
 from pyomo.gdp import Disjunct
 
@@ -847,15 +848,15 @@
             b.b = 5
 
     def test_clear(self):
         class DerivedBlock(ScalarBlock):
             _Block_reserved_words = None
 
         DerivedBlock._Block_reserved_words = (
-            set(['a', 'b', 'c']) | _BlockData._Block_reserved_words
+            set(['a', 'b', 'c']) | BlockData._Block_reserved_words
         )
 
         m = ConcreteModel()
         m.clear()
         self.assertEqual(m._ctypes, {})
         self.assertEqual(m._decl, {})
         self.assertEqual(m._decl_order, [])
@@ -961,24 +962,24 @@
         ### creation of a circular reference
         b = Block(concrete=True)
         b.c = Block()
         b.c.d = Block()
         b.c.d.e = Block()
         with self.assertRaisesRegex(
             ValueError,
-            r'_BlockData.transfer_attributes_from\(\): '
+            r'BlockData.transfer_attributes_from\(\): '
             r'Cannot set a sub-block \(c.d.e\) to a parent block \(c\):',
         ):
             b.c.d.e.transfer_attributes_from(b.c)
 
         ### bad data type
         b = Block(concrete=True)
         with self.assertRaisesRegex(
             ValueError,
-            r'_BlockData.transfer_attributes_from\(\): expected a Block '
+            r'BlockData.transfer_attributes_from\(\): expected a Block '
             'or dict; received str',
         ):
             b.transfer_attributes_from('foo')
 
     def test_iterate_hierarchy_defaults(self):
         self.assertIs(TraversalStrategy.BFS, TraversalStrategy.BreadthFirstSearch)
 
@@ -2663,15 +2664,14 @@
     b : Size=1, Index=None, Active=True
         0 Declarations: 
     c : Size=1, Index=None, Active=True
         0 Declarations: 
 
 5 Declarations: a1_IDX a3_IDX c a b
 """
-        self.maxDiff = None
         self.assertEqual(ref, buf.getvalue())
 
     @unittest.skipIf(not 'glpk' in solvers, "glpk solver is not available")
     def test_solve1(self):
         model = Block(concrete=True)
         model.A = RangeSet(1, 4)
         model.x = Var(model.A, bounds=(-1, 1))
@@ -2972,17 +2972,78 @@
             ValueError, ".*Could not infer file format from file name"
         ):
             m.write(filename="foo.bogus")
 
         with self.assertRaisesRegex(ValueError, ".*Cannot write model in format"):
             m.write(format="bogus")
 
-    def test_override_pprint(self):
+    def test_custom_block(self):
+        @declare_custom_block('TestingBlock')
+        class TestingBlockData(BlockData):
+            def __init__(self, component):
+                BlockData.__init__(self, component)
+                logging.getLogger(__name__).warning("TestingBlockData.__init__")
+
+        self.assertIn('TestingBlock', globals())
+        self.assertIn('ScalarTestingBlock', globals())
+        self.assertIn('IndexedTestingBlock', globals())
+        self.assertIs(TestingBlock.__module__, __name__)
+        self.assertIs(ScalarTestingBlock.__module__, __name__)
+        self.assertIs(IndexedTestingBlock.__module__, __name__)
+
+        with LoggingIntercept() as LOG:
+            obj = TestingBlock()
+        self.assertIs(type(obj), ScalarTestingBlock)
+        self.assertEqual(LOG.getvalue().strip(), "TestingBlockData.__init__")
+
+        with LoggingIntercept() as LOG:
+            obj = TestingBlock([1, 2])
+        self.assertIs(type(obj), IndexedTestingBlock)
+        self.assertEqual(LOG.getvalue(), "")
+
+        # Test that we can derive from a ScalarCustomBlock
+        class DerivedScalarTestingBlock(ScalarTestingBlock):
+            pass
+
+        with LoggingIntercept() as LOG:
+            obj = DerivedScalarTestingBlock()
+        self.assertIs(type(obj), DerivedScalarTestingBlock)
+        self.assertEqual(LOG.getvalue().strip(), "TestingBlockData.__init__")
+
+    def test_custom_block_ctypes(self):
+        @declare_custom_block('TestingBlock')
+        class TestingBlockData(BlockData):
+            pass
+
+        self.assertIs(TestingBlock().ctype, Block)
+
+        @declare_custom_block('TestingBlock', True)
+        class TestingBlockData(BlockData):
+            pass
+
+        self.assertIs(TestingBlock().ctype, TestingBlock)
+
+        @declare_custom_block('TestingBlock', Constraint)
+        class TestingBlockData(BlockData):
+            pass
+
+        self.assertIs(TestingBlock().ctype, Constraint)
+
+        with self.assertRaisesRegex(
+            ValueError,
+            r"Expected new_ctype to be either type or 'True'; received: \[\]",
+        ):
+
+            @declare_custom_block('TestingBlock', [])
+            class TestingBlockData(BlockData):
+                pass
+
+    def test_custom_block_override_pprint(self):
         @declare_custom_block('TempBlock')
-        class TempBlockData(_BlockData):
+        class TempBlockData(BlockData):
             def pprint(self, ostream=None, verbose=False, prefix=""):
                 ostream.write('Testing pprint of a custom block.')
 
         correct_s = 'Testing pprint of a custom block.'
         b = TempBlock(concrete=True)
         stream = StringIO()
         b.pprint(ostream=stream)
@@ -3049,17 +3110,17 @@
         # assumption that unconstructed scalar blocks initialize
         # `_data[None] = self` (therefore doesn't fully support abstract
         # models).  At one point, that was causing the block rule to
         # fire twice during construction.
         class ConcreteBlock(Block):
             pass
 
-        class ScalarConcreteBlock(_BlockData, ConcreteBlock):
+        class ScalarConcreteBlock(BlockData, ConcreteBlock):
             def __init__(self, *args, **kwds):
-                _BlockData.__init__(self, component=self)
+                BlockData.__init__(self, component=self)
                 ConcreteBlock.__init__(self, *args, **kwds)
 
         _buf = []
 
         def _rule(b):
             _buf.append(1)
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_block_model.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_block_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_bounds.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_check.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_check.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_compare.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_compare.py`

 * *Files 4% similar despite different names*

```diff
@@ -161,25 +161,19 @@
         expected = [
             (Expr_ifExpression, 3),
             (InequalityExpression, 2),
             m.x,
             0,
             (EqualityExpression, 2),
             (LinearExpression, 2),
-            (MonomialTermExpression, 2),
-            1,
             m.y,
-            (MonomialTermExpression, 2),
-            1,
             m.x,
             0,
             (EqualityExpression, 2),
             (LinearExpression, 2),
-            (MonomialTermExpression, 2),
-            1,
             m.y,
             (MonomialTermExpression, 2),
             -1,
             m.x,
             0,
         ]
         self.assertEqual(pn, expected)
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_component.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_component.py`

 * *Files 2% similar despite different names*

```diff
@@ -62,27 +62,25 @@
         self.assertNotIn(id(m), cache)
         self.assertEqual(
             m.b[2].c[1, 3].getname(fully_qualified=True, name_buffer=cache),
             "b[2].c[1,3]",
         )
 
         m.b[2]._component = None
-        self.assertEqual(
-            m.b[2].getname(fully_qualified=True), "[Unattached _BlockData]"
-        )
+        self.assertEqual(m.b[2].getname(fully_qualified=True), "[Unattached BlockData]")
         # I think that getname() should do this:
         # self.assertEqual(m.b[2].c[2,4].getname(fully_qualified=True),
-        #                 "[Unattached _BlockData].c[2,4]")
+        #                 "[Unattached BlockData].c[2,4]")
         # but it doesn't match current behavior.  I will file a PEP to
         # propose changing the behavior later and proceed to test
         # current behavior.
         self.assertEqual(m.b[2].c[2, 4].getname(fully_qualified=True), "c[2,4]")
 
         self.assertEqual(
-            m.b[2].getname(fully_qualified=False), "[Unattached _BlockData]"
+            m.b[2].getname(fully_qualified=False), "[Unattached BlockData]"
         )
         self.assertEqual(m.b[2].c[2, 4].getname(fully_qualified=False), "c[2,4]")
 
         # Cached names still work...
         self.assertEqual(
             m.b[2].getname(fully_qualified=True, name_buffer=cache), "b[2]"
         )
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_componentuid.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_componentuid.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_con.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_con.py`

 * *Files 1% similar despite different names*

```diff
@@ -40,15 +40,15 @@
 )
 from pyomo.core.expr import (
     SumExpression,
     EqualityExpression,
     InequalityExpression,
     RangedExpression,
 )
-from pyomo.core.base.constraint import _GeneralConstraintData
+from pyomo.core.base.constraint import ConstraintData
 
 
 class TestConstraintCreation(unittest.TestCase):
     def create_model(self, abstract=False):
         if abstract is True:
             model = AbstractModel()
         else:
@@ -1070,15 +1070,15 @@
         m.x = Var()
         m.c = Constraint(range(5))
         self.assertEqual(len(m.c), 0)
 
         m.c[2] = m.x**2 <= 4
         self.assertEqual(len(m.c), 1)
         self.assertEqual(list(m.c.keys()), [2])
-        self.assertIsInstance(m.c[2], _GeneralConstraintData)
+        self.assertIsInstance(m.c[2], ConstraintData)
         self.assertEqual(m.c[2].upper, 4)
 
         m.c[3] = Constraint.Skip
         self.assertEqual(len(m.c), 1)
         self.assertRaisesRegex(KeyError, "3", m.c.__getitem__, 3)
 
         self.assertRaisesRegex(
@@ -1384,15 +1384,15 @@
     def test_empty_singleton(self):
         a = Constraint()
         a.construct()
         #
         # Even though we construct a ScalarConstraint,
         # if it is not initialized that means it is "empty"
         # and we should encounter errors when trying to access the
-        # _ConstraintData interface methods until we assign
+        # ConstraintData interface methods until we assign
         # something to the constraint.
         #
         self.assertEqual(a._constructed, True)
         self.assertEqual(len(a), 0)
         try:
             a()
             self.fail("Component is empty")
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_concrete.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_concrete.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_connector.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_connector.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_deprecation.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_deprecation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_derivs.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_derivs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_dict_objects.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_dict_objects.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,18 +13,18 @@
 from pyomo.core.base import ConcreteModel, Var, Reals
 from pyomo.core.beta.dict_objects import (
     VarDict,
     ConstraintDict,
     ObjectiveDict,
     ExpressionDict,
 )
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.objective import _GeneralObjectiveData
-from pyomo.core.base.expression import _GeneralExpressionData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.objective import ObjectiveData
+from pyomo.core.base.expression import ExpressionData
 
 
 class _TestComponentDictBase(object):
     _ctype = None
     _cdatatype = None
 
     def setUp(self):
@@ -344,51 +344,51 @@
         model.c.deactivate()
         self.assertEqual(model.c.active, False)
         model.c[1] = self._cdatatype(self._arg())
         self.assertEqual(model.c.active, True)
 
 
 class TestVarDict(_TestComponentDictBase, unittest.TestCase):
-    # Note: the updated _GeneralVarData class only takes an optional
+    # Note: the updated VarData class only takes an optional
     # parent argument (you no longer pass the domain in)
     _ctype = VarDict
-    _cdatatype = lambda self, arg: _GeneralVarData()
+    _cdatatype = lambda self, arg: VarData()
 
     def setUp(self):
         _TestComponentDictBase.setUp(self)
         self._arg = lambda: Reals
 
 
 class TestExpressionDict(_TestComponentDictBase, unittest.TestCase):
     _ctype = ExpressionDict
-    _cdatatype = _GeneralExpressionData
+    _cdatatype = ExpressionData
 
     def setUp(self):
         _TestComponentDictBase.setUp(self)
         self._arg = lambda: self.model.x**3
 
 
 #
 # Test components that include activate/deactivate
 # functionality.
 #
 
 
 class TestConstraintDict(_TestActiveComponentDictBase, unittest.TestCase):
     _ctype = ConstraintDict
-    _cdatatype = _GeneralConstraintData
+    _cdatatype = ConstraintData
 
     def setUp(self):
         _TestComponentDictBase.setUp(self)
         self._arg = lambda: self.model.x >= 1
 
 
 class TestObjectiveDict(_TestActiveComponentDictBase, unittest.TestCase):
     _ctype = ObjectiveDict
-    _cdatatype = _GeneralObjectiveData
+    _cdatatype = ObjectiveData
 
     def setUp(self):
         _TestComponentDictBase.setUp(self)
         self._arg = lambda: self.model.x**2
 
 
 if __name__ == "__main__":
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_disable_methods.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_disable_methods.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_enums.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_enums.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_expr_misc.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_expr_misc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_expression.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_obj.py`

 * *Files 27% similar despite different names*

```diff
@@ -4,1049 +4,826 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
+#
+# Unit Tests for Elements of a Model
+#
+# TestScalarObj                Class for testing single objective
+# TestArrayObj                Class for testing array of objective
+#
 
-import copy
-
-from io import StringIO
-from pyomo.core.expr import expr_common
+import os
+from os.path import abspath, dirname
 
+currdir = dirname(abspath(__file__)) + os.sep
 
 import pyomo.common.unittest as unittest
-import pyomo.core.expr as EXPR
 
 from pyomo.environ import (
     ConcreteModel,
     AbstractModel,
-    Expression,
+    Objective,
+    ObjectiveList,
     Var,
-    Set,
     Param,
-    Objective,
+    Set,
+    RangeSet,
     value,
-    sum_product,
+    maximize,
+    minimize,
+    simple_objective_rule,
+    simple_objectivelist_rule,
 )
-from pyomo.core.base.expression import _GeneralExpressionData
-from pyomo.core.expr.compare import compare_expressions, assertExpressionsEqual
-from pyomo.common.tee import capture_output
-
-
-class TestExpressionData(unittest.TestCase):
-    def test_exprdata_get_set(self):
-        model = ConcreteModel()
-        model.e = Expression([1])
-        self.assertEqual(len(model.e), 1)
-        self.assertEqual(model.e[1].expr, None)
-        model.e.add(1, 1)
-        self.assertEqual(model.e[1].expr, 1)
-        model.e[1].expr += 2
-        self.assertEqual(model.e[1].expr, 3)
-
-    def test_exprdata_get_set_value(self):
-        model = ConcreteModel()
-        model.e = Expression([1])
-        self.assertEqual(len(model.e), 1)
-        self.assertEqual(model.e[1].expr, None)
-        model.e.add(1, 1)
-        model.e[1].expr = 1
-        self.assertEqual(model.e[1].expr, 1)
-        model.e[1].expr += 2
-        self.assertEqual(model.e[1].expr, 3)
-
-    # The copy method must be invoked on expression container to obtain
-    # a shallow copy of the class, the underlying expression remains
-    # a reference.
-    def test_copy(self):
-        model = ConcreteModel()
-        model.a = Var(initialize=5)
-        model.b = Var(initialize=10)
-
-        model.expr1 = Expression(initialize=model.a)
-
-        # Do a shallow copy, the same underlying expression is still referenced
-        expr2 = copy.copy(model.expr1)
-        self.assertEqual(model.expr1(), 5)
-        self.assertEqual(expr2(), 5)
-        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
-
-        # Do an in place modification the expression
-        model.expr1.expr.set_value(1)
-        self.assertEqual(model.expr1(), 1)
-        self.assertEqual(expr2(), 1)
-        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
-
-        # Update the expression value on expr1 only
-        model.expr1.set_value(model.b)
-        self.assertEqual(model.expr1(), 10)
-        self.assertEqual(expr2(), 1)
-        self.assertNotEqual(id(model.expr1.expr), id(expr2.expr))
-
-        model.a.set_value(5)
-        model.b.set_value(10)
-        model.del_component('expr1')
-        model.expr1 = Expression(initialize=model.a + model.b)
-
-        # Do a shallow copy, the same underlying expression is still referenced
-        expr2 = copy.copy(model.expr1)
-        self.assertEqual(model.expr1(), 15)
-        self.assertEqual(expr2(), 15)
-        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
-        self.assertEqual(id(model.expr1.expr.arg(0)), id(expr2.expr.arg(0)))
-        self.assertEqual(id(model.expr1.expr.arg(1)), id(expr2.expr.arg(1)))
-
-        # Do an in place modification the expression
-        # This causes cloning due to reference counting
-        model.a.set_value(0)
-        self.assertEqual(model.expr1(), 10)
-        self.assertEqual(expr2(), 10)
-        self.assertEqual(id(model.expr1.expr), id(expr2.expr))
-        self.assertEqual(id(model.expr1.expr.arg(0)), id(expr2.expr.arg(0)))
-        self.assertEqual(id(model.expr1.expr.arg(1)), id(expr2.expr.arg(1)))
-
-        # Do an in place modification the expression
-        # This causes cloning due to reference counting
-        model.expr1.expr += 1
-        self.assertEqual(model.expr1(), 11)
-        self.assertEqual(expr2(), 10)
-        self.assertNotEqual(id(model.expr1.expr), id(expr2.expr))
-
-    # test that an object is properly deepcopied when the model is cloned
-    def test_model_clone(self):
-        model = ConcreteModel()
-        model.x = Var(initialize=2.0)
-        model.y = Var(initialize=0.0)
-        model.ec = Expression(initialize=model.x**2 + 1)
-        model.obj = Objective(expr=model.y + model.ec)
-        self.assertEqual(model.obj.expr(), 5.0)
-        self.assertTrue(id(model.ec) in [id(e) for e in model.obj.expr.args])
-        inst = model.clone()
-        self.assertEqual(inst.obj.expr(), 5.0)
-        if not id(inst.ec) in [id(e) for e in inst.obj.expr.args]:
-            print("BUG?")
-            print(id(inst.ec))
-            print(inst.obj.expr.__class__)
-            print([id(e) for e in inst.obj.expr.args])
-            print([e.__class__ for e in inst.obj.expr.args])
-            print([id(e) for e in model.obj.expr.args])
-            print([e.__class__ for e in model.obj.expr.args])
-        self.assertTrue(id(inst.ec) in [id(e) for e in inst.obj.expr.args])
-        self.assertNotEqual(id(model.ec), id(inst.ec))
-        self.assertFalse(id(inst.ec) in [id(e) for e in model.obj.expr.args])
 
-    def test_is_constant(self):
-        model = ConcreteModel()
-        model.x = Var(initialize=1.0)
-        model.p = Param(initialize=1.0)
-        model.ec = Expression(initialize=model.x)
-        self.assertEqual(model.ec.is_constant(), False)
-        self.assertEqual(model.ec.expr.is_constant(), False)
-        model.ec.set_value(model.p)
-        self.assertEqual(model.ec.is_constant(), False)
-        self.assertEqual(model.ec.expr.is_constant(), True)
 
-    def test_polynomial_degree(self):
+class TestScalarObj(unittest.TestCase):
+    def test_singleton_get_set(self):
         model = ConcreteModel()
-        model.x = Var(initialize=1.0)
-        model.ec = Expression(initialize=model.x)
-        self.assertEqual(
-            model.ec.polynomial_degree(), model.ec.expr.polynomial_degree()
-        )
-        self.assertEqual(model.ec.polynomial_degree(), 1)
-        model.ec.set_value(model.x**2)
-        self.assertEqual(
-            model.ec.polynomial_degree(), model.ec.expr.polynomial_degree()
-        )
-        self.assertEqual(model.ec.polynomial_degree(), 2)
+        model.o = Objective(expr=1)
+        self.assertEqual(len(model.o), 1)
+        self.assertEqual(model.o.expr, 1)
+        model.o.expr = 2
+        self.assertEqual(model.o.expr, 2)
+        model.o.expr += 2
+        self.assertEqual(model.o.expr, 4)
 
-    def test_init_concrete(self):
+    def test_singleton_get_set_value(self):
         model = ConcreteModel()
-        model.y = Var(initialize=0.0)
-        model.x = Var(initialize=1.0)
-
-        model.ec = Expression(expr=0)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=model.y)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.y.set_value(-1)
-        model.ec = Expression(initialize=model.y + 1.0)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-
-    def test_init_abstract(self):
-        model = AbstractModel()
-        model.y = Var(initialize=0.0)
-        model.x = Var(initialize=1.0)
-        model.ec = Expression(initialize=0.0)
+        model.o = Objective(expr=1)
+        self.assertEqual(len(model.o), 1)
+        self.assertEqual(model.o.expr, 1)
+        model.o.expr = 2
+        self.assertEqual(model.o.expr, 2)
+        model.o.expr += 2
+        self.assertEqual(model.o.expr, 4)
 
-        def obj_rule(model):
-            return 1.0 + model.ec
-
-        model.obj = Objective(rule=obj_rule)
-        inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=0.0)
-
-        def obj_rule(model):
-            return 1.0 + model.ec
-
-        model.obj = Objective(rule=obj_rule)
-        inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=0.0)
-
-        def obj_rule(model):
-            return 1.0 + model.ec
-
-        model.obj = Objective(rule=obj_rule)
-        inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-
-
-class TestExpression(unittest.TestCase):
-    def setUp(self):
-        TestExpression._save = expr_common.TO_STRING_VERBOSE
-        # Tests can choose what they want - this just makes sure that
-        # things are restored after the tests run.
-        # expr_common.TO_STRING_VERBOSE = True
-
-    def tearDown(self):
-        expr_common.TO_STRING_VERBOSE = TestExpression._save
+    def test_scalar_invalid_expr(self):
+        m = ConcreteModel()
+        m.x = Var()
+        with self.assertRaisesRegex(
+            ValueError,
+            "Cannot assign InequalityExpression to 'obj': "
+            "ScalarObjective components only allow numeric expression "
+            "types.",
+        ):
+            m.obj = Objective(expr=m.x <= 0)
 
-    def test_unconstructed_singleton(self):
-        a = Expression()
-        self.assertEqual(a._constructed, False)
+    def test_empty_singleton(self):
+        a = Objective()
+        a.construct()
+        #
+        # Even though we construct a ScalarObjective,
+        # if it is not initialized that means it is "empty"
+        # and we should encounter errors when trying to access the
+        # ObjectiveData interface methods until we assign
+        # something to the objective.
+        #
+        self.assertEqual(a._constructed, True)
         self.assertEqual(len(a), 0)
         try:
             a()
-            self.fail("Component is unconstructed")
+            self.fail("Component is empty")
         except ValueError:
             pass
         try:
             a.expr
-            self.fail("Component is unconstructed")
+            self.fail("Component is empty")
+        except ValueError:
+            pass
+        try:
+            a.sense
+            self.fail("Component is empty")
         except ValueError:
             pass
+        x = Var(initialize=1.0)
+        x.construct()
+        a.set_value(x + 1)
+        self.assertEqual(len(a), 1)
+        self.assertEqual(a(), 2)
+        self.assertEqual(a.expr(), 2)
+        self.assertEqual(a.sense, minimize)
+
+    def test_unconstructed_singleton(self):
+        a = Objective()
+        self.assertEqual(a._constructed, False)
+        self.assertEqual(len(a), 0)
         try:
-            a.is_constant()
+            a()
             self.fail("Component is unconstructed")
         except ValueError:
             pass
         try:
-            a.is_fixed()
+            a.expr
             self.fail("Component is unconstructed")
         except ValueError:
             pass
         try:
-            a.set_value(4)
+            a.sense
             self.fail("Component is unconstructed")
         except ValueError:
             pass
         a.construct()
+        a.set_sense(minimize)
         self.assertEqual(len(a), 1)
         self.assertEqual(a(), None)
         self.assertEqual(a.expr, None)
-        self.assertEqual(a.is_constant(), False)
-        a.set_value(5)
+        self.assertEqual(a.sense, minimize)
+        a.sense = maximize
         self.assertEqual(len(a), 1)
-        self.assertEqual(a(), 5)
-        self.assertEqual(a.expr, 5)
-        self.assertEqual(a.is_constant(), False)
-        self.assertEqual(a.is_fixed(), True)
-
-    def test_display(self):
-        model = ConcreteModel()
-        model.e = Expression()
-        with capture_output() as out:
-            model.e.display()
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-e : Size=1
-    Key  : Value
-    None : Undefined
-        """.strip(),
-        )
+        self.assertEqual(a(), None)
+        self.assertEqual(a.expr, None)
+        self.assertEqual(a.sense, maximize)
 
-        model.e.set_value(1.0)
-        with capture_output() as out:
-            model.e.display()
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-e : Size=1
-    Key  : Value
-    None :   1.0
-        """.strip(),
-        )
+    def test_numeric_expr(self):
+        """Test expr option with a single numeric constant"""
+        model = ConcreteModel()
+        model.obj = Objective(expr=0.0)
+        self.assertEqual(model.obj(), 0.0)
+        self.assertEqual(value(model.obj), 0.0)
+        self.assertEqual(value(model.obj._data[None]), 0.0)
 
-        out = StringIO()
-        with capture_output() as no_out:
-            model.e.display(ostream=out)
-        self.assertEqual(no_out.getvalue(), "")
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-e : Size=1
-    Key  : Value
-    None :   1.0
-        """.strip(),
-        )
+    def test_mutable_param_expr(self):
+        """Test expr option with a single mutable param"""
+        model = ConcreteModel()
+        model.p = Param(initialize=1.0, mutable=True)
+        model.obj = Objective(expr=model.p)
 
-        model.E = Expression([1, 2])
-        with capture_output() as out:
-            model.E.display()
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-E : Size=2
-    Key : Value
-      1 : Undefined
-      2 : Undefined
-        """.strip(),
-        )
+        self.assertEqual(model.obj(), 1.0)
+        self.assertEqual(value(model.obj), 1.0)
+        self.assertEqual(value(model.obj._data[None]), 1.0)
 
-        model.E[1].set_value(1.0)
-        with capture_output() as out:
-            model.E.display()
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-E : Size=2
-    Key : Value
-      1 :       1.0
-      2 : Undefined
-        """.strip(),
-        )
+    def test_immutable_param_expr(self):
+        """Test expr option a single immutable param"""
+        model = ConcreteModel()
+        model.p = Param(initialize=1.0, mutable=False)
+        model.obj = Objective(expr=model.p)
 
-        out = StringIO()
-        with capture_output() as no_out:
-            model.E.display(ostream=out)
-        self.assertEqual(no_out.getvalue(), "")
-        self.assertEqual(
-            out.getvalue().strip(),
-            """
-E : Size=2
-    Key : Value
-      1 :       1.0
-      2 : Undefined
-        """.strip(),
-        )
+        self.assertEqual(model.obj(), 1.0)
+        self.assertEqual(value(model.obj), 1.0)
+        self.assertEqual(value(model.obj._data[None]), 1.0)
 
-    def test_extract_values_store_values(self):
+    def test_var_expr(self):
+        """Test expr option with a single var"""
         model = ConcreteModel()
-        model.e = Expression()
-        self.assertEqual(model.e.extract_values(), {None: None})
-        model.e.store_values({None: 1.0})
-        self.assertEqual(model.e.extract_values(), {None: 1.0})
-        with self.assertRaises(KeyError):
-            model.e.store_values({1: 1.0})
-
-        model.E = Expression([1, 2])
-        self.assertEqual(model.E.extract_values(), {1: None, 2: None})
-        model.E.store_values({1: 1.0})
-        self.assertEqual(model.E.extract_values(), {1: 1.0, 2: None})
-        model.E.store_values({1: None, 2: 2.0})
-        self.assertEqual(model.E.extract_values(), {1: None, 2: 2.0})
-        with self.assertRaises(KeyError):
-            model.E.store_values({3: 3.0})
-
-    def test_setitem(self):
-        model = ConcreteModel()
-        model.E = Expression([1])
-        model.E[1] = 1
-        self.assertEqual(value(model.E[1]), 1)
-        with self.assertRaises(KeyError):
-            model.E[2] = 1
-        model.del_component(model.E)
-        model.Index = Set(dimen=3, initialize=[(1, 2, 3)])
-        model.E = Expression(model.Index)
-        model.E[(1, 2, 3)] = 1
-        self.assertEqual(value(model.E[(1, 2, 3)]), 1)
-        # GH: testing this ludicrous behavior simply for
-        #     coverage in expression.py.
-        model.E[(1, (2, 3))] = 1
-        self.assertEqual(value(model.E[(1, 2, 3)]), 1)
-        with self.assertRaises(KeyError):
-            model.E[2] = 1
+        model.x = Var(initialize=1.0)
+        model.obj = Objective(expr=model.x)
 
-    def test_nonindexed_construct_rule(self):
+        self.assertEqual(model.obj(), 1.0)
+        self.assertEqual(value(model.obj), 1.0)
+        self.assertEqual(value(model.obj._data[None]), 1.0)
+
+    def test_expr1_option(self):
+        """Test expr option"""
         model = ConcreteModel()
+        model.B = RangeSet(1, 4)
+        model.x = Var(model.B, initialize=2)
+        ans = 0
+        for i in model.B:
+            ans = ans + model.x[i]
+        model.obj = Objective(expr=ans)
 
-        def _some_rule(model):
-            return 1.0
+        self.assertEqual(model.obj(), 8)
+        self.assertEqual(value(model.obj), 8)
+        self.assertEqual(value(model.obj._data[None]), 8)
 
-        model.e = Expression(rule=_some_rule)
-        self.assertEqual(value(model.e), 1.0)
-        model.del_component(model.e)
-        del _some_rule
-
-        def _some_rule(model):
-            return Expression.Skip
-
-        model.e = Expression(rule=_some_rule)
-        self.assertEqual(len(model.e), 0)
-
-    def test_nonindexed_construct_expr(self):
-        model = ConcreteModel()
-        model.e = Expression(expr=Expression.Skip)
-        self.assertEqual(len(model.e), 0)
-        model.del_component(model.e)
-        model.e = Expression()
-        self.assertEqual(model.e.extract_values(), {None: None})
-        model.del_component(model.e)
-        model.e = Expression(expr=1.0)
-        self.assertEqual(model.e.extract_values(), {None: 1.0})
-        model.del_component(model.e)
-        model.e = Expression(expr={None: 1.0})
-        self.assertEqual(model.e.extract_values(), {None: 1.0})
-        # Even though add can be called with any
-        # indexed on indexed Expressions, None must
-        # always be used as the index for non-indexed
-        # Expressions
-        with self.assertRaises(KeyError):
-            model.e.add(2, 2)
+    def test_expr2_option(self):
+        """Test expr option"""
+        model = ConcreteModel()
+        model.x = Var(initialize=2)
+        model.obj = Objective(expr=model.x)
 
-    def test_indexed_construct_rule(self):
+        self.assertEqual(model.obj(), 2)
+        self.assertEqual(value(model.obj), 2)
+        self.assertEqual(value(model.obj._data[None]), 2)
+
+    def test_rule_option(self):
+        """Test rule option"""
         model = ConcreteModel()
-        model.Index = Set(initialize=[1, 2, 3])
 
-        def _some_rule(model, i):
-            if i == 1:
-                return Expression.Skip
-            else:
-                return i
-
-        model.E = Expression(model.Index, rule=_some_rule)
-        self.assertEqual(model.E.extract_values(), {2: 2, 3: 3})
-        self.assertEqual(len(model.E), 2)
-
-    def test_implicit_definition(self):
-        model = ConcreteModel()
-        model.idx = Set(initialize=[1, 2, 3])
-        model.E = Expression(model.idx)
-        self.assertEqual(len(model.E), 3)
-        expr = model.E[1]
-        self.assertIs(type(expr), _GeneralExpressionData)
-        model.E[1] = None
-        self.assertIs(expr, model.E[1])
-        self.assertIs(type(expr), _GeneralExpressionData)
-        self.assertIs(expr.expr, None)
-        model.E[1] = 5
-        self.assertIs(expr, model.E[1])
-        self.assertEqual(model.E.extract_values(), {1: 5, 2: None, 3: None})
-        model.E[2] = 6
-        self.assertIsNot(expr, model.E[2])
-        self.assertEqual(model.E.extract_values(), {1: 5, 2: 6, 3: None})
-
-    def test_explicit_skip_definition(self):
-        model = ConcreteModel()
-        model.idx = Set(initialize=[1, 2, 3])
-        model.E = Expression(model.idx, rule=lambda m, i: Expression.Skip)
-        self.assertEqual(len(model.E), 0)
-        with self.assertRaises(KeyError):
-            expr = model.E[1]
-
-        model.E[1] = None
-        expr = model.E[1]
-        self.assertIs(type(expr), _GeneralExpressionData)
-        self.assertIs(expr.expr, None)
-        model.E[1] = 5
-        self.assertIs(expr, model.E[1])
-        self.assertEqual(model.E.extract_values(), {1: 5})
-        model.E[2] = 6
-        self.assertIsNot(expr, model.E[2])
-        self.assertEqual(model.E.extract_values(), {1: 5, 2: 6})
-
-    def test_indexed_construct_expr(self):
-        model = ConcreteModel()
-        model.Index = Set(initialize=[1, 2, 3])
-        model.E = Expression(model.Index, expr=Expression.Skip)
-        self.assertEqual(len(model.E), 0)
-        model.E = Expression(model.Index)
-        self.assertEqual(model.E.extract_values(), {1: None, 2: None, 3: None})
-        model.del_component(model.E)
-        model.E = Expression(model.Index, expr=1.0)
-        self.assertEqual(model.E.extract_values(), {1: 1.0, 2: 1.0, 3: 1.0})
-        model.del_component(model.E)
-        model.E = Expression(
-            model.Index, expr={1: Expression.Skip, 2: Expression.Skip, 3: 1.0}
-        )
-        self.assertEqual(model.E.extract_values(), {3: 1.0})
+        def f(model):
+            ans = 0
+            for i in [1, 2, 3, 4]:
+                ans = ans + model.x[i]
+            return ans
+
+        model.x = Var(RangeSet(1, 4), initialize=2)
+        model.obj = Objective(rule=f)
+
+        self.assertEqual(model.obj(), 8)
+        self.assertEqual(value(model.obj), 8)
+        self.assertEqual(value(model.obj._data[None]), 8)
 
-    def test_bad_init_too_many_keywords(self):
+    def test_arguments(self):
+        """Test that arguments notare of type ScalarSet"""
         model = ConcreteModel()
 
-        def _some_rule(model):
-            return 1.0
+        def rule(model):
+            return 1
+
+        try:
+            model.obj = Objective(model, rule=rule)
+        except TypeError:
+            pass
+        else:
+            self.fail("Objective should only accept ScalarSets")
 
-        with self.assertRaises(ValueError):
-            model.e = Expression(expr=1.0, rule=_some_rule)
-        del _some_rule
+    def test_sense_option(self):
+        """Test sense option"""
+        model = ConcreteModel()
 
-        def _some_indexed_rule(model, i):
+        def rule(model):
             return 1.0
 
-        with self.assertRaises(ValueError):
-            model.e = Expression([1], expr=1.0, rule=_some_indexed_rule)
-        del _some_indexed_rule
+        model.obj = Objective(sense=maximize, rule=rule)
+
+        self.assertEqual(model.obj.sense, maximize)
+        self.assertEqual(model.obj.is_minimizing(), False)
 
-    def test_init_concrete_indexed(self):
+    def test_dim(self):
+        """Test dim method"""
         model = ConcreteModel()
-        model.y = Var(initialize=0.0)
-        model.x = Var([1, 2, 3], initialize=1.0)
 
-        model.ec = Expression([1, 2, 3], initialize=1.0)
-        model.obj = Objective(expr=1.0 + sum_product(model.ec, index=[1, 2, 3]))
-        self.assertEqual(model.obj.expr(), 4.0)
-        model.ec[1].set_value(2.0)
-        self.assertEqual(model.obj.expr(), 5.0)
+        def rule(model):
+            return 1
 
-    def test_init_concrete_nonindexed(self):
+        model.obj = Objective(rule=rule)
+
+        self.assertEqual(model.obj.dim(), 0)
+
+    def test_keys(self):
+        """Test keys method"""
         model = ConcreteModel()
-        model.y = Var(initialize=0.0)
-        model.x = Var(initialize=1.0)
 
-        model.ec = Expression(initialize=0)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=model.y)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.y.set_value(-1)
-        model.ec = Expression(initialize=model.y + 1.0)
-        model.obj = Objective(expr=1.0 + model.ec)
-        self.assertEqual(model.obj.expr(), 1.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e = 1.0
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 2.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        model.ec.set_value(e)
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
-        e += model.x
-        self.assertEqual(model.obj.expr(), 3.0)
-        self.assertEqual(id(model.obj.expr.arg(1)), id(model.ec))
+        def rule(model):
+            return 1
+
+        model.obj = Objective(rule=rule)
+
+        self.assertEqual(list(model.obj.keys()), [None])
+        self.assertEqual(id(model.obj), id(model.obj[None]))
 
-    def test_init_abstract_indexed(self):
+    def test_len(self):
+        """Test len method"""
         model = AbstractModel()
-        model.ec = Expression([1, 2, 3], initialize=1.0)
-        model.obj = Objective(rule=lambda m: 1.0 + sum_product(m.ec, index=[1, 2, 3]))
+
+        def rule(model):
+            return 1.0
+
+        model.obj = Objective(rule=rule)
+        self.assertEqual(len(model.obj), 0)
         inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 4.0)
-        inst.ec[1].set_value(2.0)
-        self.assertEqual(inst.obj.expr(), 5.0)
+        self.assertEqual(len(inst.obj), 1)
 
-    def test_init_abstract_nonindexed(self):
         model = AbstractModel()
-        model.y = Var(initialize=0.0)
-        model.x = Var(initialize=1.0)
-        model.ec = Expression(initialize=0.0)
+        """Test rule option"""
 
-        def obj_rule(model):
-            return 1.0 + model.ec
+        def f(model):
+            ans = 0
+            for i in model.x.keys():
+                ans = ans + model.x[i]
+            return ans
 
-        model.obj = Objective(rule=obj_rule)
+        model = AbstractModel()
+        model.x = Var(RangeSet(1, 4), initialize=2)
+        model.obj = Objective(rule=f)
+
+        self.assertEqual(len(model.obj), 0)
         inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=0.0)
+        self.assertEqual(len(inst.obj), 1)
 
-        def obj_rule(model):
-            return 1.0 + model.ec
+    def test_keys_empty(self):
+        """Test keys method"""
+        model = ConcreteModel()
+        model.o = Objective()
 
-        model.obj = Objective(rule=obj_rule)
-        inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-
-        model.del_component('obj')
-        model.del_component('ec')
-        model.ec = Expression(initialize=0.0)
+        self.assertEqual(list(model.o.keys()), [])
 
-        def obj_rule(model):
-            return 1.0 + model.ec
+    def test_len_empty(self):
+        """Test len method"""
+        model = ConcreteModel()
+        model.o = Objective()
+        self.assertEqual(len(model.o), 0)
 
-        model.obj = Objective(rule=obj_rule)
-        inst = model.create_instance()
-        self.assertEqual(inst.obj.expr(), 1.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e = 1.0
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 2.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        inst.ec.set_value(e)
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
-        e += inst.x
-        self.assertEqual(inst.obj.expr(), 3.0)
-        self.assertEqual(id(inst.obj.expr.arg(1)), id(inst.ec))
 
-    def test_pprint_oldStyle(self):
-        expr_common.TO_STRING_VERBOSE = True
+class TestArrayObj(unittest.TestCase):
+    def create_model(self):
+        #
+        # Create Model
+        #
+        model = ConcreteModel()
+        model.A = Set(initialize=[1, 2])
+        return model
 
+    def test_objdata_get_set(self):
         model = ConcreteModel()
+        model.o = Objective([1], rule=lambda m, i: 1)
+        self.assertEqual(len(model.o), 1)
+        self.assertEqual(model.o[1].expr, 1)
+        model.o[1].expr = 2
+        self.assertEqual(model.o[1].expr, 2)
+        model.o[1].expr += 2
+        self.assertEqual(model.o[1].expr, 4)
+
+    def test_objdata_get_set_value(self):
+        model = ConcreteModel()
+        model.o = Objective([1], rule=lambda m, i: 1)
+        self.assertEqual(len(model.o), 1)
+        self.assertEqual(model.o[1].expr, 1)
+        model.o[1].expr = 2
+        self.assertEqual(model.o[1].expr, 2)
+        model.o[1].expr += 2
+        self.assertEqual(model.o[1].expr, 4)
+
+    def test_objdata_get_set_sense(self):
+        model = ConcreteModel()
+        model.o = Objective([1], rule=lambda m, i: 1, sense=maximize)
+        self.assertEqual(len(model.o), 1)
+        self.assertEqual(model.o[1].expr, 1)
+        self.assertEqual(model.o[1].sense, maximize)
+        model.o[1].set_sense(minimize)
+        self.assertEqual(model.o[1].sense, minimize)
+        model.o[1].sense = maximize
+        self.assertEqual(model.o[1].sense, maximize)
+
+    def test_rule_option1(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        def f(model, i):
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[1](), 8)
+        self.assertEqual(model.obj[2](), 16)
+        self.assertEqual(value(model.obj[1]), 8)
+        self.assertEqual(value(model.obj[2]), 16)
+
+    def test_rule_option2(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        def f(model, i):
+            if i == 1:
+                return Objective.Skip
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 16)
+        self.assertEqual(value(model.obj[2]), 16)
+
+    def test_rule_option3(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        @simple_objective_rule
+        def f(model, i):
+            if i == 1:
+                return None
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 16)
+        self.assertEqual(value(model.obj[2]), 16)
+
+    def test_rule_numeric_expr(self):
+        """Test rule option with returns a single numeric constant for the expression"""
+        model = self.create_model()
+
+        def f(model, i):
+            return 1.0
+
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 1.0)
+        self.assertEqual(value(model.obj[2]), 1.0)
+
+    def test_rule_immutable_param_expr(self):
+        """Test rule option that returns a single immutable param for the expression"""
+        model = self.create_model()
+
+        def f(model, i):
+            return model.p[i]
+
+        model.p = Param(RangeSet(1, 4), initialize=1.0, mutable=False)
         model.x = Var()
-        model.e = Expression(initialize=model.x + 2)
-        model.E = Expression([1, 2], initialize=model.x**2 + 1)
-        expr = model.e * model.x**2 + model.E[1]
-
-        output = """\
-sum(prod(e{sum(mon(1, x), 2)}, pow(x, 2)), E[1]{sum(pow(x, 2), 1)})
-e : Size=1, Index=None
-    Key  : Expression
-    None : sum(mon(1, x), 2)
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : sum(pow(x, 2), 1)
-      2 : sum(pow(x, 2), 1)
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
-
-        model.e.set_value(1.0)
-        model.E[1].set_value(2.0)
-        output = """\
-sum(prod(e{1.0}, pow(x, 2)), E[1]{2.0})
-e : Size=1, Index=None
-    Key  : Expression
-    None :        1.0
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : 2.0
-      2 : sum(pow(x, 2), 1)
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
-
-        model.e.set_value(None)
-        model.E[1].set_value(None)
-        output = """\
-sum(prod(e{Undefined}, pow(x, 2)), E[1]{Undefined})
-e : Size=1, Index=None
-    Key  : Expression
-    None :  Undefined
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : Undefined
-      2 : sum(pow(x, 2), 1)
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 1.0)
+        self.assertEqual(value(model.obj[2]), 1.0)
+
+    def test_rule_mutable_param_expr(self):
+        """Test rule option that returns a single mutable param for the expression"""
+        model = self.create_model()
+
+        def f(model, i):
+            return model.p[i]
+
+        model.r = RangeSet(1, 4)
+        model.p = Param(model.r, initialize=1.0, mutable=True)
+        model.x = Var()
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 1.0)
+        self.assertEqual(value(model.obj[2]), 1.0)
+
+    def test_rule_var_expr(self):
+        """Test rule option that returns a single var for the expression"""
+        model = self.create_model()
+
+        def f(model, i):
+            return model.x[i]
+
+        model.r = RangeSet(1, 4)
+        model.x = Var(model.r, initialize=1.0)
+        model.obj = Objective(model.A, rule=f)
+
+        self.assertEqual(model.obj[2](), 1.0)
+        self.assertEqual(value(model.obj[2]), 1.0)
+
+    def test_sense_option(self):
+        """Test sense option"""
+        model = self.create_model()
+        model.obj1 = Objective(model.A, rule=lambda m, i: 1.0, sense=maximize)
+        model.obj2 = Objective(model.A, rule=lambda m, i: 1.0, sense=minimize)
+        model.obj3 = Objective(model.A, rule=lambda m, i: 1.0)
+        self.assertTrue(len(model.A) > 0)
+        self.assertEqual(len(model.obj1), len(model.A))
+        self.assertEqual(len(model.obj2), len(model.A))
+        self.assertEqual(len(model.obj3), len(model.A))
+        for i in model.A:
+            self.assertEqual(model.obj1[i].sense, maximize)
+            self.assertEqual(model.obj1[i].is_minimizing(), False)
+            self.assertEqual(model.obj2[i].sense, minimize)
+            self.assertEqual(model.obj2[i].is_minimizing(), True)
+            self.assertEqual(model.obj3[i].sense, minimize)
+            self.assertEqual(model.obj3[i].is_minimizing(), True)
+
+    def test_dim(self):
+        """Test dim method"""
+        model = self.create_model()
+        model.obj = Objective(model.A)
+
+        self.assertEqual(model.obj.dim(), 1)
+
+    def test_keys(self):
+        """Test keys method"""
+        model = self.create_model()
+
+        def A_rule(model, i):
+            return model.x
+
+        model.x = Var()
+        model.obj = Objective(model.A, rule=A_rule)
+
+        self.assertEqual(len(list(model.obj.keys())), 2)
+
+    def test_len(self):
+        """Test len method"""
+        model = self.create_model()
+        model.obj = Objective(model.A)
+        self.assertEqual(len(model.obj), 0)
+
+        model = self.create_model()
+        """Test rule option"""
+
+        def f(model):
+            ans = 0
+            for i in model.x.keys():
+                ans = ans + model.x[i]
+            return ans
+
+        model.x = Var(RangeSet(1, 4), initialize=2)
+        model.obj = Objective(rule=f)
+
+        self.assertEqual(len(model.obj), 1)
+
+
+class Test2DArrayObj(unittest.TestCase):
+    def create_model(self):
+        model = ConcreteModel()
+        model.A = Set(initialize=[1, 2])
+        return model
+
+    def test_rule_option1(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        def f(model, i, k):
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.obj = Objective(model.A, model.A, rule=f)
+
+        try:
+            self.assertEqual(model.obj(), None)
+            self.fail("Expected TypeError")
+        except TypeError:
+            pass
+
+        self.assertEqual(model.obj[1, 1](), 8)
+        self.assertEqual(model.obj[2, 1](), 16)
+        self.assertEqual(value(model.obj[1, 1]), 8)
+        self.assertEqual(value(model.obj[2, 1]), 16)
+
+    def test_sense_option(self):
+        """Test sense option"""
+        model = self.create_model()
+        model.obj1 = Objective(
+            model.A, model.A, rule=lambda m, i, j: 1.0, sense=maximize
+        )
+        model.obj2 = Objective(
+            model.A, model.A, rule=lambda m, i, j: 1.0, sense=minimize
+        )
+        model.obj3 = Objective(model.A, model.A, rule=lambda m, i, j: 1.0)
+        self.assertTrue(len(model.A) > 0)
+        self.assertEqual(len(model.obj1), len(model.A) * len(model.A))
+        self.assertEqual(len(model.obj2), len(model.A) * len(model.A))
+        self.assertEqual(len(model.obj3), len(model.A) * len(model.A))
+        for i in model.A:
+            for j in model.A:
+                self.assertEqual(model.obj1[i, j].sense, maximize)
+                self.assertEqual(model.obj1[i, j].is_minimizing(), False)
+                self.assertEqual(model.obj2[i, j].sense, minimize)
+                self.assertEqual(model.obj2[i, j].is_minimizing(), True)
+                self.assertEqual(model.obj3[i, j].sense, minimize)
+                self.assertEqual(model.obj3[i, j].is_minimizing(), True)
+
+    def test_dim(self):
+        """Test dim method"""
+        model = self.create_model()
+        model.obj = Objective(model.A, model.A)
+
+        self.assertEqual(model.obj.dim(), 2)
+
+    def test_keys(self):
+        """Test keys method"""
+        model = self.create_model()
+
+        def A_rule(model, i, j):
+            return model.x
+
+        model.x = Var()
+        model.obj = Objective(model.A, model.A, rule=A_rule)
+
+        self.assertEqual(len(list(model.obj.keys())), 4)
+
+    def test_len(self):
+        """Test len method"""
+        model = self.create_model()
+        model.obj = Objective(model.A, model.A)
+        self.assertEqual(len(model.obj), 0)
+
+        model = self.create_model()
+        """Test rule option"""
+
+        def f(model):
+            ans = 0
+            for i in model.x.keys():
+                ans = ans + model.x[i]
+            return ans
 
-    def test_pprint_newStyle(self):
-        expr_common.TO_STRING_VERBOSE = False
+        model.x = Var(RangeSet(1, 4), initialize=2)
+        model.obj = Objective(rule=f)
 
+        self.assertEqual(len(model.obj), 1)
+
+
+class TestObjList(unittest.TestCase):
+    def create_model(self):
+        model = ConcreteModel()
+        model.A = Set(initialize=[1, 2, 3, 4])
+        return model
+
+    #
+    # Tests that adding Objective.Skip increments
+    # the internal counter but does not create an object
+    #
+    def test_conlist_skip(self):
         model = ConcreteModel()
         model.x = Var()
-        model.e = Expression(initialize=model.x + 2)
-        model.E = Expression([1, 2], initialize=model.x**2 + 1)
-        expr = model.e * model.x**2 + model.E[1]
-
-        output = """\
-(x + 2)*x**2 + (x**2 + 1)
-e : Size=1, Index=None
-    Key  : Expression
-    None : x + 2
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : x**2 + 1
-      2 : x**2 + 1
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
+        model.c = ObjectiveList()
+        self.assertTrue(1 not in model.c)
+        self.assertEqual(len(model.c), 0)
+        model.c.add(Objective.Skip)
+        self.assertTrue(1 not in model.c)
+        self.assertEqual(len(model.c), 0)
+        model.c.add(model.x + 1)
+        self.assertTrue(1 not in model.c)
+        self.assertTrue(2 in model.c)
+        self.assertEqual(len(model.c), 1)
+
+    def test_rule_option1(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        def f(model, i):
+            if i > 4:
+                return ObjectiveList.End
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.o = ObjectiveList(rule=f)
+
+        self.assertEqual(model.o[1](), 8)
+        self.assertEqual(model.o[2](), 16)
+        self.assertEqual(len(model.o), 4)
+
+    def test_rule_option2(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        def f(model, i):
+            if i > 2:
+                return ObjectiveList.End
+            i = 2 * i - 1
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.o = ObjectiveList(rule=f)
+
+        self.assertEqual(model.o[1](), 8)
+        self.assertEqual(len(model.o), 2)
+
+    def test_rule_option1a(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        @simple_objectivelist_rule
+        def f(model, i):
+            if i > 4:
+                return None
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.o = ObjectiveList(rule=f)
+
+        self.assertEqual(model.o[1](), 8)
+        self.assertEqual(model.o[2](), 16)
+        self.assertEqual(len(model.o), 4)
+
+    def test_rule_option2a(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.B = RangeSet(1, 4)
+
+        @simple_objectivelist_rule
+        def f(model, i):
+            if i > 2:
+                return None
+            i = 2 * i - 1
+            ans = 0
+            for j in model.B:
+                ans = ans + model.x[j]
+            ans *= i
+            return ans
+
+        model.x = Var(model.B, initialize=2)
+        model.o = ObjectiveList(rule=f)
+
+        self.assertEqual(model.o[1](), 8)
+        self.assertEqual(len(model.o), 2)
+
+    def test_rule_option3(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.y = Var(initialize=2)
+
+        def f(model):
+            yield model.y
+            yield 2 * model.y
+            yield 2 * model.y
+            yield ObjectiveList.End
+
+        model.c = ObjectiveList(rule=f)
+        self.assertEqual(len(model.c), 3)
+        self.assertEqual(model.c[1](), 2)
+        model.d = ObjectiveList(rule=f(model))
+        self.assertEqual(len(model.d), 3)
+        self.assertEqual(model.d[1](), 2)
+
+    def test_rule_option4(self):
+        """Test rule option"""
+        model = self.create_model()
+        model.y = Var(initialize=2)
+        model.c = ObjectiveList(rule=((i + 1) * model.y for i in range(3)))
+        self.assertEqual(len(model.c), 3)
+        self.assertEqual(model.c[1](), 2)
+
+    def test_dim(self):
+        """Test dim method"""
+        model = self.create_model()
+        model.o = ObjectiveList()
+
+        self.assertEqual(model.o.dim(), 1)
+
+    def test_keys(self):
+        """Test keys method"""
+        model = self.create_model()
+        model.o = ObjectiveList()
 
-        model.e.set_value(1.0)
-        model.E[1].set_value(2.0)
-        #
-        # WEH - the 1.0 seems unnecessary here, but it results from
-        # a fixed variable in a sub-expression.  I can't decide if this
-        # is the expected behavior or not.
-        #
-        output = """\
-x**2 + 2.0
-e : Size=1, Index=None
-    Key  : Expression
-    None :        1.0
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : 2.0
-      2 : x**2 + 1
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
-
-        model.e.set_value(None)
-        model.E[1].set_value(None)
-        output = """\
-e{None}*x**2 + E[1]{None}
-e : Size=1, Index=None
-    Key  : Expression
-    None :  Undefined
-E : Size=2, Index={1, 2}
-    Key : Expression
-      1 : Undefined
-      2 : x**2 + 1
-"""
-        out = StringIO()
-        out.write(str(expr) + "\n")
-        model.e.pprint(ostream=out)
-        # model.E[1].pprint(ostream=out)
-        model.E.pprint(ostream=out)
-        self.assertEqual(output, out.getvalue())
+        self.assertEqual(len(list(model.o.keys())), 0)
 
     def test_len(self):
-        model = AbstractModel()
-        model.e = Expression()
+        """Test len method"""
+        model = self.create_model()
+        model.o = ObjectiveList()
 
-        self.assertEqual(len(model.e), 0)
-        inst = model.create_instance()
-        self.assertEqual(len(inst.e), 1)
+        self.assertEqual(len(model.o), 0)
 
-    def test_None_key(self):
-        model = AbstractModel()
-        model.e = Expression()
-        inst = model.create_instance()
-        self.assertEqual(id(inst.e), id(inst.e[None]))
 
-    def test_singleton_get_set(self):
+class MiscObjTests(unittest.TestCase):
+    def test_constructor(self):
+        a = Objective(name="b")
+        self.assertEqual(a.local_name, "b")
+        try:
+            a = Objective(foo="bar")
+            self.fail("Can't specify an unexpected constructor option")
+        except ValueError:
+            pass
+
+    def test_rule(self):
+        def rule1(model):
+            return []
+
+        model = ConcreteModel()
+        try:
+            model.o = Objective(rule=rule1)
+            self.fail("Error generating objective")
+        except Exception:
+            pass
+        #
         model = ConcreteModel()
-        model.e = Expression()
-        self.assertEqual(len(model.e), 1)
-        self.assertEqual(model.e.expr, None)
-        model.e.expr = 1
-        self.assertEqual(model.e.expr, 1)
-        model.e.expr += 2
-        self.assertEqual(model.e.expr, 3)
 
-    def test_singleton_get_set_value(self):
+        def rule1(model):
+            return 1.1
+
+        model = ConcreteModel()
+        model.o = Objective(rule=rule1)
+        self.assertEqual(model.o(), 1.1)
+        #
         model = ConcreteModel()
-        model.e = Expression()
-        self.assertEqual(len(model.e), 1)
-        self.assertEqual(model.e.expr, None)
-        model.e.expr = 1
-        self.assertEqual(model.e.expr, 1)
-        model.e.expr += 2
-        self.assertEqual(model.e.expr, 3)
+
+        def rule1(model, i):
+            return 1.1
+
+        model = ConcreteModel()
+        model.a = Set(initialize=[1, 2, 3])
+        try:
+            model.o = Objective(model.a, rule=rule1)
+        except Exception:
+            self.fail("Error generating objective")
 
     def test_abstract_index(self):
         model = AbstractModel()
         model.A = Set()
         model.B = Set()
         model.C = model.A | model.B
-        model.x = Expression(model.C)
-
-    def test_iadd(self):
-        # make sure simple for loops that look like they
-        # create a new expression do not modify the named
-        # expression
-        m = ConcreteModel()
-        e = m.e = Expression(expr=1.0)
-        expr = 0.0
-        for v in [1.0, e]:
-            expr += v
-        self.assertEqual(e.expr, 1)
-        self.assertEqual(expr(), 2)
-        expr = 0.0
-        for v in [e, 1.0]:
-            expr += v
-        self.assertEqual(e.expr, 1)
-        self.assertEqual(expr, 2)
-        # Make sure that using in-place operators on named expressions
-        # do not create loops inthe expression tree (test #1890)
-        m.x = Var()
-        m.y = Var()
-        m.e.expr = m.x
-        m.e += m.y
-        assertExpressionsEqual(self, m.e.expr, m.x + m.y)
-
-    def test_isub(self):
-        # make sure simple for loops that look like they
-        # create a new expression do not modify the named
-        # expression
-        m = ConcreteModel()
-        e = m.e = Expression(expr=1.0)
-        expr = 0.0
-        for v in [1.0, e]:
-            expr -= v
-        self.assertEqual(e.expr, 1)
-        self.assertEqual(expr(), -2)
-        expr = 0.0
-        for v in [e, 1.0]:
-            expr -= v
-        self.assertEqual(e.expr, 1)
-        self.assertEqual(expr(), -2)
-        # Make sure that using in-place operators on named expressions
-        # do not create loops inthe expression tree (test #1890)
-        m.x = Var()
-        m.y = Var()
-        m.e.expr = m.x
-        m.e -= m.y
-        assertExpressionsEqual(
-            self,
-            m.e.expr,
-            EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, m.x)),
-                    EXPR.MonomialTermExpression((-1, m.y)),
-                ]
-            ),
-        )
-        self.assertTrue(compare_expressions(m.e.expr, m.x - m.y))
-
-    def test_imul(self):
-        # make sure simple for loops that look like they
-        # create a new expression do not modify the named
-        # expression
-        m = ConcreteModel()
-        e = m.e = Expression(expr=3.0)
-        expr = 1.0
-        for v in [2.0, e]:
-            expr *= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr(), 6)
-        expr = 1.0
-        for v in [e, 2.0]:
-            expr *= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 6)
-        # Make sure that using in-place operators on named expressions
-        # do not create loops inthe expression tree (test #1890)
-        m.x = Var()
-        m.y = Var()
-        m.e.expr = m.x
-        m.e *= m.y
-        self.assertTrue(compare_expressions(m.e.expr, m.x * m.y))
-
-    def test_idiv(self):
-        # make sure simple for loops that look like they
-        # create a new expression do not modify the named
-        # expression
-        # floating point division
-        m = ConcreteModel()
-        e = m.e = Expression(expr=3.0)
-        expr = e
-        for v in [2.0, 1.0]:
-            expr /= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 1.5)
-        expr = e
-        for v in [1.0, 2.0]:
-            expr /= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 1.5)
-        # note that integer division does not occur within
-        # Pyomo expressions
-        m = ConcreteModel()
-        e = m.e = Expression(expr=3.0)
-        expr = e
-        for v in [2, 1]:
-            expr /= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 1.5)
-        expr = e
-        for v in [1, 2]:
-            expr /= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 1.5)
-        # Make sure that using in-place operators on named expressions
-        # do not create loops inthe expression tree (test #1890)
-        m.x = Var()
-        m.y = Var()
-        m.e.expr = m.x
-        m.e /= m.y
-        self.assertTrue(compare_expressions(m.e.expr, m.x / m.y))
-
-    def test_ipow(self):
-        # make sure simple for loops that look like they
-        # create a new expression do not modify the named
-        # expression
-        m = ConcreteModel()
-        e = m.e = Expression(expr=3.0)
-        expr = e
-        for v in [2.0, 1.0]:
-            expr **= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 9)
-        expr = e
-        for v in [1.0, 2.0]:
-            expr **= v
-        self.assertEqual(e.expr, 3)
-        self.assertEqual(expr, 9)
-        # Make sure that using in-place operators on named expressions
-        # do not create loops inthe expression tree (test #1890)
-        m.x = Var()
-        m.y = Var()
-        m.e.expr = m.x
-        m.e **= m.y
-        self.assertTrue(compare_expressions(m.e.expr, m.x**m.y))
+        model.x = Objective(model.C)
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_external.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_external.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_indexed.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_indexed.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_indexed_slice.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_indexed_slice.py`

 * *Files 0% similar despite different names*

```diff
@@ -13,15 +13,15 @@
 #
 
 import pickle
 
 import pyomo.common.unittest as unittest
 
 from pyomo.environ import Var, Block, ConcreteModel, RangeSet, Set, Any
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base.indexed_component_slice import IndexedComponent_slice
 from pyomo.core.base.set import normalize_index
 
 
 def _x_init(m, k):
     return k
 
@@ -60,15 +60,15 @@
         m.b = Block(m.I, m.J, rule=_b)
         m.bb = Block(m.I, m.J, m.K, rule=_bb)
 
     def tearDown(self):
         self.m = None
 
     def test_simple_getitem(self):
-        self.assertIsInstance(self.m.b[1, 4], _BlockData)
+        self.assertIsInstance(self.m.b[1, 4], BlockData)
 
     def test_simple_getslice(self):
         _slicer = self.m.b[:, 4]
         self.assertIsInstance(_slicer, IndexedComponent_slice)
         ans = [str(x) for x in _slicer]
         self.assertEqual(ans, ['b[1,4]', 'b[2,4]', 'b[3,4]'])
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_initializer.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_initializer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_kernel_register_numpy_types.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_kernel_register_numpy_types.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_list_objects.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_list_objects.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,18 +13,18 @@
 from pyomo.core.base import ConcreteModel, Var, Reals
 from pyomo.core.beta.list_objects import (
     XVarList,
     XConstraintList,
     XObjectiveList,
     XExpressionList,
 )
-from pyomo.core.base.var import _GeneralVarData
-from pyomo.core.base.constraint import _GeneralConstraintData
-from pyomo.core.base.objective import _GeneralObjectiveData
-from pyomo.core.base.expression import _GeneralExpressionData
+from pyomo.core.base.var import VarData
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.objective import ObjectiveData
+from pyomo.core.base.expression import ExpressionData
 
 
 class _TestComponentListBase(object):
     _ctype = None
     _cdatatype = None
 
     def setUp(self):
@@ -361,51 +361,51 @@
         model.c.deactivate()
         self.assertEqual(model.c.active, False)
         model.c.insert(0, self._cdatatype(self._arg()))
         self.assertEqual(model.c.active, True)
 
 
 class TestVarList(_TestComponentListBase, unittest.TestCase):
-    # Note: the updated _GeneralVarData class only takes an optional
+    # Note: the updated VarData class only takes an optional
     # parent argument (you no longer pass the domain in)
     _ctype = XVarList
-    _cdatatype = lambda self, arg: _GeneralVarData()
+    _cdatatype = lambda self, arg: VarData()
 
     def setUp(self):
         _TestComponentListBase.setUp(self)
         self._arg = lambda: Reals
 
 
 class TestExpressionList(_TestComponentListBase, unittest.TestCase):
     _ctype = XExpressionList
-    _cdatatype = _GeneralExpressionData
+    _cdatatype = ExpressionData
 
     def setUp(self):
         _TestComponentListBase.setUp(self)
         self._arg = lambda: self.model.x**3
 
 
 #
 # Test components that include activate/deactivate
 # functionality.
 #
 
 
 class TestConstraintList(_TestActiveComponentListBase, unittest.TestCase):
     _ctype = XConstraintList
-    _cdatatype = _GeneralConstraintData
+    _cdatatype = ConstraintData
 
     def setUp(self):
         _TestComponentListBase.setUp(self)
         self._arg = lambda: self.model.x >= 1
 
 
 class TestObjectiveList(_TestActiveComponentListBase, unittest.TestCase):
     _ctype = XObjectiveList
-    _cdatatype = _GeneralObjectiveData
+    _cdatatype = ObjectiveData
 
     def setUp(self):
         _TestComponentListBase.setUp(self)
         self._arg = lambda: self.model.x**2
 
 
 if __name__ == "__main__":
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_constraint.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_expr_expanded.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_expr_expanded.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_logical_to_linear.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_logical_to_linear.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_matrix_constraint.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_matrix_constraint.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_misc.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_misc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_model.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_mutable.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_mutable.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr.py`

 * *Files 4% similar despite different names*

```diff
@@ -108,15 +108,15 @@
 from pyomo.core.expr.relational_expr import RelationalExpression, EqualityExpression
 from pyomo.common.errors import PyomoException
 from pyomo.core.expr.visitor import expression_to_string, clone_expression
 from pyomo.core.expr import Expr_if
 from pyomo.core.base.label import NumericLabeler
 from pyomo.core.expr.template_expr import IndexTemplate
 from pyomo.core.expr import expr_common
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.var import VarData
 
 from pyomo.repn import generate_standard_repn
 from pyomo.core.expr.numvalue import NumericValue
 
 
 class decompose_linear_term_wrapper(object):
     def __init__(self, pairs):
@@ -290,15 +290,15 @@
         # Confirm that 'exp' has the expected value
         #
         self.assertEqual(value(exp), val)
 
 
 class TestExpression_EvaluateVarData(TestExpression_EvaluateNumericValue):
     def create(self, val, domain):
-        tmp = _GeneralVarData()
+        tmp = VarData()
         tmp.domain = domain
         tmp.value = val
         return tmp
 
 
 class TestExpression_EvaluateVar(TestExpression_EvaluateNumericValue):
     def create(self, val, domain):
@@ -634,52 +634,36 @@
     def test_simpleSum(self):
         # a + b
         m = AbstractModel()
         m.a = Var()
         m.b = Var()
         e = m.a + m.b
         #
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.a)), MonomialTermExpression((1, m.b))]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b]))
 
         self.assertRaises(KeyError, e.arg, 3)
 
     def test_simpleSum_API(self):
         m = ConcreteModel()
         m.a = Var()
         m.b = Var()
         e = m.a + m.b
         e += 2 * m.a
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.a)),
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((2, m.a)),
-                ]
-            ),
+            e, LinearExpression([m.a, m.b, MonomialTermExpression((2, m.a))])
         )
 
     def test_constSum(self):
         # a + 5
         m = AbstractModel()
         m.a = Var()
         #
-        self.assertExpressionsEqual(
-            m.a + 5, LinearExpression([MonomialTermExpression((1, m.a)), 5])
-        )
+        self.assertExpressionsEqual(m.a + 5, LinearExpression([m.a, 5]))
 
-        self.assertExpressionsEqual(
-            5 + m.a, LinearExpression([5, MonomialTermExpression((1, m.a))])
-        )
+        self.assertExpressionsEqual(5 + m.a, LinearExpression([5, m.a]))
 
     def test_nestedSum(self):
         #
         # Check the structure of nested sums
         #
         expectedType = SumExpression
 
@@ -692,91 +676,53 @@
         #           +
         #          / \
         #         +   5
         #        / \
         #       a   b
         e1 = m.a + m.b
         e = e1 + 5
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.a)), MonomialTermExpression((1, m.b)), 5]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b, 5]))
 
         #       +
         #      / \
         #     5   +
         #        / \
         #       a   b
         e1 = m.a + m.b
         e = 5 + e1
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.a)), MonomialTermExpression((1, m.b)), 5]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b, 5]))
 
         #           +
         #          / \
         #         +   c
         #        / \
         #       a   b
         e1 = m.a + m.b
         e = e1 + m.c
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.a)),
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((1, m.c)),
-                ]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b, m.c]))
 
         #       +
         #      / \
         #     c   +
         #        / \
         #       a   b
         e1 = m.a + m.b
         e = m.c + e1
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.a)),
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((1, m.c)),
-                ]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b, m.c]))
 
         #            +
         #          /   \
         #         +     +
         #        / \   / \
         #       a   b c   d
         e1 = m.a + m.b
         e2 = m.c + m.d
         e = e1 + e2
         #
-        self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.a)),
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((1, m.c)),
-                    MonomialTermExpression((1, m.d)),
-                ]
-            ),
-        )
+        self.assertExpressionsEqual(e, LinearExpression([m.a, m.b, m.c, m.d]))
 
     def test_nestedSum2(self):
         #
         # Check the structure of nested sums
         #
         expectedType = SumExpression
 
@@ -794,30 +740,15 @@
         #          / \
         #         a   b
         e1 = m.a + m.b
         e = 2 * e1 + m.c
 
         self.assertExpressionsEqual(
             e,
-            SumExpression(
-                [
-                    ProductExpression(
-                        (
-                            2,
-                            LinearExpression(
-                                [
-                                    MonomialTermExpression((1, m.a)),
-                                    MonomialTermExpression((1, m.b)),
-                                ]
-                            ),
-                        )
-                    ),
-                    m.c,
-                ]
-            ),
+            SumExpression([ProductExpression((2, LinearExpression([m.a, m.b]))), m.c]),
         )
 
         #         *
         #        / \
         #       3   +
         #          / \
         #         *   c
@@ -830,28 +761,15 @@
 
         self.assertExpressionsEqual(
             e,
             ProductExpression(
                 (
                     3,
                     SumExpression(
-                        [
-                            ProductExpression(
-                                (
-                                    2,
-                                    LinearExpression(
-                                        [
-                                            MonomialTermExpression((1, m.a)),
-                                            MonomialTermExpression((1, m.b)),
-                                        ]
-                                    ),
-                                )
-                            ),
-                            m.c,
-                        ]
+                        [ProductExpression((2, LinearExpression([m.a, m.b]))), m.c]
                     ),
                 )
             ),
         )
 
     def test_trivialSum(self):
         #
@@ -887,70 +805,50 @@
         #     *   b
         #    / \
         #   a   5
         e1 = m.a * 5
         e = e1 + m.b
         #
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((5, m.a)), MonomialTermExpression((1, m.b))]
-            ),
+            e, LinearExpression([MonomialTermExpression((5, m.a)), m.b])
         )
 
         #       +
         #      / \
         #     b   *
         #        / \
         #       a   5
         e = m.b + e1
         #
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.b)), MonomialTermExpression((5, m.a))]
-            ),
+            e, LinearExpression([m.b, MonomialTermExpression((5, m.a))])
         )
 
         #            +
         #          /   \
         #         *     +
         #        / \   / \
         #       a   5 b   c
         e2 = m.b + m.c
         e = e1 + e2
         #
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((1, m.c)),
-                    MonomialTermExpression((5, m.a)),
-                ]
-            ),
+            e, LinearExpression([m.b, m.c, MonomialTermExpression((5, m.a))])
         )
 
         #            +
         #          /   \
         #         +     *
         #        / \   / \
         #       b   c a   5
         e2 = m.b + m.c
         e = e2 + e1
         #
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((1, m.c)),
-                    MonomialTermExpression((5, m.a)),
-                ]
-            ),
+            e, LinearExpression([m.b, m.c, MonomialTermExpression((5, m.a))])
         )
 
     def test_simpleDiff(self):
         #
         # Check the structure of a simple difference with two variables
         #
         m = AbstractModel()
@@ -958,33 +856,28 @@
         m.b = Var()
 
         #    -
         #   / \
         #  a   b
         e = m.a - m.b
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.a)), MonomialTermExpression((-1, m.b))]
-            ),
+            e, LinearExpression([m.a, MonomialTermExpression((-1, m.b))])
         )
 
     def test_constDiff(self):
         #
         # Check the structure of a simple difference with a constant
         #
         m = AbstractModel()
         m.a = Var()
 
         #    -
         #   / \
         #  a   5
-        self.assertExpressionsEqual(
-            m.a - 5, LinearExpression([MonomialTermExpression((1, m.a)), -5])
-        )
+        self.assertExpressionsEqual(m.a - 5, LinearExpression([m.a, -5]))
 
         #    -
         #   / \
         #  5   a
         self.assertExpressionsEqual(
             5 - m.a, LinearExpression([5, MonomialTermExpression((-1, m.a))])
         )
@@ -998,18 +891,15 @@
         m.p = Param()
 
         #    -
         #   / \
         #  a   p
         e = m.a - m.p
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [MonomialTermExpression((1, m.a)), NPV_NegationExpression((m.p,))]
-            ),
+            e, LinearExpression([m.a, NPV_NegationExpression((m.p,))])
         )
 
         #      -
         #     / \
         #  m.p   a
         e = m.p - m.a
         self.assertExpressionsEqual(
@@ -1075,22 +965,15 @@
         #      / \
         #     -   5
         #    / \
         #   a   b
         e1 = m.a - m.b
         e = e1 - 5
         self.assertExpressionsEqual(
-            e,
-            LinearExpression(
-                [
-                    MonomialTermExpression((1, m.a)),
-                    MonomialTermExpression((-1, m.b)),
-                    -5,
-                ]
-            ),
+            e, LinearExpression([m.a, MonomialTermExpression((-1, m.b)), -5])
         )
 
         #       -
         #      / \
         #     5   -
         #        / \
         #       a   b
@@ -1098,22 +981,15 @@
         e = 5 - e1
         self.assertExpressionsEqual(
             e,
             SumExpression(
                 [
                     5,
                     NegationExpression(
-                        (
-                            LinearExpression(
-                                [
-                                    MonomialTermExpression((1, m.a)),
-                                    MonomialTermExpression((-1, m.b)),
-                                ]
-                            ),
-                        )
+                        (LinearExpression([m.a, MonomialTermExpression((-1, m.b))]),)
                     ),
                 ]
             ),
         )
 
         #       -
         #      / \
@@ -1122,15 +998,15 @@
         #   a   b
         e1 = m.a - m.b
         e = e1 - m.c
         self.assertExpressionsEqual(
             e,
             LinearExpression(
                 [
-                    MonomialTermExpression((1, m.a)),
+                    m.a,
                     MonomialTermExpression((-1, m.b)),
                     MonomialTermExpression((-1, m.c)),
                 ]
             ),
         )
 
         #       -
@@ -1142,22 +1018,15 @@
         e = m.c - e1
         self.assertExpressionsEqual(
             e,
             SumExpression(
                 [
                     m.c,
                     NegationExpression(
-                        (
-                            LinearExpression(
-                                [
-                                    MonomialTermExpression((1, m.a)),
-                                    MonomialTermExpression((-1, m.b)),
-                                ]
-                            ),
-                        )
+                        (LinearExpression([m.a, MonomialTermExpression((-1, m.b))]),)
                     ),
                 ]
             ),
         )
 
         #            -
         #          /   \
@@ -1167,29 +1036,17 @@
         e1 = m.a - m.b
         e2 = m.c - m.d
         e = e1 - e2
         self.assertExpressionsEqual(
             e,
             SumExpression(
                 [
-                    LinearExpression(
-                        [
-                            MonomialTermExpression((1, m.a)),
-                            MonomialTermExpression((-1, m.b)),
-                        ]
-                    ),
+                    LinearExpression([m.a, MonomialTermExpression((-1, m.b))]),
                     NegationExpression(
-                        (
-                            LinearExpression(
-                                [
-                                    MonomialTermExpression((1, m.c)),
-                                    MonomialTermExpression((-1, m.d)),
-                                ]
-                            ),
-                        )
+                        (LinearExpression([m.c, MonomialTermExpression((-1, m.d))]),)
                     ),
                 ]
             ),
         )
 
     def test_negation_param(self):
         #
@@ -1378,18 +1235,15 @@
         #        / \
         #       a   5
         e1 = m.a * m.p
         e = m.b - e1
         self.assertExpressionsEqual(
             e,
             LinearExpression(
-                [
-                    MonomialTermExpression((1, m.b)),
-                    MonomialTermExpression((NPV_NegationExpression((m.p,)), m.a)),
-                ]
+                [m.b, MonomialTermExpression((NPV_NegationExpression((m.p,)), m.a))]
             ),
         )
 
         #            -
         #          /   \
         #         *     -
         #        / \   / \
@@ -1399,41 +1253,33 @@
         e = e1 - e2
         self.assertExpressionsEqual(
             e,
             SumExpression(
                 [
                     MonomialTermExpression((m.p, m.a)),
                     NegationExpression(
-                        (
-                            LinearExpression(
-                                [
-                                    MonomialTermExpression((1, m.b)),
-                                    MonomialTermExpression((-1, m.c)),
-                                ]
-                            ),
-                        )
+                        (LinearExpression([m.b, MonomialTermExpression((-1, m.c))]),)
                     ),
                 ]
             ),
         )
 
         #            -
         #          /   \
         #         -     *
         #        / \   / \
         #       b   c a   5
         e1 = m.a * m.p
         e2 = m.b - m.c
         e = e2 - e1
-        self.maxDiff = None
         self.assertExpressionsEqual(
             e,
             LinearExpression(
                 [
-                    MonomialTermExpression((1, m.b)),
+                    m.b,
                     MonomialTermExpression((-1, m.c)),
                     MonomialTermExpression((NPV_NegationExpression((m.p,)), m.a)),
                 ]
             ),
         )
 
 
@@ -1595,30 +1441,15 @@
         e2 = m.c + e1
         e3 = e1 + m.d
         e = e2 * e3
 
         self.assertExpressionsEqual(
             e,
             ProductExpression(
-                (
-                    LinearExpression(
-                        [
-                            MonomialTermExpression((1, m.a)),
-                            MonomialTermExpression((1, m.b)),
-                            MonomialTermExpression((1, m.c)),
-                        ]
-                    ),
-                    LinearExpression(
-                        [
-                            MonomialTermExpression((1, m.a)),
-                            MonomialTermExpression((1, m.b)),
-                            MonomialTermExpression((1, m.d)),
-                        ]
-                    ),
-                )
+                (LinearExpression([m.a, m.b, m.c]), LinearExpression([m.a, m.b, m.d]))
             ),
         )
         # Verify shared args...
         self.assertIs(e1._args_, e2._args_)
         self.assertIsNot(e1._args_, e3._args_)
         self.assertIs(e1._args_, e.arg(0)._args_)
         self.assertIs(e.arg(0).arg(0), e.arg(1).arg(0))
@@ -1635,17 +1466,15 @@
         #           / \
         #          a   b
         e1 = m.a + m.b
         e2 = m.c * e1
         e3 = e1 * m.d
         e = e2 * e3
         #
-        inner = LinearExpression(
-            [MonomialTermExpression((1, m.a)), MonomialTermExpression((1, m.b))]
-        )
+        inner = LinearExpression([m.a, m.b])
         self.assertExpressionsEqual(
             e,
             ProductExpression(
                 (ProductExpression((m.c, inner)), ProductExpression((inner, m.d)))
             ),
         )
         # Verify shared args...
@@ -2031,18 +1860,18 @@
         # Print simple sum
         #
         model = ConcreteModel()
         model.a = Var()
         model.p = Param(mutable=True)
 
         expr = 5 + model.a + model.a
-        self.assertEqual("sum(5, mon(1, a), mon(1, a))", str(expr))
+        self.assertEqual("sum(5, a, a)", str(expr))
 
         expr += 5
-        self.assertEqual("sum(5, mon(1, a), mon(1, a), 5)", str(expr))
+        self.assertEqual("sum(5, a, a, 5)", str(expr))
 
         expr = 2 + model.p
         self.assertEqual("sum(2, p)", str(expr))
 
     def test_linearsum(self):
         #
         # Print simple sum
@@ -2050,32 +1879,26 @@
         model = ConcreteModel()
         A = range(5)
         model.a = Var(A)
         model.p = Param(A, initialize=2, mutable=True)
 
         expr = quicksum(i * model.a[i] for i in A)
         self.assertEqual(
-            "sum(mon(0, a[0]), mon(1, a[1]), mon(2, a[2]), mon(3, a[3]), "
-            "mon(4, a[4]))",
+            "sum(mon(0, a[0]), a[1], mon(2, a[2]), mon(3, a[3]), " "mon(4, a[4]))",
             str(expr),
         )
 
         expr = quicksum((i - 2) * model.a[i] for i in A)
         self.assertEqual(
-            "sum(mon(-2, a[0]), mon(-1, a[1]), mon(0, a[2]), mon(1, a[3]), "
-            "mon(2, a[4]))",
+            "sum(mon(-2, a[0]), mon(-1, a[1]), mon(0, a[2]), a[3], " "mon(2, a[4]))",
             str(expr),
         )
 
         expr = quicksum(model.a[i] for i in A)
-        self.assertEqual(
-            "sum(mon(1, a[0]), mon(1, a[1]), mon(1, a[2]), mon(1, a[3]), "
-            "mon(1, a[4]))",
-            str(expr),
-        )
+        self.assertEqual("sum(a[0], a[1], a[2], a[3], a[4])", str(expr))
 
         model.p[1].value = 0
         model.p[3].value = 3
         expr = quicksum(model.p[i] * model.a[i] if i != 3 else model.p[i] for i in A)
         self.assertEqual(
             "sum(mon(2, a[0]), mon(0, a[1]), mon(2, a[2]), 3, mon(2, a[4]))",
             expression_to_string(expr, compute_values=True),
@@ -2135,18 +1958,18 @@
         expr = model.a >= 5
         self.assertEqual("5  <=  a", str(expr))
 
         expr = expr < 10
         self.assertEqual("5  <=  a  <  10", str(expr))
 
         expr = 5 <= model.a + 5
-        self.assertEqual("5  <=  sum(mon(1, a), 5)", str(expr))
+        self.assertEqual("5  <=  sum(a, 5)", str(expr))
 
         expr = expr < 10
-        self.assertEqual("5  <=  sum(mon(1, a), 5)  <  10", str(expr))
+        self.assertEqual("5  <=  sum(a, 5)  <  10", str(expr))
 
     def test_equality(self):
         #
         # Print equality
         #
         model = ConcreteModel()
         model.a = Var()
@@ -2163,18 +1986,18 @@
         expr = 5 == model.a
         self.assertEqual("a  ==  5", str(expr))
 
         expr = model.a == 10
         self.assertEqual("a  ==  10", str(expr))
 
         expr = 5 == model.a + 5
-        self.assertEqual("sum(mon(1, a), 5)  ==  5", str(expr))
+        self.assertEqual("sum(a, 5)  ==  5", str(expr))
 
         expr = model.a + 5 == 5
-        self.assertEqual("sum(mon(1, a), 5)  ==  5", str(expr))
+        self.assertEqual("sum(a, 5)  ==  5", str(expr))
 
     def test_getitem(self):
         m = ConcreteModel()
         m.I = RangeSet(1, 9)
         m.x = Var(m.I, initialize=lambda m, i: i + 1)
         m.P = Param(m.I, initialize=lambda m, i: 10 - i, mutable=True)
         t = IndexTemplate(m.I)
@@ -2203,15 +2026,15 @@
         expr = 2 / expr
         expr = 2**expr
         expr = -expr
         expr = +expr
         expr = abs(expr)
         self.assertEqual(
             "abs(neg(pow(2, div(2, prod(2, sum(1, neg(pow(div(prod(sum("
-            "mon(1, a), 1, -1), a), a), b)), 1))))))",
+            "a, 1, -1), a), a), b)), 1))))))",
             str(expr),
         )
 
 
 class TestPrettyPrinter_newStyle(unittest.TestCase):
     _save = None
 
@@ -3751,21 +3574,15 @@
         self.m = None
 
     def test_summation1(self):
         e = sum_product(self.m.a)
         self.assertExpressionsEqual(
             e,
             LinearExpression(
-                [
-                    MonomialTermExpression((1, self.m.a[1])),
-                    MonomialTermExpression((1, self.m.a[2])),
-                    MonomialTermExpression((1, self.m.a[3])),
-                    MonomialTermExpression((1, self.m.a[4])),
-                    MonomialTermExpression((1, self.m.a[5])),
-                ]
+                [self.m.a[1], self.m.a[2], self.m.a[3], self.m.a[4], self.m.a[5]]
             ),
         )
 
     def test_summation2(self):
         e = sum_product(self.m.p, self.m.a)
         self.assertExpressionsEqual(
             e,
@@ -3869,24 +3686,24 @@
         e1 = sum_product(self.m.a)
         e2 = sum_product(self.m.b)
         e = e1 + e2
         self.assertExpressionsEqual(
             e,
             LinearExpression(
                 [
-                    MonomialTermExpression((1, self.m.a[1])),
-                    MonomialTermExpression((1, self.m.a[2])),
-                    MonomialTermExpression((1, self.m.a[3])),
-                    MonomialTermExpression((1, self.m.a[4])),
-                    MonomialTermExpression((1, self.m.a[5])),
-                    MonomialTermExpression((1, self.m.b[1])),
-                    MonomialTermExpression((1, self.m.b[2])),
-                    MonomialTermExpression((1, self.m.b[3])),
-                    MonomialTermExpression((1, self.m.b[4])),
-                    MonomialTermExpression((1, self.m.b[5])),
+                    self.m.a[1],
+                    self.m.a[2],
+                    self.m.a[3],
+                    self.m.a[4],
+                    self.m.a[5],
+                    self.m.b[1],
+                    self.m.b[2],
+                    self.m.b[3],
+                    self.m.b[4],
+                    self.m.b[5],
                 ]
             ),
         )
 
 
 class TestSumExpression(unittest.TestCase):
     def setUp(self):
@@ -3909,37 +3726,25 @@
             LOG.getvalue().replace('\n', ' '),
             r"DEPRECATED: The quicksum\(linear=...\) argument is deprecated "
             r"and ignored.",
         )
         self.assertExpressionsEqual(
             e,
             LinearExpression(
-                [
-                    MonomialTermExpression((1, self.m.a[1])),
-                    MonomialTermExpression((1, self.m.a[2])),
-                    MonomialTermExpression((1, self.m.a[3])),
-                    MonomialTermExpression((1, self.m.a[4])),
-                    MonomialTermExpression((1, self.m.a[5])),
-                ]
+                [self.m.a[1], self.m.a[2], self.m.a[3], self.m.a[4], self.m.a[5]]
             ),
         )
 
     def test_summation1(self):
         e = quicksum((self.m.a[i] for i in self.m.a))
         self.assertEqual(e(), 25)
         self.assertExpressionsEqual(
             e,
             LinearExpression(
-                [
-                    MonomialTermExpression((1, self.m.a[1])),
-                    MonomialTermExpression((1, self.m.a[2])),
-                    MonomialTermExpression((1, self.m.a[3])),
-                    MonomialTermExpression((1, self.m.a[4])),
-                    MonomialTermExpression((1, self.m.a[5])),
-                ]
+                [self.m.a[1], self.m.a[2], self.m.a[3], self.m.a[4], self.m.a[5]]
             ),
         )
 
     def test_summation2(self):
         e = quicksum(self.m.p[i] * self.m.a[i] for i in self.m.a)
         self.assertEqual(e(), 25)
         self.assertExpressionsEqual(
@@ -4153,23 +3958,23 @@
             start = counter.count
             expr1 = self.m.a + self.m.b
             expr2 = expr1.clone()
             self.assertEqual(expr1(), 15)
             self.assertEqual(expr2(), 15)
             self.assertNotEqual(id(expr1), id(expr2))
             self.assertNotEqual(id(expr1._args_), id(expr2._args_))
-            self.assertIs(expr1.arg(0).arg(1), expr2.arg(0).arg(1))
-            self.assertIs(expr1.arg(1).arg(1), expr2.arg(1).arg(1))
+            self.assertIs(expr1.arg(0), expr2.arg(0))
+            self.assertIs(expr1.arg(1), expr2.arg(1))
             expr1 += self.m.b
             self.assertEqual(expr1(), 25)
             self.assertEqual(expr2(), 15)
             self.assertNotEqual(id(expr1), id(expr2))
             self.assertNotEqual(id(expr1._args_), id(expr2._args_))
-            self.assertIs(expr1.arg(0).arg(1), expr2.arg(0).arg(1))
-            self.assertIs(expr1.arg(1).arg(1), expr2.arg(1).arg(1))
+            self.assertIs(expr1.arg(0), expr2.arg(0))
+            self.assertIs(expr1.arg(1), expr2.arg(1))
             #
             total = counter.count - start
             self.assertEqual(total, 1)
 
     def test_SumExpressionX(self):
         with clone_counter() as counter:
             start = counter.count
@@ -4338,17 +4143,17 @@
             self.assertEqual(expr1.arg(1)(), expr2.arg(1)())
 
             self.assertEqual(expr1.arg(0).nargs(), 2)
             self.assertEqual(expr2.arg(0).nargs(), 2)
             self.assertEqual(expr1.arg(1).nargs(), 2)
             self.assertEqual(expr2.arg(1).nargs(), 2)
 
-            self.assertIs(expr1.arg(0).arg(0).arg(1), expr2.arg(0).arg(0).arg(1))
-            self.assertIs(expr1.arg(0).arg(1).arg(1), expr2.arg(0).arg(1).arg(1))
-            self.assertIs(expr1.arg(1).arg(0).arg(1), expr2.arg(1).arg(0).arg(1))
+            self.assertIs(expr1.arg(0).arg(0), expr2.arg(0).arg(0))
+            self.assertIs(expr1.arg(0).arg(1), expr2.arg(0).arg(1))
+            self.assertIs(expr1.arg(1).arg(0), expr2.arg(1).arg(0))
 
             expr1 *= self.m.b
             self.assertEqual(expr1(), 1500)
             self.assertEqual(expr2(), 150)
             self.assertNotEqual(id(expr1), id(expr2))
             self.assertNotEqual(id(expr1.arg(0)), id(expr2.arg(0)))
             self.assertNotEqual(id(expr1.arg(1)), id(expr2.arg(1)))
@@ -4379,16 +4184,16 @@
             self.assertEqual(expr1.nargs(), 2)
             self.assertEqual(expr2.nargs(), 2)
             self.assertEqual(expr1.arg(0).nargs(), 2)
             self.assertEqual(expr2.arg(0).nargs(), 2)
             self.assertEqual(expr1.arg(1).nargs(), 2)
             self.assertEqual(expr2.arg(1).nargs(), 2)
 
-            self.assertIs(expr1.arg(0).arg(0).arg(1), expr2.arg(0).arg(0).arg(1))
-            self.assertIs(expr1.arg(0).arg(1).arg(1), expr2.arg(0).arg(1).arg(1))
+            self.assertIs(expr1.arg(0).arg(0), expr2.arg(0).arg(0))
+            self.assertIs(expr1.arg(0).arg(1), expr2.arg(0).arg(1))
 
             expr1 /= self.m.b
             self.assertAlmostEqual(expr1(), 0.15)
             self.assertAlmostEqual(expr2(), 1.5)
             self.assertNotEqual(id(expr1.arg(0)), id(expr2.arg(0)))
             self.assertNotEqual(id(expr1.arg(1)), id(expr2.arg(1)))
 
@@ -5211,26 +5016,15 @@
             e = 2**e
             self.assertExpressionsEqual(e, NPV_PowExpression((2, m.p)))
 
         with linear_expression() as e:
             e += m.v[0] + m.v[1]
             e = m.v[0] ** e
             self.assertExpressionsEqual(
-                e,
-                PowExpression(
-                    (
-                        m.v[0],
-                        LinearExpression(
-                            [
-                                MonomialTermExpression((1, m.v[0])),
-                                MonomialTermExpression((1, m.v[1])),
-                            ]
-                        ),
-                    )
-                ),
+                e, PowExpression((m.v[0], LinearExpression([m.v[0], m.v[1]])))
             )
 
 
 class TestNonlinearExpression(unittest.TestCase):
     def test_sum_other(self):
         m = ConcreteModel()
         m.v = Var(range(5))
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_api.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_api.py`

 * *Files 0% similar despite different names*

```diff
@@ -219,15 +219,15 @@
 
         e = -(m.x + 2 * m.x)
         self.assertTrue(e.is_potentially_variable())
         self.assertEqual(e.polynomial_degree(), 1)
         self.assertEqual(is_fixed(e), False)
         self.assertEqual(value(e), -15)
         self.assertEqual(str(e), "- (x + 2*x)")
-        self.assertEqual(e.to_string(verbose=True), "neg(sum(mon(1, x), mon(2, x)))")
+        self.assertEqual(e.to_string(verbose=True), "neg(sum(x, mon(2, x)))")
 
         # This can't occur through operator overloading, but could
         # through expression substitution
         e = NegationExpression((NegationExpression((m.x,)),))
         self.assertTrue(e.is_potentially_variable())
         self.assertEqual(e.polynomial_degree(), 1)
         self.assertEqual(is_fixed(e), False)
@@ -630,16 +630,15 @@
 
         self.assertTrue(e.is_potentially_variable())
         self.assertEqual(e.polynomial_degree(), 1)
         self.assertEqual(is_fixed(e), False)
         self.assertEqual(value(e), 1 + 4 + 5 + 2)
         self.assertEqual(str(e), "0*x[0] + x[1] + 2*x[2] + 5 + y - 3")
         self.assertEqual(
-            e.to_string(verbose=True),
-            "sum(mon(0, x[0]), mon(1, x[1]), mon(2, x[2]), 5, mon(1, y), -3)",
+            e.to_string(verbose=True), "sum(mon(0, x[0]), x[1], mon(2, x[2]), 5, y, -3)"
         )
 
         self.assertIs(type(e), LinearExpression)
         self.assertEqual(e.constant, 2)
         cache = e._cache
         self.assertEqual(e.linear_coefs, [0, 1, 2, 1])
         self.assertIs(cache, e._cache)
@@ -697,15 +696,15 @@
         self.assertEqual(is_fixed(e), False)
         self.assertEqual(value(e), 5)
         self.assertEqual(
             str(e), "Expr_if( ( 5  <=  y ), then=( x[0] + 5 ), else=( x[1]**2 ) )"
         )
         self.assertEqual(
             e.to_string(verbose=True),
-            "Expr_if( ( 5  <=  y ), then=( sum(mon(1, x[0]), 5) ), else=( pow(x[1], 2) ) )",
+            "Expr_if( ( 5  <=  y ), then=( sum(x[0], 5) ), else=( pow(x[1], 2) ) )",
         )
 
         m.y.fix()
         self.assertTrue(e.is_potentially_variable())
         self.assertEqual(e.polynomial_degree(), 1)
         self.assertEqual(is_fixed(e), False)
         self.assertEqual(value(e), 5)
@@ -968,17 +967,15 @@
         f = e.create_node_with_local_data(e.args)
         self.assertIsNot(f, e)
         self.assertIs(type(f), type(e))
 
         f = e.create_node_with_local_data((m.p, m.x))
         self.assertIsNot(f, e)
         self.assertIs(type(f), LinearExpression)
-        assertExpressionsStructurallyEqual(
-            self, f.args, [m.p, MonomialTermExpression((1, m.x))]
-        )
+        assertExpressionsStructurallyEqual(self, f.args, [m.p, m.x])
 
         f = e.create_node_with_local_data((m.p, m.x**2))
         self.assertIsNot(f, e)
         self.assertIs(type(f), SumExpression)
         assertExpressionsStructurallyEqual(self, f.args, [m.p, PowExpression((m.x, 2))])
 
     def test_linear(self):
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_dispatcher.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_dispatcher.py`

 * *Files 1% similar despite different names*

```diff
@@ -119,16 +119,14 @@
 
         self.mutable_l0 = _MutableSumExpression([])
         self.mutable_l1 = _MutableLinearExpression([self.mon_npv])
         self.mutable_l2 = _MutableSumExpression([self.mon_npv, self.other])
         self.mutable_l3 = _MutableNPVSumExpression([self.npv])
 
         # often repeated reference expressions
-        self.mon_bin = MonomialTermExpression((1, self.bin))
-        self.mon_var = MonomialTermExpression((1, self.var))
         self.minus_bin = MonomialTermExpression((-1, self.bin))
         self.minus_npv = NPV_NegationExpression((self.npv,))
         self.minus_param_mut = NPV_NegationExpression((self.param_mut,))
         self.minus_var = MonomialTermExpression((-1, self.var))
         self.minus_mon_native = MonomialTermExpression((-3, self.mon_native.arg(1)))
         self.minus_mon_param = MonomialTermExpression(
             (NPV_NegationExpression((self.mon_param.arg(0),)), self.mon_param.arg(1))
@@ -364,69 +362,61 @@
 
     def test_add_asbinary(self):
         tests = [
             (self.asbinary, self.invalid, NotImplemented),
             # BooleanVar objects do not support addition
             (self.asbinary, self.asbinary, NotImplemented),
             (self.asbinary, self.zero, self.bin),
-            (self.asbinary, self.one, LinearExpression([self.mon_bin, 1])),
+            (self.asbinary, self.one, LinearExpression([self.bin, 1])),
             # 4:
-            (self.asbinary, self.native, LinearExpression([self.mon_bin, 5])),
-            (self.asbinary, self.npv, LinearExpression([self.mon_bin, self.npv])),
-            (self.asbinary, self.param, LinearExpression([self.mon_bin, 6])),
+            (self.asbinary, self.native, LinearExpression([self.bin, 5])),
+            (self.asbinary, self.npv, LinearExpression([self.bin, self.npv])),
+            (self.asbinary, self.param, LinearExpression([self.bin, 6])),
             (
                 self.asbinary,
                 self.param_mut,
-                LinearExpression([self.mon_bin, self.param_mut]),
+                LinearExpression([self.bin, self.param_mut]),
             ),
             # 8:
-            (self.asbinary, self.var, LinearExpression([self.mon_bin, self.mon_var])),
+            (self.asbinary, self.var, LinearExpression([self.bin, self.var])),
             (
                 self.asbinary,
                 self.mon_native,
-                LinearExpression([self.mon_bin, self.mon_native]),
+                LinearExpression([self.bin, self.mon_native]),
             ),
             (
                 self.asbinary,
                 self.mon_param,
-                LinearExpression([self.mon_bin, self.mon_param]),
-            ),
-            (
-                self.asbinary,
-                self.mon_npv,
-                LinearExpression([self.mon_bin, self.mon_npv]),
+                LinearExpression([self.bin, self.mon_param]),
             ),
+            (self.asbinary, self.mon_npv, LinearExpression([self.bin, self.mon_npv])),
             # 12:
             (
                 self.asbinary,
                 self.linear,
-                LinearExpression(self.linear.args + [self.mon_bin]),
+                LinearExpression(self.linear.args + [self.bin]),
             ),
             (self.asbinary, self.sum, SumExpression(self.sum.args + [self.bin])),
             (self.asbinary, self.other, SumExpression([self.bin, self.other])),
             (self.asbinary, self.mutable_l0, self.bin),
             # 16:
             (
                 self.asbinary,
                 self.mutable_l1,
-                LinearExpression([self.mon_bin, self.mon_npv]),
+                LinearExpression([self.bin, self.mon_npv]),
             ),
             (
                 self.asbinary,
                 self.mutable_l2,
                 SumExpression(self.mutable_l2.args + [self.bin]),
             ),
             (self.asbinary, self.param0, self.bin),
-            (self.asbinary, self.param1, LinearExpression([self.mon_bin, 1])),
+            (self.asbinary, self.param1, LinearExpression([self.bin, 1])),
             # 20:
-            (
-                self.asbinary,
-                self.mutable_l3,
-                LinearExpression([self.mon_bin, self.npv]),
-            ),
+            (self.asbinary, self.mutable_l3, LinearExpression([self.bin, self.npv])),
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_zero(self):
         tests = [
             (self.zero, self.invalid, NotImplemented),
@@ -458,24 +448,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_one(self):
         tests = [
             (self.one, self.invalid, NotImplemented),
-            (self.one, self.asbinary, LinearExpression([1, self.mon_bin])),
+            (self.one, self.asbinary, LinearExpression([1, self.bin])),
             (self.one, self.zero, 1),
             (self.one, self.one, 2),
             # 4:
             (self.one, self.native, 6),
             (self.one, self.npv, NPV_SumExpression([1, self.npv])),
             (self.one, self.param, 7),
             (self.one, self.param_mut, NPV_SumExpression([1, self.param_mut])),
             # 8:
-            (self.one, self.var, LinearExpression([1, self.mon_var])),
+            (self.one, self.var, LinearExpression([1, self.var])),
             (self.one, self.mon_native, LinearExpression([1, self.mon_native])),
             (self.one, self.mon_param, LinearExpression([1, self.mon_param])),
             (self.one, self.mon_npv, LinearExpression([1, self.mon_npv])),
             # 12:
             (self.one, self.linear, LinearExpression(self.linear.args + [1])),
             (self.one, self.sum, SumExpression(self.sum.args + [1])),
             (self.one, self.other, SumExpression([1, self.other])),
@@ -490,24 +480,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_native(self):
         tests = [
             (self.native, self.invalid, NotImplemented),
-            (self.native, self.asbinary, LinearExpression([5, self.mon_bin])),
+            (self.native, self.asbinary, LinearExpression([5, self.bin])),
             (self.native, self.zero, 5),
             (self.native, self.one, 6),
             # 4:
             (self.native, self.native, 10),
             (self.native, self.npv, NPV_SumExpression([5, self.npv])),
             (self.native, self.param, 11),
             (self.native, self.param_mut, NPV_SumExpression([5, self.param_mut])),
             # 8:
-            (self.native, self.var, LinearExpression([5, self.mon_var])),
+            (self.native, self.var, LinearExpression([5, self.var])),
             (self.native, self.mon_native, LinearExpression([5, self.mon_native])),
             (self.native, self.mon_param, LinearExpression([5, self.mon_param])),
             (self.native, self.mon_npv, LinearExpression([5, self.mon_npv])),
             # 12:
             (self.native, self.linear, LinearExpression(self.linear.args + [5])),
             (self.native, self.sum, SumExpression(self.sum.args + [5])),
             (self.native, self.other, SumExpression([5, self.other])),
@@ -526,24 +516,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_npv(self):
         tests = [
             (self.npv, self.invalid, NotImplemented),
-            (self.npv, self.asbinary, LinearExpression([self.npv, self.mon_bin])),
+            (self.npv, self.asbinary, LinearExpression([self.npv, self.bin])),
             (self.npv, self.zero, self.npv),
             (self.npv, self.one, NPV_SumExpression([self.npv, 1])),
             # 4:
             (self.npv, self.native, NPV_SumExpression([self.npv, 5])),
             (self.npv, self.npv, NPV_SumExpression([self.npv, self.npv])),
             (self.npv, self.param, NPV_SumExpression([self.npv, 6])),
             (self.npv, self.param_mut, NPV_SumExpression([self.npv, self.param_mut])),
             # 8:
-            (self.npv, self.var, LinearExpression([self.npv, self.mon_var])),
+            (self.npv, self.var, LinearExpression([self.npv, self.var])),
             (self.npv, self.mon_native, LinearExpression([self.npv, self.mon_native])),
             (self.npv, self.mon_param, LinearExpression([self.npv, self.mon_param])),
             (self.npv, self.mon_npv, LinearExpression([self.npv, self.mon_npv])),
             # 12:
             (self.npv, self.linear, LinearExpression(self.linear.args + [self.npv])),
             (self.npv, self.sum, SumExpression(self.sum.args + [self.npv])),
             (self.npv, self.other, SumExpression([self.npv, self.other])),
@@ -566,24 +556,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_param(self):
         tests = [
             (self.param, self.invalid, NotImplemented),
-            (self.param, self.asbinary, LinearExpression([6, self.mon_bin])),
+            (self.param, self.asbinary, LinearExpression([6, self.bin])),
             (self.param, self.zero, 6),
             (self.param, self.one, 7),
             # 4:
             (self.param, self.native, 11),
             (self.param, self.npv, NPV_SumExpression([6, self.npv])),
             (self.param, self.param, 12),
             (self.param, self.param_mut, NPV_SumExpression([6, self.param_mut])),
             # 8:
-            (self.param, self.var, LinearExpression([6, self.mon_var])),
+            (self.param, self.var, LinearExpression([6, self.var])),
             (self.param, self.mon_native, LinearExpression([6, self.mon_native])),
             (self.param, self.mon_param, LinearExpression([6, self.mon_param])),
             (self.param, self.mon_npv, LinearExpression([6, self.mon_npv])),
             # 12:
             (self.param, self.linear, LinearExpression(self.linear.args + [6])),
             (self.param, self.sum, SumExpression(self.sum.args + [6])),
             (self.param, self.other, SumExpression([6, self.other])),
@@ -601,33 +591,29 @@
 
     def test_add_param_mut(self):
         tests = [
             (self.param_mut, self.invalid, NotImplemented),
             (
                 self.param_mut,
                 self.asbinary,
-                LinearExpression([self.param_mut, self.mon_bin]),
+                LinearExpression([self.param_mut, self.bin]),
             ),
             (self.param_mut, self.zero, self.param_mut),
             (self.param_mut, self.one, NPV_SumExpression([self.param_mut, 1])),
             # 4:
             (self.param_mut, self.native, NPV_SumExpression([self.param_mut, 5])),
             (self.param_mut, self.npv, NPV_SumExpression([self.param_mut, self.npv])),
             (self.param_mut, self.param, NPV_SumExpression([self.param_mut, 6])),
             (
                 self.param_mut,
                 self.param_mut,
                 NPV_SumExpression([self.param_mut, self.param_mut]),
             ),
             # 8:
-            (
-                self.param_mut,
-                self.var,
-                LinearExpression([self.param_mut, self.mon_var]),
-            ),
+            (self.param_mut, self.var, LinearExpression([self.param_mut, self.var])),
             (
                 self.param_mut,
                 self.mon_native,
                 LinearExpression([self.param_mut, self.mon_native]),
             ),
             (
                 self.param_mut,
@@ -670,96 +656,72 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_var(self):
         tests = [
             (self.var, self.invalid, NotImplemented),
-            (self.var, self.asbinary, LinearExpression([self.mon_var, self.mon_bin])),
+            (self.var, self.asbinary, LinearExpression([self.var, self.bin])),
             (self.var, self.zero, self.var),
-            (self.var, self.one, LinearExpression([self.mon_var, 1])),
+            (self.var, self.one, LinearExpression([self.var, 1])),
             # 4:
-            (self.var, self.native, LinearExpression([self.mon_var, 5])),
-            (self.var, self.npv, LinearExpression([self.mon_var, self.npv])),
-            (self.var, self.param, LinearExpression([self.mon_var, 6])),
-            (
-                self.var,
-                self.param_mut,
-                LinearExpression([self.mon_var, self.param_mut]),
-            ),
-            # 8:
-            (self.var, self.var, LinearExpression([self.mon_var, self.mon_var])),
-            (
-                self.var,
-                self.mon_native,
-                LinearExpression([self.mon_var, self.mon_native]),
-            ),
-            (
-                self.var,
-                self.mon_param,
-                LinearExpression([self.mon_var, self.mon_param]),
-            ),
-            (self.var, self.mon_npv, LinearExpression([self.mon_var, self.mon_npv])),
+            (self.var, self.native, LinearExpression([self.var, 5])),
+            (self.var, self.npv, LinearExpression([self.var, self.npv])),
+            (self.var, self.param, LinearExpression([self.var, 6])),
+            (self.var, self.param_mut, LinearExpression([self.var, self.param_mut])),
+            # 8:
+            (self.var, self.var, LinearExpression([self.var, self.var])),
+            (self.var, self.mon_native, LinearExpression([self.var, self.mon_native])),
+            (self.var, self.mon_param, LinearExpression([self.var, self.mon_param])),
+            (self.var, self.mon_npv, LinearExpression([self.var, self.mon_npv])),
             # 12:
-            (
-                self.var,
-                self.linear,
-                LinearExpression(self.linear.args + [self.mon_var]),
-            ),
+            (self.var, self.linear, LinearExpression(self.linear.args + [self.var])),
             (self.var, self.sum, SumExpression(self.sum.args + [self.var])),
             (self.var, self.other, SumExpression([self.var, self.other])),
             (self.var, self.mutable_l0, self.var),
             # 16:
             (
                 self.var,
                 self.mutable_l1,
-                LinearExpression([self.mon_var] + self.mutable_l1.args),
+                LinearExpression([self.var] + self.mutable_l1.args),
             ),
             (
                 self.var,
                 self.mutable_l2,
                 SumExpression(self.mutable_l2.args + [self.var]),
             ),
             (self.var, self.param0, self.var),
-            (self.var, self.param1, LinearExpression([self.mon_var, 1])),
+            (self.var, self.param1, LinearExpression([self.var, 1])),
             # 20:
-            (
-                self.var,
-                self.mutable_l3,
-                LinearExpression([MonomialTermExpression((1, self.var)), self.npv]),
-            ),
+            (self.var, self.mutable_l3, LinearExpression([self.var, self.npv])),
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_mon_native(self):
         tests = [
             (self.mon_native, self.invalid, NotImplemented),
             (
                 self.mon_native,
                 self.asbinary,
-                LinearExpression([self.mon_native, self.mon_bin]),
+                LinearExpression([self.mon_native, self.bin]),
             ),
             (self.mon_native, self.zero, self.mon_native),
             (self.mon_native, self.one, LinearExpression([self.mon_native, 1])),
             # 4:
             (self.mon_native, self.native, LinearExpression([self.mon_native, 5])),
             (self.mon_native, self.npv, LinearExpression([self.mon_native, self.npv])),
             (self.mon_native, self.param, LinearExpression([self.mon_native, 6])),
             (
                 self.mon_native,
                 self.param_mut,
                 LinearExpression([self.mon_native, self.param_mut]),
             ),
             # 8:
-            (
-                self.mon_native,
-                self.var,
-                LinearExpression([self.mon_native, self.mon_var]),
-            ),
+            (self.mon_native, self.var, LinearExpression([self.mon_native, self.var])),
             (
                 self.mon_native,
                 self.mon_native,
                 LinearExpression([self.mon_native, self.mon_native]),
             ),
             (
                 self.mon_native,
@@ -809,33 +771,29 @@
 
     def test_add_mon_param(self):
         tests = [
             (self.mon_param, self.invalid, NotImplemented),
             (
                 self.mon_param,
                 self.asbinary,
-                LinearExpression([self.mon_param, self.mon_bin]),
+                LinearExpression([self.mon_param, self.bin]),
             ),
             (self.mon_param, self.zero, self.mon_param),
             (self.mon_param, self.one, LinearExpression([self.mon_param, 1])),
             # 4:
             (self.mon_param, self.native, LinearExpression([self.mon_param, 5])),
             (self.mon_param, self.npv, LinearExpression([self.mon_param, self.npv])),
             (self.mon_param, self.param, LinearExpression([self.mon_param, 6])),
             (
                 self.mon_param,
                 self.param_mut,
                 LinearExpression([self.mon_param, self.param_mut]),
             ),
             # 8:
-            (
-                self.mon_param,
-                self.var,
-                LinearExpression([self.mon_param, self.mon_var]),
-            ),
+            (self.mon_param, self.var, LinearExpression([self.mon_param, self.var])),
             (
                 self.mon_param,
                 self.mon_native,
                 LinearExpression([self.mon_param, self.mon_native]),
             ),
             (
                 self.mon_param,
@@ -878,32 +836,28 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_mon_npv(self):
         tests = [
             (self.mon_npv, self.invalid, NotImplemented),
-            (
-                self.mon_npv,
-                self.asbinary,
-                LinearExpression([self.mon_npv, self.mon_bin]),
-            ),
+            (self.mon_npv, self.asbinary, LinearExpression([self.mon_npv, self.bin])),
             (self.mon_npv, self.zero, self.mon_npv),
             (self.mon_npv, self.one, LinearExpression([self.mon_npv, 1])),
             # 4:
             (self.mon_npv, self.native, LinearExpression([self.mon_npv, 5])),
             (self.mon_npv, self.npv, LinearExpression([self.mon_npv, self.npv])),
             (self.mon_npv, self.param, LinearExpression([self.mon_npv, 6])),
             (
                 self.mon_npv,
                 self.param_mut,
                 LinearExpression([self.mon_npv, self.param_mut]),
             ),
             # 8:
-            (self.mon_npv, self.var, LinearExpression([self.mon_npv, self.mon_var])),
+            (self.mon_npv, self.var, LinearExpression([self.mon_npv, self.var])),
             (
                 self.mon_npv,
                 self.mon_native,
                 LinearExpression([self.mon_npv, self.mon_native]),
             ),
             (
                 self.mon_npv,
@@ -945,33 +899,29 @@
 
     def test_add_linear(self):
         tests = [
             (self.linear, self.invalid, NotImplemented),
             (
                 self.linear,
                 self.asbinary,
-                LinearExpression(self.linear.args + [self.mon_bin]),
+                LinearExpression(self.linear.args + [self.bin]),
             ),
             (self.linear, self.zero, self.linear),
             (self.linear, self.one, LinearExpression(self.linear.args + [1])),
             # 4:
             (self.linear, self.native, LinearExpression(self.linear.args + [5])),
             (self.linear, self.npv, LinearExpression(self.linear.args + [self.npv])),
             (self.linear, self.param, LinearExpression(self.linear.args + [6])),
             (
                 self.linear,
                 self.param_mut,
                 LinearExpression(self.linear.args + [self.param_mut]),
             ),
             # 8:
-            (
-                self.linear,
-                self.var,
-                LinearExpression(self.linear.args + [self.mon_var]),
-            ),
+            (self.linear, self.var, LinearExpression(self.linear.args + [self.var])),
             (
                 self.linear,
                 self.mon_native,
                 LinearExpression(self.linear.args + [self.mon_native]),
             ),
             (
                 self.linear,
@@ -1130,15 +1080,15 @@
 
     def test_add_mutable_l1(self):
         tests = [
             (self.mutable_l1, self.invalid, NotImplemented),
             (
                 self.mutable_l1,
                 self.asbinary,
-                LinearExpression(self.mutable_l1.args + [self.mon_bin]),
+                LinearExpression(self.mutable_l1.args + [self.bin]),
             ),
             (self.mutable_l1, self.zero, self.mon_npv),
             (self.mutable_l1, self.one, LinearExpression(self.mutable_l1.args + [1])),
             # 4:
             (
                 self.mutable_l1,
                 self.native,
@@ -1155,15 +1105,15 @@
                 self.param_mut,
                 LinearExpression(self.mutable_l1.args + [self.param_mut]),
             ),
             # 8:
             (
                 self.mutable_l1,
                 self.var,
-                LinearExpression(self.mutable_l1.args + [self.mon_var]),
+                LinearExpression(self.mutable_l1.args + [self.var]),
             ),
             (
                 self.mutable_l1,
                 self.mon_native,
                 LinearExpression(self.mutable_l1.args + [self.mon_native]),
             ),
             (
@@ -1337,24 +1287,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_param1(self):
         tests = [
             (self.param1, self.invalid, NotImplemented),
-            (self.param1, self.asbinary, LinearExpression([1, self.mon_bin])),
+            (self.param1, self.asbinary, LinearExpression([1, self.bin])),
             (self.param1, self.zero, 1),
             (self.param1, self.one, 2),
             # 4:
             (self.param1, self.native, 6),
             (self.param1, self.npv, NPV_SumExpression([1, self.npv])),
             (self.param1, self.param, 7),
             (self.param1, self.param_mut, NPV_SumExpression([1, self.param_mut])),
             # 8:
-            (self.param1, self.var, LinearExpression([1, self.mon_var])),
+            (self.param1, self.var, LinearExpression([1, self.var])),
             (self.param1, self.mon_native, LinearExpression([1, self.mon_native])),
             (self.param1, self.mon_param, LinearExpression([1, self.mon_param])),
             (self.param1, self.mon_npv, LinearExpression([1, self.mon_npv])),
             # 12:
             (self.param1, self.linear, LinearExpression(self.linear.args + [1])),
             (self.param1, self.sum, SumExpression(self.sum.args + [1])),
             (self.param1, self.other, SumExpression([1, self.other])),
@@ -1376,15 +1326,15 @@
 
     def test_add_mutable_l3(self):
         tests = [
             (self.mutable_l3, self.invalid, NotImplemented),
             (
                 self.mutable_l3,
                 self.asbinary,
-                LinearExpression(self.mutable_l3.args + [self.mon_bin]),
+                LinearExpression(self.mutable_l3.args + [self.bin]),
             ),
             (self.mutable_l3, self.zero, self.npv),
             (self.mutable_l3, self.one, NPV_SumExpression(self.mutable_l3.args + [1])),
             # 4:
             (
                 self.mutable_l3,
                 self.native,
@@ -1405,15 +1355,15 @@
                 self.param_mut,
                 NPV_SumExpression(self.mutable_l3.args + [self.param_mut]),
             ),
             # 8:
             (
                 self.mutable_l3,
                 self.var,
-                LinearExpression(self.mutable_l3.args + [self.mon_var]),
+                LinearExpression(self.mutable_l3.args + [self.var]),
             ),
             (
                 self.mutable_l3,
                 self.mon_native,
                 LinearExpression(self.mutable_l3.args + [self.mon_native]),
             ),
             (
@@ -1511,64 +1461,64 @@
 
     def test_sub_asbinary(self):
         tests = [
             (self.asbinary, self.invalid, NotImplemented),
             # BooleanVar objects do not support addition
             (self.asbinary, self.asbinary, NotImplemented),
             (self.asbinary, self.zero, self.bin),
-            (self.asbinary, self.one, LinearExpression([self.mon_bin, -1])),
+            (self.asbinary, self.one, LinearExpression([self.bin, -1])),
             # 4:
-            (self.asbinary, self.native, LinearExpression([self.mon_bin, -5])),
-            (self.asbinary, self.npv, LinearExpression([self.mon_bin, self.minus_npv])),
-            (self.asbinary, self.param, LinearExpression([self.mon_bin, -6])),
+            (self.asbinary, self.native, LinearExpression([self.bin, -5])),
+            (self.asbinary, self.npv, LinearExpression([self.bin, self.minus_npv])),
+            (self.asbinary, self.param, LinearExpression([self.bin, -6])),
             (
                 self.asbinary,
                 self.param_mut,
-                LinearExpression([self.mon_bin, self.minus_param_mut]),
+                LinearExpression([self.bin, self.minus_param_mut]),
             ),
             # 8:
-            (self.asbinary, self.var, LinearExpression([self.mon_bin, self.minus_var])),
+            (self.asbinary, self.var, LinearExpression([self.bin, self.minus_var])),
             (
                 self.asbinary,
                 self.mon_native,
-                LinearExpression([self.mon_bin, self.minus_mon_native]),
+                LinearExpression([self.bin, self.minus_mon_native]),
             ),
             (
                 self.asbinary,
                 self.mon_param,
-                LinearExpression([self.mon_bin, self.minus_mon_param]),
+                LinearExpression([self.bin, self.minus_mon_param]),
             ),
             (
                 self.asbinary,
                 self.mon_npv,
-                LinearExpression([self.mon_bin, self.minus_mon_npv]),
+                LinearExpression([self.bin, self.minus_mon_npv]),
             ),
             # 12:
             (self.asbinary, self.linear, SumExpression([self.bin, self.minus_linear])),
             (self.asbinary, self.sum, SumExpression([self.bin, self.minus_sum])),
             (self.asbinary, self.other, SumExpression([self.bin, self.minus_other])),
             (self.asbinary, self.mutable_l0, self.bin),
             # 16:
             (
                 self.asbinary,
                 self.mutable_l1,
-                LinearExpression([self.mon_bin, self.minus_mon_npv]),
+                LinearExpression([self.bin, self.minus_mon_npv]),
             ),
             (
                 self.asbinary,
                 self.mutable_l2,
                 SumExpression([self.bin, self.minus_mutable_l2]),
             ),
             (self.asbinary, self.param0, self.bin),
-            (self.asbinary, self.param1, LinearExpression([self.mon_bin, -1])),
+            (self.asbinary, self.param1, LinearExpression([self.bin, -1])),
             # 20:
             (
                 self.asbinary,
                 self.mutable_l3,
-                LinearExpression([self.mon_bin, self.minus_npv]),
+                LinearExpression([self.bin, self.minus_npv]),
             ),
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_zero(self):
         tests = [
@@ -1833,71 +1783,63 @@
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_var(self):
         tests = [
             (self.var, self.invalid, NotImplemented),
-            (self.var, self.asbinary, LinearExpression([self.mon_var, self.minus_bin])),
+            (self.var, self.asbinary, LinearExpression([self.var, self.minus_bin])),
             (self.var, self.zero, self.var),
-            (self.var, self.one, LinearExpression([self.mon_var, -1])),
+            (self.var, self.one, LinearExpression([self.var, -1])),
             # 4:
-            (self.var, self.native, LinearExpression([self.mon_var, -5])),
-            (self.var, self.npv, LinearExpression([self.mon_var, self.minus_npv])),
-            (self.var, self.param, LinearExpression([self.mon_var, -6])),
+            (self.var, self.native, LinearExpression([self.var, -5])),
+            (self.var, self.npv, LinearExpression([self.var, self.minus_npv])),
+            (self.var, self.param, LinearExpression([self.var, -6])),
             (
                 self.var,
                 self.param_mut,
-                LinearExpression([self.mon_var, self.minus_param_mut]),
+                LinearExpression([self.var, self.minus_param_mut]),
             ),
             # 8:
-            (self.var, self.var, LinearExpression([self.mon_var, self.minus_var])),
+            (self.var, self.var, LinearExpression([self.var, self.minus_var])),
             (
                 self.var,
                 self.mon_native,
-                LinearExpression([self.mon_var, self.minus_mon_native]),
+                LinearExpression([self.var, self.minus_mon_native]),
             ),
             (
                 self.var,
                 self.mon_param,
-                LinearExpression([self.mon_var, self.minus_mon_param]),
-            ),
-            (
-                self.var,
-                self.mon_npv,
-                LinearExpression([self.mon_var, self.minus_mon_npv]),
+                LinearExpression([self.var, self.minus_mon_param]),
             ),
+            (self.var, self.mon_npv, LinearExpression([self.var, self.minus_mon_npv])),
             # 12:
             (
                 self.var,
                 self.linear,
                 SumExpression([self.var, NegationExpression((self.linear,))]),
             ),
             (self.var, self.sum, SumExpression([self.var, self.minus_sum])),
             (self.var, self.other, SumExpression([self.var, self.minus_other])),
             (self.var, self.mutable_l0, self.var),
             # 16:
             (
                 self.var,
                 self.mutable_l1,
-                LinearExpression([self.mon_var, self.minus_mon_npv]),
+                LinearExpression([self.var, self.minus_mon_npv]),
             ),
             (
                 self.var,
                 self.mutable_l2,
                 SumExpression([self.var, self.minus_mutable_l2]),
             ),
             (self.var, self.param0, self.var),
-            (self.var, self.param1, LinearExpression([self.mon_var, -1])),
+            (self.var, self.param1, LinearExpression([self.var, -1])),
             # 20:
-            (
-                self.var,
-                self.mutable_l3,
-                LinearExpression([self.mon_var, self.minus_npv]),
-            ),
+            (self.var, self.mutable_l3, LinearExpression([self.var, self.minus_npv])),
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_mon_native(self):
         tests = [
             (self.mon_native, self.invalid, NotImplemented),
@@ -6507,24 +6449,24 @@
     #
     #
 
     def test_mutable_nvp_iadd(self):
         mutable_npv = _MutableNPVSumExpression([])
         tests = [
             (mutable_npv, self.invalid, NotImplemented),
-            (mutable_npv, self.asbinary, _MutableLinearExpression([self.mon_bin])),
+            (mutable_npv, self.asbinary, _MutableLinearExpression([self.bin])),
             (mutable_npv, self.zero, _MutableNPVSumExpression([])),
             (mutable_npv, self.one, _MutableNPVSumExpression([1])),
             # 4:
             (mutable_npv, self.native, _MutableNPVSumExpression([5])),
             (mutable_npv, self.npv, _MutableNPVSumExpression([self.npv])),
             (mutable_npv, self.param, _MutableNPVSumExpression([6])),
             (mutable_npv, self.param_mut, _MutableNPVSumExpression([self.param_mut])),
             # 8:
-            (mutable_npv, self.var, _MutableLinearExpression([self.mon_var])),
+            (mutable_npv, self.var, _MutableLinearExpression([self.var])),
             (mutable_npv, self.mon_native, _MutableLinearExpression([self.mon_native])),
             (mutable_npv, self.mon_param, _MutableLinearExpression([self.mon_param])),
             (mutable_npv, self.mon_npv, _MutableLinearExpression([self.mon_npv])),
             # 12:
             (mutable_npv, self.linear, _MutableLinearExpression(self.linear.args)),
             (mutable_npv, self.sum, _MutableSumExpression(self.sum.args)),
             (mutable_npv, self.other, _MutableSumExpression([self.other])),
@@ -6542,28 +6484,28 @@
             (mutable_npv, self.mutable_l3, _MutableNPVSumExpression([self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
         mutable_npv = _MutableNPVSumExpression([10])
         tests = [
             (mutable_npv, self.invalid, NotImplemented),
-            (mutable_npv, self.asbinary, _MutableLinearExpression([10, self.mon_bin])),
+            (mutable_npv, self.asbinary, _MutableLinearExpression([10, self.bin])),
             (mutable_npv, self.zero, _MutableNPVSumExpression([10])),
-            (mutable_npv, self.one, _MutableNPVSumExpression([10, 1])),
+            (mutable_npv, self.one, _MutableNPVSumExpression([11])),
             # 4:
-            (mutable_npv, self.native, _MutableNPVSumExpression([10, 5])),
+            (mutable_npv, self.native, _MutableNPVSumExpression([15])),
             (mutable_npv, self.npv, _MutableNPVSumExpression([10, self.npv])),
-            (mutable_npv, self.param, _MutableNPVSumExpression([10, 6])),
+            (mutable_npv, self.param, _MutableNPVSumExpression([16])),
             (
                 mutable_npv,
                 self.param_mut,
                 _MutableNPVSumExpression([10, self.param_mut]),
             ),
             # 8:
-            (mutable_npv, self.var, _MutableLinearExpression([10, self.mon_var])),
+            (mutable_npv, self.var, _MutableLinearExpression([10, self.var])),
             (
                 mutable_npv,
                 self.mon_native,
                 _MutableLinearExpression([10, self.mon_native]),
             ),
             (
                 mutable_npv,
@@ -6588,34 +6530,34 @@
             ),
             (
                 mutable_npv,
                 self.mutable_l2,
                 _MutableSumExpression([10] + self.mutable_l2.args),
             ),
             (mutable_npv, self.param0, _MutableNPVSumExpression([10])),
-            (mutable_npv, self.param1, _MutableNPVSumExpression([10, 1])),
+            (mutable_npv, self.param1, _MutableNPVSumExpression([11])),
             # 20:
             (mutable_npv, self.mutable_l3, _MutableNPVSumExpression([10, self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
     def test_mutable_lin_iadd(self):
         mutable_lin = _MutableLinearExpression([])
         tests = [
             (mutable_lin, self.invalid, NotImplemented),
-            (mutable_lin, self.asbinary, _MutableLinearExpression([self.mon_bin])),
+            (mutable_lin, self.asbinary, _MutableLinearExpression([self.bin])),
             (mutable_lin, self.zero, _MutableLinearExpression([])),
             (mutable_lin, self.one, _MutableLinearExpression([1])),
             # 4:
             (mutable_lin, self.native, _MutableLinearExpression([5])),
             (mutable_lin, self.npv, _MutableLinearExpression([self.npv])),
             (mutable_lin, self.param, _MutableLinearExpression([6])),
             (mutable_lin, self.param_mut, _MutableLinearExpression([self.param_mut])),
             # 8:
-            (mutable_lin, self.var, _MutableLinearExpression([self.mon_var])),
+            (mutable_lin, self.var, _MutableLinearExpression([self.var])),
             (mutable_lin, self.mon_native, _MutableLinearExpression([self.mon_native])),
             (mutable_lin, self.mon_param, _MutableLinearExpression([self.mon_param])),
             (mutable_lin, self.mon_npv, _MutableLinearExpression([self.mon_npv])),
             # 12:
             (mutable_lin, self.linear, _MutableLinearExpression(self.linear.args)),
             (mutable_lin, self.sum, _MutableSumExpression(self.sum.args)),
             (mutable_lin, self.other, _MutableSumExpression([self.other])),
@@ -6630,89 +6572,77 @@
             (mutable_lin, self.param0, _MutableLinearExpression([])),
             (mutable_lin, self.param1, _MutableLinearExpression([1])),
             # 20:
             (mutable_lin, self.mutable_l3, _MutableLinearExpression([self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
-        mutable_lin = _MutableLinearExpression([self.mon_bin])
+        mutable_lin = _MutableLinearExpression([self.bin])
         tests = [
             (mutable_lin, self.invalid, NotImplemented),
             (
                 mutable_lin,
                 self.asbinary,
-                _MutableLinearExpression([self.mon_bin, self.mon_bin]),
+                _MutableLinearExpression([self.bin, self.bin]),
             ),
-            (mutable_lin, self.zero, _MutableLinearExpression([self.mon_bin])),
-            (mutable_lin, self.one, _MutableLinearExpression([self.mon_bin, 1])),
+            (mutable_lin, self.zero, _MutableLinearExpression([self.bin])),
+            (mutable_lin, self.one, _MutableLinearExpression([self.bin, 1])),
             # 4:
-            (mutable_lin, self.native, _MutableLinearExpression([self.mon_bin, 5])),
-            (mutable_lin, self.npv, _MutableLinearExpression([self.mon_bin, self.npv])),
-            (mutable_lin, self.param, _MutableLinearExpression([self.mon_bin, 6])),
+            (mutable_lin, self.native, _MutableLinearExpression([self.bin, 5])),
+            (mutable_lin, self.npv, _MutableLinearExpression([self.bin, self.npv])),
+            (mutable_lin, self.param, _MutableLinearExpression([self.bin, 6])),
             (
                 mutable_lin,
                 self.param_mut,
-                _MutableLinearExpression([self.mon_bin, self.param_mut]),
+                _MutableLinearExpression([self.bin, self.param_mut]),
             ),
             # 8:
-            (
-                mutable_lin,
-                self.var,
-                _MutableLinearExpression([self.mon_bin, self.mon_var]),
-            ),
+            (mutable_lin, self.var, _MutableLinearExpression([self.bin, self.var])),
             (
                 mutable_lin,
                 self.mon_native,
-                _MutableLinearExpression([self.mon_bin, self.mon_native]),
+                _MutableLinearExpression([self.bin, self.mon_native]),
             ),
             (
                 mutable_lin,
                 self.mon_param,
-                _MutableLinearExpression([self.mon_bin, self.mon_param]),
+                _MutableLinearExpression([self.bin, self.mon_param]),
             ),
             (
                 mutable_lin,
                 self.mon_npv,
-                _MutableLinearExpression([self.mon_bin, self.mon_npv]),
+                _MutableLinearExpression([self.bin, self.mon_npv]),
             ),
             # 12:
             (
                 mutable_lin,
                 self.linear,
-                _MutableLinearExpression([self.mon_bin] + self.linear.args),
-            ),
-            (
-                mutable_lin,
-                self.sum,
-                _MutableSumExpression([self.mon_bin] + self.sum.args),
-            ),
-            (
-                mutable_lin,
-                self.other,
-                _MutableSumExpression([self.mon_bin, self.other]),
+                _MutableLinearExpression([self.bin] + self.linear.args),
             ),
-            (mutable_lin, self.mutable_l0, _MutableLinearExpression([self.mon_bin])),
+            (mutable_lin, self.sum, _MutableSumExpression([self.bin] + self.sum.args)),
+            (mutable_lin, self.other, _MutableSumExpression([self.bin, self.other])),
+            (mutable_lin, self.mutable_l0, _MutableLinearExpression([self.bin])),
             # 16:
             (
                 mutable_lin,
                 self.mutable_l1,
-                _MutableLinearExpression([self.mon_bin] + self.mutable_l1.args),
+                _MutableLinearExpression([self.bin] + self.mutable_l1.args),
             ),
             (
                 mutable_lin,
                 self.mutable_l2,
-                _MutableSumExpression([self.mon_bin] + self.mutable_l2.args),
+                _MutableSumExpression([self.bin] + self.mutable_l2.args),
             ),
-            (mutable_lin, self.param0, _MutableLinearExpression([self.mon_bin])),
-            (mutable_lin, self.param1, _MutableLinearExpression([self.mon_bin, 1])),
+            (mutable_lin, self.param0, _MutableLinearExpression([self.bin])),
+            (mutable_lin, self.param1, _MutableLinearExpression([self.bin, 1])),
             # 20:
             (
                 mutable_lin,
                 self.mutable_l3,
-                _MutableLinearExpression([self.mon_bin, self.npv]),
+                _MutableLinearExpression([self.bin, self.npv]),
             ),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
     def test_mutable_sum_iadd(self):
         mutable_sum = _MutableSumExpression([])
         tests = [
@@ -6850,15 +6780,15 @@
         e = abs(obj)
         assertExpressionsEqual(self, AbsExpression((self.var,)), e)
 
         e = obj**2
         assertExpressionsEqual(self, PowExpression((self.var, 2)), e)
 
         e = obj + obj
-        assertExpressionsEqual(self, LinearExpression((self.mon_var, self.mon_var)), e)
+        assertExpressionsEqual(self, LinearExpression((self.var, self.var)), e)
 
     def test_categorize_arg_type(self):
         class CustomAsNumeric(NumericValue):
             def __init__(self, val):
                 self._value = val
 
             def is_numeric_type(self):
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numeric_expr_zerofilter.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numeric_expr_zerofilter.py`

 * *Files 4% similar despite different names*

```diff
@@ -98,69 +98,61 @@
 
     def test_add_asbinary(self):
         tests = [
             (self.asbinary, self.invalid, NotImplemented),
             # BooleanVar objects do not support addition
             (self.asbinary, self.asbinary, NotImplemented),
             (self.asbinary, self.zero, self.bin),
-            (self.asbinary, self.one, LinearExpression([self.mon_bin, 1])),
+            (self.asbinary, self.one, LinearExpression([self.bin, 1])),
             # 4:
-            (self.asbinary, self.native, LinearExpression([self.mon_bin, 5])),
-            (self.asbinary, self.npv, LinearExpression([self.mon_bin, self.npv])),
-            (self.asbinary, self.param, LinearExpression([self.mon_bin, 6])),
+            (self.asbinary, self.native, LinearExpression([self.bin, 5])),
+            (self.asbinary, self.npv, LinearExpression([self.bin, self.npv])),
+            (self.asbinary, self.param, LinearExpression([self.bin, 6])),
             (
                 self.asbinary,
                 self.param_mut,
-                LinearExpression([self.mon_bin, self.param_mut]),
+                LinearExpression([self.bin, self.param_mut]),
             ),
             # 8:
-            (self.asbinary, self.var, LinearExpression([self.mon_bin, self.mon_var])),
+            (self.asbinary, self.var, LinearExpression([self.bin, self.var])),
             (
                 self.asbinary,
                 self.mon_native,
-                LinearExpression([self.mon_bin, self.mon_native]),
+                LinearExpression([self.bin, self.mon_native]),
             ),
             (
                 self.asbinary,
                 self.mon_param,
-                LinearExpression([self.mon_bin, self.mon_param]),
-            ),
-            (
-                self.asbinary,
-                self.mon_npv,
-                LinearExpression([self.mon_bin, self.mon_npv]),
+                LinearExpression([self.bin, self.mon_param]),
             ),
+            (self.asbinary, self.mon_npv, LinearExpression([self.bin, self.mon_npv])),
             # 12:
             (
                 self.asbinary,
                 self.linear,
-                LinearExpression(self.linear.args + [self.mon_bin]),
+                LinearExpression(self.linear.args + [self.bin]),
             ),
             (self.asbinary, self.sum, SumExpression(self.sum.args + [self.bin])),
             (self.asbinary, self.other, SumExpression([self.bin, self.other])),
             (self.asbinary, self.mutable_l0, self.bin),
             # 16:
             (
                 self.asbinary,
                 self.mutable_l1,
-                LinearExpression([self.mon_bin, self.mon_npv]),
+                LinearExpression([self.bin, self.mon_npv]),
             ),
             (
                 self.asbinary,
                 self.mutable_l2,
                 SumExpression(self.mutable_l2.args + [self.bin]),
             ),
             (self.asbinary, self.param0, self.bin),
-            (self.asbinary, self.param1, LinearExpression([self.mon_bin, 1])),
+            (self.asbinary, self.param1, LinearExpression([self.bin, 1])),
             # 20:
-            (
-                self.asbinary,
-                self.mutable_l3,
-                LinearExpression([self.mon_bin, self.npv]),
-            ),
+            (self.asbinary, self.mutable_l3, LinearExpression([self.bin, self.npv])),
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_zero(self):
         tests = [
             (self.zero, self.invalid, NotImplemented),
@@ -192,24 +184,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_one(self):
         tests = [
             (self.one, self.invalid, NotImplemented),
-            (self.one, self.asbinary, LinearExpression([1, self.mon_bin])),
+            (self.one, self.asbinary, LinearExpression([1, self.bin])),
             (self.one, self.zero, 1),
             (self.one, self.one, 2),
             # 4:
             (self.one, self.native, 6),
             (self.one, self.npv, NPV_SumExpression([1, self.npv])),
             (self.one, self.param, 7),
             (self.one, self.param_mut, NPV_SumExpression([1, self.param_mut])),
             # 8:
-            (self.one, self.var, LinearExpression([1, self.mon_var])),
+            (self.one, self.var, LinearExpression([1, self.var])),
             (self.one, self.mon_native, LinearExpression([1, self.mon_native])),
             (self.one, self.mon_param, LinearExpression([1, self.mon_param])),
             (self.one, self.mon_npv, LinearExpression([1, self.mon_npv])),
             # 12:
             (self.one, self.linear, LinearExpression(self.linear.args + [1])),
             (self.one, self.sum, SumExpression(self.sum.args + [1])),
             (self.one, self.other, SumExpression([1, self.other])),
@@ -224,24 +216,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_native(self):
         tests = [
             (self.native, self.invalid, NotImplemented),
-            (self.native, self.asbinary, LinearExpression([5, self.mon_bin])),
+            (self.native, self.asbinary, LinearExpression([5, self.bin])),
             (self.native, self.zero, 5),
             (self.native, self.one, 6),
             # 4:
             (self.native, self.native, 10),
             (self.native, self.npv, NPV_SumExpression([5, self.npv])),
             (self.native, self.param, 11),
             (self.native, self.param_mut, NPV_SumExpression([5, self.param_mut])),
             # 8:
-            (self.native, self.var, LinearExpression([5, self.mon_var])),
+            (self.native, self.var, LinearExpression([5, self.var])),
             (self.native, self.mon_native, LinearExpression([5, self.mon_native])),
             (self.native, self.mon_param, LinearExpression([5, self.mon_param])),
             (self.native, self.mon_npv, LinearExpression([5, self.mon_npv])),
             # 12:
             (self.native, self.linear, LinearExpression(self.linear.args + [5])),
             (self.native, self.sum, SumExpression(self.sum.args + [5])),
             (self.native, self.other, SumExpression([5, self.other])),
@@ -260,24 +252,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_npv(self):
         tests = [
             (self.npv, self.invalid, NotImplemented),
-            (self.npv, self.asbinary, LinearExpression([self.npv, self.mon_bin])),
+            (self.npv, self.asbinary, LinearExpression([self.npv, self.bin])),
             (self.npv, self.zero, self.npv),
             (self.npv, self.one, NPV_SumExpression([self.npv, 1])),
             # 4:
             (self.npv, self.native, NPV_SumExpression([self.npv, 5])),
             (self.npv, self.npv, NPV_SumExpression([self.npv, self.npv])),
             (self.npv, self.param, NPV_SumExpression([self.npv, 6])),
             (self.npv, self.param_mut, NPV_SumExpression([self.npv, self.param_mut])),
             # 8:
-            (self.npv, self.var, LinearExpression([self.npv, self.mon_var])),
+            (self.npv, self.var, LinearExpression([self.npv, self.var])),
             (self.npv, self.mon_native, LinearExpression([self.npv, self.mon_native])),
             (self.npv, self.mon_param, LinearExpression([self.npv, self.mon_param])),
             (self.npv, self.mon_npv, LinearExpression([self.npv, self.mon_npv])),
             # 12:
             (self.npv, self.linear, LinearExpression(self.linear.args + [self.npv])),
             (self.npv, self.sum, SumExpression(self.sum.args + [self.npv])),
             (self.npv, self.other, SumExpression([self.npv, self.other])),
@@ -300,24 +292,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_param(self):
         tests = [
             (self.param, self.invalid, NotImplemented),
-            (self.param, self.asbinary, LinearExpression([6, self.mon_bin])),
+            (self.param, self.asbinary, LinearExpression([6, self.bin])),
             (self.param, self.zero, 6),
             (self.param, self.one, 7),
             # 4:
             (self.param, self.native, 11),
             (self.param, self.npv, NPV_SumExpression([6, self.npv])),
             (self.param, self.param, 12),
             (self.param, self.param_mut, NPV_SumExpression([6, self.param_mut])),
             # 8:
-            (self.param, self.var, LinearExpression([6, self.mon_var])),
+            (self.param, self.var, LinearExpression([6, self.var])),
             (self.param, self.mon_native, LinearExpression([6, self.mon_native])),
             (self.param, self.mon_param, LinearExpression([6, self.mon_param])),
             (self.param, self.mon_npv, LinearExpression([6, self.mon_npv])),
             # 12:
             (self.param, self.linear, LinearExpression(self.linear.args + [6])),
             (self.param, self.sum, SumExpression(self.sum.args + [6])),
             (self.param, self.other, SumExpression([6, self.other])),
@@ -335,33 +327,29 @@
 
     def test_add_param_mut(self):
         tests = [
             (self.param_mut, self.invalid, NotImplemented),
             (
                 self.param_mut,
                 self.asbinary,
-                LinearExpression([self.param_mut, self.mon_bin]),
+                LinearExpression([self.param_mut, self.bin]),
             ),
             (self.param_mut, self.zero, self.param_mut),
             (self.param_mut, self.one, NPV_SumExpression([self.param_mut, 1])),
             # 4:
             (self.param_mut, self.native, NPV_SumExpression([self.param_mut, 5])),
             (self.param_mut, self.npv, NPV_SumExpression([self.param_mut, self.npv])),
             (self.param_mut, self.param, NPV_SumExpression([self.param_mut, 6])),
             (
                 self.param_mut,
                 self.param_mut,
                 NPV_SumExpression([self.param_mut, self.param_mut]),
             ),
             # 8:
-            (
-                self.param_mut,
-                self.var,
-                LinearExpression([self.param_mut, self.mon_var]),
-            ),
+            (self.param_mut, self.var, LinearExpression([self.param_mut, self.var])),
             (
                 self.param_mut,
                 self.mon_native,
                 LinearExpression([self.param_mut, self.mon_native]),
             ),
             (
                 self.param_mut,
@@ -404,96 +392,72 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_var(self):
         tests = [
             (self.var, self.invalid, NotImplemented),
-            (self.var, self.asbinary, LinearExpression([self.mon_var, self.mon_bin])),
+            (self.var, self.asbinary, LinearExpression([self.var, self.bin])),
             (self.var, self.zero, self.var),
-            (self.var, self.one, LinearExpression([self.mon_var, 1])),
+            (self.var, self.one, LinearExpression([self.var, 1])),
             # 4:
-            (self.var, self.native, LinearExpression([self.mon_var, 5])),
-            (self.var, self.npv, LinearExpression([self.mon_var, self.npv])),
-            (self.var, self.param, LinearExpression([self.mon_var, 6])),
-            (
-                self.var,
-                self.param_mut,
-                LinearExpression([self.mon_var, self.param_mut]),
-            ),
-            # 8:
-            (self.var, self.var, LinearExpression([self.mon_var, self.mon_var])),
-            (
-                self.var,
-                self.mon_native,
-                LinearExpression([self.mon_var, self.mon_native]),
-            ),
-            (
-                self.var,
-                self.mon_param,
-                LinearExpression([self.mon_var, self.mon_param]),
-            ),
-            (self.var, self.mon_npv, LinearExpression([self.mon_var, self.mon_npv])),
+            (self.var, self.native, LinearExpression([self.var, 5])),
+            (self.var, self.npv, LinearExpression([self.var, self.npv])),
+            (self.var, self.param, LinearExpression([self.var, 6])),
+            (self.var, self.param_mut, LinearExpression([self.var, self.param_mut])),
+            # 8:
+            (self.var, self.var, LinearExpression([self.var, self.var])),
+            (self.var, self.mon_native, LinearExpression([self.var, self.mon_native])),
+            (self.var, self.mon_param, LinearExpression([self.var, self.mon_param])),
+            (self.var, self.mon_npv, LinearExpression([self.var, self.mon_npv])),
             # 12:
-            (
-                self.var,
-                self.linear,
-                LinearExpression(self.linear.args + [self.mon_var]),
-            ),
+            (self.var, self.linear, LinearExpression(self.linear.args + [self.var])),
             (self.var, self.sum, SumExpression(self.sum.args + [self.var])),
             (self.var, self.other, SumExpression([self.var, self.other])),
             (self.var, self.mutable_l0, self.var),
             # 16:
             (
                 self.var,
                 self.mutable_l1,
-                LinearExpression([self.mon_var] + self.mutable_l1.args),
+                LinearExpression([self.var] + self.mutable_l1.args),
             ),
             (
                 self.var,
                 self.mutable_l2,
                 SumExpression(self.mutable_l2.args + [self.var]),
             ),
             (self.var, self.param0, self.var),
-            (self.var, self.param1, LinearExpression([self.mon_var, 1])),
+            (self.var, self.param1, LinearExpression([self.var, 1])),
             # 20:
-            (
-                self.var,
-                self.mutable_l3,
-                LinearExpression([MonomialTermExpression((1, self.var)), self.npv]),
-            ),
+            (self.var, self.mutable_l3, LinearExpression([self.var, self.npv])),
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_mon_native(self):
         tests = [
             (self.mon_native, self.invalid, NotImplemented),
             (
                 self.mon_native,
                 self.asbinary,
-                LinearExpression([self.mon_native, self.mon_bin]),
+                LinearExpression([self.mon_native, self.bin]),
             ),
             (self.mon_native, self.zero, self.mon_native),
             (self.mon_native, self.one, LinearExpression([self.mon_native, 1])),
             # 4:
             (self.mon_native, self.native, LinearExpression([self.mon_native, 5])),
             (self.mon_native, self.npv, LinearExpression([self.mon_native, self.npv])),
             (self.mon_native, self.param, LinearExpression([self.mon_native, 6])),
             (
                 self.mon_native,
                 self.param_mut,
                 LinearExpression([self.mon_native, self.param_mut]),
             ),
             # 8:
-            (
-                self.mon_native,
-                self.var,
-                LinearExpression([self.mon_native, self.mon_var]),
-            ),
+            (self.mon_native, self.var, LinearExpression([self.mon_native, self.var])),
             (
                 self.mon_native,
                 self.mon_native,
                 LinearExpression([self.mon_native, self.mon_native]),
             ),
             (
                 self.mon_native,
@@ -543,33 +507,29 @@
 
     def test_add_mon_param(self):
         tests = [
             (self.mon_param, self.invalid, NotImplemented),
             (
                 self.mon_param,
                 self.asbinary,
-                LinearExpression([self.mon_param, self.mon_bin]),
+                LinearExpression([self.mon_param, self.bin]),
             ),
             (self.mon_param, self.zero, self.mon_param),
             (self.mon_param, self.one, LinearExpression([self.mon_param, 1])),
             # 4:
             (self.mon_param, self.native, LinearExpression([self.mon_param, 5])),
             (self.mon_param, self.npv, LinearExpression([self.mon_param, self.npv])),
             (self.mon_param, self.param, LinearExpression([self.mon_param, 6])),
             (
                 self.mon_param,
                 self.param_mut,
                 LinearExpression([self.mon_param, self.param_mut]),
             ),
             # 8:
-            (
-                self.mon_param,
-                self.var,
-                LinearExpression([self.mon_param, self.mon_var]),
-            ),
+            (self.mon_param, self.var, LinearExpression([self.mon_param, self.var])),
             (
                 self.mon_param,
                 self.mon_native,
                 LinearExpression([self.mon_param, self.mon_native]),
             ),
             (
                 self.mon_param,
@@ -612,32 +572,28 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_mon_npv(self):
         tests = [
             (self.mon_npv, self.invalid, NotImplemented),
-            (
-                self.mon_npv,
-                self.asbinary,
-                LinearExpression([self.mon_npv, self.mon_bin]),
-            ),
+            (self.mon_npv, self.asbinary, LinearExpression([self.mon_npv, self.bin])),
             (self.mon_npv, self.zero, self.mon_npv),
             (self.mon_npv, self.one, LinearExpression([self.mon_npv, 1])),
             # 4:
             (self.mon_npv, self.native, LinearExpression([self.mon_npv, 5])),
             (self.mon_npv, self.npv, LinearExpression([self.mon_npv, self.npv])),
             (self.mon_npv, self.param, LinearExpression([self.mon_npv, 6])),
             (
                 self.mon_npv,
                 self.param_mut,
                 LinearExpression([self.mon_npv, self.param_mut]),
             ),
             # 8:
-            (self.mon_npv, self.var, LinearExpression([self.mon_npv, self.mon_var])),
+            (self.mon_npv, self.var, LinearExpression([self.mon_npv, self.var])),
             (
                 self.mon_npv,
                 self.mon_native,
                 LinearExpression([self.mon_npv, self.mon_native]),
             ),
             (
                 self.mon_npv,
@@ -679,33 +635,29 @@
 
     def test_add_linear(self):
         tests = [
             (self.linear, self.invalid, NotImplemented),
             (
                 self.linear,
                 self.asbinary,
-                LinearExpression(self.linear.args + [self.mon_bin]),
+                LinearExpression(self.linear.args + [self.bin]),
             ),
             (self.linear, self.zero, self.linear),
             (self.linear, self.one, LinearExpression(self.linear.args + [1])),
             # 4:
             (self.linear, self.native, LinearExpression(self.linear.args + [5])),
             (self.linear, self.npv, LinearExpression(self.linear.args + [self.npv])),
             (self.linear, self.param, LinearExpression(self.linear.args + [6])),
             (
                 self.linear,
                 self.param_mut,
                 LinearExpression(self.linear.args + [self.param_mut]),
             ),
             # 8:
-            (
-                self.linear,
-                self.var,
-                LinearExpression(self.linear.args + [self.mon_var]),
-            ),
+            (self.linear, self.var, LinearExpression(self.linear.args + [self.var])),
             (
                 self.linear,
                 self.mon_native,
                 LinearExpression(self.linear.args + [self.mon_native]),
             ),
             (
                 self.linear,
@@ -864,15 +816,15 @@
 
     def test_add_mutable_l1(self):
         tests = [
             (self.mutable_l1, self.invalid, NotImplemented),
             (
                 self.mutable_l1,
                 self.asbinary,
-                LinearExpression(self.mutable_l1.args + [self.mon_bin]),
+                LinearExpression(self.mutable_l1.args + [self.bin]),
             ),
             (self.mutable_l1, self.zero, self.mon_npv),
             (self.mutable_l1, self.one, LinearExpression(self.mutable_l1.args + [1])),
             # 4:
             (
                 self.mutable_l1,
                 self.native,
@@ -889,15 +841,15 @@
                 self.param_mut,
                 LinearExpression(self.mutable_l1.args + [self.param_mut]),
             ),
             # 8:
             (
                 self.mutable_l1,
                 self.var,
-                LinearExpression(self.mutable_l1.args + [self.mon_var]),
+                LinearExpression(self.mutable_l1.args + [self.var]),
             ),
             (
                 self.mutable_l1,
                 self.mon_native,
                 LinearExpression(self.mutable_l1.args + [self.mon_native]),
             ),
             (
@@ -1071,24 +1023,24 @@
         ]
         self._run_cases(tests, operator.add)
         self._run_cases(tests, operator.iadd)
 
     def test_add_param1(self):
         tests = [
             (self.param1, self.invalid, NotImplemented),
-            (self.param1, self.asbinary, LinearExpression([1, self.mon_bin])),
+            (self.param1, self.asbinary, LinearExpression([1, self.bin])),
             (self.param1, self.zero, 1),
             (self.param1, self.one, 2),
             # 4:
             (self.param1, self.native, 6),
             (self.param1, self.npv, NPV_SumExpression([1, self.npv])),
             (self.param1, self.param, 7),
             (self.param1, self.param_mut, NPV_SumExpression([1, self.param_mut])),
             # 8:
-            (self.param1, self.var, LinearExpression([1, self.mon_var])),
+            (self.param1, self.var, LinearExpression([1, self.var])),
             (self.param1, self.mon_native, LinearExpression([1, self.mon_native])),
             (self.param1, self.mon_param, LinearExpression([1, self.mon_param])),
             (self.param1, self.mon_npv, LinearExpression([1, self.mon_npv])),
             # 12:
             (self.param1, self.linear, LinearExpression(self.linear.args + [1])),
             (self.param1, self.sum, SumExpression(self.sum.args + [1])),
             (self.param1, self.other, SumExpression([1, self.other])),
@@ -1110,15 +1062,15 @@
 
     def test_add_mutable_l3(self):
         tests = [
             (self.mutable_l3, self.invalid, NotImplemented),
             (
                 self.mutable_l3,
                 self.asbinary,
-                LinearExpression(self.mutable_l3.args + [self.mon_bin]),
+                LinearExpression(self.mutable_l3.args + [self.bin]),
             ),
             (self.mutable_l3, self.zero, self.npv),
             (self.mutable_l3, self.one, NPV_SumExpression(self.mutable_l3.args + [1])),
             # 4:
             (
                 self.mutable_l3,
                 self.native,
@@ -1139,15 +1091,15 @@
                 self.param_mut,
                 NPV_SumExpression(self.mutable_l3.args + [self.param_mut]),
             ),
             # 8:
             (
                 self.mutable_l3,
                 self.var,
-                LinearExpression(self.mutable_l3.args + [self.mon_var]),
+                LinearExpression(self.mutable_l3.args + [self.var]),
             ),
             (
                 self.mutable_l3,
                 self.mon_native,
                 LinearExpression(self.mutable_l3.args + [self.mon_native]),
             ),
             (
@@ -1245,64 +1197,64 @@
 
     def test_sub_asbinary(self):
         tests = [
             (self.asbinary, self.invalid, NotImplemented),
             # BooleanVar objects do not support addition
             (self.asbinary, self.asbinary, NotImplemented),
             (self.asbinary, self.zero, self.bin),
-            (self.asbinary, self.one, LinearExpression([self.mon_bin, -1])),
+            (self.asbinary, self.one, LinearExpression([self.bin, -1])),
             # 4:
-            (self.asbinary, self.native, LinearExpression([self.mon_bin, -5])),
-            (self.asbinary, self.npv, LinearExpression([self.mon_bin, self.minus_npv])),
-            (self.asbinary, self.param, LinearExpression([self.mon_bin, -6])),
+            (self.asbinary, self.native, LinearExpression([self.bin, -5])),
+            (self.asbinary, self.npv, LinearExpression([self.bin, self.minus_npv])),
+            (self.asbinary, self.param, LinearExpression([self.bin, -6])),
             (
                 self.asbinary,
                 self.param_mut,
-                LinearExpression([self.mon_bin, self.minus_param_mut]),
+                LinearExpression([self.bin, self.minus_param_mut]),
             ),
             # 8:
-            (self.asbinary, self.var, LinearExpression([self.mon_bin, self.minus_var])),
+            (self.asbinary, self.var, LinearExpression([self.bin, self.minus_var])),
             (
                 self.asbinary,
                 self.mon_native,
-                LinearExpression([self.mon_bin, self.minus_mon_native]),
+                LinearExpression([self.bin, self.minus_mon_native]),
             ),
             (
                 self.asbinary,
                 self.mon_param,
-                LinearExpression([self.mon_bin, self.minus_mon_param]),
+                LinearExpression([self.bin, self.minus_mon_param]),
             ),
             (
                 self.asbinary,
                 self.mon_npv,
-                LinearExpression([self.mon_bin, self.minus_mon_npv]),
+                LinearExpression([self.bin, self.minus_mon_npv]),
             ),
             # 12:
             (self.asbinary, self.linear, SumExpression([self.bin, self.minus_linear])),
             (self.asbinary, self.sum, SumExpression([self.bin, self.minus_sum])),
             (self.asbinary, self.other, SumExpression([self.bin, self.minus_other])),
             (self.asbinary, self.mutable_l0, self.bin),
             # 16:
             (
                 self.asbinary,
                 self.mutable_l1,
-                LinearExpression([self.mon_bin, self.minus_mon_npv]),
+                LinearExpression([self.bin, self.minus_mon_npv]),
             ),
             (
                 self.asbinary,
                 self.mutable_l2,
                 SumExpression([self.bin, self.minus_mutable_l2]),
             ),
             (self.asbinary, self.param0, self.bin),
-            (self.asbinary, self.param1, LinearExpression([self.mon_bin, -1])),
+            (self.asbinary, self.param1, LinearExpression([self.bin, -1])),
             # 20:
             (
                 self.asbinary,
                 self.mutable_l3,
-                LinearExpression([self.mon_bin, self.minus_npv]),
+                LinearExpression([self.bin, self.minus_npv]),
             ),
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_zero(self):
         tests = [
@@ -1567,71 +1519,63 @@
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_var(self):
         tests = [
             (self.var, self.invalid, NotImplemented),
-            (self.var, self.asbinary, LinearExpression([self.mon_var, self.minus_bin])),
+            (self.var, self.asbinary, LinearExpression([self.var, self.minus_bin])),
             (self.var, self.zero, self.var),
-            (self.var, self.one, LinearExpression([self.mon_var, -1])),
+            (self.var, self.one, LinearExpression([self.var, -1])),
             # 4:
-            (self.var, self.native, LinearExpression([self.mon_var, -5])),
-            (self.var, self.npv, LinearExpression([self.mon_var, self.minus_npv])),
-            (self.var, self.param, LinearExpression([self.mon_var, -6])),
+            (self.var, self.native, LinearExpression([self.var, -5])),
+            (self.var, self.npv, LinearExpression([self.var, self.minus_npv])),
+            (self.var, self.param, LinearExpression([self.var, -6])),
             (
                 self.var,
                 self.param_mut,
-                LinearExpression([self.mon_var, self.minus_param_mut]),
+                LinearExpression([self.var, self.minus_param_mut]),
             ),
             # 8:
-            (self.var, self.var, LinearExpression([self.mon_var, self.minus_var])),
+            (self.var, self.var, LinearExpression([self.var, self.minus_var])),
             (
                 self.var,
                 self.mon_native,
-                LinearExpression([self.mon_var, self.minus_mon_native]),
+                LinearExpression([self.var, self.minus_mon_native]),
             ),
             (
                 self.var,
                 self.mon_param,
-                LinearExpression([self.mon_var, self.minus_mon_param]),
-            ),
-            (
-                self.var,
-                self.mon_npv,
-                LinearExpression([self.mon_var, self.minus_mon_npv]),
+                LinearExpression([self.var, self.minus_mon_param]),
             ),
+            (self.var, self.mon_npv, LinearExpression([self.var, self.minus_mon_npv])),
             # 12:
             (
                 self.var,
                 self.linear,
                 SumExpression([self.var, NegationExpression((self.linear,))]),
             ),
             (self.var, self.sum, SumExpression([self.var, self.minus_sum])),
             (self.var, self.other, SumExpression([self.var, self.minus_other])),
             (self.var, self.mutable_l0, self.var),
             # 16:
             (
                 self.var,
                 self.mutable_l1,
-                LinearExpression([self.mon_var, self.minus_mon_npv]),
+                LinearExpression([self.var, self.minus_mon_npv]),
             ),
             (
                 self.var,
                 self.mutable_l2,
                 SumExpression([self.var, self.minus_mutable_l2]),
             ),
             (self.var, self.param0, self.var),
-            (self.var, self.param1, LinearExpression([self.mon_var, -1])),
+            (self.var, self.param1, LinearExpression([self.var, -1])),
             # 20:
-            (
-                self.var,
-                self.mutable_l3,
-                LinearExpression([self.mon_var, self.minus_npv]),
-            ),
+            (self.var, self.mutable_l3, LinearExpression([self.var, self.minus_npv])),
         ]
         self._run_cases(tests, operator.sub)
         self._run_cases(tests, operator.isub)
 
     def test_sub_mon_native(self):
         tests = [
             (self.mon_native, self.invalid, NotImplemented),
@@ -6035,24 +5979,24 @@
     #
     #
 
     def test_mutable_nvp_iadd(self):
         mutable_npv = _MutableNPVSumExpression([])
         tests = [
             (mutable_npv, self.invalid, NotImplemented),
-            (mutable_npv, self.asbinary, _MutableLinearExpression([self.mon_bin])),
+            (mutable_npv, self.asbinary, _MutableLinearExpression([self.bin])),
             (mutable_npv, self.zero, _MutableNPVSumExpression([])),
             (mutable_npv, self.one, _MutableNPVSumExpression([1])),
             # 4:
             (mutable_npv, self.native, _MutableNPVSumExpression([5])),
             (mutable_npv, self.npv, _MutableNPVSumExpression([self.npv])),
             (mutable_npv, self.param, _MutableNPVSumExpression([6])),
             (mutable_npv, self.param_mut, _MutableNPVSumExpression([self.param_mut])),
             # 8:
-            (mutable_npv, self.var, _MutableLinearExpression([self.mon_var])),
+            (mutable_npv, self.var, _MutableLinearExpression([self.var])),
             (mutable_npv, self.mon_native, _MutableLinearExpression([self.mon_native])),
             (mutable_npv, self.mon_param, _MutableLinearExpression([self.mon_param])),
             (mutable_npv, self.mon_npv, _MutableLinearExpression([self.mon_npv])),
             # 12:
             (mutable_npv, self.linear, _MutableLinearExpression(self.linear.args)),
             (mutable_npv, self.sum, _MutableSumExpression(self.sum.args)),
             (mutable_npv, self.other, _MutableSumExpression([self.other])),
@@ -6070,28 +6014,28 @@
             (mutable_npv, self.mutable_l3, _MutableNPVSumExpression([self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
         mutable_npv = _MutableNPVSumExpression([10])
         tests = [
             (mutable_npv, self.invalid, NotImplemented),
-            (mutable_npv, self.asbinary, _MutableLinearExpression([10, self.mon_bin])),
+            (mutable_npv, self.asbinary, _MutableLinearExpression([10, self.bin])),
             (mutable_npv, self.zero, _MutableNPVSumExpression([10])),
-            (mutable_npv, self.one, _MutableNPVSumExpression([10, 1])),
+            (mutable_npv, self.one, _MutableNPVSumExpression([11])),
             # 4:
-            (mutable_npv, self.native, _MutableNPVSumExpression([10, 5])),
+            (mutable_npv, self.native, _MutableNPVSumExpression([15])),
             (mutable_npv, self.npv, _MutableNPVSumExpression([10, self.npv])),
-            (mutable_npv, self.param, _MutableNPVSumExpression([10, 6])),
+            (mutable_npv, self.param, _MutableNPVSumExpression([16])),
             (
                 mutable_npv,
                 self.param_mut,
                 _MutableNPVSumExpression([10, self.param_mut]),
             ),
             # 8:
-            (mutable_npv, self.var, _MutableLinearExpression([10, self.mon_var])),
+            (mutable_npv, self.var, _MutableLinearExpression([10, self.var])),
             (
                 mutable_npv,
                 self.mon_native,
                 _MutableLinearExpression([10, self.mon_native]),
             ),
             (
                 mutable_npv,
@@ -6116,34 +6060,34 @@
             ),
             (
                 mutable_npv,
                 self.mutable_l2,
                 _MutableSumExpression([10] + self.mutable_l2.args),
             ),
             (mutable_npv, self.param0, _MutableNPVSumExpression([10])),
-            (mutable_npv, self.param1, _MutableNPVSumExpression([10, 1])),
+            (mutable_npv, self.param1, _MutableNPVSumExpression([11])),
             # 20:
             (mutable_npv, self.mutable_l3, _MutableNPVSumExpression([10, self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
     def test_mutable_lin_iadd(self):
         mutable_lin = _MutableLinearExpression([])
         tests = [
             (mutable_lin, self.invalid, NotImplemented),
-            (mutable_lin, self.asbinary, _MutableLinearExpression([self.mon_bin])),
+            (mutable_lin, self.asbinary, _MutableLinearExpression([self.bin])),
             (mutable_lin, self.zero, _MutableLinearExpression([])),
             (mutable_lin, self.one, _MutableLinearExpression([1])),
             # 4:
             (mutable_lin, self.native, _MutableLinearExpression([5])),
             (mutable_lin, self.npv, _MutableLinearExpression([self.npv])),
             (mutable_lin, self.param, _MutableLinearExpression([6])),
             (mutable_lin, self.param_mut, _MutableLinearExpression([self.param_mut])),
             # 8:
-            (mutable_lin, self.var, _MutableLinearExpression([self.mon_var])),
+            (mutable_lin, self.var, _MutableLinearExpression([self.var])),
             (mutable_lin, self.mon_native, _MutableLinearExpression([self.mon_native])),
             (mutable_lin, self.mon_param, _MutableLinearExpression([self.mon_param])),
             (mutable_lin, self.mon_npv, _MutableLinearExpression([self.mon_npv])),
             # 12:
             (mutable_lin, self.linear, _MutableLinearExpression(self.linear.args)),
             (mutable_lin, self.sum, _MutableSumExpression(self.sum.args)),
             (mutable_lin, self.other, _MutableSumExpression([self.other])),
@@ -6158,89 +6102,77 @@
             (mutable_lin, self.param0, _MutableLinearExpression([])),
             (mutable_lin, self.param1, _MutableLinearExpression([1])),
             # 20:
             (mutable_lin, self.mutable_l3, _MutableLinearExpression([self.npv])),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
-        mutable_lin = _MutableLinearExpression([self.mon_bin])
+        mutable_lin = _MutableLinearExpression([self.bin])
         tests = [
             (mutable_lin, self.invalid, NotImplemented),
             (
                 mutable_lin,
                 self.asbinary,
-                _MutableLinearExpression([self.mon_bin, self.mon_bin]),
+                _MutableLinearExpression([self.bin, self.bin]),
             ),
-            (mutable_lin, self.zero, _MutableLinearExpression([self.mon_bin])),
-            (mutable_lin, self.one, _MutableLinearExpression([self.mon_bin, 1])),
+            (mutable_lin, self.zero, _MutableLinearExpression([self.bin])),
+            (mutable_lin, self.one, _MutableLinearExpression([self.bin, 1])),
             # 4:
-            (mutable_lin, self.native, _MutableLinearExpression([self.mon_bin, 5])),
-            (mutable_lin, self.npv, _MutableLinearExpression([self.mon_bin, self.npv])),
-            (mutable_lin, self.param, _MutableLinearExpression([self.mon_bin, 6])),
+            (mutable_lin, self.native, _MutableLinearExpression([self.bin, 5])),
+            (mutable_lin, self.npv, _MutableLinearExpression([self.bin, self.npv])),
+            (mutable_lin, self.param, _MutableLinearExpression([self.bin, 6])),
             (
                 mutable_lin,
                 self.param_mut,
-                _MutableLinearExpression([self.mon_bin, self.param_mut]),
+                _MutableLinearExpression([self.bin, self.param_mut]),
             ),
             # 8:
-            (
-                mutable_lin,
-                self.var,
-                _MutableLinearExpression([self.mon_bin, self.mon_var]),
-            ),
+            (mutable_lin, self.var, _MutableLinearExpression([self.bin, self.var])),
             (
                 mutable_lin,
                 self.mon_native,
-                _MutableLinearExpression([self.mon_bin, self.mon_native]),
+                _MutableLinearExpression([self.bin, self.mon_native]),
             ),
             (
                 mutable_lin,
                 self.mon_param,
-                _MutableLinearExpression([self.mon_bin, self.mon_param]),
+                _MutableLinearExpression([self.bin, self.mon_param]),
             ),
             (
                 mutable_lin,
                 self.mon_npv,
-                _MutableLinearExpression([self.mon_bin, self.mon_npv]),
+                _MutableLinearExpression([self.bin, self.mon_npv]),
             ),
             # 12:
             (
                 mutable_lin,
                 self.linear,
-                _MutableLinearExpression([self.mon_bin] + self.linear.args),
-            ),
-            (
-                mutable_lin,
-                self.sum,
-                _MutableSumExpression([self.mon_bin] + self.sum.args),
-            ),
-            (
-                mutable_lin,
-                self.other,
-                _MutableSumExpression([self.mon_bin, self.other]),
+                _MutableLinearExpression([self.bin] + self.linear.args),
             ),
-            (mutable_lin, self.mutable_l0, _MutableLinearExpression([self.mon_bin])),
+            (mutable_lin, self.sum, _MutableSumExpression([self.bin] + self.sum.args)),
+            (mutable_lin, self.other, _MutableSumExpression([self.bin, self.other])),
+            (mutable_lin, self.mutable_l0, _MutableLinearExpression([self.bin])),
             # 16:
             (
                 mutable_lin,
                 self.mutable_l1,
-                _MutableLinearExpression([self.mon_bin] + self.mutable_l1.args),
+                _MutableLinearExpression([self.bin] + self.mutable_l1.args),
             ),
             (
                 mutable_lin,
                 self.mutable_l2,
-                _MutableSumExpression([self.mon_bin] + self.mutable_l2.args),
+                _MutableSumExpression([self.bin] + self.mutable_l2.args),
             ),
-            (mutable_lin, self.param0, _MutableLinearExpression([self.mon_bin])),
-            (mutable_lin, self.param1, _MutableLinearExpression([self.mon_bin, 1])),
+            (mutable_lin, self.param0, _MutableLinearExpression([self.bin])),
+            (mutable_lin, self.param1, _MutableLinearExpression([self.bin, 1])),
             # 20:
             (
                 mutable_lin,
                 self.mutable_l3,
-                _MutableLinearExpression([self.mon_bin, self.npv]),
+                _MutableLinearExpression([self.bin, self.npv]),
             ),
         ]
         self._run_iadd_cases(tests, operator.iadd)
 
     def test_mutable_sum_iadd(self):
         mutable_sum = _MutableSumExpression([])
         tests = [
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numpy_expr.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numpy_expr.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_numvalue.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_numvalue.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 
 import subprocess
 import sys
 from math import nan, inf
 
 import pyomo.common.unittest as unittest
 from pyomo.common.dependencies import numpy, numpy_available
+from pyomo.core.base.units_container import pint_available
 
 from pyomo.environ import (
     value,
     ConcreteModel,
     Param,
     Var,
     polynomial_degree,
@@ -46,15 +47,24 @@
 class MyBogusType(object):
     def __init__(self, val=0):
         self.val = float(val)
 
 
 class MyBogusNumericType(MyBogusType):
     def __add__(self, other):
-        return MyBogusNumericType(self.val + float(other))
+        if other.__class__ in native_numeric_types:
+            return MyBogusNumericType(self.val + float(other))
+        else:
+            return NotImplemented
+
+    def __le__(self, other):
+        if other.__class__ in native_numeric_types:
+            return self.val <= float(other)
+        else:
+            return NotImplemented
 
     def __lt__(self, other):
         return self.val < float(other)
 
     def __ge__(self, other):
         return self.val >= float(other)
 
@@ -530,14 +540,16 @@
     def test_unknownNumericType(self):
         ref = MyBogusNumericType(42)
         self.assertNotIn(MyBogusNumericType, native_numeric_types)
         self.assertNotIn(MyBogusNumericType, native_types)
         try:
             val = as_numeric(ref)
             self.assertEqual(val().val, 42.0)
+            self.assertIn(MyBogusNumericType, native_numeric_types)
+            self.assertIn(MyBogusNumericType, native_types)
         finally:
             native_numeric_types.remove(MyBogusNumericType)
             native_types.remove(MyBogusNumericType)
 
     @unittest.skipUnless(numpy_available, "This test requires NumPy")
     def test_numpy_basic_float_registration(self):
         self.assertIn(numpy.float_, native_numeric_types)
@@ -558,37 +570,83 @@
         self.assertNotIn(numpy.bool_, native_integer_types)
         self.assertIn(numpy.bool_, _native_boolean_types)
         self.assertIn(numpy.bool_, native_types)
 
     @unittest.skipUnless(numpy_available, "This test requires NumPy")
     def test_automatic_numpy_registration(self):
         cmd = (
-            'import pyomo; from pyomo.core.base import Var, Param; '
-            'from pyomo.core.base.units_container import units; import numpy as np; '
-            'print(np.float64 in pyomo.common.numeric_types.native_numeric_types); '
-            '%s; print(np.float64 in pyomo.common.numeric_types.native_numeric_types)'
+            'from pyomo.common.numeric_types import native_numeric_types as nnt; '
+            'print("float64" in [_.__name__ for _ in nnt]); '
+            'import numpy; '
+            'print("float64" in [_.__name__ for _ in nnt])'
+        )
+
+        rc = subprocess.run(
+            [sys.executable, '-c', cmd],
+            stdout=subprocess.PIPE,
+            stderr=subprocess.STDOUT,
+            text=True,
+        )
+        self.assertEqual((rc.returncode, rc.stdout), (0, "False\nTrue\n"))
+
+        cmd = (
+            'import numpy; '
+            'from pyomo.common.numeric_types import native_numeric_types as nnt; '
+            'print("float64" in [_.__name__ for _ in nnt])'
+        )
+
+        rc = subprocess.run(
+            [sys.executable, '-c', cmd],
+            stdout=subprocess.PIPE,
+            stderr=subprocess.STDOUT,
+            text=True,
+        )
+        self.assertEqual((rc.returncode, rc.stdout), (0, "True\n"))
+
+    def test_unknownNumericType_expr_registration(self):
+        cmd = (
+            'import pyomo; '
+            'from pyomo.core.base import Var, Param; '
+            'from pyomo.core.base.units_container import units; '
+            'from pyomo.common.numeric_types import native_numeric_types as nnt; '
+            f'from {__name__} import MyBogusNumericType; '
+            'ref = MyBogusNumericType(42); '
+            'print(MyBogusNumericType in nnt); %s; print(MyBogusNumericType in nnt); '
         )
 
         def _tester(expr):
             rc = subprocess.run(
                 [sys.executable, '-c', cmd % expr],
                 stdout=subprocess.PIPE,
                 stderr=subprocess.STDOUT,
                 text=True,
             )
-            self.assertEqual((rc.returncode, rc.stdout), (0, "False\nTrue\n"))
+            self.assertEqual(
+                (rc.returncode, rc.stdout),
+                (
+                    0,
+                    '''False
+WARNING: Dynamically registering the following numeric type:
+        pyomo.core.tests.unit.test_numvalue.MyBogusNumericType
+    Dynamic registration is supported for convenience, but there are known
+    limitations to this approach.  We recommend explicitly registering numeric
+    types using RegisterNumericType() or RegisterIntegerType().
+True
+''',
+                ),
+            )
 
-        _tester('Var() <= np.float64(5)')
-        _tester('np.float64(5) <= Var()')
-        _tester('np.float64(5) + Var()')
-        _tester('Var() + np.float64(5)')
-        _tester('v = Var(); v.construct(); v.value = np.float64(5)')
-        _tester('p = Param(mutable=True); p.construct(); p.value = np.float64(5)')
-        _tester('v = Var(units=units.m); v.construct(); v.value = np.float64(5)')
-        _tester(
-            'p = Param(mutable=True, units=units.m); p.construct(); '
-            'p.value = np.float64(5)'
-        )
+        _tester('Var() <= ref')
+        _tester('ref <= Var()')
+        _tester('ref + Var()')
+        _tester('Var() + ref')
+        _tester('v = Var(); v.construct(); v.value = ref')
+        _tester('p = Param(mutable=True); p.construct(); p.value = ref')
+        if pint_available:
+            _tester('v = Var(units=units.m); v.construct(); v.value = ref')
+            _tester(
+                'p = Param(mutable=True, units=units.m); p.construct(); p.value = ref'
+            )
 
 
 if __name__ == "__main__":
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_param.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_param.py`

 * *Files 1% similar despite different names*

```diff
@@ -61,16 +61,16 @@
     asinh,
     acosh,
     atanh,
 )
 from pyomo.common.errors import PyomoException
 from pyomo.common.log import LoggingIntercept
 from pyomo.common.tempfiles import TempfileManager
-from pyomo.core.base.param import _ParamData
-from pyomo.core.base.set import _SetData
+from pyomo.core.base.param import ParamData
+from pyomo.core.base.set import SetData
 from pyomo.core.base.units_container import units, pint_available, UnitsError
 
 from io import StringIO
 
 NoValue = Param.NoValue
 
 
@@ -177,24 +177,24 @@
         keys = self.instance.A.sparse_keys()
         if not keys or None in keys:
             return
 
         idx = sorted(keys)[0]
         self.assertEqual(value(self.instance.A[idx]), self.data[idx])
         if self.instance.A.mutable:
-            self.assertTrue(isinstance(self.instance.A[idx], _ParamData))
+            self.assertTrue(isinstance(self.instance.A[idx], ParamData))
         else:
             self.assertEqual(type(self.instance.A[idx]), float)
 
         try:
             self.instance.A[idx] = 4.3
             if not self.instance.A.mutable:
                 self.fail("Expected setitem[%s] to fail for immutable Params" % (idx,))
             self.assertEqual(value(self.instance.A[idx]), 4.3)
-            self.assertTrue(isinstance(self.instance.A[idx], _ParamData))
+            self.assertTrue(isinstance(self.instance.A[idx], ParamData))
         except TypeError:
             # immutable Params should raise a TypeError exception
             if self.instance.A.mutable:
                 raise
 
         try:
             self.instance.A[idx] = -4.3
@@ -245,26 +245,26 @@
         while True:
             idx = keys.pop(0)
             if not idx in sparse_keys:
                 break
 
         self.assertEqual(value(self.instance.A[idx]), self.instance.A._default_val)
         if self.instance.A.mutable:
-            self.assertIsInstance(self.instance.A[idx], _ParamData)
+            self.assertIsInstance(self.instance.A[idx], ParamData)
         else:
             self.assertEqual(
                 type(self.instance.A[idx]), type(value(self.instance.A._default_val))
             )
 
         try:
             self.instance.A[idx] = 4.3
             if not self.instance.A.mutable:
                 self.fail("Expected setitem[%s] to fail for immutable Params" % (idx,))
             self.assertEqual(self.instance.A[idx].value, 4.3)
-            self.assertIsInstance(self.instance.A[idx], _ParamData)
+            self.assertIsInstance(self.instance.A[idx], ParamData)
         except TypeError:
             # immutable Params should raise a TypeError exception
             if self.instance.A.mutable:
                 raise
 
         try:
             self.instance.A[idx] = -4.3
@@ -1483,15 +1483,15 @@
         self.assertIs(i.p.domain._owner(), i.p)
 
     def test_domain_set_initializer(self):
         m = ConcreteModel()
         m.I = Set(initialize=[1, 2, 3])
         param_vals = {1: 1, 2: 1, 3: -1}
         m.p = Param(m.I, initialize=param_vals, domain={-1, 1})
-        self.assertIsInstance(m.p.domain, _SetData)
+        self.assertIsInstance(m.p.domain, SetData)
 
     @unittest.skipUnless(pint_available, "units test requires pint module")
     def test_set_value_units(self):
         m = ConcreteModel()
         m.p = Param(units=units.g)
         m.p = 5
         self.assertEqual(value(m.p), 5)
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_pickle.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_pickle.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_piecewise.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_piecewise.py`

 * *Files 0% similar despite different names*

```diff
@@ -100,15 +100,15 @@
         args = ([1], model.range2, model.y)
         model.con2 = Piecewise(*args, **keywords)
 
         args = ([1], model.range2, model.y[1])
         model.con3 = Piecewise(*args, **keywords)
 
     # test that nonindexed Piecewise can handle
-    # _VarData (e.g model.x[1]
+    # VarData (e.g model.x[1]
     def test_nonindexed_with_indexed_vars(self):
         model = ConcreteModel()
         model.range = Var([1])
 
         model.x = Var([1], bounds=(-1, 1))
         args = (model.range[1], model.x[1])
         keywords = {
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_preprocess.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_simple.py`

 * *Files 25% similar despite different names*

```diff
@@ -4,49 +4,69 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
-#
-# Unit Tests for model preprocessing
-#
-
-import os
-from os.path import abspath, dirname
-
-currdir = dirname(abspath(__file__)) + os.sep
-
-import pyomo.common.unittest as unittest
-
-from pyomo.environ import AbstractModel, Set, Param, Var, Objective
-
-
-class TestPreprocess(unittest.TestCase):
-    def Xtest_label1(self):
-        model = AbstractModel()
-        model.A = Set(initialize=[1, 2, 3])
-        model.B = Param(model.A, initialize={1: 100, 2: 200, 3: 300})
-        model.x = Var(model.A)
-        model.y = Var(model.A)
-        instance = model.create_instance()
-        instance.preprocess()
-        self.assertEqual(instance.num_used_variables(), 0)
-
-    def Xtest_label2(self):
-        model = AbstractModel()
-        model.A = Set(initialize=[1, 2, 3])
-        model.B = Param(model.A, initialize={1: 100, 2: 200, 3: 300})
-        model.x = Var(model.A)
-        model.y = Var(model.A)
-        model.obj = Objective(rule=lambda inst: inst.x[1])
-        instance = model.create_instance()
-        instance.preprocess()
-        self.assertEqual(instance.num_used_variables(), 1)
-        self.assertEqual(instance.x[1].label, "x(1)")
-        self.assertEqual(instance.x[2].label, "x(2)")
-        self.assertEqual(instance.y[1].label, "y(1)")
 
-
-if __name__ == "__main__":
-    unittest.main()
+import pyomo.kernel as pmo
+from pyomo.core import (
+    ConcreteModel,
+    Param,
+    Var,
+    Objective,
+    Constraint,
+    Binary,
+    NonNegativeReals,
+)
+from pyomo.solvers.tests.models.base import _BaseTestModel, register_model
+
+
+@register_model
+class MILP_simple(_BaseTestModel):
+    """
+    A simple mixed-integer linear program
+    """
+
+    description = "MILP_simple"
+    level = ('nightly', 'expensive')
+    capabilities = set(['linear', 'integer'])
+
+    def __init__(self):
+        _BaseTestModel.__init__(self)
+        self.add_results(self.description + ".json")
+
+    def _generate_model(self):
+        self.model = ConcreteModel()
+        model = self.model
+        model._name = self.description
+
+        model.a = Param(initialize=1.0)
+        model.x = Var(within=NonNegativeReals)
+        model.y = Var(within=Binary)
+
+        model.obj = Objective(expr=model.x + 3.0 * model.y)
+        model.c1 = Constraint(expr=model.a <= model.y)
+        model.c2 = Constraint(expr=(2.0, model.x / model.a - model.y, 10))
+
+    def warmstart_model(self):
+        assert self.model is not None
+        model = self.model
+        model.x.value = 0.1
+        model.y.value = 0
+
+
+@register_model
+class MILP_simple_kernel(MILP_simple):
+    def _generate_model(self):
+        self.model = pmo.block()
+        model = self.model
+        model._name = self.description
+
+        model.a = pmo.parameter(value=1.0)
+        model.x = pmo.variable(domain=NonNegativeReals)
+        model.y = pmo.variable(domain=Binary)
+
+        model.obj = pmo.objective(model.x + 3.0 * model.y)
+        model.c1 = pmo.constraint(model.a <= model.y)
+        model.c2 = pmo.constraint((2.0, model.x / model.a - model.y, 10))
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_range.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_range.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_reference.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_reference.py`

 * *Files 1% similar despite different names*

```diff
@@ -796,27 +796,27 @@
         m.r = Reference(m.x, ctype=IndexedComponent)
         buf = StringIO()
         m.r.pprint(ostream=buf)
         self.assertEqual(
             buf.getvalue(),
             """r : Size=2, Index={1, 2}, ReferenceTo=x
     Key : Object
-      1 : <class 'pyomo.core.base.var._GeneralVarData'>
-      2 : <class 'pyomo.core.base.var._GeneralVarData'>
+      1 : <class 'pyomo.core.base.var.VarData'>
+      2 : <class 'pyomo.core.base.var.VarData'>
 """,
         )
         m.s = Reference(m.x[:, ...], ctype=IndexedComponent)
         buf = StringIO()
         m.s.pprint(ostream=buf)
         self.assertEqual(
             buf.getvalue(),
             """s : Size=2, Index={1, 2}, ReferenceTo=x[:, ...]
     Key : Object
-      1 : <class 'pyomo.core.base.var._GeneralVarData'>
-      2 : <class 'pyomo.core.base.var._GeneralVarData'>
+      1 : <class 'pyomo.core.base.var.VarData'>
+      2 : <class 'pyomo.core.base.var.VarData'>
 """,
         )
 
     def test_single_reference(self):
         m = ConcreteModel()
         m.b = Block([1, 2])
         m.b[1].x = Var(bounds=(1, None))
@@ -1276,15 +1276,14 @@
             m.ref = Reference(m.v[:, 1])
             self.assertIn(('a', 1), m.ref)
             self.assertNotIn(('a', 10), m.ref)
         finally:
             normalize_index.flatten = _old_flatten
 
     def test_pprint_nonfinite_sets(self):
-        self.maxDiff = None
         m = ConcreteModel()
         m.v = Var(NonNegativeIntegers, dense=False)
         m.ref = Reference(m.v)
         buf = StringIO()
         m.pprint(ostream=buf)
         self.assertEqual(
             buf.getvalue().strip(),
@@ -1318,15 +1317,14 @@
 
 2 Declarations: v ref
 """.strip(),
         )
 
     def test_pprint_nonfinite_sets_ctypeNone(self):
         # test issue #2039
-        self.maxDiff = None
         m = ConcreteModel()
         m.v = Var(NonNegativeIntegers, dense=False)
         m.ref = Reference(m.v, ctype=None)
         buf = StringIO()
         m.pprint(ostream=buf)
         self.assertEqual(
             buf.getvalue().strip(),
@@ -1355,16 +1353,16 @@
         Key : Lower : Value : Upper : Fixed : Stale : Domain
           3 :  None :  None :  None : False :  True :  Reals
           5 :  None :  None :  None : False :  True :  Reals
 
 1 IndexedComponent Declarations
     ref : Size=2, Index=NonNegativeIntegers, ReferenceTo=v
         Key : Object
-          3 : <class 'pyomo.core.base.var._GeneralVarData'>
-          5 : <class 'pyomo.core.base.var._GeneralVarData'>
+          3 : <class 'pyomo.core.base.var.VarData'>
+          5 : <class 'pyomo.core.base.var.VarData'>
 
 2 Declarations: v ref
 """.strip(),
         )
 
     def test_pprint_nested(self):
         m = ConcreteModel()
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_relational_expr.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_relational_expr.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_set.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_set.py`

 * *Files 0% similar despite different names*

```diff
@@ -56,16 +56,16 @@
     NonNegativeIntegers,
     Set,
     SetOf,
     OrderedSetOf,
     FiniteSetOf,
     InfiniteSetOf,
     RangeSet,
-    _FiniteRangeSetData,
-    _InfiniteRangeSetData,
+    FiniteRangeSetData,
+    InfiniteRangeSetData,
     FiniteScalarRangeSet,
     InfiniteScalarRangeSet,
     AbstractFiniteScalarRangeSet,
     SetUnion_InfiniteSet,
     SetUnion_FiniteSet,
     SetUnion_OrderedSet,
     SetIntersection_InfiniteSet,
@@ -77,18 +77,18 @@
     SetSymmetricDifference_InfiniteSet,
     SetSymmetricDifference_FiniteSet,
     SetSymmetricDifference_OrderedSet,
     SetProduct,
     SetProduct_InfiniteSet,
     SetProduct_FiniteSet,
     SetProduct_OrderedSet,
-    _SetData,
-    _FiniteSetData,
-    _InsertionOrderSetData,
-    _SortedSetData,
+    SetData,
+    FiniteSetData,
+    InsertionOrderSetData,
+    SortedSetData,
     _FiniteSetMixin,
     _OrderedSetMixin,
     SetInitializer,
     SetIntersectInitializer,
     BoundsInitializer,
     UnknownSetDimen,
     UnindexedComponent_set,
@@ -1281,27 +1281,27 @@
         self.assertTrue(i.isfinite())
         self.assertTrue(i.isordered())
 
         i = RangeSet(3)
         self.assertTrue(i.isdiscrete())
         self.assertTrue(i.isfinite())
         self.assertTrue(i.isordered())
-        self.assertIsInstance(i, _FiniteRangeSetData)
+        self.assertIsInstance(i, FiniteRangeSetData)
 
         i = RangeSet(1, 3)
         self.assertTrue(i.isdiscrete())
         self.assertTrue(i.isfinite())
         self.assertTrue(i.isordered())
-        self.assertIsInstance(i, _FiniteRangeSetData)
+        self.assertIsInstance(i, FiniteRangeSetData)
 
         i = RangeSet(1, 3, 0)
         self.assertFalse(i.isdiscrete())
         self.assertFalse(i.isfinite())
         self.assertFalse(i.isordered())
-        self.assertIsInstance(i, _InfiniteRangeSetData)
+        self.assertIsInstance(i, InfiniteRangeSetData)
 
     def test_pprint(self):
         m = ConcreteModel()
         m.I = RangeSet(3)
         m.K1 = RangeSet(0)
         m.K2 = RangeSet(10, 9)
         m.NotI = RangeSet(1, 3, 0)
@@ -4133,17 +4133,17 @@
         self.assertEqual(list(m.I[3]), [4])
         self.assertIsNot(m.I[1], m.I[2])
         self.assertIsNot(m.I[1], m.I[3])
         self.assertIsNot(m.I[2], m.I[3])
         self.assertFalse(m.I[1].isordered())
         self.assertFalse(m.I[2].isordered())
         self.assertFalse(m.I[3].isordered())
-        self.assertIs(type(m.I[1]), _FiniteSetData)
-        self.assertIs(type(m.I[2]), _FiniteSetData)
-        self.assertIs(type(m.I[3]), _FiniteSetData)
+        self.assertIs(type(m.I[1]), FiniteSetData)
+        self.assertIs(type(m.I[2]), FiniteSetData)
+        self.assertIs(type(m.I[3]), FiniteSetData)
         self.assertEqual(m.I.data(), {1: (1,), 2: (2,), 3: (4,)})
 
         # Explicit (constant) construction
         m = ConcreteModel()
         m.I = Set([1, 2, 3], initialize=(4, 2, 5))
         self.assertEqual(len(m.I), 3)
         self.assertEqual(list(m.I[1]), [4, 2, 5])
@@ -4151,17 +4151,17 @@
         self.assertEqual(list(m.I[3]), [4, 2, 5])
         self.assertIsNot(m.I[1], m.I[2])
         self.assertIsNot(m.I[1], m.I[3])
         self.assertIsNot(m.I[2], m.I[3])
         self.assertTrue(m.I[1].isordered())
         self.assertTrue(m.I[2].isordered())
         self.assertTrue(m.I[3].isordered())
-        self.assertIs(type(m.I[1]), _InsertionOrderSetData)
-        self.assertIs(type(m.I[2]), _InsertionOrderSetData)
-        self.assertIs(type(m.I[3]), _InsertionOrderSetData)
+        self.assertIs(type(m.I[1]), InsertionOrderSetData)
+        self.assertIs(type(m.I[2]), InsertionOrderSetData)
+        self.assertIs(type(m.I[3]), InsertionOrderSetData)
         self.assertEqual(m.I.data(), {1: (4, 2, 5), 2: (4, 2, 5), 3: (4, 2, 5)})
 
         # Explicit (constant) construction
         m = ConcreteModel()
         m.I = Set([1, 2, 3], initialize=(4, 2, 5), ordered=Set.SortedOrder)
         self.assertEqual(len(m.I), 3)
         self.assertEqual(list(m.I[1]), [2, 4, 5])
@@ -4169,17 +4169,17 @@
         self.assertEqual(list(m.I[3]), [2, 4, 5])
         self.assertIsNot(m.I[1], m.I[2])
         self.assertIsNot(m.I[1], m.I[3])
         self.assertIsNot(m.I[2], m.I[3])
         self.assertTrue(m.I[1].isordered())
         self.assertTrue(m.I[2].isordered())
         self.assertTrue(m.I[3].isordered())
-        self.assertIs(type(m.I[1]), _SortedSetData)
-        self.assertIs(type(m.I[2]), _SortedSetData)
-        self.assertIs(type(m.I[3]), _SortedSetData)
+        self.assertIs(type(m.I[1]), SortedSetData)
+        self.assertIs(type(m.I[2]), SortedSetData)
+        self.assertIs(type(m.I[3]), SortedSetData)
         self.assertEqual(m.I.data(), {1: (2, 4, 5), 2: (2, 4, 5), 3: (2, 4, 5)})
 
         # Explicit (procedural) construction
         m = ConcreteModel()
         m.I = Set([1, 2, 3], ordered=True)
         self.assertEqual(len(m.I), 0)
         m.I[1] = [1, 2, 3]
@@ -4296,15 +4296,15 @@
         self.assertEqual(
             list(m.K), [(1, 1), (2, 1), (2, 2), (3, 1), (3, 2), (3, 3), (0, 0)]
         )
 
         # This tests a filter that matches the dimentionality of the
         # component.  construct() needs to recognize that the filter is
         # returning a constant in construct() and re-assign it to be the
-        # _filter for each _SetData
+        # _filter for each SetData
         def _lt_3(model, i):
             self.assertIs(model, m)
             return i < 3
 
         m.L = Set([1, 2, 3, 4, 5], initialize=RangeSet(10), filter=_lt_3)
         self.assertEqual(len(m.L), 5)
         self.assertEqual(list(m.L[1]), [1, 2])
@@ -5293,23 +5293,23 @@
             self.assertIn(2, m.J)
             self.assertIn((2,), m.J)
         finally:
             normalize_index.flatten = _oldFlatten
 
 
 class TestAbstractSetAPI(unittest.TestCase):
-    def test_SetData(self):
+    def testSetData(self):
         # This tests an anstract non-finite set API
 
         m = ConcreteModel()
         m.I = Set(initialize=[1])
-        s = _SetData(m.I)
+        s = SetData(m.I)
 
         #
-        # _SetData API
+        # SetData API
         #
 
         with self.assertRaises(DeveloperError):
             # __contains__
             None in s
 
         with self.assertRaises(DeveloperError):
@@ -5391,23 +5391,23 @@
         with self.assertRaises(DeveloperError):
             s > m.I
         with self.assertRaises(DeveloperError):
             m.I > s
 
     def test_FiniteMixin(self):
         # This tests an anstract finite set API
-        class FiniteMixin(_FiniteSetMixin, _SetData):
+        class FiniteMixin(_FiniteSetMixin, SetData):
             pass
 
         m = ConcreteModel()
         m.I = Set(initialize=[1])
         s = FiniteMixin(m.I)
 
         #
-        # _SetData API
+        # SetData API
         #
 
         with self.assertRaises(DeveloperError):
             # __contains__
             None in s
 
         with self.assertRaises(DeveloperError):
@@ -5516,23 +5516,23 @@
         with self.assertRaises(DeveloperError):
             s.sorted_data()
 
         self.assertEqual(s.bounds(), (None, None))
 
     def test_OrderedMixin(self):
         # This tests an anstract ordered set API
-        class OrderedMixin(_OrderedSetMixin, _FiniteSetMixin, _SetData):
+        class OrderedMixin(_OrderedSetMixin, _FiniteSetMixin, SetData):
             pass
 
         m = ConcreteModel()
         m.I = Set(initialize=[1])
         s = OrderedMixin(m.I)
 
         #
-        # _SetData API
+        # SetData API
         #
 
         with self.assertRaises(DeveloperError):
             # __contains__
             None in s
 
         with self.assertRaises(DeveloperError):
@@ -6263,15 +6263,14 @@
         out2 = StringIO()
         model.OS.pprint(ostream=out2)
 
         self.assertEqual(out1.getvalue().strip(), out2.getvalue().strip()[1:])
 
     @unittest.skipIf(NamedTuple is None, "typing module not available")
     def test_issue_938(self):
-        self.maxDiff = None
         NodeKey = NamedTuple('NodeKey', [('id', int)])
         ArcKey = NamedTuple('ArcKey', [('node_from', NodeKey), ('node_to', NodeKey)])
 
         def build_model():
             model = ConcreteModel()
             model.node_keys = Set(
                 doc='Set of nodes', initialize=[NodeKey(0), NodeKey(1)]
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_sets.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_sets.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_smap.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_smap.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_sos.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_sos.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_sos_v2.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_sos_v2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_suffix.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_suffix.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_symbol_map.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_symbol_map.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_symbolic.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_symbolic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_taylor_series.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_taylor_series.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_template_expr.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_template_expr.py`

 * *Files 2% similar despite different names*

```diff
@@ -123,15 +123,15 @@
         # Generic templates generate CallExpression objects
         ee = e.polynomial_degree()
         self.assertIs(type(ee), EXPR.CallExpression)
         t.set_value(1)
         # Note that structural expressions do not implement polynomial_degree
         with self.assertRaisesRegex(
             AttributeError,
-            "'_InsertionOrderSetData' object has " "no attribute 'polynomial_degree'",
+            "'InsertionOrderSetData' object has " "no attribute 'polynomial_degree'",
         ):
             e.polynomial_degree()
         self.assertEqual(str(e), "s[{I}]")
         t.set_value(5)
         v = e()
         self.assertIs(v, m.s[5])
         self.assertIs(resolve_template(e), m.s[5])
@@ -486,22 +486,22 @@
             str(template),
             "SUM(SUM(x[_2,_1,_3] for _3 in K[_2]) for _1 in J for _2 in I)  <=  0",
         )
         # Evaluate the template
         self.assertEqual(
             str(resolve_template(template)),
             'x[1,1,10] + '
-            '(x[2,1,10] + x[2,1,20]) + '
-            '(x[3,1,10] + x[3,1,20] + x[3,1,30]) + '
-            '(x[1,2,10]) + '
-            '(x[2,2,10] + x[2,2,20]) + '
-            '(x[3,2,10] + x[3,2,20] + x[3,2,30]) + '
-            '(x[1,3,10]) + '
-            '(x[2,3,10] + x[2,3,20]) + '
-            '(x[3,3,10] + x[3,3,20] + x[3,3,30])  <=  0',
+            'x[2,1,10] + x[2,1,20] + '
+            'x[3,1,10] + x[3,1,20] + x[3,1,30] + '
+            'x[1,2,10] + '
+            'x[2,2,10] + x[2,2,20] + '
+            'x[3,2,10] + x[3,2,20] + x[3,2,30] + '
+            'x[1,3,10] + '
+            'x[2,3,10] + x[2,3,20] + '
+            'x[3,3,10] + x[3,3,20] + x[3,3,30]  <=  0',
         )
 
     def test_multidim_nested_sum_rule(self):
         m = ConcreteModel()
         m.I = RangeSet(3)
         m.J = RangeSet(3)
         m.JI = m.J * m.I
@@ -562,22 +562,22 @@
             str(template),
             "SUM(SUM(x[_2,_1,_3] for _3 in K[_2]) for _1, _2 in JI)  <=  0",
         )
         # Evaluate the template
         self.assertEqual(
             str(resolve_template(template)),
             'x[1,1,10] + '
-            '(x[2,1,10] + x[2,1,20]) + '
-            '(x[3,1,10] + x[3,1,20] + x[3,1,30]) + '
-            '(x[1,2,10]) + '
-            '(x[2,2,10] + x[2,2,20]) + '
-            '(x[3,2,10] + x[3,2,20] + x[3,2,30]) + '
-            '(x[1,3,10]) + '
-            '(x[2,3,10] + x[2,3,20]) + '
-            '(x[3,3,10] + x[3,3,20] + x[3,3,30])  <=  0',
+            'x[2,1,10] + x[2,1,20] + '
+            'x[3,1,10] + x[3,1,20] + x[3,1,30] + '
+            'x[1,2,10] + '
+            'x[2,2,10] + x[2,2,20] + '
+            'x[3,2,10] + x[3,2,20] + x[3,2,30] + '
+            'x[1,3,10] + '
+            'x[2,3,10] + x[2,3,20] + '
+            'x[3,3,10] + x[3,3,20] + x[3,3,30]  <=  0',
         )
 
     def test_multidim_nested_getattr_sum_rule(self):
         m = ConcreteModel()
         m.I = RangeSet(3)
         m.J = RangeSet(3)
         m.JI = m.J * m.I
@@ -605,22 +605,22 @@
             str(template),
             "SUM(SUM(x[_2,_1,_3] for _3 in b[_2].K) for _1, _2 in JI)  <=  0",
         )
         # Evaluate the template
         self.assertEqual(
             str(resolve_template(template)),
             'x[1,1,10] + '
-            '(x[2,1,10] + x[2,1,20]) + '
-            '(x[3,1,10] + x[3,1,20] + x[3,1,30]) + '
-            '(x[1,2,10]) + '
-            '(x[2,2,10] + x[2,2,20]) + '
-            '(x[3,2,10] + x[3,2,20] + x[3,2,30]) + '
-            '(x[1,3,10]) + '
-            '(x[2,3,10] + x[2,3,20]) + '
-            '(x[3,3,10] + x[3,3,20] + x[3,3,30])  <=  0',
+            'x[2,1,10] + x[2,1,20] + '
+            'x[3,1,10] + x[3,1,20] + x[3,1,30] + '
+            'x[1,2,10] + '
+            'x[2,2,10] + x[2,2,20] + '
+            'x[3,2,10] + x[3,2,20] + x[3,2,30] + '
+            'x[1,3,10] + '
+            'x[2,3,10] + x[2,3,20] + '
+            'x[3,3,10] + x[3,3,20] + x[3,3,30]  <=  0',
         )
 
     def test_eval_getattr(self):
         m = ConcreteModel()
         m.T = RangeSet(3)
 
         @m.Block(m.T)
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_units.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_units.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_var.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_var.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_var_set_bounds.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_var_set_bounds.py`

 * *Files 0% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 )
 
 solvers = check_available_solvers('glpk')
 
 # GAH: These tests been temporarily disabled. It is no longer the job of Var
 #      to validate its domain at the time of construction. It only needs to
 #      ensure that whatever object is passed as its domain is suitable for
-#      interacting with the _VarData interface (e.g., has a bounds method)
+#      interacting with the VarData interface (e.g., has a bounds method)
 #      The plan is to start adding functionality to the solver interfaces
 #      that will support custom domains.
 
 
 class TestVarSetBounds(unittest.TestCase):
     @unittest.skipIf(not 'glpk' in solvers, "glpk solver is not available")
     def Xtest_rangeset_domain(self):
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_visitor.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_visitor.py`

 * *Files 1% similar despite different names*

```diff
@@ -68,15 +68,15 @@
     sizeof_expression,
     identify_variables,
     identify_components,
     identify_mutable_parameters,
     RECURSION_LIMIT,
     get_stack_depth,
 )
-from pyomo.core.base.param import _ParamData, ScalarParam
+from pyomo.core.base.param import ParamData, ScalarParam
 from pyomo.core.expr.template_expr import IndexTemplate
 from pyomo.common.collections import ComponentSet
 from pyomo.common.errors import TemplateExpressionError
 from pyomo.common.log import LoggingIntercept
 from io import StringIO
 from pyomo.core.expr.compare import assertExpressionsEqual
 
@@ -141,36 +141,43 @@
         # Identify variables in various algebraic expressions
         #
         self.assertEqual(list(identify_variables(m.a)), [m.a])
         self.assertEqual(list(identify_variables(m.b[1])), [m.b[1]])
         self.assertEqual(list(identify_variables(m.a + m.b[1])), [m.a, m.b[1]])
         self.assertEqual(list(identify_variables(m.a ** m.b[1])), [m.a, m.b[1]])
         self.assertEqual(
-            list(identify_variables(m.a ** m.b[1] + m.b[2])), [m.b[2], m.a, m.b[1]]
+            ComponentSet(identify_variables(m.a ** m.b[1] + m.b[2])),
+            ComponentSet([m.b[2], m.a, m.b[1]]),
         )
         self.assertEqual(
             list(identify_variables(m.a ** m.b[1] + m.b[2] * m.b[3] * m.b[2])),
             [m.a, m.b[1], m.b[2], m.b[3]],
         )
         self.assertEqual(
             list(identify_variables(m.a ** m.b[1] + m.b[2] / m.b[3] * m.b[2])),
             [m.a, m.b[1], m.b[2], m.b[3]],
         )
         #
         # Identify variables in the arguments to functions
         #
         self.assertEqual(
-            list(identify_variables(m.x(m.a, 'string_param', 1, []) * m.b[1])),
-            [m.b[1], m.a],
+            ComponentSet(identify_variables(m.x(m.a, 'string_param', 1, []) * m.b[1])),
+            ComponentSet([m.b[1], m.a]),
         )
         self.assertEqual(
             list(identify_variables(m.x(m.p, 'string_param', 1, []) * m.b[1])), [m.b[1]]
         )
-        self.assertEqual(list(identify_variables(tanh(m.a) * m.b[1])), [m.b[1], m.a])
-        self.assertEqual(list(identify_variables(abs(m.a) * m.b[1])), [m.b[1], m.a])
+        self.assertEqual(
+            ComponentSet(identify_variables(tanh(m.a) * m.b[1])),
+            ComponentSet([m.b[1], m.a]),
+        )
+        self.assertEqual(
+            ComponentSet(identify_variables(abs(m.a) * m.b[1])),
+            ComponentSet([m.b[1], m.a]),
+        )
         #
         # Check logic for allowing duplicates
         #
         self.assertEqual(list(identify_variables(m.a**m.a + m.a)), [m.a])
         # self.assertEqual( list(identify_variables(m.a**m.a + m.a, allow_duplicates=True)),
         #                  [ m.a, m.a, m.a,  ] )
 
@@ -433,17 +440,15 @@
         m.x = Var()
         m.y = Var()
         e = LinearExpression(linear_coefs=[2], linear_vars=[m.x])
         e += m.y
         sub_map = dict()
         sub_map[id(m.x)] = 5
         e2 = replace_expressions(e, sub_map)
-        assertExpressionsEqual(
-            self, e2, LinearExpression([10, MonomialTermExpression((1, m.y))])
-        )
+        assertExpressionsEqual(self, e2, LinearExpression([10, m.y]))
 
         e = LinearExpression(linear_coefs=[2, 3], linear_vars=[m.x, m.y])
         sub_map = dict()
         sub_map[id(m.x)] = 5
         e2 = replace_expressions(e, sub_map)
         assertExpressionsEqual(
             self, e2, LinearExpression([10, MonomialTermExpression((3, m.y))])
@@ -683,15 +688,15 @@
 #
 class ReplacementWalkerTest3(ExpressionReplacementVisitor):
     def __init__(self, model):
         super().__init__(remove_named_expressions=False)
         self.model = model
 
     def visiting_potential_leaf(self, node):
-        if node.__class__ in (_ParamData, ScalarParam):
+        if node.__class__ in (ParamData, ScalarParam):
             if id(node) in self.substitute:
                 return True, self.substitute[id(node)]
             self.substitute[id(node)] = 2 * self.model.w.add()
             return True, self.substitute[id(node)]
 
         if (
             node.__class__ in nonpyomo_leaf_types
@@ -882,28 +887,15 @@
 
         e = m.y[1] * m.y[2] + m.y[2] * m.y[3] == 0
         f = ReplacementWalker_ReplaceInternal().dfs_postorder_stack(e)
         assertExpressionsEqual(self, m.y[1] * m.y[2] + m.y[2] * m.y[3] == 0, e)
         assertExpressionsEqual(
             self,
             SumExpression(
-                [
-                    LinearExpression(
-                        [
-                            MonomialTermExpression((1, m.y[1])),
-                            MonomialTermExpression((1, m.y[2])),
-                        ]
-                    ),
-                    LinearExpression(
-                        [
-                            MonomialTermExpression((1, m.y[2])),
-                            MonomialTermExpression((1, m.y[3])),
-                        ]
-                    ),
-                ]
+                [LinearExpression([m.y[1], m.y[2]]), LinearExpression([m.y[2], m.y[3]])]
             )
             == 0,
             f,
         )
 
     def test_replace_nested(self):
         m = ConcreteModel()
@@ -926,17 +918,15 @@
         m.x = Var()
 
         e1 = m.p1 + 2
         e2 = replace_expressions(e1, {id(m.p1): m.p2})
         e3 = replace_expressions(e1, {id(m.p1): m.x})
 
         assertExpressionsEqual(self, e2, m.p2 + 2)
-        assertExpressionsEqual(
-            self, e3, LinearExpression([MonomialTermExpression((1, m.x)), 2])
-        )
+        assertExpressionsEqual(self, e3, LinearExpression([m.x, 2]))
 
     def test_npv_negation(self):
         m = ConcreteModel()
         m.p1 = Param(mutable=True)
         m.p2 = Param(mutable=True)
         m.x = Var()
```

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/test_xfrm_discrete_vars.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/test_xfrm_discrete_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/uninstantiated_model_linear.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/uninstantiated_model_linear.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/tests/unit/uninstantiated_model_quadratic.py` & `Pyomo-6.7.2/pyomo/core/tests/unit/uninstantiated_model_quadratic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/core/util.py` & `Pyomo-6.7.2/pyomo/core/util.py`

 * *Files 0% similar despite different names*

```diff
@@ -14,15 +14,15 @@
 #
 
 from pyomo.common.deprecation import deprecation_warning
 from pyomo.core.expr.numvalue import native_numeric_types
 from pyomo.core.expr.numeric_expr import mutable_expression, NPV_SumExpression
 from pyomo.core.base.var import Var
 from pyomo.core.base.expression import Expression
-from pyomo.core.base.component import _ComponentBase
+from pyomo.core.base.component import ComponentBase
 import logging
 
 logger = logging.getLogger(__name__)
 
 
 def prod(terms):
     """
@@ -234,20 +234,20 @@
         return range(1, args[0] + 1)
     if len(args) == 2:
         return range(args[0], args[1] + 1)
     return range(args[0], args[1] + 1, args[2])
 
 
 def target_list(x):
-    if isinstance(x, _ComponentBase):
+    if isinstance(x, ComponentBase):
         return [x]
     elif hasattr(x, '__iter__'):
         ans = []
         for i in x:
-            if isinstance(i, _ComponentBase):
+            if isinstance(i, ComponentBase):
                 ans.append(i)
             else:
                 raise ValueError(
                     "Expected Component or list of Components."
                     "\n\tReceived %s" % (type(i),)
                 )
         return ans
```

### Comparing `Pyomo-6.7.1/pyomo/dae/__init__.py` & `Pyomo-6.7.2/pyomo/dae/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/contset.py` & `Pyomo-6.7.2/pyomo/dae/contset.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/diffvar.py` & `Pyomo-6.7.2/pyomo/dae/diffvar.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/flatten.py` & `Pyomo-6.7.2/pyomo/dae/flatten.py`

 * *Files 0% similar despite different names*

```diff
@@ -255,23 +255,23 @@
 ):
     """Recursively generate slices of the specified ctype along the
     specified sets
 
     Parameters
     ----------
 
-    b: _BlockData
+    b: BlockData
         Block whose components will be sliced
 
     index_stack: list
         Sets above ``b`` in the block hierarchy, including on its parent
         component, that have been sliced. This is necessary to return the
         sets that have been sliced.
 
-    slice_: IndexedComponent_slice or _BlockData
+    slice_: IndexedComponent_slice or BlockData
         Slice generated so far.  This function will yield extensions to
         this slice at the current level of the block hierarchy.
 
     sets: ComponentSet of Pyomo sets
         Sets that will be sliced
 
     ctype: Subclass of Component
@@ -439,15 +439,15 @@
     """This function iterates over components (recursively) contained
     in a block and partitions their data objects into components
     indexed only by the specified sets.
 
     Parameters
     ----------
 
-    m: _BlockData
+    m: BlockData
         Block whose components (and their sub-components) will be
         partitioned
 
     sets: Tuple of Pyomo Sets
         Sets to be sliced. Returned components will be indexed by
         some combination of these sets, if at all.
 
@@ -542,15 +542,15 @@
 def flatten_dae_components(model, time, ctype, indices=None, active=None):
     """Partitions components into ComponentData and Components indexed only
     by the provided set.
 
     Parameters
     ----------
 
-    model: _BlockData
+    model: BlockData
         Block whose components are partitioned
 
     time: Set
         Indexing by this set (and only this set) will be preserved in the
         returned components.
 
     ctype: Subclass of Component
```

### Comparing `Pyomo-6.7.1/pyomo/dae/initialization.py` & `Pyomo-6.7.2/pyomo/dae/initialization.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/integral.py` & `Pyomo-6.7.2/pyomo/dae/integral.py`

 * *Files 2% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 #  ___________________________________________________________________________
 
 from pyomo.common.deprecation import RenamedClass
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.indexed_component import rule_wrapper
 from pyomo.core.base.expression import (
     Expression,
-    _GeneralExpressionData,
+    ExpressionData,
     ScalarExpression,
     IndexedExpression,
 )
 from pyomo.dae.contset import ContinuousSet
 from pyomo.dae.diffvar import DAE_Error
 
 
@@ -147,15 +147,15 @@
 class ScalarIntegral(ScalarExpression, Integral):
     """
     An integral that will have no indexing sets after applying a numerical
     integration transformation
     """
 
     def __init__(self, *args, **kwds):
-        _GeneralExpressionData.__init__(self, None, component=self)
+        ExpressionData.__init__(self, None, component=self)
         Integral.__init__(self, *args, **kwds)
 
     def clear(self):
         self._data = {}
 
     def is_fully_discretized(self):
         """
```

### Comparing `Pyomo-6.7.1/pyomo/dae/misc.py` & `Pyomo-6.7.2/pyomo/dae/misc.py`

 * *Files 0% similar despite different names*

```diff
@@ -259,15 +259,15 @@
     This method will construct any additional indices in a variable
     resulting from the discretization of a ContinuousSet.
     """
 
     # Note: This is not required it is handled by the _default method on
     #       Var (which is now a IndexedComponent). However, it
     #       would be much slower to rely on that method to generate new
-    #       _VarData for a large number of new indices.
+    #       VarData for a large number of new indices.
     new_indices = set(v.index_set()) - set(v._data.keys())
     for index in new_indices:
         v.add(index)
 
 
 def _update_constraint(con):
     """
```

### Comparing `Pyomo-6.7.1/pyomo/dae/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/dae/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/plugins/colloc.py` & `Pyomo-6.7.2/pyomo/dae/plugins/colloc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/plugins/finitedifference.py` & `Pyomo-6.7.2/pyomo/dae/plugins/finitedifference.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/set_utils.py` & `Pyomo-6.7.2/pyomo/dae/set_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/simulator.py` & `Pyomo-6.7.2/pyomo/dae/simulator.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/__init__.py` & `Pyomo-6.7.2/pyomo/dae/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_colloc.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_colloc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_contset.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_contset.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_diffvar.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_diffvar.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_finite_diff.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_finite_diff.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_flatten.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_flatten.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_initialization.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_initialization.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_integral.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_integral.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_misc.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_misc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_set_utils.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_set_utils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/tests/test_simulator.py` & `Pyomo-6.7.2/pyomo/dae/tests/test_simulator.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dae/utilities.py` & `Pyomo-6.7.2/pyomo/dae/utilities.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/DataPortal.py` & `Pyomo-6.7.2/pyomo/dataportal/DataPortal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/TableData.py` & `Pyomo-6.7.2/pyomo/dataportal/TableData.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/__init__.py` & `Pyomo-6.7.2/pyomo/dataportal/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/factory.py` & `Pyomo-6.7.2/pyomo/dataportal/factory.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/parse_datacmds.py` & `Pyomo-6.7.2/pyomo/dataportal/parse_datacmds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/csv_table.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/csv_table.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/datacommands.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/datacommands.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/db_table.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/db_table.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/json_dict.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/json_dict.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/sheet.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/sheet.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/text.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/text.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/plugins/xml_table.py` & `Pyomo-6.7.2/pyomo/dataportal/plugins/xml_table.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/process_data.py` & `Pyomo-6.7.2/pyomo/dataportal/process_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/tests/__init__.py` & `Pyomo-6.7.2/pyomo/dataportal/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/tests/test_dat_parser.py` & `Pyomo-6.7.2/pyomo/dataportal/tests/test_dat_parser.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/dataportal/tests/test_dataportal.py` & `Pyomo-6.7.2/pyomo/dataportal/tests/test_dataportal.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/duality/__init__.py` & `Pyomo-6.7.2/pyomo/gdp/tests/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,8 +5,10 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-import pyomo.duality.collect
+"""
+pyomo.gdp tests
+"""
```

### Comparing `Pyomo-6.7.1/pyomo/duality/collect.py` & `Pyomo-6.7.2/pyomo/duality/collect.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/duality/lagrangian_dual.py` & `Pyomo-6.7.2/pyomo/duality/lagrangian_dual.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/duality/plugins.py` & `Pyomo-6.7.2/pyomo/duality/plugins.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/duality/tests/__init__.py` & `Pyomo-6.7.2/pyomo/duality/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/duality/tests/test_linear_dual.py` & `Pyomo-6.7.2/pyomo/duality/tests/test_linear_dual.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/environ/__init__.py` & `Pyomo-6.7.2/pyomo/environ/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -46,14 +46,15 @@
     'pyomo.contrib.gjh',
     'pyomo.contrib.gdp_bounds',
     'pyomo.contrib.mcpp',
     'pyomo.contrib.mindtpy',
     'pyomo.contrib.multistart',
     'pyomo.contrib.preprocessing',
     'pyomo.contrib.pynumero',
+    'pyomo.contrib.simplification',
     'pyomo.contrib.solver',
     'pyomo.contrib.trustregion',
 ]
 
 
 def _import_packages():
     #
```

### Comparing `Pyomo-6.7.1/pyomo/environ/tests/__init__.py` & `Pyomo-6.7.2/pyomo/environ/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/environ/tests/standalone_minimal_pyomo_driver.py` & `Pyomo-6.7.2/pyomo/environ/tests/standalone_minimal_pyomo_driver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/environ/tests/test_environ.py` & `Pyomo-6.7.2/pyomo/environ/tests/test_environ.py`

 * *Files 2% similar despite different names*

```diff
@@ -136,14 +136,15 @@
             'argparse',
             'ast',  # Imported on Windows
             'backports_abc',  # Imported by cython on Linux
             'base64',  # Imported on Windows
             'cPickle',
             'csv',
             'ctypes',  # mandatory import in core/base/external.py; TODO: fix this
+            'datetime',  # imported by contrib.solver
             'decimal',
             'gc',  # Imported on MacOS, Windows; Linux in 3.10
             'glob',
             'heapq',  # Added in Python 3.10
             'importlib',
             'inspect',
             'json',  # Imported on Windows
```

### Comparing `Pyomo-6.7.1/pyomo/environ/tests/test_package_layout.py` & `Pyomo-6.7.2/pyomo/environ/tests/test_package_layout.py`

 * *Files 2% similar despite different names*

```diff
@@ -34,14 +34,15 @@
 # List of directories under `pyomo` that intentionally do NOT have
 # __init__.py files (because they either contain no Python files - or
 # contain Python files that are only used in testing and explicitly NOT
 # part of the "Pyomo package")
 _NON_MODULE_DIRS = {
     join('contrib', 'ampl_function_demo', 'src'),
     join('contrib', 'appsi', 'cmodel', 'src'),
+    join('contrib', 'simplification', 'ginac', 'src'),
     join('contrib', 'pynumero', 'src'),
     join('core', 'tests', 'data', 'baselines'),
     join('core', 'tests', 'diet', 'baselines'),
     join('opt', 'tests', 'solver', 'exe_dir'),
     join('solvers', 'tests', 'checks', 'data'),
     join('solvers', 'tests', 'mip', 'asl'),
     join('solvers', 'tests', 'mip', 'cbc'),
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/__init__.py` & `Pyomo-6.7.2/pyomo/opt/solver/__init__.py`

 * *Files 22% similar despite different names*

```diff
@@ -5,13 +5,15 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.gdp.disjunct import GDP_Error, Disjunct, Disjunction
-
-# Do not import these files: importing them registers the transformation
-# plugins with the pyomo script so that they get automatically invoked.
-# import pyomo.gdp.bigm
-# import pyomo.gdp.hull
+from pyomo.opt.solver.shellcmd import (
+    ResultsFormat,
+    OptSolver,
+    SolverStatus,
+    SolverResults,
+    SystemCallSolver,
+)
+from pyomo.opt.solver.ilmcmd import ILMLicensedSystemCallSolver
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/basic_step.py` & `Pyomo-6.7.2/pyomo/gdp/basic_step.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/disjunct.py` & `Pyomo-6.7.2/pyomo/gdp/disjunct.py`

 * *Files 1% similar despite different names*

```diff
@@ -37,15 +37,15 @@
 )
 from pyomo.core.base.component import (
     ActiveComponent,
     ActiveComponentData,
     ComponentData,
 )
 from pyomo.core.base.global_set import UnindexedComponent_index
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base.misc import apply_indexed_rule
 from pyomo.core.base.indexed_component import ActiveIndexedComponent
 from pyomo.core.expr.expr_common import ExpressionType
 
 logger = logging.getLogger('pyomo.gdp')
 
 _rule_returned_none_error = """Disjunction '%s': rule returned None.
@@ -408,53 +408,58 @@
         elif hasattr(arg, '__getitem__'):
             return (_Initializer.dict_like, arg)
         else:
             # Hopefully this thing is castable to the type that is desired
             return (_Initializer.deferred_value, arg)
 
 
-class _DisjunctData(_BlockData):
+class DisjunctData(BlockData):
     __autoslot_mappers__ = {'_transformation_block': AutoSlots.weakref_mapper}
 
     _Block_reserved_words = set()
 
     @property
     def transformation_block(self):
         return (
             None if self._transformation_block is None else self._transformation_block()
         )
 
     def __init__(self, component):
-        _BlockData.__init__(self, component)
+        BlockData.__init__(self, component)
         with self._declare_reserved_components():
             self.indicator_var = AutoLinkedBooleanVar()
             self.binary_indicator_var = AutoLinkedBinaryVar(self.indicator_var)
         self.indicator_var.associate_binary_var(self.binary_indicator_var)
         # pointer to transformation block if this disjunct has been
         # transformed. None indicates it hasn't been transformed.
         self._transformation_block = None
 
     def activate(self):
-        super(_DisjunctData, self).activate()
+        super(DisjunctData, self).activate()
         self.indicator_var.unfix()
 
     def deactivate(self):
-        super(_DisjunctData, self).deactivate()
+        super(DisjunctData, self).deactivate()
         self.indicator_var.fix(False)
 
     def _deactivate_without_fixing_indicator(self):
-        super(_DisjunctData, self).deactivate()
+        super(DisjunctData, self).deactivate()
 
     def _activate_without_unfixing_indicator(self):
-        super(_DisjunctData, self).activate()
+        super(DisjunctData, self).activate()
+
+
+class _DisjunctData(metaclass=RenamedClass):
+    __renamed__new_class__ = DisjunctData
+    __renamed__version__ = '6.7.2'
 
 
 @ModelComponentFactory.register("Disjunctive blocks.")
 class Disjunct(Block):
-    _ComponentDataClass = _DisjunctData
+    _ComponentDataClass = DisjunctData
 
     def __new__(cls, *args, **kwds):
         if cls != Disjunct:
             return super(Disjunct, cls).__new__(cls)
         if args == ():
             return ScalarDisjunct.__new__(ScalarDisjunct)
         else:
@@ -471,43 +476,43 @@
         Block.__init__(self, *args, **kwargs)
 
     # For the time being, this method is not needed.
     #
     # def _deactivate_without_fixing_indicator(self):
     #    # Ideally, this would be a super call from this class.  However,
     #    # doing that would trigger a call to deactivate() on all the
-    #    # _DisjunctData objects (exactly what we want to avoid!)
+    #    # DisjunctData objects (exactly what we want to avoid!)
     #    #
     #    # For the time being, we will do something bad and directly call
     #    # the base class method from where we would otherwise want to
     #    # call this method.
 
     def _activate_without_unfixing_indicator(self):
         # Ideally, this would be a super call from this class.  However,
         # doing that would trigger a call to deactivate() on all the
-        # _DisjunctData objects (exactly what we want to avoid!)
+        # DisjunctData objects (exactly what we want to avoid!)
         #
         # For the time being, we will do something bad and directly call
         # the base class method from where we would otherwise want to
         # call this method.
         ActiveComponent.activate(self)
         if self.is_indexed():
             for component_data in self.values():
                 component_data._activate_without_unfixing_indicator()
 
 
-class ScalarDisjunct(_DisjunctData, Disjunct):
+class ScalarDisjunct(DisjunctData, Disjunct):
     def __init__(self, *args, **kwds):
         ## FIXME: This is a HACK to get around a chicken-and-egg issue
-        ## where _BlockData creates the indicator_var *before*
+        ## where BlockData creates the indicator_var *before*
         ## Block.__init__ declares the _defer_construction flag.
         self._defer_construction = True
         self._suppress_ctypes = set()
 
-        _DisjunctData.__init__(self, self)
+        DisjunctData.__init__(self, self)
         Disjunct.__init__(self, *args, **kwds)
         self._data[None] = self
         self._index = UnindexedComponent_index
 
 
 class SimpleDisjunct(metaclass=RenamedClass):
     __renamed__new_class__ = ScalarDisjunct
@@ -520,33 +525,33 @@
     # that will take time and a PEP
     #
     @property
     def active(self):
         return any(d.active for d in self._data.values())
 
 
-_DisjunctData._Block_reserved_words = set(dir(Disjunct()))
+DisjunctData._Block_reserved_words = set(dir(Disjunct()))
 
 
-class _DisjunctionData(ActiveComponentData):
+class DisjunctionData(ActiveComponentData):
     __slots__ = ('disjuncts', 'xor', '_algebraic_constraint', '_transformation_map')
     __autoslot_mappers__ = {'_algebraic_constraint': AutoSlots.weakref_mapper}
     _NoArgument = (0,)
 
     @property
     def algebraic_constraint(self):
         return (
             None if self._algebraic_constraint is None else self._algebraic_constraint()
         )
 
     def __init__(self, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _ConstraintData,
+        #   - ConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = NOTSET
         self._active = True
         self.disjuncts = []
         self.xor = True
@@ -616,17 +621,22 @@
                         "Unsupported expression type on Disjunct "
                         f"{disjunct.name}: expected either relational or "
                         f"logical expression, found {e.__class__.__name__}"
                     )
             self.disjuncts.append(disjunct)
 
 
+class _DisjunctionData(metaclass=RenamedClass):
+    __renamed__new_class__ = DisjunctionData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("Disjunction expressions.")
 class Disjunction(ActiveIndexedComponent):
-    _ComponentDataClass = _DisjunctionData
+    _ComponentDataClass = DisjunctionData
 
     def __new__(cls, *args, **kwds):
         if cls != Disjunction:
             return super(Disjunction, cls).__new__(cls)
         if args == ():
             return ScalarDisjunction.__new__(ScalarDisjunction)
         else:
@@ -759,28 +769,28 @@
             ],
             self.items(),
             ("Disjuncts", "Active", "XOR"),
             lambda k, v: [[x.name for x in v.disjuncts], v.active, v.xor],
         )
 
 
-class ScalarDisjunction(_DisjunctionData, Disjunction):
+class ScalarDisjunction(DisjunctionData, Disjunction):
     def __init__(self, *args, **kwds):
-        _DisjunctionData.__init__(self, component=self)
+        DisjunctionData.__init__(self, component=self)
         Disjunction.__init__(self, *args, **kwds)
         self._index = UnindexedComponent_index
 
     #
     # Singleton disjunctions are strange in that we want them to be
     # both be constructed but have len() == 0 when not initialized with
     # anything (at least according to the unit tests that are
     # currently in place). So during initialization only, we will
     # treat them as "indexed" objects where things like
     # Constraint.Skip are managed. But after that they will behave
-    # like _DisjunctionData objects where set_value does not handle
+    # like DisjunctionData objects where set_value does not handle
     # Disjunction.Skip but expects a valid expression or None.
     #
 
     def set_value(self, expr):
         """Set the expression on this disjunction."""
         if not self._constructed:
             raise ValueError(
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/between_steps.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/between_steps.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/bigm.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/bigm.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 """Big-M Generalized Disjunctive Programming transformation module."""
 
 import logging
 
+from pyomo.common.autoslots import AutoSlots
 from pyomo.common.collections import ComponentMap
 from pyomo.common.config import ConfigDict, ConfigValue
 from pyomo.common.gc_manager import PauseGC
 from pyomo.common.modeling import unique_component_name
 from pyomo.common.deprecation import deprecated, deprecation_warning
 from pyomo.contrib.cp.transform.logical_to_disjunctive_program import (
     LogicalToDisjunctive,
@@ -54,14 +55,34 @@
 from pyomo.network import Port
 from pyomo.repn import generate_standard_repn
 from weakref import ref as weakref_ref, ReferenceType
 
 logger = logging.getLogger('pyomo.gdp.bigm')
 
 
+class _BigMData(AutoSlots.Mixin):
+    __slots__ = ('bigm_src',)
+
+    def __init__(self):
+        # we will keep a map of constraints (hashable, ha!) to a tuple to
+        # indicate what their M value is and where it came from, of the form:
+        # ((lower_value, lower_source, lower_key), (upper_value, upper_source,
+        # upper_key)), where the first tuple is the information for the lower M,
+        # the second tuple is the info for the upper M, source is the Suffix or
+        # argument dictionary and None if the value was calculated, and key is
+        # the key in the Suffix or argument dictionary, and None if it was
+        # calculated. (Note that it is possible the lower or upper is
+        # user-specified and the other is not, hence the need to store
+        # information for both.)
+        self.bigm_src = {}
+
+
+Block.register_private_data_initializer(_BigMData)
+
+
 @TransformationFactory.register(
     'gdp.bigm', doc="Relax disjunctive model using big-M terms."
 )
 class BigM_Transformation(GDP_to_MIP_Transformation, _BigM_MixIn):
     """Relax disjunctive model using big-M terms.
 
     Relaxes a disjunctive model into an algebraic model by adding Big-M
@@ -90,23 +111,16 @@
 
     Specifying "bigM=N" is automatically mapped to "bigM={None: N}".
 
     The transformation will create a new Block with a unique
     name beginning "_pyomo_gdp_bigm_reformulation".  That Block will
     contain an indexed Block named "relaxedDisjuncts", which will hold
     the relaxed disjuncts.  This block is indexed by an integer
-    indicating the order in which the disjuncts were relaxed.
-    Each block has a dictionary "_constraintMap":
-
-        'srcConstraints': ComponentMap(<transformed constraint>:
-                                       <src constraint>)
-        'transformedConstraints': ComponentMap(<src constraint>:
-                                               <transformed constraint>)
-
-    All transformed Disjuncts will have a pointer to the block their transformed
+    indicating the order in which the disjuncts were relaxed. All
+    transformed Disjuncts will have a pointer to the block their transformed
     constraints are on, and all transformed Disjunctions will have a
     pointer to the corresponding 'Or' or 'ExactlyOne' constraint.
 
     """
 
     CONFIG = ConfigDict("gdp.bigm")
     CONFIG.declare(
@@ -195,95 +209,91 @@
         # the list.
         gdp_tree = self._get_gdp_tree_from_targets(instance, targets)
         preprocessed_targets = gdp_tree.reverse_topological_sort()
 
         bigM = self._config.bigM
         for t in preprocessed_targets:
             if t.ctype is Disjunction:
-                self._transform_disjunctionData(
-                    t,
-                    t.index(),
-                    bigM,
-                    parent_disjunct=gdp_tree.parent(t),
-                    root_disjunct=gdp_tree.root_disjunct(t),
-                )
+                self._transform_disjunctionData(t, t.index(), bigM, gdp_tree)
 
         # issue warnings about anything that was in the bigM args dict that we
         # didn't use
         _warn_for_unused_bigM_args(bigM, self.used_args, logger)
 
-    def _transform_disjunctionData(
-        self, obj, index, bigM, parent_disjunct=None, root_disjunct=None
-    ):
+    def _transform_disjunctionData(self, obj, index, bigM, gdp_tree):
+        parent_disjunct = gdp_tree.parent(obj)
+        root_disjunct = gdp_tree.root_disjunct(obj)
         (transBlock, xorConstraint) = self._setup_transform_disjunctionData(
             obj, root_disjunct
         )
 
         # add or (or xor) constraint
         or_expr = 0
         for disjunct in obj.disjuncts:
             or_expr += disjunct.binary_indicator_var
-            self._transform_disjunct(disjunct, bigM, transBlock)
+            self._transform_disjunct(disjunct, bigM, transBlock, gdp_tree)
 
         if obj.xor:
             xorConstraint[index] = or_expr == 1
         else:
             xorConstraint[index] = or_expr >= 1
         # Mark the DisjunctionData as transformed by mapping it to its XOR
         # constraint.
         obj._algebraic_constraint = weakref_ref(xorConstraint[index])
 
         # and deactivate for the writers
         obj.deactivate()
 
-    def _transform_disjunct(self, obj, bigM, transBlock):
+    def _transform_disjunct(self, obj, bigM, transBlock, gdp_tree):
         # We're not using the preprocessed list here, so this could be
         # inactive. We've already done the error checking in preprocessing, so
         # we just skip it here.
         if not obj.active:
             return
 
         suffix_list = _get_bigM_suffix_list(obj)
         arg_list = self._get_bigM_arg_list(bigM, obj)
 
         relaxationBlock = self._get_disjunct_transformation_block(obj, transBlock)
 
-        # we will keep a map of constraints (hashable, ha!) to a tuple to
-        # indicate what their M value is and where it came from, of the form:
-        # ((lower_value, lower_source, lower_key), (upper_value, upper_source,
-        # upper_key)), where the first tuple is the information for the lower M,
-        # the second tuple is the info for the upper M, source is the Suffix or
-        # argument dictionary and None if the value was calculated, and key is
-        # the key in the Suffix or argument dictionary, and None if it was
-        # calculated. (Note that it is possible the lower or upper is
-        # user-specified and the other is not, hence the need to store
-        # information for both.)
-        relaxationBlock.bigm_src = {}
+        indicator_expression = 0
+        node = obj
+        while node is not None:
+            indicator_expression += 1 - node.binary_indicator_var
+            node = gdp_tree.parent_disjunct(node)
 
         # This is crazy, but if the disjunction has been previously
         # relaxed, the disjunct *could* be deactivated.  This is a big
         # deal for Hull, as it uses the component_objects /
         # component_data_objects generators.  For BigM, that is OK,
         # because we never use those generators with active=True.  I am
         # only noting it here for the future when someone (me?) is
         # comparing the two relaxations.
         #
         # Transform each component within this disjunct
-        self._transform_block_components(obj, obj, bigM, arg_list, suffix_list)
+        self._transform_block_components(
+            obj, obj, bigM, arg_list, suffix_list, indicator_expression
+        )
 
         # deactivate disjunct to keep the writers happy
         obj._deactivate_without_fixing_indicator()
 
     def _transform_constraint(
-        self, obj, disjunct, bigMargs, arg_list, disjunct_suffix_list
+        self,
+        obj,
+        disjunct,
+        bigMargs,
+        arg_list,
+        disjunct_suffix_list,
+        indicator_expression,
     ):
         # add constraint to the transformation block, we'll transform it there.
         transBlock = disjunct._transformation_block()
-        bigm_src = transBlock.bigm_src
-        constraintMap = transBlock._constraintMap
+        bigm_src = transBlock.private_data().bigm_src
+        constraint_map = transBlock.private_data('pyomo.gdp')
 
         disjunctionRelaxationBlock = transBlock.parent_block()
 
         # We will make indexes from ({obj.local_name} x obj.index_set() x ['lb',
         # 'ub']), but don't bother construct that set here, as taking Cartesian
         # products is kind of expensive (and redundant since we have the
         # original model)
@@ -342,15 +352,21 @@
                     "after estimating (if needed) is %s." % (c.name, str(M))
                 )
 
             # save the source information
             bigm_src[c] = (lower, upper)
 
             self._add_constraint_expressions(
-                c, i, M, disjunct.binary_indicator_var, newConstraint, constraintMap
+                c,
+                i,
+                M,
+                disjunct.binary_indicator_var,
+                newConstraint,
+                constraint_map,
+                indicator_expression=indicator_expression,
             )
 
             # deactivate because we relaxed
             c.deactivate()
 
     def _update_M_from_suffixes(self, constraint, suffix_list, lower, upper):
         # It's possible we found half the answer in args, but we are still
@@ -405,15 +421,15 @@
         "information or the get_M_value function if you "
         "only need values.",
         version='5.7.1',
     )
     def get_m_value_src(self, constraint):
         transBlock = _get_constraint_transBlock(constraint)
         ((lower_val, lower_source, lower_key), (upper_val, upper_source, upper_key)) = (
-            transBlock.bigm_src[constraint]
+            transBlock.private_data().bigm_src[constraint]
         )
 
         if (
             constraint.lower is not None
             and constraint.upper is not None
             and (not lower_source is upper_source or not lower_key is upper_key)
         ):
@@ -460,30 +476,30 @@
         ----------
         constraint: Constraint, which must be in the subtree of a transformed
                     Disjunct
         """
         transBlock = _get_constraint_transBlock(constraint)
         # This is a KeyError if it fails, but it is also my fault if it
         # fails... (That is, it's a bug in the mapping.)
-        return transBlock.bigm_src[constraint]
+        return transBlock.private_data().bigm_src[constraint]
 
     def get_M_value(self, constraint):
         """Returns the M values used to transform constraint. Return is a tuple:
         (lower_M_value, upper_M_value). Either can be None if constraint does
         not have a lower or upper bound, respectively.
 
         Parameters
         ----------
         constraint: Constraint, which must be in the subtree of a transformed
                     Disjunct
         """
         transBlock = _get_constraint_transBlock(constraint)
         # This is a KeyError if it fails, but it is also my fault if it
         # fails... (That is, it's a bug in the mapping.)
-        lower, upper = transBlock.bigm_src[constraint]
+        lower, upper = transBlock.private_data().bigm_src[constraint]
         return (lower[0], upper[0])
 
     def get_all_M_values_by_constraint(self, model):
         """Returns a dictionary mapping each constraint to a tuple:
         (lower_M_value, upper_M_value), where either can be None if the
         constraint does not have a lower or upper bound (respectively).
 
@@ -495,17 +511,16 @@
         for disj in model.component_data_objects(
             Disjunct, active=None, descend_into=(Block, Disjunct)
         ):
             transBlock = disj.transformation_block
             # First check if it was transformed at all.
             if transBlock is not None:
                 # If it was transformed with BigM, we get the M values.
-                if hasattr(transBlock, 'bigm_src'):
-                    for cons in transBlock.bigm_src:
-                        m_values[cons] = self.get_M_value(cons)
+                for cons in transBlock.private_data().bigm_src:
+                    m_values[cons] = self.get_M_value(cons)
         return m_values
 
     def get_largest_M_value(self, model):
         """Returns the largest M value for any constraint on the model.
 
         Parameters
         ----------
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/bigm_mixin.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/bigm_mixin.py`

 * *Files 15% similar despite different names*

```diff
@@ -228,48 +228,53 @@
                 "constraint are bounded." % constraint.name
             )
         else:
             M = (expr_lb, expr_ub)
         return tuple(M)
 
     def _add_constraint_expressions(
-        self, c, i, M, indicator_var, newConstraint, constraintMap
+        self,
+        c,
+        i,
+        M,
+        indicator_var,
+        newConstraint,
+        constraint_map,
+        indicator_expression=None,
     ):
         # Since we are both combining components from multiple blocks and using
         # local names, we need to make sure that the first index for
         # transformedConstraints is guaranteed to be unique. We just grab the
         # current length of the list here since that will be monotonically
         # increasing and hence unique. We'll append it to the
         # slightly-more-human-readable constraint name for something familiar
         # but unique. (Note that we really could do this outside of the loop
         # over the constraint indices, but I don't think it matters a lot.)
         unique = len(newConstraint)
         name = c.local_name + "_%s" % unique
+        if indicator_expression is None:
+            indicator_expression = 1 - indicator_var
 
         if c.lower is not None:
             if M[0] is None:
                 raise GDP_Error(
                     "Cannot relax disjunctive constraint '%s' "
                     "because M is not defined." % name
                 )
-            M_expr = M[0] * (1 - indicator_var)
+            M_expr = M[0] * indicator_expression
             newConstraint.add((name, i, 'lb'), c.lower <= c.body - M_expr)
-            constraintMap['transformedConstraints'][c] = [newConstraint[name, i, 'lb']]
-            constraintMap['srcConstraints'][newConstraint[name, i, 'lb']] = c
+            constraint_map.transformed_constraints[c].append(
+                newConstraint[name, i, 'lb']
+            )
+            constraint_map.src_constraint[newConstraint[name, i, 'lb']] = c
         if c.upper is not None:
             if M[1] is None:
                 raise GDP_Error(
                     "Cannot relax disjunctive constraint '%s' "
                     "because M is not defined." % name
                 )
-            M_expr = M[1] * (1 - indicator_var)
+            M_expr = M[1] * indicator_expression
             newConstraint.add((name, i, 'ub'), c.body - M_expr <= c.upper)
-            transformed = constraintMap['transformedConstraints'].get(c)
-            if transformed is not None:
-                constraintMap['transformedConstraints'][c].append(
-                    newConstraint[name, i, 'ub']
-                )
-            else:
-                constraintMap['transformedConstraints'][c] = [
-                    newConstraint[name, i, 'ub']
-                ]
-            constraintMap['srcConstraints'][newConstraint[name, i, 'ub']] = c
+            constraint_map.transformed_constraints[c].append(
+                newConstraint[name, i, 'ub']
+            )
+            constraint_map.src_constraint[newConstraint[name, i, 'ub']] = c
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/bilinear.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/bilinear.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/binary_multiplication.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/binary_multiplication.py`

 * *Files 13% similar despite different names*

```diff
@@ -117,15 +117,15 @@
 
         # deactivate disjunct to keep the writers happy
         obj._deactivate_without_fixing_indicator()
 
     def _transform_constraint(self, obj, disjunct):
         # add constraint to the transformation block, we'll transform it there.
         transBlock = disjunct._transformation_block()
-        constraintMap = transBlock._constraintMap
+        constraint_map = transBlock.private_data('pyomo.gdp')
 
         disjunctionRelaxationBlock = transBlock.parent_block()
 
         # We will make indexes from ({obj.local_name} x obj.index_set() x ['lb',
         # 'ub']), but don't bother construct that set here, as taking Cartesian
         # products is kind of expensive (and redundant since we have the
         # original model)
@@ -133,44 +133,44 @@
 
         for i in sorted(obj.keys()):
             c = obj[i]
             if not c.active:
                 continue
 
             self._add_constraint_expressions(
-                c, i, disjunct.binary_indicator_var, newConstraint, constraintMap
+                c, i, disjunct.binary_indicator_var, newConstraint, constraint_map
             )
 
             # deactivate because we relaxed
             c.deactivate()
 
     def _add_constraint_expressions(
-        self, c, i, indicator_var, newConstraint, constraintMap
+        self, c, i, indicator_var, newConstraint, constraint_map
     ):
         # Since we are both combining components from multiple blocks and using
         # local names, we need to make sure that the first index for
         # transformedConstraints is guaranteed to be unique. We just grab the
         # current length of the list here since that will be monotonically
         # increasing and hence unique. We'll append it to the
         # slightly-more-human-readable constraint name for something familiar
         # but unique. (Note that we really could do this outside of the loop
         # over the constraint indices, but I don't think it matters a lot.)
         unique = len(newConstraint)
         name = c.local_name + "_%s" % unique
-        transformed = constraintMap['transformedConstraints'][c] = []
+        transformed = constraint_map.transformed_constraints[c]
 
         lb, ub = c.lower, c.upper
         if (c.equality or lb is ub) and lb is not None:
             # equality
             newConstraint.add((name, i, 'eq'), (c.body - lb) * indicator_var == 0)
             transformed.append(newConstraint[name, i, 'eq'])
-            constraintMap['srcConstraints'][newConstraint[name, i, 'eq']] = c
+            constraint_map.src_constraint[newConstraint[name, i, 'eq']] = c
         else:
             # inequality
             if lb is not None:
                 newConstraint.add((name, i, 'lb'), 0 <= (c.body - lb) * indicator_var)
                 transformed.append(newConstraint[name, i, 'lb'])
-                constraintMap['srcConstraints'][newConstraint[name, i, 'lb']] = c
+                constraint_map.src_constraint[newConstraint[name, i, 'lb']] = c
             if ub is not None:
                 newConstraint.add((name, i, 'ub'), (c.body - ub) * indicator_var <= 0)
                 transformed.append(newConstraint[name, i, 'ub'])
-                constraintMap['srcConstraints'][newConstraint[name, i, 'ub']] = c
+                constraint_map.src_constraint[newConstraint[name, i, 'ub']] = c
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/bound_pretransformation.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/bound_pretransformation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/chull.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/chull.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/cuttingplane.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/cuttingplane.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/fix_disjuncts.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/fix_disjuncts.py`

 * *Files 1% similar despite different names*

```diff
@@ -48,15 +48,15 @@
     (MI)(N)LP.""",
 )
 class GDP_Disjunct_Fixer(Transformation):
     """Fix disjuncts to their current Boolean values.
 
     This reclassifies all disjuncts in the passed model instance as ctype Block
     and deactivates the constraints and disjunctions within inactive disjuncts.
-    In addition, it transforms relvant LogicalConstraints and BooleanVars so
+    In addition, it transforms relevant LogicalConstraints and BooleanVars so
     that the resulting model is a (MI)(N)LP (where it is only mixed-integer
     if the model contains integer-domain Vars or BooleanVars which were not
     indicator_vars of Disjuncs.
     """
 
     def __init__(self, **kwargs):
         # TODO This uses an integer tolerance. At some point, these should be
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/gdp_to_mip_transformation.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/gdp_to_mip_transformation.py`

 * *Files 4% similar despite different names*

```diff
@@ -7,15 +7,16 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from functools import wraps
 
-from pyomo.common.collections import ComponentMap
+from pyomo.common.autoslots import AutoSlots
+from pyomo.common.collections import ComponentMap, DefaultComponentMap
 from pyomo.common.log import is_debug_set
 from pyomo.common.modeling import unique_component_name
 
 from pyomo.core.base import Transformation, TransformationFactory
 from pyomo.core.base.external import ExternalFunction
 from pyomo.core import (
     Any,
@@ -44,14 +45,25 @@
     _warn_for_active_disjunct,
 )
 from pyomo.network import Port
 
 from weakref import ref as weakref_ref
 
 
+class _GDPTransformationData(AutoSlots.Mixin):
+    __slots__ = ('src_constraint', 'transformed_constraints')
+
+    def __init__(self):
+        self.src_constraint = ComponentMap()
+        self.transformed_constraints = DefaultComponentMap(list)
+
+
+Block.register_private_data_initializer(_GDPTransformationData, scope='pyomo.gdp')
+
+
 class GDP_to_MIP_Transformation(Transformation):
     """
     Base class for transformations from GDP to MIP
     """
 
     def __init__(self, logger):
         """Initialize transformation object."""
@@ -239,22 +251,15 @@
             return disjunct.transformation_block
 
         # create a relaxation block for this disjunct
         relaxedDisjuncts = transBlock.relaxedDisjuncts
         relaxationBlock = relaxedDisjuncts[len(relaxedDisjuncts)]
 
         relaxationBlock.transformedConstraints = Constraint(Any)
-
         relaxationBlock.localVarReferences = Block()
-        # add the map that will link back and forth between transformed
-        # constraints and their originals.
-        relaxationBlock._constraintMap = {
-            'srcConstraints': ComponentMap(),
-            'transformedConstraints': ComponentMap(),
-        }
 
         # add mappings to source disjunct (so we'll know we've relaxed)
         disjunct._transformation_block = weakref_ref(relaxationBlock)
         relaxationBlock._src_disjunct = weakref_ref(disjunct)
 
         return relaxationBlock
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/gdp_var_mover.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/gdp_var_mover.py`

 * *Files 0% similar despite different names*

```diff
@@ -111,15 +111,15 @@
                         )
 
             # Reclassify this disjunct as a block
             disjunct_component.parent_block().reclassify_component_type(
                 disjunct_component, Block
             )
             # HACK: activate the block, but do not activate the
-            # _BlockData objects
+            # BlockData objects
             super(ActiveIndexedComponent, disjunct_component).activate()
 
             # Deactivate all constraints.  Note that we only need to
             # descend into blocks: we will catch disjuncts in the outer
             # loop.
             #
             # Note that we defer this until AFTER we reactivate the
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/hull.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/hull.py`

 * *Files 3% similar despite different names*

```diff
@@ -38,15 +38,15 @@
     RangeSet,
     Reals,
     value,
     NonNegativeIntegers,
     Binary,
 )
 from pyomo.gdp import Disjunct, Disjunction, GDP_Error
-from pyomo.gdp.disjunct import _DisjunctData
+from pyomo.gdp.disjunct import DisjunctData
 from pyomo.gdp.plugins.gdp_to_mip_transformation import GDP_to_MIP_Transformation
 from pyomo.gdp.transformed_disjunct import _TransformedDisjunct
 from pyomo.gdp.util import (
     clone_without_expression_components,
     is_child_of,
     _warn_for_active_disjunct,
 )
@@ -54,20 +54,26 @@
 from pyomo.util.vars_from_expressions import get_vars_from_components
 from weakref import ref as weakref_ref
 
 logger = logging.getLogger('pyomo.gdp.hull')
 
 
 class _HullTransformationData(AutoSlots.Mixin):
-    __slots__ = ('disaggregated_var_map', 'original_var_map', 'bigm_constraint_map')
+    __slots__ = (
+        'disaggregated_var_map',
+        'original_var_map',
+        'bigm_constraint_map',
+        'disaggregation_constraint_map',
+    )
 
     def __init__(self):
         self.disaggregated_var_map = DefaultComponentMap(ComponentMap)
         self.original_var_map = ComponentMap()
         self.bigm_constraint_map = DefaultComponentMap(ComponentMap)
+        self.disaggregation_constraint_map = DefaultComponentMap(ComponentMap)
 
 
 Block.register_private_data_initializer(_HullTransformationData)
 
 
 @TransformationFactory.register(
     'gdp.hull', doc="Relax disjunctive model by forming the hull reformulation."
@@ -91,32 +97,19 @@
     targets : (block, disjunction, or list of those types)
         The targets to transform. This can be a block, disjunction, or a
         list of blocks and Disjunctions [default: the instance]
 
     The transformation will create a new Block with a unique
     name beginning "_pyomo_gdp_hull_reformulation". It will contain an
     indexed Block named "relaxedDisjuncts" that will hold the relaxed
-    disjuncts.  This block is indexed by an integer indicating the order
-    in which the disjuncts were relaxed. Each block has a dictionary
-    "_constraintMap":
-
-        'srcConstraints': ComponentMap(<transformed constraint>:
-                                       <src constraint>),
-        'transformedConstraints':
-            ComponentMap(<src constraint container> :
-                         <transformed constraint container>,
-                         <src constraintData> : [<transformed constraintDatas>])
-
-    All transformed Disjuncts will have a pointer to the block their transformed
-    constraints are on, and all transformed Disjunctions will have a
-    pointer to the corresponding OR or XOR constraint.
-
-    The _pyomo_gdp_hull_reformulation block will have a ComponentMap
-    "_disaggregationConstraintMap":
-        <src var>:ComponentMap(<srcDisjunction>: <disaggregation constraint>)
+    disjuncts. This block is indexed by an integer indicating the order
+    in which the disjuncts were relaxed. All transformed Disjuncts will
+    have a pointer to the block their transformed constraints are on,
+    and all transformed Disjunctions will have a pointer to the
+    corresponding OR or XOR constraint.
     """
 
     CONFIG = cfg.ConfigDict('gdp.hull')
     CONFIG.declare(
         'targets',
         cfg.ConfigValue(
             default=None,
@@ -290,18 +283,14 @@
 
         transBlock.lbub = Set(initialize=['lb', 'ub', 'eq'])
 
         # We will store all of the disaggregation constraints for any
         # Disjunctions we transform onto this block here.
         transBlock.disaggregationConstraints = Constraint(NonNegativeIntegers)
 
-        # This will map from srcVar to a map of srcDisjunction to the
-        # disaggregation constraint corresponding to srcDisjunction
-        transBlock._disaggregationConstraintMap = ComponentMap()
-
         # we are going to store some of the disaggregated vars directly here
         # when we have vars that don't appear in every disjunct
         transBlock._disaggregatedVars = Var(NonNegativeIntegers, dense=False)
         transBlock._boundsConstraints = Constraint(NonNegativeIntegers, transBlock.lbub)
 
         return transBlock, True
 
@@ -326,15 +315,17 @@
         # that, we actually need everything to get transformed again as we go up
         # the nested hierarchy (if there is one)
         transBlock, xorConstraint = self._setup_transform_disjunctionData(
             obj, root_disjunct=None
         )
 
         disaggregationConstraint = transBlock.disaggregationConstraints
-        disaggregationConstraintMap = transBlock._disaggregationConstraintMap
+        disaggregationConstraintMap = (
+            transBlock.private_data().disaggregation_constraint_map
+        )
         disaggregatedVars = transBlock._disaggregatedVars
         disaggregated_var_bounds = transBlock._boundsConstraints
 
         # We first go through and collect all the variables that we are going to
         # disaggregate. We do this in its own pass because we want to know all
         # the Disjuncts that each Var appears in since that will tell us exactly
         # which diaggregated variables we need.
@@ -495,21 +486,15 @@
             # constraint will be transformed again. (And if it turns out
             # everything in it is local, then that transformation won't actually
             # change the mathematical expression, so it's okay.
             disaggregationConstraint.add(cons_idx, var == disaggregatedExpr)
             # and update the map so that we can find this later. We index by
             # variable and the particular disjunction because there is a
             # different one for each disjunction
-            if var in disaggregationConstraintMap:
-                disaggregationConstraintMap[var][obj] = disaggregationConstraint[
-                    cons_idx
-                ]
-            else:
-                thismap = disaggregationConstraintMap[var] = ComponentMap()
-                thismap[obj] = disaggregationConstraint[cons_idx]
+            disaggregationConstraintMap[var][obj] = disaggregationConstraint[cons_idx]
 
         # deactivate for the writers
         obj.deactivate()
 
     def _transform_disjunct(
         self,
         obj,
@@ -671,15 +656,15 @@
         return local_var_list
 
     def _transform_constraint(
         self, obj, disjunct, var_substitute_map, zero_substitute_map
     ):
         # we will put a new transformed constraint on the relaxation block.
         relaxationBlock = disjunct._transformation_block()
-        constraintMap = relaxationBlock._constraintMap
+        constraint_map = relaxationBlock.private_data('pyomo.gdp')
 
         # We will make indexes from ({obj.local_name} x obj.index_set() x ['lb',
         # 'ub']), but don't bother construct that set here, as taking Cartesian
         # products is kind of expensive (and redundant since we have the
         # original model)
         newConstraint = relaxationBlock.transformedConstraints
 
@@ -753,96 +738,88 @@
                         # will also be fixed to 0.
                         v[0].fix(0)
                         # ESJ: If you ask where the transformed constraint is,
                         # the answer is nowhere. Really, it is in the bounds of
                         # this variable, so I'm going to return
                         # it. Alternatively we could return an empty list, but I
                         # think I like this better.
-                        constraintMap['transformedConstraints'][c] = [v[0]]
+                        constraint_map.transformed_constraints[c].append(v[0])
                         # Reverse map also (this is strange)
-                        constraintMap['srcConstraints'][v[0]] = c
+                        constraint_map.src_constraint[v[0]] = c
                         continue
                     newConsExpr = expr - (1 - y) * h_0 == c.lower * y
 
                 if obj.is_indexed():
                     newConstraint.add((name, i, 'eq'), newConsExpr)
-                    # map the _ConstraintDatas (we mapped the container above)
-                    constraintMap['transformedConstraints'][c] = [
+                    # map the ConstraintDatas (we mapped the container above)
+                    constraint_map.transformed_constraints[c].append(
                         newConstraint[name, i, 'eq']
-                    ]
-                    constraintMap['srcConstraints'][newConstraint[name, i, 'eq']] = c
+                    )
+                    constraint_map.src_constraint[newConstraint[name, i, 'eq']] = c
                 else:
                     newConstraint.add((name, 'eq'), newConsExpr)
-                    # map to the _ConstraintData (And yes, for
+                    # map to the ConstraintData (And yes, for
                     # ScalarConstraints, this is overwriting the map to the
                     # container we made above, and that is what I want to
                     # happen. ScalarConstraints will map to lists. For
                     # IndexedConstraints, we can map the container to the
                     # container, but more importantly, we are mapping the
-                    # _ConstraintDatas to each other above)
-                    constraintMap['transformedConstraints'][c] = [
+                    # ConstraintDatas to each other above)
+                    constraint_map.transformed_constraints[c].append(
                         newConstraint[name, 'eq']
-                    ]
-                    constraintMap['srcConstraints'][newConstraint[name, 'eq']] = c
+                    )
+                    constraint_map.src_constraint[newConstraint[name, 'eq']] = c
 
                 continue
 
             if c.lower is not None:
                 if self._generate_debug_messages:
                     _name = c.getname(fully_qualified=True)
                     logger.debug("GDP(Hull): Transforming constraint " + "'%s'", _name)
                 if NL:
                     newConsExpr = expr >= c.lower * y
                 else:
                     newConsExpr = expr - (1 - y) * h_0 >= c.lower * y
 
                 if obj.is_indexed():
                     newConstraint.add((name, i, 'lb'), newConsExpr)
-                    constraintMap['transformedConstraints'][c] = [
+                    constraint_map.transformed_constraints[c].append(
                         newConstraint[name, i, 'lb']
-                    ]
-                    constraintMap['srcConstraints'][newConstraint[name, i, 'lb']] = c
+                    )
+                    constraint_map.src_constraint[newConstraint[name, i, 'lb']] = c
                 else:
                     newConstraint.add((name, 'lb'), newConsExpr)
-                    constraintMap['transformedConstraints'][c] = [
+                    constraint_map.transformed_constraints[c].append(
                         newConstraint[name, 'lb']
-                    ]
-                    constraintMap['srcConstraints'][newConstraint[name, 'lb']] = c
+                    )
+                    constraint_map.src_constraint[newConstraint[name, 'lb']] = c
 
             if c.upper is not None:
                 if self._generate_debug_messages:
                     _name = c.getname(fully_qualified=True)
                     logger.debug("GDP(Hull): Transforming constraint " + "'%s'", _name)
                 if NL:
                     newConsExpr = expr <= c.upper * y
                 else:
                     newConsExpr = expr - (1 - y) * h_0 <= c.upper * y
 
                 if obj.is_indexed():
                     newConstraint.add((name, i, 'ub'), newConsExpr)
                     # map (have to account for fact we might have created list
                     # above
-                    transformed = constraintMap['transformedConstraints'].get(c)
-                    if transformed is not None:
-                        transformed.append(newConstraint[name, i, 'ub'])
-                    else:
-                        constraintMap['transformedConstraints'][c] = [
-                            newConstraint[name, i, 'ub']
-                        ]
-                    constraintMap['srcConstraints'][newConstraint[name, i, 'ub']] = c
+                    constraint_map.transformed_constraints[c].append(
+                        newConstraint[name, i, 'ub']
+                    )
+                    constraint_map.src_constraint[newConstraint[name, i, 'ub']] = c
                 else:
                     newConstraint.add((name, 'ub'), newConsExpr)
-                    transformed = constraintMap['transformedConstraints'].get(c)
-                    if transformed is not None:
-                        transformed.append(newConstraint[name, 'ub'])
-                    else:
-                        constraintMap['transformedConstraints'][c] = [
-                            newConstraint[name, 'ub']
-                        ]
-                    constraintMap['srcConstraints'][newConstraint[name, 'ub']] = c
+                    constraint_map.transformed_constraints[c].append(
+                        newConstraint[name, 'ub']
+                    )
+                    constraint_map.src_constraint[newConstraint[name, 'ub']] = c
 
         # deactivate now that we have transformed
         obj.deactivate()
 
     def _get_local_var_suffix(self, disjunct):
         # If the Suffix is there, we will borrow it. If not, we make it. If it's
         # something else, we complain.
@@ -927,17 +904,19 @@
             raise GDP_Error(
                 "Disjunction '%s' has not been properly "
                 "transformed:"
                 " None of its disjuncts are transformed." % disjunction.name
             )
 
         try:
-            cons = transBlock.parent_block()._disaggregationConstraintMap[original_var][
-                disjunction
-            ]
+            cons = (
+                transBlock.parent_block()
+                .private_data()
+                .disaggregation_constraint_map[original_var][disjunction]
+            )
         except:
             if raise_exception:
                 logger.error(
                     "It doesn't appear that '%s' is a variable that was "
                     "disaggregated by Disjunction '%s'"
                     % (original_var.name, disjunction.name)
                 )
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/multiple_bigm.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/multiple_bigm.py`

 * *Files 8% similar despite different names*

```diff
@@ -355,15 +355,15 @@
 
         # deactivate disjunct so writers can be happy
         obj._deactivate_without_fixing_indicator()
 
     def _transform_constraint(self, obj, disjunct, active_disjuncts, Ms):
         # we will put a new transformed constraint on the relaxation block.
         relaxationBlock = disjunct._transformation_block()
-        constraintMap = relaxationBlock._constraintMap
+        constraint_map = relaxationBlock.private_data('pyomo.gdp')
         transBlock = relaxationBlock.parent_block()
 
         # Though rare, it is possible to get naming conflicts here
         # since constraints from all blocks are getting moved onto the
         # same block. So we get a unique name
         name = unique_component_name(
             relaxationBlock, obj.getname(fully_qualified=False)
@@ -374,15 +374,15 @@
 
         for i in sorted(obj.keys()):
             c = obj[i]
             if not c.active:
                 continue
 
             if not self._config.only_mbigm_bound_constraints:
-                transformed = []
+                transformed = constraint_map.transformed_constraints[c]
                 if c.lower is not None:
                     rhs = sum(
                         Ms[c, disj][0] * disj.indicator_var.get_associated_binary()
                         for disj in active_disjuncts
                         if disj is not disjunct
                     )
                     newConstraint.add((i, 'lb'), c.body - c.lower >= rhs)
@@ -393,16 +393,15 @@
                         Ms[c, disj][1] * disj.indicator_var.get_associated_binary()
                         for disj in active_disjuncts
                         if disj is not disjunct
                     )
                     newConstraint.add((i, 'ub'), c.body - c.upper <= rhs)
                     transformed.append(newConstraint[i, 'ub'])
                 for c_new in transformed:
-                    constraintMap['srcConstraints'][c_new] = [c]
-                constraintMap['transformedConstraints'][c] = transformed
+                    constraint_map.src_constraint[c_new] = [c]
             else:
                 lower = (None, None, None)
                 upper = (None, None, None)
 
                 if disjunct not in self._arg_list:
                     self._arg_list[disjunct] = self._get_bigM_arg_list(
                         self._config.bigM, disjunct
@@ -423,15 +422,15 @@
                     upper = (M[1], None, None)
                 self._add_constraint_expressions(
                     c,
                     i,
                     M,
                     disjunct.indicator_var.get_associated_binary(),
                     newConstraint,
-                    constraintMap,
+                    constraint_map,
                 )
 
             # deactivate now that we have transformed
             c.deactivate()
 
     def _transform_bound_constraints(self, active_disjuncts, transBlock, Ms):
         # first we're just going to find all of them
@@ -492,14 +491,15 @@
         for i, (v, (lower_dict, upper_dict)) in enumerate(bounds_cons.items()):
             lower_rhs = 0
             upper_rhs = 0
             for disj in active_disjuncts:
                 relaxationBlock = self._get_disjunct_transformation_block(
                     disj, transBlock
                 )
+                constraint_map = relaxationBlock.private_data('pyomo.gdp')
                 if len(lower_dict) > 0:
                     M = lower_dict.get(disj, None)
                     if M is None:
                         # substitute the lower bound if it has one
                         M = v.lb
                     if M is None:
                         raise GDP_Error(
@@ -523,47 +523,32 @@
                             "the special bound constraint relaxation without "
                             "one of these." % (v.name, disj.name)
                         )
                     upper_rhs += M * disj.indicator_var.get_associated_binary()
             idx = i + offset
             if len(lower_dict) > 0:
                 transformed.add((idx, 'lb'), v >= lower_rhs)
-                relaxationBlock._constraintMap['srcConstraints'][
-                    transformed[idx, 'lb']
-                ] = []
+                constraint_map.src_constraint[transformed[idx, 'lb']] = []
                 for c, disj in lower_bound_constraints_by_var[v]:
-                    relaxationBlock._constraintMap['srcConstraints'][
-                        transformed[idx, 'lb']
-                    ].append(c)
-                    disj.transformation_block._constraintMap['transformedConstraints'][
-                        c
-                    ] = [transformed[idx, 'lb']]
+                    constraint_map.src_constraint[transformed[idx, 'lb']].append(c)
+                    disj.transformation_block.private_data(
+                        'pyomo.gdp'
+                    ).transformed_constraints[c].append(transformed[idx, 'lb'])
             if len(upper_dict) > 0:
                 transformed.add((idx, 'ub'), v <= upper_rhs)
-                relaxationBlock._constraintMap['srcConstraints'][
-                    transformed[idx, 'ub']
-                ] = []
+                constraint_map.src_constraint[transformed[idx, 'ub']] = []
                 for c, disj in upper_bound_constraints_by_var[v]:
-                    relaxationBlock._constraintMap['srcConstraints'][
-                        transformed[idx, 'ub']
-                    ].append(c)
+                    constraint_map.src_constraint[transformed[idx, 'ub']].append(c)
                     # might already be here if it had an upper bound
-                    if (
-                        c
-                        in disj.transformation_block._constraintMap[
-                            'transformedConstraints'
-                        ]
-                    ):
-                        disj.transformation_block._constraintMap[
-                            'transformedConstraints'
-                        ][c].append(transformed[idx, 'ub'])
-                    else:
-                        disj.transformation_block._constraintMap[
-                            'transformedConstraints'
-                        ][c] = [transformed[idx, 'ub']]
+                    disj_constraint_map = disj.transformation_block.private_data(
+                        'pyomo.gdp'
+                    )
+                    disj_constraint_map.transformed_constraints[c].append(
+                        transformed[idx, 'ub']
+                    )
 
         return transformed_constraints
 
     def _add_transformation_block(self, to_block):
         transBlock, new_block = super()._add_transformation_block(to_block)
 
         if new_block:
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/partition_disjuncts.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/partition_disjuncts.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/plugins/transform_current_disjunctive_state.py` & `Pyomo-6.7.2/pyomo/gdp/plugins/transform_current_disjunctive_state.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/__init__.py` & `Pyomo-6.7.2/pyomo/mpec/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/common_tests.py` & `Pyomo-6.7.2/pyomo/gdp/tests/common_tests.py`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
     BooleanVar,
     SolverFactory,
     TerminationCondition,
 )
 from pyomo.gdp import Disjunct, Disjunction, GDP_Error
 from pyomo.core.expr.compare import assertExpressionsEqual
 from pyomo.core.base import constraint, ComponentUID
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.repn import generate_standard_repn
 import pyomo.core.expr as EXPR
 import pyomo.gdp.tests.models as models
 from io import StringIO
 import random
 
 import pyomo.opt
@@ -421,20 +421,15 @@
 
 def check_two_term_disjunction_xor(self, xor, disj1, disj2):
     self.assertIsInstance(xor, Constraint)
     self.assertEqual(len(xor), 1)
     assertExpressionsEqual(
         self,
         xor.body,
-        EXPR.LinearExpression(
-            [
-                EXPR.MonomialTermExpression((1, disj1.binary_indicator_var)),
-                EXPR.MonomialTermExpression((1, disj2.binary_indicator_var)),
-            ]
-        ),
+        EXPR.LinearExpression([disj1.binary_indicator_var, disj2.binary_indicator_var]),
     )
     self.assertEqual(xor.lower, 1)
     self.assertEqual(xor.upper, 1)
 
 
 def check_xor_constraint(self, transformation):
     # verify xor constraint for a SimpleDisjunction
@@ -953,26 +948,24 @@
         m, targets=[m.disjunction[2]]
     )
 
     # we got a transformation block on the model
     transBlock = m.component("_pyomo_gdp_%s_reformulation" % transformation)
     self.assertIsInstance(transBlock, Block)
     self.assertIsInstance(transBlock.component("disjunction_xor"), Constraint)
-    self.assertIsInstance(
-        transBlock.disjunction_xor[2], constraint._GeneralConstraintData
-    )
+    self.assertIsInstance(transBlock.disjunction_xor[2], constraint.ConstraintData)
     self.assertIsInstance(transBlock.component("relaxedDisjuncts"), Block)
     self.assertEqual(len(transBlock.relaxedDisjuncts), 3)
 
     # suppose we transform the next one separately
     TransformationFactory('gdp.%s' % transformation).apply_to(
         m, targets=[m.disjunction[1]]
     )
     self.assertIsInstance(
-        m.disjunction[1].algebraic_constraint, constraint._GeneralConstraintData
+        m.disjunction[1].algebraic_constraint, constraint.ConstraintData
     )
     transBlock = m.component("_pyomo_gdp_%s_reformulation_4" % transformation)
     self.assertIsInstance(transBlock, Block)
     self.assertEqual(len(transBlock.relaxedDisjuncts), 3)
 
 
 def check_disjunction_data_target_any_index(self, transformation):
@@ -1705,18 +1698,18 @@
 
 
 def check_all_components_transformed(self, m):
     # checks that all the disjunctive components claim to be transformed in the
     # makeNestedDisjunctions_NestedDisjuncts model.
     self.assertIsInstance(m.disj.algebraic_constraint, Constraint)
     self.assertIsInstance(m.d1.disj2.algebraic_constraint, Constraint)
-    self.assertIsInstance(m.d1.transformation_block, _BlockData)
-    self.assertIsInstance(m.d2.transformation_block, _BlockData)
-    self.assertIsInstance(m.d1.d3.transformation_block, _BlockData)
-    self.assertIsInstance(m.d1.d4.transformation_block, _BlockData)
+    self.assertIsInstance(m.d1.transformation_block, BlockData)
+    self.assertIsInstance(m.d2.transformation_block, BlockData)
+    self.assertIsInstance(m.d1.d3.transformation_block, BlockData)
+    self.assertIsInstance(m.d1.d4.transformation_block, BlockData)
 
 
 def check_transformation_blocks_nestedDisjunctions(self, m, transformation):
     disjunctionTransBlock = m.disj.algebraic_constraint.parent_block()
     transBlocks = disjunctionTransBlock.relaxedDisjuncts
     if transformation == 'bigm':
         self.assertEqual(len(transBlocks), 4)
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/models.py` & `Pyomo-6.7.2/pyomo/gdp/tests/models.py`

 * *Files 0% similar despite different names*

```diff
@@ -836,15 +836,15 @@
 
 
 def makeAnyIndexedDisjunctionOfDisjunctDatas():
     """An IndexedDisjunction indexed by Any, with two two-term DisjunctionDatas
     build from DisjunctDatas. Identical mathematically to
     makeDisjunctionOfDisjunctDatas.
 
-    Used to test that the right things happen for a case where soemone
+    Used to test that the right things happen for a case where someone
     implements an algorithm which iteratively generates disjuncts and
     retransforms"""
     m = ConcreteModel()
     m.x = Var(bounds=(-100, 100))
 
     m.obj = Objective(expr=m.x)
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_basic_step.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_basic_step.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_bigm.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_bigm.py`

 * *Files 3% similar despite different names*

```diff
@@ -15,23 +15,26 @@
 
 from pyomo.environ import (
     TransformationFactory,
     Block,
     Set,
     Constraint,
     ComponentMap,
+    LogicalConstraint,
+    Objective,
     SolverFactory,
     Suffix,
+    TerminationCondition,
     ConcreteModel,
     Var,
     Any,
     value,
 )
 from pyomo.gdp import Disjunct, Disjunction, GDP_Error
-from pyomo.core.base import constraint, _ConstraintData
+from pyomo.core.base import constraint, ConstraintData
 from pyomo.core.expr.compare import (
     assertExpressionsEqual,
     assertExpressionsStructurallyEqual,
 )
 from pyomo.repn import generate_standard_repn
 from pyomo.repn.linear import LinearRepnVisitor
 from pyomo.common.log import LoggingIntercept
@@ -151,18 +154,15 @@
         # check or constraint is an or (upper bound is None)
         orcons = m._pyomo_gdp_bigm_reformulation.component("disjunction_xor")
         self.assertIsInstance(orcons, Constraint)
         assertExpressionsEqual(
             self,
             orcons.body,
             EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, m.d[0].binary_indicator_var)),
-                    EXPR.MonomialTermExpression((1, m.d[1].binary_indicator_var)),
-                ]
+                [m.d[0].binary_indicator_var, m.d[1].binary_indicator_var]
             ),
         )
         self.assertEqual(orcons.lower, 1)
         self.assertIsNone(orcons.upper)
 
     def test_deactivated_constraints(self):
         ct.check_deactivated_constraints(self, 'bigm')
@@ -652,22 +652,22 @@
             self.assertIs(bigm.get_src_disjunct(transformedDisjunct), srcDisjunct)
             self.assertIs(transformedDisjunct, srcDisjunct.transformation_block)
 
             transformed = bigm.get_transformed_constraints(srcDisjunct.c)
             if src[0]:
                 # equality
                 self.assertEqual(len(transformed), 2)
-                self.assertIsInstance(transformed[0], _ConstraintData)
-                self.assertIsInstance(transformed[1], _ConstraintData)
+                self.assertIsInstance(transformed[0], ConstraintData)
+                self.assertIsInstance(transformed[1], ConstraintData)
                 self.assertIs(bigm.get_src_constraint(transformed[0]), srcDisjunct.c)
                 self.assertIs(bigm.get_src_constraint(transformed[1]), srcDisjunct.c)
             else:
                 # >=
                 self.assertEqual(len(transformed), 1)
-                self.assertIsInstance(transformed[0], _ConstraintData)
+                self.assertIsInstance(transformed[0], ConstraintData)
                 # check reverse map from the container
                 self.assertIs(bigm.get_src_constraint(transformed[0]), srcDisjunct.c)
 
     def test_deactivated_disjuncts(self):
         ct.check_deactivated_disjuncts(self, 'bigm')
 
     def test_deactivated_disjunction(self):
@@ -1312,34 +1312,26 @@
         m.BigM = Suffix(direction=Suffix.LOCAL)
         m.BigM[None] = 30
         m.b.simpledisj1.c[1].deactivate()
         bigm = TransformationFactory('gdp.bigm')
         bigm.apply_to(m)
 
         # the real test: This wasn't transformed
-        log = StringIO()
-        with LoggingIntercept(log, 'pyomo.gdp', logging.ERROR):
-            self.assertRaisesRegex(
-                KeyError,
-                r".*b.simpledisj1.c\[1\]",
-                bigm.get_transformed_constraints,
-                m.b.simpledisj1.c[1],
-            )
-        self.assertRegex(
-            log.getvalue(),
-            r".*Constraint 'b.simpledisj1.c\[1\]' has not been transformed.",
-        )
+        with self.assertRaisesRegex(
+            GDP_Error, r"Constraint 'b.simpledisj1.c\[1\]' has not been transformed."
+        ):
+            bigm.get_transformed_constraints(m.b.simpledisj1.c[1])
 
         # and the rest of the container was transformed
         cons_list = bigm.get_transformed_constraints(m.b.simpledisj1.c[2])
         self.assertEqual(len(cons_list), 2)
         lb = cons_list[0]
         ub = cons_list[1]
-        self.assertIsInstance(lb, constraint._GeneralConstraintData)
-        self.assertIsInstance(ub, constraint._GeneralConstraintData)
+        self.assertIsInstance(lb, constraint.ConstraintData)
+        self.assertIsInstance(ub, constraint.ConstraintData)
 
     def checkMs(
         self, m, disj1c1lb, disj1c1ub, disj1c2lb, disj1c2ub, disj2c1ub, disj2c2ub
     ):
         bigm = TransformationFactory('gdp.bigm')
         m_values = bigm.get_all_M_values_by_constraint(m)
 
@@ -1886,20 +1878,19 @@
         self.assertIsNone(u_key)
         self.assertEqual(l_val, -58)
         self.assertIsNone(u_val)
 
     # many of the transformed constraints look like this, so can call this
     # function to test them.
     def check_bigM_constraint(self, cons, variable, M, indicator_var):
-        repn = generate_standard_repn(cons.body)
-        self.assertTrue(repn.is_linear())
-        self.assertEqual(repn.constant, -M)
-        self.assertEqual(len(repn.linear_vars), 2)
-        ct.check_linear_coef(self, repn, variable, 1)
-        ct.check_linear_coef(self, repn, indicator_var, M)
+        assertExpressionsEqual(
+            self,
+            cons.body,
+            variable - float(M) * (1 - indicator_var.get_associated_binary()),
+        )
 
     def check_inner_xor_constraint(self, inner_disjunction, outer_disjunct, bigm):
         inner_xor = inner_disjunction.algebraic_constraint
         sum_indicators = sum(
             d.binary_indicator_var for d in inner_disjunction.disjuncts
         )
         assertExpressionsEqual(self, inner_xor.expr, sum_indicators == 1)
@@ -1956,54 +1947,90 @@
                                                 (
                                                     -1,
                                                     m.disjunct[1]
                                                     .innerdisjunct[0]
                                                     .binary_indicator_var,
                                                 )
                                             ),
+                                            1,
+                                            EXPR.MonomialTermExpression(
+                                                (-1, m.disjunct[1].binary_indicator_var)
+                                            ),
                                         ]
                                     ),
                                 )
                             ),
                         )
                     ),
                 ]
             ),
         )
-        self.assertIsNone(cons1ub.lower)
-        self.assertEqual(cons1ub.upper, 0)
-        self.check_bigM_constraint(
-            cons1ub, m.z, 10, m.disjunct[1].innerdisjunct[0].indicator_var
+        assertExpressionsEqual(
+            self,
+            cons1ub.expr,
+            m.z
+            - 10.0
+            * (
+                1
+                - m.disjunct[1].innerdisjunct[0].binary_indicator_var
+                + 1
+                - m.disjunct[1].binary_indicator_var
+            )
+            <= 0.0,
         )
 
         cons2 = bigm.get_transformed_constraints(m.disjunct[1].innerdisjunct[1].c)
         self.assertEqual(len(cons2), 1)
         cons2lb = cons2[0]
-        self.assertEqual(cons2lb.lower, 5)
-        self.assertIsNone(cons2lb.upper)
-        self.check_bigM_constraint(
-            cons2lb, m.z, -5, m.disjunct[1].innerdisjunct[1].indicator_var
+        assertExpressionsEqual(
+            self,
+            cons2lb.expr,
+            5.0
+            <= m.z
+            - (-5.0)
+            * (
+                1
+                - m.disjunct[1].innerdisjunct[1].binary_indicator_var
+                + 1
+                - m.disjunct[1].binary_indicator_var
+            ),
         )
 
         cons3 = bigm.get_transformed_constraints(m.simpledisjunct.innerdisjunct0.c)
         self.assertEqual(len(cons3), 1)
         cons3ub = cons3[0]
-        self.assertEqual(cons3ub.upper, 2)
-        self.assertIsNone(cons3ub.lower)
-        self.check_bigM_constraint(
-            cons3ub, m.x, 7, m.simpledisjunct.innerdisjunct0.indicator_var
+        assertExpressionsEqual(
+            self,
+            cons3ub.expr,
+            m.x
+            - 7.0
+            * (
+                1
+                - m.simpledisjunct.innerdisjunct0.binary_indicator_var
+                + 1
+                - m.simpledisjunct.binary_indicator_var
+            )
+            <= 2.0,
         )
 
         cons4 = bigm.get_transformed_constraints(m.simpledisjunct.innerdisjunct1.c)
         self.assertEqual(len(cons4), 1)
         cons4lb = cons4[0]
-        self.assertEqual(cons4lb.lower, 4)
-        self.assertIsNone(cons4lb.upper)
-        self.check_bigM_constraint(
-            cons4lb, m.x, -13, m.simpledisjunct.innerdisjunct1.indicator_var
+        assertExpressionsEqual(
+            self,
+            cons4lb.expr,
+            m.x
+            - (-13.0)
+            * (
+                1
+                - m.simpledisjunct.innerdisjunct1.binary_indicator_var
+                + 1
+                - m.simpledisjunct.binary_indicator_var
+            )
+            >= 4.0,
         )
 
         # Here we check that the xor constraint from
         # simpledisjunct.innerdisjunction is transformed.
         self.check_inner_xor_constraint(
             m.simpledisjunct.innerdisjunction, m.simpledisjunct, bigm
         )
@@ -2095,43 +2122,14 @@
         ]
         for disjunct in disjuncts:
             self.assertIs(
                 disjunct.transformation_block.parent_component(),
                 m._pyomo_gdp_bigm_reformulation.relaxedDisjuncts,
             )
 
-    def check_first_disjunct_constraint(self, disj1c, x, ind_var):
-        self.assertEqual(len(disj1c), 1)
-        cons = disj1c[0]
-        self.assertIsNone(cons.lower)
-        self.assertEqual(cons.upper, 1)
-        repn = generate_standard_repn(cons.body)
-        self.assertTrue(repn.is_quadratic())
-        self.assertEqual(len(repn.linear_vars), 1)
-        self.assertEqual(len(repn.quadratic_vars), 4)
-        ct.check_linear_coef(self, repn, ind_var, 143)
-        self.assertEqual(repn.constant, -143)
-        for i in range(1, 5):
-            ct.check_squared_term_coef(self, repn, x[i], 1)
-
-    def check_second_disjunct_constraint(self, disj2c, x, ind_var):
-        self.assertEqual(len(disj2c), 1)
-        cons = disj2c[0]
-        self.assertIsNone(cons.lower)
-        self.assertEqual(cons.upper, 1)
-        repn = generate_standard_repn(cons.body)
-        self.assertTrue(repn.is_quadratic())
-        self.assertEqual(len(repn.linear_vars), 5)
-        self.assertEqual(len(repn.quadratic_vars), 4)
-        self.assertEqual(repn.constant, -63)  # M = 99, so this is 36 - 99
-        ct.check_linear_coef(self, repn, ind_var, 99)
-        for i in range(1, 5):
-            ct.check_squared_term_coef(self, repn, x[i], 1)
-            ct.check_linear_coef(self, repn, x[i], -6)
-
     def simplify_cons(self, cons, leq):
         visitor = LinearRepnVisitor({}, {}, {}, None)
         repn = visitor.walk_expression(cons.body)
         self.assertIsNone(repn.nonlinear)
         if leq:
             self.assertIsNone(cons.lower)
             ub = cons.upper
@@ -2149,38 +2147,84 @@
 
         self.check_inner_xor_constraint(
             m.disjunct_block.disj2.disjunction, m.disjunct_block.disj2, bigm
         )
 
         # outer disjunction constraints
         disj1c = bigm.get_transformed_constraints(m.disj1.c)
-        self.check_first_disjunct_constraint(disj1c, m.x, m.disj1.binary_indicator_var)
+        self.assertEqual(len(disj1c), 1)
+        cons = disj1c[0]
+        assertExpressionsEqual(
+            self,
+            cons.expr,
+            m.x[1] ** 2
+            + m.x[2] ** 2
+            + m.x[3] ** 2
+            + m.x[4] ** 2
+            - 143.0 * (1 - m.disj1.binary_indicator_var)
+            <= 1.0,
+        )
 
         disj2c = bigm.get_transformed_constraints(m.disjunct_block.disj2.c)
-        self.check_second_disjunct_constraint(
-            disj2c, m.x, m.disjunct_block.disj2.binary_indicator_var
+        self.assertEqual(len(disj2c), 1)
+        cons = disj2c[0]
+        assertExpressionsEqual(
+            self,
+            cons.expr,
+            (3 - m.x[1]) ** 2
+            + (3 - m.x[2]) ** 2
+            + (3 - m.x[3]) ** 2
+            + (3 - m.x[4]) ** 2
+            - 99.0 * (1 - m.disjunct_block.disj2.binary_indicator_var)
+            <= 1.0,
         )
 
         # inner disjunction constraints
         innerd1c = bigm.get_transformed_constraints(
             m.disjunct_block.disj2.disjunction_disjuncts[0].constraint[1]
         )
-        self.check_first_disjunct_constraint(
-            innerd1c,
-            m.x,
-            m.disjunct_block.disj2.disjunction_disjuncts[0].binary_indicator_var,
+        self.assertEqual(len(innerd1c), 1)
+        cons = innerd1c[0]
+        assertExpressionsEqual(
+            self,
+            cons.expr,
+            m.x[1] ** 2
+            + m.x[2] ** 2
+            + m.x[3] ** 2
+            + m.x[4] ** 2
+            - 143.0
+            * (
+                1
+                - m.disjunct_block.disj2.disjunction_disjuncts[0].binary_indicator_var
+                + 1
+                - m.disjunct_block.disj2.binary_indicator_var
+            )
+            <= 1.0,
         )
 
         innerd2c = bigm.get_transformed_constraints(
             m.disjunct_block.disj2.disjunction_disjuncts[1].constraint[1]
         )
-        self.check_second_disjunct_constraint(
-            innerd2c,
-            m.x,
-            m.disjunct_block.disj2.disjunction_disjuncts[1].binary_indicator_var,
+        self.assertEqual(len(innerd2c), 1)
+        cons = innerd2c[0]
+        assertExpressionsEqual(
+            self,
+            cons.expr,
+            (3 - m.x[1]) ** 2
+            + (3 - m.x[2]) ** 2
+            + (3 - m.x[3]) ** 2
+            + (3 - m.x[4]) ** 2
+            - 99.0
+            * (
+                1
+                - m.disjunct_block.disj2.disjunction_disjuncts[1].binary_indicator_var
+                + 1
+                - m.disjunct_block.disj2.binary_indicator_var
+            )
+            <= 1.0,
         )
 
     def test_hierarchical_badly_ordered_targets(self):
         m = models.makeHierarchicalNested_DeclOrderMatchesInstantiationOrder()
         bigm = TransformationFactory('gdp.bigm')
         bigm.apply_to(m, targets=[m.disjunction_block, m.disjunct_block.disj2])
 
@@ -2200,18 +2244,58 @@
         # the same check to make sure everything is transformed correctly.
         self.check_hierarchical_nested_model(m, bigm)
 
     @unittest.skipUnless(gurobi_available, "Gurobi is not available")
     def test_do_not_assume_nested_indicators_local(self):
         ct.check_do_not_assume_nested_indicators_local(self, 'gdp.bigm')
 
+    @unittest.skipUnless(gurobi_available, "Gurobi is not available")
+    def test_constraints_not_enforced_when_an_ancestor_indicator_is_False(self):
+        m = ConcreteModel()
+        m.x = Var(bounds=(0, 30))
+
+        m.left = Disjunct()
+        m.left.left = Disjunct()
+        m.left.left.c = Constraint(expr=m.x >= 10)
+        m.left.right = Disjunct()
+        m.left.right.c = Constraint(expr=m.x >= 9)
+        m.left.disjunction = Disjunction(expr=[m.left.left, m.left.right])
+        m.right = Disjunct()
+        m.right.left = Disjunct()
+        m.right.left.c = Constraint(expr=m.x >= 11)
+        m.right.right = Disjunct()
+        m.right.right.c = Constraint(expr=m.x >= 8)
+        m.right.disjunction = Disjunction(expr=[m.right.left, m.right.right])
+        m.disjunction = Disjunction(expr=[m.left, m.right])
+
+        m.equiv_left = LogicalConstraint(
+            expr=m.left.left.indicator_var.equivalent_to(m.right.left.indicator_var)
+        )
+        m.equiv_right = LogicalConstraint(
+            expr=m.left.right.indicator_var.equivalent_to(m.right.right.indicator_var)
+        )
+
+        m.obj = Objective(expr=m.x)
+
+        TransformationFactory('gdp.bigm').apply_to(m)
+        results = SolverFactory('gurobi').solve(m)
+        self.assertEqual(
+            results.solver.termination_condition, TerminationCondition.optimal
+        )
+        self.assertTrue(value(m.right.indicator_var))
+        self.assertFalse(value(m.left.indicator_var))
+        self.assertTrue(value(m.right.right.indicator_var))
+        self.assertFalse(value(m.right.left.indicator_var))
+        self.assertTrue(value(m.left.right.indicator_var))
+        self.assertAlmostEqual(value(m.x), 8)
+
 
 class IndexedDisjunction(unittest.TestCase):
     # this tests that if the targets are a subset of the
-    # _DisjunctDatas in an IndexedDisjunction that the xor constraint
+    # DisjunctDatas in an IndexedDisjunction that the xor constraint
     # created on the parent block will still be indexed as expected.
     def test_xor_constraint(self):
         ct.check_indexed_xor_constraints_with_targets(self, 'bigm')
 
     def test_partial_deactivate_indexed_disjunction(self):
         ct.check_partial_deactivate_indexed_disjunction(self, 'bigm')
 
@@ -2268,26 +2352,20 @@
         evil1 = bigm.get_transformed_constraints(m.evil[1].component('b.c'))
         self.assertEqual(len(evil1), 1)
         self.assertIs(evil1[0].parent_block(), disjBlock[1])
         evil1 = bigm.get_transformed_constraints(m.evil[1].b.c)
         self.assertEqual(len(evil1), 2)
         self.assertIs(evil1[0].parent_block(), disjBlock[1])
         self.assertIs(evil1[1].parent_block(), disjBlock[1])
-        out = StringIO()
-        with LoggingIntercept(out, 'pyomo.gdp', logging.ERROR):
-            self.assertRaisesRegex(
-                KeyError,
-                r".*.evil\[1\].b.anotherblock.c",
-                bigm.get_transformed_constraints,
-                m.evil[1].b.anotherblock.c,
-            )
-        self.assertRegex(
-            out.getvalue(),
-            r".*Constraint 'evil\[1\].b.anotherblock.c' has not been transformed.",
-        )
+        with self.assertRaisesRegex(
+            GDP_Error,
+            r"Constraint 'evil\[1\].b.anotherblock.c' has not been transformed.",
+        ):
+            bigm.get_transformed_constraints(m.evil[1].b.anotherblock.c)
+
         evil1 = bigm.get_transformed_constraints(m.evil[1].bb[1].c)
         self.assertEqual(len(evil1), 2)
         self.assertIs(evil1[0].parent_block(), disjBlock[1])
         self.assertIs(evil1[1].parent_block(), disjBlock[1])
 
     def test_do_not_transform_deactivated_constraint(self):
         m = models.makeTwoTermDisj_BlockOnDisj()
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_binary_multiplication.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_binary_multiplication.py`

 * *Files 1% similar despite different names*

```diff
@@ -142,18 +142,15 @@
             "disjunction_xor"
         )
         self.assertIsInstance(orcons, Constraint)
         assertExpressionsEqual(
             self,
             orcons.body,
             EXPR.LinearExpression(
-                [
-                    EXPR.MonomialTermExpression((1, m.d[0].binary_indicator_var)),
-                    EXPR.MonomialTermExpression((1, m.d[1].binary_indicator_var)),
-                ]
+                [m.d[0].binary_indicator_var, m.d[1].binary_indicator_var]
             ),
         )
         self.assertEqual(orcons.lower, 1)
         self.assertIsNone(orcons.upper)
 
     def test_deactivated_constraints(self):
         ct.check_deactivated_constraints(self, 'binary_multiplication')
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_bound_pretransformation.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_bound_pretransformation.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_cuttingplane.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_cuttingplane.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_disjunct.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_disjunct.py`

 * *Files 2% similar despite different names*

```diff
@@ -628,27 +628,21 @@
         with LoggingIntercept(out):
             self.assertIs((m.iv > 0).args[1], m.biv)
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             e = m.iv + 1
-        assertExpressionsEqual(
-            self, e, EXPR.LinearExpression([EXPR.MonomialTermExpression((1, m.biv)), 1])
-        )
+        assertExpressionsEqual(self, e, EXPR.LinearExpression([m.biv, 1]))
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             e = m.iv - 1
-        assertExpressionsEqual(
-            self,
-            e,
-            EXPR.LinearExpression([EXPR.MonomialTermExpression((1, m.biv)), -1]),
-        )
+        assertExpressionsEqual(self, e, EXPR.LinearExpression([m.biv, -1]))
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             self.assertIs((m.iv * 2).args[1], m.biv)
         self.assertIn(deprecation_msg, out.getvalue())
 
@@ -661,17 +655,15 @@
         with LoggingIntercept(out):
             self.assertIs((m.iv**2).args[0], m.biv)
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             e = 1 + m.iv
-        assertExpressionsEqual(
-            self, e, EXPR.LinearExpression([1, EXPR.MonomialTermExpression((1, m.biv))])
-        )
+        assertExpressionsEqual(self, e, EXPR.LinearExpression([1, m.biv]))
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             e = 1 - m.iv
         assertExpressionsEqual(
             self,
@@ -695,28 +687,22 @@
             self.assertIs((2**m.iv).args[1], m.biv)
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             a = m.iv
             a += 1
-        assertExpressionsEqual(
-            self, a, EXPR.LinearExpression([EXPR.MonomialTermExpression((1, m.biv)), 1])
-        )
+        assertExpressionsEqual(self, a, EXPR.LinearExpression([m.biv, 1]))
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             a = m.iv
             a -= 1
-        assertExpressionsEqual(
-            self,
-            a,
-            EXPR.LinearExpression([EXPR.MonomialTermExpression((1, m.biv)), -1]),
-        )
+        assertExpressionsEqual(self, a, EXPR.LinearExpression([m.biv, -1]))
         self.assertIn(deprecation_msg, out.getvalue())
 
         out = StringIO()
         with LoggingIntercept(out):
             a = m.iv
             a *= 2
             self.assertIs(a.args[1], m.biv)
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_fix_disjuncts.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_fix_disjuncts.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_gdp.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_gdp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_gdp_reclassification_error.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_gdp_reclassification_error.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_hull.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_hull.py`

 * *Files 1% similar despite different names*

```diff
@@ -893,26 +893,18 @@
         m.a[1].setub(100)
         m.a[2].setlb(0)
         m.a[2].setub(100)
         m.b.simpledisj1.c[1].deactivate()
         hull = TransformationFactory('gdp.hull')
         hull.apply_to(m)
         # can't ask for simpledisj1.c[1]: it wasn't transformed
-        log = StringIO()
-        with LoggingIntercept(log, 'pyomo.gdp', logging.ERROR):
-            self.assertRaisesRegex(
-                KeyError,
-                r".*b.simpledisj1.c\[1\]",
-                hull.get_transformed_constraints,
-                m.b.simpledisj1.c[1],
-            )
-        self.assertRegex(
-            log.getvalue(),
-            r".*Constraint 'b.simpledisj1.c\[1\]' has not been transformed.",
-        )
+        with self.assertRaisesRegex(
+            GDP_Error, r"Constraint 'b.simpledisj1.c\[1\]' has not been transformed."
+        ):
+            hull.get_transformed_constraints(m.b.simpledisj1.c[1])
 
         # this fixes a[2] to 0, so we should get the disggregated var
         transformed = hull.get_transformed_constraints(m.b.simpledisj1.c[2])
         self.assertEqual(len(transformed), 1)
         disaggregated_a2 = hull.get_disaggregated_var(m.a[2], m.b.simpledisj1)
         self.assertIs(transformed[0], disaggregated_a2)
         self.assertIsInstance(disaggregated_a2, Var)
@@ -1256,20 +1248,18 @@
         self.assertEqual(len(firstTerm_cons), 1)
         self.assertIs(firstTerm_cons[0].parent_block(), transBlock.relaxedDisjuncts[0])
         self.assertEqual(len(secondTerm_cons), 1)
         self.assertIs(secondTerm_cons[0].parent_block(), transBlock.relaxedDisjuncts[1])
 
         orig = model.component("_pyomo_gdp_hull_reformulation")
         self.assertIsInstance(
-            model.disjunctionList[1].algebraic_constraint,
-            constraint._GeneralConstraintData,
+            model.disjunctionList[1].algebraic_constraint, constraint.ConstraintData
         )
         self.assertIsInstance(
-            model.disjunctionList[0].algebraic_constraint,
-            constraint._GeneralConstraintData,
+            model.disjunctionList[0].algebraic_constraint, constraint.ConstraintData
         )
         self.assertFalse(model.disjunctionList[1].active)
         self.assertFalse(model.disjunctionList[0].active)
 
     def test_disjunction_and_disjuncts_indexed_by_any(self):
         ct.check_disjunction_and_disjuncts_indexed_by_any(self, 'hull')
 
@@ -2310,16 +2300,15 @@
         ):
             hull.get_var_bounds_constraint(m.w)
 
         log = StringIO()
         with LoggingIntercept(log, 'pyomo.gdp.hull', logging.ERROR):
             self.assertRaisesRegex(
                 KeyError,
-                r".*_pyomo_gdp_hull_reformulation.relaxedDisjuncts\[1\]."
-                r"disaggregatedVars.w",
+                r".*disjunction",
                 hull.get_disaggregation_constraint,
                 m.d[1].transformation_block.disaggregatedVars.w,
                 m.disjunction,
             )
         self.assertRegex(
             log.getvalue(),
             ".*It doesn't appear that "
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_mbigm.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_mbigm.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_partition_disjuncts.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_partition_disjuncts.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_reclassify.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_reclassify.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_transform_current_disjunctive_state.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_transform_current_disjunctive_state.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/gdp/tests/test_util.py` & `Pyomo-6.7.2/pyomo/gdp/tests/test_util.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.common.unittest as unittest
 
 from pyomo.core import ConcreteModel, Var, Expression, Block, RangeSet, Any
 import pyomo.core.expr as EXPR
-from pyomo.core.base.expression import _ExpressionData
+from pyomo.core.base.expression import NamedExpressionData
 from pyomo.gdp.util import (
     clone_without_expression_components,
     is_child_of,
     get_gdp_tree,
 )
 from pyomo.gdp import Disjunct, Disjunction
 
@@ -36,26 +36,26 @@
         test = clone_without_expression_components(base, {id(m.x): m.y})
         self.assertEqual(3**2 + 1, test())
 
         base = m.e
         test = clone_without_expression_components(base, {})
         self.assertIsNot(base, test)
         self.assertEqual(base(), test())
-        self.assertIsInstance(base, _ExpressionData)
+        self.assertIsInstance(base, NamedExpressionData)
         self.assertIsInstance(test, EXPR.SumExpression)
         test = clone_without_expression_components(base, {id(m.x): m.y})
         self.assertEqual(3**2 + 3 - 1, test())
 
         base = m.e + m.x
         test = clone_without_expression_components(base, {})
         self.assertIsNot(base, test)
         self.assertEqual(base(), test())
         self.assertIsInstance(base, EXPR.SumExpression)
         self.assertIsInstance(test, EXPR.SumExpression)
-        self.assertIsInstance(base.arg(0), _ExpressionData)
+        self.assertIsInstance(base.arg(0), NamedExpressionData)
         self.assertIsInstance(test.arg(0), EXPR.SumExpression)
         test = clone_without_expression_components(base, {id(m.x): m.y})
         self.assertEqual(3**2 + 3 - 1 + 3, test())
 
     def test_is_child_of(self):
         m = ConcreteModel()
         m.b = Block()
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/transformed_disjunct.py` & `Pyomo-6.7.2/pyomo/gdp/transformed_disjunct.py`

 * *Files 9% similar despite different names*

```diff
@@ -6,27 +6,27 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.autoslots import AutoSlots
-from pyomo.core.base.block import _BlockData, IndexedBlock
+from pyomo.core.base.block import BlockData, IndexedBlock
 from pyomo.core.base.global_set import UnindexedComponent_index, UnindexedComponent_set
 
 
-class _TransformedDisjunctData(_BlockData):
+class _TransformedDisjunctData(BlockData):
     __slots__ = ('_src_disjunct',)
     __autoslot_mappers__ = {'_src_disjunct': AutoSlots.weakref_mapper}
 
     @property
     def src_disjunct(self):
         return None if self._src_disjunct is None else self._src_disjunct()
 
     def __init__(self, component):
-        _BlockData.__init__(self, component)
+        BlockData.__init__(self, component)
         # pointer to the Disjunct whose transformation block this is.
         self._src_disjunct = None
 
 
 class _TransformedDisjunct(IndexedBlock):
     _ComponentDataClass = _TransformedDisjunctData
```

### Comparing `Pyomo-6.7.1/pyomo/gdp/util.py` & `Pyomo-6.7.2/pyomo/gdp/util.py`

 * *Files 2% similar despite different names*

```diff
@@ -6,27 +6,26 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.gdp import GDP_Error, Disjunction
-from pyomo.gdp.disjunct import _DisjunctData, Disjunct
+from pyomo.gdp.disjunct import DisjunctData, Disjunct
 
 import pyomo.core.expr as EXPR
-from pyomo.core.base.component import _ComponentBase
 from pyomo.core import (
     Block,
     Suffix,
     TraversalStrategy,
     SortComponents,
     LogicalConstraint,
     value,
 )
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.common.collections import ComponentMap, ComponentSet, OrderedSet
 from pyomo.opt import TerminationCondition, SolverStatus
 
 from weakref import ref as weakref_ref
 from collections import defaultdict
 import logging
 
@@ -140,21 +139,21 @@
 
     def parent(self, u):
         """Returns the parent node of u, or None if u is a root.
 
         Arg:
             u : A node in the tree
         """
+        if u in self._parent:
+            return self._parent[u]
         if u not in self._vertices:
             raise ValueError(
                 "'%s' is not a vertex in the GDP tree. Cannot "
                 "retrieve its parent." % u
             )
-        if u in self._parent:
-            return self._parent[u]
         else:
             return None
 
     def children(self, u):
         """Returns the direct descendents of node u.
 
         Arg:
@@ -326,15 +325,15 @@
     for t in targets:
         # first check it's not insane, that is, it is at least on the instance
         if not is_child_of(parent=instance, child=t, knownBlocks=knownBlocks):
             raise GDP_Error(
                 "Target '%s' is not a component on instance "
                 "'%s'!" % (t.name, instance.name)
             )
-        if t.ctype is Block or isinstance(t, _BlockData):
+        if t.ctype is Block or isinstance(t, BlockData):
             _blocks = t.values() if t.is_indexed() else (t,)
             for block in _blocks:
                 if not block.active:
                     continue
                 gdp_tree = _gather_disjunctions(block, gdp_tree, include_root=False)
         elif t.ctype is Disjunction:
             parent = _parent_disjunct(t)
@@ -383,15 +382,15 @@
 def is_child_of(parent, child, knownBlocks=None):
     # Note: we can get away with a dictionary and not ComponentMap because we
     # will only store Blocks (or their ilk), and Blocks are hashable (only
     # derivatives of NumericValue are not hashable)
     if knownBlocks is None:
         knownBlocks = {}
     tmp = set()
-    node = child if isinstance(child, (Block, _BlockData)) else child.parent_block()
+    node = child if isinstance(child, (Block, BlockData)) else child.parent_block()
     while True:
         known = knownBlocks.get(node)
         if known:
             knownBlocks.update({c: True for c in tmp})
             return True
         if known is not None and not known:
             knownBlocks.update({c: False for c in tmp})
@@ -448,15 +447,15 @@
 
 def get_src_disjunct(transBlock):
     """Return the Disjunct object whose transformed components are on
     transBlock.
 
     Parameters
     ----------
-    transBlock: _BlockData which is in the relaxedDisjuncts IndexedBlock
+    transBlock: BlockData which is in the relaxedDisjuncts IndexedBlock
                 on a transformation block.
     """
     if (
         not hasattr(transBlock, "_src_disjunct")
         or type(transBlock._src_disjunct) is not weakref_ref
     ):
         raise GDP_Error(
@@ -473,30 +472,31 @@
     Parameters
     ----------
     transformedConstraint: Constraint, which must be a component on one of
     the BlockDatas in the relaxedDisjuncts Block of
     a transformation block
     """
     transBlock = transformedConstraint.parent_block()
+    src_constraints = transBlock.private_data('pyomo.gdp').src_constraint
     # This should be our block, so if it's not, the user messed up and gave
     # us the wrong thing. If they happen to also have a _constraintMap then
     # the world is really against us.
-    if not hasattr(transBlock, "_constraintMap"):
+    if transformedConstraint not in src_constraints:
         raise GDP_Error(
             "Constraint '%s' is not a transformed constraint"
             % transformedConstraint.name
         )
     # if something goes wrong here, it's a bug in the mappings.
-    return transBlock._constraintMap['srcConstraints'][transformedConstraint]
+    return src_constraints[transformedConstraint]
 
 
 def _find_parent_disjunct(constraint):
     # traverse up until we find the disjunct this constraint lives on
     parent_disjunct = constraint.parent_block()
-    while not isinstance(parent_disjunct, _DisjunctData):
+    while not isinstance(parent_disjunct, DisjunctData):
         if parent_disjunct is None:
             raise GDP_Error(
                 "Constraint '%s' is not on a disjunct and so was not "
                 "transformed" % constraint.name
             )
         parent_disjunct = parent_disjunct.parent_block()
 
@@ -520,32 +520,36 @@
 
 
 def get_transformed_constraints(srcConstraint):
     """Return the transformed version of srcConstraint
 
     Parameters
     ----------
-    srcConstraint: ScalarConstraint or _ConstraintData, which must be in
+    srcConstraint: ScalarConstraint or ConstraintData, which must be in
     the subtree of a transformed Disjunct
     """
     if srcConstraint.is_indexed():
         raise GDP_Error(
             "Argument to get_transformed_constraint should be "
-            "a ScalarConstraint or _ConstraintData. (If you "
+            "a ScalarConstraint or ConstraintData. (If you "
             "want the container for all transformed constraints "
             "from an IndexedDisjunction, this is the parent "
             "component of a transformed constraint originating "
-            "from any of its _ComponentDatas.)"
+            "from any of its ComponentDatas.)"
         )
     transBlock = _get_constraint_transBlock(srcConstraint)
-    try:
-        return transBlock._constraintMap['transformedConstraints'][srcConstraint]
-    except:
-        logger.error("Constraint '%s' has not been transformed." % srcConstraint.name)
-        raise
+    transformed_constraints = transBlock.private_data(
+        'pyomo.gdp'
+    ).transformed_constraints
+    if srcConstraint in transformed_constraints:
+        return transformed_constraints[srcConstraint]
+    else:
+        raise GDP_Error(
+            "Constraint '%s' has not been transformed." % srcConstraint.name
+        )
 
 
 def _warn_for_active_disjunct(innerdisjunct, outerdisjunct):
     assert innerdisjunct.active
     problemdisj = innerdisjunct
     if innerdisjunct.is_indexed():
         for i in sorted(innerdisjunct.keys()):
```

### Comparing `Pyomo-6.7.1/pyomo/kernel/__init__.py` & `Pyomo-6.7.2/pyomo/kernel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/kernel/util.py` & `Pyomo-6.7.2/pyomo/kernel/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/__init__.py` & `Pyomo-6.7.2/pyomo/mpec/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/complementarity.py` & `Pyomo-6.7.2/pyomo/mpec/complementarity.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 from pyomo.common.log import is_debug_set
 from pyomo.common.timing import ConstructionTimer
 import pyomo.core.expr as EXPR
 from pyomo.core.expr.numvalue import ZeroConstant, native_numeric_types, as_numeric
 from pyomo.core import Constraint, Var, Block, Set
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.global_set import UnindexedComponent_index
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.base.disable_methods import disable_methods
 from pyomo.core.base.initializer import (
     Initializer,
     IndexedCallInitializer,
     CountedCallInitializer,
 )
 
@@ -39,15 +39,15 @@
 
 
 def complements(a, b):
     """Return a named 2-tuple"""
     return ComplementarityTuple(a, b)
 
 
-class _ComplementarityData(_BlockData):
+class ComplementarityData(BlockData):
     def _canonical_expression(self, e):
         # Note: as the complimentarity component maintains references to
         # the original expression (e), it is NOT safe or valid to bypass
         # the clone checks: bypassing the check can result in corrupting
         # the original expressions and will result in mind-boggling
         # pprint output.
         e_ = None
@@ -175,17 +175,22 @@
             return self.set_value(tuple(cc))
         else:
             raise ValueError(
                 "Unexpected value for Complementarity %s:\n\t%s" % (self.name, cc)
             )
 
 
+class _ComplementarityData(metaclass=RenamedClass):
+    __renamed__new_class__ = ComplementarityData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("Complementarity conditions.")
 class Complementarity(Block):
-    _ComponentDataClass = _ComplementarityData
+    _ComponentDataClass = ComplementarityData
 
     def __new__(cls, *args, **kwds):
         if cls != Complementarity:
             return super(Complementarity, cls).__new__(cls)
         if args == ():
             return super(Complementarity, cls).__new__(AbstractScalarComplementarity)
         else:
@@ -294,17 +299,17 @@
             ],
             self._data.items(),
             ("Arg0", "Arg1", "Active"),
             (_table_data, _conditional_block_printer),
         )
 
 
-class ScalarComplementarity(_ComplementarityData, Complementarity):
+class ScalarComplementarity(ComplementarityData, Complementarity):
     def __init__(self, *args, **kwds):
-        _ComplementarityData.__init__(self, self)
+        ComplementarityData.__init__(self, self)
         Complementarity.__init__(self, *args, **kwds)
         self._data[None] = self
         self._index = UnindexedComponent_index
 
 
 class SimpleComplementarity(metaclass=RenamedClass):
     __renamed__new_class__ = ScalarComplementarity
```

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/mpec1.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/mpec1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/mpec2.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/mpec2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/mpec3.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/mpec3.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/mpec4.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/mpec4.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/pathampl.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/pathampl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/solver1.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/solver1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/plugins/solver2.py` & `Pyomo-6.7.2/pyomo/mpec/plugins/solver2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/tests/__init__.py` & `Pyomo-6.7.2/pyomo/repn/__init__.py`

 * *Files 21% similar despite different names*

```diff
@@ -5,10 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-"""
-pyomo.gdp tests
-"""
+from pyomo.repn.standard_repn import StandardRepn, generate_standard_repn
+from pyomo.repn.standard_aux import compute_standard_repn
```

### Comparing `Pyomo-6.7.1/pyomo/mpec/tests/test_complementarity.py` & `Pyomo-6.7.2/pyomo/mpec/tests/test_complementarity.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/tests/test_minlp.py` & `Pyomo-6.7.2/pyomo/mpec/tests/test_minlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/tests/test_nlp.py` & `Pyomo-6.7.2/pyomo/mpec/tests/test_nlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/mpec/tests/test_path.py` & `Pyomo-6.7.2/pyomo/mpec/tests/test_path.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/__init__.py` & `Pyomo-6.7.2/pyomo/neos/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/kestrel.py` & `Pyomo-6.7.2/pyomo/neos/kestrel.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/plugins/NEOS.py` & `Pyomo-6.7.2/pyomo/neos/plugins/NEOS.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/neos/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/plugins/kestrel_plugin.py` & `Pyomo-6.7.2/pyomo/neos/plugins/kestrel_plugin.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/tests/__init__.py` & `Pyomo-6.7.2/pyomo/neos/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/tests/model_min_lp.py` & `Pyomo-6.7.2/pyomo/neos/tests/model_min_lp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/neos/tests/test_neos.py` & `Pyomo-6.7.2/pyomo/neos/tests/test_neos.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/__init__.py` & `Pyomo-6.7.2/pyomo/network/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/arc.py` & `Pyomo-6.7.2/pyomo/network/arc.py`

 * *Files 2% similar despite different names*

```diff
@@ -48,15 +48,15 @@
             source=source, destination=destination, ports=ports, directed=directed
         )
     elif "directed" not in vals:
         vals["directed"] = directed
     return vals
 
 
-class _ArcData(ActiveComponentData):
+class ArcData(ActiveComponentData):
     """
     This class defines the data for a single Arc
 
     Attributes
     ----------
         source: `Port`
             The source Port when directed, else None. Aliases to src.
@@ -242,14 +242,19 @@
                         )
                 except AttributeError:
                     raise ValueError(
                         msg + "%s object '%s' not of type Port." % (str(p), side)
                     )
 
 
+class _ArcData(metaclass=RenamedClass):
+    __renamed__new_class__ = ArcData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register("Component used for connecting two Ports.")
 class Arc(ActiveIndexedComponent):
     """
     Component used for connecting the members of two Port objects
 
     Parameters
     ----------
@@ -263,15 +268,15 @@
             Set True for directed. Use along with `rule` to be able to
             return an implied (source, destination) tuple.
         rule: `function`
             A function that returns either a dictionary of the arc arguments
             or a two-member iterable of ports
     """
 
-    _ComponentDataClass = _ArcData
+    _ComponentDataClass = ArcData
 
     def __new__(cls, *args, **kwds):
         if cls != Arc:
             return super(Arc, cls).__new__(cls)
         if not args or (args[0] is UnindexedComponent_set and len(args) == 1):
             return ScalarArc.__new__(ScalarArc)
         else:
@@ -369,17 +374,17 @@
                 "(%s, %s)" % v.ports if v.ports is not None else None,
                 v.directed,
                 v.active,
             ],
         )
 
 
-class ScalarArc(_ArcData, Arc):
+class ScalarArc(ArcData, Arc):
     def __init__(self, *args, **kwds):
-        _ArcData.__init__(self, self)
+        ArcData.__init__(self, self)
         Arc.__init__(self, *args, **kwds)
         self.index = UnindexedComponent_index
 
     def set_value(self, vals):
         """
         Set the port attributes on this arc.
```

### Comparing `Pyomo-6.7.1/pyomo/network/decomposition.py` & `Pyomo-6.7.2/pyomo/network/decomposition.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/foqus_graph.py` & `Pyomo-6.7.2/pyomo/network/foqus_graph.py`

 * *Files 0% similar despite different names*

```diff
@@ -354,17 +354,17 @@
             adj.append([])
             adjR.append([])
 
         # build adjacency lists
         done = False
         for i in range(len(sccNodes)):
             for j in range(len(sccNodes)):
-                for ine in ie[i]:
-                    for oute in oe[j]:
-                        if ine == oute:
+                for in_e in ie[i]:
+                    for out_e in oe[j]:
+                        if in_e == out_e:
                             adj[j].append(i)
                             adjR[i].append(j)
                             done = True
                     if done:
                         break
                 if done:
                     break
```

### Comparing `Pyomo-6.7.1/pyomo/network/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/network/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/plugins/expand_arcs.py` & `Pyomo-6.7.2/pyomo/network/plugins/expand_arcs.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/port.py` & `Pyomo-6.7.2/pyomo/network/port.py`

 * *Files 1% similar despite different names*

```diff
@@ -32,15 +32,15 @@
 from pyomo.core.base.label import alphanum_label_from_name
 
 from pyomo.network.util import create_var, tighten_var_domain
 
 logger = logging.getLogger('pyomo.network')
 
 
-class _PortData(ComponentData):
+class PortData(ComponentData):
     """
     This class defines the data for a single Port
 
     Attributes
     ----------
         vars:`dict`
             A dictionary mapping added names to variables
@@ -281,14 +281,19 @@
         res = self._splitfracs.get(arc, None)
         if res is None:
             return None
         else:
             return res
 
 
+class _PortData(metaclass=RenamedClass):
+    __renamed__new_class__ = PortData
+    __renamed__version__ = '6.7.2'
+
+
 @ModelComponentFactory.register(
     "A bundle of variables that can be connected to other ports."
 )
 class Port(IndexedComponent):
     """
     A collection of variables, which may be connected to other ports
 
@@ -335,15 +340,15 @@
         kwd.setdefault('ctype', Port)
         IndexedComponent.__init__(self, *args, **kwd)
 
     # This method must be defined on subclasses of
     # IndexedComponent that support implicit definition
     def _getitem_when_not_present(self, idx):
         """Returns the default component data value."""
-        tmp = self._data[idx] = _PortData(component=self)
+        tmp = self._data[idx] = PortData(component=self)
         tmp._index = idx
         return tmp
 
     def construct(self, data=None):
         if self._constructed:
             return
         self._constructed = True
@@ -353,15 +358,15 @@
         if is_debug_set(logger):  # pragma:nocover
             logger.debug("Constructing Port, name=%s, from data=%s" % (self.name, data))
 
         if self._anonymous_sets is not None:
             for _set in self._anonymous_sets:
                 _set.construct()
 
-        # Construct _PortData objects for all index values
+        # Construct PortData objects for all index values
         if self.is_indexed():
             self._initialize_members(self._index_set)
         else:
             self._data[None] = self
             self._initialize_members([None])
 
         # get rid of these references
@@ -759,17 +764,17 @@
         # before making a new one.
         evar = eblock.component(name)
         if evar is None:
             evar = create_var(member, name, eblock, index_set)
         return evar
 
 
-class ScalarPort(Port, _PortData):
+class ScalarPort(Port, PortData):
     def __init__(self, *args, **kwd):
-        _PortData.__init__(self, component=self)
+        PortData.__init__(self, component=self)
         Port.__init__(self, *args, **kwd)
         self._index = UnindexedComponent_index
 
 
 class SimplePort(metaclass=RenamedClass):
     __renamed__new_class__ = ScalarPort
     __renamed__version__ = '6.0'
```

### Comparing `Pyomo-6.7.1/pyomo/network/tests/__init__.py` & `Pyomo-6.7.2/pyomo/network/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/tests/test_arc.py` & `Pyomo-6.7.2/pyomo/network/tests/test_arc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/tests/test_decomposition.py` & `Pyomo-6.7.2/pyomo/network/tests/test_decomposition.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/tests/test_port.py` & `Pyomo-6.7.2/pyomo/network/tests/test_port.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/network/util.py` & `Pyomo-6.7.2/pyomo/network/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/__init__.py` & `Pyomo-6.7.2/pyomo/opt/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/__init__.py` & `Pyomo-6.7.2/pyomo/opt/base/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/convert.py` & `Pyomo-6.7.2/pyomo/opt/base/convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/error.py` & `Pyomo-6.7.2/pyomo/opt/base/error.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/formats.py` & `Pyomo-6.7.2/pyomo/opt/base/formats.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/opt_config.py` & `Pyomo-6.7.2/pyomo/opt/base/opt_config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/problem.py` & `Pyomo-6.7.2/pyomo/opt/base/problem.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/results.py` & `Pyomo-6.7.2/pyomo/opt/base/results.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/base/solvers.py` & `Pyomo-6.7.2/pyomo/opt/base/solvers.py`

 * *Files 0% similar despite different names*

```diff
@@ -532,32 +532,32 @@
         """Solve the problem"""
 
         self.available(exception_flag=True)
         #
         # If the inputs are models, then validate that they have been
         # constructed! Collect suffix names to try and import from solution.
         #
-        from pyomo.core.base.block import _BlockData
+        from pyomo.core.base.block import BlockData
         import pyomo.core.base.suffix
         from pyomo.core.kernel.block import IBlock
         import pyomo.core.kernel.suffix
 
         _model = None
         for arg in args:
-            if isinstance(arg, (_BlockData, IBlock)):
-                if isinstance(arg, _BlockData):
+            if isinstance(arg, (BlockData, IBlock)):
+                if isinstance(arg, BlockData):
                     if not arg.is_constructed():
                         raise RuntimeError(
                             "Attempting to solve model=%s with unconstructed "
                             "component(s)" % (arg.name,)
                         )
 
                 _model = arg
                 # import suffixes must be on the top-level model
-                if isinstance(arg, _BlockData):
+                if isinstance(arg, BlockData):
                     model_suffixes = list(
                         name
                         for (
                             name,
                             comp,
                         ) in pyomo.core.base.suffix.active_import_suffix_generator(arg)
                     )
```

### Comparing `Pyomo-6.7.1/pyomo/opt/parallel/__init__.py` & `Pyomo-6.7.2/pyomo/opt/parallel/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/parallel/async_solver.py` & `Pyomo-6.7.2/pyomo/opt/parallel/async_solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/parallel/local.py` & `Pyomo-6.7.2/pyomo/opt/parallel/local.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/parallel/manager.py` & `Pyomo-6.7.2/pyomo/opt/parallel/manager.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/opt/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/plugins/res.py` & `Pyomo-6.7.2/pyomo/opt/plugins/res.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/plugins/sol.py` & `Pyomo-6.7.2/pyomo/opt/plugins/sol.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/problem/__init__.py` & `Pyomo-6.7.2/pyomo/opt/problem/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/problem/ampl.py` & `Pyomo-6.7.2/pyomo/opt/problem/ampl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/results/__init__.py` & `Pyomo-6.7.2/pyomo/opt/results/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/results/container.py` & `Pyomo-6.7.2/pyomo/opt/results/container.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/results/results_.py` & `Pyomo-6.7.2/pyomo/opt/results/results_.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/results/solution.py` & `Pyomo-6.7.2/pyomo/opt/results/solution.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/results/solver.py` & `Pyomo-6.7.2/pyomo/opt/results/solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/solver/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -4,16 +4,10 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
-
-from pyomo.opt.solver.shellcmd import (
-    ResultsFormat,
-    OptSolver,
-    SolverStatus,
-    SolverResults,
-    SystemCallSolver,
-)
-from pyomo.opt.solver.ilmcmd import ILMLicensedSystemCallSolver
+#
+# Tests for Pyomo solvers
+#
```

### Comparing `Pyomo-6.7.1/pyomo/opt/solver/ilmcmd.py` & `Pyomo-6.7.2/pyomo/opt/solver/ilmcmd.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/solver/shellcmd.py` & `Pyomo-6.7.2/pyomo/opt/solver/shellcmd.py`

 * *Files 1% similar despite different names*

```diff
@@ -56,14 +56,15 @@
         self._results_file = None
         self._timer = ''
         self._user_executable = None
         # broadly useful for reporting, and in cases where
         # a solver plugin may not report execution time.
         self._last_solve_time = None
         self._define_signal_handlers = None
+        self._version_timeout = 2
 
         if executable is not None:
             self.set_executable(name=executable, validate=validate)
 
     def set_executable(self, name=None, validate=True):
         """
         Set the executable for this solver.
```

### Comparing `Pyomo-6.7.1/pyomo/opt/testing/__init__.py` & `Pyomo-6.7.2/pyomo/opt/testing/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/testing/pyunit.py` & `Pyomo-6.7.2/pyomo/opt/testing/pyunit.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/__init__.py` & `Pyomo-6.7.2/pyomo/opt/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/__init__.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_ampl.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_ampl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_convert.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_factory.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_factory.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_sol.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_sol.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_soln.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_soln.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/base/test_solver.py` & `Pyomo-6.7.2/pyomo/opt/tests/base/test_solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/solver/__init__.py` & `Pyomo-6.7.2/pyomo/opt/tests/solver/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/opt/tests/solver/test_shellcmd.py` & `Pyomo-6.7.2/pyomo/opt/tests/solver/test_shellcmd.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/pysp/__init__.py` & `Pyomo-6.7.2/pyomo/pysp/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/__init__.py` & `Pyomo-6.7.2/pyomo/repn/plugins/ampl/__init__.py`

 * *Files 20% similar despite different names*

```diff
@@ -5,9 +5,8 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.repn.standard_repn import StandardRepn, generate_standard_repn
-from pyomo.repn.standard_aux import compute_standard_repn
+from pyomo.repn.plugins.ampl.ampl_ import ProblemWriter_nl
```

### Comparing `Pyomo-6.7.1/pyomo/repn/beta/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/baron/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -4,9 +4,10 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
-
-import pyomo.repn.beta.matrix
+#
+# Pyomo BARON plugin tests
+#
```

### Comparing `Pyomo-6.7.1/pyomo/repn/beta/matrix.py` & `Pyomo-6.7.2/pyomo/repn/beta/matrix.py`

 * *Files 1% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 from pyomo.core.base.set_types import Any
 from pyomo.core.base import SortComponents, Var
 from pyomo.core.base.component import ModelComponentFactory
 from pyomo.core.base.constraint import (
     Constraint,
     IndexedConstraint,
     ScalarConstraint,
-    _ConstraintData,
+    ConstraintData,
 )
 from pyomo.core.expr.numvalue import native_numeric_types
 from pyomo.repn import generate_standard_repn
 
 from collections.abc import Mapping
 
 
@@ -243,15 +243,15 @@
     constraints_removed = 0
     constraint_containers_removed = 0
     for block, constraint in empty_constraint_containers_to_remove:
         block.del_component(constraint)
         constraint_containers_removed += 1
     for constraint, index in constraint_data_to_remove:
         # Note that this del is not needed: assigning Constraint.Skip
-        # above removes the _ConstraintData from the _data dict.
+        # above removes the ConstraintData from the _data dict.
         # del constraint[index]
         constraints_removed += 1
     for block, constraint in constraint_containers_to_remove:
         block.del_component(constraint)
         constraints_removed += 1
         constraint_containers_removed += 1
     for block, constraint in constraint_containers_to_check:
@@ -344,20 +344,20 @@
             Ranges,
             RangeTypes,
             ColumnIndexToVarObject,
         ),
     )
 
 
-# class _LinearConstraintData(_ConstraintData,LinearCanonicalRepn):
+# class _LinearConstraintData(ConstraintData,LinearCanonicalRepn):
 #
 # This change breaks this class, but it's unclear whether this
 # is being used...
 #
-class _LinearConstraintData(_ConstraintData):
+class _LinearConstraintData(ConstraintData):
     """
     This class defines the data for a single linear constraint
         in canonical form.
 
     Constructor arguments:
         component       The Constraint object that owns this data.
 
@@ -389,15 +389,15 @@
 
     __slots__ = ()
 
     def __init__(self, index, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
-        #   - _ConstraintData,
+        #   - ConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = weakref_ref(component) if (component is not None) else None
         self._index = index
         self._active = True
 
 
@@ -438,15 +438,15 @@
     __slots__ = ()
 
     def __init__(self, index, component=None):
         #
         # These lines represent in-lining of the
         # following constructors:
         #   - _LinearConstraintData
-        #   - _ConstraintData,
+        #   - ConstraintData,
         #   - ActiveComponentData
         #   - ComponentData
         self._component = weakref_ref(component) if (component is not None) else None
         self._active = True
 
         # row index into the sparse matrix stored on the parent
         assert index >= 0
@@ -580,15 +580,15 @@
             for p in range(prows[self._index], prows[self._index + 1])
             if varmap[jcols[p]].fixed
         )
 
         return sum(terms)
 
     #
-    # Abstract Interface (_ConstraintData)
+    # Abstract Interface (ConstraintData)
     #
 
     @property
     def body(self):
         """Access the body of a constraint expression."""
         comp = self.parent_component()
         index = self.index()
```

### Comparing `Pyomo-6.7.1/pyomo/repn/linear.py` & `Pyomo-6.7.2/pyomo/repn/linear.py`

 * *Files 11% similar despite different names*

```diff
@@ -27,16 +27,16 @@
     PowExpression,
     AbsExpression,
     UnaryFunctionExpression,
     Expr_ifExpression,
     MonomialTermExpression,
     LinearExpression,
     SumExpression,
-    NPV_SumExpression,
     ExternalFunctionExpression,
+    mutable_expression,
 )
 from pyomo.core.expr.relational_expr import (
     EqualityExpression,
     InequalityExpression,
     RangedExpression,
 )
 from pyomo.core.expr.visitor import StreamBasedExpressionVisitor, _EvaluationVisitor
@@ -116,30 +116,22 @@
             # assignment) in case the term is a non-numeric node (like a
             # relational expression)
             ans = self.nonlinear
         else:
             ans = 0
         if self.linear:
             var_map = visitor.var_map
-            if len(self.linear) == 1:
-                vid, coef = next(iter(self.linear.items()))
-                if coef == 1:
-                    ans += var_map[vid]
-                elif coef:
-                    ans += MonomialTermExpression((coef, var_map[vid]))
-                else:
-                    pass
-            else:
-                ans += LinearExpression(
-                    [
-                        MonomialTermExpression((coef, var_map[vid]))
-                        for vid, coef in self.linear.items()
-                        if coef
-                    ]
-                )
+            with mutable_expression() as e:
+                for vid, coef in self.linear.items():
+                    if coef:
+                        e += coef * var_map[vid]
+            if e.nargs() > 1:
+                ans += e
+            elif e.nargs() == 1:
+                ans += e.arg(0)
         if self.constant:
             ans += self.constant
         if self.multiplier != 1:
             ans *= self.multiplier
         return ans
 
     def append(self, other):
@@ -204,39 +196,36 @@
 
 def _handle_negation_ANY(visitor, node, arg):
     arg[1].multiplier *= -1
     return arg
 
 
 _exit_node_handlers[NegationExpression] = {
+    None: _handle_negation_ANY,
     (_CONSTANT,): _handle_negation_constant,
-    (_LINEAR,): _handle_negation_ANY,
-    (_GENERAL,): _handle_negation_ANY,
 }
 
 #
 # PRODUCT handlers
 #
 
 
 def _handle_product_constant_constant(visitor, node, arg1, arg2):
-    _, arg1 = arg1
-    _, arg2 = arg2
-    ans = arg1 * arg2
+    ans = arg1[1] * arg2[1]
     if ans != ans:
-        if not arg1 or not arg2:
+        if not arg1[1] or not arg2[1]:
             deprecation_warning(
-                f"Encountered {str(arg1)}*{str(arg2)} in expression tree.  "
+                f"Encountered {str(arg1[1])}*{str(arg2[1])} in expression tree.  "
                 "Mapping the NaN result to 0 for compatibility "
                 "with the lp_v1 writer.  In the future, this NaN "
                 "will be preserved/emitted to comply with IEEE-754.",
                 version='6.6.0',
             )
-            return _, 0
-    return _, arg1 * arg2
+            return _CONSTANT, 0
+    return _CONSTANT, ans
 
 
 def _handle_product_constant_ANY(visitor, node, arg1, arg2):
     arg2[1].multiplier *= arg1[1]
     return arg2
 
 
@@ -280,65 +269,56 @@
         x1.nonlinear = None
         x2.constant = 0
         ans.nonlinear += to_expression(visitor, arg1) * to_expression(visitor, arg2)
     return _GENERAL, ans
 
 
 _exit_node_handlers[ProductExpression] = {
+    None: _handle_product_nonlinear,
     (_CONSTANT, _CONSTANT): _handle_product_constant_constant,
     (_CONSTANT, _LINEAR): _handle_product_constant_ANY,
     (_CONSTANT, _GENERAL): _handle_product_constant_ANY,
     (_LINEAR, _CONSTANT): _handle_product_ANY_constant,
-    (_LINEAR, _LINEAR): _handle_product_nonlinear,
-    (_LINEAR, _GENERAL): _handle_product_nonlinear,
     (_GENERAL, _CONSTANT): _handle_product_ANY_constant,
-    (_GENERAL, _LINEAR): _handle_product_nonlinear,
-    (_GENERAL, _GENERAL): _handle_product_nonlinear,
 }
 _exit_node_handlers[MonomialTermExpression] = _exit_node_handlers[ProductExpression]
 
 #
 # DIVISION handlers
 #
 
 
 def _handle_division_constant_constant(visitor, node, arg1, arg2):
     return _CONSTANT, apply_node_operation(node, (arg1[1], arg2[1]))
 
 
 def _handle_division_ANY_constant(visitor, node, arg1, arg2):
-    arg1[1].multiplier /= arg2[1]
+    arg1[1].multiplier = apply_node_operation(node, (arg1[1].multiplier, arg2[1]))
     return arg1
 
 
 def _handle_division_nonlinear(visitor, node, arg1, arg2):
     ans = visitor.Result()
     ans.nonlinear = to_expression(visitor, arg1) / to_expression(visitor, arg2)
     return _GENERAL, ans
 
 
 _exit_node_handlers[DivisionExpression] = {
+    None: _handle_division_nonlinear,
     (_CONSTANT, _CONSTANT): _handle_division_constant_constant,
-    (_CONSTANT, _LINEAR): _handle_division_nonlinear,
-    (_CONSTANT, _GENERAL): _handle_division_nonlinear,
     (_LINEAR, _CONSTANT): _handle_division_ANY_constant,
-    (_LINEAR, _LINEAR): _handle_division_nonlinear,
-    (_LINEAR, _GENERAL): _handle_division_nonlinear,
     (_GENERAL, _CONSTANT): _handle_division_ANY_constant,
-    (_GENERAL, _LINEAR): _handle_division_nonlinear,
-    (_GENERAL, _GENERAL): _handle_division_nonlinear,
 }
 
 #
 # EXPONENTIATION handlers
 #
 
 
-def _handle_pow_constant_constant(visitor, node, *args):
-    arg1, arg2 = args
+def _handle_pow_constant_constant(visitor, node, arg1, arg2):
     ans = apply_node_operation(node, (arg1[1], arg2[1]))
     if ans.__class__ in native_complex_types:
         ans = complex_number_error(ans, visitor, node)
     return _CONSTANT, ans
 
 
 def _handle_pow_ANY_constant(visitor, node, arg1, arg2):
@@ -362,23 +342,18 @@
 def _handle_pow_nonlinear(visitor, node, arg1, arg2):
     ans = visitor.Result()
     ans.nonlinear = to_expression(visitor, arg1) ** to_expression(visitor, arg2)
     return _GENERAL, ans
 
 
 _exit_node_handlers[PowExpression] = {
+    None: _handle_pow_nonlinear,
     (_CONSTANT, _CONSTANT): _handle_pow_constant_constant,
-    (_CONSTANT, _LINEAR): _handle_pow_nonlinear,
-    (_CONSTANT, _GENERAL): _handle_pow_nonlinear,
     (_LINEAR, _CONSTANT): _handle_pow_ANY_constant,
-    (_LINEAR, _LINEAR): _handle_pow_nonlinear,
-    (_LINEAR, _GENERAL): _handle_pow_nonlinear,
     (_GENERAL, _CONSTANT): _handle_pow_ANY_constant,
-    (_GENERAL, _LINEAR): _handle_pow_nonlinear,
-    (_GENERAL, _GENERAL): _handle_pow_nonlinear,
 }
 
 #
 # ABS and UNARY handlers
 #
 
 
@@ -393,17 +368,16 @@
 def _handle_unary_nonlinear(visitor, node, arg):
     ans = visitor.Result()
     ans.nonlinear = node.create_node_with_local_data((to_expression(visitor, arg),))
     return _GENERAL, ans
 
 
 _exit_node_handlers[UnaryFunctionExpression] = {
+    None: _handle_unary_nonlinear,
     (_CONSTANT,): _handle_unary_constant,
-    (_LINEAR,): _handle_unary_nonlinear,
-    (_GENERAL,): _handle_unary_nonlinear,
 }
 _exit_node_handlers[AbsExpression] = _exit_node_handlers[UnaryFunctionExpression]
 
 #
 # NAMED EXPRESSION handlers
 #
 
@@ -418,17 +392,16 @@
     # Record this common expression
     visitor.subexpression_cache[id(node)] = arg1
     _type, arg1 = arg1
     return _type, arg1.duplicate()
 
 
 _exit_node_handlers[Expression] = {
+    None: _handle_named_ANY,
     (_CONSTANT,): _handle_named_constant,
-    (_LINEAR,): _handle_named_ANY,
-    (_GENERAL,): _handle_named_ANY,
 }
 
 #
 # EXPR_IF handlers
 #
 
 
@@ -453,20 +426,15 @@
             to_expression(visitor, arg2),
             to_expression(visitor, arg3),
         )
     )
     return _GENERAL, ans
 
 
-_exit_node_handlers[Expr_ifExpression] = {
-    (i, j, k): _handle_expr_if_nonlinear
-    for i in (_LINEAR, _GENERAL)
-    for j in (_CONSTANT, _LINEAR, _GENERAL)
-    for k in (_CONSTANT, _LINEAR, _GENERAL)
-}
+_exit_node_handlers[Expr_ifExpression] = {None: _handle_expr_if_nonlinear}
 for j in (_CONSTANT, _LINEAR, _GENERAL):
     for k in (_CONSTANT, _LINEAR, _GENERAL):
         _exit_node_handlers[Expr_ifExpression][_CONSTANT, j, k] = _handle_expr_if_const
 
 #
 # Relational expression handlers
 #
@@ -491,19 +459,17 @@
     ans.nonlinear = EqualityExpression(
         (to_expression(visitor, arg1), to_expression(visitor, arg2))
     )
     return _GENERAL, ans
 
 
 _exit_node_handlers[EqualityExpression] = {
-    (i, j): _handle_equality_general
-    for i in (_CONSTANT, _LINEAR, _GENERAL)
-    for j in (_CONSTANT, _LINEAR, _GENERAL)
+    None: _handle_equality_general,
+    (_CONSTANT, _CONSTANT): _handle_equality_const,
 }
-_exit_node_handlers[EqualityExpression][_CONSTANT, _CONSTANT] = _handle_equality_const
 
 
 def _handle_inequality_const(visitor, node, arg1, arg2):
     # It is exceptionally likely that if we get here, one of the
     # arguments is an InvalidNumber
     args, causes = InvalidNumber.parse_args(arg1[1], arg2[1])
     try:
@@ -521,21 +487,17 @@
     ans.nonlinear = InequalityExpression(
         (to_expression(visitor, arg1), to_expression(visitor, arg2)), node.strict
     )
     return _GENERAL, ans
 
 
 _exit_node_handlers[InequalityExpression] = {
-    (i, j): _handle_inequality_general
-    for i in (_CONSTANT, _LINEAR, _GENERAL)
-    for j in (_CONSTANT, _LINEAR, _GENERAL)
+    None: _handle_inequality_general,
+    (_CONSTANT, _CONSTANT): _handle_inequality_const,
 }
-_exit_node_handlers[InequalityExpression][
-    _CONSTANT, _CONSTANT
-] = _handle_inequality_const
 
 
 def _handle_ranged_const(visitor, node, arg1, arg2, arg3):
     # It is exceptionally likely that if we get here, one of the
     # arguments is an InvalidNumber
     args, causes = InvalidNumber.parse_args(arg1[1], arg2[1], arg3[1])
     try:
@@ -558,22 +520,17 @@
         ),
         node.strict,
     )
     return _GENERAL, ans
 
 
 _exit_node_handlers[RangedExpression] = {
-    (i, j, k): _handle_ranged_general
-    for i in (_CONSTANT, _LINEAR, _GENERAL)
-    for j in (_CONSTANT, _LINEAR, _GENERAL)
-    for k in (_CONSTANT, _LINEAR, _GENERAL)
+    None: _handle_ranged_general,
+    (_CONSTANT, _CONSTANT, _CONSTANT): _handle_ranged_const,
 }
-_exit_node_handlers[RangedExpression][
-    _CONSTANT, _CONSTANT, _CONSTANT
-] = _handle_ranged_const
 
 
 class LinearBeforeChildDispatcher(BeforeChildDispatcher):
     def __init__(self):
         # Special handling for external functions: will be handled
         # as terminal nodes from the point of view of the visitor
         self[ExternalFunctionExpression] = self._before_external
@@ -700,14 +657,26 @@
                     linear[_id] = arg1
                 elif _id in linear:
                     linear[_id] += arg1
                 else:
                     linear[_id] = arg1
             elif arg.__class__ in native_numeric_types:
                 const += arg
+            elif arg.is_variable_type():
+                _id = id(arg)
+                if _id not in var_map:
+                    if arg.fixed:
+                        const += visitor.check_constant(arg.value, arg)
+                        continue
+                    LinearBeforeChildDispatcher._record_var(visitor, arg)
+                    linear[_id] = 1
+                elif _id in linear:
+                    linear[_id] += 1
+                else:
+                    linear[_id] = 1
             else:
                 try:
                     const += visitor.check_constant(visitor.evaluate(arg), arg)
                 except (ValueError, ArithmeticError):
                     return True, None
         if linear:
             ans.constant = const
@@ -746,15 +715,18 @@
 #
 # Initialize the _exit_node_dispatcher
 #
 def _initialize_exit_node_dispatcher(exit_handlers):
     exit_dispatcher = {}
     for cls, handlers in exit_handlers.items():
         for args, fcn in handlers.items():
-            exit_dispatcher[(cls, *args)] = fcn
+            if args is None:
+                exit_dispatcher[cls] = fcn
+            else:
+                exit_dispatcher[(cls, *args)] = fcn
     return exit_dispatcher
 
 
 class LinearRepnVisitor(StreamBasedExpressionVisitor):
     Result = LinearRepn
     exit_node_handlers = _exit_node_handlers
     exit_node_dispatcher = ExitNodeDispatcher(
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/repn/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/ampl/__init__.py` & `Pyomo-6.7.2/pyomo/scripting/__init__.py`

 * *Files 11% similar despite different names*

```diff
@@ -5,8 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-from pyomo.repn.plugins.ampl.ampl_ import ProblemWriter_nl
+import pyomo.scripting.pyomo_command
+import pyomo.scripting.util
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/ampl/ampl_.py` & `Pyomo-6.7.2/pyomo/repn/plugins/ampl/ampl_.py`

 * *Files 0% similar despite different names*

```diff
@@ -29,15 +29,15 @@
     native_numeric_types,
     value,
     is_fixed,
 )
 from pyomo.core.base import (
     SymbolMap,
     NameLabeler,
-    _ExpressionData,
+    NamedExpressionData,
     SortComponents,
     var,
     param,
     Var,
     ExternalFunction,
     ComponentMap,
     Objective,
@@ -164,19 +164,19 @@
         "\t#lt",  # <
         "\t#le",
     )  # <=
 
     _op_template[EXPR.EqualityExpression] = "o24{C}\n"
     _op_comment[EXPR.EqualityExpression] = "\t#eq"
 
-    _op_template[var._VarData] = "v%d{C}\n"
-    _op_comment[var._VarData] = "\t#%s"
+    _op_template[var.VarData] = "v%d{C}\n"
+    _op_comment[var.VarData] = "\t#%s"
 
-    _op_template[param._ParamData] = "n%r{C}\n"
-    _op_comment[param._ParamData] = ""
+    _op_template[param.ParamData] = "n%r{C}\n"
+    _op_comment[param.ParamData] = ""
 
     _op_template[NumericConstant] = "n%r{C}\n"
     _op_comment[NumericConstant] = ""
 
     _op_template[EXPR.SumExpressionBase] = (
         "o54{C}\n%d\n",  # nary +
         "o0{C}\n",  # +
@@ -720,41 +720,41 @@
                 self._print_nonlinear_terms_NL(right)
 
             elif exp_type is EXPR.EqualityExpression:
                 OUTPUT.write(self._op_string[EXPR.EqualityExpression])
                 self._print_nonlinear_terms_NL(exp.arg(0))
                 self._print_nonlinear_terms_NL(exp.arg(1))
 
-            elif isinstance(exp, (_ExpressionData, IIdentityExpression)):
+            elif isinstance(exp, (NamedExpressionData, IIdentityExpression)):
                 self._print_nonlinear_terms_NL(exp.expr)
 
             else:
                 raise ValueError(
                     "Unsupported expression type (%s) in _print_nonlinear_terms_NL"
                     % (exp_type)
                 )
 
-        elif isinstance(exp, (var._VarData, IVariable)) and (not exp.is_fixed()):
+        elif isinstance(exp, (var.VarData, IVariable)) and (not exp.is_fixed()):
             # (self._output_fixed_variable_bounds or
             if not self._symbolic_solver_labels:
                 OUTPUT.write(
-                    self._op_string[var._VarData]
+                    self._op_string[var.VarData]
                     % (self.ampl_var_id[self._varID_map[id(exp)]])
                 )
             else:
                 OUTPUT.write(
-                    self._op_string[var._VarData]
+                    self._op_string[var.VarData]
                     % (
                         self.ampl_var_id[self._varID_map[id(exp)]],
                         self._name_labeler(exp),
                     )
                 )
 
-        elif isinstance(exp, param._ParamData):
-            OUTPUT.write(self._op_string[param._ParamData] % (value(exp)))
+        elif isinstance(exp, param.ParamData):
+            OUTPUT.write(self._op_string[param.ParamData] % (value(exp)))
 
         elif isinstance(exp, NumericConstant) or exp.is_fixed():
             OUTPUT.write(self._op_string[NumericConstant] % (value(exp)))
 
         else:
             raise ValueError(
                 "Unsupported expression type (%s) in _print_nonlinear_terms_NL"
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/baron_writer.py` & `Pyomo-6.7.2/pyomo/repn/plugins/baron_writer.py`

 * *Files 2% similar despite different names*

```diff
@@ -170,23 +170,34 @@
         if const in _plusMinusOne:
             if const < 0:
                 return '-' + self.smap.getSymbol(var)
             else:
                 return self.smap.getSymbol(var)
         return ftoa(const, True) + '*' + self.smap.getSymbol(var)
 
+    def _var_to_string(self, node):
+        if node.is_fixed():
+            return ftoa(node.value, True)
+        self.variables.add(id(node))
+        return self.smap.getSymbol(node)
+
     def _linear_to_string(self, node):
         values = [
             (
                 self._monomial_to_string(arg)
-                if (
-                    arg.__class__ is EXPR.MonomialTermExpression
-                    and not arg.arg(1).is_fixed()
+                if arg.__class__ is EXPR.MonomialTermExpression
+                else (
+                    ftoa(arg)
+                    if arg.__class__ in native_numeric_types
+                    else (
+                        self._var_to_string(arg)
+                        if arg.is_variable_type()
+                        else ftoa(value(arg), True)
+                    )
                 )
-                else ftoa(value(arg))
             )
             for arg in node.args
         ]
         return node._to_string(values, False, self.smap)
 
 
 def expression_to_string(expr, variables, smap):
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/cpxlp.py` & `Pyomo-6.7.2/pyomo/repn/plugins/cpxlp.py`

 * *Files 0% similar despite different names*

```diff
@@ -56,15 +56,15 @@
 class ProblemWriter_cpxlp(AbstractProblemWriter):
     def __init__(self):
         AbstractProblemWriter.__init__(self, ProblemFormat.cpxlp)
 
         # The LP writer tracks which variables are
         # referenced in constraints, so that a user does not end up with a
         # zillion "unreferenced variables" warning messages.
-        # This dictionary maps id(_VarData) -> _VarData.
+        # This dictionary maps id(VarData) -> VarData.
         self._referenced_variable_ids = {}
 
         # Per ticket #4319, we are using %.17g, which mocks the
         # behavior of using %r (i.e., float('%r'%<number>) == <number>) with
         # the added benefit of outputting (+/-). The only case where this
         # fails to mock the behavior of %r is for large (long) integers (L),
         # which is a rare case to run into and is probably indicative of
@@ -370,15 +370,15 @@
         #
         # Return constant offset
         #
         return x.constant
 
     def printSOS(self, symbol_map, labeler, variable_symbol_map, soscondata, output):
         """
-        Prints the SOS constraint associated with the _SOSConstraintData object
+        Prints the SOS constraint associated with the SOSConstraintData object
         """
         sos_template_string = self.sos_template_string
 
         if hasattr(soscondata, 'get_items'):
             sos_items = list(soscondata.get_items())
         else:
             sos_items = list(soscondata.items())
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/gams_writer.py` & `Pyomo-6.7.2/pyomo/repn/plugins/gams_writer.py`

 * *Files 1% similar despite different names*

```diff
@@ -179,15 +179,24 @@
         return ftoa(const, True) + '*' + self.smap.getSymbol(var)
 
     def _linear_to_string(self, node):
         values = [
             (
                 self._monomial_to_string(arg)
                 if arg.__class__ is EXPR.MonomialTermExpression
-                else ftoa(arg, True)
+                else (
+                    ftoa(arg, True)
+                    if arg.__class__ in native_numeric_types
+                    else (
+                        self.smap.getSymbol(arg)
+                        if arg.is_variable_type()
+                        and (not arg.fixed or self.output_fixed_variables)
+                        else ftoa(value(arg), True)
+                    )
+                )
             )
             for arg in node.args
         ]
         return node._to_string(values, False, self.smap)
 
 
 def expression_to_string(expr, treechecker, smap=None, output_fixed_variables=False):
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/lp_writer.py` & `Pyomo-6.7.2/pyomo/repn/plugins/lp_writer.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/mps.py` & `Pyomo-6.7.2/pyomo/repn/plugins/mps.py`

 * *Files 0% similar despite different names*

```diff
@@ -58,15 +58,15 @@
     def __init__(self, int_marker=False):
         AbstractProblemWriter.__init__(self, ProblemFormat.mps)
 
         # the MPS writer is responsible for tracking which variables are
         # referenced in constraints, so that one doesn't end up with a
         # zillion "unreferenced variables" warning messages. stored at
         # the object level to avoid additional method arguments.
-        # dictionary of id(_VarData)->_VarData.
+        # dictionary of id(VarData)->VarData.
         self._referenced_variable_ids = {}
 
         # Keven Hunter made a nice point about using %.16g in his attachment
         # to ticket #4319. I am adjusting this to %.17g as this mocks the
         # behavior of using %r (i.e., float('%r'%<number>) == <number>) with
         # the added benefit of outputting (+/-). The only case where this
         # fails to mock the behavior of %r is for large (long) integers (L),
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/nl_writer.py` & `Pyomo-6.7.2/pyomo/repn/plugins/nl_writer.py`

 * *Files 1% similar despite different names*

```diff
@@ -65,23 +65,19 @@
     SOSConstraint,
     SymbolMap,
     NameLabeler,
     SortComponents,
     minimize,
 )
 from pyomo.core.base.component import ActiveComponent
-from pyomo.core.base.constraint import _ConstraintData
-from pyomo.core.base.expression import ScalarExpression, _GeneralExpressionData
-from pyomo.core.base.objective import (
-    ScalarObjective,
-    _GeneralObjectiveData,
-    _ObjectiveData,
-)
+from pyomo.core.base.constraint import ConstraintData
+from pyomo.core.base.expression import ScalarExpression, ExpressionData
+from pyomo.core.base.objective import ScalarObjective, ObjectiveData
 from pyomo.core.base.suffix import SuffixFinder
-from pyomo.core.base.var import _VarData
+from pyomo.core.base.var import VarData
 import pyomo.core.kernel as kernel
 from pyomo.core.pyomoobject import PyomoObject
 from pyomo.opt import WriterFactory
 
 from pyomo.repn.util import (
     BeforeChildDispatcher,
     ExitNodeDispatcher,
@@ -109,14 +105,15 @@
 
 logger = logging.getLogger(__name__)
 
 # Feasibility tolerance for trivial (fixed) constraints
 TOL = 1e-8
 inf = float('inf')
 minus_inf = -inf
+allowable_binary_var_bounds = {(0, 0), (0, 1), (1, 1)}
 
 _CONSTANT = ExprType.CONSTANT
 _MONOMIAL = ExprType.MONOMIAL
 _GENERAL = ExprType.GENERAL
 
 ScalingFactors = namedtuple(
     'ScalingFactors', ['variables', 'constraints', 'objectives']
@@ -125,25 +122,25 @@
 
 # TODO: make a proper base class
 class NLWriterInfo(object):
     """Return type for NLWriter.write()
 
     Attributes
     ----------
-    variables: List[_VarData]
+    variables: List[VarData]
 
         The list of (unfixed) Pyomo model variables in the order written
         to the NL file
 
-    constraints: List[_ConstraintData]
+    constraints: List[ConstraintData]
 
         The list of (active) Pyomo model constraints in the order written
         to the NL file
 
-    objectives: List[_ObjectiveData]
+    objectives: List[ObjectiveData]
 
         The list of (active) Pyomo model objectives in the order written
         to the NL file
 
     external_function_libraries: List[str]
 
         The list of paths to external function libraries referenced by
@@ -158,18 +155,18 @@
 
     column_labels: List[str]
 
         The list of string names for the variables written to the NL
         file in the same order as the :py:attr:`variables` and generated
         .col file.
 
-    eliminated_vars: List[Tuple[_VarData, NumericExpression]]
+    eliminated_vars: List[Tuple[VarData, NumericExpression]]
 
         The list of variables in the model that were eliminated by the
-        presolve.  Each entry is a 2-tuple of (:py:class:`_VarData`,
+        presolve.  Each entry is a 2-tuple of (:py:class:`VarData`,
         :py:class`NumericExpression`|`float`).  The list is in the
         necessary order for correct evaluation (i.e., all variables
         appearing in the expression must either have been sent to the
         solver, or appear *earlier* in this list.
 
     scaling: ScalingFactors or None
 
@@ -437,14 +434,15 @@
         self.datatype.add(suffix.datatype)
         self.values.update(suffix)
 
     def store(self, obj, val):
         self.values[obj] = val
 
     def compile(self, column_order, row_order, obj_order, model_id):
+        var_con_obj = {Var, Constraint, Objective}
         missing_component_data = ComponentSet()
         unknown_data = ComponentSet()
         queue = [self.values.items()]
         while queue:
             for obj, val in queue.pop(0):
                 if val.__class__ not in int_float:
                     # [JDS] I am not entirely sure why, but we have
@@ -462,26 +460,28 @@
                     self.var[column_order[_id]] = val
                 elif _id in row_order:
                     self.con[row_order[_id]] = val
                 elif _id in obj_order:
                     self.obj[obj_order[_id]] = val
                 elif _id == model_id:
                     self.prob[0] = val
-                elif isinstance(obj, (_VarData, _ConstraintData, _ObjectiveData)):
-                    missing_component_data.add(obj)
-                elif isinstance(obj, (Var, Constraint, Objective)):
-                    # Expand this indexed component to store the
-                    # individual ComponentDatas, but ONLY if the
-                    # component data is not in the original dictionary
-                    # of values that we extracted from the Suffixes
-                    queue.append(
-                        product(
-                            filterfalse(self.values.__contains__, obj.values()), (val,)
+                elif getattr(obj, 'ctype', None) in var_con_obj:
+                    if obj.is_indexed():
+                        # Expand this indexed component to store the
+                        # individual ComponentDatas, but ONLY if the
+                        # component data is not in the original dictionary
+                        # of values that we extracted from the Suffixes
+                        queue.append(
+                            product(
+                                filterfalse(self.values.__contains__, obj.values()),
+                                (val,),
+                            )
                         )
-                    )
+                    else:
+                        missing_component_data.add(obj)
                 else:
                     unknown_data.add(obj)
         if missing_component_data:
             logger.warning(
                 f"model contains export suffix '{self.name}' that "
                 f"contains {len(missing_component_data)} component keys that are "
                 "not exported as part of the NL file.  "
@@ -878,15 +878,20 @@
         for _id in all_vars:
             v = var_map[_id]
             if v.is_continuous():
                 continuous_vars.add(_id)
             elif v.is_binary():
                 binary_vars.add(_id)
             elif v.is_integer():
-                integer_vars.add(_id)
+                # Note: integer variables whose bounds are in {0, 1}
+                # should be classified as binary
+                if var_bounds[_id] in allowable_binary_var_bounds:
+                    binary_vars.add(_id)
+                else:
+                    integer_vars.add(_id)
             else:
                 raise ValueError(
                     f"Variable '{v.name}' has a domain that is not Real, "
                     f"Integer, or Binary: Cannot write a legal NL file."
                 )
         discrete_vars = binary_vars | integer_vars
 
@@ -1077,17 +1082,45 @@
                 # Update _vmap to output scaled variables in NL expressions
                 _vmap[_id] = (
                     template.division + _vmap[_id] + '\n' + template.const % scale
                 ).rstrip()
 
         # Update any eliminated variables to point to the (potentially
         # scaled) substituted variables
-        for _id, expr_info in eliminated_vars.items():
+        for _id, expr_info in list(eliminated_vars.items()):
             nl, args, _ = expr_info.compile_repn(visitor)
-            _vmap[_id] = nl.rstrip() % tuple(_vmap[_id] for _id in args)
+            for _i in args:
+                # It is possible that the eliminated variable could
+                # reference another variable that is no longer part of
+                # the model and therefore does not have a _vmap entry.
+                # This can happen when there is an underdetermined
+                # independent linear subsystem and the presolve removed
+                # all the constraints from the subsystem.  Because the
+                # free variables in the subsystem are not referenced
+                # anywhere else in the model, they are not part of the
+                # `variables` list.  Implicitly "fix" it to an arbitrary
+                # valid value from the presolved domain (see #3192).
+                if _i not in _vmap:
+                    lb, ub = var_bounds[_i]
+                    if lb is None:
+                        lb = -inf
+                    if ub is None:
+                        ub = inf
+                    if lb <= 0 <= ub:
+                        val = 0
+                    else:
+                        val = lb if abs(lb) < abs(ub) else ub
+                    eliminated_vars[_i] = AMPLRepn(val, {}, None)
+                    _vmap[_i] = expr_info.compile_repn(visitor)[0]
+                    logger.warning(
+                        "presolve identified an underdetermined independent "
+                        "linear subsystem that was removed from the model.  "
+                        f"Setting '{var_map[_i]}' == {val}"
+                    )
+            _vmap[_id] = nl.rstrip() % tuple(_vmap[_i] for _i in args)
 
         r_lines = [None] * n_cons
         for idx, (con, expr_info, lb, ub) in enumerate(constraints):
             if lb == ub:  # TBD: should this be within tolerance?
                 if lb is None:
                     # type = 3  # -inf <= c <= inf
                     r_lines[idx] = "3"
@@ -1245,16 +1278,16 @@
         ostream.write(
             " %d %d %d %d %d \t"
             "# discrete variables: binary, integer, nonlinear (b,c,o)\n"
             % (
                 len(linear_binary_vars),
                 len(linear_integer_vars),
                 len(both_vars_nonlinear.intersection(discrete_vars)),
-                len(con_vars_nonlinear.intersection(discrete_vars)),
-                len(obj_vars_nonlinear.intersection(discrete_vars)),
+                len(con_only_nonlinear_vars.intersection(discrete_vars)),
+                len(obj_only_nonlinear_vars.intersection(discrete_vars)),
             )
         )
         #
         # LINE 8
         #
         # objective info computed above
         ostream.write(
@@ -1756,15 +1789,15 @@
                 expr_info, lb = info
                 _id, coef = expr_info.linear.popitem()
                 id2, coef2 = expr_info.linear.popitem()
                 #
                 id2_isdiscrete = var_map[id2].domain.isdiscrete()
                 if var_map[_id].domain.isdiscrete() ^ id2_isdiscrete:
                     # if only one variable is discrete, then we need to
-                    # substiitute out the other
+                    # substitute out the other
                     if id2_isdiscrete:
                         _id, id2 = id2, _id
                         coef, coef2 = coef2, coef
                 else:
                     # In an attempt to improve numerical stability, we will
                     # solve for (and substitute out) the variable with the
                     # coefficient closer to +/-1)
@@ -1816,29 +1849,41 @@
                 # will be 0 - thereby preventing us from re-updating
                 # the expression.  We still want it to persist so
                 # that if later substitutions replace x with
                 # something else, then the expr_info gets updated
                 # appropriately (that expr_info is persisting in the
                 # eliminated_vars dict - and we will use that to
                 # update other linear expressions later.)
+                old_nnz = len(expr_info.linear)
                 c = expr_info.linear.pop(_id, 0)
+                nnz = old_nnz - 1
                 expr_info.const += c * b
                 if x in expr_info.linear:
                     expr_info.linear[x] += c * a
+                    if expr_info.linear[x] == 0:
+                        nnz -= 1
+                        coef = expr_info.linear.pop(x)
                 elif a:
                     expr_info.linear[x] = c * a
                     # replacing _id with x... NNZ is not changing,
                     # but we need to remember that x is now part of
                     # this constraint
                     comp_by_linear_var[x].append((con_id, expr_info))
                     continue
-                # NNZ has been reduced by 1
-                nnz = len(expr_info.linear)
-                _old = lcon_by_linear_nnz[nnz + 1]
+                _old = lcon_by_linear_nnz[old_nnz]
                 if con_id in _old:
+                    if not nnz:
+                        if abs(expr_info.const) > TOL:
+                            # constraint is trivially infeasible
+                            raise InfeasibleConstraintException(
+                                "model contains a trivially infeasible constraint "
+                                f"{expr_info.const} == {coef}*{var_map[x]}"
+                            )
+                        # constraint is trivially feasible
+                        eliminated_cons.add(con_id)
                     lcon_by_linear_nnz[nnz][con_id] = _old.pop(con_id)
             # If variables were replaced by the variable that
             # we are currently eliminating, then we need to update
             # the representation of those variables
             for resubst in substitutions_by_linear_var.pop(_id, ()):
                 expr_info = eliminated_vars[resubst]
                 c = expr_info.linear.pop(_id, 0)
@@ -2764,14 +2809,28 @@
                     linear[_id] = arg1
                 elif _id in linear:
                     linear[_id] += arg1
                 else:
                     linear[_id] = arg1
             elif arg.__class__ in native_types:
                 const += arg
+            elif arg.is_variable_type():
+                _id = id(arg)
+                if _id not in var_map:
+                    if arg.fixed:
+                        if _id not in visitor.fixed_vars:
+                            visitor.cache_fixed_var(_id, arg)
+                        const += visitor.fixed_vars[_id]
+                        continue
+                    _before_child_handlers._record_var(visitor, arg)
+                    linear[_id] = 1
+                elif _id in linear:
+                    linear[_id] += 1
+                else:
+                    linear[_id] = 1
             else:
                 try:
                     const += visitor.check_constant(visitor.evaluate(arg), arg)
                 except (ValueError, ArithmeticError):
                     return True, None
 
         if linear:
```

### Comparing `Pyomo-6.7.1/pyomo/repn/plugins/standard_form.py` & `Pyomo-6.7.2/pyomo/repn/plugins/standard_form.py`

 * *Files 6% similar despite different names*

```diff
@@ -16,14 +16,15 @@
 from pyomo.common.config import (
     ConfigBlock,
     ConfigValue,
     InEnum,
     document_kwargs_from_configdict,
 )
 from pyomo.common.dependencies import scipy, numpy as np
+from pyomo.common.enums import ObjectiveSense
 from pyomo.common.gc_manager import PauseGC
 from pyomo.common.timing import TicTocTimer
 
 from pyomo.core.base import (
     Block,
     Objective,
     Constraint,
@@ -57,60 +58,70 @@
 
 # TODO: make a proper base class
 class LinearStandardFormInfo(object):
     """Return type for LinearStandardFormCompiler.write()
 
     Attributes
     ----------
-    c : scipy.sparse.csr_array
+    c : scipy.sparse.csc_array
 
         The objective coefficients.  Note that this is a sparse array
         and may contain multiple rows (for multiobjective problems).  The
         objectives may be calculated by "c @ x"
 
+    c_offset : numpy.ndarray
+
+        The list of objective constant offsets
+
     A : scipy.sparse.csc_array
 
         The constraint coefficients.  The constraint bodies may be
         calculated by "A @ x"
 
     rhs : numpy.ndarray
 
         The constraint right-hand sides.
 
-    rows : List[Tuple[_ConstraintData, int]]
+    rows : List[Tuple[ConstraintData, int]]
 
         The list of Pyomo constraint objects corresponding to the rows
         in `A`.  Each element in the list is a 2-tuple of
-        (_ConstraintData, row_multiplier).  The `row_multiplier` will be
+        (ConstraintData, row_multiplier).  The `row_multiplier` will be
         +/- 1 indicating if the row was multiplied by -1 (corresponding
         to a constraint lower bound) or +1 (upper bound).
 
-    columns : List[_VarData]
+    columns : List[VarData]
 
         The list of Pyomo variable objects corresponding to columns in
         the `A` and `c` matrices.
 
-    eliminated_vars: List[Tuple[_VarData, NumericExpression]]
+    objectives : List[ObjectiveData]
+
+        The list of Pyomo objective objects corresponding to the active objectives
+
+    eliminated_vars: List[Tuple[VarData, NumericExpression]]
 
         The list of variables from the original model that do not appear
         in the standard form (usually because they were replaced by
         nonnegative variables).  Each entry is a 2-tuple of
-        (:py:class:`_VarData`, :py:class`NumericExpression`|`float`).
+        (:py:class:`VarData`, :py:class`NumericExpression`|`float`).
         The list is in the necessary order for correct evaluation (i.e.,
         all variables appearing in the expression must either have
         appeared in the standard form, or appear *earlier* in this list.
 
     """
 
-    def __init__(self, c, A, rhs, rows, columns, eliminated_vars):
+    def __init__(self, c, c_offset, A, rhs, rows, columns, objectives, eliminated_vars):
         self.c = c
+        self.c_offset = c_offset
         self.A = A
         self.rhs = rhs
         self.rows = rows
         self.columns = columns
+        self.objectives = objectives
         self.eliminated_vars = eliminated_vars
 
     @property
     def x(self):
         return self.columns
 
     @property
@@ -136,14 +147,31 @@
         ConfigValue(
             default=False,
             domain=bool,
             description='Add slack variables and return `min cTx s.t. Ax == b`',
         ),
     )
     CONFIG.declare(
+        'mixed_form',
+        ConfigValue(
+            default=False,
+            domain=bool,
+            description='Return A in mixed form (the comparison operator is a '
+            'mix of <=, ==, and >=)',
+        ),
+    )
+    CONFIG.declare(
+        'set_sense',
+        ConfigValue(
+            default=ObjectiveSense.minimize,
+            domain=InEnum(ObjectiveSense),
+            description='If not None, map all objectives to the specified sense.',
+        ),
+    )
+    CONFIG.declare(
         'show_section_timing',
         ConfigValue(
             default=False,
             domain=bool,
             description='Print timing after each stage of the compilation process',
         ),
     )
@@ -292,50 +320,53 @@
                     + "\n    ".join(s.name for s in suffixes)
                     + "\nStandard Form compiler ignores export suffixes.  Skipping."
                 )
 
         #
         # Process objective
         #
-        if not component_map[Objective]:
-            objectives = [Objective(expr=1)]
-            objectives[0].construct()
-        else:
-            objectives = []
-            for blk in component_map[Objective]:
-                objectives.extend(
-                    blk.component_data_objects(
-                        Objective, active=True, descend_into=False, sort=sorter
-                    )
+        set_sense = self.config.set_sense
+        objectives = []
+        for blk in component_map[Objective]:
+            objectives.extend(
+                blk.component_data_objects(
+                    Objective, active=True, descend_into=False, sort=sorter
                 )
+            )
+        obj_offset = []
         obj_data = []
         obj_index = []
         obj_index_ptr = [0]
-        for i, obj in enumerate(objectives):
+        for obj in objectives:
             repn = visitor.walk_expression(obj.expr)
             if repn.nonlinear is not None:
                 raise ValueError(
                     f"Model objective ({obj.name}) contains nonlinear terms that "
                     "cannot be compiled to standard (linear) form."
                 )
             N = len(repn.linear)
             obj_data.append(np.fromiter(repn.linear.values(), float, N))
-            if obj.sense == maximize:
+            obj_offset.append(repn.constant)
+            if set_sense is not None and set_sense != obj.sense:
                 obj_data[-1] *= -1
+                obj_offset[-1] *= -1
             obj_index.append(
                 np.fromiter(map(var_order.__getitem__, repn.linear), float, N)
             )
             obj_index_ptr.append(obj_index_ptr[-1] + N)
             if with_debug_timing:
                 timer.toc('Objective %s', obj, level=logging.DEBUG)
 
         #
         # Tabulate constraints
         #
         slack_form = self.config.slack_form
+        mixed_form = self.config.mixed_form
+        if slack_form and mixed_form:
+            raise ValueError("cannot specify both slack_form and mixed_form")
         rows = []
         rhs = []
         con_data = []
         con_index = []
         con_index_ptr = [0]
         last_parent = None
         for con in ordered_active_constraints(model, self.config):
@@ -368,15 +399,38 @@
             if not repn.linear:
                 if (lb is None or lb <= offset) and (ub is None or ub >= offset):
                     continue
                 raise InfeasibleError(
                     f"model contains a trivially infeasible constraint, '{con.name}'"
                 )
 
-            if slack_form:
+            if mixed_form:
+                N = len(repn.linear)
+                _data = np.fromiter(repn.linear.values(), float, N)
+                _index = np.fromiter(map(var_order.__getitem__, repn.linear), float, N)
+                if ub == lb:
+                    rows.append(RowEntry(con, 0))
+                    rhs.append(ub - offset)
+                    con_data.append(_data)
+                    con_index.append(_index)
+                    con_index_ptr.append(con_index_ptr[-1] + N)
+                else:
+                    if ub is not None:
+                        rows.append(RowEntry(con, 1))
+                        rhs.append(ub - offset)
+                        con_data.append(_data)
+                        con_index.append(_index)
+                        con_index_ptr.append(con_index_ptr[-1] + N)
+                    if lb is not None:
+                        rows.append(RowEntry(con, -1))
+                        rhs.append(lb - offset)
+                        con_data.append(_data)
+                        con_index.append(_index)
+                        con_index_ptr.append(con_index_ptr[-1] + N)
+            elif slack_form:
                 _data = list(repn.linear.values())
                 _index = list(map(var_order.__getitem__, repn.linear))
                 if lb == ub:  # TODO: add tolerance?
                     rhs.append(ub - offset)
                 else:
                     # add slack variable
                     v = Var(name=f'_slack_{len(rhs)}', bounds=(None, None))
@@ -417,56 +471,60 @@
         if with_debug_timing:
             # report the last constraint
             timer.toc('Constraint %s', last_parent, level=logging.DEBUG)
 
         # Get the variable list
         columns = list(var_map.values())
         # Convert the compiled data to scipy sparse matrices
+        if obj_data:
+            obj_data = np.concatenate(obj_data)
+            obj_index = np.concatenate(obj_index)
         c = scipy.sparse.csr_array(
-            (np.concatenate(obj_data), np.concatenate(obj_index), obj_index_ptr),
-            [len(obj_index_ptr) - 1, len(columns)],
+            (obj_data, obj_index, obj_index_ptr), [len(obj_index_ptr) - 1, len(columns)]
         ).tocsc()
+        if rows:
+            con_data = np.concatenate(con_data)
+            con_index = np.concatenate(con_index)
         A = scipy.sparse.csr_array(
-            (np.concatenate(con_data), np.concatenate(con_index), con_index_ptr),
-            [len(rows), len(columns)],
+            (con_data, con_index, con_index_ptr), [len(rows), len(columns)]
         ).tocsc()
 
         # Some variables in the var_map may not actually appear in the
         # objective or constraints (e.g., added from col_order, or
         # multiplied by 0 in the expressions).  The easiest way to check
         # for empty columns is to convert from CSR to CSC and then look
         # at the index pointer list (an O(num_var) operation).
         c_ip = c.indptr
         A_ip = A.indptr
-        active_var_idx = list(
-            filter(
-                lambda i: A_ip[i] != A_ip[i + 1] or c_ip[i] != c_ip[i + 1],
-                range(len(columns)),
-            )
-        )
-        nCol = len(active_var_idx)
+        active_var_mask = (A_ip[1:] > A_ip[:-1]) | (c_ip[1:] > c_ip[:-1])
+
+        # Masks on NumPy arrays are very fast.  Build the reduced A
+        # indptr and then check if we actually have to manipulate the
+        # columns
+        augmented_mask = np.concatenate((active_var_mask, [True]))
+        reduced_A_indptr = A.indptr[augmented_mask]
+        nCol = len(reduced_A_indptr) - 1
         if nCol != len(columns):
-            # Note that the indptr can't just use range() because a var
-            # may only appear in the objectives or the constraints.
-            columns = list(map(columns.__getitem__, active_var_idx))
-            active_var_idx.append(c.indptr[-1])
+            columns = [v for k, v in zip(active_var_mask, columns) if k]
             c = scipy.sparse.csc_array(
-                (c.data, c.indices, c.indptr.take(active_var_idx)), [c.shape[0], nCol]
+                (c.data, c.indices, c.indptr[augmented_mask]), [c.shape[0], nCol]
             )
-            active_var_idx[-1] = A.indptr[-1]
+            # active_var_idx[-1] = len(columns)
             A = scipy.sparse.csc_array(
-                (A.data, A.indices, A.indptr.take(active_var_idx)), [A.shape[0], nCol]
+                (A.data, A.indices, reduced_A_indptr), [A.shape[0], nCol]
             )
 
         if self.config.nonnegative_vars:
             c, A, columns, eliminated_vars = _csc_to_nonnegative_vars(c, A, columns)
         else:
             eliminated_vars = []
 
-        info = LinearStandardFormInfo(c, A, rhs, rows, columns, eliminated_vars)
+        info = LinearStandardFormInfo(
+            c, np.array(obj_offset), A, rhs, rows, columns, objectives, eliminated_vars
+        )
         timer.toc("Generated linear standard form representation", delta=False)
         return info
 
 
 def _csc_to_nonnegative_vars(c, A, columns):
     eliminated_vars = []
     new_columns = []
```

### Comparing `Pyomo-6.7.1/pyomo/repn/quadratic.py` & `Pyomo-6.7.2/pyomo/repn/quadratic.py`

 * *Files 24% similar despite different names*

```diff
@@ -94,30 +94,23 @@
                 for (x1, x2), coef in self.quadratic.items():
                     if x1 == x2:
                         e += coef * var_map[x1] ** 2
                     else:
                         e += coef * (var_map[x1] * var_map[x2])
             ans += e
         if self.linear:
-            if len(self.linear) == 1:
-                vid, coef = next(iter(self.linear.items()))
-                if coef == 1:
-                    ans += var_map[vid]
-                elif coef:
-                    ans += MonomialTermExpression((coef, var_map[vid]))
-                else:
-                    pass
-            else:
-                ans += LinearExpression(
-                    [
-                        MonomialTermExpression((coef, var_map[vid]))
-                        for vid, coef in self.linear.items()
-                        if coef
-                    ]
-                )
+            var_map = visitor.var_map
+            with mutable_expression() as e:
+                for vid, coef in self.linear.items():
+                    if coef:
+                        e += coef * var_map[vid]
+            if e.nargs() > 1:
+                ans += e
+            elif e.nargs() == 1:
+                ans += e.arg(0)
         if self.constant:
             ans += self.constant
         if self.multiplier != 1:
             ans *= self.multiplier
         return ans
 
     def append(self, other):
@@ -280,127 +273,70 @@
     if x1_c and x2.nonlinear is not None:
         ans.nonlinear += x1_c * x2.nonlinear
     return _GENERAL, ans
 
 
 _exit_node_handlers[ProductExpression].update(
     {
+        None: _handle_product_nonlinear,
         (_CONSTANT, _QUADRATIC): linear._handle_product_constant_ANY,
-        (_LINEAR, _QUADRATIC): _handle_product_nonlinear,
-        (_QUADRATIC, _QUADRATIC): _handle_product_nonlinear,
-        (_GENERAL, _QUADRATIC): _handle_product_nonlinear,
         (_QUADRATIC, _CONSTANT): linear._handle_product_ANY_constant,
-        (_QUADRATIC, _LINEAR): _handle_product_nonlinear,
-        (_QUADRATIC, _GENERAL): _handle_product_nonlinear,
         # Replace handler from the linear walker
         (_LINEAR, _LINEAR): _handle_product_linear_linear,
-        (_GENERAL, _GENERAL): _handle_product_nonlinear,
-        (_GENERAL, _LINEAR): _handle_product_nonlinear,
-        (_LINEAR, _GENERAL): _handle_product_nonlinear,
     }
 )
 
 #
 # DIVISION
 #
 _exit_node_handlers[DivisionExpression].update(
-    {
-        (_CONSTANT, _QUADRATIC): linear._handle_division_nonlinear,
-        (_LINEAR, _QUADRATIC): linear._handle_division_nonlinear,
-        (_QUADRATIC, _QUADRATIC): linear._handle_division_nonlinear,
-        (_GENERAL, _QUADRATIC): linear._handle_division_nonlinear,
-        (_QUADRATIC, _CONSTANT): linear._handle_division_ANY_constant,
-        (_QUADRATIC, _LINEAR): linear._handle_division_nonlinear,
-        (_QUADRATIC, _GENERAL): linear._handle_division_nonlinear,
-    }
+    {(_QUADRATIC, _CONSTANT): linear._handle_division_ANY_constant}
 )
 
 
 #
 # EXPONENTIATION
 #
 _exit_node_handlers[PowExpression].update(
-    {
-        (_CONSTANT, _QUADRATIC): linear._handle_pow_nonlinear,
-        (_LINEAR, _QUADRATIC): linear._handle_pow_nonlinear,
-        (_QUADRATIC, _QUADRATIC): linear._handle_pow_nonlinear,
-        (_GENERAL, _QUADRATIC): linear._handle_pow_nonlinear,
-        (_QUADRATIC, _CONSTANT): linear._handle_pow_ANY_constant,
-        (_QUADRATIC, _LINEAR): linear._handle_pow_nonlinear,
-        (_QUADRATIC, _GENERAL): linear._handle_pow_nonlinear,
-    }
+    {(_QUADRATIC, _CONSTANT): linear._handle_pow_ANY_constant}
 )
 
 #
 # ABS and UNARY handlers
 #
-_exit_node_handlers[AbsExpression][(_QUADRATIC,)] = linear._handle_unary_nonlinear
-_exit_node_handlers[UnaryFunctionExpression][
-    (_QUADRATIC,)
-] = linear._handle_unary_nonlinear
+# (no changes needed)
 
 #
 # NAMED EXPRESSION handlers
 #
-_exit_node_handlers[Expression][(_QUADRATIC,)] = linear._handle_named_ANY
+# (no changes needed)
 
 #
 # EXPR_IF handlers
 #
 # Note: it is easier to just recreate the entire data structure, rather
 # than update it
-_exit_node_handlers[Expr_ifExpression] = {
-    (i, j, k): linear._handle_expr_if_nonlinear
-    for i in (_LINEAR, _QUADRATIC, _GENERAL)
-    for j in (_CONSTANT, _LINEAR, _QUADRATIC, _GENERAL)
-    for k in (_CONSTANT, _LINEAR, _QUADRATIC, _GENERAL)
-}
-for j in (_CONSTANT, _LINEAR, _QUADRATIC, _GENERAL):
-    for k in (_CONSTANT, _LINEAR, _QUADRATIC, _GENERAL):
-        _exit_node_handlers[Expr_ifExpression][
-            _CONSTANT, j, k
-        ] = linear._handle_expr_if_const
-
-#
-# RELATIONAL handlers
-#
-_exit_node_handlers[EqualityExpression].update(
-    {
-        (_CONSTANT, _QUADRATIC): linear._handle_equality_general,
-        (_LINEAR, _QUADRATIC): linear._handle_equality_general,
-        (_QUADRATIC, _QUADRATIC): linear._handle_equality_general,
-        (_GENERAL, _QUADRATIC): linear._handle_equality_general,
-        (_QUADRATIC, _CONSTANT): linear._handle_equality_general,
-        (_QUADRATIC, _LINEAR): linear._handle_equality_general,
-        (_QUADRATIC, _GENERAL): linear._handle_equality_general,
-    }
-)
-_exit_node_handlers[InequalityExpression].update(
+_exit_node_handlers[Expr_ifExpression].update(
     {
-        (_CONSTANT, _QUADRATIC): linear._handle_inequality_general,
-        (_LINEAR, _QUADRATIC): linear._handle_inequality_general,
-        (_QUADRATIC, _QUADRATIC): linear._handle_inequality_general,
-        (_GENERAL, _QUADRATIC): linear._handle_inequality_general,
-        (_QUADRATIC, _CONSTANT): linear._handle_inequality_general,
-        (_QUADRATIC, _LINEAR): linear._handle_inequality_general,
-        (_QUADRATIC, _GENERAL): linear._handle_inequality_general,
+        (_CONSTANT, i, _QUADRATIC): linear._handle_expr_if_const
+        for i in (_CONSTANT, _LINEAR, _QUADRATIC, _GENERAL)
     }
 )
-_exit_node_handlers[RangedExpression].update(
+_exit_node_handlers[Expr_ifExpression].update(
     {
-        (_CONSTANT, _QUADRATIC): linear._handle_ranged_general,
-        (_LINEAR, _QUADRATIC): linear._handle_ranged_general,
-        (_QUADRATIC, _QUADRATIC): linear._handle_ranged_general,
-        (_GENERAL, _QUADRATIC): linear._handle_ranged_general,
-        (_QUADRATIC, _CONSTANT): linear._handle_ranged_general,
-        (_QUADRATIC, _LINEAR): linear._handle_ranged_general,
-        (_QUADRATIC, _GENERAL): linear._handle_ranged_general,
+        (_CONSTANT, _QUADRATIC, i): linear._handle_expr_if_const
+        for i in (_CONSTANT, _LINEAR, _GENERAL)
     }
 )
 
+#
+# RELATIONAL handlers
+#
+# (no changes needed)
+
 
 class QuadraticRepnVisitor(linear.LinearRepnVisitor):
     Result = QuadraticRepn
     exit_node_handlers = _exit_node_handlers
     exit_node_dispatcher = linear.ExitNodeDispatcher(
         linear._initialize_exit_node_dispatcher(_exit_node_handlers)
     )
```

### Comparing `Pyomo-6.7.1/pyomo/repn/standard_aux.py` & `Pyomo-6.7.2/pyomo/repn/standard_aux.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/standard_repn.py` & `Pyomo-6.7.2/pyomo/repn/standard_repn.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,19 +15,23 @@
 import itertools
 
 from pyomo.common.numeric_types import native_types, native_numeric_types
 from pyomo.core.base import Constraint, Objective, ComponentMap
 
 import pyomo.core.expr as EXPR
 from pyomo.core.expr.numvalue import NumericConstant
-from pyomo.core.base.objective import _GeneralObjectiveData, ScalarObjective
-from pyomo.core.base import _ExpressionData, Expression
-from pyomo.core.base.expression import ScalarExpression, _GeneralExpressionData
-from pyomo.core.base.var import ScalarVar, Var, _GeneralVarData, value
-from pyomo.core.base.param import ScalarParam, _ParamData
+from pyomo.core.base.objective import ObjectiveData, ScalarObjective
+from pyomo.core.base import Expression
+from pyomo.core.base.expression import (
+    ScalarExpression,
+    NamedExpressionData,
+    ExpressionData,
+)
+from pyomo.core.base.var import ScalarVar, Var, VarData, value
+from pyomo.core.base.param import ScalarParam, ParamData
 from pyomo.core.kernel.expression import expression, noclone
 from pyomo.core.kernel.variable import IVariable, variable
 from pyomo.core.kernel.objective import objective
 
 from io import StringIO
 
 logger = logging.getLogger('pyomo.core')
@@ -317,14 +321,24 @@
                         if id_ in linear_coefs:
                             linear_coefs[id_] += c
                         else:
                             linear_coefs[id_] = c
                             linear_vars[id_] = v
                     elif arg.__class__ in native_numeric_types:
                         C_ += arg
+                    elif arg.is_variable_type():
+                        if arg.fixed:
+                            C_ += arg.value
+                            continue
+                        id_ = id(arg)
+                        if id_ in linear_coefs:
+                            linear_coefs[id_] += 1
+                        else:
+                            linear_coefs[id_] = 1
+                            linear_vars[id_] = arg
                     else:
                         C_ += EXPR.evaluate_expression(arg)
             else:  # compute_values == False
                 for arg in expr.args:
                     if arg.__class__ is EXPR.MonomialTermExpression:
                         c, v = arg.args
                         if v.fixed:
@@ -332,14 +346,26 @@
                             continue
                         id_ = id(v)
                         if id_ in linear_coefs:
                             linear_coefs[id_] += c
                         else:
                             linear_coefs[id_] = c
                             linear_vars[id_] = v
+                    elif arg.__class__ in native_numeric_types:
+                        C_ += arg
+                    elif arg.is_variable_type():
+                        if arg.fixed:
+                            C_ += arg
+                            continue
+                        id_ = id(arg)
+                        if id_ in linear_coefs:
+                            linear_coefs[id_] += 1
+                        else:
+                            linear_coefs[id_] = 1
+                            linear_vars[id_] = arg
                     else:
                         C_ += arg
 
             vars_ = []
             coef_ = []
             for id_, coef in linear_coefs.items():
                 if coef.__class__ in native_numeric_types and not coef:
@@ -1110,33 +1136,33 @@
     EXPR.AbsExpression: _collect_nonl,
     EXPR.NegationExpression: _collect_negation,
     EXPR.LinearExpression: _collect_linear,
     EXPR.InequalityExpression: _collect_comparison,
     EXPR.RangedExpression: _collect_comparison,
     EXPR.EqualityExpression: _collect_comparison,
     EXPR.ExternalFunctionExpression: _collect_external_fn,
-    # _ConnectorData          : _collect_linear_connector,
+    # ConnectorData          : _collect_linear_connector,
     # ScalarConnector         : _collect_linear_connector,
-    _ParamData: _collect_const,
+    ParamData: _collect_const,
     ScalarParam: _collect_const,
     # param.Param             : _collect_linear_const,
     # parameter               : _collect_linear_const,
     NumericConstant: _collect_const,
-    _GeneralVarData: _collect_var,
+    VarData: _collect_var,
     ScalarVar: _collect_var,
     Var: _collect_var,
     variable: _collect_var,
     IVariable: _collect_var,
-    _GeneralExpressionData: _collect_identity,
+    ExpressionData: _collect_identity,
     ScalarExpression: _collect_identity,
     expression: _collect_identity,
     noclone: _collect_identity,
-    _ExpressionData: _collect_identity,
+    NamedExpressionData: _collect_identity,
     Expression: _collect_identity,
-    _GeneralObjectiveData: _collect_identity,
+    ObjectiveData: _collect_identity,
     ScalarObjective: _collect_identity,
     objective: _collect_identity,
 }
 
 
 def _collect_standard_repn(exp, multiplier, idMap, compute_values, verbose, quadratic):
     fn = _repn_collectors.get(exp.__class__, None)
@@ -1510,32 +1536,32 @@
     EXPR.NegationExpression                     : _linear_collect_negation,
     EXPR.LinearExpression                       : _linear_collect_linear,
     #EXPR.InequalityExpression                   : _linear_collect_comparison,
     #EXPR.RangedExpression                       : _linear_collect_comparison,
     #EXPR.EqualityExpression                     : _linear_collect_comparison,
     #EXPR.ExternalFunctionExpression             : _linear_collect_external_fn,
     ##EXPR.LinearSumExpression               : _collect_linear_sum,
-    ##_ConnectorData          : _collect_linear_connector,
+    ##ConnectorData          : _collect_linear_connector,
     ##ScalarConnector         : _collect_linear_connector,
-    ##param._ParamData        : _collect_linear_const,
+    ##param.ParamData        : _collect_linear_const,
     ##param.ScalarParam       : _collect_linear_const,
     ##param.Param             : _collect_linear_const,
     ##parameter               : _collect_linear_const,
-    _GeneralVarData                             : _linear_collect_var,
+    VarData                             : _linear_collect_var,
     ScalarVar                                   : _linear_collect_var,
     Var                                         : _linear_collect_var,
     variable                                    : _linear_collect_var,
     IVariable                                   : _linear_collect_var,
-    _GeneralExpressionData                      : _linear_collect_identity,
+    ExpressionData                      : _linear_collect_identity,
     ScalarExpression                            : _linear_collect_identity,
     expression                                  : _linear_collect_identity,
     noclone                                     : _linear_collect_identity,
-    _ExpressionData                             : _linear_collect_identity,
+    NamedExpressionData                             : _linear_collect_identity,
     Expression                                  : _linear_collect_identity,
-    _GeneralObjectiveData                       : _linear_collect_identity,
+    ObjectiveData                       : _linear_collect_identity,
     ScalarObjective                             : _linear_collect_identity,
     objective                                   : _linear_collect_identity,
     }
 
 
 def _collect_linear_standard_repn(exp, multiplier, idMap, compute_values, verbose, coefs):
     fn = _linear_repn_collectors.get(exp.__class__, None)
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/helper.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/helper.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/nl_diff.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/nl_diff.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small10_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small10_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small11_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small11_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small12_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small12_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small13_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small13_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small14_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small14_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small15_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small15_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small1_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small1_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small2_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small2_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small3_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small3_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small4_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small4_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small5_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small5_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small6_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small6_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small7_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small7_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small8_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small8_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/small9_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/small9_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_comparison.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_comparison.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_nl.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_nl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/test_ampl_repn.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/test_ampl_repn.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/test_nlv2.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/test_nlv2.py`

 * *Files 12% similar despite different names*

```diff
@@ -38,14 +38,16 @@
     Param,
     Var,
     log,
     ExternalFunction,
     Suffix,
     Constraint,
     Expression,
+    Binary,
+    Integers,
 )
 import pyomo.environ as pyo
 
 _invalid_1j = r'InvalidNumber\((\([-+0-9.e]+\+)?1j\)?\)'
 
 
 class INFO(object):
@@ -1092,15 +1094,14 @@
         m.x[2].domain = pyo.Integers
         m.p = Param(initialize=5, mutable=True)
         m.o1 = Objective([1, 2], rule=lambda m, i: 1)
         m.o2 = Objective(expr=m.x[1] * m.x[2])
         m.c1 = Constraint([1, 2], rule=lambda m, i: sum(m.x.values()) == 1)
         m.c2 = Constraint(expr=m.p * m.x[1] ** 2 + m.x[2] ** 3 <= 100)
 
-        self.maxDiff = None
         OUT = io.StringIO()
         with capture_output() as LOG:
             with report_timing(level=logging.DEBUG):
                 nl_writer.NLWriter().write(m, OUT)
         self.assertEqual(
             """      [+   #.##] Initialized column order
       [+   #.##] Collected suffixes
@@ -1263,15 +1264,15 @@
             *nl_diff(
                 """g3 1 1 0       #problem unknown
  4 1 1 0 0     #vars, constraints, objectives, ranges, eqns
  0 0 0 0 0 0   #nonlinear constrs, objs; ccons: lin, nonlin, nd, nzlb
  0 0   #network constraints: nonlinear, linear
  0 0 0 #nonlinear vars in constraints, objectives, both
  0 0 0 1       #linear network variables; functions; arith, flags
- 0 4 0 0 0     #discrete variables: binary, integer, nonlinear (b,c,o)
+ 4 0 0 0 0     #discrete variables: binary, integer, nonlinear (b,c,o)
  4 4   #nonzeros in Jacobian, obj. gradient
  6 4   #max name lengths: constraints, variables
  0 0 0 0 0     #common exprs: b,c,o,c1,o1
 C0     #weight
 n0
 O0 1   #value
 n0
@@ -1684,14 +1685,211 @@
 0 0
 1 0
 """,
                 OUT.getvalue(),
             )
         )
 
+    def test_presolve_zero_coef(self):
+        m = ConcreteModel()
+        m.x = Var()
+        m.y = Var()
+        m.z = Var()
+        m.obj = Objective(expr=m.x**2 + m.y**2 + m.z**2)
+        m.c1 = Constraint(expr=m.x == m.y + m.z + 1.5)
+        m.c2 = Constraint(expr=m.z == -m.y)
+
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            nlinfo = nl_writer.NLWriter().write(
+                m, OUT, symbolic_solver_labels=True, linear_presolve=True
+            )
+        self.assertEqual(LOG.getvalue(), "")
+
+        self.assertEqual(nlinfo.eliminated_vars[0], (m.x, 1.5))
+        self.assertIs(nlinfo.eliminated_vars[1][0], m.y)
+        self.assertExpressionsEqual(
+            nlinfo.eliminated_vars[1][1], LinearExpression([-1.0 * m.z])
+        )
+
+        self.assertEqual(
+            *nl_diff(
+                """g3 1 1 0	# problem unknown
+ 1 0 1 0 0	#vars, constraints, objectives, ranges, eqns
+ 0 1 0 0 0 0	#nonlinear constrs, objs; ccons: lin, nonlin, nd, nzlb
+ 0 0	#network constraints: nonlinear, linear
+ 0 1 0	#nonlinear vars in constraints, objectives, both
+ 0 0 0 1	#linear network variables; functions; arith, flags
+ 0 0 0 0 0	#discrete variables: binary, integer, nonlinear (b,c,o)
+ 0 1	#nonzeros in Jacobian, obj. gradient
+ 3 1	#max name lengths: constraints, variables
+ 0 0 0 0 0	#common exprs: b,c,o,c1,o1
+O0 0	#obj
+o54	#sumlist
+3	#(n)
+o5	#^
+n1.5
+n2
+o5	#^
+o16	#-
+v0	#z
+n2
+o5	#^
+v0	#z
+n2
+x0	#initial guess
+r	#0 ranges (rhs's)
+b	#1 bounds (on variables)
+3	#z
+k0	#intermediate Jacobian column lengths
+G0 1	#obj
+0 0
+""",
+                OUT.getvalue(),
+            )
+        )
+
+        m.c3 = Constraint(expr=m.x == 2)
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            with self.assertRaisesRegex(
+                nl_writer.InfeasibleConstraintException,
+                r"model contains a trivially infeasible constraint 0.5 == 0.0\*y",
+            ):
+                nlinfo = nl_writer.NLWriter().write(
+                    m, OUT, symbolic_solver_labels=True, linear_presolve=True
+                )
+        self.assertEqual(LOG.getvalue(), "")
+
+        m.c1.set_value(m.x >= m.y + m.z + 1.5)
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            nlinfo = nl_writer.NLWriter().write(
+                m, OUT, symbolic_solver_labels=True, linear_presolve=True
+            )
+        self.assertEqual(LOG.getvalue(), "")
+
+        self.assertIs(nlinfo.eliminated_vars[0][0], m.y)
+        self.assertExpressionsEqual(
+            nlinfo.eliminated_vars[0][1], LinearExpression([-1.0 * m.z])
+        )
+        self.assertEqual(nlinfo.eliminated_vars[1], (m.x, 2))
+
+        self.assertEqual(
+            *nl_diff(
+                """g3 1 1 0	# problem unknown
+ 1 1 1 0 0	#vars, constraints, objectives, ranges, eqns
+ 0 1 0 0 0 0	#nonlinear constrs, objs; ccons: lin, nonlin, nd, nzlb
+ 0 0	#network constraints: nonlinear, linear
+ 0 1 0	#nonlinear vars in constraints, objectives, both
+ 0 0 0 1	#linear network variables; functions; arith, flags
+ 0 0 0 0 0	#discrete variables: binary, integer, nonlinear (b,c,o)
+ 0 1	#nonzeros in Jacobian, obj. gradient
+ 3 1	#max name lengths: constraints, variables
+ 0 0 0 0 0	#common exprs: b,c,o,c1,o1
+C0	#c1
+n0
+O0 0	#obj
+o54	#sumlist
+3	#(n)
+o5	#^
+n2
+n2
+o5	#^
+o16	#-
+v0	#z
+n2
+o5	#^
+v0	#z
+n2
+x0	#initial guess
+r	#1 ranges (rhs's)
+1 0.5	#c1
+b	#1 bounds (on variables)
+3	#z
+k0	#intermediate Jacobian column lengths
+G0 1	#obj
+0 0
+""",
+                OUT.getvalue(),
+            )
+        )
+
+    def test_presolve_independent_subsystem(self):
+        # This is derived from the example in #3192
+        m = ConcreteModel()
+        m.x = Var()
+        m.y = Var()
+        m.z = Var()
+        m.d = Constraint(expr=m.z == m.y)
+        m.c = Constraint(expr=m.y == m.x)
+        m.o = Objective(expr=0)
+
+        ref = """g3 1 1 0       #problem unknown
+ 0 0 1 0 0     #vars, constraints, objectives, ranges, eqns
+ 0 0 0 0 0 0   #nonlinear constrs, objs; ccons: lin, nonlin, nd, nzlb
+ 0 0   #network constraints: nonlinear, linear
+ 0 0 0 #nonlinear vars in constraints, objectives, both
+ 0 0 0 1       #linear network variables; functions; arith, flags
+ 0 0 0 0 0     #discrete variables: binary, integer, nonlinear (b,c,o)
+ 0 0   #nonzeros in Jacobian, obj. gradient
+ 1 0   #max name lengths: constraints, variables
+ 0 0 0 0 0     #common exprs: b,c,o,c1,o1
+O0 0   #o
+n0
+x0     #initial guess
+r      #0 ranges (rhs's)
+b      #0 bounds (on variables)
+k-1    #intermediate Jacobian column lengths
+"""
+
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            nlinfo = nl_writer.NLWriter().write(
+                m, OUT, symbolic_solver_labels=True, linear_presolve=True
+            )
+        self.assertEqual(
+            LOG.getvalue(),
+            "presolve identified an underdetermined independent linear subsystem "
+            "that was removed from the model.  Setting 'z' == 0\n",
+        )
+
+        self.assertEqual(*nl_diff(ref, OUT.getvalue()))
+
+        m.x.lb = 5.0
+
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            nlinfo = nl_writer.NLWriter().write(
+                m, OUT, symbolic_solver_labels=True, linear_presolve=True
+            )
+        self.assertEqual(
+            LOG.getvalue(),
+            "presolve identified an underdetermined independent linear subsystem "
+            "that was removed from the model.  Setting 'z' == 5.0\n",
+        )
+
+        self.assertEqual(*nl_diff(ref, OUT.getvalue()))
+
+        m.x.lb = -5.0
+        m.z.ub = -2.0
+
+        OUT = io.StringIO()
+        with LoggingIntercept() as LOG:
+            nlinfo = nl_writer.NLWriter().write(
+                m, OUT, symbolic_solver_labels=True, linear_presolve=True
+            )
+        self.assertEqual(
+            LOG.getvalue(),
+            "presolve identified an underdetermined independent linear subsystem "
+            "that was removed from the model.  Setting 'z' == -2.0\n",
+        )
+
+        self.assertEqual(*nl_diff(ref, OUT.getvalue()))
+
     def test_scaling(self):
         m = pyo.ConcreteModel()
         m.x = pyo.Var(initialize=0)
         m.y = pyo.Var(initialize=0, bounds=(-2e5, 1e5))
         m.z = pyo.Var(initialize=0, bounds=(1e3, None))
         m.v = pyo.Var(initialize=0, bounds=(1e3, 1e3))
         m.w = pyo.Var(initialize=0, bounds=(None, 1e3))
@@ -1969,7 +2167,144 @@
 0 0
 1 0
 2 0
 """,
                 OUT.getvalue(),
             )
         )
+
+    def test_discrete_var_tabulation(self):
+        # This tests an error reported in #3235
+        #
+        # Among other issues, this verifies that nonlinear discrete
+        # variables are tabulated correctly (header line 7), and that
+        # integer variables with bounds in {0, 1} are mapped to binary
+        # variables.
+        m = ConcreteModel()
+        m.p1 = Var(bounds=(0.85, 1.15))
+        m.p2 = Var(bounds=(0.68, 0.92))
+        m.c1 = Var(bounds=(-0.0, 0.7))
+        m.c2 = Var(bounds=(-0.0, 0.7))
+        m.t1 = Var(within=Binary, bounds=(0, 1))
+        m.t2 = Var(within=Binary, bounds=(0, 1))
+        m.t3 = Var(within=Binary, bounds=(0, 1))
+        m.t4 = Var(within=Binary, bounds=(0, 1))
+        m.t5 = Var(within=Integers, bounds=(0, None))
+        m.t6 = Var(within=Integers, bounds=(0, None))
+        m.x1 = Var(within=Binary)
+        m.x2 = Var(within=Integers, bounds=(0, 1))
+        m.x3 = Var(within=Integers, bounds=(0, None))
+        m.const = Constraint(
+            expr=(
+                (0.7 - (m.c1 * m.t1 + m.c2 * m.t2))
+                <= (m.p1 * m.t1 + m.p2 * m.t2 + m.p1 * m.t4 + m.t6 * m.t5)
+            )
+        )
+        m.OBJ = Objective(
+            expr=(m.p1 * m.t1 + m.p2 * m.t2 + m.p2 * m.t3 + m.x1 + m.x2 + m.x3)
+        )
+
+        OUT = io.StringIO()
+        nl_writer.NLWriter().write(m, OUT, symbolic_solver_labels=True)
+
+        self.assertEqual(
+            *nl_diff(
+                """g3 1 1 0	# problem unknown
+ 13 1 1 0 0    #vars, constraints, objectives, ranges, eqns
+ 1 1 0 0 0 0   #nonlinear constrs, objs; ccons: lin, nonlin, nd, nzlb
+ 0 0   #network constraints: nonlinear, linear
+ 9 10 4        #nonlinear vars in constraints, objectives, both
+ 0 0 0 1       #linear network variables; functions; arith, flags
+ 2 1 2 3 1     #discrete variables: binary, integer, nonlinear (b,c,o)
+ 9 8   #nonzeros in Jacobian, obj. gradient
+ 5 2   #max name lengths: constraints, variables
+ 0 0 0 0 0     #common exprs: b,c,o,c1,o1
+C0     #const
+o0     #+
+o16    #-
+o0     #+
+o2     #*
+v4     #c1
+v2     #t1
+o2     #*
+v5     #c2
+v3     #t2
+o16    #-
+o54    #sumlist
+4      #(n)
+o2     #*
+v0     #p1
+v2     #t1
+o2     #*
+v1     #p2
+v3     #t2
+o2     #*
+v0     #p1
+v6     #t4
+o2     #*
+v7     #t6
+v8     #t5
+O0 0   #OBJ
+o54    #sumlist
+3      #(n)
+o2     #*
+v0     #p1
+v2     #t1
+o2     #*
+v1     #p2
+v3     #t2
+o2     #*
+v1     #p2
+v9     #t3
+x0     #initial guess
+r      #1 ranges (rhs's)
+1 -0.7 #const
+b      #13 bounds (on variables)
+0 0.85 1.15    #p1
+0 0.68 0.92    #p2
+0 0 1  #t1
+0 0 1  #t2
+0 -0.0 0.7     #c1
+0 -0.0 0.7     #c2
+0 0 1  #t4
+2 0    #t6
+2 0    #t5
+0 0 1  #t3
+0 0 1  #x1
+0 0 1  #x2
+2 0    #x3
+k12    #intermediate Jacobian column lengths
+1
+2
+3
+4
+5
+6
+7
+8
+9
+9
+9
+9
+J0 9   #const
+0 0
+1 0
+2 0
+3 0
+4 0
+5 0
+6 0
+7 0
+8 0
+G0 8   #OBJ
+0 0
+1 0
+2 0
+3 0
+9 0
+10 1
+11 1
+12 1
+""",
+                OUT.getvalue(),
+            )
+        )
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/ampl/test_suffixes.py` & `Pyomo-6.7.2/pyomo/repn/tests/ampl/test_suffixes.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/baron/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/cpxlp/__init__.py`

 * *Files 3% similar despite different names*

```diff
@@ -5,9 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# Pyomo BARON plugin tests
+# Pyomo CPXLP plugin tests
 #
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/baron/small14a_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/baron/small14a_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/baron/test_baron.py` & `Pyomo-6.7.2/pyomo/repn/tests/baron/test_baron.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/baron/test_baron_comparison.py` & `Pyomo-6.7.2/pyomo/repn/tests/baron/test_baron_comparison.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/cpxlp/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/mps/__init__.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,9 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# Pyomo CPXLP plugin tests
+# Pyomo MPS plugin tests
 #
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/cpxlp/test_cpxlp.py` & `Pyomo-6.7.2/pyomo/repn/tests/cpxlp/test_cpxlp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/cpxlp/test_lpv2.py` & `Pyomo-6.7.2/pyomo/repn/tests/cpxlp/test_lpv2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/diffutils.py` & `Pyomo-6.7.2/pyomo/repn/tests/diffutils.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/gams/__init__.py` & `Pyomo-6.7.2/pyomo/repn/tests/gams/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/gams/small14a_testCase.py` & `Pyomo-6.7.2/pyomo/repn/tests/gams/small14a_testCase.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/gams/test_gams.py` & `Pyomo-6.7.2/pyomo/repn/tests/gams/test_gams.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/gams/test_gams_comparison.py` & `Pyomo-6.7.2/pyomo/repn/tests/gams/test_gams_comparison.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/lp_diff.py` & `Pyomo-6.7.2/pyomo/repn/tests/lp_diff.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/mps/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/tests/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -5,9 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# Pyomo MPS plugin tests
+# pyomo.solvers tests
 #
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/mps/test_mps.py` & `Pyomo-6.7.2/pyomo/repn/tests/mps/test_mps.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/nl_diff.py` & `Pyomo-6.7.2/pyomo/repn/tests/nl_diff.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/test_linear.py` & `Pyomo-6.7.2/pyomo/repn/tests/test_linear.py`

 * *Files 0% similar despite different names*

```diff
@@ -1432,14 +1432,30 @@
         m = ConcreteModel()
         m.p = Param(mutable=True, initialize=0, domain=Any)
         m.x = Var()
         m.y = Var()
         m.z = Var()
         m.y.fix(1)
 
+        expr = (m.x + 1) / m.p
+        cfg = VisitorConfig()
+        with LoggingIntercept() as LOG:
+            repn = LinearRepnVisitor(*cfg).walk_expression(expr)
+        self.assertEqual(
+            LOG.getvalue(),
+            "Exception encountered evaluating expression 'div(1, 0)'\n"
+            "\tmessage: division by zero\n"
+            "\texpression: (x + 1)/p\n",
+        )
+        self.assertEqual(repn.multiplier, 1)
+        self.assertEqual(str(repn.constant), 'InvalidNumber(nan)')
+        self.assertEqual(len(repn.linear), 1)
+        self.assertEqual(str(repn.linear[id(m.x)]), 'InvalidNumber(nan)')
+        self.assertEqual(repn.nonlinear, None)
+
         expr = m.y + m.x + m.z + ((3 * m.x) / m.p) / m.y
         cfg = VisitorConfig()
         with LoggingIntercept() as LOG:
             repn = LinearRepnVisitor(*cfg).walk_expression(expr)
         self.assertEqual(
             LOG.getvalue(),
             "Exception encountered evaluating expression 'div(3, 0)'\n"
@@ -1585,15 +1601,15 @@
             self, expr.to_expression(visitor), (2 * m.x + 3 * m.y) * 10
         )
         expr.multiplier = 1
 
         expr.constant = 0
         expr.linear[id(m.x)] = 0
         expr.linear[id(m.y)] = 0
-        assertExpressionsEqual(self, expr.to_expression(visitor), LinearExpression())
+        assertExpressionsEqual(self, expr.to_expression(visitor), 0)
 
     @unittest.skipUnless(numpy_available, "Test requires numpy")
     def test_nonnumeric(self):
         m = ConcreteModel()
         m.p = Param(mutable=True, initialize=numpy.array([3]), domain=Any)
         m.e = Expression()
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/test_quadratic.py` & `Pyomo-6.7.2/pyomo/repn/tests/test_quadratic.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/test_standard.py` & `Pyomo-6.7.2/pyomo/repn/tests/test_standard.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/test_standard_form.py` & `Pyomo-6.7.2/pyomo/repn/tests/test_standard_form.py`

 * *Files 10% similar despite different names*

```diff
@@ -38,14 +38,31 @@
         m.d = pyo.Constraint(expr=m.y[1] + 4 * m.y[3] <= 5)
 
         repn = LinearStandardFormCompiler().write(m)
 
         self.assertTrue(np.all(repn.c == np.array([0, 0, 0])))
         self.assertTrue(np.all(repn.A == np.array([[-1, -2, 0], [0, 1, 4]])))
         self.assertTrue(np.all(repn.rhs == np.array([-3, 5])))
+        self.assertEqual(repn.rows, [(m.c, -1), (m.d, 1)])
+        self.assertEqual(repn.columns, [m.x, m.y[1], m.y[3]])
+
+    def test_almost_dense_linear_model(self):
+        m = pyo.ConcreteModel()
+        m.x = pyo.Var()
+        m.y = pyo.Var([1, 2, 3])
+        m.c = pyo.Constraint(expr=m.x + 2 * m.y[1] + 4 * m.y[3] >= 10)
+        m.d = pyo.Constraint(expr=5 * m.x + 6 * m.y[1] + 8 * m.y[3] <= 20)
+
+        repn = LinearStandardFormCompiler().write(m)
+
+        self.assertTrue(np.all(repn.c == np.array([0, 0, 0])))
+        self.assertTrue(np.all(repn.A == np.array([[-1, -2, -4], [5, 6, 8]])))
+        self.assertTrue(np.all(repn.rhs == np.array([-10, 20])))
+        self.assertEqual(repn.rows, [(m.c, -1), (m.d, 1)])
+        self.assertEqual(repn.columns, [m.x, m.y[1], m.y[3]])
 
     def test_linear_model_row_col_order(self):
         m = pyo.ConcreteModel()
         m.x = pyo.Var()
         m.y = pyo.Var([1, 2, 3])
         m.c = pyo.Constraint(expr=m.x + 2 * m.y[1] >= 3)
         m.d = pyo.Constraint(expr=m.y[1] + 4 * m.y[3] <= 5)
@@ -53,14 +70,16 @@
         repn = LinearStandardFormCompiler().write(
             m, column_order=[m.y[3], m.y[2], m.x, m.y[1]], row_order=[m.d, m.c]
         )
 
         self.assertTrue(np.all(repn.c == np.array([0, 0, 0])))
         self.assertTrue(np.all(repn.A == np.array([[4, 0, 1], [0, -1, -2]])))
         self.assertTrue(np.all(repn.rhs == np.array([5, -3])))
+        self.assertEqual(repn.rows, [(m.d, 1), (m.c, -1)])
+        self.assertEqual(repn.columns, [m.y[3], m.x, m.y[1]])
 
     def test_suffix_warning(self):
         m = pyo.ConcreteModel()
         m.x = pyo.Var()
         m.y = pyo.Var([1, 2, 3])
         m.c = pyo.Constraint(expr=m.x + 2 * m.y[1] >= 3)
         m.d = pyo.Constraint(expr=m.y[1] + 4 * m.y[3] <= 5)
@@ -219,14 +238,36 @@
             np.all(
                 repn.c == np.array([[-1, 0, -5, 0, 0, 0, 0], [1, 0, 0, 15, 0, 0, 0]])
             )
         )
         self._verify_solution(soln, repn, True)
 
         repn = LinearStandardFormCompiler().write(
+            m, mixed_form=True, column_order=col_order
+        )
+
+        self.assertEqual(
+            repn.rows, [(m.c, -1), (m.d, 1), (m.e, 1), (m.e, -1), (m.f, 0)]
+        )
+        self.assertEqual(list(map(str, repn.x)), ['x', 'y[0]', 'y[1]', 'y[3]'])
+        self.assertEqual(
+            list(v.bounds for v in repn.x), [(None, None), (0, 10), (-5, 10), (-5, -2)]
+        )
+        ref = np.array(
+            [[1, 0, 2, 0], [0, 0, 1, 4], [0, 1, 6, 0], [0, 1, 6, 0], [1, 1, 0, 0]]
+        )
+        self.assertTrue(np.all(repn.A == ref))
+        self.assertTrue(np.all(repn.b == np.array([3, 5, 6, -3, 8])))
+        self.assertTrue(np.all(repn.c == np.array([[-1, 0, -5, 0], [1, 0, 0, 15]])))
+        # Note that the mixed_form solution is a mix of inequality and
+        # equality constraints, so we cannot (easily) reuse the
+        # _verify_solutions helper (as in the above cases):
+        # self._verify_solution(soln, repn, False)
+
+        repn = LinearStandardFormCompiler().write(
             m, slack_form=True, nonnegative_vars=True, column_order=col_order
         )
 
         self.assertEqual(repn.rows, [(m.c, 1), (m.d, 1), (m.e, 1), (m.f, 1)])
         self.assertEqual(
             list(map(str, repn.x)),
             [
```

### Comparing `Pyomo-6.7.1/pyomo/repn/tests/test_util.py` & `Pyomo-6.7.2/pyomo/repn/tests/test_util.py`

 * *Files 0% similar despite different names*

```diff
@@ -714,24 +714,22 @@
             pass
 
         node = UnknownExpression((6, 7))
         with self.assertRaisesRegex(
             DeveloperError, r".*Unexpected expression node type 'UnknownExpression'"
         ):
             end[node.__class__](None, node, *node.args)
-        self.assertEqual(len(end), 9)
-        self.assertIn(UnknownExpression, end)
+        self.assertEqual(len(end), 8)
 
         node = UnknownExpression((6, 7))
         with self.assertRaisesRegex(
             DeveloperError, r".*Unexpected expression node type 'UnknownExpression'"
         ):
             end[node.__class__, 6, 7](None, node, *node.args)
-        self.assertEqual(len(end), 10)
-        self.assertIn((UnknownExpression, 6, 7), end)
+        self.assertEqual(len(end), 8)
 
     def test_BeforeChildDispatcher_registration(self):
         class BeforeChildDispatcherTester(BeforeChildDispatcher):
             @staticmethod
             def _before_var(visitor, child):
                 return child
```

### Comparing `Pyomo-6.7.1/pyomo/repn/util.py` & `Pyomo-6.7.2/pyomo/repn/util.py`

 * *Files 1% similar despite different names*

```diff
@@ -36,30 +36,30 @@
     Block,
     Constraint,
     Expression,
     Suffix,
     SortComponents,
 )
 from pyomo.core.base.component import ActiveComponent
-from pyomo.core.base.expression import _ExpressionData
+from pyomo.core.base.expression import NamedExpressionData
 from pyomo.core.expr.numvalue import is_fixed, value
 import pyomo.core.expr as EXPR
 import pyomo.core.kernel as kernel
 
 logger = logging.getLogger('pyomo.core')
 
 valid_expr_ctypes_minlp = {Var, Param, Expression, Objective}
 valid_active_ctypes_minlp = {Block, Constraint, Objective, Suffix}
 sum_like_expression_types = {
     EXPR.SumExpression,
     EXPR.LinearExpression,
     EXPR.NPV_SumExpression,
 }
 _named_subexpression_types = (
-    _ExpressionData,
+    NamedExpressionData,
     kernel.expression.expression,
     kernel.objective.objective,
 )
 
 HALT_ON_EVALUATION_ERROR = False
 nan = float('nan')
 int_float = {int, float}
@@ -396,50 +396,59 @@
     __slots__ = ()
 
     def __init__(self, *args, **kwargs):
         super().__init__(None, *args, **kwargs)
 
     def __missing__(self, key):
         if type(key) is tuple:
-            node_class = key[0]
+            # Only lookup/cache argument-specific handlers for unary,
+            # binary and ternary operators
+            if len(key) <= 3:
+                node_class = key[0]
+                node_args = key[1:]
+            else:
+                node_class = key = key[0]
+                if node_class in self:
+                    return self[node_class]
         else:
             node_class = key
         bases = node_class.__mro__
         # Note: if we add an `etype`, then this special-case can be removed
         if (
             issubclass(node_class, _named_subexpression_types)
             or node_class is kernel.expression.noclone
         ):
             bases = [Expression]
         fcn = None
         for base_type in bases:
-            if isinstance(key, tuple):
-                base_key = (base_type,) + key[1:]
-                # Only cache handlers for unary, binary and ternary operators
-                cache = len(key) <= 4
-            else:
-                base_key = base_type
-                cache = True
-            if base_key in self:
-                fcn = self[base_key]
-            elif base_type in self:
+            if key is not node_class:
+                if (base_type,) + node_args in self:
+                    fcn = self[(base_type,) + node_args]
+                    break
+            if base_type in self:
                 fcn = self[base_type]
-            elif any((k[0] if type(k) is tuple else k) is base_type for k in self):
-                raise DeveloperError(
-                    f"Base expression key '{base_key}' not found when inserting "
-                    f"dispatcher for node '{node_class.__name__}' while walking "
-                    "expression tree."
-                )
+                break
         if fcn is None:
-            fcn = self.unexpected_expression_type
-        if cache:
-            self[key] = fcn
+            partial_matches = set(
+                k[0] for k in self if type(k) is tuple and issubclass(node_class, k[0])
+            )
+            for base_type in node_class.__mro__:
+                if node_class is not key:
+                    key = (base_type,) + node_args
+                if base_type in partial_matches:
+                    raise DeveloperError(
+                        f"Base expression key '{key}' not found when inserting "
+                        f"dispatcher for node '{node_class.__name__}' while walking "
+                        "expression tree."
+                    )
+            return self.unexpected_expression_type
+        self[key] = fcn
         return fcn
 
-    def unexpected_expression_type(self, visitor, node, *arg):
+    def unexpected_expression_type(self, visitor, node, *args):
         raise DeveloperError(
             f"Unexpected expression node type '{type(node).__name__}' "
             f"found while walking expression tree in {type(visitor).__name__}."
         )
 
 
 def apply_node_operation(node, args):
@@ -482,15 +491,15 @@
     component types are added to a dictionary of `unrecognized`
     components.
 
     A Component type may not appear in both `valid` and `targets` sets.
 
     Parameters
     ----------
-    model: _BlockData
+    model: BlockData
         The model tree to walk
 
     active: True or None
         If True, only unrecognized active components are returned in the
         `uncategorized` dictionary.  Also, if True, only active Blocks
         are descended into.
 
@@ -503,15 +512,15 @@
 
     targets: Set[type]
         The set of component types to "collect".  Blocks with components
         in the `targets` set will be returned in the `component_map`
 
     Returns
     -------
-    component_map: Dict[type, List[_BlockData]]
+    component_map: Dict[type, List[BlockData]]
         A dict mapping component type to a list of block data
         objects that contain declared component of that type.
 
     unrecognized: Dict[type, List[ComponentData]]
         A dict mapping unrecognized component types to a (non-empty)
         list of component data objects found on the model.
```

### Comparing `Pyomo-6.7.1/pyomo/scripting/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/simplification/plugins.py`

 * *Files 17% similar despite different names*

```diff
@@ -5,9 +5,13 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
-import pyomo.scripting.pyomo_command
-import pyomo.scripting.util
+from pyomo.common.extensions import ExtensionBuilderFactory
+from .build import GiNaCInterfaceBuilder
+
+
+def load():
+    ExtensionBuilderFactory.register('ginac')(GiNaCInterfaceBuilder)
```

### Comparing `Pyomo-6.7.1/pyomo/scripting/commands.py` & `Pyomo-6.7.2/pyomo/scripting/commands.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/convert.py` & `Pyomo-6.7.2/pyomo/scripting/convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/driver_help.py` & `Pyomo-6.7.2/pyomo/scripting/driver_help.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/interface.py` & `Pyomo-6.7.2/pyomo/scripting/interface.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/build_ext.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/build_ext.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/convert.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/download.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/download.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/extras.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/extras.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/plugins/solve.py` & `Pyomo-6.7.2/pyomo/scripting/plugins/solve.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/pyomo_command.py` & `Pyomo-6.7.2/pyomo/scripting/pyomo_command.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/pyomo_main.py` & `Pyomo-6.7.2/pyomo/scripting/pyomo_main.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/pyomo_parser.py` & `Pyomo-6.7.2/pyomo/scripting/pyomo_parser.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/solve_config.py` & `Pyomo-6.7.2/pyomo/scripting/solve_config.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/tests/__init__.py` & `Pyomo-6.7.2/pyomo/scripting/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/tests/test_cmds.py` & `Pyomo-6.7.2/pyomo/scripting/tests/test_cmds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/scripting/util.py` & `Pyomo-6.7.2/pyomo/scripting/util.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/mockmip.py` & `Pyomo-6.7.2/pyomo/solvers/mockmip.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/converter/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/converter/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/converter/ampl.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/converter/ampl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/converter/glpsol.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/converter/glpsol.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/converter/model.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/converter/model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/converter/pico.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/converter/pico.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/ASL.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/ASL.py`

 * *Files 4% similar despite different names*

```diff
@@ -19,14 +19,15 @@
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.opt.base import ProblemFormat, ResultsFormat
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
 from pyomo.opt.solver import SystemCallSolver
 from pyomo.core.kernel.block import IBlock
 from pyomo.solvers.mockmip import MockMIP
+from pyomo.solvers.amplfunc_merge import amplfunc_merge
 from pyomo.core import TransformationFactory
 
 import logging
 
 logger = logging.getLogger('pyomo.solvers')
 
 
@@ -154,19 +155,17 @@
         #
         env = os.environ.copy()
         #
         # Merge the PYOMO_AMPLFUNC (externals defined within
         # Pyomo/Pyomo) with any user-specified external function
         # libraries
         #
-        if 'PYOMO_AMPLFUNC' in env:
-            if 'AMPLFUNC' in env:
-                env['AMPLFUNC'] += "\n" + env['PYOMO_AMPLFUNC']
-            else:
-                env['AMPLFUNC'] = env['PYOMO_AMPLFUNC']
+        amplfunc = amplfunc_merge(env)
+        if amplfunc:
+            env['AMPLFUNC'] = amplfunc
 
         cmd = [executable, problem_files[0], '-AMPL']
         if self._timer:
             cmd.insert(0, self._timer)
         #
         # GAH: I am going to re-add the code by Zev that passed options through
         # to the command line. Setting the environment variable in this way does
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/BARON.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/BARON.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CBCplugin.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CBCplugin.py`

 * *Files 1% similar despite different names*

```diff
@@ -12,28 +12,28 @@
 import os
 import re
 import time
 import logging
 import subprocess
 
 from pyomo.common import Executable
+from pyomo.common.enums import maximize, minimize
 from pyomo.common.errors import ApplicationError
 from pyomo.common.collections import Bunch
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.core.kernel.block import IBlock
 from pyomo.core import Var
 from pyomo.opt.base import ProblemFormat, ResultsFormat, OptSolver
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
 from pyomo.opt.results import (
     SolverResults,
     SolverStatus,
     TerminationCondition,
     SolutionStatus,
-    ProblemSense,
     Solution,
 )
 from pyomo.opt.solver import SystemCallSolver
 from pyomo.solvers.mockmip import MockMIP
 
 logger = logging.getLogger('pyomo.solvers')
 
@@ -439,15 +439,15 @@
         #
         OUTPUT = open(self._log_file)
         output = "".join(OUTPUT.readlines())
         OUTPUT.close()
         #
         # Parse logfile lines
         #
-        results.problem.sense = ProblemSense.minimize
+        results.problem.sense = minimize
         results.problem.name = None
         optim_value = float('inf')
         lower_bound = None
         upper_bound = None
         gap = None
         nodes = None
         # See https://www.coin-or.org/Cbc/cbcuserguide.html#messages
@@ -574,15 +574,15 @@
                     results.problem.number_of_binary_variables = int(tokens[5][1:])
                 elif n_tokens == 5 and tokens[3] == "NAME":
                     results.problem.name = tokens[4]
                 elif (
                     'CoinLpIO::readLp(): Maximization problem reformulated as minimization'
                     in ' '.join(tokens)
                 ):
-                    results.problem.sense = ProblemSense.maximize
+                    results.problem.sense = maximize
                 # https://projects.coin-or.org/Cbc/browser/trunk/Cbc/src/CbcSolver.cpp?rev=2497#L3047
                 elif n_tokens > 3 and tokens[:2] == ('Result', '-'):
                     if tokens[2:4] in [('Run', 'abandoned'), ('User', 'ctrl-c')]:
                         results.solver.termination_condition = (
                             TerminationCondition.userInterrupt
                         )
                     if n_tokens > 4:
@@ -748,17 +748,17 @@
             ):
                 results.solver.termination_message = (
                     "Optimization terminated because the total number of simplex "
                     "iterations performed exceeded the value specified in the "
                     "maxIterations parameter."
                 )
         soln.gap = gap
-        if results.problem.sense == ProblemSense.minimize:
+        if results.problem.sense == minimize:
             upper_bound = optim_value
-        elif results.problem.sense == ProblemSense.maximize:
+        elif results.problem.sense == maximize:
             _ver = self.version()
             if _ver and _ver[:3] < (2, 10, 2):
                 optim_value *= -1
                 upper_bound = None if lower_bound is None else -lower_bound
             else:
                 upper_bound = None if lower_bound is None else lower_bound
             lower_bound = optim_value
@@ -820,15 +820,15 @@
 
         try:
             INPUT = open(self._soln_file, "r")
         except IOError:
             INPUT = []
 
         _ver = self.version()
-        invert_objective_sense = results.problem.sense == ProblemSense.maximize and (
+        invert_objective_sense = results.problem.sense == maximize and (
             _ver and _ver[:3] < (2, 10, 2)
         )
 
         for line in INPUT:
             tokens = tuple(re.split('[ \t]+', line.strip()))
             n_tokens = len(tokens)
             #
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CONOPT.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CONOPT.py`

 * *Files 1% similar despite different names*

```diff
@@ -75,15 +75,15 @@
         Returns a tuple describing the solver executable version.
         """
         solver_exec = self.executable()
         if solver_exec is None:
             return _extract_version('')
         results = subprocess.run(
             [solver_exec],
-            timeout=1,
+            timeout=self._version_timeout,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
         )
         return _extract_version(results.stdout)
 
     def create_command_line(self, executable, problem_files):
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/CPLEX.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/CPLEX.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,26 +13,26 @@
 import os
 import re
 import time
 import logging
 import subprocess
 
 from pyomo.common import Executable
+from pyomo.common.enums import maximize, minimize
 from pyomo.common.errors import ApplicationError
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.common.collections import ComponentMap, Bunch
 from pyomo.opt.base import ProblemFormat, ResultsFormat, OptSolver, BranchDirection
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
 from pyomo.opt.results import (
     SolverResults,
     SolverStatus,
     TerminationCondition,
     SolutionStatus,
-    ProblemSense,
     Solution,
 )
 from pyomo.opt.solver import ILMLicensedSystemCallSolver
 from pyomo.solvers.mockmip import MockMIP
 from pyomo.core.base import Var, Suffix, active_export_suffix_generator
 from pyomo.core.kernel.suffix import export_suffix_generator
 from pyomo.core.kernel.block import IBlock
@@ -400,15 +400,15 @@
         Returns a tuple describing the solver executable version.
         """
         solver_exec = self.executable()
         if solver_exec is None:
             return _extract_version('')
         results = subprocess.run(
             [solver_exec, '-c', 'quit'],
-            timeout=1,
+            timeout=self._version_timeout,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
         )
         return _extract_version(results.stdout)
 
     def create_command_line(self, executable, problem_files):
@@ -543,17 +543,17 @@
                 results.problem.number_of_constraints = int(tokens[3])
             elif len(tokens) >= 3 and tokens[0] == "Nonzeros":
                 if (
                     results.problem.number_of_nonzeros is None
                 ):  # CPLEX 11.2 and subsequent has two Nonzeros sections.
                     results.problem.number_of_nonzeros = int(tokens[2])
             elif len(tokens) >= 5 and tokens[4] == "MINIMIZE":
-                results.problem.sense = ProblemSense.minimize
+                results.problem.sense = minimize
             elif len(tokens) >= 5 and tokens[4] == "MAXIMIZE":
-                results.problem.sense = ProblemSense.maximize
+                results.problem.sense = maximize
             elif (
                 len(tokens) >= 4
                 and tokens[0] == "Solution"
                 and tokens[1] == "time"
                 and tokens[2] == "="
             ):
                 # technically, I'm not sure if this is CPLEX user time or user+system - CPLEX doesn't appear
@@ -855,17 +855,17 @@
                     if tokens[0][0] in ['\\', '*']:
                         continue
                     elif tokens[0] == "NAME":
                         results.problem.name = tokens[1]
                     else:
                         sense = tokens[0].lower()
                         if sense in ['max', 'maximize']:
-                            results.problem.sense = ProblemSense.maximize
+                            results.problem.sense = maximize
                         if sense in ['min', 'minimize']:
-                            results.problem.sense = ProblemSense.minimize
+                            results.problem.sense = minimize
                     break
                 tINPUT.close()
 
             elif (
                 tokens[0].startswith("objectiveValue")
                 and tokens[0] != 'objectiveValues'
             ):
@@ -948,27 +948,27 @@
                 time_limit_exceeded is True
             ):
                 primal_feasible = int(
                     ((" ".join(tokens).split('=')[1]).strip()).lstrip("\"").rstrip("\"")
                 )
                 if primal_feasible == 1:
                     soln.status = SolutionStatus.feasible
-                    if results.problem.sense == ProblemSense.minimize:
+                    if results.problem.sense == minimize:
                         results.problem.upper_bound = soln.objective[
                             '__default_objective__'
                         ]['Value']
                     else:
                         results.problem.lower_bound = soln.objective[
                             '__default_objective__'
                         ]['Value']
                 else:
                     soln.status = SolutionStatus.infeasible
 
         if self._best_bound is not None:
-            if results.problem.sense == ProblemSense.minimize:
+            if results.problem.sense == minimize:
                 results.problem.lower_bound = self._best_bound
             else:
                 results.problem.upper_bound = self._best_bound
         if self._gap is not None:
             soln.gap = self._gap
 
         # For the range constraints, supply only the dual with the largest
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GAMS.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GAMS.py`

 * *Files 2% similar despite different names*

```diff
@@ -32,20 +32,19 @@
 
 from pyomo.opt.results import (
     SolverResults,
     SolverStatus,
     Solution,
     SolutionStatus,
     TerminationCondition,
-    ProblemSense,
 )
 
 from pyomo.common.dependencies import attempt_import
 
-gdxcc, gdxcc_available = attempt_import('gdxcc', defer_check=True)
+gdxcc, gdxcc_available = attempt_import('gdxcc')
 
 logger = logging.getLogger('pyomo.solvers')
 
 
 class _GAMSSolver(object):
     """Aggregate of common methods for GAMS interfaces"""
 
@@ -194,27 +193,27 @@
 
     def _get_version(self):
         """Returns a tuple describing the solver executable version."""
         if not self.available(exception_flag=False):
             return _extract_version('')
         from gams import GamsWorkspace
 
-        ws = GamsWorkspace()
-        version = tuple(int(i) for i in ws._version.split('.')[:4])
+        workspace = GamsWorkspace()
+        version = tuple(int(i) for i in workspace._version.split('.')[:4])
         while len(version) < 4:
             version += (0,)
         return version
 
     def _run_simple_model(self, n):
         tmpdir = mkdtemp()
         try:
             from gams import GamsWorkspace, DebugLevel
 
-            ws = GamsWorkspace(debug=DebugLevel.Off, working_directory=tmpdir)
-            t1 = ws.add_job_from_string(self._simple_model(n))
+            workspace = GamsWorkspace(debug=DebugLevel.Off, working_directory=tmpdir)
+            t1 = workspace.add_job_from_string(self._simple_model(n))
             t1.run()
             return True
         except:
             return False
         finally:
             shutil.rmtree(tmpdir)
 
@@ -326,44 +325,46 @@
         # made, if not keepfiles. That way the user can select a directory
         # they already have, like the current directory, without having to
         # worry about the rest of the contents of that directory being deleted.
         newdir = True
         if tmpdir is not None and os.path.exists(tmpdir):
             newdir = False
 
-        ws = GamsWorkspace(
+        workspace = GamsWorkspace(
             debug=DebugLevel.KeepFiles if keepfiles else DebugLevel.Off,
             working_directory=tmpdir,
         )
 
-        t1 = ws.add_job_from_string(output_file.getvalue())
+        t1 = workspace.add_job_from_string(output_file.getvalue())
 
         try:
             with OutputStream(tee=tee, logfile=logfile) as output_stream:
                 t1.run(output=output_stream)
         except GamsExceptionExecution as e:
             try:
                 if e.rc == 3:
                     # Execution Error
                     check_expr_evaluation(model, symbolMap, 'direct')
             finally:
                 # Always name working directory or delete files,
                 # regardless of any errors.
                 if keepfiles:
-                    print("\nGAMS WORKING DIRECTORY: %s\n" % ws.working_directory)
+                    print(
+                        "\nGAMS WORKING DIRECTORY: %s\n" % workspace.working_directory
+                    )
                 elif tmpdir is not None:
                     # Garbage collect all references to t1.out_db
                     # So that .gdx file can be deleted
                     t1 = rec = rec_lo = rec_hi = None
                     file_removal_gams_direct(tmpdir, newdir)
                 raise
         except:
             # Catch other errors and remove files first
             if keepfiles:
-                print("\nGAMS WORKING DIRECTORY: %s\n" % ws.working_directory)
+                print("\nGAMS WORKING DIRECTORY: %s\n" % workspace.working_directory)
             elif tmpdir is not None:
                 # Garbage collect all references to t1.out_db
                 # So that .gdx file can be deleted
                 t1 = rec = rec_lo = rec_hi = None
                 file_removal_gams_direct(tmpdir, newdir)
             raise
 
@@ -394,15 +395,17 @@
                     comp,
                 ) in pyomo.core.base.suffix.active_import_suffix_generator(model)
             )
         extract_dual = 'dual' in model_suffixes
         extract_rc = 'rc' in model_suffixes
 
         results = SolverResults()
-        results.problem.name = os.path.join(ws.working_directory, t1.name + '.gms')
+        results.problem.name = os.path.join(
+            workspace.working_directory, t1.name + '.gms'
+        )
         results.problem.lower_bound = t1.out_db["OBJEST"].find_record().value
         results.problem.upper_bound = t1.out_db["OBJEST"].find_record().value
         results.problem.number_of_variables = t1.out_db["NUMVAR"].find_record().value
         results.problem.number_of_constraints = t1.out_db["NUMEQU"].find_record().value
         results.problem.number_of_nonzeros = t1.out_db["NUMNZ"].find_record().value
         results.problem.number_of_binary_variables = None
         # Includes binary vars:
@@ -414,19 +417,18 @@
             - t1.out_db["NUMDVAR"].find_record().value
         )
         results.problem.number_of_objectives = 1  # required by GAMS writer
         obj = list(model.component_data_objects(Objective, active=True))
         assert len(obj) == 1, 'Only one objective is allowed.'
         obj = obj[0]
         objctvval = t1.out_db["OBJVAL"].find_record().value
+        results.problem.sense = obj.sense
         if obj.is_minimizing():
-            results.problem.sense = ProblemSense.minimize
             results.problem.upper_bound = objctvval
         else:
-            results.problem.sense = ProblemSense.maximize
             results.problem.lower_bound = objctvval
 
         results.solver.name = "GAMS " + str(self.version())
 
         # Init termination condition to None to give preference to this first
         # block of code, only set certain TC's below if it's still None
         results.solver.termination_condition = None
@@ -583,15 +585,15 @@
                         # Solver didn't provide marginals,
                         # nothing else to do here
                         break
 
         results.solution.insert(soln)
 
         if keepfiles:
-            print("\nGAMS WORKING DIRECTORY: %s\n" % ws.working_directory)
+            print("\nGAMS WORKING DIRECTORY: %s\n" % workspace.working_directory)
         elif tmpdir is not None:
             # Garbage collect all references to t1.out_db
             # So that .gdx file can be deleted
             t1 = rec = rec_lo = rec_hi = None
             file_removal_gams_direct(tmpdir, newdir)
 
         ####################################################################
@@ -976,19 +978,18 @@
             stat_vars["NUMVAR"] - stat_vars["NUMDVAR"]
         )
         results.problem.number_of_objectives = 1  # required by GAMS writer
         obj = list(model.component_data_objects(Objective, active=True))
         assert len(obj) == 1, 'Only one objective is allowed.'
         obj = obj[0]
         objctvval = stat_vars["OBJVAL"]
+        results.problem.sense = obj.sense
         if obj.is_minimizing():
-            results.problem.sense = ProblemSense.minimize
             results.problem.upper_bound = objctvval
         else:
-            results.problem.sense = ProblemSense.maximize
             results.problem.lower_bound = objctvval
 
         results.solver.name = "GAMS " + str(self.version())
 
         # Init termination condition to None to give preference to this first
         # block of code, only set certain TC's below if it's still None
         results.solver.termination_condition = None
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GLPK.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GLPK.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,23 +15,24 @@
 import csv
 import subprocess
 
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.common import Executable
 from pyomo.common.collections import Bunch
+from pyomo.common.enums import maximize, minimize
+from pyomo.common.errors import ApplicationError
 from pyomo.opt import (
     SolverFactory,
     OptSolver,
     ProblemFormat,
     ResultsFormat,
     SolverResults,
     TerminationCondition,
     SolutionStatus,
-    ProblemSense,
 )
 from pyomo.opt.base.solvers import _extract_version
 from pyomo.opt.solver import SystemCallSolver
 from pyomo.solvers.mockmip import MockMIP
 
 logger = logging.getLogger('pyomo.solvers')
 
@@ -133,15 +134,15 @@
         """
         if executable is None:
             executable = self.executable()
         result = subprocess.run(
             [executable, "--version"],
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
-            timeout=1,
+            timeout=self._version_timeout,
             universal_newlines=True,
         )
         return _extract_version(result.stdout)
 
     def create_command_line(self, executable, problem_files):
         #
         # Not the best place to catch this, but we want to make sure
@@ -303,18 +304,16 @@
                 or psense not in ('max', 'min')
                 or prows < 0
                 or pcols < 0
                 or pnonz < 0
             ):
                 raise ValueError
 
-            self.is_integer = 'mip' == ptype and True or False
-            prob.sense = (
-                'min' == psense and ProblemSense.minimize or ProblemSense.maximize
-            )
+            self.is_integer = 'mip' == ptype
+            prob.sense = minimize if 'min' == psense else maximize
             prob.number_of_constraints = prows
             prob.number_of_nonzeros = pnonz
             prob.number_of_variables = pcols
 
             for line in f:
                 glp_line_count += 1
                 tokens = line.split()
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GUROBI.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GUROBI.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,25 +14,25 @@
 import re
 import time
 import logging
 import subprocess
 
 from pyomo.common import Executable
 from pyomo.common.collections import Bunch
+from pyomo.common.enums import maximize, minimize
 from pyomo.common.fileutils import this_file_dir
 from pyomo.common.tee import capture_output
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.opt.base import ProblemFormat, ResultsFormat, OptSolver
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
 from pyomo.opt.results import (
     SolverStatus,
     TerminationCondition,
     SolutionStatus,
-    ProblemSense,
     Solution,
 )
 from pyomo.opt.solver import ILMLicensedSystemCallSolver
 from pyomo.core.kernel.block import IBlock
 from pyomo.core import ConcreteModel, Var, Objective
 
 from .gurobi_direct import gurobipy_available
@@ -468,15 +468,15 @@
                     elif tokens[0] == 'gap':
                         soln.gap = float(tokens[1])
                     elif tokens[0] == 'objective':
                         if tokens[1].strip() != 'None':
                             soln.objective['__default_objective__'] = {
                                 'Value': float(tokens[1])
                             }
-                            if results.problem.sense == ProblemSense.minimize:
+                            if results.problem.sense == minimize:
                                 results.problem.upper_bound = float(tokens[1])
                             else:
                                 results.problem.lower_bound = float(tokens[1])
                     elif tokens[0] == 'constraintdual':
                         name = tokens[1]
                         if name != "c_e_ONE_VAR_CONSTANT":
                             if name.startswith('c_'):
@@ -510,17 +510,17 @@
                         if tokens[1] != "ONE_VAR_CONSTANT":
                             soln_variables[tokens[1]]["Rc"] = float(tokens[2])
                     else:
                         setattr(soln, tokens[0], tokens[1])
                 elif section == 1:
                     if tokens[0] == 'sense':
                         if tokens[1] == 'minimize':
-                            results.problem.sense = ProblemSense.minimize
+                            results.problem.sense = minimize
                         elif tokens[1] == 'maximize':
-                            results.problem.sense = ProblemSense.maximize
+                            results.problem.sense = maximize
                     else:
                         try:
                             val = eval(tokens[1])
                         except:
                             val = tokens[1]
                         setattr(results.problem, tokens[0], val)
                 elif section == 3:
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/GUROBI_RUN.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/GUROBI_RUN.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/IPOPT.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/IPOPT.py`

 * *Files 4% similar despite different names*

```diff
@@ -17,14 +17,16 @@
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.opt.base import ProblemFormat, ResultsFormat
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
 from pyomo.opt.results import SolverStatus, SolverResults, TerminationCondition
 from pyomo.opt.solver import SystemCallSolver
 
+from pyomo.solvers.amplfunc_merge import amplfunc_merge
+
 import logging
 
 logger = logging.getLogger('pyomo.solvers')
 
 
 @SolverFactory.register('ipopt', doc='The Ipopt NLP solver')
 class IPOPT(SystemCallSolver):
@@ -75,15 +77,15 @@
         Returns a tuple describing the solver executable version.
         """
         solver_exec = self.executable()
         if solver_exec is None:
             return _extract_version('')
         results = subprocess.run(
             [solver_exec, "-v"],
-            timeout=1,
+            timeout=self._version_timeout,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
         )
         return _extract_version(results.stdout)
 
     def create_command_line(self, executable, problem_files):
@@ -115,19 +117,17 @@
         #
         env = os.environ.copy()
         #
         # Merge the PYOMO_AMPLFUNC (externals defined within
         # Pyomo/Pyomo) with any user-specified external function
         # libraries
         #
-        if 'PYOMO_AMPLFUNC' in env:
-            if 'AMPLFUNC' in env:
-                env['AMPLFUNC'] += "\n" + env['PYOMO_AMPLFUNC']
-            else:
-                env['AMPLFUNC'] = env['PYOMO_AMPLFUNC']
+        amplfunc = amplfunc_merge(env)
+        if amplfunc:
+            env['AMPLFUNC'] = amplfunc
 
         cmd = [executable, problem_files[0], '-AMPL']
         if self._timer:
             cmd.insert(0, self._timer)
 
         env_opt = []
         of_opt = []
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/SCIPAMPL.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/SCIPAMPL.py`

 * *Files 2% similar despite different names*

```diff
@@ -16,20 +16,15 @@
 
 from pyomo.common import Executable
 from pyomo.common.collections import Bunch
 from pyomo.common.tempfiles import TempfileManager
 
 from pyomo.opt.base import ProblemFormat, ResultsFormat
 from pyomo.opt.base.solvers import _extract_version, SolverFactory
-from pyomo.opt.results import (
-    SolverStatus,
-    TerminationCondition,
-    SolutionStatus,
-    ProblemSense,
-)
+from pyomo.opt.results import SolverStatus, TerminationCondition, SolutionStatus
 from pyomo.opt.solver import SystemCallSolver
 
 import logging
 
 logger = logging.getLogger('pyomo.solvers')
 
 
@@ -99,15 +94,15 @@
         """
         if solver_exec is None:
             solver_exec = self.executable()
             if solver_exec is None:
                 return _extract_version('')
         results = subprocess.run(
             [solver_exec, "--version"],
-            timeout=1,
+            timeout=self._version_timeout,
             stdout=subprocess.PIPE,
             stderr=subprocess.STDOUT,
             universal_newlines=True,
         )
         return _extract_version(results.stdout)
 
     def create_command_line(self, executable, problem_files):
@@ -370,17 +365,19 @@
 
         elif "optimal solution" in results.solver.message:
             results.solver.status = SolverStatus.ok
             results.solver.termination_condition = TerminationCondition.optimal
             if len(results.solution) > 0:
                 results.solution(0).status = SolutionStatus.optimal
             try:
-                if results.problem.sense == ProblemSense.minimize:
+                if results.solver.primal_bound < results.solver.dual_bound:
                     results.problem.lower_bound = results.solver.primal_bound
+                    results.problem.upper_bound = results.solver.dual_bound
                 else:
+                    results.problem.lower_bound = results.solver.dual_bound
                     results.problem.upper_bound = results.solver.primal_bound
             except AttributeError:
                 """
                 This may occur if SCIP solves the problem during presolve. In that case,
                 the log file may not get parsed correctly (self.read_scip_log), and
                 results.solver.primal_bound will not be populated.
                 """
@@ -451,15 +448,15 @@
                 return {}
 
         # get data
 
         solver_status = scip_lines[0][colon_position + 2 : scip_lines[0].index('\n')]
 
         solving_time = float(
-            scip_lines[1][colon_position + 2 : scip_lines[1].index('\n')]
+            scip_lines[1][colon_position + 2 : scip_lines[1].index('\n')].split(' ')[0]
         )
 
         try:
             solving_nodes = int(
                 scip_lines[2][colon_position + 2 : scip_lines[2].index('(')]
             )
         except ValueError:
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/XPRESS.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/XPRESS.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/cplex_direct.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/cplex_direct.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/cplex_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/cplex_persistent.py`

 * *Files 2% similar despite different names*

```diff
@@ -78,15 +78,15 @@
         """Update a single variable in the solver's model.
 
         This will update bounds, fix/unfix the variable as needed, and
         update the variable type.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if var.is_indexed():
         #    for child_var in var.values():
@@ -126,15 +126,15 @@
         model, and put the coefficients on the associated
         constraints in the solver model. If the obj_coef is
         not zero, it will add obj_coef*var to the objective
         of the solver's model.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
         obj_coef: float
         constraints: list of solver constraints
         coefficients: list of coefficients to put on var in the associated constraint
         """
 
         ## set-up add var
         varname = self._symbol_map.getSymbol(var, self._labeler)
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/direct_or_persistent_solver.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/direct_or_persistent_solver.py`

 * *Files 0% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.core.base.PyomoModel import Model
-from pyomo.core.base.block import Block, _BlockData
+from pyomo.core.base.block import Block, BlockData
 from pyomo.core.kernel.block import IBlock
 from pyomo.opt.base.solvers import OptSolver
 from pyomo.core.base import SymbolMap, NumericLabeler, TextLabeler
 import pyomo.common
 from pyomo.common.errors import ApplicationError
 from pyomo.common.collections import ComponentMap, ComponentSet, Bunch
 from pyomo.common.tempfiles import TempfileManager
@@ -173,15 +173,15 @@
 
     def _postsolve(self):
         return OptSolver._postsolve(self)
 
     """ This method should be implemented by subclasses."""
 
     def _set_instance(self, model, kwds={}):
-        if not isinstance(model, (Model, IBlock, Block, _BlockData)):
+        if not isinstance(model, (Model, IBlock, Block, BlockData)):
             msg = (
                 "The problem instance supplied to the {0} plugin "
                 "'_presolve' method must be a Model or a Block".format(type(self))
             )
             raise ValueError(msg)
         self._pyomo_model = model
         self._symbolic_solver_labels = kwds.pop(
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/direct_solver.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/direct_solver.py`

 * *Files 0% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 
 import time
 import logging
 
 from pyomo.solvers.plugins.solvers.direct_or_persistent_solver import (
     DirectOrPersistentSolver,
 )
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.kernel.block import IBlock
 from pyomo.core.base.suffix import active_import_suffix_generator
 from pyomo.core.kernel.suffix import import_suffix_generator
 from pyomo.common.errors import ApplicationError
 from pyomo.common.collections import Bunch
 
 logger = logging.getLogger('pyomo.solvers')
@@ -75,25 +75,25 @@
         self.available(exception_flag=True)
         #
         # If the inputs are models, then validate that they have been
         # constructed! Collect suffix names to try and import from solution.
         #
         _model = None
         for arg in args:
-            if isinstance(arg, (_BlockData, IBlock)):
-                if isinstance(arg, _BlockData):
+            if isinstance(arg, (BlockData, IBlock)):
+                if isinstance(arg, BlockData):
                     if not arg.is_constructed():
                         raise RuntimeError(
                             "Attempting to solve model=%s with unconstructed "
                             "component(s)" % (arg.name,)
                         )
 
                 _model = arg
                 # import suffixes must be on the top-level model
-                if isinstance(arg, _BlockData):
+                if isinstance(arg, BlockData):
                     model_suffixes = list(
                         name for (name, comp) in active_import_suffix_generator(arg)
                     )
                 else:
                     assert isinstance(arg, IBlock)
                     model_suffixes = list(
                         comp.storage_key
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/gurobi_direct.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/gurobi_direct.py`

 * *Files 0% similar despite different names*

```diff
@@ -489,17 +489,16 @@
     def _add_block(self, block):
         DirectOrPersistentSolver._add_block(self, block)
 
     def _add_constraint(self, con):
         if not con.active:
             return None
 
-        if is_fixed(con.body):
-            if self._skip_trivial_constraints:
-                return None
+        if self._skip_trivial_constraints and is_fixed(con.body):
+            return None
 
         conname = self._symbol_map.getSymbol(con, self._labeler)
 
         if con._linear_canonical_form:
             gurobi_expr, referenced_vars = self._get_expr_from_pyomo_repn(
                 con.canonical_form(), self._max_constraint_degree
             )
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/gurobi_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/gurobi_persistent.py`

 * *Files 1% similar despite different names*

```diff
@@ -107,15 +107,15 @@
         """Update a single variable in the solver's model.
 
         This will update bounds, fix/unfix the variable as needed, and
         update the variable type.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if var.is_indexed():
         #    for child_var in var.values():
@@ -153,15 +153,15 @@
 
     def set_linear_constraint_attr(self, con, attr, val):
         """
         Set the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
 
                 CBasis
                 DStart
@@ -188,15 +188,15 @@
 
     def set_var_attr(self, var, attr, val):
         """
         Set the value of an attribute on a gurobi variable.
 
         Parameters
         ----------
-        con: pyomo.core.base.var._GeneralVarData
+        con: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be modified.
         attr: str
             The attribute to be modified. Options are:
 
                 Start
                 VarHintVal
@@ -338,15 +338,15 @@
 
     def get_var_attr(self, var, attr):
         """
         Get the value of an attribute on a gurobi var.
 
         Parameters
         ----------
-        var: pyomo.core.base.var._GeneralVarData
+        var: pyomo.core.base.var.VarData
             The pyomo var for which the corresponding gurobi var attribute
             should be retrieved.
         attr: str
             The attribute to get. Options are:
 
                 LB
                 UB
@@ -380,15 +380,15 @@
 
     def get_linear_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi linear constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. Options are:
 
                 Sense
                 RHS
@@ -409,15 +409,15 @@
 
     def get_sos_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi sos constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.sos._SOSConstraintData
+        con: pyomo.core.base.sos.SOSConstraintData
             The pyomo SOS constraint for which the corresponding gurobi SOS constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. Options are:
 
                 IISSOS
         """
@@ -427,15 +427,15 @@
 
     def get_quadratic_constraint_attr(self, con, attr):
         """
         Get the value of an attribute on a gurobi quadratic constraint.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The pyomo constraint for which the corresponding gurobi constraint attribute
             should be retrieved.
         attr: str
             The attribute to get. Options are:
 
                 QCSense
                 QCRHS
@@ -565,15 +565,15 @@
 
     def cbCut(self, con):
         """
         Add a cut within a callback.
 
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The cut to add
         """
         if not con.active:
             raise ValueError('cbCut expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbCut expected a non-trivial constraint')
@@ -643,15 +643,15 @@
         for i, v in enumerate(vars):
             v.set_value(var_values[i], skip_validation=True)
 
     def cbLazy(self, con):
         """
         Parameters
         ----------
-        con: pyomo.core.base.constraint._GeneralConstraintData
+        con: pyomo.core.base.constraint.ConstraintData
             The lazy constraint to add
         """
         if not con.active:
             raise ValueError('cbLazy expected an active constraint.')
 
         if is_fixed(con.body):
             raise ValueError('cbLazy expected a non-trivial constraint')
@@ -706,15 +706,15 @@
         model, and put the coefficients on the associated
         constraints in the solver model. If the obj_coef is
         not zero, it will add obj_coef*var to the objective
         of the solver's model.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
         obj_coef: float
         constraints: list of solver constraints
         coefficients: list of coefficients to put on var in the associated constraint
         """
 
         ## set-up add var
         varname = self._symbol_map.getSymbol(var, self._labeler)
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/mosek_direct.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/mosek_direct.py`

 * *Files 1% similar despite different names*

```diff
@@ -488,21 +488,18 @@
             sub_names = tuple(
                 self._symbol_map.getSymbol(c, self._labeler) for c in lq_all
             )
             ptre = tuple(itertools.accumulate(list(map(len, l_ids))))
             ptrb = (0,) + ptre[:-1]
             asubs = tuple(itertools.chain.from_iterable(l_ids))
             avals = tuple(itertools.chain.from_iterable(l_coefs))
-            qcsubi = tuple(itertools.chain.from_iterable(q_is))
-            qcsubj = tuple(itertools.chain.from_iterable(q_js))
-            qcval = tuple(itertools.chain.from_iterable(q_vals))
-            qcsubk = tuple(i for i in sub for j in range(len(q_is[i - con_num])))
             self._solver_model.appendcons(num_lq)
             self._solver_model.putarowlist(sub, ptrb, ptre, asubs, avals)
-            self._solver_model.putqcon(qcsubk, qcsubi, qcsubj, qcval)
+            for k, i, j, v in zip(sub, q_is, q_js, q_vals):
+                self._solver_model.putqconk(k, i, j, v)
             self._solver_model.putconboundlist(sub, bound_types, lbs, ubs)
             for i, s_n in enumerate(sub_names):
                 self._solver_model.putconname(sub[i], s_n)
             self._pyomo_con_to_solver_con_map.update(zip(lq_all, sub))
             self._solver_con_to_pyomo_con_map.update(zip(sub, lq_all))
 
             for i, c in enumerate(lq_all):
@@ -554,15 +551,15 @@
         This will keep any existing model components intact.
 
         Use this method when cones are passed as_domain. The add_constraint method
         is compatible with regular cones, not when the as_domain method is used.
 
         Parameters
         ----------
-        block: Block (scalar Block or single _BlockData)
+        block: Block (scalar Block or single BlockData)
         """
         var_seq = tuple(
             block.component_data_objects(
                 ctype=pyomo.core.base.var.Var, descend_into=True, active=True, sort=True
             )
         )
         self._add_vars(var_seq)
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/mosek_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/mosek_persistent.py`

 * *Files 1% similar despite different names*

```diff
@@ -81,36 +81,36 @@
         This will keep any existing model components intact.
 
         NOTE: If this method is used to add cones, then the cones should be
         passed as constraints. Use the add_block method for conic_domains.
 
         Parameters
         ----------
-        con_seq: tuple/list of Constraint (scalar Constraint or single _ConstraintData)
+        con_seq: tuple/list of Constraint (scalar Constraint or single ConstraintData)
         """
         self._add_constraints(con_seq)
 
     def remove_var(self, solver_var):
         """
         Remove a single variable from the model as well as the MOSEK task.
         This will keep any other model components intact.
         Parameters
         ----------
-        solver_var: Var (scalar Var or single _VarData)
+        solver_var: Var (scalar Var or single VarData)
         """
         self.remove_vars(solver_var)
 
     def remove_vars(self, *solver_vars):
         """
         Remove multiple scalar variables from the model as well as the MOSEK task. The
         user can pass an unpacked list of scalar variables.
         This will keep any other model components intact.
         Parameters
         ----------
-        *solver_var: Var (scalar Var or single _VarData)
+        *solver_var: Var (scalar Var or single VarData)
         """
         try:
             var_ids = []
             for v in solver_vars:
                 var_ids.append(self._pyomo_var_to_solver_var_map[v])
                 self._symbol_map.removeSymbol(v)
                 del self._referenced_variables[v]
@@ -133,29 +133,29 @@
         Remove a single constraint from the model as well as the MOSEK task.
 
         This will keep any other model components intact.
 
         To remove a conic-domain, you should use the remove_block method.
         Parameters
         ----------
-        solver_con: Constraint (scalar Constraint or single _ConstraintData)
+        solver_con: Constraint (scalar Constraint or single ConstraintData)
         """
         self.remove_constraints(solver_con)
 
     def remove_constraints(self, *solver_cons):
         """
         Remove multiple constraints from the model as well as the MOSEK task in one
         method call.
 
         This will keep any other model components intact.
         To remove conic-domains, use the remove_block method.
 
         Parameters
         ----------
-        *solver_cons: Constraint (scalar Constraint or single _ConstraintData)
+        *solver_cons: Constraint (scalar Constraint or single ConstraintData)
         """
         lq_cons = tuple(
             itertools.filterfalse(lambda x: isinstance(x, _ConicBase), solver_cons)
         )
         cone_cons = tuple(filter(lambda x: isinstance(x, _ConicBase), solver_cons))
         try:
             lq = []
@@ -201,15 +201,15 @@
 
     def update_vars(self, *solver_vars):
         """
         Update multiple scalar variables in solver model. This method allows fixing/unfixing,
         changing variable types and bounds.
         Parameters
         ----------
-        *solver_var: Constraint (scalar Constraint or single _ConstraintData)
+        *solver_var: Constraint (scalar Constraint or single ConstraintData)
         """
         try:
             var_ids = []
             for v in solver_vars:
                 var_ids.append(self._pyomo_var_to_solver_var_map[v])
             vtypes = tuple(map(self._mosek_vartype_from_var, solver_vars))
             lbs = tuple(
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/persistent_solver.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/persistent_solver.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.solvers.plugins.solvers.direct_or_persistent_solver import (
     DirectOrPersistentSolver,
 )
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.core.kernel.block import IBlock
 from pyomo.core.base.suffix import active_import_suffix_generator
 from pyomo.core.kernel.suffix import import_suffix_generator
 from pyomo.core.expr.numvalue import native_numeric_types, value
 from pyomo.core.expr.visitor import evaluate_expression
 from pyomo.core.base.constraint import Constraint
 from pyomo.core.base.var import Var
@@ -92,15 +92,15 @@
     def add_block(self, block):
         """Add a single Pyomo Block to the solver's model.
 
         This will keep any existing model components intact.
 
         Parameters
         ----------
-        block: Block (scalar Block or single _BlockData)
+        block: Block (scalar Block or single BlockData)
 
         """
         if self._pyomo_model is None:
             raise RuntimeError('You must call set_instance before calling add_block.')
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
@@ -128,15 +128,15 @@
     def add_constraint(self, con):
         """Add a single constraint to the solver's model.
 
         This will keep any existing model components intact.
 
         Parameters
         ----------
-        con: Constraint (scalar Constraint or single _ConstraintData)
+        con: Constraint (scalar Constraint or single ConstraintData)
 
         """
         if self._pyomo_model is None:
             raise RuntimeError(
                 'You must call set_instance before calling add_constraint.'
             )
         # see PR #366 for discussion about handling indexed
@@ -202,17 +202,17 @@
         constraints in the solver model. If the obj_coef is
         not zero, it will add obj_coef*var to the objective
         of both the Pyomo and solver's model.
 
         Parameters
         ----------
         model: pyomo ConcreteModel to which the column will be added
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
         obj_coef: float, pyo.Param
-        constraints: list of scalar Constraints of single _ConstraintDatas
+        constraints: list of scalar Constraints of single ConstraintDatas
         coefficients: list of the coefficient to put on var in the associated constraint
 
         """
         if self._pyomo_model is None:
             raise RuntimeError('You must call set_instance before calling add_column.')
         if id(self._pyomo_model) != id(model):
             raise RuntimeError(
@@ -291,15 +291,15 @@
 
         This will keep any other model components intact.
 
         WARNING: Users must call remove_block BEFORE modifying the block.
 
         Parameters
         ----------
-        block: Block (scalar Block or a single _BlockData)
+        block: Block (scalar Block or a single BlockData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if block.is_indexed():
         #    for sub_block in block.values():
@@ -324,15 +324,15 @@
     def remove_constraint(self, con):
         """Remove a single constraint from the solver's model.
 
         This will keep any other model components intact.
 
         Parameters
         ----------
-        con: Constraint (scalar Constraint or single _ConstraintData)
+        con: Constraint (scalar Constraint or single ConstraintData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if con.is_indexed():
         #    for child_con in con.values():
@@ -376,15 +376,15 @@
     def remove_var(self, var):
         """Remove a single variable from the solver's model.
 
         This will keep any other model components intact.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if var.is_indexed():
         #    for child_var in var.values():
@@ -451,15 +451,15 @@
                     ' to the set_instance method in the persistent solver interface. '
                 )
                 raise ValueError(msg)
 
         self.available(exception_flag=True)
 
         # Collect suffix names to try and import from solution.
-        if isinstance(self._pyomo_model, _BlockData):
+        if isinstance(self._pyomo_model, BlockData):
             model_suffixes = list(
                 name
                 for (name, comp) in active_import_suffix_generator(self._pyomo_model)
             )
 
         else:
             assert isinstance(self._pyomo_model, IBlock)
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/pywrapper.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/pywrapper.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/xpress_direct.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/xpress_direct.py`

 * *Files 1% similar despite different names*

```diff
@@ -663,17 +663,16 @@
     def _add_block(self, block):
         DirectOrPersistentSolver._add_block(self, block)
 
     def _add_constraint(self, con):
         if not con.active:
             return None
 
-        if is_fixed(con.body):
-            if self._skip_trivial_constraints:
-                return None
+        if self._skip_trivial_constraints and is_fixed(con.body):
+            return None
 
         conname = self._symbol_map.getSymbol(con, self._labeler)
 
         if con._linear_canonical_form:
             xpress_expr, referenced_vars = self._get_expr_from_pyomo_repn(
                 con.canonical_form(), self._max_constraint_degree
             )
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/plugins/solvers/xpress_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/plugins/solvers/xpress_persistent.py`

 * *Files 1% similar despite different names*

```diff
@@ -86,15 +86,15 @@
         """Update a single variable in the solver's model.
 
         This will update bounds, fix/unfix the variable as needed, and
         update the variable type.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
 
         """
         # see PR #366 for discussion about handling indexed
         # objects and keeping compatibility with the
         # pyomo.kernel objects
         # if var.is_indexed():
         #    for child_var in var.values():
@@ -120,15 +120,15 @@
         model, and put the coefficients on the associated
         constraints in the solver model. If the obj_coef is
         not zero, it will add obj_coef*var to the objective
         of the solver's model.
 
         Parameters
         ----------
-        var: Var (scalar Var or single _VarData)
+        var: Var (scalar Var or single VarData)
         obj_coef: float
         constraints: list of solver constraints
         coefficients: list of coefficients to put on var in the associated constraint
         """
 
         ## set-up add var
         varname = self._symbol_map.getSymbol(var, self._labeler)
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -5,9 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# pyomo.solvers tests
+# pyomo.solvers mip tests
 #
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,9 +5,9 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# Tests for Pyomo solvers
+# Tests for Pyomo Piecewise component
 #
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_BARON.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_BARON.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CBCplugin.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CBCplugin.py`

 * *Files 1% similar despite different names*

```diff
@@ -25,15 +25,15 @@
     NonNegativeIntegers,
     NonNegativeReals,
     Integers,
     Binary,
     maximize,
     minimize,
 )
-from pyomo.opt import SolverFactory, ProblemSense, TerminationCondition, SolverStatus
+from pyomo.opt import SolverFactory, TerminationCondition, SolverStatus
 from pyomo.solvers.plugins.solvers.CBCplugin import CBCSHELL
 
 cbc_available = SolverFactory('cbc', solver_io='lp').available(exception_flag=False)
 
 data_dir = '{}/data'.format(dirname(abspath(__file__)))
 
 
@@ -58,15 +58,15 @@
         self.model.X = Var(within=Reals)
         self.model.C1 = Constraint(expr=self.model.X <= 1)
         self.model.C2 = Constraint(expr=self.model.X >= 2)
         self.model.Obj = Objective(expr=self.model.X, sense=minimize)
 
         results = self.opt.solve(self.model)
 
-        self.assertEqual(ProblemSense.minimize, results.problem.sense)
+        self.assertEqual(minimize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.infeasible, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was proven to be infeasible.', results.solver.termination_message
         )
         self.assertEqual(SolverStatus.warning, results.solver.status)
@@ -77,15 +77,15 @@
         self.model.X = Var(self.model.Idx, within=Reals)
         self.model.Obj = Objective(
             expr=self.model.X[1] + self.model.X[2], sense=maximize
         )
 
         results = self.opt.solve(self.model)
 
-        self.assertEqual(ProblemSense.maximize, results.problem.sense)
+        self.assertEqual(maximize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.unbounded, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was proven to be unbounded.', results.solver.termination_message
         )
         self.assertEqual(SolverStatus.warning, results.solver.status)
@@ -95,15 +95,15 @@
         self.model.X = Var(within=NonNegativeReals)
         self.model.Obj = Objective(expr=self.model.X, sense=minimize)
 
         results = self.opt.solve(self.model)
 
         self.assertEqual(0.0, results.problem.lower_bound)
         self.assertEqual(0.0, results.problem.upper_bound)
-        self.assertEqual(ProblemSense.minimize, results.problem.sense)
+        self.assertEqual(minimize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.optimal, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was solved to optimality (subject to tolerances), and an optimal solution is available.',
             results.solver.termination_message,
         )
@@ -114,15 +114,15 @@
         self.model.X = Var(within=NonNegativeIntegers)
         self.model.C1 = Constraint(expr=self.model.X <= 1)
         self.model.C2 = Constraint(expr=self.model.X >= 2)
         self.model.Obj = Objective(expr=self.model.X, sense=minimize)
 
         results = self.opt.solve(self.model)
 
-        self.assertEqual(ProblemSense.minimize, results.problem.sense)
+        self.assertEqual(minimize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.infeasible, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was proven to be infeasible.', results.solver.termination_message
         )
         self.assertEqual(SolverStatus.warning, results.solver.status)
@@ -130,15 +130,15 @@
     @unittest.skipIf(not cbc_available, "The 'cbc' solver is not available")
     def test_unbounded_mip(self):
         self.model.X = Var(within=Integers)
         self.model.Obj = Objective(expr=self.model.X, sense=minimize)
 
         results = self.opt.solve(self.model)
 
-        self.assertEqual(ProblemSense.minimize, results.problem.sense)
+        self.assertEqual(minimize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.unbounded, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was proven to be unbounded.', results.solver.termination_message
         )
         self.assertEqual(SolverStatus.warning, results.solver.status)
@@ -155,15 +155,15 @@
 
         results = self.opt.solve(self.model)
 
         self.assertEqual(1.0, results.problem.lower_bound)
         self.assertEqual(1.0, results.problem.upper_bound)
         self.assertEqual(results.problem.number_of_binary_variables, 2)
         self.assertEqual(results.problem.number_of_integer_variables, 4)
-        self.assertEqual(ProblemSense.maximize, results.problem.sense)
+        self.assertEqual(maximize, results.problem.sense)
         self.assertEqual(
             TerminationCondition.optimal, results.solver.termination_condition
         )
         self.assertEqual(
             'Model was solved to optimality (subject to tolerances), and an optimal solution is available.',
             results.solver.termination_message,
         )
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CPLEXDirect.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CPLEXDirect.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_CPLEXPersistent.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_CPLEXPersistent.py`

 * *Files 1% similar despite different names*

```diff
@@ -97,15 +97,15 @@
         m.y = Var()
         # len(coefficients) == len(constraints)
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c], [1, 2])
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c, z], [1])
 
         # add indexed constraint
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.ci], [1])
-        # add something not a _ConstraintData
+        # add something not a ConstraintData
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.x], [1])
 
         # constraint not on solver model
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m2.c], [1])
 
         # inactive constraint
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m.cd], [1])
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_GAMS.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_GAMS.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_MOSEKDirect.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_MOSEKDirect.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_MOSEKPersistent.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_MOSEKPersistent.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_cbc.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_cbc.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_cplex.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_cplex.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi_direct.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi_direct.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_gurobi_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_gurobi_persistent.py`

 * *Files 0% similar despite different names*

```diff
@@ -378,15 +378,15 @@
         m.y = pyo.Var()
         # len(coefficients) == len(constraints)
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c], [1, 2])
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c, z], [1])
 
         # add indexed constraint
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.ci], [1])
-        # add something not a _ConstraintData
+        # add something not a ConstraintData
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.x], [1])
 
         # constraint not on solver model
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m2.c], [1])
 
         # inactive constraint
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m.cd], [1])
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_no_solution_behavior.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_no_solution_behavior.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_pickle.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_pickle.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_writers.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_writers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/checks/test_xpress_persistent.py` & `Pyomo-6.7.2/pyomo/solvers/tests/checks/test_xpress_persistent.py`

 * *Files 0% similar despite different names*

```diff
@@ -258,15 +258,15 @@
         m.y = pe.Var()
         # len(coefficients) == len(constraints)
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c], [1, 2])
         self.assertRaises(RuntimeError, opt.add_column, m, m.y, -2, [m.c, z], [1])
 
         # add indexed constraint
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.ci], [1])
-        # add something not a _ConstraintData
+        # add something not a ConstraintData
         self.assertRaises(AttributeError, opt.add_column, m, m.y, -2, [m.x], [1])
 
         # constraint not on solver model
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m2.c], [1])
 
         # inactive constraint
         self.assertRaises(KeyError, opt.add_column, m, m.y, -2, [m.cd], [1])
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/__init__.py` & `Pyomo-6.7.2/pyomo/version/tests/__init__.py`

 * *Files 14% similar despite different names*

```diff
@@ -5,9 +5,7 @@
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 #
-# pyomo.solvers mip tests
-#
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/model.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/model.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_asl.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_asl.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_convert.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_convert.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_factory.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_factory.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_ipopt.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_ipopt.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_mip.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_mip.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_qp.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_qp.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip.py`

 * *Files 4% similar despite different names*

```diff
@@ -102,11 +102,17 @@
         results.Solution(0).Message = "Scip"
         results.Solver.Message = "Scip"
         results.Solver.Time = 0
         _out = TempfileManager.create_tempfile(".txt")
         results.write(filename=_out, times=False, format='json')
         self.compare_json(_out, join(currdir, "test_scip_solve_from_instance.baseline"))
 
+    def test_scip_solve_from_instance_with_reoptimization(self):
+        # Test scip with re-optimization option enabled
+        # This case changes the Scip output results which may break the results parser
+        self.scip.options['reoptimization/enable'] = True
+        self.test_scip_solve_from_instance()
+
 
 if __name__ == "__main__":
     deleteFiles = False
     unittest.main()
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip_log_data.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip_log_data.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_scip_version.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_scip_version.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/mip/test_solver.py` & `Pyomo-6.7.2/pyomo/solvers/tests/mip/test_solver.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_block.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_block.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_compiled.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_compiled.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_constant_objective1.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_constant_objective1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_constant_objective2.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_constant_objective2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_duals_maximize.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_duals_maximize.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_duals_minimize.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_duals_minimize.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_inactive_index.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_inactive_index.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_infeasible1.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_infeasible1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_infeasible2.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_infeasible2.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_piecewise.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_piecewise.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_trivial_constraints.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_trivial_constraints.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unbounded.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unbounded.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unique_duals.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unique_duals.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/LP_unused_vars.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/LP_unused_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_discrete_var_bounds.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_discrete_var_bounds.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_infeasible1.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_infeasible1.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/SOS1_simple.py`

 * *Files 12% similar despite different names*

```diff
@@ -12,61 +12,77 @@
 import pyomo.kernel as pmo
 from pyomo.core import (
     ConcreteModel,
     Param,
     Var,
     Objective,
     Constraint,
-    Binary,
     NonNegativeReals,
+    SOSConstraint,
+    sum_product,
 )
 from pyomo.solvers.tests.models.base import _BaseTestModel, register_model
 
 
 @register_model
-class MILP_simple(_BaseTestModel):
+class SOS1_simple(_BaseTestModel):
     """
-    A simple mixed-integer linear program
+    A simple linear program
     """
 
-    description = "MILP_simple"
+    description = "SOS1_simple"
     level = ('nightly', 'expensive')
-    capabilities = set(['linear', 'integer'])
+    capabilities = set(['linear', 'integer', 'sos1'])
 
     def __init__(self):
         _BaseTestModel.__init__(self)
         self.add_results(self.description + ".json")
 
     def _generate_model(self):
         self.model = ConcreteModel()
         model = self.model
         model._name = self.description
 
-        model.a = Param(initialize=1.0)
+        model.a = Param(initialize=0.1)
         model.x = Var(within=NonNegativeReals)
-        model.y = Var(within=Binary)
+        model.y = Var([1, 2], within=NonNegativeReals)
 
-        model.obj = Objective(expr=model.x + 3.0 * model.y)
-        model.c1 = Constraint(expr=model.a <= model.y)
-        model.c2 = Constraint(expr=(2.0, model.x / model.a - model.y, 10))
+        model.obj = Objective(expr=model.x + model.y[1] + 2 * model.y[2])
+        model.c1 = Constraint(expr=model.a <= model.y[2])
+        model.c2 = Constraint(expr=(2.0, model.x, 10.0))
+        model.c3 = SOSConstraint(var=model.y, index=[1, 2], sos=1)
+        model.c4 = Constraint(expr=sum_product(model.y) == 1)
+
+        # Make an empty SOSConstraint
+        model.c5 = SOSConstraint(var=model.y, index=[1, 2], sos=1)
+        model.c5.set_items([], [])
+        assert len(list(model.c5.get_items())) == 0
 
     def warmstart_model(self):
         assert self.model is not None
         model = self.model
-        model.x.value = 0.1
-        model.y.value = 0
+        model.x.value = 0
+        model.y[1].value = 1
+        model.y[2].value = None
 
 
 @register_model
-class MILP_simple_kernel(MILP_simple):
+class SOS1_simple_kernel(SOS1_simple):
     def _generate_model(self):
         self.model = pmo.block()
         model = self.model
         model._name = self.description
 
-        model.a = pmo.parameter(value=1.0)
+        model.a = pmo.parameter(value=0.1)
         model.x = pmo.variable(domain=NonNegativeReals)
-        model.y = pmo.variable(domain=Binary)
+        model.y = pmo.variable_dict()
+        model.y[1] = pmo.variable(domain=NonNegativeReals)
+        model.y[2] = pmo.variable(domain=NonNegativeReals)
+
+        model.obj = pmo.objective(model.x + model.y[1] + 2 * model.y[2])
+        model.c1 = pmo.constraint(model.a <= model.y[2])
+        model.c2 = pmo.constraint((2.0, model.x, 10.0))
+        model.c3 = pmo.sos1(model.y.values())
+        model.c4 = pmo.constraint(sum(model.y.values()) == 1)
 
-        model.obj = pmo.objective(model.x + 3.0 * model.y)
-        model.c1 = pmo.constraint(model.a <= model.y)
-        model.c2 = pmo.constraint((2.0, model.x / model.a - model.y, 10))
+        # Make an empty SOS constraint
+        model.c5 = pmo.sos1([])
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_unbounded.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_unbounded.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MILP_unused_vars.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MILP_unused_vars.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MIQCP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MIQCP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/MIQP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/MIQP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/QCP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/QCP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/QP_constant_objective.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/QP_constant_objective.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/QP_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/QP_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/SOS2_simple.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/SOS2_simple.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/__init__.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/models/base.py` & `Pyomo-6.7.2/pyomo/solvers/tests/models/base.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/__init__.py` & `Pyomo-6.7.2/pyomo/util/__init__.py`

 * *Files 13% similar despite different names*

```diff
@@ -4,10 +4,7 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
-#
-# Tests for Pyomo Piecewise component
-#
```

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_examples.py` & `Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_examples.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear.py` & `Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear_kernel.py` & `Pyomo-6.7.2/pyomo/solvers/tests/piecewise_linear/test_piecewise_linear_kernel.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/solvers.py` & `Pyomo-6.7.2/pyomo/solvers/tests/solvers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/tests/testcases.py` & `Pyomo-6.7.2/pyomo/solvers/tests/testcases.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/solvers/wrappers.py` & `Pyomo-6.7.2/pyomo/solvers/wrappers.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/__init__.py` & `Pyomo-6.7.2/pyomo/util/tests/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/blockutil.py` & `Pyomo-6.7.2/pyomo/util/blockutil.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/calc_var_value.py` & `Pyomo-6.7.2/pyomo/util/calc_var_value.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 from pyomo.common.errors import IterationLimitError
 from pyomo.common.numeric_types import native_numeric_types, native_complex_types, value
 from pyomo.core.expr.calculus.derivatives import differentiate
-from pyomo.core.base.constraint import Constraint, _ConstraintData
+from pyomo.core.base.constraint import Constraint
 
 import logging
 
 logger = logging.getLogger(__name__)
 
 _default_differentiation_mode = differentiate.Modes.sympy
 _symbolic_modes = {
@@ -49,17 +49,17 @@
     -----
     This is an unconstrained solver and is NOT guaranteed to respect the
     variable bounds or domain.  The solver may leave the variable value
     in an infeasible state (outside the declared bounds or domain bounds).
 
     Parameters:
     -----------
-    variable: :py:class:`_VarData`
+    variable: :py:class:`VarData`
         The variable to solve for
-    constraint: :py:class:`_ConstraintData` or relational expression or `tuple`
+    constraint: :py:class:`ConstraintData` or relational expression or `tuple`
         The equality constraint to use to solve for the variable value.
         May be a `ConstraintData` object or any valid argument for
         ``Constraint(expr=<>)`` (i.e., a relational expression or 2- or
         3-tuple)
     eps: `float`
         The tolerance to use to determine equality [default=1e-8].
     iterlim: `int`
@@ -77,18 +77,25 @@
 
     Returns:
     --------
     None
 
     """
     # Leverage all the Constraint logic to process the incoming tuple/expression
-    if not isinstance(constraint, _ConstraintData):
+    if not getattr(constraint, 'ctype', None) is Constraint:
         constraint = Constraint(expr=constraint, name=type(constraint).__name__)
         constraint.construct()
 
+    if constraint.is_indexed():
+        raise ValueError(
+            'calculate_variable_from_constraint(): constraint must be a '
+            'scalar constraint or a single ConstraintData.  Received '
+            f'{constraint.__class__.__name__} ("{constraint.name}")'
+        )
+
     body = constraint.body
     lower = constraint.lb
     upper = constraint.ub
 
     if lower != upper:
         raise ValueError(f"Constraint '{constraint}' must be an equality constraint")
```

### Comparing `Pyomo-6.7.1/pyomo/util/check_units.py` & `Pyomo-6.7.2/pyomo/util/check_units.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/components.py` & `Pyomo-6.7.2/pyomo/util/components.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/diagnostics.py` & `Pyomo-6.7.2/pyomo/util/diagnostics.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/infeasible.py` & `Pyomo-6.7.2/pyomo/util/infeasible.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/model_size.py` & `Pyomo-6.7.2/pyomo/util/model_size.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/report_scaling.py` & `Pyomo-6.7.2/pyomo/util/report_scaling.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
 
 import pyomo.environ as pyo
 import math
-from pyomo.core.base.block import _BlockData
+from pyomo.core.base.block import BlockData
 from pyomo.common.collections import ComponentSet
-from pyomo.core.base.var import _GeneralVarData
+from pyomo.core.base.var import Var
 from pyomo.contrib.fbbt.fbbt import compute_bounds_on_expr
 from pyomo.core.expr.calculus.diff_with_pyomo import reverse_sd
 import logging
 
 
 logger = logging.getLogger(__name__)
 
@@ -38,15 +38,15 @@
         s += f'{v_lb:>12.2e}{v_ub:>12.2e}    {str(v)}\n'
 
     s += '\n'
 
     return s
 
 
-def _check_var_bounds(m: _BlockData, too_large: float):
+def _check_var_bounds(m: BlockData, too_large: float):
     vars_without_bounds = ComponentSet()
     vars_with_large_bounds = ComponentSet()
     for v in m.component_data_objects(pyo.Var, descend_into=True):
         if v.is_fixed():
             continue
         if v.lb is None or v.ub is None:
             vars_without_bounds.add(v)
@@ -69,15 +69,15 @@
 
 
 def _check_coefficients(
     comp, expr, too_large, too_small, largs_coef_map, small_coef_map
 ):
     ders = reverse_sd(expr)
     for _v, _der in ders.items():
-        if isinstance(_v, _GeneralVarData):
+        if getattr(_v, 'ctype', None) is Var:
             if _v.is_fixed():
                 continue
             der_lb, der_ub = compute_bounds_on_expr(_der)
             der_lb, der_ub = _bounds_to_float(der_lb, der_ub)
             if der_lb <= -too_large or der_ub >= too_large:
                 if comp not in largs_coef_map:
                     largs_coef_map[comp] = list()
@@ -86,15 +86,15 @@
                 if der_lb != 0 or der_ub != 0:
                     if comp not in small_coef_map:
                         small_coef_map[comp] = list()
                     small_coef_map[comp].append((_v, der_lb, der_ub))
 
 
 def report_scaling(
-    m: _BlockData, too_large: float = 5e4, too_small: float = 1e-6
+    m: BlockData, too_large: float = 5e4, too_small: float = 1e-6
 ) -> bool:
     """
     This function logs potentially poorly scaled parts of the model.
     It requires that all variables be bounded.
 
     It is important to note that this check is neither necessary nor sufficient
     to ensure a well-scaled model. However, it is a useful tool to help identify
@@ -103,15 +103,15 @@
     This function uses symbolic differentiation and interval arithmetic
     to compute bounds on each entry in the jacobian of the constraints.
 
     Note that logging has to be turned on to get the output
 
     Parameters
     ----------
-    m: _BlockData
+    m: BlockData
         The pyomo model or block
     too_large: float
         Values above too_large will generate a log entry
     too_small: float
         Coefficients below too_small will generate a log entry
 
     Returns
```

### Comparing `Pyomo-6.7.1/pyomo/util/slices.py` & `Pyomo-6.7.2/pyomo/util/slices.py`

 * *Files 1% similar despite different names*

```diff
@@ -94,15 +94,15 @@
     -----------
     comp: `pyomo.core.base.component.Component` or
     `pyomo.core.base.component.ComponentData`
         Component whose parent structure to search and replace
     sets: `pyomo.common.collections.ComponentSet`
         Contains the sets to replace with slices
     context: `pyomo.core.base.block.Block` or
-    `pyomo.core.base.block._BlockData`
+    `pyomo.core.base.block.BlockData`
         Block below which to search for sets
 
     Returns:
     --------
     `pyomo.core.base.indexed_component_slice.IndexedComponent_slice`:
         Slice of `comp` with wildcards replacing the indices of `sets`
```

### Comparing `Pyomo-6.7.1/pyomo/util/subsystems.py` & `Pyomo-6.7.2/pyomo/util/subsystems.py`

 * *Files 10% similar despite different names*

```diff
@@ -10,58 +10,84 @@
 #  ___________________________________________________________________________
 
 from pyomo.core.base.block import Block
 from pyomo.core.base.reference import Reference
 from pyomo.core.expr.visitor import identify_variables
 from pyomo.common.collections import ComponentSet, ComponentMap
 from pyomo.common.modeling import unique_component_name
-
+from pyomo.util.vars_from_expressions import get_vars_from_components
 from pyomo.core.base.constraint import Constraint
 from pyomo.core.base.expression import Expression
+from pyomo.core.base.objective import Objective
 from pyomo.core.base.external import ExternalFunction
 from pyomo.core.expr.visitor import StreamBasedExpressionVisitor
 from pyomo.core.expr.numeric_expr import ExternalFunctionExpression
-from pyomo.core.expr.numvalue import native_types
+from pyomo.core.expr.numvalue import native_types, NumericValue
 
 
 class _ExternalFunctionVisitor(StreamBasedExpressionVisitor):
+    def __init__(self, descend_into_named_expressions=True):
+        super().__init__()
+        self._descend_into_named_expressions = descend_into_named_expressions
+        self.named_expressions = []
+
     def initializeWalker(self, expr):
         self._functions = []
         self._seen = set()
         return True, None
 
+    def beforeChild(self, parent, child, index):
+        if child.__class__ in native_types:
+            return False, None
+        elif (
+            not self._descend_into_named_expressions
+            and child.is_named_expression_type()
+        ):
+            self.named_expressions.append(child)
+            return False, None
+        return True, None
+
     def exitNode(self, node, data):
         if type(node) is ExternalFunctionExpression:
             if id(node) not in self._seen:
                 self._seen.add(id(node))
                 self._functions.append(node)
 
     def finalizeResult(self, result):
         return self._functions
 
-    def enterNode(self, node):
-        pass
-
-    def acceptChildResult(self, node, data, child_result, child_idx):
-        pass
-
-    def acceptChildResult(self, node, data, child_result, child_idx):
-        if child_result.__class__ in native_types:
-            return False, None
-        return child_result.is_expression_type(), None
-
 
 def identify_external_functions(expr):
     yield from _ExternalFunctionVisitor().walk_expression(expr)
 
 
 def add_local_external_functions(block):
     ef_exprs = []
-    for comp in block.component_data_objects((Constraint, Expression), active=True):
-        ef_exprs.extend(identify_external_functions(comp.expr))
+    named_expressions = []
+    visitor = _ExternalFunctionVisitor(descend_into_named_expressions=False)
+    for comp in block.component_data_objects(
+        (Constraint, Expression, Objective), active=True
+    ):
+        ef_exprs.extend(visitor.walk_expression(comp.expr))
+    named_expr_set = ComponentSet(visitor.named_expressions)
+    # List of unique named expressions
+    named_expressions = list(named_expr_set)
+    while named_expressions:
+        expr = named_expressions.pop()
+        # Clear named expression cache so we don't re-check named expressions
+        # we've seen before.
+        visitor.named_expressions.clear()
+        ef_exprs.extend(visitor.walk_expression(expr))
+        # Only add to the stack named expressions that we have
+        # not encountered yet.
+        for local_expr in visitor.named_expressions:
+            if local_expr not in named_expr_set:
+                named_expressions.append(local_expr)
+                named_expr_set.add(local_expr)
+
     unique_functions = []
     fcn_set = set()
     for expr in ef_exprs:
         fcn = expr._fcn
         data = (fcn._library, fcn._function)
         if data not in fcn_set:
             fcn_set.add(data)
@@ -102,19 +128,17 @@
     if variables is None:
         variables = []
     block = Block(concrete=True)
     block.vars = Reference(variables)
     block.cons = Reference(constraints)
     var_set = ComponentSet(variables)
     input_vars = []
-    for con in constraints:
-        for var in identify_variables(con.expr, include_fixed=include_fixed):
-            if var not in var_set:
-                input_vars.append(var)
-                var_set.add(var)
+    for var in get_vars_from_components(block, Constraint, include_fixed=include_fixed):
+        if var not in var_set:
+            input_vars.append(var)
     block.input_vars = Reference(input_vars)
     add_local_external_functions(block)
     return block
 
 
 def generate_subsystem_blocks(subsystems, include_fixed=False):
     """Generates blocks that contain subsystems of variables and constraints.
@@ -144,15 +168,22 @@
     """This class is a context manager for cases when we want to
     temporarily fix or deactivate certain variables or constraints
     in order to perform some solve or calculation with the resulting
     subsystem.
 
     """
 
-    def __init__(self, to_fix=None, to_deactivate=None, to_reset=None, to_unfix=None):
+    def __init__(
+        self,
+        to_fix=None,
+        to_deactivate=None,
+        to_reset=None,
+        to_unfix=None,
+        remove_bounds_on_fix=False,
+    ):
         """
         Arguments
         ---------
         to_fix: List
             List of var data objects that should be temporarily fixed.
             These are restored to their original status on exit from
             this object's context manager.
@@ -164,14 +195,16 @@
             List of var data objects that should be reset to their
             original values on exit from this object's context context
             manager.
         to_unfix: List
             List of var data objects to be temporarily unfixed. These are
             restored to their original status on exit from this object's
             context manager.
+        remove_bounds_on_fix: Bool
+            Whether bounds should be removed temporarily for fixed variables
 
         """
         if to_fix is None:
             to_fix = []
         if to_deactivate is None:
             to_deactivate = []
         if to_reset is None:
@@ -190,25 +223,32 @@
         self._cons_to_deactivate = to_deactivate
         self._comps_to_set = to_reset
         self._vars_to_unfix = to_unfix
         self._var_was_fixed = None
         self._con_was_active = None
         self._comp_original_value = None
         self._var_was_unfixed = None
+        self._remove_bounds_on_fix = remove_bounds_on_fix
+        self._fixed_var_bounds = None
 
     def __enter__(self):
         to_fix = self._vars_to_fix
         to_deactivate = self._cons_to_deactivate
         to_set = self._comps_to_set
         to_unfix = self._vars_to_unfix
         self._var_was_fixed = [(var, var.fixed) for var in to_fix + to_unfix]
         self._con_was_active = [(con, con.active) for con in to_deactivate]
         self._comp_original_value = [(comp, comp.value) for comp in to_set]
+        self._fixed_var_bounds = [(var.lb, var.ub) for var in to_fix]
 
         for var in self._vars_to_fix:
+            if self._remove_bounds_on_fix:
+                # TODO: Potentially override var.domain as well?
+                var.setlb(None)
+                var.setub(None)
             var.fix()
 
         for con in self._cons_to_deactivate:
             con.deactivate()
 
         for var in self._vars_to_unfix:
             # As of Pyomo 6.5, attempting to unfix an already unfixed var
@@ -219,14 +259,19 @@
 
     def __exit__(self, ex_type, ex_val, ex_bt):
         for var, was_fixed in self._var_was_fixed:
             if was_fixed:
                 var.fix()
             else:
                 var.unfix()
+        if self._remove_bounds_on_fix:
+            for var, (lb, ub) in zip(self._vars_to_fix, self._fixed_var_bounds):
+                var.setlb(lb)
+                var.setub(ub)
+
         for con, was_active in self._con_was_active:
             if was_active:
                 con.activate()
         for comp, val in self._comp_original_value:
             comp.set_value(val)
```

### Comparing `Pyomo-6.7.1/pyomo/util/tests/__init__.py` & `Pyomo-6.7.2/pyomo/contrib/simplification/__init__.py`

 * *Files 18% similar despite different names*

```diff
@@ -4,7 +4,9 @@
 #  Copyright (c) 2008-2024
 #  National Technology and Engineering Solutions of Sandia, LLC
 #  Under the terms of Contract DE-NA0003525 with National Technology and
 #  Engineering Solutions of Sandia, LLC, the U.S. Government retains certain
 #  rights in this software.
 #  This software is distributed under the 3-clause BSD License.
 #  ___________________________________________________________________________
+
+from .simplify import Simplifier
```

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_blockutil.py` & `Pyomo-6.7.2/pyomo/util/tests/test_blockutil.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_calc_var_value.py` & `Pyomo-6.7.2/pyomo/util/tests/test_calc_var_value.py`

 * *Files 2% similar despite different names*

```diff
@@ -97,14 +97,23 @@
 
         m.lt = Constraint(expr=m.x <= m.y)
         with self.assertRaisesRegex(
             ValueError, "Constraint 'lt' must be an equality constraint"
         ):
             calculate_variable_from_constraint(m.x, m.lt)
 
+        m.indexed = Constraint([1, 2], rule=lambda m, i: m.x <= i)
+        with self.assertRaisesRegex(
+            ValueError,
+            r"calculate_variable_from_constraint\(\): constraint must be a scalar "
+            r"constraint or a single ConstraintData.  Received IndexedConstraint "
+            r'\("indexed"\)',
+        ):
+            calculate_variable_from_constraint(m.x, m.indexed)
+
     def test_linear(self):
         m = ConcreteModel()
         m.x = Var()
         m.c = Constraint(expr=5 * m.x == 10)
 
         for mode in all_diff_modes:
             m.x.set_value(None)
```

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_check_units.py` & `Pyomo-6.7.2/pyomo/util/tests/test_check_units.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_components.py` & `Pyomo-6.7.2/pyomo/util/tests/test_components.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_infeasible.py` & `Pyomo-6.7.2/pyomo/util/tests/test_infeasible.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_model_size.py` & `Pyomo-6.7.2/pyomo/util/tests/test_model_size.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_report_scaling.py` & `Pyomo-6.7.2/pyomo/util/tests/test_report_scaling.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_slices.py` & `Pyomo-6.7.2/pyomo/util/tests/test_slices.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/util/tests/test_subsystems.py` & `Pyomo-6.7.2/pyomo/util/tests/test_subsystems.py`

 * *Files 2% similar despite different names*

```diff
@@ -288,25 +288,37 @@
             self.assertTrue(m.v4.fixed)
 
         self.assertFalse(m.v1.fixed)
         self.assertFalse(m.v2.fixed)
         self.assertFalse(m.v3.fixed)
         self.assertTrue(m.v4.fixed)
 
-    def _make_model_with_external_functions(self):
+    def _make_model_with_external_functions(self, named_expressions=False):
         m = pyo.ConcreteModel()
         gsl = find_GSL()
         m.bessel = pyo.ExternalFunction(library=gsl, function="gsl_sf_bessel_J0")
         m.fermi = pyo.ExternalFunction(library=gsl, function="gsl_sf_fermi_dirac_m1")
         m.v1 = pyo.Var(initialize=1.0)
         m.v2 = pyo.Var(initialize=2.0)
         m.v3 = pyo.Var(initialize=3.0)
+        if named_expressions:
+            m.subexpr = pyo.Expression(pyo.PositiveIntegers)
+            m.subexpr[1] = 2 * m.fermi(m.v1)
+            m.subexpr[2] = m.bessel(m.v1) - m.bessel(m.v2)
+            m.subexpr[3] = m.subexpr[2] + m.v3**2
+            subexpr1 = m.subexpr[1]
+            subexpr2 = m.subexpr[2]
+            subexpr3 = m.subexpr[3]
+        else:
+            subexpr1 = 2 * m.fermi(m.v1)
+            subexpr2 = m.bessel(m.v1) - m.bessel(m.v2)
+            subexpr3 = subexpr2 + m.v3**2
         m.con1 = pyo.Constraint(expr=m.v1 == 0.5)
-        m.con2 = pyo.Constraint(expr=2 * m.fermi(m.v1) + m.v2**2 - m.v3 == 1.0)
-        m.con3 = pyo.Constraint(expr=m.bessel(m.v1) - m.bessel(m.v2) + m.v3**2 == 2.0)
+        m.con2 = pyo.Constraint(expr=subexpr1 + m.v2**2 - m.v3 == 1.0)
+        m.con3 = pyo.Constraint(expr=subexpr3 == 2.0)
         return m
 
     @unittest.skipUnless(find_GSL(), "Could not find the AMPL GSL library")
     def test_identify_external_functions(self):
         m = self._make_model_with_external_functions()
         m._con = pyo.Constraint(expr=2 * m.fermi(m.bessel(m.v1**2) + 0.1) == 1.0)
 
@@ -325,14 +337,23 @@
 
         fcns = list(identify_external_functions(m._con.expr))
         fcn_data = set((fcn._fcn._library, fcn._fcn._function) for fcn in fcns)
         self.assertEqual(len(fcns), 2)
         pred_fcn_data = {(gsl, "gsl_sf_bessel_J0"), (gsl, "gsl_sf_fermi_dirac_m1")}
         self.assertEqual(fcn_data, pred_fcn_data)
 
+    @unittest.skipUnless(find_GSL(), "Could not find the AMPL GSL library")
+    def test_local_external_functions_with_named_expressions(self):
+        m = self._make_model_with_external_functions(named_expressions=True)
+        variables = list(m.component_data_objects(pyo.Var))
+        constraints = list(m.component_data_objects(pyo.Constraint, active=True))
+        b = create_subsystem_block(constraints, variables)
+        self.assertTrue(isinstance(b._gsl_sf_bessel_J0, pyo.ExternalFunction))
+        self.assertTrue(isinstance(b._gsl_sf_fermi_dirac_m1, pyo.ExternalFunction))
+
     def _solve_ef_model_with_ipopt(self):
         m = self._make_model_with_external_functions()
         ipopt = pyo.SolverFactory("ipopt")
         ipopt.solve(m)
         return m
 
     @unittest.skipUnless(find_GSL(), "Could not find the AMPL GSL library")
@@ -344,14 +365,41 @@
         subsystem = ([m.con2, m.con3], [m.v2, m.v3])
 
         m.v1.set_value(0.5)
         block = create_subsystem_block(*subsystem)
         ipopt = pyo.SolverFactory("ipopt")
         with TemporarySubsystemManager(to_fix=list(block.input_vars.values())):
             ipopt.solve(block)
+
+        # Correct values obtained by solving with Ipopt directly
+        # in another script.
+        self.assertEqual(m.v1.value, 0.5)
+        self.assertFalse(m.v1.fixed)
+        self.assertAlmostEqual(m.v2.value, 1.04816, delta=1e-5)
+        self.assertAlmostEqual(m.v3.value, 1.34356, delta=1e-5)
+
+        # Result obtained by solving the full system
+        m_full = self._solve_ef_model_with_ipopt()
+        self.assertAlmostEqual(m.v1.value, m_full.v1.value)
+        self.assertAlmostEqual(m.v2.value, m_full.v2.value)
+        self.assertAlmostEqual(m.v3.value, m_full.v3.value)
+
+    @unittest.skipUnless(find_GSL(), "Could not find the AMPL GSL library")
+    @unittest.skipUnless(
+        pyo.SolverFactory("ipopt").available(), "ipopt is not available"
+    )
+    def test_with_external_function_in_named_expression(self):
+        m = self._make_model_with_external_functions(named_expressions=True)
+        subsystem = ([m.con2, m.con3], [m.v2, m.v3])
+
+        m.v1.set_value(0.5)
+        block = create_subsystem_block(*subsystem)
+        ipopt = pyo.SolverFactory("ipopt")
+        with TemporarySubsystemManager(to_fix=list(block.input_vars.values())):
+            ipopt.solve(block)
 
         # Correct values obtained by solving with Ipopt directly
         # in another script.
         self.assertEqual(m.v1.value, 0.5)
         self.assertFalse(m.v1.fixed)
         self.assertAlmostEqual(m.v2.value, 1.04816, delta=1e-5)
         self.assertAlmostEqual(m.v3.value, 1.34356, delta=1e-5)
```

### Comparing `Pyomo-6.7.1/pyomo/util/vars_from_expressions.py` & `Pyomo-6.7.2/pyomo/util/vars_from_expressions.py`

 * *Files 10% similar despite different names*

```diff
@@ -39,20 +39,23 @@
         active: Whether to find Vars that appear in Constraints accessible
                 via the active tree
         sort: sort method for iterating through Constraint objects
         descend_into: Ctypes to descend into when finding Constraints
         descent_order: Traversal strategy for finding the objects of type ctype
     """
     seen = set()
+    named_expression_cache = {}
     for constraint in block.component_data_objects(
         ctype,
         active=active,
         sort=sort,
         descend_into=descend_into,
         descent_order=descent_order,
     ):
         for var in EXPR.identify_variables(
-            constraint.expr, include_fixed=include_fixed
+            constraint.expr,
+            include_fixed=include_fixed,
+            named_expression_cache=named_expression_cache,
         ):
             if id(var) not in seen:
                 seen.add(id(var))
                 yield var
```

### Comparing `Pyomo-6.7.1/pyomo/version/__init__.py` & `Pyomo-6.7.2/pyomo/version/__init__.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/version/info.py` & `Pyomo-6.7.2/pyomo/version/info.py`

 * *Files 3% similar despite different names*

```diff
@@ -22,15 +22,15 @@
 #
 # The VOTD zipbuilder will automatically change releaselevel to "VOTD
 # {hash}" and set the serial number to YYMMDDhhmm.  The serial number
 # should generally be left at 0, unless a downstream package is tracking
 # main and needs a hard reference to "suitably new" development.
 major = 6
 minor = 7
-micro = 1
+micro = 2
 # releaselevel = 'invalid'
 releaselevel = 'final'
 serial = 0
 
 if releaselevel == 'final':
     pass
 elif '/tags/' in _init_url:  # pragma:nocover
```

### Comparing `Pyomo-6.7.1/pyomo/version/tests/check.py` & `Pyomo-6.7.2/pyomo/version/tests/check.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/pyomo/version/tests/test_version.py` & `Pyomo-6.7.2/pyomo/version/tests/test_version.py`

 * *Files identical despite different names*

### Comparing `Pyomo-6.7.1/setup.cfg` & `Pyomo-6.7.2/setup.cfg`

 * *Files 12% similar despite different names*

```diff
@@ -18,12 +18,13 @@
 	long: marks long performance tests
 	short: marks short performance tests
 	devel: marks developer-created performance tests
 	nl: marks nl tests
 	lp: marks lp tests
 	gams: marks gams tests
 	bar: marks bar tests
+	builders: tests that should be run when testing custom (extension) builders
 
 [egg_info]
 tag_build = 
 tag_date = 0
```

### Comparing `Pyomo-6.7.1/setup.py` & `Pyomo-6.7.2/setup.py`

 * *Files 2% similar despite different names*

```diff
@@ -252,30 +252,30 @@
             'sphinx-copybutton',
             'sphinx_rtd_theme>0.5',
             'sphinxcontrib-jsmath',
             'sphinxcontrib-napoleon',
             'sphinx-toolbox>=2.16.0',
             'sphinx-jinja2-compat>=0.1.1',
             'enum_tools',
-            'numpy',  # Needed by autodoc for pynumero
+            'numpy<2.0.0',  # Needed by autodoc for pynumero
             'scipy',  # Needed by autodoc for pynumero
         ],
         'optional': [
             'dill',  # No direct use, but improves lambda pickle
             'ipython',  # contrib.viewer
             # Note: matplotlib 3.6.1 has bug #24127, which breaks
             # seaborn's histplot (triggering parmest failures)
             'matplotlib!=3.6.1',
             # network, incidence_analysis, community_detection
             # Note: networkx 3.2 is Python>-3.9, but there is a broken
             # 3.2 package on conda-forge that will get implicitly
             # installed on python 3.8
             'networkx<3.2; python_version<"3.9"',
             'networkx; python_version>="3.9"',
-            'numpy',
+            'numpy<2.0.0',
             'openpyxl',  # dataportals
             #'pathos',   # requested for #963, but PR currently closed
             'pint',  # units
             'plotly',  # incidence_analysis
             'python-louvain',  # community_detection
             'pyyaml',  # core
             # qtconsole also requires a supported Qt version (PyQt5 or PySide6).
@@ -302,14 +302,15 @@
     packages=find_packages(exclude=("scripts",)),
     package_data={
         "pyomo.contrib.ampl_function_demo": ["src/*"],
         "pyomo.contrib.appsi.cmodel": ["src/*"],
         "pyomo.contrib.mcpp": ["*.cpp"],
         "pyomo.contrib.pynumero": ['src/*', 'src/tests/*'],
         "pyomo.contrib.viewer": ["*.ui"],
+        "pyomo.contrib.simplification.ginac": ["src/*.cpp", "src/*.hpp"],
     },
     ext_modules=ext_modules,
     entry_points="""
     [console_scripts]
     pyomo = pyomo.scripting.pyomo_main:main_console_script
 
     [pyomo.command]
```


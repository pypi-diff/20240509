# Comparing `tmp/label_convert-0.1.2-py3-none-any.whl.zip` & `tmp/label_convert-0.1.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 27212 bytes, number of entries: 17
--rw-r--r--  2.0 unx       74 b- defN 24-Apr-24 08:40 label_convert/__init__.py
--rw-r--r--  2.0 unx     5391 b- defN 24-Apr-24 08:40 label_convert/coco_to_labelImg.py
--rw-r--r--  2.0 unx     7501 b- defN 24-Apr-24 08:40 label_convert/darknet_to_coco.py
--rw-r--r--  2.0 unx     7182 b- defN 24-Apr-24 08:40 label_convert/labelImg_to_publaynet.py
--rw-r--r--  2.0 unx     5372 b- defN 24-Apr-24 08:40 label_convert/labelImg_to_yolov5.py
--rw-r--r--  2.0 unx     8525 b- defN 24-Apr-24 08:40 label_convert/labelme_to_coco.py
--rw-r--r--  2.0 unx     3739 b- defN 24-Apr-24 08:40 label_convert/vis_coco.py
--rw-r--r--  2.0 unx     8701 b- defN 24-Apr-24 08:40 label_convert/yolov5_to_coco.py
--rw-r--r--  2.0 unx     3062 b- defN 24-Apr-24 08:40 label_convert/yolov5_to_yolov8.py
--rw-r--r--  2.0 unx     8491 b- defN 24-Apr-24 08:40 label_convert/yolov5_yaml_to_coco.py
--rw-r--r--  2.0 unx     4037 b- defN 24-Apr-24 08:40 label_convert/yolov8_to_yolov5.py
--rw-r--r--  2.0 unx    11336 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/LICENSE
--rw-r--r--  2.0 unx     1107 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/WHEEL
--rw-r--r--  2.0 unx      564 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       14 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1497 b- defN 24-Apr-24 08:40 label_convert-0.1.2.dist-info/RECORD
-17 files, 76685 bytes uncompressed, 24722 bytes compressed:  67.8%
+Zip file size: 28437 bytes, number of entries: 17
+-rw-r--r--  2.0 unx       74 b- defN 24-May-09 13:50 label_convert/__init__.py
+-rw-r--r--  2.0 unx     6598 b- defN 24-May-09 13:50 label_convert/coco_to_labelImg.py
+-rw-r--r--  2.0 unx     7501 b- defN 24-May-09 13:50 label_convert/darknet_to_coco.py
+-rw-r--r--  2.0 unx     7182 b- defN 24-May-09 13:50 label_convert/labelImg_to_publaynet.py
+-rw-r--r--  2.0 unx     5372 b- defN 24-May-09 13:50 label_convert/labelImg_to_yolov5.py
+-rw-r--r--  2.0 unx    10741 b- defN 24-May-09 13:50 label_convert/labelme_to_coco.py
+-rw-r--r--  2.0 unx     4521 b- defN 24-May-09 13:50 label_convert/vis_coco.py
+-rw-r--r--  2.0 unx     8701 b- defN 24-May-09 13:50 label_convert/yolov5_to_coco.py
+-rw-r--r--  2.0 unx     3062 b- defN 24-May-09 13:50 label_convert/yolov5_to_yolov8.py
+-rw-r--r--  2.0 unx     8491 b- defN 24-May-09 13:50 label_convert/yolov5_yaml_to_coco.py
+-rw-r--r--  2.0 unx     4037 b- defN 24-May-09 13:50 label_convert/yolov8_to_yolov5.py
+-rw-r--r--  2.0 unx    11336 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1107 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx      564 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       14 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1498 b- defN 24-May-09 13:51 label_convert-0.1.3.dist-info/RECORD
+17 files, 80891 bytes uncompressed, 25947 bytes compressed:  67.9%
```

## zipnote {}

```diff
@@ -27,26 +27,26 @@
 
 Filename: label_convert/yolov5_yaml_to_coco.py
 Comment: 
 
 Filename: label_convert/yolov8_to_yolov5.py
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/LICENSE
+Filename: label_convert-0.1.3.dist-info/LICENSE
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/METADATA
+Filename: label_convert-0.1.3.dist-info/METADATA
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/WHEEL
+Filename: label_convert-0.1.3.dist-info/WHEEL
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/entry_points.txt
+Filename: label_convert-0.1.3.dist-info/entry_points.txt
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/top_level.txt
+Filename: label_convert-0.1.3.dist-info/top_level.txt
 Comment: 
 
-Filename: label_convert-0.1.2.dist-info/RECORD
+Filename: label_convert-0.1.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## label_convert/coco_to_labelImg.py

```diff
@@ -3,14 +3,15 @@
 # @Contact: liekkaskono@163.com
 import argparse
 import json
 import shutil
 from pathlib import Path
 from typing import Any, Dict, List, Tuple, Union
 
+import cv2
 import numpy as np
 from tqdm import tqdm
 
 ValueType = Union[str, Path, None]
 
 
 class COCOTolabelImg:
@@ -61,57 +62,90 @@
 
         data = self.read_json(str(json_path))
         self.gen_classes_txt(save_dir, data.get("categories"))
 
         id_img_dict = {v["id"]: v for v in data.get("images")}
         all_annotaions = data.get("annotations")
         for one_anno in tqdm(all_annotaions):
-            image_info = id_img_dict.get(one_anno["image_id"])
-            img_name = image_info.get("file_name")
-            img_height = image_info.get("height")
-            img_width = image_info.get("width")
-
-            seg_info = one_anno.get("segmentation")
-            if seg_info:
-                bbox = self.get_bbox(seg_info)
+            img_info = id_img_dict.get(one_anno["image_id"])
+            img_name = img_info.get("file_name")
+            img_height = img_info.get("height")
+            img_width = img_info.get("width")
+            category_id = int(one_anno.get("category_id")) - 1
+
+            bbox_info = one_anno.get("bbox", None)
+            seg_info = one_anno.get("segmentation", None)
+
+            if bbox_info:
+                x0, y0, w, h = bbox_info
+                xyxy_bbox = [x0, y0, x0 + w, y0 + h]
+                xywh = self.xyxy_to_xywh(xyxy_bbox, img_width, img_height)
+            elif seg_info:
+                points = np.array(seg_info).reshape(4, 2)
+                bbox = self.get_bbox_from_poly(img_height, img_width, points)
                 xywh = self.xyxy_to_xywh(bbox, img_width, img_height)
-                category_id = int(one_anno.get("category_id")) - 1
-                xywh_str = " ".join([str(v) for v in xywh])
-                label_str = f"{category_id} {xywh_str}"
-
-                # 写入标注的txt文件
-                txt_full_path = save_dir / f"{Path(img_name).stem}.txt"
-                self.write_txt(txt_full_path, label_str, mode="a")
+            else:
+                print("The bbox and segmentation are all None, skip current anno.")
+                continue
+
+            xywh_str = " ".join([str(v) for v in xywh])
+            label_str = f"{category_id} {xywh_str}"
+
+            txt_full_path = save_dir / f"{Path(img_name).stem}.txt"
+            self.write_txt(txt_full_path, label_str, mode="a")
 
-            # 复制图像到转换后目录
             img_full_path = img_dir / img_name
             shutil.copy2(img_full_path, save_dir)
 
     @staticmethod
     def read_json(json_path: Union[Path, str]) -> Dict[str, Any]:
         with open(str(json_path), "r", encoding="utf-8") as f:
             data = json.load(f)
         return data
 
     def gen_classes_txt(self, save_dir: Path, categories_dict: List[Dict[str, str]]):
         class_info = [value["name"] for value in categories_dict]
         self.write_txt(save_dir / "classes.txt", class_info)
 
-    def get_bbox(self, seg_info: List[List[float]]) -> List[float]:
-        seg_info = np.array(seg_info[0]).reshape(4, 2)
-        x0, y0 = np.min(seg_info, axis=0)
-        x1, y1 = np.max(seg_info, axis=0)
-        bbox = [x0, y0, x1, y1]
+    def get_bbox_from_poly(
+        self, img_h: int, img_w: int, points: np.ndarray
+    ) -> List[float]:
+        mask = np.zeros((img_h, img_w), dtype="uint8")
+        img_mask = cv2.fillPoly(mask, np.int32([points]), 255)
+        contours, _ = cv2.findContours(img_mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
+        contour = contours[0]
+        bbox = self.get_mini_boxes(contour)
         return bbox
 
     @staticmethod
-    def write_txt(save_path: str, content: List[str], mode="w") -> None:
-        if not isinstance(save_path, str):
-            save_path = str(save_path)
+    def get_mini_boxes(contour) -> List[int]:
+        bounding_box = cv2.minAreaRect(contour)
+        points = sorted(list(cv2.boxPoints(bounding_box)), key=lambda x: x[0])
+
+        index_1, index_2, index_3, index_4 = 0, 1, 2, 3
+        if points[1][1] > points[0][1]:
+            index_1 = 0
+            index_4 = 1
+        else:
+            index_1 = 1
+            index_4 = 0
+        if points[3][1] > points[2][1]:
+            index_2 = 2
+            index_3 = 3
+        else:
+            index_2 = 3
+            index_3 = 2
+
+        box = [points[index_1], points[index_2], points[index_3], points[index_4]]
+        box = np.round(box).astype(np.int32).tolist()
+        left_top, right_bottom = box[0], box[2]
+        return left_top + right_bottom
 
+    @staticmethod
+    def write_txt(save_path: str, content: List[str], mode="w") -> None:
         if isinstance(content, str):
             content = [content]
 
         with open(save_path, mode, encoding="utf-8") as f:
             for value in content:
                 f.write(f"{value}\n")
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## label_convert/labelme_to_coco.py

```diff
@@ -3,20 +3,23 @@
 # @Contact: liekkaskono@163.com
 import argparse
 import json
 import random
 import shutil
 import time
 from pathlib import Path
-from typing import Union
+from typing import List, Union
 
+import cv2
 import numpy as np
 from tqdm import tqdm
 
 ValueType = Union[str, Path, None]
+RECTANGLE = "rectangle"
+POLYGON = "polygon"
 
 
 class LabelmeToCOCO:
     def __init__(
         self,
         data_dir: ValueType = None,
         save_dir: ValueType = None,
@@ -176,44 +179,65 @@
             new_img_name = f"{img_id:012d}{Path(img_path).suffix}"
             new_img_path = save_dir / new_img_name
             self.cp_file(img_path, new_img_path)
 
             raw_json_path = img_path.with_suffix(".json")
             raw_json_data = self.read_json(raw_json_path)
 
+            img_h = raw_json_data.get("imageHeight")
+            img_w = raw_json_data.get("imageWidth")
             img_info = {
                 "date_captured": str(self.cur_year),
                 "file_name": new_img_name,
                 "id": img_id,
-                "height": raw_json_data.get("imageHeight"),
-                "width": raw_json_data.get("imageWidth"),
+                "height": img_h,
+                "width": img_w,
             }
             anno["images"].append(img_info)
 
             shapes = raw_json_data.get("shapes", [])
             anno_list = []
             for shape in shapes:
+                shape_type = shape.get("shape_type")
+                if shape_type not in [RECTANGLE, POLYGON]:
+                    print(
+                        f"Current shape type is {shape_type}, not between {RECTANGLE} and {POLYGON}, skip"
+                    )
+                    continue
+
                 label_name = shape.get("label")
                 label_id = self.cls_to_idx[label_name]
-
                 points = np.array(shape.get("points"))
-                x0, y0 = np.min(points, axis=0)
-                x1, y1 = np.max(points, axis=0)
-                area = (x1 - x0) * (y1 - y0)
 
-                seg_points = [np.ravel(points, order="C").tolist()]
+                if shape_type == RECTANGLE:
+                    seg_points = [np.ravel(points, order="C").tolist()]
+
+                    x0, y0 = np.min(points, axis=0)
+                    x1, y1 = np.max(points, axis=0)
+                    w, h = x1 - x1, y1 - y0
+                    bbox_points = [x0, y0, w, h]
+                    area = w * h
+
+                elif shape_type == POLYGON:
+                    seg_points = points.tolist()
+                    bbox_points, area = self.cvt_poly_to_rect(img_h, img_w, points)
+                else:
+                    print(f"Current {shape_type} is not supported!")
+                    continue
+
                 one_anno_dict = {
                     "segmentation": seg_points,
                     "area": area,
                     "iscrowd": 0,
                     "image_id": img_id,
-                    "bbox": [x0, y0, x1, y1],
+                    "bbox": bbox_points,
                     "category_id": label_id,
                     "id": self.object_id,
                 }
+
                 anno_list.append(one_anno_dict)
                 self.object_id += 1
             anno["annotations"].extend(anno_list)
         return anno
 
     @staticmethod
     def read_json(json_path: Union[str, Path]):
@@ -237,18 +261,57 @@
 
     def cp_file(self, file_path: Path, dst_dir: Path):
         if not file_path.exists():
             raise FileExistsError(file_path)
 
         shutil.copy2(str(file_path), dst_dir)
 
+    def cvt_poly_to_rect(self, img_h: int, img_w: int, points):
+        mask = np.zeros((img_h, img_w), dtype="uint8")
+        img_mask = cv2.fillPoly(mask, np.int32([points]), 255)
+        contours, _ = cv2.findContours(img_mask, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
+        contour = contours[0]
+        bbox_points = self.get_mini_boxes(contour)
+        area = cv2.contourArea(contour)
+        return bbox_points, area
+
+    @staticmethod
+    def get_mini_boxes(contour) -> List[int]:
+        bounding_box = cv2.minAreaRect(contour)
+        points = sorted(list(cv2.boxPoints(bounding_box)), key=lambda x: x[0])
+
+        index_1, index_2, index_3, index_4 = 0, 1, 2, 3
+        if points[1][1] > points[0][1]:
+            index_1 = 0
+            index_4 = 1
+        else:
+            index_1 = 1
+            index_4 = 0
+        if points[3][1] > points[2][1]:
+            index_2 = 2
+            index_3 = 3
+        else:
+            index_2 = 3
+            index_3 = 2
+
+        box = [points[index_1], points[index_2], points[index_3], points[index_4]]
+        box = np.round(box).astype(np.int32).tolist()
+        left_top, right_bottom = box[0], box[2]
+        box_w = right_bottom[0] - left_top[0]
+        box_h = right_bottom[1] - left_top[1]
+        return left_top + [box_w, box_h]
+
 
 def main():
     parser = argparse.ArgumentParser("Datasets converter from labelme to COCO")
-    parser.add_argument("--data_dir", type=str, default=None)
+    parser.add_argument(
+        "--data_dir",
+        type=str,
+        default="/Users/joshuawang/projects/_self/LabelConvert/data",
+    )
     parser.add_argument("--save_dir", type=str, default=None)
     parser.add_argument("--val_ratio", type=float, default=0.2)
     parser.add_argument("--have_test", action="store_true", default=False)
     parser.add_argument("--test_ratio", type=float, default=0.2)
     args = parser.parse_args()
 
     converter = LabelmeToCOCO(
```

## label_convert/vis_coco.py

```diff
@@ -1,50 +1,45 @@
 # -*- encoding: utf-8 -*-
 # @Author: SWHL
 # @Contact: liekkaskono@163.com
 import argparse
 import json
-import platform
 import random
 from pathlib import Path
+from typing import List, Tuple
 
 import cv2
 import numpy as np
 
 
 class VisCOCO:
     def __init__(
         self,
     ):
         self.font_size = 0.7
 
-    def __call__(self, img_id: int, json_path, img_path):
-        with open(json_path, "r", encoding="utf-8") as annos:
-            anno_dict = json.load(annos)
-
+    def __call__(self, img_id: int, json_path: str, img_path: str):
+        anno_dict = self.read_json(json_path)
         anno_imgs = anno_dict.get("images", None)
         if anno_imgs is None:
             raise ValueError(f"The images of {json_path} cannot be empty.")
 
-        print("The anno_dict num_key is:", len(anno_dict))
-        print("The anno_dict key is:", anno_dict.keys())
-        print("The anno_dict num_images is:", len(anno_imgs))
+        print(f"The anno_dict num_key is: {len(anno_dict)}")
+        print(f"The anno_dict key is: {anno_dict.keys()}")
+        print(f"The anno_dict num_images is: {len(anno_imgs)}")
 
         categories = anno_dict["categories"]
         categories_dict = {c["id"]: c["name"] for c in categories}
 
         class_nums = len(categories_dict.keys())
-        color = [
-            (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))
-            for _ in range(class_nums)
-        ]
+        color = self.get_class_color(class_nums)
 
         img_info = anno_dict["images"][img_id - 1]
-        img_name = img_info.get("file_name")
 
+        img_name = img_info.get("file_name")
         img_full_path = Path(img_path) / img_name
         image = cv2.imread(str(img_full_path))
 
         annotations = anno_dict["annotations"]
         num_bbox = 0
         img_id = img_info.get("id")
         for anno in annotations:
@@ -53,58 +48,91 @@
 
             num_bbox += 1
 
             class_id = anno["category_id"]
             class_name = categories_dict[class_id]
             class_color = color[class_id - 1]
 
-            # plot sgmentations
             segs = anno.get("segmentation", None)
             if segs is not None:
-                segs = np.array(segs).reshape(-1, 2)
-                cv2.polylines(image, np.int32([segs]), 2, class_color)
+                self.plot_segmentations(image, segs, class_color)
+                self.plot_text(image, segs[0][:2], class_color, class_name)
+
+            bbox = anno.get("bbox", None)
+            if bbox is None:
+                continue
+
+            self.plot_rectangle(image, bbox, class_color)
+            self.plot_text(image, bbox, class_color, class_name)
+
+        print(f"The unm_bbox of the display image is: {num_bbox}")
+        save_path = f"vis_{Path(img_name).stem}.jpg"
+        cv2.imwrite(save_path, image)
+        print(f"The {save_path} has been saved the current director.")
+
+    @staticmethod
+    def read_json(json_path):
+        with open(json_path, "r", encoding="utf-8") as f:
+            data = json.load(f)
+        return data
+
+    @staticmethod
+    def get_class_color(class_nums: int) -> List[Tuple[int]]:
+        def random_color():
+            return random.randint(0, 255)
 
-            # plot rectangle
-            x, y, w, h = [round(v) for v in anno["bbox"]]
-            cv2.rectangle(
-                image, (int(x), int(y)), (int(x + w), int(y + h)), class_color, 2
-            )
-
-            txt_size = cv2.getTextSize(
-                class_name, cv2.FONT_HERSHEY_SIMPLEX, self.font_size, 1
-            )[0]
-            cv2.rectangle(
-                image,
-                (x, y + 1),
-                (x + txt_size[0] + 5, y - int(1.5 * txt_size[1])),
-                class_color,
-                -1,
-            )
-            cv2.putText(
-                image,
-                class_name,
-                (x + 5, y - 5),
-                cv2.FONT_HERSHEY_SIMPLEX,
-                self.font_size,
-                (255, 255, 255),
-                1,
-            )
-
-        print("The unm_bbox of the display image is:", num_bbox)
-
-        cur_os = platform.system()
-        if cur_os == "Windows":
-            cv2.namedWindow(img_name, 0)
-            cv2.resizeWindow(img_name, 1000, 1000)
-            cv2.imshow(img_name, image)
-            cv2.waitKey(0)
-        else:
-            save_path = f"vis_{Path(img_name).stem}.jpg"
-            cv2.imwrite(save_path, image)
-            print(f"The {save_path} has been saved the current director.")
+        color = [
+            (random_color(), random_color(), random_color()) for _ in range(class_nums)
+        ]
+        return color
+
+    @staticmethod
+    def plot_segmentations(
+        image: np.ndarray, segs: List[List[float]], class_color: Tuple[int]
+    ):
+        segs = np.array(segs).reshape(-1, 2)
+        cv2.polylines(image, np.int32([segs]), 2, class_color)
+
+    @staticmethod
+    def plot_rectangle(
+        image: np.ndarray,
+        bbox: List[float],
+        class_color: Tuple[int],
+        thickness: int = 1,
+    ):
+        x, y, w, h = [round(v) for v in bbox]
+        start_point = (int(x), int(y))
+        end_point = (int(x + w), int(y + h))
+        cv2.rectangle(image, start_point, end_point, class_color, thickness)
+
+    def plot_text(
+        self,
+        image: np.ndarray,
+        bbox: Tuple[float],
+        class_color: str,
+        class_name: str,
+    ):
+        txt_size = cv2.getTextSize(
+            class_name, cv2.FONT_HERSHEY_SIMPLEX, self.font_size, 1
+        )[0]
+
+        x, y = [round(v) for v in bbox[:2]]
+        start_point = (x, y + 1)
+        end_point = (x + txt_size[0] + 5, y - int(1.5 * txt_size[1]))
+        cv2.rectangle(image, start_point, end_point, class_color, -1)
+
+        cv2.putText(
+            image,
+            class_name,
+            (x + 5, y - 5),
+            cv2.FONT_HERSHEY_SIMPLEX,
+            self.font_size,
+            (255, 255, 255),
+            1,
+        )
 
 
 def main():
     parser = argparse.ArgumentParser()
     parser.add_argument("--img_id", type=int, default=1, help="visual which one")
     parser.add_argument(
         "--json_path",
```

## Comparing `label_convert-0.1.2.dist-info/LICENSE` & `label_convert-0.1.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `label_convert-0.1.2.dist-info/METADATA` & `label_convert-0.1.3.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: label-convert
-Version: 0.1.2
+Version: 0.1.3
 Summary: A tool for object detection and image segmentation dataset format conversion. Supports conversion between labelme tool annotated data, labelImg tool annotated data, YOLO, PubLayNet and COCO data set formats.
 Home-page: https://github.com/RapidAI/LabelConvert
 Author: SWHL
 Author-email: liekkaskono@163.com
 License: Apache-2.0
 Project-URL: Documentation, https://rapidai.github.io/LabelConvert/docs
 Keywords: convert,coco,labelme,labelImg,yolov5,yolox,yolov6,yolov8
```

## Comparing `label_convert-0.1.2.dist-info/entry_points.txt` & `label_convert-0.1.3.dist-info/entry_points.txt`

 * *Files identical despite different names*

## Comparing `label_convert-0.1.2.dist-info/RECORD` & `label_convert-0.1.3.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,17 +1,17 @@
 label_convert/__init__.py,sha256=m-UGKHJ-31qL7pBis4nfoFz5fzb-dXsiTLNqY-xpSoA,74
-label_convert/coco_to_labelImg.py,sha256=KtBLHxBmdgA4z-MYxAWgjFNlQEh9c8kSb0wvY_-pIK8,5391
+label_convert/coco_to_labelImg.py,sha256=3NQm5fIbHNgmKI4lirOBIk31rtSG4gdvNUYrq1Zyhr0,6598
 label_convert/darknet_to_coco.py,sha256=espSEsTQKMx5LS1rdDxGT06jZ19mEVfhaftBtbm_Ibg,7501
 label_convert/labelImg_to_publaynet.py,sha256=BiKPrnzoRw2JTv878aj-oXBLaKVe0mfnk5z-fOgRo1o,7182
 label_convert/labelImg_to_yolov5.py,sha256=TRFbg-9YWCRJzau6fyN50g6-_LbqSIg8SmeXtBwE6Nc,5372
-label_convert/labelme_to_coco.py,sha256=5bLfA31pKvhzeWdwLccdOXU6Eq1HDWTNZvdxUlgV7qs,8525
-label_convert/vis_coco.py,sha256=fqBnN6dodXIny5trzTW5Y4ANfasQo8Vd8Eg7py-DlF0,3739
+label_convert/labelme_to_coco.py,sha256=fKfi3Zz2RB9Adg2RzyEx0BfInc-JaTep-AADJqr9ezA,10741
+label_convert/vis_coco.py,sha256=5UtPUXR03e4oc4nMHzipyeaw366LeekdD9muW-tmxh4,4521
 label_convert/yolov5_to_coco.py,sha256=c6klH5AEsJ9BxYQPZk84uNMbn6CdMKQt7dyIsHjQGNM,8701
 label_convert/yolov5_to_yolov8.py,sha256=kizDa1dqGqkmLiGeRPh9gvq_nwp3OM0wzk558ixWWS0,3062
 label_convert/yolov5_yaml_to_coco.py,sha256=jFJ4I1qb7BOKQVMTj7E4-C1R29Nt1Az4wYQufkztfDU,8491
 label_convert/yolov8_to_yolov5.py,sha256=icECDrO84Z952yPH6bE2ZCHxfTrTYW1dN4HVbepNmAg,4037
-label_convert-0.1.2.dist-info/LICENSE,sha256=it8xkwp-gjqyrpU_P9H7V6a4v_Ws0nkOQWifs03Gmz4,11336
-label_convert-0.1.2.dist-info/METADATA,sha256=wGcpIIisc69GYrTIgGJ3TV7u3dOJk59SCvcohWHKouU,1107
-label_convert-0.1.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-label_convert-0.1.2.dist-info/entry_points.txt,sha256=Qf3ErvNvgYxLMwpj6H7uidiwE0maV2rG-mgiAgJ57PE,564
-label_convert-0.1.2.dist-info/top_level.txt,sha256=19hCY1mpryjfbkF4MbzbCTj3Mzsdh4pt3rkx1yYbspo,14
-label_convert-0.1.2.dist-info/RECORD,,
+label_convert-0.1.3.dist-info/LICENSE,sha256=it8xkwp-gjqyrpU_P9H7V6a4v_Ws0nkOQWifs03Gmz4,11336
+label_convert-0.1.3.dist-info/METADATA,sha256=7Zor4RIAUfv_IuIx1ffwhax15uNklC4XJnDJkt80ANU,1107
+label_convert-0.1.3.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+label_convert-0.1.3.dist-info/entry_points.txt,sha256=Qf3ErvNvgYxLMwpj6H7uidiwE0maV2rG-mgiAgJ57PE,564
+label_convert-0.1.3.dist-info/top_level.txt,sha256=19hCY1mpryjfbkF4MbzbCTj3Mzsdh4pt3rkx1yYbspo,14
+label_convert-0.1.3.dist-info/RECORD,,
```


# Comparing `tmp/snuba_sdk-2.0.8-py2.py3-none-any.whl.zip` & `tmp/snuba_sdk-2.0.9-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,33 +1,33 @@
-Zip file size: 41314 bytes, number of entries: 31
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-09 17:09 examples/__init__.py
--rw-r--r--  2.0 unx     1206 b- defN 23-Nov-09 17:09 snuba_sdk/__init__.py
--rw-r--r--  2.0 unx     1552 b- defN 23-Nov-09 17:09 snuba_sdk/aliased_expression.py
--rw-r--r--  2.0 unx     2645 b- defN 23-Nov-09 17:09 snuba_sdk/column.py
--rw-r--r--  2.0 unx     4464 b- defN 23-Nov-09 17:09 snuba_sdk/conditions.py
--rw-r--r--  2.0 unx     2269 b- defN 23-Nov-09 17:09 snuba_sdk/entity.py
--rw-r--r--  2.0 unx     3086 b- defN 23-Nov-09 17:09 snuba_sdk/expressions.py
--rw-r--r--  2.0 unx     2894 b- defN 23-Nov-09 17:09 snuba_sdk/formula.py
--rw-r--r--  2.0 unx     5080 b- defN 23-Nov-09 17:09 snuba_sdk/function.py
--rw-r--r--  2.0 unx    11219 b- defN 23-Nov-09 17:09 snuba_sdk/legacy.py
--rw-r--r--  2.0 unx     3271 b- defN 23-Nov-09 17:09 snuba_sdk/metrics_query.py
--rw-r--r--  2.0 unx    10077 b- defN 23-Nov-09 17:09 snuba_sdk/metrics_query_visitors.py
--rw-r--r--  2.0 unx     7595 b- defN 23-Nov-09 17:09 snuba_sdk/metrics_visitors.py
--rw-r--r--  2.0 unx     1901 b- defN 23-Nov-09 17:09 snuba_sdk/orderby.py
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-09 17:09 snuba_sdk/py.typed
--rw-r--r--  2.0 unx     6630 b- defN 23-Nov-09 17:09 snuba_sdk/query.py
--rw-r--r--  2.0 unx     7931 b- defN 23-Nov-09 17:09 snuba_sdk/query_validation.py
--rw-r--r--  2.0 unx    12231 b- defN 23-Nov-09 17:09 snuba_sdk/query_visitors.py
--rw-r--r--  2.0 unx     3401 b- defN 23-Nov-09 17:09 snuba_sdk/relationships.py
--rw-r--r--  2.0 unx     2862 b- defN 23-Nov-09 17:09 snuba_sdk/request.py
--rw-r--r--  2.0 unx     1487 b- defN 23-Nov-09 17:09 snuba_sdk/schema.py
--rw-r--r--  2.0 unx     2668 b- defN 23-Nov-09 17:09 snuba_sdk/snuba.py
--rw-r--r--  2.0 unx    10401 b- defN 23-Nov-09 17:09 snuba_sdk/timeseries.py
--rw-r--r--  2.0 unx    13451 b- defN 23-Nov-09 17:09 snuba_sdk/visitors.py
--rw-r--r--  2.0 unx        0 b- defN 23-Nov-09 17:09 snuba_sdk/dsl/__init__.py
--rw-r--r--  2.0 unx    11176 b- defN 23-Nov-09 17:09 snuba_sdk/dsl/dsl.py
--rw-r--r--  2.0 unx     1095 b- defN 23-Nov-09 17:09 snuba_sdk-2.0.8.dist-info/LICENSE
--rw-r--r--  2.0 unx     4708 b- defN 23-Nov-09 17:09 snuba_sdk-2.0.8.dist-info/METADATA
--rw-r--r--  2.0 unx      110 b- defN 23-Nov-09 17:09 snuba_sdk-2.0.8.dist-info/WHEEL
--rw-r--r--  2.0 unx       19 b- defN 23-Nov-09 17:09 snuba_sdk-2.0.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2467 b- defN 23-Nov-09 17:09 snuba_sdk-2.0.8.dist-info/RECORD
-31 files, 137896 bytes uncompressed, 37416 bytes compressed:  72.9%
+Zip file size: 42588 bytes, number of entries: 31
+-rw-r--r--  2.0 unx        0 b- defN 23-Nov-10 19:39 examples/__init__.py
+-rw-r--r--  2.0 unx     1305 b- defN 23-Nov-10 19:39 snuba_sdk/__init__.py
+-rw-r--r--  2.0 unx     1552 b- defN 23-Nov-10 19:39 snuba_sdk/aliased_expression.py
+-rw-r--r--  2.0 unx     2645 b- defN 23-Nov-10 19:39 snuba_sdk/column.py
+-rw-r--r--  2.0 unx     4464 b- defN 23-Nov-10 19:39 snuba_sdk/conditions.py
+-rw-r--r--  2.0 unx     2269 b- defN 23-Nov-10 19:39 snuba_sdk/entity.py
+-rw-r--r--  2.0 unx     3086 b- defN 23-Nov-10 19:39 snuba_sdk/expressions.py
+-rw-r--r--  2.0 unx     3896 b- defN 23-Nov-10 19:39 snuba_sdk/formula.py
+-rw-r--r--  2.0 unx     5080 b- defN 23-Nov-10 19:39 snuba_sdk/function.py
+-rw-r--r--  2.0 unx    11219 b- defN 23-Nov-10 19:39 snuba_sdk/legacy.py
+-rw-r--r--  2.0 unx     3271 b- defN 23-Nov-10 19:39 snuba_sdk/metrics_query.py
+-rw-r--r--  2.0 unx    10102 b- defN 23-Nov-10 19:39 snuba_sdk/metrics_query_visitors.py
+-rw-r--r--  2.0 unx    12646 b- defN 23-Nov-10 19:39 snuba_sdk/metrics_visitors.py
+-rw-r--r--  2.0 unx     1901 b- defN 23-Nov-10 19:39 snuba_sdk/orderby.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Nov-10 19:39 snuba_sdk/py.typed
+-rw-r--r--  2.0 unx     6630 b- defN 23-Nov-10 19:39 snuba_sdk/query.py
+-rw-r--r--  2.0 unx     7931 b- defN 23-Nov-10 19:39 snuba_sdk/query_validation.py
+-rw-r--r--  2.0 unx    12231 b- defN 23-Nov-10 19:39 snuba_sdk/query_visitors.py
+-rw-r--r--  2.0 unx     3401 b- defN 23-Nov-10 19:39 snuba_sdk/relationships.py
+-rw-r--r--  2.0 unx     2862 b- defN 23-Nov-10 19:39 snuba_sdk/request.py
+-rw-r--r--  2.0 unx     1487 b- defN 23-Nov-10 19:39 snuba_sdk/schema.py
+-rw-r--r--  2.0 unx     2668 b- defN 23-Nov-10 19:39 snuba_sdk/snuba.py
+-rw-r--r--  2.0 unx    10401 b- defN 23-Nov-10 19:39 snuba_sdk/timeseries.py
+-rw-r--r--  2.0 unx    13451 b- defN 23-Nov-10 19:39 snuba_sdk/visitors.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Nov-10 19:39 snuba_sdk/dsl/__init__.py
+-rw-r--r--  2.0 unx    11167 b- defN 23-Nov-10 19:39 snuba_sdk/dsl/dsl.py
+-rw-r--r--  2.0 unx     1095 b- defN 23-Nov-10 19:39 snuba_sdk-2.0.9.dist-info/LICENSE
+-rw-r--r--  2.0 unx     4708 b- defN 23-Nov-10 19:39 snuba_sdk-2.0.9.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 23-Nov-10 19:39 snuba_sdk-2.0.9.dist-info/WHEEL
+-rw-r--r--  2.0 unx       19 b- defN 23-Nov-10 19:39 snuba_sdk-2.0.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2468 b- defN 23-Nov-10 19:39 snuba_sdk-2.0.9.dist-info/RECORD
+31 files, 144065 bytes uncompressed, 38690 bytes compressed:  73.1%
```

## zipnote {}

```diff
@@ -72,23 +72,23 @@
 
 Filename: snuba_sdk/dsl/__init__.py
 Comment: 
 
 Filename: snuba_sdk/dsl/dsl.py
 Comment: 
 
-Filename: snuba_sdk-2.0.8.dist-info/LICENSE
+Filename: snuba_sdk-2.0.9.dist-info/LICENSE
 Comment: 
 
-Filename: snuba_sdk-2.0.8.dist-info/METADATA
+Filename: snuba_sdk-2.0.9.dist-info/METADATA
 Comment: 
 
-Filename: snuba_sdk-2.0.8.dist-info/WHEEL
+Filename: snuba_sdk-2.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: snuba_sdk-2.0.8.dist-info/top_level.txt
+Filename: snuba_sdk-2.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: snuba_sdk-2.0.8.dist-info/RECORD
+Filename: snuba_sdk-2.0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## snuba_sdk/__init__.py

```diff
@@ -3,33 +3,36 @@
 """
 
 from snuba_sdk.aliased_expression import AliasedExpression
 from snuba_sdk.column import Column
 from snuba_sdk.conditions import And, BooleanCondition, BooleanOp, Condition, Op, Or
 from snuba_sdk.entity import Entity
 from snuba_sdk.expressions import Granularity, Limit, Offset, Totals
+from snuba_sdk.formula import ArithmeticOperator, Formula
 from snuba_sdk.function import CurriedFunction, Function, Identifier, Lambda
 from snuba_sdk.metrics_query import MetricsQuery
 from snuba_sdk.orderby import Direction, LimitBy, OrderBy
 from snuba_sdk.query import Query
 from snuba_sdk.relationships import Join, Relationship
 from snuba_sdk.request import Flags, Request
 from snuba_sdk.timeseries import Metric, MetricsScope, Rollup, Timeseries
 
 __all__ = [
     "AliasedExpression",
     "And",
+    "ArithmeticOperator",
     "BooleanCondition",
     "BooleanOp",
     "Column",
     "Condition",
     "CurriedFunction",
     "Direction",
     "Entity",
     "Flags",
+    "Formula",
     "Function",
     "Granularity",
     "Identifier",
     "Join",
     "Lambda",
     "Limit",
     "LimitBy",
```

## snuba_sdk/formula.py

```diff
@@ -39,30 +39,54 @@
                 f"formula '{self.operator}' must be a ArithmeticOperator"
             )
         if self.parameters is not None:
             if not isinstance(self.parameters, Sequence):
                 raise InvalidFormulaError(
                     f"parameters of formula {self.operator.value} must be a Sequence"
                 )
+
+            # - Must have the same entities, and must have an entity (no formulas on just literals)
+            # - Must have the same groupbys
+            entity = None
+            groupby = None
             for param in self.parameters:
-                if not isinstance(param, (Formula, Timeseries, float, int)):
+                if not isinstance(param, (Timeseries, float, int)):
                     raise InvalidFormulaError(
                         f"parameter '{param}' of formula {self.operator.value} is an invalid type"
                     )
 
+                if isinstance(param, Timeseries):
+                    if entity is None:
+                        entity = param.metric.entity
+                    elif entity != param.metric.entity:
+                        raise InvalidFormulaError(
+                            "Formulas can only operate on a single entity"
+                        )
+
+                    to_check = set(param.groupby) if param.groupby is not None else None
+                    if groupby is None:
+                        groupby = to_check
+                    elif groupby != to_check:
+                        raise InvalidFormulaError(
+                            "Formula parameters must group by the same columns"
+                        )
+
+            if not entity:
+                raise InvalidFormulaError("Formulas must have an an entity")
+
     def _replace(self, field: str, value: Any) -> Formula:
         new = replace(self, **{field: value})
         return new
 
     def set_parameters(self, parameters: Sequence[FormulaParameterGroup]) -> Formula:
         if parameters is not None and not list_type(
             parameters, (Formula, Timeseries, float, int)
         ):
             raise InvalidFormulaError(
-                "parameters must be a list of either Formulas, Timeseries, floats, or ints"
+                "parameters must be a list of either Timeseries, floats, or ints"
             )
         return self._replace("parameters", parameters)
 
     def set_filters(self, filters: ConditionGroup | None) -> Formula:
         if filters is not None and not list_type(
             filters, (BooleanCondition, Condition)
         ):
@@ -71,8 +95,8 @@
 
     def set_groupby(self, groupby: list[Column | AliasedExpression] | None) -> Formula:
         if groupby is not None and not list_type(groupby, (Column, AliasedExpression)):
             raise InvalidFormulaError("groupby must be a list of Columns")
         return self._replace("groupby", groupby)
 
 
-FormulaParameterGroup = Union[Formula, Timeseries, float, int]
+FormulaParameterGroup = Union[Timeseries, float, int]
```

## snuba_sdk/metrics_query_visitors.py

```diff
@@ -8,14 +8,15 @@
 # https://github.com/agronholm/sphinx-autodoc-typehints#dealing-with-circular-imports
 from snuba_sdk import metrics_query as main
 from snuba_sdk.column import Column
 from snuba_sdk.conditions import Condition, Op
 from snuba_sdk.expressions import Limit, Offset
 from snuba_sdk.formula import Formula
 from snuba_sdk.metrics_visitors import (
+    FormulaSnQLVisitor,
     RollupSnQLPrinter,
     ScopeSnQLPrinter,
     TimeseriesSnQLPrinter,
 )
 from snuba_sdk.timeseries import MetricsScope, Rollup, Timeseries
 from snuba_sdk.visitors import Translation
 
@@ -75,33 +76,34 @@
 class SnQLPrinter(MetricsQueryVisitor[str]):
     def __init__(self, pretty: bool = False) -> None:
         self.pretty = pretty
         self.expression_visitor = Translation()
         self.timeseries_visitor = TimeseriesSnQLPrinter(self.expression_visitor)
         self.rollup_visitor = RollupSnQLPrinter(self.expression_visitor)
         self.scope_visitor = ScopeSnQLPrinter(self.expression_visitor)
+        self.formula_visitor = FormulaSnQLVisitor()
         self.separator = "\n" if self.pretty else " "
         self.match_clause = "MATCH ({entity})"
         self.select_clause = "SELECT {select_columns}"
         self.groupby_clause = "BY {groupby_columns}"
         self.where_clause = "WHERE {where_clauses}"
         self.orderby_clause = "ORDER BY {orderby_columns}"
         self.limit_clause = "LIMIT {limit}"
         self.offset_clause = "OFFSET {offset}"
 
     def _combine(
         self, query: main.MetricsQuery, returns: Mapping[str, str | Mapping[str, str]]
     ) -> str:
-        timeseries_data = returns["query"]
-        assert isinstance(timeseries_data, dict)
+        query_data = returns["query"]
+        assert isinstance(query_data, dict)
 
-        entity = timeseries_data["entity"]
+        entity = query_data["entity"]
 
         select_columns = []
-        select_columns.append(timeseries_data["aggregate"])
+        select_columns.append(query_data["aggregate"])
 
         rollup_data = returns["rollup"]
         assert isinstance(rollup_data, dict)
 
         groupby_columns = []
         orderby_columns = []
         where_clauses = []
@@ -113,20 +115,21 @@
         # rollup itself and we don't use interval data.
         if rollup_data["interval"]:
             groupby_columns.append(rollup_data["interval"])
         if rollup_data["orderby"]:
             orderby_columns.append(rollup_data["orderby"])
         where_clauses.append(rollup_data["filter"])
 
-        if timeseries_data["groupby"]:
-            groupby_columns.append(timeseries_data["groupby"])
+        if query_data["groupby"]:
+            groupby_columns.append(query_data["groupby"])
 
-        where_clauses.append(timeseries_data["metric_filter"])
-        if timeseries_data["filters"]:
-            where_clauses.append(timeseries_data["filters"])
+        if "metric_filter" in query_data:
+            where_clauses.append(query_data["metric_filter"])
+        if "filters" in query_data and query_data["filters"]:
+            where_clauses.append(query_data["filters"])
 
         where_clauses.append(returns["scope"])
         where_clauses.append(returns["start"])
         where_clauses.append(returns["end"])
 
         groupby_clause = (
             self.groupby_clause.format(groupby_columns=", ".join(groupby_columns))
@@ -164,17 +167,16 @@
 
         return self.separator.join(filter(lambda x: x != "", clauses)).strip()
 
     def _visit_query(self, query: Timeseries | Formula | None) -> Mapping[str, str]:
         if query is None:
             raise InvalidMetricsQueryError("MetricQuery.query must not be None")
         if isinstance(query, Formula):
-            raise InvalidMetricsQueryError(
-                "Serializing a Formula in MetricQuery.query is unsupported"
-            )
+            return self.formula_visitor.visit(query)
+
         return self.timeseries_visitor.visit(query)
 
     def _visit_start(self, start: datetime | None) -> str:
         if start is None:
             raise InvalidMetricsQueryError("MetricQuery.start must not be None")
 
         condition = Condition(Column("timestamp"), Op.GTE, start)
```

## snuba_sdk/metrics_visitors.py

```diff
@@ -1,15 +1,22 @@
 from __future__ import annotations
 
 from abc import ABC, abstractmethod
 from typing import Any, Generic, Mapping, TypeVar
 
 from snuba_sdk.column import Column
-from snuba_sdk.conditions import And, Condition, ConditionGroup, Op
+from snuba_sdk.conditions import (
+    OPERATOR_TO_FUNCTION,
+    And,
+    Condition,
+    ConditionGroup,
+    Op,
+)
 from snuba_sdk.expressions import InvalidExpressionError, Totals
+from snuba_sdk.formula import Formula
 from snuba_sdk.function import CurriedFunction, Function
 from snuba_sdk.orderby import Direction, OrderBy
 from snuba_sdk.timeseries import Metric, MetricsScope, Rollup, Timeseries
 from snuba_sdk.visitors import Translation
 
 TVisited = TypeVar("TVisited")
 
@@ -225,7 +232,145 @@
                     Op.EQ,
                     scope.use_case_id,
                 ),
             ]
         )
 
         return self.translator.visit(condition)
+
+
+# Normally this would be a visitor class, but this is itself a hack to get derived metrics off the ground
+# This can be better codified when we write a visitor that converts Formulas to MQL.
+class FormulaSnQLVisitor:
+    def __init__(
+        self, timeseries_visitor: TimeseriesFormulaSnQLPrinter | None = None
+    ) -> None:
+        self.timeseries_visitor = timeseries_visitor or TimeseriesFormulaSnQLPrinter()
+        self.expression_visitor = self.timeseries_visitor.expression_visitor
+
+    def _visit_parameter(
+        self, side: Timeseries | int | float, filters: ConditionGroup | None
+    ) -> Mapping[str, str]:
+        if isinstance(side, (float, int)):
+            return {"select": f"{side}"}
+        assert isinstance(
+            side, Timeseries
+        )  # This is guaranteed by the Formula validator
+
+        if filters:
+            if side.filters is not None:
+                side = side.set_filters(
+                    [*side.filters, *filters]
+                )  # Push formula filters down into timeseries
+            else:
+                side = side.set_filters(filters)
+
+        tdata = self.timeseries_visitor.visit(side)
+        ret = {
+            "entity": str(tdata["entity"]),
+            "groupby": str(tdata["groupby"]),
+            "select": str(tdata["aggregate"]),
+        }
+
+        return ret
+
+    def visit(self, formula: Formula) -> Mapping[str, str]:
+        parameters = []
+        if formula.parameters is not None:
+            parameters = [
+                self._visit_parameter(p, formula.filters) for p in formula.parameters
+            ]
+
+        entity = None
+        for p in parameters:
+            if isinstance(p, dict):
+                if "entity" in p:
+                    if entity is None:
+                        entity = p["entity"]
+                    elif entity != p["entity"]:
+                        raise InvalidExpressionError(
+                            "Formulas can only operate on a single entity"
+                        )
+        assert entity is not None  # This is guaranteed by the Formula validator
+        ret = {"entity": entity}
+
+        # collect all the group bys
+        groupbys = []
+        if formula.groupby:
+            for g in formula.groupby:
+                groupbys.append(self.expression_visitor.visit(g))
+
+        for p in parameters:
+            if isinstance(p, dict) and "groupby" in p:
+                groupbys.append(p["groupby"])
+                break  # The validator guarantees all the groupbys are equal, so we only need one
+
+        ret["groupby"] = ", ".join([g for g in groupbys if g != ""])
+
+        # Collect select statements
+        parameters = ", ".join(p["select"] for p in parameters)
+        ret[
+            "aggregate"
+        ] = f"{formula.operator.value}({parameters}) AS {AGGREGATE_ALIAS}"
+
+        return ret
+
+
+class TimeseriesFormulaSnQLPrinter(TimeseriesVisitor[str]):
+    def __init__(
+        self,
+        expression_visitor: Translation | None = None,
+        metrics_visitor: MetricSnQLPrinter | None = None,
+    ) -> None:
+        self.expression_visitor = expression_visitor or Translation()
+        self.metrics_visitor = metrics_visitor or MetricSnQLPrinter(expression_visitor)
+
+    def _combine(
+        self,
+        timeseries: Timeseries,
+        returns: Mapping[str, str | Mapping[str, str]],
+    ) -> Mapping[str, str]:
+        metric_data = self.metrics_visitor.visit(timeseries.metric)
+        assert isinstance(metric_data, Mapping)  # mypy
+
+        ret = {
+            "entity": metric_data["entity"],
+        }
+
+        metric_filter = Function("equals", [Column("metric_id"), timeseries.metric.id])
+
+        # In Formulas, the filters need to be built into the aggregate as infix functions
+        filters = []
+        if timeseries.filters:
+            for cond in timeseries.filters:
+                assert isinstance(cond.op, Op)  # BooleanOp is not a valid function
+                op = OPERATOR_TO_FUNCTION[cond.op]
+                filters.append(Function(op.value, [cond.lhs, cond.rhs]))
+
+        and_filters = Function("and", [metric_filter, *filters])
+        aggregate = CurriedFunction(
+            f"{timeseries.aggregate}If",
+            timeseries.aggregate_params,
+            [Column("value"), and_filters],
+        )
+        ret["aggregate"] = self.expression_visitor.visit(aggregate)
+
+        if returns["groupby"] is not None:
+            ret["groupby"] = str(returns["groupby"])
+
+        return ret
+
+    def _visit_metric(self, metric: Metric) -> Mapping[str, str]:
+        return {}
+
+    def _visit_aggregate(
+        self, aggregate: str, aggregate_params: list[Any] | None
+    ) -> str:
+        return ""
+
+    def _visit_filters(self, filters: ConditionGroup | None) -> str:
+        return ""
+
+    def _visit_groupby(self, groupby: list[Column] | None) -> str:
+        if groupby is not None:
+            return ", ".join(self.expression_visitor.visit(c) for c in groupby)
+        return ""
```

## snuba_sdk/dsl/dsl.py

```diff
@@ -134,15 +134,15 @@
         self, node: Node, children: Sequence[Any]
     ) -> Union[Formula, Timeseries, float, int]:
         """
         Checks if the current node contains two term children, if so
         then merge them into a single Formula with the operator.
         """
         term, zero_or_more_others = children
-        assert isinstance(term, (Formula, Timeseries, float, int))
+        assert isinstance(term, (Timeseries, float, int))
         if zero_or_more_others:
             _, term_operator, _, coefficient, *_ = zero_or_more_others[0]
             return Formula(term_operator, [term, coefficient])
         return term
 
     def visit_term_op(self, node: Node, children: Sequence[Any]) -> Any:
         # raise InvalidQueryError("Arithmetic function not supported yet")
```

## Comparing `snuba_sdk-2.0.8.dist-info/LICENSE` & `snuba_sdk-2.0.9.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `snuba_sdk-2.0.8.dist-info/METADATA` & `snuba_sdk-2.0.9.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: snuba-sdk
-Version: 2.0.8
+Version: 2.0.9
 Summary: Snuba SDK for generating SnQL queries.
 Home-page: https://github.com/getsentry/snuba-sdk
 Author: Sentry
 Author-email: oss@sentry.io
 License: MIT
 Project-URL: Changelog, https://github.com/getsentry/snuba-sdk/blob/main/CHANGES.rst
 Platform: UNKNOWN
```

